/**
 *  @file
 *
 *  @brief      MasterCommander Driver hardware dependent stuff for KXX
 *
 *
 *  $Header: $
 *
 *  @copyright  Copyright 2016-$Date$. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
 */

#ifndef __MC_HAL_KXX_H
#define __MC_HAL_KXX_H

#include "master_commander.h"
#include "Uart.h"

/******************************************************************************
 * Supress warnings generated by IAR EWBARM compiler
 ******************************************************************************/
//#pragma diag_suppress=Pe174
//#pragma diag_suppress=Pe177
//#pragma diag_suppress=Pe174
//#pragma diag_suppress=Pe550

/******************************************************************************
 * platform-specific default configuration
 ******************************************************************************/

/* use 32-bit (EX) commands by default */
#ifndef MC_USE_EX_CMDS
#define MC_USE_EX_CMDS 1
#endif

/* do not use 16-bit (no-EX) commands by default */
#ifndef MC_USE_NOEX_CMDS
#define MC_USE_NOEX_CMDS 0
#endif

/* at least one of EX or no-EX command handling must be enabled */
#if !MC_USE_EX_CMDS && !MC_USE_NOEX_CMDS
    //#error At least one of EX or no-EX command handling must be enabled (please set MC_USE_EX_CMDS)
    #undef  MC_USE_EX_CMDS
    #define MC_USE_EX_CMDS 1
#endif

/*****************************************************************************
* Board configuration information 
******************************************************************************/

#define MC_PROT_VER           3      /* protocol version 3 */
#define MC_CFG_FLAGS          0      /* board info flags */
#define MC_CFG_BUS_WIDTH      1      /* data bus width */
#define MC_GLOB_VERSION_MAJOR 2      /* driver version */
#define MC_GLOB_VERSION_MINOR 0
#define MC_IDT_STRING "Kxx MasterCommander Driver"
#define MC_TSA_FLAGS          0

/******************************************************************************
* platform-specific types
******************************************************************************/

typedef unsigned char  MC_U8;         /* smallest memory entity */
typedef unsigned short MC_U16;        /* 16bit value */
typedef unsigned long  MC_U32;        /* 32bit value */

typedef signed char    MC_S8;         /* signed 8bit value */
typedef signed short   MC_S16;        /* signed 16bit value */
typedef signed long    MC_S32;        /* signed 32bit value */

#if MC_REC_FLOAT_TRIG
typedef float          MC_FLOAT;        /* float value */
#endif

typedef unsigned char  MC_FLAGS;      /* type to be union-ed with flags (at least 8 bits) */
typedef unsigned char  MC_SIZE8;      /* one-byte size value */
typedef signed short   MC_INDEX;      /* general for-loop index (must be signed) */

typedef unsigned char  MC_BCHR;       /* type of a single character in comm.buffer */
typedef unsigned char* MC_BPTR;       /* pointer within a communication buffer */

typedef unsigned char  MC_SCISR;      /* data type to store SCI status register */

/******************************************************************************
* communication buffer access functions
******************************************************************************/

/* mixed EX and non-EX commands may occur */
#if MC_USE_EX_CMDS && MC_USE_NOEX_CMDS || (MC_BUFFER_ACCESS_BY_FUNCT)
void MC_SetExAddr(MC_BOOL bNextAddrIsEx);
#else
/* otherwise, we always know what addresses are used, (ignore MC_SetExAddr) */
#define MC_SetExAddr(bNextAddrIsEx)
#endif

#if MC_REC_FLOAT_TRIG
#define MC_GetFloat(addr) ( *(MC_FLOAT*)(addr) )
#endif

/****************************************************************************************
* Other helper macros
*****************************************************************************************/

/* This macro assigns C pointer to MC_ADDR-typed variable */
#define MC_PTR2ADDR(tmpAddr,ptr) ( tmpAddr = (MC_ADDR) (MC_U8*) ptr )
#define MC_ARR2ADDR MC_PTR2ADDR

/****************************************************************************************
* Platform-specific configuration
*****************************************************************************************/

/* FlexCAN functionality tested on KXX */
#define MC_CANHW_FLEXCAN 1 

/****************************************************************************************
* General peripheral space access macros
*****************************************************************************************/

#define MC_SETREG8(base, offset, value)    (*(volatile MC_U8*)(((MC_U32)(base))+(offset)) = value)
#define MC_GETREG8(base, offset)           (*(volatile MC_U8*)(((MC_U32)(base))+(offset)))
#define MC_SETBIT8(base, offset, bit)      (*(volatile MC_U8*)(((MC_U32)(base))+(offset)) |= bit)
#define MC_CLRBIT8(base, offset, bit)      (*(volatile MC_U8*)(((MC_U32)(base))+(offset)) &= (MC_U16)~((MC_U16)(bit)))
#define MC_SETREG16(base, offset, value)   (*(volatile MC_U16*)(((MC_U32)(base))+(offset)) = value)
#define MC_GETREG16(base, offset)          (*(volatile MC_U16*)(((MC_U32)(base))+(offset)))
#define MC_SETBIT16(base, offset, bit)     (*(volatile MC_U16*)(((MC_U32)(base))+(offset)) |= bit)
#define MC_CLRBIT16(base, offset, bit)     (*(volatile MC_U16*)(((MC_U32)(base))+(offset)) &= (MC_U16)~((MC_U16)(bit)))
#define MC_TSTBIT16(base, offset, bit)     (*(volatile MC_U16*)(((MC_U32)(base))+(offset)) & (bit))
#define MC_SETREG32(base, offset, value)   (*(volatile MC_U32*)(((MC_U32)(base))+(offset)) = value)
#define MC_GETREG32(base, offset)          (*(volatile MC_U32*)(((MC_U32)(base))+(offset)))
#define MC_SETBIT32(base, offset, bit)     ((*(volatile MC_U32*)(((MC_U32)(base))+(offset))) |= bit)
#define MC_CLRBIT32(base, offset, bit)     ((*(volatile MC_U32*)(((MC_U32)(base))+(offset))) &= ~(bit))
#define MC_TSTBIT32(base, offset, bit)     (*(volatile MC_U32*)(((MC_U32)(base))+(offset)) & (bit))


/*******************************************************************************************
* SCI access macros
*****************************************************************************************/

/* transmitter enable/disable */
#define MC_SCI_TE() Uart__Enable(MASTERCOMMANDER_COMPORT,UART_OPTION_TX_EN)
#define MC_SCI_TD() Uart__Disable(MASTERCOMMANDER_COMPORT,UART_OPTION_TX_EN)

/* receiver enable/disable */
#define MC_SCI_RE() Uart__Enable(MASTERCOMMANDER_COMPORT,UART_OPTION_RX_EN)
#define MC_SCI_RD() Uart__Disable(MASTERCOMMANDER_COMPORT,UART_OPTION_RX_EN)

//#define MC_SCI_TE_RE() MC_SETBIT8(MC_SCI_BASE, MC_SCIC2_OFFSET, MC_SCIC2_RE | MC_SCIC2_TE)

/* Transmitter-empty interrupt enable/disable */
#define MC_SCI_ETXI() Uart__Enable(MASTERCOMMANDER_COMPORT,UART_OPTION_TX_EN)
#define MC_SCI_DTXI() Uart__Disable(MASTERCOMMANDER_COMPORT,UART_OPTION_TX_EN)

/* Receiver-full interrupt enable/disable */
#define MC_SCI_ERXI() Uart__Enable(MASTERCOMMANDER_COMPORT,UART_ENABLE_OPTIONS_DEF)
#define MC_SCI_DRXI() Uart__Disable(MASTERCOMMANDER_COMPORT,UART_ENABLE_OPTIONS_DEF)

/* Tranmsit character */
#define MC_SCI_PUTCHAR(ch) Uart__WriteByte(MASTERCOMMANDER_COMPORT, ch)

/* Get received character */
#define MC_SCI_GETCHAR() Uart__ReadByte(MASTERCOMMANDER_COMPORT)

/* read status register */
#define MC_SCI_GETSR()   Uart__GetStatus(MASTERCOMMANDER_COMPORT, UART_STATUS_TX_AVAILABLE)

/* read & clear status register */
#define MC_SCI_RDCLRSR() Uart__GetStatus(MASTERCOMMANDER_COMPORT, UART_STATUS_DEF)

#endif /* __MC_HAL_KXX_H */

