/**
 *  @file
 *
 *  @brief   Extraction parameters
 *
 *
 *  @copyright  Copyright 2017  $  Whirlpool Corporation.  All rights reserved - CONFIDENTIAL.
 */

// -- This Module --
#include "C_Extensions.h"
#include "ExtractionParams.h"
#include "ExtractionEmbeddedParams.h"

// -- Other Modules --
#include "API007App.h"
#include "Log.h"
#include "SettingFile.h"
#include <string.h>
#include <limits.h>

//=====================================================================================================================
//-------------------------------------- PUBLIC (Extern Variables, Constants & Defines) -------------------------------
//=====================================================================================================================
//! The name of this module for use by the Log module.
#define MODULE_NAME MODULE_EXTR_PARAMS

//! A list of log message IDs that are generated by this module.
typedef enum MODULE_EXTR_PARAMS_LOG_MESSAGE_ID_ENUM
{
    SETTING_FILE_PARAMS_ERROR = 1,
	API007_PARAMS_ERROR
} MODULE_EXTR_PARAMS_LOG_MESSAGE_ID_TYPE;

//! Setup pointers are dereferenced by the Extraction generated code as external pointers.
const EXTRACTION_SETUP_TYPE *GESE_Extr_Setup;
const CLEAN_WASHER_SETUP_TYPE *GESE_Extr_CleanWasherSetup;

//! Low Speed Extraction setup
const MASS_CONVERSION_COEFFS_TYPE *GESE_Extr_MassConvCoeffs;
const UB_CONVERSION_COEFFS_TYPE *GESE_Extr_UnbConvCoeffs;
const FDR_SETUP_TYPE *GESE_Extr_FastDistRampSetup;
const OPT_RAMP_SETUP_TYPE *GESE_Extr_OptRampSetup;
const MDDP_SETUP_TYPE *GESE_Extr_MddpSetup;
const P2P_TORQUE_SETUP_TYPE *GESE_Extr_P2PTorqueSetup;
const SATELLIZATION_SETUP_TYPE *GESE_Extr_SatellizationSetup;
const DISTRIBUTION_PULSE_TYPE *GESE_Extr_DistProf;
uint8 GESE_Extr_DistProfPulseCnt;
const PARAM_EST_SETUP_INDEX_TYPE *GESE_Extr_ParamEstLowSpeedSetup;
DIGITAL_FILTER_SOS_TYPE GESE_Extr_HighPassFilterSetup[2];
const uint8 *GESE_Extr_RebalAttemptsArray;
const uint8 *GESE_Extr_TargetSpeedArray_Div10;
uint8 GESE_Extr_ExtUnbTargetCount;
const REBALANCE_TABLE_TYPE *GESE_Extr_RebalTable;
uint8 GESE_Extr_RebalTableCount;
BALANCE_INDEX_CONVERSION_TABLE_TYPE GESE_Extr_BalanceIndexConversionLut;

//! PRE_LOOKUP data to be used by Low Speed Extraction as external variables.
PRE_LOOKUP_TYPE_UINT16 GESE_Extr_FastDistRampTargetSpeed_BP;
PRE_LOOKUP_TYPE_UINT16 GESE_Extr_MddpLoadMassX10_BP;
PRE_LOOKUP_TYPE_UINT16 GESE_Extr_OptRampLoadMassX100_BP;
PRE_LOOKUP_TYPE_UINT16 GESE_Extr_P2PTorqueLoadMassX10_BP;
PRE_LOOKUP_TYPE_UINT8 GESE_Extr_RebalAttempts_BP;
PRE_LOOKUP_TYPE_UINT8 GESE_Extr_TargetSpeedDiv10_BP;
PRE_LOOKUP_TYPE_UINT16 GESE_Extr_WaterTemp_BP;

//! LUT data to be used by Low Speed Extraction as external pointers.
const uint8 *GESE_Extr_MddpDuration_LUT;
const uint8 *GESE_Extr_MddpRamp_LUT;
const uint16 *GESE_Extr_MddpSpeed_LUT;
const uint8 *GESE_Extr_OptRampConvTime_LUT;
const uint16 *GESE_Extr_OptRampPhaseTolerance_LUT;
const uint16 *GESE_Extr_OptRampPhsAdvTgt_LUT;
const uint8 *GESE_Extr_OptRampPlateauTime_LUT;
const uint16 *GESE_Extr_OptRampUnbBeforeMDDP_LUT;
const uint16 *GESE_Extr_OptRampUnbAfterMDDP_LUT;
const sint16 *GESE_Extr_OptRampLowerOffsetBeforeMDDP_LUT;
const sint16 *GESE_Extr_OptRampLowerOffsetAfterMDDP_LUT;
const sint16 *GESE_Extr_OptRampUpperOffsetBeforeMDDP_LUT;
const sint16 *GESE_Extr_OptRampUpperOffsetAfterMDDP_LUT;
const uint16 *GESE_Extr_P2PTorqueX100_LUT;

uint8_T GESE_Extr_OptRampUnbLut_Size[2];

//! High Speed Extraction setup
#if (EXTR_FEATURE_HIGH_SPEED_PE_ENABLED != 0)
const HIGH_SPEED_CONFIG_TYPE *GESE_Extr_HighSpdConfig;
const BASELINE_FACTORY_CALIBRATION_SETUP_TYPE *GESE_Extr_BaselineFactoryCalibrationSetup;
const CEM_SETUP_TYPE *GESE_Extr_CEMSetup;

//! LUT data to be used by High Speed Extraction as external variables.
PRE_LOOKUP_TYPE_UINT8 GESE_Extr_BaselineFrictionRefSpeed_BP;
PRE_LOOKUP_TYPE_UINT8 GESE_Extr_BaselineFrictionRefSpeed_Sig;
const uint16 *GESE_Extr_BaselineDefaultFrictionArray_x1000;
const uint8 *GESE_Extr_FactoryFrictionSelIndexArray;
const uint16 *GESE_Extr_FactoryCalScalingFactorArray;
#endif //(EXTR_FEATURE_HIGH_SPEED_PE_ENABLED != 0)
const EXT_UNB_CHK_SETUP_TYPE *GESE_Extr_ExtUnbSetup;
const SPIN_PULSE_TYPE *GESE_Extr_SpinPulses;
const SPIN_PROFILE_TYPE *GESE_Extr_SpinProfileConfig;
const HIGH_SPEED_UNB_SETUP_TYPE *GESE_Extr_HighSpdUnbConfig;
const EXT_UNB_CHK_TARGET_TYPE *GESE_Extr_ExtUnbTargetSet;

//! Accelerometer related setup structs
#if (EXTR_FEATURE_ACCEL_ENABLED != 0)
const FLOOR_DISPLACEMENT_SETUP_TYPE *GESE_Extr_FloorDispSetup;
const VIB_MAP_FLOOR_DISPL_THRESHOLD_TYPE *GESE_Extr_VibMapFDThreshold;
const VIBRATION_MAPPING_SETUP_TYPE *GESE_Extr_VibMapSetup;
const CABINET_HIT_SETUP_TYPE *GESE_Extr_CabHitSetup;

//! Vibration Mapping reference speed array
PRE_LOOKUP_TYPE_UINT8 GESE_Extr_VibMapRefSpeedArray_div10;
#endif //(EXTR_FEATURE_ACCEL_ENABLED != 0)

//-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------

#define EXTR_SPIN_PULSES_OFFSET			8
#define ACCEL_FILTER_MAX_NUM_SECTIONS	4
#define ACCEL_AXES_COUNT				3

//! Friction baseline factory calibration values
static uint16 Extr_Baseline_Factory_x1000[BASELINE_ARRAY_MAX_SIZE];

//! Friction baseline lifetime values
static uint16 Extr_Baseline_Lifetime_x1000[BASELINE_ARRAY_MAX_SIZE];

//! Vibration Mapping reference displacement array
static uint16 Extr_Vib_Map_Ref_Disp_x100[VIB_MAP_REF_ARRAY_MAX_SIZE];

#if (EXTR_FEATURE_ACCEL_ENABLED != 0)
//! Accelerometer filter setup
static DIGITAL_FILTER_SOS_TYPE Extr_Accel_Filter;
static DIGITAL_FILTER_SOS_TYPE Extr_Vib_Map_Filter;
static DIGITAL_FILTER_SOS_TYPE Extr_Cab_Hit_Filter;

//! Accelerometer filter states
static BIQUAD_STATE_TYPE Accel_Filter_Storage[ACCEL_AXES_COUNT][ACCEL_FILTER_MAX_NUM_SECTIONS];
static BIQUAD_STATE_TYPE Vib_Map_Filter_Storage[ACCEL_AXES_COUNT][ACCEL_FILTER_MAX_NUM_SECTIONS];
static BIQUAD_STATE_TYPE Cab_Hit_Filter_Storage[ACCEL_AXES_COUNT][ACCEL_FILTER_MAX_NUM_SECTIONS];
#endif

static float32 Extr_Accel_VibMapThrshCrossSpd;

//! Private Variable Definitions
static BOOL_TYPE Setting_File_Parameters_Error;
static BOOL_TYPE LMS_Flags;

// -- Private Structure Type Declarations --

typedef PACKED struct PARAM_EST_CONFIG_SET_STRUCT
{
    /* Parameter Estimation configuration index. */
    uint8_T Param_Est_Config_Index;

    /* Randomized Excitation configuration index. */
    uint8_T Param_Est_Exc_Config_Index;
} PARAM_EST_CONFIG_SET_TYPE;

#if (EXTRACTION_LOW_SPEED_PARAMETERS_IN_PLACE != 0)

//! Optimum Ramp Unbalance Table structure
typedef PACKED struct OPTIMUM_RAMP_UNBALANCE_TABLE_STRUCT
{
	uint8 Limit_Load_Mass_Kg_Table;
	uint8 OR_To_MDDP_Lim_Offset_Up_g_Table;
	uint8 OR_To_MDDP_Lim_Offset_Low_g_Table;
	uint8 OR_To_SP_Lim_Offset_Up_g_Table;
	uint8 OR_To_SP_Lim_Offset_Low_g_Table;
	uint8 Rebalance_Level_Attempts_Table;
	uint8 Unbalance_Lev_Max_Velocity_Table;
	uint8 OR_To_MDDP_Unbalance_Level_Table;
	uint8 OR_To_SP_Unbalance_Level_Table;
	uint8 Padding;
} OPTIMUM_RAMP_UNBALANCE_TABLE_TYPE;

//! Rebalance Level Attempts Table structure
typedef PACKED struct REBALANCE_LEV_ATT_TABLE_STRUCT
{
	uint8 Num_Of_Values;
	uint8 Unused;
	uint8 First_Value;
} REBALANCE_LEV_ATT_TABLE_TYPE;

//! Rebalance Level Attempts Table structure
typedef PACKED struct UNBAL_LEV_MAX_VEL_TABLE_STRUCT
{
	uint8 Num_Of_Values;
	uint8 Unused;
	uint8 First_Value;
} UNBAL_LEV_MAX_VEL_TABLE_TYPE;

typedef PACKED struct DIGITAL_FILTER_STRUCT
{
	union
	{
		uint8 All;
		struct
		{
			uint8 Section_Number		:3;
			uint8 Unused				:5;
		} Bit;
	} Byte_0;

	uint8 Unused_Byte_1;
	uint8 Unused_Byte_2;
	uint8 Unused_Byte_3;

	float32 First_Filter_Coeff;
} DIGITAL_FILTER_TYPE;

#endif // (EXTRACTION_LOW_SPEED_PARAMETERS_IN_PLACE != 0)

#if (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE != 0)

//! Rebalance Level Attempts Table structure
typedef PACKED struct BASELINE_REF_VELOCITY_TABLE_STRUCT
{
	uint8 Num_Of_Values;
	uint8 Unused;
	uint8 First_Value;
} BASELINE_REF_VELOCITY_TABLE_TYPE;

#endif // (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE == 0)

#if (EXTRACTION_ACCEL_PARAMETERS_IN_PLACE != 0)
//! Sorted Spin Target Velocities Table structure
typedef PACKED struct SORTED_SPIN_TGT_VELOCITIES_STRUCT
{
	uint8 Num_Of_Values;
	uint8 Unused;
	uint8 First_Value;
} SORTED_SPIN_TGT_VELOCITIES_TYPE;
#endif // (EXTRACTION_ACCEL_PARAMETERS_IN_PLACE == 0)

#if (EXTRACTION_ATHLETE_PARAMETERS_IN_PLACE != 0)
typedef PACKED struct EXTENDED_UNBALANCE_TABLE_STRUCT
{
	EXT_UNB_CHK_SETUP_TYPE Setup;

	/* The first pair (Unbalance Extended Level) - (Unbalance Extended Level Target Velocity) in the table. */
	EXT_UNB_CHK_TARGET_TYPE First_Item;

} EXTENDED_UNBALANCE_TABLE_TYPE;
#endif // (EXTRACTION_ATHLETE_PARAMETERS_IN_PLACE != 0)

//-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------

static void InitializeEmbeddedParams(void);
static PASS_FAIL_TYPE InitializeGESEParams(uint8 extraction_set_index, uint8 vm_fd_threshold_config_index);
static PASS_FAIL_TYPE InitializeHighSpeedParameters(uint8 extraction_set_index);
static PASS_FAIL_TYPE InitializeAccelerometerParameters(uint8 vm_fd_threshold_config_index);
static PASS_FAIL_TYPE InitializeLowSpeedParameters(uint8 extraction_set_index);
static void ResetAccelFilters(void);

//=====================================================================================================================
//-------------------------------------- Public Functions -------------------------------------------------------------
//=====================================================================================================================

/**
 * Initialize extraction instance.
 * @param extraction_set_index = The setting file displacement for the selected extraction instance.
 * @param vm_fd_threshold_config_index = The setting file displacement for the selected Vib Map configuration.
 * @return PASS if all parameters have been loaded properly.
 */
PASS_FAIL_TYPE ExtractionParams__Initialize(uint8 extraction_set_index, uint8 vm_fd_threshold_config_index)
{
	PASS_FAIL_TYPE ret_value;

	ret_value = PASS;
	LMS_Flags = FALSE;
	Setting_File_Parameters_Error = FALSE;

	if (InitializeGESEParams(extraction_set_index, vm_fd_threshold_config_index) == FAIL)
	{
		LOG_ADD_EXCEPTION(SETTING_FILE_PARAMS_ERROR, 0);
		Setting_File_Parameters_Error = TRUE;
		ret_value = FAIL;
	}

	InitializeEmbeddedParams();

#if (EXTR_FEATURE_ACCEL_ENABLED == 1 || EXTR_FEATURE_HIGH_SPEED_PE_ENABLED == 1)
	if (API007App__AreAllDataReceived() == FALSE)
	{
		LOG_ADD_EXCEPTION(API007_PARAMS_ERROR, 0);
		ret_value = FAIL;
	}
#endif //(EXTR_FEATURE_ACCEL_ENABLED == 1 || EXTR_FEATURE_HIGH_SPEED_PE_ENABLED)

#if (EXTR_FEATURE_ACCEL_ENABLED == 1)
	ResetAccelFilters();
#endif //(EXTR_FEATURE_ACCEL_ENABLED == 1)

	return ret_value;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Check if the special load mass measurement cycle has been enabled.
 * @return TRUE if dry load mass measurement is enabled.
 */
BOOL_TYPE ExtractionParams__IsLMSEnabled(void)
{
	return (LMS_Flags);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @return Pointer to the baseline friction factory calibration array.
 */
uint8 *ExtractionParams__GetBaselineFrictionFactoryArray()
{
	return (uint8 *)(void*)Extr_Baseline_Factory_x1000;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Load the baseline friction factory calibration values.
 * @param array = Pointer to the first element in the array.
 * @param length = Array length.
 */
void ExtractionParams__SetBaselineFrictionFactoryArray(uint8 *array, uint8 length)
{
	if (length > sizeof(Extr_Baseline_Factory_x1000))
	{
		length = sizeof(Extr_Baseline_Factory_x1000);
	}

	memcpy(Extr_Baseline_Factory_x1000, array, length);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @return Pointer to the lifetime baseline friction array.
 */
uint8 *ExtractionParams__GetBaselineFrictionLifetimeArray()
{
	return (uint8 *)(void*)Extr_Baseline_Lifetime_x1000;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Load the lifetime baseline friction values.
 * @param array = Pointer to the first element in the array.
 * @param length = Array length.
 */
void ExtractionParams__SetBaselineFrictionLifetimeArray(uint8 *array, uint8 length)
{
	if (length > sizeof(Extr_Baseline_Lifetime_x1000))
	{
		length = sizeof(Extr_Baseline_Lifetime_x1000);
	}

	memcpy(Extr_Baseline_Lifetime_x1000, array, length);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @return Pointer to the reference floor displacement array.
 */
uint8 *ExtractionParams__GetFloorDisplacementRefArray()
{
	return (uint8*)(void*)Extr_Vib_Map_Ref_Disp_x100;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Load the reference floor displacement values.
 * @param array = Pointer to the first element in the array.
 * @param length = Array length.
 */
void ExtractionParams__SetFloorDisplacementRefArray(uint8 *array, uint8 length)
{
	if (length > sizeof(Extr_Vib_Map_Ref_Disp_x100))
	{
		length = sizeof(Extr_Vib_Map_Ref_Disp_x100);
	}

	memcpy(Extr_Vib_Map_Ref_Disp_x100, array, length);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @return The speed in which the vibration mapping threshold has been crossed.
 */
float32 ExtractionParams__GetVibMapThrshCrossSpd(void)
{
	return Extr_Accel_VibMapThrshCrossSpd;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Set the vibration mapping threshold crossing speed.
 * @param speed = The speed in which the vibration mapping threshold has been crossed.
 */
void ExtractionParams__SetVibMapThrshCrossSpd(float32 speed)
{
	Extr_Accel_VibMapThrshCrossSpd = speed;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Sets the setting file error flag to TRUE.
 */
void ExtractionParams__SetSettingFileError(void)
{
	Setting_File_Parameters_Error = TRUE;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Sets the setting file error flag to FALSE.
 */
void ExtractionParams__ResetSettingFileError(void)
{
	Setting_File_Parameters_Error = FALSE;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Retrieve the setting file error flag.
 * @return TRUE if there was any setting file error during this module's initialization.
 */
BOOL_TYPE ExtractionParams__GetSettingFileError(void)
{
	if (ParamEst__GetSettingFileError() == TRUE)
	{
		Setting_File_Parameters_Error = TRUE;
	}

	return Setting_File_Parameters_Error;
}

//-------------------------------------- Public Functions Used by Extraction-------------------------------------------

//---------------------------------------------------------------------------------------------------------------------
/**
 * Retrieve Parameter Estimation setup from Setting File.
 * @param index = Setting file displacement where the requested PE setup struct is stored.
 * @return Parameter Estimation setup struct.
 */
PARAM_EST_SETUP_TYPE ExtractionParams__GetParamEstSetup(uint8 index)
{
	SETTINGFILE_LOADER_TYPE loaded_data;
	const PARAM_EST_CONFIG_SET_TYPE *PE_config_set_ptr;
	PARAM_EST_SETUP_TYPE pe_setup;

    memset(&pe_setup, 0, sizeof(pe_setup));

    if (index != EXTR_CONFIG_INVALID_INDEX)
    {
#if ((EXTRACTION_LOW_SPEED_PARAMETERS_IN_PLACE == 0) || (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE == 0))
    	if (index >= PE_HARD_CODED_INDEXES_OFFSET)
    	{
    		// This is a temporary workaround to allow GetParamEstSetup() to distinguish if index is coming
    		// from setting file or is hard coded.
    		// In this way the routine can satisfy both Low Speed calls (expected to come from setting file)
    		// and High Speed call (expected to be hard coded).
    		// It assumes that setting file values for index are less than PE_HARD_CODED_INDEXES_OFFSET and
    		// it is reasonable, since as long as (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE == 0)
    		// in the setting file there will be just few tables for Parameter Estimation.
    		pe_setup = Param_Est_Setup_Bank[index - PE_HARD_CODED_INDEXES_OFFSET];
    	}
    	else
#endif // ((EXTRACTION_LOW_SPEED_PARAMETERS_IN_PLACE != 0) || (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE == 0))
		if (SettingFile__BasicLoader(SF_PTR_MCU_PARAMETER_ESTIMATION, index, &loaded_data) == PASS)
		{
			PE_config_set_ptr = (const PARAM_EST_CONFIG_SET_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

			if (SettingFile__BasicLoader(SF_PTR_MCU_PARAMETER_ESTIMATION, PE_config_set_ptr->Param_Est_Config_Index, &loaded_data) == PASS)
			{
				pe_setup = *(const PARAM_EST_SETUP_TYPE *)(loaded_data.Data);	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			}
			else
			{
				Setting_File_Parameters_Error = TRUE;
			}
		}
		else
		{
			Setting_File_Parameters_Error = TRUE;
		}
    }

    return pe_setup;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Retrieve Parameter Estimation Excitation setup from Setting File.
 * @param index = Setting file displacement where the requested PE Exc setup struct is stored.
 * @return Parameter Estimation Excitation setup struct.
 */
PARAM_EST_EXC_SETUP_TYPE ExtractionParams__GetParamEstExcSetup(uint8 index)
{
	SETTINGFILE_LOADER_TYPE loaded_data;
	const PARAM_EST_CONFIG_SET_TYPE *PE_config_set_ptr;
	PARAM_EST_EXC_SETUP_TYPE pe_exc_setup;

    memset(&pe_exc_setup, 0, sizeof(pe_exc_setup));

    if (index != EXTR_CONFIG_INVALID_INDEX)
    {
#if ((EXTRACTION_LOW_SPEED_PARAMETERS_IN_PLACE == 0) || (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE == 0))
    	if (index >= PE_HARD_CODED_INDEXES_OFFSET)
    	{
    		// This is a temporary workaround to allow GetParamEstSetup() to distinguish if index is coming
    		// from setting file or is hard coded.
    		// In this way the routine can satisfy both Low Speed calls (expected to come from setting file)
    		// and High Speed call (expected to be hard coded).
    		// It assumes that setting file values for index are less than PE_HARD_CODED_INDEXES_OFFSET and
    		// it is reasonable, since as long as (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE == 0)
    		// in the setting file there will be just few tables for Parameter Estimation.
     		pe_exc_setup = Param_Est_Exc_Setup_Bank[index - PE_HARD_CODED_INDEXES_OFFSET];
    	}
    	else
#endif // ((EXTRACTION_LOW_SPEED_PARAMETERS_IN_PLACE != 0) || (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE == 0))

		if (SettingFile__BasicLoader(SF_PTR_MCU_PARAMETER_ESTIMATION, index, &loaded_data) == PASS)
		{
			PE_config_set_ptr = (const PARAM_EST_CONFIG_SET_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

			if (SettingFile__BasicLoader(SF_PTR_MCU_PARAMETER_ESTIMATION, PE_config_set_ptr->Param_Est_Exc_Config_Index, &loaded_data) == PASS)
			{
				pe_exc_setup = *(const PARAM_EST_EXC_SETUP_TYPE *)(loaded_data.Data);		//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			}
			else
			{
				Setting_File_Parameters_Error = TRUE;
			}
		}
		else
		{
			Setting_File_Parameters_Error = TRUE;
		}
    }

    return pe_exc_setup;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Retrieve Parameter Estimation App Specific setup from Setting File.
 * @param index = Setting file displacement where the requested PE App Specific setup struct is stored.
 * @return Parameter Estimation App Specific setup struct.
 */
PARAM_EST_APP_SPECIFIC_SETUP_TYPE ExtractionParams__GetParamEstAppSpecificSetup(uint8 index)
{
	SETTINGFILE_LOADER_TYPE loaded_data;
	PARAM_EST_APP_SPECIFIC_SETUP_TYPE pe_appl_specific_setup;

    memset(&pe_appl_specific_setup, 0, sizeof(pe_appl_specific_setup));

    if (index != EXTR_CONFIG_INVALID_INDEX)
	{
#if ((EXTRACTION_LOW_SPEED_PARAMETERS_IN_PLACE == 0) || (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE == 0))
    	if (index >= PE_HARD_CODED_INDEXES_OFFSET)
    	{
    		// This is a temporary workaround to allow GetParamEstSetup() to distinguish if index is coming
    		// from setting file or is hard coded.
    		// In this way the routine can satisfy both Low Speed calls (expected to come from setting file)
    		// and High Speed call (expected to be hard coded).
    		// It assumes that setting file values for index are less than PE_HARD_CODED_INDEXES_OFFSET and
    		// it is reasonable, since as long as (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE == 0)
    		// in the setting file there will be just few tables for Parameter Estimation.
     		pe_appl_specific_setup = Param_Est_App_Specific_Setup_Bank[index - PE_HARD_CODED_INDEXES_OFFSET];
    	}
    	else
#endif // ((EXTRACTION_LOW_SPEED_PARAMETERS_IN_PLACE != 0) || (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE == 0))

		if (SettingFile__BasicLoader(SF_PTR_MCU_PARAMETER_ESTIMATION, index, &loaded_data) == PASS)
		{
			pe_appl_specific_setup = *(const PARAM_EST_APP_SPECIFIC_SETUP_TYPE *)(loaded_data.Data);	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
		}
		else
		{
			Setting_File_Parameters_Error = TRUE;
		}
	}

    return pe_appl_specific_setup;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Retrieve Spin Pulse Config setup from Setting File.
 * @param index = Setting file displacement where the requested Spin Pulse Config struct is stored.
 * @return Spin Pulse Config struct.
 */
HIGH_SPEED_PULSE_CONFIG_TYPE ExtractionParams__GetHighSpdPulseConfig(uint8 index)
{
#if (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE != 0)
	SETTINGFILE_LOADER_TYPE loaded_data;
#endif // (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE != 0)

	HIGH_SPEED_PULSE_CONFIG_TYPE hi_speed_pulse_config;

    memset(&hi_speed_pulse_config, 0, sizeof(hi_speed_pulse_config));

    if(index != EXTR_CONFIG_INVALID_INDEX)
	{
#if (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE != 0)

    	if (SettingFile__BasicLoader(SF_PTR_MCU_HIGH_SPEED_DATA, index, &loaded_data) == PASS)
		{
    		hi_speed_pulse_config = *(const HIGH_SPEED_PULSE_CONFIG_TYPE *)(loaded_data.Data);	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
		}
		else
		{
			Setting_File_Parameters_Error = TRUE;
		}

#else // (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE != 0)

    	hi_speed_pulse_config = High_Speed_Pulse_Config_Set[index];

#endif // (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE != 0)
	}

    return hi_speed_pulse_config;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Retrieve High Speed Extraction Friction Baseline setup from Setting File.
 * @param index = Setting file displacement where the requested Friction Baseline setup struct is stored.
 * @return Friction Baseline setup struct.
 */
HIGH_SPEED_BASELINE_CONFIG_TYPE ExtractionParams__GetHighSpdBaselineConfig(uint8 index)
{
#if (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE != 0)
	SETTINGFILE_LOADER_TYPE loaded_data;
#endif // (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE != 0)

	HIGH_SPEED_BASELINE_CONFIG_TYPE hi_spd_baseline_pulse_config;

    memset(&hi_spd_baseline_pulse_config, 0, sizeof(hi_spd_baseline_pulse_config));

    if (index != EXTR_CONFIG_INVALID_INDEX)
	{
#if (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE != 0)

    	if (SettingFile__BasicLoader(SF_PTR_MCU_BASELINE_UPDATE_DATA, index, &loaded_data) == PASS)
		{
    		hi_spd_baseline_pulse_config = *(const HIGH_SPEED_BASELINE_CONFIG_TYPE *)(loaded_data.Data);	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
		}
		else
		{
			Setting_File_Parameters_Error = TRUE;
		}

#else // (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE != 0)

		hi_spd_baseline_pulse_config = High_Speed_Baseline_Set[index];

#endif // (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE != 0)
	}

	return hi_spd_baseline_pulse_config;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Retrieve Load Mass Limit Check setup from Setting File.
 * @param index = Setting file displacement where the requested Load Mass Limit Check setup struct is stored.
 * @return Load Mass Limit Check setup struct.
 */
LOAD_MASS_LIMIT_SETUP_TYPE ExtractionParams__GetLoadMassLimitConfig(uint8 index)
{
#if (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE != 0)
	SETTINGFILE_LOADER_TYPE loaded_data;
#endif // (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE != 0)

	LOAD_MASS_LIMIT_SETUP_TYPE hi_spd_lmlc_config;

    memset(&hi_spd_lmlc_config, 0, sizeof(hi_spd_lmlc_config));

    if (index != EXTR_CONFIG_INVALID_INDEX)
	{
#if (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE != 0)

    	if (SettingFile__BasicLoader(SF_PTR_MCU_LOAD_MASS_LIMIT_CHECK_DATA, index, &loaded_data) == PASS)
		{
    		hi_spd_lmlc_config = *(const LOAD_MASS_LIMIT_SETUP_TYPE *)(loaded_data.Data);	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
		}
		else
		{
			Setting_File_Parameters_Error = TRUE;
		}

#else // (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE != 0)

    	hi_spd_lmlc_config = High_Speed_LMLC_Set[index];

#endif // (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE != 0)
	}

	return hi_spd_lmlc_config;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Verify if there was any error when loading Extraction parameters from the Setting File.
 * @return TRUE if no error was encountered.
 */
BOOL_TYPE ExtractionParams__IsExtrConfigValid(void)
{
	BOOL_TYPE ret_val;

	if (Setting_File_Parameters_Error == FALSE)
	{
		ret_val = TRUE;
	}
	else
	{
		ret_val = FALSE;
	}

	return ret_val;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Retrieve the baseline friction value associated with a spin pulse.
 * @param index = Baseline friction index.
 * @return Baseline friction value.
 */
uint16 ExtractionParams__GetBaselineFriction(uint8 index)
{
	if (index < BASELINE_ARRAY_MAX_SIZE)
	{
		return Extr_Baseline_Lifetime_x1000[index];
	}
	else 
	{
		return 0;
	}
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Set the baseline friction value associated with a spin pulse.
 * @param index = Baseline friction index.
 * @param value = Baseline friction value.
 */
void ExtractionParams__SetBaselineFriction(uint8 index, uint16 value)
{
	if (index < BASELINE_ARRAY_MAX_SIZE)
	{
		Extr_Baseline_Lifetime_x1000[index] = value;
	}
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Retrieve the factory calibrated baseline friction value associated with a spin pulse.
 * @param index = Baseline friction index.
 * @return Baseline friction value.
 */
uint16 ExtractionParams__GetFactoryBaselineFriction(uint8 index)
{
	if (index < BASELINE_ARRAY_MAX_SIZE)
	{
		return Extr_Baseline_Factory_x1000[index];
	}
	else
	{
		return 0;
	}
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Set the factory calibrated baseline friction value associated with a spin pulse.
 * @param index = Baseline friction index.
 * @param value = Baseline friction value.
 */
void ExtractionParams__SetFactoryBaselineFriction(uint8 index, uint16 value)
{
	if (index < BASELINE_ARRAY_MAX_SIZE)
	{
		Extr_Baseline_Factory_x1000[index] = value;
	}
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Filter the accelerometer output data.
 * @param u = Pointer to the first address on the input array (X, Y, Z accelerations).
 * @param y = Pointer to the first address on the output array (filtered X, Y, Z accelerations).
 */
void ExtractionParams__FilterAccelData(float32 *u, float32 *y)
{
#if (EXTR_FEATURE_ACCEL_ENABLED != 0)
	if (Extr_Accel_Filter.Coeffs != NULL)
	{
		for(int i = 0; i < ACCEL_AXES_COUNT; i++) // loop over channels
		{
			y[i] = DigitalFilter__DF2TSOS(u[i], Extr_Accel_Filter, Accel_Filter_Storage[i]);
		}
	}
	else
	{
		memcpy(y,u,3*sizeof(float));
	}
#endif
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Filter the accelerometer data on the vibration mapping algorithm input.
 * @param u = Pointer to the first address on the input array (X, Y, Z accelerations).
 * @param y = Pointer to the first address on the output array (filtered X, Y, Z accelerations).
 */
void ExtractionParams__FilterVibMapAccel(float32 *u, float32 *y)
{
#if (EXTR_FEATURE_ACCEL_ENABLED != 0)
	if (Extr_Vib_Map_Filter.Coeffs != NULL)
	{
		for(int i = 0; i < ACCEL_AXES_COUNT; i++) // loop over channels
		{
			y[i] = DigitalFilter__DF2TSOS(u[i], Extr_Vib_Map_Filter, Vib_Map_Filter_Storage[i]);
		}
	}
	else
	{
		memcpy(y,u,3*sizeof(float));
	}
#endif
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Filter the accelerometer data on the cabinet hit algorithm input.
 * @param u = Pointer to the first address on the input array (X, Y, Z accelerations).
 * @param y = Pointer to the first address on the output array (filtered X, Y, Z accelerations).
 */
void ExtractionParams__FilterCabHitAccel(float32 *u, float32 *y)
{
#if (EXTR_FEATURE_ACCEL_ENABLED != 0)
	if (Extr_Cab_Hit_Filter.Coeffs != NULL)
	{
		for(int i = 0; i < ACCEL_AXES_COUNT; i++) // loop over channels
		{
			y[i] = DigitalFilter__DF2TSOS(u[i], Extr_Cab_Hit_Filter, Cab_Hit_Filter_Storage[i]);
		}
	}
	else
	{
		memcpy(y,u,3*sizeof(float));
	}
#endif
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Retrieve the vibration mapping reference displacement from a determined index.
 * @param index = Reference displacement index.
 * @return Reference displacement value.
 */
uint16 ExtractionParams__GetVibMapRefDisp(uint8 index)
{
	return Extr_Vib_Map_Ref_Disp_x100[index];
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Set the vibration mapping reference floor displacement value associated to a determined index.
 * @param index = Reference displacement index.
 * @param value = Reference displacement value.
 */
void ExtractionParams__SetVibMapRefDisp(uint8 index, uint16 value)
{
	Extr_Vib_Map_Ref_Disp_x100[index] = value;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Verify if the cabinet hit algorithm has been enabled in GESE.
 * @return TRUE if the cabinet hit table is found found.
 */
uint8 ExtractionParams__IsCabHitEnabled(void)
{
#if (EXTRACTION_ACCEL_PARAMETERS_IN_PLACE != 0)
	SETTINGFILE_LOADER_TYPE loaded_data;
	return (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_CABINET_HIT_PARAMS, &loaded_data) == PASS);
#else
	return 0;
#endif //! (EXTRACTION_ACCEL_PARAMETERS_IN_PLACE != 0)
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Verify if the vibration mapping algorithm has been enabled in GESE.
 * @return TRUE if the vibration mapping table is found found.
 */
uint8 ExtractionParams__IsVibMapEnabled(void)
{
#if (EXTRACTION_ACCEL_PARAMETERS_IN_PLACE != 0)
	SETTINGFILE_LOADER_TYPE loaded_data;
	return (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_VIBRATION_MAPPING_PARAMS, &loaded_data) == PASS);
#else
	return 0;
#endif //! (EXTRACTION_ACCEL_PARAMETERS_IN_PLACE != 0)
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Load a distribution profile to the global variable GESE_Extr_DistProf that serves as interface
 * to the Extraction auto generated code.
 * @param index = Distribution profile index.
 * @return TRUE if the profile has been loaded successfully.
 */
BOOL_TYPE ExtractionParams__LoadDistributionProfile(uint8 index)
{
	BOOL_TYPE ret_value;
	ret_value = TRUE;

#if (EXTRACTION_LOW_SPEED_PARAMETERS_IN_PLACE != 0)
	SETTINGFILE_LOADER_TYPE loaded_data;
	if (SettingFile__BasicLoader(SF_PTR_MCU_DYNAMIC_PROFILES_DATA, index, &loaded_data) == PASS)
	{
		GESE_Extr_DistProf = (const DISTRIBUTION_PULSE_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
		GESE_Extr_DistProfPulseCnt = (loaded_data.Length)/sizeof(DISTRIBUTION_PULSE_TYPE);
	}
	else
	{
		ExtractionParams__SetSettingFileError();
		ret_value = FALSE;
	}
#else
	if (index > HARD_CODED_DIST_PROFILES_COUNT - 1)
	{
		ret_value = FALSE;
	}
	else
	{
		GESE_Extr_DistProf = Distribution_Profile_Set[index];
		GESE_Extr_DistProfPulseCnt = Distribution_Profile_Count_Set[index];
	}
#endif // (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE != 0)

	return ret_value;
}

//=====================================================================================================================
//-------------------------------------- Private Functions ------------------------------------------------------------
//=====================================================================================================================

//---------------------------------------------------------------------------------------------------------------------
/**
 * Initialize GESE parameters for the current extraction instance.
 * @param extraction_set_index = The setting file displacement for the selected extraction instance.
 * @return PASS If all parameters were succesfully initialized.
 */
static PASS_FAIL_TYPE InitializeGESEParams(uint8 extraction_set_index, uint8 vm_fd_threshold_config_index)
{
	PASS_FAIL_TYPE ret_value;
	ret_value = PASS;

	if (InitializeLowSpeedParameters(extraction_set_index) != PASS)
	{
		ret_value = FAIL;
	}

	if (InitializeHighSpeedParameters(extraction_set_index) != PASS)
	{
		ret_value = FAIL;
	}

#if (EXTR_FEATURE_ACCEL_ENABLED != 0)
	if (InitializeAccelerometerParameters(vm_fd_threshold_config_index) != PASS)
	{
		ret_value = FAIL;
	}
#endif //! (EXTR_FEATURE_ACCEL_ENABLED != 0)

	return ret_value;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Initialize the low speed extraction parameters.
 * @param extraction_set_index = The setting file displacement for the selected extraction instance.
 * @return PASS If all parameters were succesfully initialized.
 */
static PASS_FAIL_TYPE InitializeLowSpeedParameters(uint8 extraction_set_index)
{
	SETTINGFILE_LOADER_TYPE loaded_data;
	PASS_FAIL_TYPE ret_value;
	ret_value = PASS;

#if (EXTRACTION_LOW_SPEED_PARAMETERS_IN_PLACE != 0)
	const OPTIMUM_RAMP_UNBALANCE_TABLE_TYPE *opt_ramp_unbalance_table_ptr;
	const REBALANCE_LEV_ATT_TABLE_TYPE *rebalance_lev_att_table_ptr;
	const UNBAL_LEV_MAX_VEL_TABLE_TYPE *unbal_lev_max_vel_table_ptr;
	const DIGITAL_FILTER_TYPE *high_pass_filter_ptr;

	// Init pointers that depend on extraction_set_index
	if (SettingFile__BasicLoader(SF_PTR_MCU_SPIN_SET_DATA, extraction_set_index, &loaded_data) == PASS)
	{
		GESE_Extr_Setup = (const EXTRACTION_SETUP_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

		if (GESE_Extr_Setup->LMS_Enabled == TRUE)
		{
			LMS_Flags = TRUE;

			// Init pointer for Dry Load Mass Coefficients
			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_DRY_LOAD_MASS_PE_CALC_PARAMS, &loaded_data) == PASS)
			{
				GESE_Extr_MassConvCoeffs = (const MASS_CONVERSION_COEFFS_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			}
			else
			{
				ret_value = FAIL;
			}
		}
		else
		{
			LMS_Flags = FALSE;

			// Init pointer for Wet Load Mass Coefficients
			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_LOAD_MASS_PE_CALC_PARAMS, &loaded_data) == PASS)
			{
				GESE_Extr_MassConvCoeffs = (const MASS_CONVERSION_COEFFS_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			}
			else
			{
				ret_value = FAIL;
			}
		}

		if (GESE_Extr_Setup->DR_Enabled == 0)
		{
			// ToDo To be updated when the extraction model will be able to manage static profiles.
			ret_value = FAIL;
		}

		if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_UNBALANCE_DATA, GESE_Extr_Setup->Optimum_Ramp_Unbalance_Table_Index, &loaded_data) == PASS)
		{
			opt_ramp_unbalance_table_ptr = (const OPTIMUM_RAMP_UNBALANCE_TABLE_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_UNBALANCE_DATA, opt_ramp_unbalance_table_ptr->Limit_Load_Mass_Kg_Table, &loaded_data) == PASS)
			{
				GESE_Extr_OptRampLoadMassX100_BP.N = (loaded_data.Length)/sizeof(uint16);
				GESE_Extr_OptRampLoadMassX100_BP.BP = (uint16 *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

				GESE_Extr_OptRampUnbLut_Size[1] = GESE_Extr_OptRampLoadMassX100_BP.N;
			}
			else
			{
				ret_value = FAIL;
			}

			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_UNBALANCE_DATA, opt_ramp_unbalance_table_ptr->Rebalance_Level_Attempts_Table, &loaded_data) == PASS)
			{
				rebalance_lev_att_table_ptr = (const REBALANCE_LEV_ATT_TABLE_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

				GESE_Extr_RebalAttempts_BP.N = rebalance_lev_att_table_ptr->Num_Of_Values;
				GESE_Extr_RebalAttempts_BP.BP = (uint8_T *)&(rebalance_lev_att_table_ptr->First_Value);	//lint !e926 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
				GESE_Extr_RebalAttemptsArray = GESE_Extr_RebalAttempts_BP.BP;

				GESE_Extr_OptRampUnbLut_Size[0] = GESE_Extr_RebalAttempts_BP.N;
			}
			else
			{
				ret_value = FAIL;
			}

			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_UNBALANCE_DATA, opt_ramp_unbalance_table_ptr->Unbalance_Lev_Max_Velocity_Table, &loaded_data) == PASS)
			{
				unbal_lev_max_vel_table_ptr = (const UNBAL_LEV_MAX_VEL_TABLE_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

				GESE_Extr_TargetSpeedDiv10_BP.N = unbal_lev_max_vel_table_ptr->Num_Of_Values;
				GESE_Extr_TargetSpeedDiv10_BP.BP = (uint8_T*)&(unbal_lev_max_vel_table_ptr->First_Value);	//lint !e926 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
				GESE_Extr_TargetSpeedArray_Div10 = GESE_Extr_TargetSpeedDiv10_BP.BP;
			}
			else
			{
				ret_value = FAIL;
			}

			// Consistency check
			if (GESE_Extr_RebalAttempts_BP.N != GESE_Extr_TargetSpeedDiv10_BP.N)
			{
				ret_value = FAIL;
			}

			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_UNBALANCE_DATA, opt_ramp_unbalance_table_ptr->OR_To_MDDP_Lim_Offset_Low_g_Table, &loaded_data) == PASS)
			{
				GESE_Extr_OptRampLowerOffsetBeforeMDDP_LUT = (const sint16 *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			}
			else
			{
				ret_value = FAIL;
			}

			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_UNBALANCE_DATA, opt_ramp_unbalance_table_ptr->OR_To_SP_Lim_Offset_Low_g_Table, &loaded_data) == PASS)
			{
				GESE_Extr_OptRampLowerOffsetAfterMDDP_LUT = (const sint16 *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			}
			else
			{
				ret_value = FAIL;
			}

			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_UNBALANCE_DATA, opt_ramp_unbalance_table_ptr->OR_To_MDDP_Lim_Offset_Up_g_Table, &loaded_data) == PASS)
			{
				GESE_Extr_OptRampUpperOffsetBeforeMDDP_LUT = (const sint16 *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			}
			else
			{
				ret_value = FAIL;
			}

			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_UNBALANCE_DATA, opt_ramp_unbalance_table_ptr->OR_To_SP_Lim_Offset_Up_g_Table, &loaded_data) == PASS)
			{
				GESE_Extr_OptRampUpperOffsetAfterMDDP_LUT = (const sint16 *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			}
			else
			{
				ret_value = FAIL;
			}

			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_UNBALANCE_DATA, opt_ramp_unbalance_table_ptr->OR_To_MDDP_Unbalance_Level_Table, &loaded_data) == PASS)
			{
				GESE_Extr_OptRampUnbBeforeMDDP_LUT = (const uint16 *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

				// Consistency check
				if ( (GESE_Extr_OptRampUnbLut_Size[0] * GESE_Extr_OptRampUnbLut_Size[1]) != (loaded_data.Length)/sizeof(uint16))
				{
					ret_value = FAIL;
				}
			}
			else
			{
				ret_value = FAIL;
			}

			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_UNBALANCE_DATA, opt_ramp_unbalance_table_ptr->OR_To_SP_Unbalance_Level_Table, &loaded_data) == PASS)
			{
				GESE_Extr_OptRampUnbAfterMDDP_LUT = (const uint16 *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

				// Consistency check
				if ( (GESE_Extr_OptRampUnbLut_Size[0] * GESE_Extr_OptRampUnbLut_Size[1]) != (loaded_data.Length)/sizeof(uint16))
				{
					ret_value = FAIL;
				}
			}
			else
			{
				ret_value = FAIL;
			}
		}
		else
		{
			ret_value = FAIL;
		}
	}
	else
	{
		ret_value = FAIL;
	}

	// Init pointers for Distribution Ramp
	if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_DISTRIBUTION_RAMP_PARAMS, &loaded_data) == PASS)
	{
		GESE_Extr_FastDistRampSetup = (const FDR_SETUP_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

		if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_DYNAMIC_TABLES, GESE_Extr_FastDistRampSetup->Limit_Drum_Velocity_Table, &loaded_data) == PASS)
		{
			GESE_Extr_FastDistRampTargetSpeed_BP.N = (loaded_data.Length)/sizeof(uint16);
			GESE_Extr_FastDistRampTargetSpeed_BP.BP = (uint16 *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
		}
		else
		{
			ret_value = FAIL;
		}

		if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_DYNAMIC_TABLES, GESE_Extr_FastDistRampSetup->Limit_Load_Mass_Kg_Table, &loaded_data) == PASS)
		{
			GESE_Extr_P2PTorqueLoadMassX10_BP.N = (loaded_data.Length)/sizeof(uint16);
			GESE_Extr_P2PTorqueLoadMassX10_BP.BP = (uint16*)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
		}
		else
		{
			ret_value = FAIL;
		}

		if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_DYNAMIC_TABLES, GESE_Extr_FastDistRampSetup->Disturbance_Threshold_Table, &loaded_data) == PASS)
		{
			GESE_Extr_P2PTorqueX100_LUT = (const uint16*)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
		}
		else
		{
			ret_value = FAIL;
		}
	}
	else
	{
		ret_value = FAIL;
	}

	// Init pointer P2P Torque measurement
	if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_P2P_TORQUE_CALC_PARAMS, &loaded_data) == PASS)
	{
		GESE_Extr_P2PTorqueSetup = (const P2P_TORQUE_SETUP_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
	}
	else
	{
		ret_value = FAIL;
	}

	if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_SATEL_VELOCITY_CALC_PARAMS, &loaded_data) == PASS)
	{
		GESE_Extr_SatellizationSetup = (const SATELLIZATION_SETUP_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
	}
	else
	{
		ret_value = FAIL;
	}

	// Init High Pass Filter parameters
	if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_HIGH_PASS_FILTER_1_COEFFS, &loaded_data) == PASS)
	{
		high_pass_filter_ptr = (const DIGITAL_FILTER_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

		GESE_Extr_HighPassFilterSetup[0].Num_Sections = high_pass_filter_ptr->Byte_0.Bit.Section_Number;
		GESE_Extr_HighPassFilterSetup[0].Coeffs = (DIGITAL_FILTER_BIQUAD_COEFF_TYPE *)&(high_pass_filter_ptr->First_Filter_Coeff);	//lint !e929 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
	}
	else
	{
		ret_value = FAIL;
	}

	if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_HIGH_PASS_FILTER_2_COEFFS, &loaded_data) == PASS)
	{
		high_pass_filter_ptr = (const DIGITAL_FILTER_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

		GESE_Extr_HighPassFilterSetup[1].Num_Sections = high_pass_filter_ptr->Byte_0.Bit.Section_Number;
		GESE_Extr_HighPassFilterSetup[1].Coeffs = (DIGITAL_FILTER_BIQUAD_COEFF_TYPE *)&(high_pass_filter_ptr->First_Filter_Coeff);	//lint !e929 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
	}
	else
	{
		ret_value = FAIL;
	}

#if EXTR_FEATURE_OPT_RAMP_ENABLED
	// Init pointers for Optimum Ramp
	if (GESE_Extr_Setup->OR_Enabled)
	{
		if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_OPTIMUM_RAMP_PARAMS, &loaded_data) == PASS)
		{
			GESE_Extr_OptRampSetup = (const OPT_RAMP_SETUP_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_DYNAMIC_TABLES, GESE_Extr_OptRampSetup->Limit_Sump_Temp_C_Table, &loaded_data) == PASS)
			{
				GESE_Extr_WaterTemp_BP.N = (loaded_data.Length)/sizeof(uint16);
				GESE_Extr_WaterTemp_BP.BP = (uint16 *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			}
			else
			{
				ret_value = FAIL;
			}

			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_DYNAMIC_TABLES, GESE_Extr_OptRampSetup->BB_Phase_Adv_Target_Table, &loaded_data) == PASS)
			{
				GESE_Extr_OptRampPhsAdvTgt_LUT = (uint16 *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			}
			else
			{
				ret_value = FAIL;
			}

			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_DYNAMIC_TABLES, GESE_Extr_OptRampSetup->BB_Phase_Adv_Tolerance_Table, &loaded_data) == PASS)
			{
				GESE_Extr_OptRampPhaseTolerance_LUT = (uint16 *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			}
			else
			{
				ret_value = FAIL;
			}

			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_DYNAMIC_TABLES, GESE_Extr_OptRampSetup->Limit_Time_Plateau_Const_Table, &loaded_data) == PASS)
			{
				GESE_Extr_OptRampPlateauTime_LUT = loaded_data.Data;
			}
			else
			{
				ret_value = FAIL;
			}

			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_DYNAMIC_TABLES, GESE_Extr_OptRampSetup->Limit_Time_Convergence_Table, &loaded_data) == PASS)
			{
				GESE_Extr_OptRampConvTime_LUT = loaded_data.Data;
			}
			else
			{
				ret_value = FAIL;
			}
		}
		else
		{
			ret_value = FAIL;
		}
	}
#endif

	// Init pointer for Low Speed Parameter Estimation setup
	if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_LOW_SPEED_PAR_EST_CONFIG, &loaded_data) == PASS)
	{
		GESE_Extr_ParamEstLowSpeedSetup = (const PARAM_EST_SETUP_INDEX_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
	}
	else
	{
		ret_value = FAIL;
	}

	// Init pointers for MDDP
	if (GESE_Extr_Setup->MDDP_Enabled)
	{
		if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_MDDP_PARAMS, &loaded_data) == PASS)
		{
			GESE_Extr_MddpSetup = (const MDDP_SETUP_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_DYNAMIC_TABLES, GESE_Extr_MddpSetup->Plateau_Load_Mass_Kg_Table, &loaded_data) == PASS)
			{
				GESE_Extr_MddpLoadMassX10_BP.N = (loaded_data.Length)/sizeof(uint16);
				GESE_Extr_MddpLoadMassX10_BP.BP = (uint16 *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			}
			else
			{
				ret_value = FAIL;
			}

			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_DYNAMIC_TABLES, GESE_Extr_MddpSetup->Plateau_Duration_S_Table, &loaded_data) == PASS)
			{
				GESE_Extr_MddpDuration_LUT = loaded_data.Data;
			}
			else
			{
				ret_value = FAIL;
			}

			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_DYNAMIC_TABLES, GESE_Extr_MddpSetup->Plateau_Velocity_Rpm_Table, &loaded_data) == PASS)
			{
				GESE_Extr_MddpSpeed_LUT = (const uint16 *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			}
			else
			{
				ret_value = FAIL;
			}

			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_DYNAMIC_TABLES, GESE_Extr_MddpSetup->Ramp_Rate_Rpm_S_Table, &loaded_data) == PASS)
			{
				GESE_Extr_MddpRamp_LUT = loaded_data.Data;
			}
			else
			{
				ret_value = FAIL;
			}
		}
		else
		{
			ret_value = FAIL;
		}
	}

	// Init pointer for Unbalance Conversion Coefficients
	if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_UNBALANCE_MEAS_PE_CALC_PARAMS, &loaded_data) == PASS)
	{
		GESE_Extr_UnbConvCoeffs = (const UB_CONVERSION_COEFFS_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
	}
	else
	{
		ret_value = FAIL;
	}

	if (GESE_Extr_Setup->CWLD_Enabled)
	{
		// Init pointer for Clean Washer Coefficients
		if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_CLEAN_WASHER_LOAD_DET_PARAMS, &loaded_data) == PASS)
		{
			GESE_Extr_CleanWasherSetup = (const CLEAN_WASHER_SETUP_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
		}
		else
		{
			ret_value = FAIL;
		}
	}

#endif  // (EXTRACTION_LOW_SPEED_PARAMETERS_IN_PLACE != 0)

#if	(EXTRACTION_ATHLETE_PARAMETERS_IN_PLACE != 0)
	const EXTENDED_UNBALANCE_TABLE_TYPE *extended_unbalance_table_ptr;

		if (SettingFile__BasicLoader(SF_PTR_MCU_REBALANCE_DATA, GESE_Extr_Setup->Rebalance_Table_Index, &loaded_data) == PASS)
		{
			GESE_Extr_RebalTable = (const REBALANCE_TABLE_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			GESE_Extr_RebalTableCount = loaded_data.Length/sizeof(REBALANCE_TABLE_TYPE);
		}
		else
		{
			ret_value = FAIL;
		}

		if (SettingFile__BasicLoader(SF_PTR_MCU_REBALANCE_DATA, GESE_Extr_Setup->Extended_Unbalance_Table_Index, &loaded_data) == PASS)
		{
			extended_unbalance_table_ptr = (const EXTENDED_UNBALANCE_TABLE_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			GESE_Extr_ExtUnbTargetCount = (loaded_data.Length - sizeof(EXT_UNB_CHK_SETUP_TYPE))/sizeof(EXT_UNB_CHK_TARGET_TYPE);
			GESE_Extr_ExtUnbSetup = (const EXT_UNB_CHK_SETUP_TYPE *)&(extended_unbalance_table_ptr->Setup);	//lint !e929 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			GESE_Extr_ExtUnbTargetSet = (const EXT_UNB_CHK_TARGET_TYPE *)&(extended_unbalance_table_ptr->First_Item); //lint !e929 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
		}
		if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_SORTED_UNBALANCE_CURVES, &loaded_data) == PASS)
		{
			GESE_Extr_BalanceIndexConversionLut.Count = ((loaded_data.Length)/sizeof(uint16))/2; //! Divide length by two because there are two arrays in this displacement.
			GESE_Extr_BalanceIndexConversionLut.Converted_Values = (uint16 *)(void *)(loaded_data.Data + loaded_data.Length/2);
			GESE_Extr_BalanceIndexConversionLut.Raw_Values = (uint16 *)(void *)loaded_data.Data;
		}
		else
		{
			ret_value = FAIL;
		}
#endif // (EXTRACTION_ATHLETE_PARAMETERS_IN_PLACE != 0)

	return ret_value;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Initialize the high speed extraction parameters.
 * @param extraction_set_index = The setting file displacement for the selected extraction instance.
 * @return PASS If all parameters were succesfully initialized.
 */
static PASS_FAIL_TYPE InitializeHighSpeedParameters(uint8 extraction_set_index)
{
	PASS_FAIL_TYPE ret_value;
	ret_value = PASS;

#if (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE != 0)
	const EXTRACTION_SETUP_TYPE *extraction_set_ptr;
	SETTINGFILE_LOADER_TYPE loaded_data;

	// Init pointer for Unbalance parameters
	if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_UNBALANCE_PARAMS, &loaded_data) == PASS)
	{
		GESE_Extr_HighSpdUnbConfig = (const HIGH_SPEED_UNB_SETUP_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
	}
	else
	{
		ret_value = FAIL;
	}

	// Init pointers that depend on Spin Profile
	if (SettingFile__BasicLoader(SF_PTR_MCU_SPIN_SET_DATA, extraction_set_index, &loaded_data) == PASS)
	{
		extraction_set_ptr = (const EXTRACTION_SETUP_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

		if (SettingFile__BasicLoader(SF_PTR_MCU_DYNAMIC_SPIN_PROFILES_DATA, extraction_set_ptr->Spin_Profile_Index, &loaded_data) == PASS)
		{
			GESE_Extr_SpinProfileConfig = (const SPIN_PROFILE_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

			GESE_Extr_SpinPulses = (const SPIN_PULSE_TYPE *)(loaded_data.Data + EXTR_SPIN_PULSES_OFFSET);	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
		}
		else
		{
			ret_value = FAIL;
		}
	}
	else
	{
		ret_value = FAIL;
	}

#if (EXTR_FEATURE_HIGH_SPEED_PE_ENABLED != 0)
	const BASELINE_REF_VELOCITY_TABLE_TYPE *baseline_ref_vel_table_ptr;

	// Init pointer for High Speed Configuration
	if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_HIGH_SPD_CONFIG_PARAMS, &loaded_data) == PASS)
	{
		GESE_Extr_HighSpdConfig = (const HIGH_SPEED_CONFIG_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
	}
	else
	{
		ret_value = FAIL;
	}

	// Init pointers for Baseline Update parameters
	if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_BASELINE_UPD_CFG_PARAMS, &loaded_data) == PASS)
	{
		GESE_Extr_BaselineFactoryCalibrationSetup = (const BASELINE_FACTORY_CALIBRATION_SETUP_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

		if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_DYNAMIC_TABLES, GESE_Extr_BaselineFactoryCalibrationSetup->Reference_Velocity_Table, &loaded_data) == PASS)
		{
			baseline_ref_vel_table_ptr = (const BASELINE_REF_VELOCITY_TABLE_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

			GESE_Extr_BaselineFrictionRefSpeed_BP.N = baseline_ref_vel_table_ptr->Num_Of_Values;
			GESE_Extr_BaselineFrictionRefSpeed_BP.BP = (uint8_T *)&(baseline_ref_vel_table_ptr->First_Value);	//lint !e926 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			GESE_Extr_BaselineFrictionRefSpeed_Sig = GESE_Extr_BaselineFrictionRefSpeed_BP;
		}
		else
		{
			ret_value = FAIL;
		}

		if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_DYNAMIC_TABLES, GESE_Extr_BaselineFactoryCalibrationSetup->Default_Friction_Table, &loaded_data) == PASS)
		{
			GESE_Extr_BaselineDefaultFrictionArray_x1000 = (const uint16 *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
		}
		else
		{
			ret_value = FAIL;
		}

		if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_DYNAMIC_TABLES, GESE_Extr_BaselineFactoryCalibrationSetup->Factory_Friction_Sel_Index_Table, &loaded_data) == PASS)
		{
			GESE_Extr_FactoryFrictionSelIndexArray = (const uint8 *)loaded_data.Data;	//lint !e926 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
		}
		else
		{
			ret_value = FAIL;
		}

		if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_DYNAMIC_TABLES, GESE_Extr_BaselineFactoryCalibrationSetup->Factory_Cal_Scaling_Factor_Table, &loaded_data) == PASS)
		{
			GESE_Extr_FactoryCalScalingFactorArray = (const uint16 *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
		}
		else
		{
			ret_value = FAIL;
		}
	}
	else
	{
		ret_value = FAIL;
	}

	// Init pointer for CEM Configuration parameters
	if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_CEM_CONFIG_PARAMS, &loaded_data) == PASS)
	{
		GESE_Extr_CEMSetup = (const CEM_SETUP_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
	}
	else
	{
		ret_value = FAIL;
	}
#endif // (EXTR_FEATURE_HIGH_SPEED_PE_ENABLED != 0)

	return ret_value;
}
#endif // (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE != 0)

//---------------------------------------------------------------------------------------------------------------------
/**
 * Initialize the extraction accelerometer parameters.
 * @param vm_fd_threshold_config_index = The setting file displacement for the selected vibration mapping instance.
 * @return PASS If all parameters were succesfully initialized.
 */
#if (EXTR_FEATURE_ACCEL_ENABLED != 0)
static PASS_FAIL_TYPE InitializeAccelerometerParameters(uint8 vm_fd_threshold_config_index)
{
	PASS_FAIL_TYPE ret_value;
	ret_value = PASS;

#if (EXTRACTION_ACCEL_PARAMETERS_IN_PLACE != 0)
	const DIGITAL_FILTER_TYPE *accel_filter_ptr;
	const SORTED_SPIN_TGT_VELOCITIES_TYPE *sorted_spin_tgt_velocities_ptr;
	SETTINGFILE_LOADER_TYPE loaded_data;

	// Init pointer for Accelerometer Filter Configuration parameters
	if (SettingFile__BasicLoader(SF_PTR_MCU_MOTOR_APPLICATION_GENERIC_DATA, SF_DISPL_ACCELEROMETER_FILTER_CONFIG, &loaded_data) == PASS)
	{
		accel_filter_ptr = (const DIGITAL_FILTER_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

		Extr_Accel_Filter.Num_Sections = accel_filter_ptr->Byte_0.Bit.Section_Number;
		Extr_Accel_Filter.Coeffs = (DIGITAL_FILTER_BIQUAD_COEFF_TYPE *)&(accel_filter_ptr->First_Filter_Coeff);	//lint !e929 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
	}
	else
	{
		ret_value = FAIL;
	}

	// Init pointers for Vibration Mapping parameters
	if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_VIBRATION_MAPPING_PARAMS, &loaded_data) == PASS)
	{
		GESE_Extr_VibMapSetup = (const VIBRATION_MAPPING_SETUP_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

		// Init pointer for Vibration Mapping Filter Configuration
		if (GESE_Extr_VibMapSetup->Accel_Filter_Config_Index != EXTR_CONFIG_INVALID_INDEX)
		{
			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_DYNAMIC_TABLES, GESE_Extr_VibMapSetup->Accel_Filter_Config_Index, &loaded_data) == PASS)
			{
				accel_filter_ptr = (const DIGITAL_FILTER_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

				Extr_Vib_Map_Filter.Num_Sections = accel_filter_ptr->Byte_0.Bit.Section_Number;
				Extr_Vib_Map_Filter.Coeffs = (DIGITAL_FILTER_BIQUAD_COEFF_TYPE *)&(accel_filter_ptr->First_Filter_Coeff);	//lint !e929 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			}
			else
			{
				ret_value = FAIL;
			}
		}
		else
		{
			// Vibration Mapping Filter disabled
			Extr_Vib_Map_Filter.Num_Sections = 0;
			Extr_Vib_Map_Filter.Coeffs = (DIGITAL_FILTER_BIQUAD_COEFF_TYPE *)NULL;
		}

		// Init pointer for Floor Displacement Calculation
		if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_FLOOR_DISPLACEMENT_CALC_PARAMS, &loaded_data) == PASS)
		{
			GESE_Extr_FloorDispSetup = (const FLOOR_DISPLACEMENT_SETUP_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
		}
		else
		{
			ret_value = FAIL;
		}

		// Init pointer for Vibration Mapping Floor Displacement Threshold Characteristic Configuration
		if (SettingFile__BasicLoader(SF_PTR_MCU_VIBRATION_MAPPING_CONFIG_DATA, vm_fd_threshold_config_index, &loaded_data) == PASS)
		{
			GESE_Extr_VibMapFDThreshold = (const VIB_MAP_FLOOR_DISPL_THRESHOLD_TYPE *)loaded_data.Data;;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
		}
		else
		{
			ret_value = FAIL;
		}

		// Init pointer for Sorted Spin Target Velocities table
		if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_SORTED_SPIN_TGT_VELOCITIES, &loaded_data) == PASS)
		{
			sorted_spin_tgt_velocities_ptr = (const SORTED_SPIN_TGT_VELOCITIES_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

			GESE_Extr_VibMapRefSpeedArray_div10.N = sorted_spin_tgt_velocities_ptr->Num_Of_Values;
			GESE_Extr_VibMapRefSpeedArray_div10.BP = (uint8_T *)&(sorted_spin_tgt_velocities_ptr->First_Value);	//lint !e926 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
		}
		else
		{
			ret_value = FAIL;
		}
	}
	else
	{
		// Vibration Mapping parameters table is not mandatory. If the table is not present in GESE, it means
		// that Vibration Mapping algorithm is disabled.
		// If this is the case, GESE_Extr_VibMapSetup, GESE_Extr_FloorDispSetup and GESE_Extr_VibMapFDThreshold
		// are initialized to NULL.
		GESE_Extr_VibMapSetup = (VIBRATION_MAPPING_SETUP_TYPE *)NULL;
		GESE_Extr_FloorDispSetup = (FLOOR_DISPLACEMENT_SETUP_TYPE *)NULL;
		GESE_Extr_VibMapFDThreshold = (VIB_MAP_FLOOR_DISPL_THRESHOLD_TYPE *)NULL;
		Extr_Vib_Map_Filter.Num_Sections = 0;
		Extr_Vib_Map_Filter.Coeffs = (DIGITAL_FILTER_BIQUAD_COEFF_TYPE *)NULL;
		GESE_Extr_VibMapRefSpeedArray_div10.N = 0;
		GESE_Extr_VibMapRefSpeedArray_div10.BP = NULL;
	}

	// Init pointers for Cabinet Hit Detection parameters
	if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_COMMON_PARAMS, SF_DISPL_CABINET_HIT_PARAMS, &loaded_data) == PASS)
	{
		GESE_Extr_CabHitSetup = (const CABINET_HIT_SETUP_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

		// Init pointer for Cabinet Hit Detection filter Configuration
		if (GESE_Extr_CabHitSetup->Accel_Filter_Config_Index != EXTR_CONFIG_INVALID_INDEX)
		{
			if (SettingFile__BasicLoader(SF_PTR_MCU_EXTRACTION_DYNAMIC_TABLES, GESE_Extr_CabHitSetup->Accel_Filter_Config_Index, &loaded_data) == PASS)
			{
				accel_filter_ptr = (const DIGITAL_FILTER_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

				Extr_Cab_Hit_Filter.Num_Sections = accel_filter_ptr->Byte_0.Bit.Section_Number;
				Extr_Cab_Hit_Filter.Coeffs = (DIGITAL_FILTER_BIQUAD_COEFF_TYPE *)&(accel_filter_ptr->First_Filter_Coeff);	//lint !e929 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			}
			else
			{
				ret_value = FAIL;
			}
		}
		else
		{
			// Cabinet Hit Detection Filter disabled
			Extr_Cab_Hit_Filter.Num_Sections = 0;
			Extr_Cab_Hit_Filter.Coeffs = (DIGITAL_FILTER_BIQUAD_COEFF_TYPE *)NULL;
		}
	}
	else
	{
		// Cabinet Hit Detection parameters table is not mandatory. If the table is not present in GESE, it means
		// that Cabinet Hit Detection algorithm is disabled.
		// If this is the case, GESE_Extr_CabHitSetup is initialized to NULL.
		GESE_Extr_CabHitSetup = (CABINET_HIT_SETUP_TYPE *)NULL;
		Extr_Cab_Hit_Filter.Num_Sections = 0;
		Extr_Cab_Hit_Filter.Coeffs = (DIGITAL_FILTER_BIQUAD_COEFF_TYPE *)NULL;
	}

#endif	// (EXTRACTION_ACCEL_PARAMETERS_IN_PLACE != 0)

	return ret_value;
}
#endif //! (EXTR_FEATURE_ACCEL_ENABLED != 0)

//---------------------------------------------------------------------------------------------------------------------
/**
 * Initialize hard-coded parameters.
 */
static void InitializeEmbeddedParams(void)
{
#if ((EXTRACTION_LOW_SPEED_PARAMETERS_IN_PLACE == 0) || \
	(EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE == 0) || \
	(EXTRACTION_ACCEL_PARAMETERS_IN_PLACE == 0)	|| \
	(EXTRACTION_ATHLETE_PARAMETERS_IN_PLACE == 0))
	ExtractionEmbeddedParams__Initialize();
#endif

#if (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE == 0 && EXTR_FEATURE_HIGH_SPEED_PE_ENABLED == 1)
	ExtractionParams__SetBaselineFrictionFactoryArray(
			(uint8*)(void*)ExtractionEmbeddedParams__GetFactoryFriction(), 2*BASELINE_ARRAY_MAX_SIZE);
	ExtractionParams__SetBaselineFrictionLifetimeArray(
			(uint8*)(void*)ExtractionEmbeddedParams__GetFactoryFriction(), 2*BASELINE_ARRAY_MAX_SIZE);
#endif // (EXTRACTION_HIGH_SPEED_PARAMETERS_IN_PLACE == 0)

#if (EXTRACTION_ACCEL_PARAMETERS_IN_PLACE == 0 && EXTR_FEATURE_ACCEL_ENABLED == 1)
	memset(Extr_Vib_Map_Ref_Disp_x100,UCHAR_MAX,VIB_MAP_REF_ARRAY_MAX_SIZE);
	Extr_Accel_VibMapThrshCrossSpd = 0;
	Extr_Accel_Filter.Num_Sections = ACCEL_LP_FILTER_NUM_SOS_SECTIONS;
	Extr_Accel_Filter.Coeffs = Accel_LF_Filter_Coeffs;
	Extr_Vib_Map_Filter.Num_Sections = 0;
	Extr_Vib_Map_Filter.Coeffs = NULL;
	Extr_Cab_Hit_Filter.Num_Sections = 0;
	Extr_Cab_Hit_Filter.Coeffs = NULL;
#endif //(EXTRACTION_ACCEL_PARAMETERS_IN_PLACE == 0 && EXTR_FEATURE_ACCEL_ENABLED == 1)
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * Reset the accelerometer filters.
 */
#if (EXTR_FEATURE_ACCEL_ENABLED != 0)
static void ResetAccelFilters(void)
{
	for (int i = 0; i < ACCEL_AXES_COUNT; i++)
	{
		DigitalFilter__ResetSOS(Accel_Filter_Storage[i], ACCEL_FILTER_MAX_NUM_SECTIONS);
		DigitalFilter__ResetSOS(Vib_Map_Filter_Storage[i], ACCEL_FILTER_MAX_NUM_SECTIONS);
		DigitalFilter__ResetSOS(Cab_Hit_Filter_Storage[i], ACCEL_FILTER_MAX_NUM_SECTIONS);
	}
}
#endif
