/**
 * @file
 * @brief       Implements a FIFO queue for debug messages generated by project modules.
 * @details
 *
 * The Log module provides the following project-level features:
 *  - Macros for publishing log messages (with data) with varying severities.
 *  - A chronologically ordered record of debugging messages generated by the application.
 *  - Automatic publication of log messages over Reveal.
 *  - An optional method of filtering specific groups of messages so that they cannot be added.
 *
 * Each Log Message consists of four fields:
 *  - A Module Identifier to link the debug message to a specific module in the project.
 *  - A Message Identifier to specify a debug message unique to the module.
 *  - A Message Severity to classify the debug message. (Refer to #LOG_SEVERITY_ID_TYPE)
 *  - Associated data that can be used to further diagnose the reason for the debug message.
 *
 * The Log module works in conjunction with an external tool (LogPreprocessor) that can be run as
 * part of the build environment. The external tool scans all project modules looking for log
 * messages. It searches for a type definition with the name "MODULE_X_LOG_MESSAGE_ID_TYPE" where
 * 'X' is the name of the module. It then updates the Log module's parameter files to add the
 * module's name and log messages automatically.
 *
 * @copyright  Copyright 2013-2017 Whirlpool Corporation.  All rights reserved - CONFIDENTIAL.
 */


//  --- Include Files -------------------------------------------------------------------------------------------------

// -- This Module --
#include "SystemConfig.h"
#include "Log.h"
#if (LOG_MODULE_ENABLE == ENABLED)
#include "Log_prv.h"

// -- Other Modules --
#include "Reveal.h"
#include "string.h"


//  --- Private Properties --------------------------------------------------------------------------------------------


// -- Private Constant Declarations --

#ifndef LOG_RATE_CHECK_PERIOD
    //! The period over which the message rate is checked.
    //! This is also the period between two published messages when the message rate is exceeded.
    //! Each count represents one call to the Log__Background() function.
    //! Typically, 1 count equals 25ms, or 40 counts equals 1 second.
    #define LOG_RATE_CHECK_PERIOD 80
#endif

#ifndef LOG_MAX_RATE
    //! As long as more than LOG_MAX_RATE log messages are generated over the LOG_RATE_CHECK_PERIOD,
    //! the Log module will slow the publication rate down to one message per LOG_RATE_CHECK_PERIOD.
    #define LOG_MAX_RATE 18
#endif


// -- Private Type Declarations --


// -- Private Variables --

//! The memory buffer that holds the log messages in the Log Message Queue.
static LOG_MODULE_MESSAGE_ID_TYPE Log_Messages[LOG_MAX_MESSAGES];

//! The memory buffer that holds the data associated with the log messages in the Log Message Queue.
static LOG_DATA_TYPE Log_Data[LOG_MAX_MESSAGES];

//! The number of Log Messages currently in the Message Queue that have not been published.
static uint8 Num_Of_Messages;

//! A counter to measure the number of messages generated over the LOG_RATE_CHECK_PERIOD.
static uint8 Log_Msg_Per_Period;

//! A counter to measure the LOG_RATE_CHECK_PERIOD.
static uint8 Log_Period_Counter;

//! A flag that indicates that the message generation rate exceeded the acceptable threshold.
//! When this flag is set, the publication rate is reduced.
static BOOL_TYPE Log_Too_Fast;

#if (LOG_RUN_TIME_FILTERING == ENABLED)
    //! An array of Message Severity filters - one for each Module.
    LOG_SEVERITY_FILTER_TYPE Filters[NUMBER_OF_MODULES];
#endif


//  --- Compile-Time Assertions ---------------------------------------------------------------------------------------

// Verify that the LOG_MODULE_MESSAGE_ID_TYPE exactly overlaps the concatenation of the
// LOG_MODULE_ID_TYPE and the LOG_MESSAGE_ID_TYPE.
CT_ASSERT(sizeof(LOG_MODULE_MESSAGE_ID_TYPE) == (sizeof(LOG_MODULE_ID_TYPE) + sizeof(LOG_MESSAGE_ID_TYPE)));

// Verify that the LOG_MAX_MESSAGES is in the expected range.
CT_ASSERT((0 < LOG_MAX_MESSAGES) && (LOG_MAX_MESSAGES <= 255));

// Verify that the NUMBER_OF_MODULES is in the expected range.
CT_ASSERT((0 < NUMBER_OF_MODULES) && (NUMBER_OF_MODULES <= 255));

// Verify that the LOG_SEVERITY_FILTERS_TABLE is correctly sized.
CT_ASSERT(sizeof(LOG_SEVERITY_FILTERS_TABLE) == (sizeof(LOG_SEVERITY_FILTER_TYPE) * (NUMBER_OF_MODULES)));


//  --- Private Function Prototypes -----------------------------------------------------------------------------------


//=====================================================================================================================
//  --- Public Functions ----------------------------------------------------------------------------------------------
//=====================================================================================================================



//---------------------------------------------------------------------------------------------------------------------
/**
 * Initialize all Log module variables.
 *
 * Reset the Message Queue variables to an empty Message Queue.
 * Fill the Message Queue memory with invalid Log Messages.
 * If the #LOG_RUN_TIME_FILTERING is ENABLED, then reset the Message Filters to the default values
 * from the LOG_SEVERITY_FILTERS_TABLE[] array.
 */
void Log__Initialize(void)
{
    // Set the variables for an empty Message Queue.
    Num_Of_Messages = 0;

    // Fill the Log's memory buffer with invalid messages.
    for (uint8 i = 0; i < LOG_MAX_MESSAGES; i++)
    {
        Log_Messages[i] = MODULE_LOG_INVALID_MESSAGE;
        Log_Data[i] = 0;
    }

    // Reset the message filters.
    #if (LOG_RUN_TIME_FILTERING == ENABLED)
        memcpy(Filters, LOG_SEVERITY_FILTERS_TABLE, sizeof(Filters));
    #endif
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Check for a message in the Log buffer and send it if Reveal is not busy.
 */
void Log__Background(void)
{
    // Check for a message rate that is too fast.
    Log_Period_Counter++;
    if (Log_Period_Counter >= LOG_RATE_CHECK_PERIOD)
    {
        Log_Too_Fast = (BOOL_TYPE)(Log_Msg_Per_Period > LOG_MAX_RATE);
        Log_Msg_Per_Period = 0;
        Log_Period_Counter = 0;
    }

    // Check if Log Buffer is not empty and Reveal queue is empty.
    if (((Log_Too_Fast == FALSE) ||
         (Log_Period_Counter == 0)) &&
        (Num_Of_Messages > 0) &&
        (Reveal__GetNumMessagesQueue() == 0))
    {
        // Send the available Log message on Reveal.
        REVEAL_COMMAND_TYPE* ptr = Reveal__NewFeedback(LOG_REPORT_API, LOG_REPORT_OPCODE, REVEAL_BROADCAST_NODE,
                                                       sizeof(LOG_MODULE_MESSAGE_ID_TYPE) + sizeof(LOG_DATA_TYPE));
        if (ptr != (REVEAL_COMMAND_TYPE *)NULL)
        {
            uint8 index = Num_Of_Messages - 1;
            if ((Reveal__AddDataU16(ptr, Log_Messages[index]) == PASS) &&
                (Reveal__AddDataU16(ptr, Log_Data[index]) == PASS) &&
                (Reveal__QueueCommand(ptr) == TRUE))
            {
                Num_Of_Messages--;
            }
        }
    }
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Add a new Log Message to the Message Queue.
 *
 * Log Messages that are disabled through a filter will not be added to the Message Queue.
 *
 * If the Message Queue is full when this function is called, then the passed information will be
 * discarded. The alternative solution of dropping the oldest Log Message is not used. If a
 * project module floods the Message Queue, the Log Messages leading up to the flood are typically
 * more useful than the repeated Log Message that generates the flood.
 *
 * Throws DEBUG_MODULE_ID_INVALID(module_id) if the Module Identifier is invalid.
 *
 * Throws DEBUG_SEVERITY_ID_INVALID(module_id, severity_id) if the Message Severity is invalid.
 *
 * @param module_id = Module Identifier value to use in the 'Module' field of the Log Message.
 * @param message_id = Message Identifier value to use in the 'Id' field of the Log Message.
 * @param severity_id = Message Severity value to use in the 'Severity' field of the Log Message.
 * @param data = Data value to use in the 'Data' field of the Log Message.
 */
void Log__AddMessage(LOG_MODULE_ID_TYPE module_id, LOG_MESSAGE_ID_TYPE message_id, LOG_SEVERITY_ID_TYPE severity_id, LOG_DATA_TYPE data)
{
    if (module_id >= NUMBER_OF_MODULES)
    {
        // Module Identifier is invalid.
        DEBUG_MODULE_ID_INVALID(module_id);
    }
    else if (severity_id > LOG_ERROR)
    {
        // Severity is invalid.
        DEBUG_SEVERITY_ID_INVALID(module_id, severity_id);
    }
    else if ((LOG_SEVERITY_FILTERS_TABLE[module_id] & (1 << severity_id)) == 0)
    {
        // Log Message was filtered out, so do nothing.
    }
    else
    {
        if (Num_Of_Messages >= LOG_MAX_MESSAGES)
        {
            // Refer to the function description.
        }
        else
        {
            // Log_Messages[] and Log_Data[] arrays are FIFOs.
            // Shift all the messages down by one and write the newest message to index 0.
            memmove(&Log_Messages[1], &Log_Messages[0], (LOG_MAX_MESSAGES - 1) * sizeof(LOG_MODULE_MESSAGE_ID_TYPE));
            memmove(&Log_Data[1], &Log_Data[0], (LOG_MAX_MESSAGES - 1) * sizeof(LOG_DATA_TYPE));
            Log_Messages[0] = (LOG_MODULE_MESSAGE_ID_TYPE)COMBINE_BYTES(module_id, message_id);
            Log_Data[0] = data;

            // increment the number of messages to publish by one.
            // Num_Of_Messages is known to be less than the max due to the check at the start of the function.
            Num_Of_Messages++;
        }

        // Count the number of requested messages independent of the number of published messages.
        if (Log_Msg_Per_Period < 0xFF)
        {
            Log_Msg_Per_Period++;
        }
    }
}


#if (LOG_RUN_TIME_FILTERING == ENABLED)
//---------------------------------------------------------------------------------------------------------------------
/**
 * Implement a filter to enable/disable Log Messages based on the module ID and severity IDs.
 *
 * Log Messages that are disabled through a filter will not be added to the Message Queue.
 *
 * Throws DEBUG_MODULE_ID_INVALID(module_id) if the Module Identifier is invalid.
 *
 * If #LOG_RUN_TIME_FILTERING is DISABLED, then this function will have no effect.
 *
 * @image html "log_sq_set_message_filter_api.png"
 *
 * @param module_id = The LOG_MODULE_ID_TYPE for the module being filtered.
 * @param severities_allowed = The combination of Message Severities that will be allowed.
 *          Log Messages with other Message Severities will not be added to the Message Queue.
 */
void Log__SetMessageFilter(LOG_MODULE_ID_TYPE module_id, LOG_SEVERITY_FILTER_TYPE severities_allowed)
{
    if (module_id < NUMBER_OF_MODULES)
    {
        Filters[module_id] = severities_allowed;
    }
    else
    {
        DEBUG_MODULE_ID_INVALID(module_id);
    }
}
#endif  // #if (LOG_RUN_TIME_FILTERING == ENABLED)

//=====================================================================================================================
//  --- Private Functions ---------------------------------------------------------------------------------------------
//=====================================================================================================================


#endif  // #if (LOG_MODULE_ENABLE == ENABLED)
