/**
 * @file
 * @brief       Communications to control a remote motor or motor-controlled device.
 *
 * @details     The same API221MotionCtrl module is used on the client and the server.
 *                  Client Definitions:
 *                      API221_CLIENT_FEATURE should be ENABLED
 *                      API221_SERVER_FEATURE should be DISABLED
 *                  Server Definitions:
 *                      API221_CLIENT_FEATURE should be DISABLED
 *                      API221_SERVER_FEATURE should be ENABLED
 *              Using the same module on the client and server helps ensure that the client and
 *              server are using the same type and version of the API.
 *
 *              API221MotionCtrl allows each client to control one or more motor control servers
 *              that each controls one or more motor. For each of the system motors, the API
 *              manages four types of data:
 *                  - Behaviors
 *                  - Events
 *                  - Failure Flags
 *                  - Data Acquisition
 *
 *              Behaviors:
 *              Behaviors are executed by the motor or device. The Stop and Run Behaviors are
 *              standard behaviors that must be implemented by every motor controller for every
 *              motor or device. Any motor controller can define additional platform-specific
 *              behaviors.
 *
 *              Events:
 *              Events are generated by each motor or device in the system. The motor controller
 *              generates the events as they occur. Each time an event is generated, an event
 *              message is sent to the Client. There are standard events that every motor or
 *              device can generate. Any motor controller can define additional platform-specific
 *              events.
 *
 *              Failure Flags:
 *              TRUE/FALSE flags that are normally FALSE. When a failure is detected, the flag
 *              that corresponds to the failure is set to TRUE. The motor controller sets the
 *              Failure Flags as necessary. The Client has the ability to read the Failure Flags
 *              and request that all the flags be reset to FALSE.
 *
 *              Data Acquisition:
 *              The API provides some limited data acquisition features for platform-specific
 *              analog data channels. The client can choose the analog data channels to monitor
 *              and the rate at which the motor controller should publish the analog data. API221
 *              will use a single publication period for all the motors and their analog data
 *              values on the same motor controller.
 *
 * @copyright   Copyright 2016-2017 Whirlpool Corporation.  All rights reserved - CONFIDENTIAL.
 */

//  --- Include Files -------------------------------------------------------------------------------------------------


// -- This Module --
#include "SystemConfig.h"

#ifndef API221_CLIENT_FEATURE
    // API221_CLIENT_FEATURE should be ENABLED for applications that interact with motor controllers.
    #error API221_CLIENT_FEATURE must be defined via SystemConfig.h as ENABLED or DISABLED.
#endif
#ifndef API221_SERVER_FEATURE
    // API221_SERVER_FEATURE should be ENABLED for applications that implement a motor controller.
    #error API221_SERVER_FEATURE must be defined via SystemConfig.h as ENABLED or DISABLED.
#endif
#if ((API221_CLIENT_FEATURE == ENABLED) && (API221_SERVER_FEATURE == ENABLED))
    // This feature is not yet supported. Request that the owner update this module to support these features together.
    #error There is currently no support for the API221 Client and Server on the same node.
#endif

#if ((API221_CLIENT_FEATURE == ENABLED) || (API221_SERVER_FEATURE == ENABLED))

#include "API221MotionCtrl.h"
#include "API221MotionCtrl_prv.h"

// -- Other Modules --
#if (API221_CLIENT_FEATURE == ENABLED)
    #include "Callback.h"
#endif
#include "Log.h"
#include <limits.h>
#include "Micro.h"
#include <string.h>
#include "Utilities.h"


// -- Compile-Time Assertions --

// Verify that API221 event values will fit in 6 bits.
// This is required by the events that use only six bits to represent the event.
CT_ASSERT(API221_EVENT_COUNT <= 0x40);


//  --- Private Declarations ------------------------------------------------------------------------------------------


// -- Private Constant Declarations --

//! The minimum number of milliseconds allowed between periodic data publications.
#define MINIMUM_PUBLICATION_MILLISECONDS            200

#if (API221_MS_TIMEOUT_TO_STOP > 0)
    //! Number of background function calls to wait before forcing a stop of the motor.
    #define TIMEOUT_TO_STOP                             (API221_MS_TIMEOUT_TO_STOP / API221_MS_PER_CALL_TO_BACKGROUND)

    // Ensure that the counter used to measure this time fits in a byte.
    CT_ASSERT(TIMEOUT_TO_STOP <= UCHAR_MAX);
#endif

//! The name of this module for use by the Log module.
#define MODULE_NAME                                 MODULE_API221_MOTION_CTRL

#if (API221_CLIENT_FEATURE == ENABLED)
    //! The total number of system motors controlled by the client.
    #define API221_SYSTEM_MOTOR_COUNT               ELEMENTS_IN_ARRAY(API221_MOTOR_IDS)

    #ifndef API221_MAX_FAILURE_EVENT_HANDLERS
        #define API221_MAX_FAILURE_EVENT_HANDLERS 1
    #endif

    #ifndef API221_MAX_STATUS_EVENT_HANDLERS
        #define API221_MAX_STATUS_EVENT_HANDLERS 1
    #endif

    // Verify that API221 client motor index will fit in 2 bits.
    // This is required by the events that use only two bits to represent the motor.
    CT_ASSERT(API221_SYSTEM_MOTOR_COUNT <= 0x4);
#endif


// -- Private Enumerated Constant Declarations --

//! All the API221 command and feedback OpCodes.
typedef enum API221MOTIONCTRL_OPCODE_ENUM
{
    API221_CMD_REQUEST_FAILURE_FLAGS        = 1,    //!< Request all failure flags
    API221_CMD_CLEAR_FAILURE_FLAGS          = 2,    //!< Clear all failure flags
    API221_CMD_KEEP_RUNNING                 = 3,    //!< Keep the previous command activated
    API221_CMD_STOP                         = 4,    //!< Stop the motor
    API221_CMD_RUN                          = 5,    //!< Start to run the motor
    API221_CMD_SET_MOTION_BEHAVIOR          = 6,    //!< Start a platform-specific motion behavior
    API221_CMD_REQUEST_MOTOR_STATUS         = 7,    //!< Request the current status of the motor
    API221_CMD_REQUEST_ANALOG_DATA          = 8,    //!< Request an analog input value
    API221_CMD_SET_DATA_PUBLICATION_PERIOD  = 9,    //!< Set the publication data rate for periodic data
    API221_CMD_ADD_PERIODIC_DATA_CHANNELS   = 10,   //!< Add a set of analog input values to the periodic data
    API221_CMD_REMOVE_PERIODIC_DATA_CHANNELS= 11,   //!< Remove a set of analog input values from the periodic data
    API221_CMD_REQUEST_PERIODIC_DATA_STATUS = 12,   //!< Request the status of the periodic data publication
    API221_CMD_WASH                         = 13,   //!< Start the wash motion.
    API221_CMD_ROTATE_X_DEGREES             = 14,   //!< Start the rotate X degrees motion.
    API221_CMD_PULSE_IMMEDIATE              = 15,   //!< Start a new pulse now.
    API221_CMD_PULSE_MODIFY                 = 16,   //!< Modify the currently running pulse.
    API221_CMD_PULSE_QUEUE                  = 17,   //!< Queue the next pulse.

    API221_FBK_PUBLISH_FAILURE_FLAGS        = 1,    //!< Publish all failure flags
    API221_FBK_PUBLISH_EVENT                = 3,    //!< Publish an event
    API221_FBK_PUBLISH_MOTOR_STATUS         = 7,    //!< Publish the current status of the motor
    API221_FBK_PUBLISH_ANALOG_DATA          = 8,    //!< Publish single requested analog input value
    API221_FBK_PUBLISH_PERIODIC_DATA        = 9,    //!< Publish the requested set of analog input values periodically
    API221_FBK_PUBLISH_PERIODIC_DATA_STATUS = 12,   //!< Publish the status of the periodic data publication
} API221MOTIONCTRL_OPCODE_TYPE;

//! A list of log message IDs that are generated by this module.
typedef enum MODULE_API221_MOTION_CTRL_LOG_MESSAGE_ID_ENUM
{
    PERIODIC_PUBLICATION_FAILED = 1,
    FEEDBACK_OPCODE_NOT_SUPPORTED,
    INVALID_SYSTEM_MOTOR,
    INVALID_CUSTOM_COMMAND,
    INVALID_STANDARD_COMMAND,
    MOTOR_STOPPED_DUE_TO_TIMEOUT
} MODULE_API221_MOTION_CTRL_LOG_MESSAGE_ID_TYPE;

//! States for the monitored state of the motor based on MCI digital inputs.
typedef enum MONITORED_MOTOR_STATE_ENUM
{
    STATE_MONITORED_STOPPED,
    STATE_MONITORED_RAMPING,
    STATE_MONITORED_PLATEAU
} MONITORED_MOTOR_STATE_TYPE;


// -- Private Structure Type Declarations --

//! The structure that reflects how the analog data values are communicated over Reveal.
//! Note that the value in the Motor can be either the client-side or server-side motor index.
//! Which is used depends on the context.
typedef PACKED struct API221_ANALOG_DATA_STRUCT
{
    API221_CLIENT_MOTOR_INDEX_TYPE Motor;
    uint8 Channel;
    sint32 Value;                                   // Stored as (micro native) little-endian.
} API221_ANALOG_DATA_TYPE;

//! The structure used to store a single analog data value.
typedef PACKED struct API221_STORED_DATA_STRUCT
{
    API221_ANALOG_DATA_TYPE Ai;
    uint8 Sequence;
} API221_STORED_DATA_TYPE;

//! The data structure that holds most of the RAM used by this module.
typedef struct API221_DATA_STRUCT
{
    #if (API221_CLIENT_FEATURE == ENABLED)
        //! A handler for processing the motor failure flags message.
        API221_FAILURES_HANDLER_TYPE Failures_Handler[API221_SYSTEM_MOTOR_COUNT][API221_MAX_FAILURE_EVENT_HANDLERS];

        //! A handler for processing the status of a motor.
        API221_MOTOR_STATUS_HANDLER_TYPE Motor_Status_Handler[API221_SYSTEM_MOTOR_COUNT][API221_MAX_STATUS_EVENT_HANDLERS];

        //! A handler for processing the status of the periodic data.
        API221_PER_DATA_STATUS_HANDLER_TYPE Periodic_Data_Status_Handler;

        //! Array of the maximum number of analog input values that can be buffered by the API221_Client.
        API221_STORED_DATA_TYPE Data[API221_STORED_ANALOG_INPUTS];
    #endif      // #if (API221_CLIENT_FEATURE == ENABLED)

    #if (API221_SERVER_FEATURE == ENABLED)
        //! A bitmap of the analog input channels requested for periodic publication.
        uint32 Requested[API221_SERVER_MOTOR_COUNT];

        //! The bitmap of the status flags.
        uint8 Status_Flags[API221_SERVER_MOTOR_COUNT];

        //! The tracked state of the motor.
        MONITORED_MOTOR_STATE_TYPE State[API221_SERVER_MOTOR_COUNT];

        #if (API221_MS_TIMEOUT_TO_STOP > 0)
            //! Counters to measure the time that no message has been sent to force a motor stop.
            uint8 Stop_Timeout[API221_SERVER_MOTOR_COUNT];
        #endif

        //! The total number of requested analog inputs for all motors.
        uint8 Num_Of_Requested_Analog_Inputs;

        //! The counter used to measure time between periodic publications of analog inputs.
        uint8 Publication_Counter;

        //! The amount of time between periodic publications of analog inputs.
        uint8 Publication_Period;

        //! The WIN node that requested the periodic publication of analog inputs.
        uint8 Requesting_Node;
    #endif      // #if (API221_SERVER_FEATURE == ENABLED)
} API221_DATA_TYPE;


//  --- Private Definitions -------------------------------------------------------------------------------------------


// -- Private Flash-Based Constant Definitions --

#if (API221_SERVER_FEATURE == ENABLED)
    //! This table is used to convert bits that represent the previous and current motor status into
    //! events. The key (used as an index into the array) consists of the following bits:
    //!     bit 3 = Was previously reached target
    //!     bit 2 = Was previously stopped
    //!     bit 1 = Is currently reached target
    //!     bit 0 = Is currently stopped
    //! For the two bits 'Reached Target' and 'Stopped', the following is assumed:
    //!     Reached Target   and   Stopped  results in   State
    //!     --------------         -------              -------
    //!         False               False               Ramping
    //!         False               True                Stopped
    //!         True                False               Plateau
    //!         True                True                Stopped
    static const API221_MOTOR_EVENT_TYPE KEY_TO_EVENT[] =
    {
        API221_EVENT_NONE,                      //!< Was ramping and is ramping
        API221_EVENT_STOPPED,                   //!< Was ramping and is stopped
        API221_EVENT_REACHED_TARGET,            //!< Was ramping and is plateau
        API221_EVENT_STOPPED,                   //!< Was ramping and is stopped
        API221_EVENT_RAMP_STARTED,              //!< Was stopped and is ramping
        API221_EVENT_NONE,                      //!< Was stopped and is stopped
        API221_EVENT_REACHED_TARGET,            //!< Was stopped and is plateau
        API221_EVENT_NONE,                      //!< Was stopped and is stopped
        API221_EVENT_RAMP_STARTED,              //!< Was plateau and is ramping
        API221_EVENT_STOPPED,                   //!< Was plateau and is stopped
        API221_EVENT_NONE,                      //!< Was plateau and is plateau
        API221_EVENT_STOPPED,                   //!< Was plateau and is stopped
        API221_EVENT_RAMP_STARTED,              //!< Was stopped and is ramping
        API221_EVENT_NONE,                      //!< Was stopped and is stopped
        API221_EVENT_REACHED_TARGET,            //!< Was stopped and is plateau
        API221_EVENT_NONE                       //!< Was stopped and is stopped
    };
#endif      // #if (API221_SERVER_FEATURE == ENABLED)


// -- Private Variable Definitions --

//! Define variables for the API221MotionCtrl module.
static API221_DATA_TYPE Api221;

#if (API221_CLIENT_FEATURE == ENABLED)
    // Declare variables for the Callback module.
    DEFINE_CALLBACK_CONTROL_STRUCTURE(Api221_Callback, API221_MAX_EVENT_HANDLERS);
#endif      // #if (API221_CLIENT_FEATURE == ENABLED)


//  --- Private Function Prototypes -----------------------------------------------------------------------------------

#if (API221_CLIENT_FEATURE == ENABLED)
    static API221_CLIENT_MOTOR_INDEX_TYPE ConvertServerMotorIndexToClientMotorIndex(uint8 node, uint8 server_motor);
    static BOOL_TYPE RequestPeriodicDataChannels(API221MOTIONCTRL_OPCODE_TYPE op_code, API221_CLIENT_MOTOR_INDEX_TYPE client_motor, uint32 channels);
    static BOOL_TYPE SendStandardCommand(API221_CLIENT_MOTOR_INDEX_TYPE client_motor, API221MOTIONCTRL_OPCODE_TYPE op_code, uint16* params, uint8 num_of_params);
    #if (API221_STORED_ANALOG_INPUTS > 0)
        static void StoreAnalogInput(API221_ANALOG_DATA_TYPE data);
    #endif      // #if (API221_STORED_ANALOG_INPUTS > 0)
#endif          // #if (API221_CLIENT_FEATURE == ENABLED)

#if (API221_SERVER_FEATURE == ENABLED)
    static uint8 GetMotorStatus(uint8 server_motor);
    static BOOL_TYPE PublishMotorStatus(uint8 requesting_node, uint8 server_motor);
    #ifdef API221_READ_ANALOG_DATA
        static BOOL_TYPE PublishAnalogData(uint8 requesting_node, uint8 server_motor, uint8 channel);
        static BOOL_TYPE PublishPeriodicData(void);
        static BOOL_TYPE PublishPeriodicDataStatus(uint8 node);
        static PASS_FAIL_TYPE RevealAddAnalogInput(REVEAL_COMMAND_TYPE* msg, uint8 server_motor, uint8 channel);
        static BOOL_TYPE SetPublicationPeriod(uint8 node, uint16 milliseconds);
        static void UpdatePeriodicDataChannels(BOOL_TYPE add, uint8 server_motor, uint32 channels);
    #endif
    #ifdef API221_READ_FAILURE_FLAGS
        static REVEAL_RECIPE_STATUS_TYPE PublishFailureFlags(uint8 requesting_node, uint8 server_motor);
    #endif
#endif      // #if (API221_SERVER_FEATURE == ENABLED)


//=====================================================================================================================
//  --- Public Functions ----------------------------------------------------------------------------------------------
//=====================================================================================================================


//---------------------------------------------------------------------------------------------------------------------
/**
 * Initialize the API221MotionCtrl module variables.
 */
void API221MotionCtrl__Initialize(void)
{
    if (Micro__GetResetMode() == MICRO_RESET_MODE_COLD)
    {
        #if (API221_SERVER_FEATURE == ENABLED)
            memset(&Api221, 0, sizeof(Api221));
        #endif

        #if (API221_CLIENT_FEATURE == ENABLED)
            Callback__Initialize(&Api221_Callback);
            memset(Api221.Failures_Handler, 0, sizeof(Api221.Failures_Handler));
            memset(Api221.Motor_Status_Handler, 0, sizeof(Api221.Motor_Status_Handler));
            Api221.Periodic_Data_Status_Handler = NULL;
            memset(&Api221.Data, UCHAR_MAX, sizeof(Api221.Data));
        #endif
    }
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Periodically publish analog inputs that were requested.
 */
void API221MotionCtrl__Background(void)
{
    #if (API221_SERVER_FEATURE == ENABLED)
        #if (API221_MS_TIMEOUT_TO_STOP > 0)
            // Stop any motors that have been not been addressed by the server for too long.
            for (uint8 server_motor = 0; server_motor < API221_SERVER_MOTOR_COUNT; server_motor++)
            {
                uint8 timeout = Api221.Stop_Timeout[server_motor];
                if (timeout > 0)
                {
                    timeout--;
                    if (timeout == 0)
                    {
                        API221_DEVICE_STOP(server_motor, API221_DEFAULT_DECELERATION);
                        LOG_ADD_EXCEPTION(MOTOR_STOPPED_DUE_TO_TIMEOUT, server_motor);
                    }
                    Api221.Stop_Timeout[server_motor] = timeout;
                }
            }
        #endif      // #if (API221_MS_TIMEOUT_TO_STOP > 0)

        // Check for events based on changes in status.
        for (uint8 server_motor = 0; server_motor < API221_SERVER_MOTOR_COUNT; server_motor++)
        {
            uint8 prev_status = Api221.Status_Flags[server_motor];
            uint8 next_status = GetMotorStatus(server_motor);
            if (prev_status != next_status)
            {
                // Determine if any error occurred.
                if ((BIT_TEST(prev_status, API221_STS_ANY_ERROR_FOUND) == 0) &&
                    (BIT_TEST(next_status, API221_STS_ANY_ERROR_FOUND) == 1))
                {
                    API221MotionCtrl__PostEvent(server_motor, API221_EVENT_ERROR);
                }

                // Look for events derived from previous and current status.
                //      Setup a key with the following bits:
                //          bit 3 = Had previously reached target
                //          bit 2 = Was previously stopped
                //          bit 1 = Has currently reached target
                //          bit 0 = Is currently stopped
                uint8 key = ((prev_status << 1) & 0x0C) + ((next_status >> 1) & 0x03);
                //      Use the key to look up the event in a table.
                API221_MOTOR_EVENT_TYPE event = KEY_TO_EVENT[key];
                if (event != API221_EVENT_NONE)
                {
                    API221MotionCtrl__PostEvent(server_motor, event);
                }

                // Save the new status.
                Api221.Status_Flags[server_motor] = next_status;
            }
        }

        #ifdef API221_READ_ANALOG_DATA
            // Periodically publish analog inputs that were requested.
            if ((Api221.Requested != 0) && (Api221.Publication_Period > 0))
            {
                if (Api221.Publication_Counter > 0)
                {
                    Api221.Publication_Counter--;
                }
                if (Api221.Publication_Counter == 0)
                {
                    if (PublishPeriodicData() == TRUE)
                    {
                        // Setup the counter for the next publication.
                        Api221.Publication_Counter = Api221.Publication_Period;
                    }
                    else
                    {
                        LOG_ADD_EXCEPTION(PERIODIC_PUBLICATION_FAILED, Api221.Num_Of_Requested_Analog_Inputs);
                    }
                }
            }
        #endif      // #ifdef API221_READ_ANALOG_DATA
    #endif      // #if (API221_SERVER_FEATURE == ENABLED)
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * This method parses API221 commands sent to a broadcast or exclusively to this node.
 * @param cmd = Pointer to the received command message.
 * @return REVEAL_RECIPE_STATUS_TYPE that expresses the result of the parsing.
 */
REVEAL_RECIPE_STATUS_TYPE API221MotionCtrl__CommandParser(REVEAL_MSG_TYPE* cmd)
{
    // Assume that the message will be incorrectly formatted.
    REVEAL_RECIPE_STATUS_TYPE reveal_response = NVO_RS_UNSUP_INVALID_PARAM;

    #if (API221_SERVER_FEATURE == ENABLED)
        // Assume that the first byte of the payload identifies the motor and evaluate it once for all
        // OpCodes that use it.
        uint8 server_motor = cmd->payload[0];
    #endif

    // Parse the command based on the OpCode.
    switch (cmd->op_code)
    {
#if (API221_SERVER_FEATURE == ENABLED)
    #ifdef API221_READ_FAILURE_FLAGS
        case API221_CMD_REQUEST_FAILURE_FLAGS:
            // Expected Payload:
            //      One byte for the server motor index
            if ((cmd->size >= 1) && (server_motor < API221_SERVER_MOTOR_COUNT))
            {
                reveal_response = PublishFailureFlags(cmd->node_id, server_motor);
            }
            break;
    #endif      // #ifdef API221_READ_FAILURE_FLAGS

    #ifdef API221_CLEAR_FAILURES
        case API221_CMD_CLEAR_FAILURE_FLAGS:
            // Expected Payload:
            //      One byte for the server motor index
            if ((cmd->size >= 1) && (server_motor < API221_SERVER_MOTOR_COUNT))
            {
                API221_CLEAR_FAILURES(server_motor);
                reveal_response = NVO_RS_READY;
            }
            break;
    #endif      // #ifdef API221_CLEAR_FAILURES

    #if (API221_MS_TIMEOUT_TO_STOP > 0)
        case API221_CMD_KEEP_RUNNING:
            // Expected Payload:
            //      One byte for the server motor index
            if ((cmd->size >= 1) && (server_motor < API221_SERVER_MOTOR_COUNT))
            {
                // Restart the timeout-based stopping.
                Api221.Stop_Timeout[server_motor] = TIMEOUT_TO_STOP;
                reveal_response = NVO_RS_READY;
            }
            break;
    #endif      // #if (API221_MS_TIMEOUT_TO_STOP > 0)

        case API221_CMD_STOP:
            // Expected Payload:
            //      One byte for the server motor index
            //      Two big-endian bytes for the deceleration rate
            if ((cmd->size >= 3) && (server_motor < API221_SERVER_MOTOR_COUNT))
            {
                uint16 deceleration = Utilities__ConvertArrayTo16bits(&cmd->payload[1]);
                if (API221_DEVICE_STOP(server_motor, deceleration) == TRUE)
                {
                    #if (API221_MS_TIMEOUT_TO_STOP > 0)
                        // Disable the timeout-based stopping since a stop command was accepted.
                        Api221.Stop_Timeout[server_motor] = 0;
                    #endif
                    reveal_response = NVO_RS_READY;
                }
                else
                {
                    reveal_response = NVO_RS_UNSUP_UNAVAILABLE;
                }
            }
            break;

        case API221_CMD_RUN:
            // Expected Payload:
            //      One byte for the server motor index
            //      Two big-endian bytes for the velocity
            //      Two big-endian bytes for the acceleration
            if ((cmd->size >= 5) && (server_motor < API221_SERVER_MOTOR_COUNT))
            {
                sint16 velocity = (sint16)Utilities__ConvertArrayTo16bits(&cmd->payload[1]);
                uint16 acceleration = Utilities__ConvertArrayTo16bits(&cmd->payload[3]);
                if (API221_DEVICE_RUN(server_motor, velocity, acceleration) == TRUE)
                {
                    #if (API221_MS_TIMEOUT_TO_STOP > 0)
                        // Enable the timeout-based stopping since a command was accepted.
                        Api221.Stop_Timeout[server_motor] = TIMEOUT_TO_STOP;
                    #endif
                    reveal_response = NVO_RS_READY;
                }
                else
                {
                    reveal_response = NVO_RS_UNSUP_UNAVAILABLE;
                }
            }
            break;

    #ifdef API221_DEVICE_MOTION
        case API221_CMD_SET_MOTION_BEHAVIOR:
            // Expected Payload:
            //      One byte for the server motor index
            //      One or more parameter bytes to describe the requested motion behavior.
            if ((cmd->size >= 2) && (server_motor < API221_SERVER_MOTOR_COUNT))
            {
                if (API221_DEVICE_MOTION(server_motor, &cmd->payload[1], cmd->size - 1) == TRUE)
                {
                    #if (API221_MS_TIMEOUT_TO_STOP > 0)
                        // Enable the timeout-based stopping since a command was accepted.
                        Api221.Stop_Timeout[server_motor] = TIMEOUT_TO_STOP;
                    #endif
                    reveal_response = NVO_RS_READY;
                }
                else
                {
                    reveal_response = NVO_RS_UNSUP_UNAVAILABLE;
                }
            }
            break;
    #endif      // #ifdef API221_DEVICE_MOTION

        case API221_CMD_REQUEST_MOTOR_STATUS:
            // Expected Payload:
            //      One byte for the server motor index
            if ((cmd->size >= 1) && (server_motor < API221_SERVER_MOTOR_COUNT))
            {
                if (PublishMotorStatus(cmd->node_id, server_motor) == TRUE)
                {
                    reveal_response = NVO_RS_READY;
                }
                else
                {
                    reveal_response = NVO_RS_UNSUP_UNAVAILABLE;
                }
            }
            break;

    #ifdef API221_READ_ANALOG_DATA
        case API221_CMD_REQUEST_ANALOG_DATA:
            // Expected Payload:
            //      One byte for the server motor index
            //      One byte for the analog channel
            if ((cmd->size >= 2) &&
                (server_motor < API221_SERVER_MOTOR_COUNT) &&
                (cmd->payload[1] < 32))
            {
                uint8 channel = cmd->payload[1];
                if (PublishAnalogData(cmd->node_id, server_motor, channel) == TRUE)
                {
                    reveal_response = NVO_RS_READY;
                }
                else
                {
                    reveal_response = NVO_RS_UNSUP_UNAVAILABLE;
                }
            }
            break;

        case API221_CMD_SET_DATA_PUBLICATION_PERIOD:
            // Expected Payload:
            //      Two big-endian bytes with the publication period.
            if (cmd->size >= 2)
            {
                if (SetPublicationPeriod(cmd->node_id, Utilities__ConvertArrayTo16bits(&cmd->payload[0])) == TRUE)
                {
                    reveal_response = NVO_RS_READY;
                }
            }
            break;

        case API221_CMD_ADD_PERIODIC_DATA_CHANNELS:
        case API221_CMD_REMOVE_PERIODIC_DATA_CHANNELS:
            // Expected Payload:
            //      One byte for the server motor index
            //      Four big-endian bytes of bits for a combination of up to 32 analog channels.
            if ((cmd->size >= 5) && (server_motor < API221_SERVER_MOTOR_COUNT))
            {
                BOOL_TYPE add = (BOOL_TYPE)(cmd->op_code == API221_CMD_ADD_PERIODIC_DATA_CHANNELS);
                uint32 channels_bitmap = Utilities__ConvertArrayTo32bits(&cmd->payload[1]);
                UpdatePeriodicDataChannels(add, server_motor, channels_bitmap);
                reveal_response = NVO_RS_READY;
            }
            break;

        case API221_CMD_REQUEST_PERIODIC_DATA_STATUS:
            // Expected No Payload
            if (PublishPeriodicDataStatus(cmd->node_id) == TRUE)
            {
                reveal_response = NVO_RS_READY;
            }
            break;
    #endif      // #ifdef API221_READ_ANALOG_DATA

    #ifdef API221_DEVICE_WASH
        case API221_CMD_WASH:
            // Expected Payload:
            //      One byte for the server motor index
            //      Two big-endian bytes for the on time
            //      Two big-endian bytes for the off time
            //      Two big-endian bytes for the velocity
            //      Two big-endian bytes for the acceleration
            //      Two big-endian bytes for the deceleration
            if ((cmd->size >= 11) && (server_motor < API221_SERVER_MOTOR_COUNT))
            {
                EMP_WASH_PARAM_TYPE wash;
                wash.On_Time = Utilities__ConvertArrayTo16bits(&cmd->payload[1]);
                wash.Off_Time = Utilities__ConvertArrayTo16bits(&cmd->payload[3]);
                wash.Velocity = (sint16)Utilities__ConvertArrayTo16bits(&cmd->payload[5]);
                wash.Acceleration = Utilities__ConvertArrayTo16bits(&cmd->payload[7]);
                wash.Deceleration = Utilities__ConvertArrayTo16bits(&cmd->payload[9]);
                if (API221_DEVICE_WASH(server_motor, &wash) == TRUE)
                {
                    #if (API221_MS_TIMEOUT_TO_STOP > 0)
                        // Enable the timeout-based stopping since a command was accepted.
                        Api221.Stop_Timeout[server_motor] = TIMEOUT_TO_STOP;
                    #endif
                    reveal_response = NVO_RS_READY;
                }
                else
                {
                    reveal_response = NVO_RS_UNSUP_UNAVAILABLE;
                }
            }
            break;
    #endif      // #ifdef API221_DEVICE_WASH

    #ifdef API221_DEVICE_ROTATE
        case API221_CMD_ROTATE_X_DEGREES:
            // Expected Payload:
            //      One byte for the server motor index
            //      Two big-endian bytes for the angular distance to rotate (in degrees)
            //      Two big-endian bytes for the velocity
            //      Two big-endian bytes for the acceleration
            if ((cmd->size >= 7) && (server_motor < API221_SERVER_MOTOR_COUNT))
            {
                EMP_ROTATE_PARAM_TYPE rotate;
                rotate.Degrees = (sint16)Utilities__ConvertArrayTo16bits(&cmd->payload[1]);
                rotate.Velocity = (sint16)Utilities__ConvertArrayTo16bits(&cmd->payload[3]);
                rotate.Acceleration = Utilities__ConvertArrayTo16bits(&cmd->payload[5]);
                if (API221_DEVICE_ROTATE(server_motor, &rotate) == TRUE)
                {
                    #if (API221_MS_TIMEOUT_TO_STOP > 0)
                        // Enable the timeout-based stopping since a command was accepted.
                        Api221.Stop_Timeout[server_motor] = TIMEOUT_TO_STOP;
                    #endif
                    reveal_response = NVO_RS_READY;
                }
                else
                {
                    reveal_response = NVO_RS_UNSUP_UNAVAILABLE;
                }
            }
            break;
    #endif      // #ifdef API221_DEVICE_ROTATE

    #ifdef API221_DEVICE_PULSE
        case API221_CMD_PULSE_IMMEDIATE:
        case API221_CMD_PULSE_MODIFY:
        case API221_CMD_PULSE_QUEUE:
            // Expected Payload:
            //      One byte for the server motor index
            //      Two big-endian bytes for the on time
            //      Two big-endian bytes for the off time
            //      Two big-endian bytes for the velocity
            //      Two big-endian bytes for the acceleration
            //      Two big-endian bytes for the deceleration
            if ((cmd->size >= 11) && (server_motor < API221_SERVER_MOTOR_COUNT))
            {
                uint8 command = (EXTERNAL_MOTOR_PULSE_IMMEDIATE + cmd->op_code - API221_CMD_PULSE_IMMEDIATE);
                EMP_PULSE_PARAM_TYPE pulse;
                pulse.On_Time = Utilities__ConvertArrayTo16bits(&cmd->payload[1]);
                pulse.Off_Time = Utilities__ConvertArrayTo16bits(&cmd->payload[3]);
                pulse.Velocity = (sint16)Utilities__ConvertArrayTo16bits(&cmd->payload[5]);
                pulse.Acceleration = Utilities__ConvertArrayTo16bits(&cmd->payload[7]);
                pulse.Deceleration = Utilities__ConvertArrayTo16bits(&cmd->payload[9]);
                if (API221_DEVICE_PULSE(server_motor, (EXTERNAL_MOTOR_SIMPLE_COMMAND_TYPE)command, &pulse) == TRUE)
                {
                    #if (API221_MS_TIMEOUT_TO_STOP > 0)
                        // Enable the timeout-based stopping since a command was accepted.
                        Api221.Stop_Timeout[server_motor] = TIMEOUT_TO_STOP;
                    #endif
                    reveal_response = NVO_RS_READY;
                }
                else
                {
                    reveal_response = NVO_RS_UNSUP_UNAVAILABLE;
                }
            }
            break;
    #endif      // #ifdef API221_DEVICE_PULSE

#endif      // #if (API221_SERVER_FEATURE == ENABLED)
        default:
            reveal_response = NVO_RS_UNSUP_OP_CODE;
            break;
    }

    return reveal_response;
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * This method parses API221 feedbacks sent to a broadcast or exclusively to this node.
 * @param fbk = Pointer to the received feedback message.
 */
void API221MotionCtrl__FeedbackParser(REVEAL_MSG_TYPE* fbk)
{
    // Parse the command based on the OpCode.
    switch (fbk->op_code)
    {
#if (API221_CLIENT_FEATURE == ENABLED)
        case API221_FBK_PUBLISH_EVENT:
            // Expected Payload:
            //      One byte for the server motor index
            //      One byte for event code (0-63)
            if (fbk->size >= 2)
            {
                uint8 client_motor = ConvertServerMotorIndexToClientMotorIndex(fbk->node_id, fbk->payload[0]);
                if (client_motor < API221_SYSTEM_MOTOR_COUNT)
                {
                    uint8 event = ((client_motor << 6) & 0xC0) + (fbk->payload[1] & 0x3F);
                    Callback__Notify(&Api221_Callback, event);
                }
            }
            break;

    #if (API221_STORED_ANALOG_INPUTS > 0)
        case API221_FBK_PUBLISH_ANALOG_DATA:
        case API221_FBK_PUBLISH_PERIODIC_DATA:
            // Expected Payload:
            //      6 Bytes for each analog value:
            //          One byte for the server motor index
            //          One byte for analog data channel
            //          Four little-endian bytes for signed data
            if (fbk->size >= sizeof(API221_ANALOG_DATA_TYPE))
            {
                API221_ANALOG_DATA_TYPE* data = (API221_ANALOG_DATA_TYPE*)(void*)(fbk->payload);
                uint8 count = fbk->size / sizeof(API221_ANALOG_DATA_TYPE);
                for (uint8 i = 0; i < count; i++)
                {
                    data[i].Motor = ConvertServerMotorIndexToClientMotorIndex(fbk->node_id, data[i].Motor);
                    if (data[i].Motor < API221_SYSTEM_MOTOR_COUNT)
                    {
                        StoreAnalogInput(data[i]);
                    }
                }
            }
            break;
    #endif      // #if (API221_STORED_ANALOG_INPUTS > 0)

        case API221_FBK_PUBLISH_FAILURE_FLAGS:
            // Expected Payload:
            //      One byte for the server motor index
            //      Four big-endian bytes for bitmap of failure flags
            if (fbk->size >= 5)
            {
                API221_CLIENT_MOTOR_INDEX_TYPE client_motor = ConvertServerMotorIndexToClientMotorIndex(fbk->node_id, fbk->payload[0]);
                if (client_motor < API221_SYSTEM_MOTOR_COUNT)
                {
                    uint32 failure_flags = Utilities__ConvertArrayTo32bits(&fbk->payload[1]);
                    API221_FAILURES_HANDLER_TYPE* handlers = Api221.Failures_Handler[client_motor];
                    for (uint8 handler_index = 0; handler_index < API221_MAX_FAILURE_EVENT_HANDLERS; handler_index++)
                    {
                        if (handlers[handler_index] == NULL)
                        {
                            // There are no more handlers for the failure flags.
                            break;                  // Break out of the for() loop.
                        }
                        handlers[handler_index](client_motor, failure_flags);
                        handlers[handler_index] = NULL;
                    }
                }
            }
            break;

        case API221_FBK_PUBLISH_MOTOR_STATUS:
            // Expected Payload:
            //      One byte for the server motor index
            //      One byte for the motor status
            if (fbk->size >= 2)
            {
                API221_CLIENT_MOTOR_INDEX_TYPE client_motor = ConvertServerMotorIndexToClientMotorIndex(fbk->node_id, fbk->payload[0]);
                if (client_motor < API221_SYSTEM_MOTOR_COUNT)
                {
                    uint8 status_flags = fbk->payload[1];
                    API221_MOTOR_STATUS_HANDLER_TYPE* handlers = Api221.Motor_Status_Handler[client_motor];
                    for (uint8 handler_index = 0; handler_index < API221_MAX_STATUS_EVENT_HANDLERS; handler_index++)
                    {
                        if (handlers[handler_index] == NULL)
                        {
                            // There are no more handlers for the motor status.
                            break;                  // Break out of the for() loop.
                        }
                        handlers[handler_index](client_motor, status_flags);
                        handlers[handler_index] = NULL;
                    }
                }
            }
            break;

        case API221_FBK_PUBLISH_PERIODIC_DATA_STATUS:
            // Expected Payload:
            //      Two big-endian bytes for publication period in milliseconds
            //      Four big-endian bytes for each motor's channel bitmap
            if ((fbk->size >= 6) && (Api221.Periodic_Data_Status_Handler != NULL))
            {
                uint16 millisecond_period = Utilities__ConvertArrayTo16bits(fbk->payload);
                uint8 num_of_motors = (fbk->size - sizeof(millisecond_period)) / sizeof(uint32);
                uint32* channels_bitmaps = (uint32*)(void*)&fbk->payload[sizeof(millisecond_period)];
                for (uint8 m = 0; m < num_of_motors; m++)
                {
                    channels_bitmaps[m] = Utilities__ConvertArrayTo32bits((uint8*)(void*)&channels_bitmaps[m]);
                }
                Api221.Periodic_Data_Status_Handler(millisecond_period, channels_bitmaps, num_of_motors);
                Api221.Periodic_Data_Status_Handler = NULL;
            }
            break;
#endif      // #if (API221_CLIENT_FEATURE == ENABLED)

        default:
            LOG_ADD_EXCEPTION(FEEDBACK_OPCODE_NOT_SUPPORTED, fbk->op_code);
            break;
    }
}


//=====================================================================================================================
//  --- Public Functions (Client Only) --------------------------------------------------------------------------------
//=====================================================================================================================


#if (API221_CLIENT_FEATURE == ENABLED)
//---------------------------------------------------------------------------------------------------------------------
/**
 * Add analog data channels from the periodically published data.
 * @param client_motor = The value used to uniquely identify the system device on the client.
 * @param channels_bitmap = The analog input channels to add to the request for periodic data.
 *                          Each bit represents an analog data channel.
 * @return TRUE if the request was sent. Otherwise, FALSE.
 */
BOOL_TYPE API221MotionCtrl__AddPeriodicDataChannels(API221_CLIENT_MOTOR_INDEX_TYPE client_motor, uint32 channels_bitmap)
{
    if (client_motor >= API221_SYSTEM_MOTOR_COUNT)
    {
        LOG_ADD_EXCEPTION(INVALID_SYSTEM_MOTOR, COMBINE_BYTES(API221_CMD_ADD_PERIODIC_DATA_CHANNELS, client_motor));
    }
    else
    {
        return RequestPeriodicDataChannels(API221_CMD_ADD_PERIODIC_DATA_CHANNELS, client_motor, channels_bitmap);
    }
    return FALSE;
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Request that all failure flags be cleared for the specified motor.
 * @param client_motor = The value used to uniquely identify the system motor on the client.
 * @return TRUE if the request was sent. Otherwise, FALSE.
 */
BOOL_TYPE API221MotionCtrl__ClearFailureFlags(API221_CLIENT_MOTOR_INDEX_TYPE client_motor)
{
    if (client_motor >= API221_SYSTEM_MOTOR_COUNT)
    {
        LOG_ADD_EXCEPTION(INVALID_SYSTEM_MOTOR, COMBINE_BYTES(API221_CMD_CLEAR_FAILURE_FLAGS, client_motor));
    }
    else
    {
        uint8 motor_node = API221_MOTOR_IDS[client_motor].Communication_Node;
        uint8 server_motor = API221_MOTOR_IDS[client_motor].Motor_Index;
        return Reveal__QueueMessageU8(API221MOTIONCTRL_NUM, API221_CMD_CLEAR_FAILURE_FLAGS, motor_node, TRUE, FALSE, server_motor);
    }
    return FALSE;
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Send a command to run the specified motor or motor-controlled device using a platform-specific behavior.
 * @param client_motor = The value used to uniquely identify the system device on the client.
 * @param buffer = Pointer to an array of platform-specific parameters.
 * @param size = Size of the 'buffer' array.
 * @return TRUE if the request was sent. Otherwise, FALSE.
 */
BOOL_TYPE API221MotionCtrl__DeviceMotion(API221_CLIENT_MOTOR_INDEX_TYPE client_motor, uint8* buffer, uint8 size)
{
    if ((client_motor >= API221_SYSTEM_MOTOR_COUNT) ||
        (buffer == NULL) ||
        (size <= 0) || (EXTERNAL_MOTOR_MAX_COMMAND_SIZE - 1 < size))
    {
        LOG_ADD_EXCEPTION(INVALID_CUSTOM_COMMAND, COMBINE_BYTES((client_motor << 6) | API221_CMD_SET_MOTION_BEHAVIOR, size));
    }
    else
    {
        uint8 motor_node = API221_MOTOR_IDS[client_motor].Communication_Node;
        REVEAL_COMMAND_TYPE* cmd = Reveal__NewCommand(API221MOTIONCTRL_NUM, API221_CMD_SET_MOTION_BEHAVIOR, motor_node, size + 1);
        uint8 server_motor = API221_MOTOR_IDS[client_motor].Motor_Index;
        return (BOOL_TYPE)((Reveal__AddDataU8(cmd, server_motor) == PASS) &&
                           (Reveal__AddDataU8Buffer(cmd, buffer, size) == PASS) &&
                           (Reveal__QueueCommand(cmd) == PASS));
    }
    return FALSE;
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Send a command to run the specified motor or motor-controlled device with the specified pulse pattern.
 * @param client_motor = The value used to uniquely identify the system device on the client.
 * @param command = The type of pulse command.
 * @param pulse = A pointer to the pulse parameters.
 * @return TRUE if the request was sent. Otherwise, FALSE.
 */
BOOL_TYPE API221MotionCtrl__DevicePulse(API221_CLIENT_MOTOR_INDEX_TYPE client_motor, EXTERNAL_MOTOR_SIMPLE_COMMAND_TYPE command, EMP_PULSE_PARAM_TYPE* pulse)
{
    API221MOTIONCTRL_OPCODE_TYPE op_code;
    switch (command)
    {
        case EXTERNAL_MOTOR_PULSE_IMMEDIATE:
            op_code = API221_CMD_PULSE_IMMEDIATE;
            break;

        case EXTERNAL_MOTOR_PULSE_MODIFY:
            op_code = API221_CMD_PULSE_MODIFY;
            break;

        case EXTERNAL_MOTOR_PULSE_QUEUE:
            op_code = API221_CMD_PULSE_QUEUE;
            break;

        default:
            return FALSE;
            break;
    }
    return SendStandardCommand(client_motor, op_code, (uint16*)pulse, sizeof(EMP_PULSE_PARAM_TYPE) / sizeof(uint16));
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Send a command to run the specified motor or motor-controlled device with the angular rotation pattern.
 * @param client_motor = The value used to uniquely identify the system device on the client.
 * @param rotate = A pointer to the rotate parameters.
 * @return TRUE if the request was sent. Otherwise, FALSE.
 */
BOOL_TYPE API221MotionCtrl__DeviceRotate(API221_CLIENT_MOTOR_INDEX_TYPE client_motor, EMP_ROTATE_PARAM_TYPE* rotate)
{
    return SendStandardCommand(client_motor, API221_CMD_ROTATE_X_DEGREES, (uint16*)rotate, sizeof(EMP_ROTATE_PARAM_TYPE) / sizeof(uint16));
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Send a command to run the specified motor or motor-controlled device to a new velocity.
 * @param client_motor = The value used to uniquely identify the system device on the client.
 * @param velocity = The target velocity for the motor or motor-controlled device.
 * @param acceleration = The acceleration rate for the motor or motor-controlled device.
 * @return TRUE if the request was sent. Otherwise, FALSE.
 */
BOOL_TYPE API221MotionCtrl__DeviceRun(API221_CLIENT_MOTOR_INDEX_TYPE client_motor, sint16 velocity, uint16 acceleration)
{
    EMP_RUN_PARAM_TYPE run;
    run.Velocity = velocity;
    run.Acceleration = acceleration;
    return SendStandardCommand(client_motor, API221_CMD_RUN, (uint16*)&run, sizeof(EMP_RUN_PARAM_TYPE) / sizeof(uint16));
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Send a command to stop the specified motor or motor-controlled device.
 * @param client_motor = The value used to uniquely identify the system device on the client.
 * @param deceleration = The deceleration rate for the motor or the motor-controlled device.
 * @return TRUE if the request was sent. Otherwise, FALSE.
 */
BOOL_TYPE API221MotionCtrl__DeviceStop(API221_CLIENT_MOTOR_INDEX_TYPE client_motor, uint16 deceleration)
{
    return SendStandardCommand(client_motor, API221_CMD_STOP, &deceleration, 1);
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Send a command to run the specified motor or motor-controlled device with the specified wash pattern.
 * @param client_motor = The value used to uniquely identify the system device on the client.
 * @param wash = A pointer to the wash parameters.
 * @return TRUE if the request was sent. Otherwise, FALSE.
 */
BOOL_TYPE API221MotionCtrl__DeviceWash(API221_CLIENT_MOTOR_INDEX_TYPE client_motor, EMP_WASH_PARAM_TYPE* wash)
{
    return SendStandardCommand(client_motor, API221_CMD_WASH, (uint16*)wash, sizeof(EMP_WASH_PARAM_TYPE) / sizeof(uint16));
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Get the specified analog input channel.
 * Returns the same value if called again and no new value has been received.
 * @param client_motor = The value used to uniquely identify the system motor on the client.
 * @param channel = The analog input channel whose value is requested.
 * @param data = A pointer to where the value should be stored if it is available.
 * @return TRUE if the analog input value was available and copied into *data; otherwise FALSE.
 */
BOOL_TYPE API221MotionCtrl__GetData(API221_CLIENT_MOTOR_INDEX_TYPE client_motor, uint8 channel, sint32* data)
{
    #if (API221_STORED_ANALOG_INPUTS > 0)
        if ((client_motor < API221_SYSTEM_MOTOR_COUNT) && (channel < 32))
        {
            for (uint8 i = 0; i < API221_STORED_ANALOG_INPUTS; i++)
            {
                API221_ANALOG_DATA_TYPE* stored = &Api221.Data[i].Ai;
                if ((channel == stored->Channel) && (client_motor == stored->Motor))
                {
                    *data = stored->Value;
                    return TRUE;
                }
            }
        }
    #endif      // #if (API221_STORED_ANALOG_INPUTS > 0)
    return FALSE;
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Get the specified analog input only if it is a new value that was not previously read.
 * @param client_motor = The value used to uniquely identify the system motor on the client.
 * @param channel = The analog input channel whose value is requested.
 * @param sync = The synchronization byte used to detect new values that were not previously read.
 * @param data = A pointer to where the value should be stored if it is available.
 * @return TRUE if the analog input value was available, new, and copied into *data; otherwise FALSE.
 */
BOOL_TYPE API221MotionCtrl__GetSynchronizedData(API221_CLIENT_MOTOR_INDEX_TYPE client_motor, uint8 channel, uint8* sync, sint32* data)
{
    #if (API221_STORED_ANALOG_INPUTS > 0)
        if ((client_motor < API221_SYSTEM_MOTOR_COUNT) && (channel < 32))
        {
            for (uint8 i = 0; i < API221_STORED_ANALOG_INPUTS; i++)
            {
                API221_STORED_DATA_TYPE* stored = &Api221.Data[i];
                if ((channel == stored->Ai.Channel) && (client_motor == stored->Ai.Motor) && (*sync != stored->Sequence))
                {
                    *data = stored->Ai.Value;
                    *sync = stored->Sequence;
                    return TRUE;
                }
            }
        }
    #endif      // #if (API221_STORED_ANALOG_INPUTS > 0)
    return FALSE;
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Determine whether the specified motor is present on the communications bus.
 * @param client_motor = The value used to uniquely identify the system device on the client.
 * @return TRUE if the specified motor is present on the communications bus; otherwise, FALSE.
 */
BOOL_TYPE API221MotionCtrl__IsMotorPresentOnBus(API221_CLIENT_MOTOR_INDEX_TYPE client_motor)
{
    if (client_motor < API221_SYSTEM_MOTOR_COUNT)
    {
        uint8 motor_node = API221_MOTOR_IDS[client_motor].Communication_Node;
        return (BOOL_TYPE)(BIT_TEST(Reveal__GetNodestatus(), motor_node));
    }
    return FALSE;
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Inform the server that the client is still present and wishes to keep the control of the motor unchanged.
 * @param client_motor = The client-side motor index for the motor whose control should remain unchanged.
 * @return TRUE if the message was successfully sent; otherwise, FALSE.
 */
BOOL_TYPE API221MotionCtrl__KeepRunning(API221_CLIENT_MOTOR_INDEX_TYPE client_motor)
{
    if (client_motor < API221_SYSTEM_MOTOR_COUNT)
    {
        uint8 motor_node = API221_MOTOR_IDS[client_motor].Communication_Node;
        uint8 server_motor = API221_MOTOR_IDS[client_motor].Motor_Index;
        return Reveal__QueueMessageU8(API221MOTIONCTRL_NUM, API221_CMD_KEEP_RUNNING, motor_node, TRUE, FALSE, server_motor);
    }
    return FALSE;
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Register for motor events received on the communications bus.
 * @param event_handler = Pointer to a function that handles motor events.
 */
void API221MotionCtrl__RegisterForEvents(API221_EVENT_MOTOR_HANDLER_TYPE event_handler)
{
    Callback__Register(&Api221_Callback, (CALLBACK_HANDLER_TYPE)(void*)event_handler);
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Remove analog data channels from the periodically published data.
 * @param client_motor = The value used to uniquely identify the system device on the client.
 * @param channels = The analog input channels to remove from the request for periodic data.
 *                   Each bit represents an analog data channel.
 * @return TRUE if the request was sent. Otherwise, FALSE.
 */
BOOL_TYPE API221MotionCtrl__RemovePeriodicDataChannels(API221_CLIENT_MOTOR_INDEX_TYPE client_motor, uint32 channels)
{
    if (client_motor >= API221_SYSTEM_MOTOR_COUNT)
    {
        LOG_ADD_EXCEPTION(INVALID_SYSTEM_MOTOR, COMBINE_BYTES(API221_CMD_REMOVE_PERIODIC_DATA_CHANNELS, client_motor));
    }
    else
    {
        return RequestPeriodicDataChannels(API221_CMD_REMOVE_PERIODIC_DATA_CHANNELS, client_motor, channels);
    }
    return FALSE;
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Request an analog input for a specified motor from the remote device.
 * The caller can use synchronized data and polling to know when the requested value has been received.
 * @param client_motor = The value used to uniquely identify the system device on the client.
 * @param channel = The analog input channel whose value is requested.
 * @return TRUE if the request was sent. Otherwise, FALSE.
 */
BOOL_TYPE API221MotionCtrl__RequestAnalogData(API221_CLIENT_MOTOR_INDEX_TYPE client_motor, uint8 channel)
{
    if (client_motor >= API221_SYSTEM_MOTOR_COUNT)
    {
        LOG_ADD_EXCEPTION(INVALID_SYSTEM_MOTOR, COMBINE_BYTES(API221_CMD_REQUEST_ANALOG_DATA, client_motor));
    }
    else
    {
        uint8 motor_node = API221_MOTOR_IDS[client_motor].Communication_Node;
        REVEAL_COMMAND_TYPE* cmd = Reveal__NewCommand(API221MOTIONCTRL_NUM, API221_CMD_REQUEST_ANALOG_DATA, motor_node, 2);
        uint8 server_motor = API221_MOTOR_IDS[client_motor].Motor_Index;
        return (BOOL_TYPE)((Reveal__AddDataU8(cmd, server_motor) == PASS) &&
                           (Reveal__AddDataU8(cmd, channel) == PASS) &&
                           (Reveal__QueueCommand(cmd) == PASS));
    }
    return FALSE;
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Request all failure flags from the node that controls the specified motor.
 * @param client_motor = The value used to uniquely identify the system motor on the client.
 * @param failures_handler = Pointer to a function that can handle the motor failure flags message.
 * @return TRUE if the request was sent. Otherwise, FALSE.
 */
BOOL_TYPE API221MotionCtrl__RequestFailureFlags(API221_CLIENT_MOTOR_INDEX_TYPE client_motor, API221_FAILURES_HANDLER_TYPE failures_handler)
{
    BOOL_TYPE result = FALSE;
    if (client_motor >= API221_SYSTEM_MOTOR_COUNT)
    {
        LOG_ADD_EXCEPTION(INVALID_SYSTEM_MOTOR, COMBINE_BYTES(API221_CMD_REQUEST_FAILURE_FLAGS, client_motor));
    }
    else if (failures_handler != NULL)
    {
        API221_FAILURES_HANDLER_TYPE* handlers = Api221.Failures_Handler[client_motor];
        for (uint8 handler_index = 0; handler_index < API221_MAX_FAILURE_EVENT_HANDLERS; handler_index++)
        {
            if ((handlers[handler_index] == NULL) ||
                (handlers[handler_index] == failures_handler))
            {
                // Found an open slot for a failure flags handler.
                result = TRUE;                      // Assume that the request was already sent.
                if (handler_index == 0)
                {
                    // Since this is the first request, send the request message.
                    uint8 motor_node = API221_MOTOR_IDS[client_motor].Communication_Node;
                    uint8 server_motor = API221_MOTOR_IDS[client_motor].Motor_Index;
                    result = Reveal__QueueMessageU8(API221MOTIONCTRL_NUM, API221_CMD_REQUEST_FAILURE_FLAGS, motor_node, TRUE, FALSE, server_motor);
                }
                if (result == TRUE)
                {
                    handlers[handler_index] = failures_handler;
                }
                break;                              // Break out of the for() loop.
            }
        }
    }
    return result;
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Request the current settings for the periodic data feature.
 * @param client_motor = Used to identify the server based on just one of the motors that it controls.
 * @param per_data_status_handler = Pointer to a function that can handle the periodic data status message.
 * @return TRUE if the request was sent. Otherwise FALSE.
 */
BOOL_TYPE API221MotionCtrl__RequestPeriodicDataStatus(API221_CLIENT_MOTOR_INDEX_TYPE client_motor, API221_PER_DATA_STATUS_HANDLER_TYPE per_data_status_handler)
{
    if (client_motor >= API221_SYSTEM_MOTOR_COUNT)
    {
        LOG_ADD_EXCEPTION(INVALID_SYSTEM_MOTOR, COMBINE_BYTES(API221_CMD_REQUEST_PERIODIC_DATA_STATUS, client_motor));
    }
    else if (per_data_status_handler != NULL)
    {
        Api221.Periodic_Data_Status_Handler = per_data_status_handler;
        uint8 motor_node = API221_MOTOR_IDS[client_motor].Communication_Node;
        return Reveal__QueueMessageNoData(API221MOTIONCTRL_NUM, API221_CMD_REQUEST_PERIODIC_DATA_STATUS, motor_node, TRUE, FALSE);
    }
    return FALSE;
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Request the current status of a motor.
 * @param client_motor = Motor for which the status is being requested.
 * @param motor_status_handler = Pointer to a function that can handle the motor status message.
 * @return TRUE if the request was sent. Otherwise FALSE.
 */
BOOL_TYPE API221MotionCtrl__RequestStatus(API221_CLIENT_MOTOR_INDEX_TYPE client_motor, API221_MOTOR_STATUS_HANDLER_TYPE motor_status_handler)
{
    BOOL_TYPE result = FALSE;
    if (client_motor >= API221_SYSTEM_MOTOR_COUNT)
    {
        LOG_ADD_EXCEPTION(INVALID_SYSTEM_MOTOR, COMBINE_BYTES(API221_CMD_REQUEST_MOTOR_STATUS, client_motor));
    }
    else if (motor_status_handler != NULL)
    {
        API221_MOTOR_STATUS_HANDLER_TYPE* handlers = Api221.Motor_Status_Handler[client_motor];
        for (uint8 handler_index = 0; handler_index < API221_MAX_STATUS_EVENT_HANDLERS; handler_index++)
        {
            if ((handlers[handler_index] == NULL) ||
                (handlers[handler_index] == motor_status_handler))
            {
                // Found an open slot for a motor status handler.
                result = TRUE;                      // Assume that the request was already sent.
                if (handler_index == 0)
                {
                    // Since this is the first request, send the request message.
                    uint8 motor_node = API221_MOTOR_IDS[client_motor].Communication_Node;
                    uint8 server_motor = API221_MOTOR_IDS[client_motor].Motor_Index;
                    result = Reveal__QueueMessageU8(API221MOTIONCTRL_NUM, API221_CMD_REQUEST_MOTOR_STATUS, motor_node, TRUE, FALSE, server_motor);
                }
                if (result == TRUE)
                {
                    handlers[handler_index] = motor_status_handler;
                }
                break;                              // Break out of the for() loop.
            }
        }
    }
    return FALSE;
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Set the data publication period for data that is periodically published by a motor controller.
 * If the requested data publication period is not supported, the motor controller will NAK the command.
 * Note that only one period is supported at a time. So, if a motor controller controls two
 * motors, then the last requested data publication period will be used for both motors.
 * @param client_motor = The value used to uniquely identify the system device on the client.
 * @param milliseconds = The requested number of milliseconds between publishing periodic data.
 * @return TRUE if the request was sent. Otherwise, FALSE.
 */
BOOL_TYPE API221MotionCtrl__SetDataPublicationPeriod(API221_CLIENT_MOTOR_INDEX_TYPE client_motor, uint16 milliseconds)
{
    if (client_motor >= API221_SYSTEM_MOTOR_COUNT)
    {
        LOG_ADD_EXCEPTION(INVALID_SYSTEM_MOTOR, COMBINE_BYTES(API221_CMD_SET_DATA_PUBLICATION_PERIOD, client_motor));
    }
    else
    {
        uint8 motor_node = API221_MOTOR_IDS[client_motor].Communication_Node;
        return Reveal__QueueMessageU16(API221MOTIONCTRL_NUM, API221_CMD_SET_DATA_PUBLICATION_PERIOD, motor_node, TRUE, FALSE, milliseconds);
    }
    return FALSE;
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Synchronize the client so that it can receive only new samples of the analog inputs as they are received.
 * @param client_motor = The value used to uniquely identify the system motor on the client.
 * @param channel = The analog input channel whose value is requested.
 * @param sync = Pointer to a byte used to synchronize the client.
 */
void API221MotionCtrl__SynchronizeData(API221_CLIENT_MOTOR_INDEX_TYPE client_motor, uint8 channel, uint8* sync)
{
    #if (API221_STORED_ANALOG_INPUTS > 0)
        for (uint8 i = 0; i < API221_STORED_ANALOG_INPUTS; i++)
        {
            API221_STORED_DATA_TYPE* stored = &Api221.Data[i];
            if ((channel == stored->Ai.Channel) && (client_motor == stored->Ai.Motor))
            {
                *sync = stored->Sequence;
                return;
            }
        }
    #endif      // #if (API221_STORED_ANALOG_INPUTS > 0)
    *sync = UCHAR_MAX;                              // Consider any data found as new data.
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Unregister for motor events received on the communications bus.
 * @param event_handler = Pointer to a function that handles motor events.
 */
void API221MotionCtrl__UnregisterForEvents(API221_EVENT_MOTOR_HANDLER_TYPE event_handler)
{
    Callback__Unregister(&Api221_Callback, (CALLBACK_HANDLER_TYPE)(void*)event_handler);
}
#endif      // #if (API221_CLIENT_FEATURE == ENABLED)


//=====================================================================================================================
//  --- Public Functions (Server Only) --------------------------------------------------------------------------------
//=====================================================================================================================


#if (API221_SERVER_FEATURE == ENABLED)
//---------------------------------------------------------------------------------------------------------------------
/**
 * Publish a motor event on the communications bus.
 * @param server_motor = The server-based motor index.
 * @param event = The specific event value to publish.
 * @return TRUE if the request was sent. Otherwise, FALSE.
 */
BOOL_TYPE API221MotionCtrl__PostEvent(uint8 server_motor, API221_MOTOR_EVENT_TYPE event)
{
    if ((server_motor < API221_SERVER_MOTOR_COUNT) && (event < API221_EVENT_COUNT))
    {
        REVEAL_COMMAND_TYPE* msg = Reveal__NewFeedback(API221MOTIONCTRL_NUM, API221_FBK_PUBLISH_EVENT, REVEAL_BROADCAST_NODE, 2);
        return (BOOL_TYPE)((Reveal__AddDataU8(msg, server_motor) == PASS) &&
                           (Reveal__AddDataU8(msg, event) == PASS) &&
                           (Reveal__QueueCommand(msg) == PASS));
    }
    return FALSE;
}
#endif      // #if (API221_SERVER_FEATURE == ENABLED)


//=====================================================================================================================
//  --- Private Functions (Client) ------------------------------------------------------------------------------------
//=====================================================================================================================


#if (API221_CLIENT_FEATURE == ENABLED)
//---------------------------------------------------------------------------------------------------------------------
/**
 * Convert the motor ID communicated on API221 to a client-side motor index.
 * @param server_motor = The server-side motor index.
 * @return The client-side motor index or an out-of-range value if there is no corresponding motor index.
 */
static API221_CLIENT_MOTOR_INDEX_TYPE ConvertServerMotorIndexToClientMotorIndex(uint8 node, uint8 server_motor)
{
    for (uint8 client_motor = 0; client_motor < API221_SYSTEM_MOTOR_COUNT; client_motor++)
    {
        if ((API221_MOTOR_IDS[client_motor].Communication_Node == node) &&
            (API221_MOTOR_IDS[client_motor].Motor_Index == server_motor))
        {
            return (API221_CLIENT_MOTOR_INDEX_TYPE)client_motor;
        }
    }
    return (API221_CLIENT_MOTOR_INDEX_TYPE)API221_SYSTEM_MOTOR_COUNT;
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Update the request for periodic publication of analog data channels.
 * All these parameters are guaranteed to be in range since they are controlled within this module.
 * @param op_code = Either API221_CMD_ADD_PERIODIC_DATA_CHANNELS or API221_CMD_REMOVE_PERIODIC_DATA_CHANNELS
 * @param client_motor = The value used to uniquely identify the system device on the client.
 * @param channels = The analog input channels to remove from the request for periodic data.
 *                   Each bit represents an analog data channel.
 * @return TRUE if the request was sent. Otherwise, FALSE.
 */
static BOOL_TYPE RequestPeriodicDataChannels(API221MOTIONCTRL_OPCODE_TYPE op_code, API221_CLIENT_MOTOR_INDEX_TYPE client_motor, uint32 channels)
{
    uint8 motor_node = API221_MOTOR_IDS[client_motor].Communication_Node;
    REVEAL_COMMAND_TYPE* cmd = Reveal__NewCommand(API221MOTIONCTRL_NUM, op_code, motor_node, 5);
    uint8 server_motor = API221_MOTOR_IDS[client_motor].Motor_Index;
    return (BOOL_TYPE)((Reveal__AddDataU8(cmd, server_motor) == PASS) &&
                       (Reveal__AddDataU32(cmd, channels) == PASS) &&
                       (Reveal__QueueCommand(cmd) == PASS));
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Send a standard command to the specified motor or motor-controlled device.
 * All standard commands contain arrays of uint16 values stored in little-endian format that must
 * be converted to big-endian format in the Reveal message.
 * @param client_motor = The value used to uniquely identify the system device on the client.
 * @param op_code = The Reveal OpCode that identifies the type of standard command.
 * @param params = A pointer to the uint16 parameters that should be placed on the Reveal payload.
 * @param size = The number of bytes to copy from the params[] array.
 * @return TRUE if the request was sent. Otherwise, FALSE.
 */
static BOOL_TYPE SendStandardCommand(API221_CLIENT_MOTOR_INDEX_TYPE client_motor, API221MOTIONCTRL_OPCODE_TYPE op_code, uint16* params, uint8 num_of_params)
{
    uint8 size = 2 * num_of_params + 1;
    if ((client_motor >= API221_SYSTEM_MOTOR_COUNT) ||
        (params == NULL) ||
        (size <= 1) || (EXTERNAL_MOTOR_MAX_COMMAND_SIZE < size))
    {
        LOG_ADD_EXCEPTION(INVALID_STANDARD_COMMAND, COMBINE_BYTES((client_motor << 6) | op_code, num_of_params));
    }
    else
    {
        uint8 motor_node = API221_MOTOR_IDS[client_motor].Communication_Node;
        REVEAL_COMMAND_TYPE* cmd = Reveal__NewCommand(API221MOTIONCTRL_NUM, op_code, motor_node, size);
        uint8 server_motor = API221_MOTOR_IDS[client_motor].Motor_Index;
        if (Reveal__AddDataU8(cmd, server_motor) == PASS)
        {
            for (uint8 param_index = 0; param_index < num_of_params; param_index++)
            {
                if (Reveal__AddDataU16(cmd, params[param_index]) == FAIL)
                {
                    return FALSE;
                }
            }
            return (BOOL_TYPE)(Reveal__QueueCommand(cmd) == PASS);
        }
    }
    return FALSE;
}


#if (API221_STORED_ANALOG_INPUTS > 0)
//---------------------------------------------------------------------------------------------------------------------
/**
 * Insert an analog input value into the array of all analog input values, Api221.Data[].
 * Replace any previously stored analog input value with the same analog input ID.
 * Maintain the array order so that the analog input values are sorted from newest to oldest.
 * Drop the oldest analog input value if it does not fit in the array.
 * Api221.Data[0] will contain the inserted analog input value when done.
 * @param data = The structure that holds the motor index, channel index, and analog input value.
 */
static void StoreAnalogInput(API221_ANALOG_DATA_TYPE data)
{
    // Look for the presence of the analog input ID in the existing stored data array.
    uint8 num_of_analog_inputs_to_shift = API221_STORED_ANALOG_INPUTS - 1;
    uint8 new_sequence_number = 0;                  // Assume this is the first occurrence in the stored data.

    // The last analog input must be checked to avoid unnecessarily losing the sequence number.
    for (uint8 i = 0; i < API221_STORED_ANALOG_INPUTS; i++)
    {
        API221_STORED_DATA_TYPE* stored = &Api221.Data[i];

        if ((stored->Ai.Channel == data.Channel) && (stored->Ai.Motor == data.Motor))
        {
            num_of_analog_inputs_to_shift = i;
            if (stored->Sequence < UCHAR_MAX - 1)
            {
                new_sequence_number = stored->Sequence + 1;
            }
            else
            {
                new_sequence_number = 1;
            }
            break;                                  // Out of the for() loop.
        }
    }

    // Shift the array elements.
    //      This will remove any previously stored copy of the analog input, and...
    //      it will make space for the new analog input at the start of the array.
    if (num_of_analog_inputs_to_shift > 0)
    {
        memmove(&Api221.Data[1], &Api221.Data[0],
                num_of_analog_inputs_to_shift * sizeof(API221_STORED_DATA_TYPE));
    }

    // Store the new analog input at the start of the array.
    Api221.Data[0].Ai = data;
    Api221.Data[0].Sequence = new_sequence_number;
}
#endif      // #if (API221_STORED_ANALOG_INPUTS > 0)
#endif      // #if (API221_CLIENT_FEATURE == ENABLED)


//=====================================================================================================================
//  --- Private Functions (Server) ------------------------------------------------------------------------------------
//=====================================================================================================================


#if (API221_SERVER_FEATURE == ENABLED)
//---------------------------------------------------------------------------------------------------------------------
/**
 * Get the status bits for the specified motor.
 * @param server_motor = The server-side motor index whose status is requested.
 * @return The status bits for the specified motor.
 */
static uint8 GetMotorStatus(uint8 server_motor)
{
    return (API221_READ_MOTOR_STATUS(server_motor));
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Publish the status for a specific motor controlled by the server.
 * @param requesting_node = The node that requested the motor status.
 * @param server_motor = The server-side motor index whose status should be published.
 * @return TRUE if the request was sent. Otherwise FALSE.
 */
static BOOL_TYPE PublishMotorStatus(uint8 requesting_node, uint8 server_motor)
{
    REVEAL_COMMAND_TYPE* msg = Reveal__NewFeedback(API221MOTIONCTRL_NUM, API221_FBK_PUBLISH_MOTOR_STATUS, requesting_node, 2);
    uint8 status = GetMotorStatus(server_motor);
    return (BOOL_TYPE)((Reveal__AddDataU8(msg, server_motor) == PASS) &&
                       (Reveal__AddDataU8(msg, status) == PASS) &&
                       (Reveal__QueueCommand(msg) == TRUE));
}


#ifdef API221_READ_ANALOG_DATA
//---------------------------------------------------------------------------------------------------------------------
/**
 * Publish a single analog input value.
 * @param requesting_node = The node that requested the analog input value.
 * @param server_motor = The server-side motor index whose analog data should be published.
 * @param channel = The analog input ID.
 * @return TRUE if the request was sent. Otherwise, FALSE.
 */
static BOOL_TYPE PublishAnalogData(uint8 requesting_node, uint8 server_motor, uint8 channel)
{
    REVEAL_COMMAND_TYPE* msg = Reveal__NewFeedback(API221MOTIONCTRL_NUM, API221_FBK_PUBLISH_ANALOG_DATA, requesting_node, sizeof(API221_ANALOG_DATA_TYPE));
    return (BOOL_TYPE)((RevealAddAnalogInput(msg, server_motor, channel) == PASS) &&
                       (Reveal__QueueCommand(msg) == PASS));
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Publish all the requested analog inputs.
 * @return TRUE if a message with the analog inputs was sent to Reveal; otherwise FALSE.
 */
static BOOL_TYPE PublishPeriodicData(void)
{
    // Determine the size of the payload.
    if (Api221.Num_Of_Requested_Analog_Inputs == 0)
    {
        return TRUE;                                // Stop -- successfully published no data.
    }
    uint8 payload_size = Api221.Num_Of_Requested_Analog_Inputs * sizeof(API221_ANALOG_DATA_TYPE);

    // Create a feedback message.
    REVEAL_COMMAND_TYPE* msg = Reveal__NewFeedback(API221MOTIONCTRL_NUM, API221_FBK_PUBLISH_PERIODIC_DATA, Api221.Requesting_Node, payload_size);
    if (msg == NULL)
    {
        return FALSE;                               // Could not get a Reveal feedback message.
    }

    // Iterate through all the server_motors and their associated analog inputs.
    for (uint8 server_motor = 0; server_motor < API221_SERVER_MOTOR_COUNT; server_motor++)
    {
        uint32 requested = Api221.Requested[server_motor];
        for (uint8 channel = 0; requested > 0; channel++)
        {
            if (BIT_TEST(requested, channel) != 0)
            {
                // Analog input 'channel' is requested for 'server_motor'.
                BIT_CLR(requested, channel);
                if (RevealAddAnalogInput(msg, server_motor, channel) == FAIL)
                {
                    return FALSE;                   // Failed to add the analog input to the payload.
                }
            }
        }
    }
    return (BOOL_TYPE)(Reveal__QueueCommand(msg) == PASS);
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Publish information about the current status of the periodic publication feature.
 * @param requesting_node = The node to which the periodic data should be sent.
 * @return TRUE if the packet was sent successfully. Otherwise FALSE.
 */
static BOOL_TYPE PublishPeriodicDataStatus(uint8 requesting_node)
{
    REVEAL_COMMAND_TYPE* msg = Reveal__NewFeedback(API221MOTIONCTRL_NUM,
                                                   API221_FBK_PUBLISH_PERIODIC_DATA_STATUS,
                                                   requesting_node,
                                                   sizeof(uint16) + API221_SERVER_MOTOR_COUNT * sizeof(uint32));
    PASS_FAIL_TYPE pass = Reveal__AddDataU16(msg, API221_MS_PER_CALL_TO_BACKGROUND * Api221.Publication_Period);
    for (uint8 server_motor = 0; (pass == PASS) && (server_motor < API221_SERVER_MOTOR_COUNT); server_motor++)
    {
        pass = Reveal__AddDataU32(msg, Api221.Requested[server_motor]);
    }

    if (pass == PASS)
    {
        return (BOOL_TYPE)Reveal__QueueCommand(msg);
    }
    else
    {
        return FALSE;
    }
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Add a single analog input to a Reveal packet that is under construction.
 * @param msg = Pointer to the REVEAL_COMMAND_TYPE that holds the message being built.
 * @param server_motor = The server-side motor index.
 * @param channel = The analog input ID.
 * @return PASS if the analog input data was successful added to the Reveal message; otherwise FAIL.
 */
static PASS_FAIL_TYPE RevealAddAnalogInput(REVEAL_COMMAND_TYPE* msg, uint8 server_motor, uint8 channel)
{
    API221_ANALOG_DATA_TYPE ai;
    ai.Motor = server_motor;
    ai.Channel = channel;
    ai.Value = API221_READ_ANALOG_DATA(server_motor, channel);

    return Reveal__AddDataU8Buffer(msg, (uint8*)(void*)&ai, sizeof(API221_ANALOG_DATA_TYPE));
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Set the publication period for all periodic data published by this communication node.
 * @param milliseconds = The requested number of milliseconds between periodically published data.
 * @return TRUE if the requested period is supported; otherwise FALSE.
 */
static BOOL_TYPE SetPublicationPeriod(uint8 node, uint16 milliseconds)
{
    if ((milliseconds == 0) || (milliseconds >= MINIMUM_PUBLICATION_MILLISECONDS))
    {
        // Verify that the requested millisecond publication rate can be supported.
        uint16 calls_to_background = milliseconds / API221_MS_PER_CALL_TO_BACKGROUND;
        if ((calls_to_background <= UCHAR_MAX) &&
            (calls_to_background * API221_MS_PER_CALL_TO_BACKGROUND == milliseconds))
        {
            if (Api221.Publication_Period != (uint8)calls_to_background)
            {
                Api221.Publication_Period = (uint8)calls_to_background;
            }
            Api221.Requesting_Node = node;
            return TRUE;
        }
    }
    return FALSE;
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * Add or remove analog data channels from the list of periodically published data.
 * @param add = TRUE to add channels; FALSE to remove channels.
 * @param server_motor = The server-side motor index.
 * @param channels = A mask of the analog data channels to add or remove.
 *                   Bit 'n' of this value represents an analog data channel #n.
 */
static void UpdatePeriodicDataChannels(BOOL_TYPE add, uint8 server_motor, uint32 channels)
{
    if (add == TRUE)
    {
        Api221.Requested[server_motor] |= channels;
    }
    else
    {
        Api221.Requested[server_motor] &= ~channels;
    }
    Api221.Num_Of_Requested_Analog_Inputs = Utilities__CountOneBitsInArray((uint8*)(Api221.Requested), sizeof(Api221.Requested));   //lint !e928 Suppress Info: cast from pointer to pointer [MISRA 2004 rule 11.4]
}
#endif      // #ifdef API221_READ_ANALOG_DATA


#ifdef API221_READ_FAILURE_FLAGS
//---------------------------------------------------------------------------------------------------------------------
/**
 * Publish all the failure flags.
 * @param requesting_node = The node that requested the failure flags.
 * @param server_motor = The server-side motor index which is associated with the failure flags.
 * @return NVO_RS_READY if the message was successfully sent; otherwise NVO_RS_REJECTED.
 */
static REVEAL_RECIPE_STATUS_TYPE PublishFailureFlags(uint8 requesting_node, uint8 server_motor)
{
    REVEAL_COMMAND_TYPE* msg = Reveal__NewFeedback(API221MOTIONCTRL_NUM, API221_FBK_PUBLISH_FAILURE_FLAGS, requesting_node, 5);
    if ((Reveal__AddDataU8(msg, server_motor) == PASS) &&
        (Reveal__AddDataU32(msg, API221_READ_FAILURE_FLAGS(server_motor)) == PASS) &&
        (Reveal__QueueCommand(msg) == PASS))
    {
        return NVO_RS_READY;
    }
    else
    {
        return NVO_RS_REJECTED;
    }
}
#endif      // #ifdef API221_READ_FAILURE_FLAGS

#endif      // #if (API221_SERVER_FEATURE == ENABLED)

#endif      // #if ((API221_CLIENT_FEATURE == ENABLED) || (API221_SERVER_FEATURE == ENABLED))
