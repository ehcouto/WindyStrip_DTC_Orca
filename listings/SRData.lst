###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        19/Nov/2024  13:15:43
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  XCategory\Common\SRData\SRData.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        SRData.obj -l ..\listings\SRData.lst XCategory\Common\SRData\SRData.c
#    List file    =  ..\listings\SRData.lst
#    Object file  =  SRData.obj
#
###############################################################################

C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Common\SRData\SRData.c
      1          /**
      2           *  @file
      3           *  @defgroup CLASS_B
      4           *  @brief      This module handle the update and check of SR (Safety Relevant) Data.
      5           *
      6           *  @details    There is a set of functions for Byte,Short, Long ,Array of Bytes and floats.
      7           *  <pre>
      8           *  Related to the usage this module it's required that the variable and its complement should have a separation in memory.
      9           *  so they should not be next each other.
     10           *  We recommend 32bits of space in between the variables
     11           *  When declaring variables it can be done by declaring all the variables and after that all the complements.
     12           *  For example:
     13           *
     14           *      uint8 A;
     15           *      uint16 B;
     16           *      uint8 C
     17           *      uint32 D
     18           *
     19           *      uint8 NA;
     20           *      uint16 NB;
     21           *      uint8 NC;
     22           *      uint32 ND;
     23           *
     24           *  The spacce in betwee a variable and its complement recommended is minimum of 32bits.
     25           * </pre>
     26           *
     27           *  $Header: SRData.c 1.22 2014/10/30 14:32:43EDT MANOEL GARBUIO DE SOUZA (SOUZAMG) Exp  $
     28           *
     29           *  @copyright  Copyright 2007-$Date: 2014/10/30 14:32:43EDT $. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     30           */
     31          //---------------------------------------------------------------------------------------------------------------------
     32          //---------------------------------------------------------------------------------------------------------------------
     33          
     34          //-------------------------------------- Include Files ----------------------------------------------------------------
     35          #include "C_Extensions.h"
     36          #include "SRData.h"
     37          #include "SRException.h"
     38          #include "Micro.h"
     39          
     40          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     41          
     42          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     43          
     44          
     45          #define SRDATA__COMPLEMENT(data)    (~(data))
     46          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
     47          #if (SRDATA_FLOAT_FEATURE == ENABLED)
     48              typedef union
     49              {
     50                  float32 vfloat;
     51                  uint32 vlong;
     52              }SRDATA_CONVERTION_F_L_TYPE;
     53          #endif
     54          //=====================================================================================================================
     55          //-------------------------------------- Public Functions -------------------------------------------------------------
     56          //=====================================================================================================================
     57          
     58          #if (SRDATA_BYTE_FEATURE == ENABLED)
     59          #ifdef __IAR_SYSTEMS_ICC__
     60              #pragma optimize = none
     61          #endif
     62          //---------------------------------------------------------------------------------------------------------------------
     63          /**
     64           * @brief This method updates a Safety Byte Variable and it's backup variable
     65           *
     66           * @param data pointer to the SR data
     67           * @param ndata pointer to the complementary SR data
     68           * @param value value to be updated in the SR variable
     69           */

   \                                 In section .text, align 2, keep-with-next
     70          void SRData__UpdateByte(uint8 * data,uint8 * ndata,uint8 value)
     71          {
   \                     SRData__UpdateByte: (+1)
   \   00000000   0xB410             PUSH     {R4}
     72              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
     73          
     74              //------- ISR Protected Code --------------------------------------------------------------------------------------
     75              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();                              // Save context and disable ISRs
   \   00000002   0xF3EF 0x8410      MRS      R4,PRIMASK
   \   00000006   0x0023             MOVS     R3,R4
   \   00000008   0xB672             CPSID    I
     76              *data = value;                                  // load variable
   \   0000000A   0x7002             STRB     R2,[R0, #+0]
     77              *ndata = SRDATA__COMPLEMENT(value);             // load inverted variable
                              ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \   0000000C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000E   0x43D4             MVNS     R4,R2
   \   00000010   0x700C             STRB     R4,[R1, #+0]
     78              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();                           // Restore the ISR context previously saved.
   \   00000012   0xF383 0x8810      MSR      PRIMASK,R3
     79              //-----------------------------------------------------------------------------------------------------------------
     80          }
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return
     81          
     82          
     83          #ifdef __IAR_SYSTEMS_ICC__
     84          #pragma optimize = none
     85          #endif
     86          //---------------------------------------------------------------------------------------------------------------------
     87          /**
     88           * @brief This method checks the integrity of a Safety Byte Variable and it's backup
     89           *
     90           * @param data pointer to the SR data
     91           * @param ndata pointer to the complementary SR data
     92           * @return Result of the verification
     93           */

   \                                 In section .text, align 2, keep-with-next
     94          SRDATA_CHECK_TYPE SRData__CheckByte(uint8 * data,uint8 * ndata)
     95          {
   \                     SRData__CheckByte: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
     96              volatile uint8 aux;
     97              volatile SRDATA_CHECK_TYPE response;
     98              volatile uint8 mask;
     99              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();          // Defined in SRMicro module, it declares a local variable;
    100              response = SRDATA_OK;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0002      STRB     R0,[SP, #+2]
    101              //------- ISR Protected Code --------------------------------------------------------------------------------------
    102              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();                              // Save context and disable ISRs.
   \   0000000E   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000012   0x0006             MOVS     R6,R0
   \   00000014   0xB672             CPSID    I
    103              aux = SRDATA__COMPLEMENT(*data);
                           ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x43C0             MVNS     R0,R0
   \   0000001A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    104              if (aux != (*ndata) )                           // test variable against it's complement if they don't match it performs a memory test
   \   0000001E   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000022   0x7829             LDRB     R1,[R5, #+0]
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD053             BEQ.N    ??SRData__CheckByte_0
    105              {
    106                  SRException__Queue(SREXCEPTION_SRDATA_NOISE,(uint32)data,(uint32)ndata); //lint !e923 Suppress Info: cast from pointer to unsigned long [Encompasses MISRA 2004 Rule 11.1], [MISRA 2004 Rule 11.3]
   \   00000028   0x002A             MOVS     R2,R5
   \   0000002A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000002C   0x0021             MOVS     R1,R4
   \   0000002E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x.... 0x....      BL       SRException__Queue
    107                  response = SRDATA_CORRUPT_NOISE;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xF88D 0x0002      STRB     R0,[SP, #+2]
    108                  aux = *data;                                // backup data
   \   0000003C   0x7820             LDRB     R0,[R4, #+0]
   \   0000003E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    109                  for (mask=1;mask>0;mask = (mask<<1))        // test variable
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \                     ??SRData__CheckByte_1: (+1)
   \   00000048   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD017             BEQ.N    ??SRData__CheckByte_2
    110                  {
    111                      *data = mask;
   \   00000050   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000054   0x7020             STRB     R0,[R4, #+0]
    112                      if (*data != mask)                      // test bit by bit
   \   00000056   0x7820             LDRB     R0,[R4, #+0]
   \   00000058   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD009             BEQ.N    ??SRData__CheckByte_3
    113                      {
    114                          SRException__Queue(SREXCEPTION_SRDATA_BAD_MEMORY,(uint32)data,(uint32)ndata);   //lint !e923 Suppress Info: cast from pointer to unsigned long [Encompasses MISRA 2004 Rule 11.1], [MISRA 2004 Rule 11.3]
   \   00000060   0x002A             MOVS     R2,R5
   \   00000062   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000064   0x0021             MOVS     R1,R4
   \   00000066   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000068   0x2002             MOVS     R0,#+2
   \   0000006A   0x.... 0x....      BL       SRException__Queue
    115                          response = SRDATA_CORRUPT_BAD_MEMORY;
   \   0000006E   0x2002             MOVS     R0,#+2
   \   00000070   0xF88D 0x0002      STRB     R0,[SP, #+2]
    116                      }
    117                  }
   \                     ??SRData__CheckByte_3: (+1)
   \   00000074   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000078   0x0040             LSLS     R0,R0,#+1
   \   0000007A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000007E   0xE7E3             B.N      ??SRData__CheckByte_1
    118                  *data = aux;                                // restore data
   \                     ??SRData__CheckByte_2: (+1)
   \   00000080   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000084   0x7020             STRB     R0,[R4, #+0]
    119          
    120          
    121                  aux = *ndata;                               // backup inverted variable data
   \   00000086   0x7828             LDRB     R0,[R5, #+0]
   \   00000088   0xF88D 0x0001      STRB     R0,[SP, #+1]
    122                  for (mask=1;mask>0;mask = (mask<<1))        // test the inverted variable
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \                     ??SRData__CheckByte_4: (+1)
   \   00000092   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD017             BEQ.N    ??SRData__CheckByte_5
    123                  {
    124                      *ndata = mask;
   \   0000009A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000009E   0x7028             STRB     R0,[R5, #+0]
    125                      if (*ndata != mask)                     // test bit by bit
   \   000000A0   0x7828             LDRB     R0,[R5, #+0]
   \   000000A2   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000000A6   0x4288             CMP      R0,R1
   \   000000A8   0xD009             BEQ.N    ??SRData__CheckByte_6
    126                      {
    127                          SRException__Queue(SREXCEPTION_SRDATA_BAD_MEMORY,(uint32)data,(uint32)ndata);   //lint !e923 Suppress Info: cast from pointer to unsigned long [Encompasses MISRA 2004 Rule 11.1], [MISRA 2004 Rule 11.3]
   \   000000AA   0x002A             MOVS     R2,R5
   \   000000AC   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000AE   0x0021             MOVS     R1,R4
   \   000000B0   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000B2   0x2002             MOVS     R0,#+2
   \   000000B4   0x.... 0x....      BL       SRException__Queue
    128                          response = SRDATA_CORRUPT_BAD_BACKUP_MEMORY;
   \   000000B8   0x2003             MOVS     R0,#+3
   \   000000BA   0xF88D 0x0002      STRB     R0,[SP, #+2]
    129                      }
    130                  }
   \                     ??SRData__CheckByte_6: (+1)
   \   000000BE   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000C2   0x0040             LSLS     R0,R0,#+1
   \   000000C4   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   000000C8   0xE7E3             B.N      ??SRData__CheckByte_4
    131                  *ndata = aux;                               // restore inverted variable data
   \                     ??SRData__CheckByte_5: (+1)
   \   000000CA   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000000CE   0x7028             STRB     R0,[R5, #+0]
    132              }
    133              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();                           // Restore the ISR context previously saved.
   \                     ??SRData__CheckByte_0: (+1)
   \   000000D0   0xF386 0x8810      MSR      PRIMASK,R6
    134              //-----------------------------------------------------------------------------------------------------------------
    135              return (response);
   \   000000D4   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   000000D8   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    136          }
    137          #endif
    138          
    139          
    140          #if (SRDATA_ARRAY_FEATURE == ENABLED)
    141          #ifdef __IAR_SYSTEMS_ICC__
    142              #pragma optimize = none
    143          #endif
    144          //---------------------------------------------------------------------------------------------------------------------
    145          /**
    146           * @brief This method updates a Safety Array of Byte Variable and it's backup
    147           *
    148           * @param data pointer to the data array
    149           * @param ndata pointer to the backup of the data array
    150           * @param value pointer to the content to be stored in the data
    151           * @param size defines size of the arrays
    152           */

   \                                 In section .text, align 2, keep-with-next
    153          void SRData__UpdateArray(void * data,void * ndata,void * value,size_t size)
    154          {
   \                     SRData__UpdateArray: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    155              size_t index;
    156              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    157          
    158              //------- ISR Protected Code --------------------------------------------------------------------------------------
    159              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();                              // Save context and disable ISRs
   \   00000002   0xF3EF 0x8610      MRS      R6,PRIMASK
   \   00000006   0x0035             MOVS     R5,R6
   \   00000008   0xB672             CPSID    I
    160              for (index =0; index < size; index++)
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0x0034             MOVS     R4,R6
   \                     ??SRData__UpdateArray_0: (+1)
   \   0000000E   0x429C             CMP      R4,R3
   \   00000010   0xD206             BCS.N    ??SRData__UpdateArray_1
    161              {
    162                  ((uint8 *)data)[index] = ((uint8 *)value)[index];   // write variable data
   \   00000012   0x5CA6             LDRB     R6,[R4, R2]
   \   00000014   0x5426             STRB     R6,[R4, R0]
    163                  ((uint8 *)ndata)[index] = SRDATA__COMPLEMENT(((uint8 *)value)[index]); // write inverted variable data
                                                   ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \   00000016   0x5CA6             LDRB     R6,[R4, R2]
   \   00000018   0x43F6             MVNS     R6,R6
   \   0000001A   0x5466             STRB     R6,[R4, R1]
    164              }
   \   0000001C   0x1C64             ADDS     R4,R4,#+1
   \   0000001E   0xE7F6             B.N      ??SRData__UpdateArray_0
    165              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();                           // Restore the ISR context previously saved.
   \                     ??SRData__UpdateArray_1: (+1)
   \   00000020   0xF385 0x8810      MSR      PRIMASK,R5
    166              //-----------------------------------------------------------------------------------------------------------------
    167          }
   \   00000024   0xBC70             POP      {R4-R6}
   \   00000026   0x4770             BX       LR               ;; return
    168          
    169          //---------------------------------------------------------------------------------------------------------------------
    170          #ifdef __IAR_SYSTEMS_ICC__
    171              #pragma optimize = none
    172          #endif
    173          /**
    174           * @brief This method checks the data array and it's backup.
    175           *
    176           * @param data pointer to the data array
    177           * @param ndata pointer to the backup of the data array
    178           * @param size defines size of the arrays
    179           * @return SRDATA_CHECK_TYPE
    180           */

   \                                 In section .text, align 2, keep-with-next
    181          SRDATA_CHECK_TYPE SRData__CheckArray(void * data, void * ndata, size_t size)
    182          {
   \                     SRData__CheckArray: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    183          
    184              volatile uint8 aux;
    185              volatile SRDATA_CHECK_TYPE response;
    186              volatile uint8 mask;
    187              size_t index;
    188              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    189              response = SRDATA_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    190          
    191              //------- ISR Protected Code --------------------------------------------------------------------------------------
    192              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();                              // Save context and disable ISRs
   \   00000012   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000016   0x4680             MOV      R8,R0
   \   00000018   0xB672             CPSID    I
    193          
    194              for (index=0; index< size; index++)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x0007             MOVS     R7,R0
   \                     ??SRData__CheckArray_0: (+1)
   \   0000001E   0x42B7             CMP      R7,R6
   \   00000020   0xD262             BCS.N    ??SRData__CheckArray_1
    195              {
    196                  aux = SRDATA__COMPLEMENT(((uint8 *)data)[index]);
                               ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \   00000022   0x5D38             LDRB     R0,[R7, R4]
   \   00000024   0x43C0             MVNS     R0,R0
   \   00000026   0xF88D 0x0002      STRB     R0,[SP, #+2]
    197                  if (aux !=  ((uint8 *)ndata)[index]  )    // Test each position of data against its inverted position
   \   0000002A   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000002E   0x5D79             LDRB     R1,[R7, R5]
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD057             BEQ.N    ??SRData__CheckArray_2
    198                  {
    199          
    200                      if(response == SRDATA_OK)               // Make sure we don't overwrite a BAD memory exception
   \   00000034   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD109             BNE.N    ??SRData__CheckArray_3
    201                      {
    202                          SRException__Queue(SREXCEPTION_SRDATA_NOISE,(uint32)data,(uint32)ndata);
   \   0000003C   0x002A             MOVS     R2,R5
   \   0000003E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000040   0x0021             MOVS     R1,R4
   \   00000042   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x.... 0x....      BL       SRException__Queue
    203                          response = SRDATA_CORRUPT_NOISE;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    204                      }
    205          
    206                      aux = ((uint8 *)data)[index];         // backup data
   \                     ??SRData__CheckArray_3: (+1)
   \   00000050   0x5D38             LDRB     R0,[R7, R4]
   \   00000052   0xF88D 0x0002      STRB     R0,[SP, #+2]
    207                      for (mask=1;mask>0;mask = (mask<<1))
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \                     ??SRData__CheckArray_4: (+1)
   \   0000005C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD017             BEQ.N    ??SRData__CheckArray_5
    208                      {
    209                          ((uint8 *)data)[index] = mask;
   \   00000064   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000068   0x5538             STRB     R0,[R7, R4]
    210                          if (((uint8 *)data)[index] != mask)   // test bit by bit
   \   0000006A   0x5D38             LDRB     R0,[R7, R4]
   \   0000006C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000070   0x4288             CMP      R0,R1
   \   00000072   0xD009             BEQ.N    ??SRData__CheckArray_6
    211                          {
    212                              SRException__Queue(SREXCEPTION_SRDATA_BAD_MEMORY,(uint32)data,(uint32)ndata);
   \   00000074   0x002A             MOVS     R2,R5
   \   00000076   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000078   0x0021             MOVS     R1,R4
   \   0000007A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000007C   0x2002             MOVS     R0,#+2
   \   0000007E   0x.... 0x....      BL       SRException__Queue
    213                              response = SRDATA_CORRUPT_BAD_MEMORY;
   \   00000082   0x2002             MOVS     R0,#+2
   \   00000084   0xF88D 0x0001      STRB     R0,[SP, #+1]
    214                          }
    215                      }
   \                     ??SRData__CheckArray_6: (+1)
   \   00000088   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000008C   0x0040             LSLS     R0,R0,#+1
   \   0000008E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000092   0xE7E3             B.N      ??SRData__CheckArray_4
    216                      ((uint8 *)data)[index] = aux;         // restore data
   \                     ??SRData__CheckArray_5: (+1)
   \   00000094   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000098   0x5538             STRB     R0,[R7, R4]
    217          
    218                      aux = ((uint8 *)ndata)[index];        // backup inverted data
   \   0000009A   0x5D78             LDRB     R0,[R7, R5]
   \   0000009C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    219                      for (mask=1;mask>0;mask = (mask<<1))
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \                     ??SRData__CheckArray_7: (+1)
   \   000000A6   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD017             BEQ.N    ??SRData__CheckArray_8
    220                      {
    221                          ((uint8 *)ndata)[index] = mask;
   \   000000AE   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000B2   0x5578             STRB     R0,[R7, R5]
    222                          if (((uint8 *)ndata)[index] != mask)  // test bit by bit
   \   000000B4   0x5D78             LDRB     R0,[R7, R5]
   \   000000B6   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000000BA   0x4288             CMP      R0,R1
   \   000000BC   0xD009             BEQ.N    ??SRData__CheckArray_9
    223                          {
    224                              SRException__Queue(SREXCEPTION_SRDATA_BAD_MEMORY,(uint32)data,(uint32)ndata);
   \   000000BE   0x002A             MOVS     R2,R5
   \   000000C0   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000C2   0x0021             MOVS     R1,R4
   \   000000C4   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000C6   0x2002             MOVS     R0,#+2
   \   000000C8   0x.... 0x....      BL       SRException__Queue
    225                              response = SRDATA_CORRUPT_BAD_BACKUP_MEMORY;
   \   000000CC   0x2003             MOVS     R0,#+3
   \   000000CE   0xF88D 0x0001      STRB     R0,[SP, #+1]
    226                          }
    227                      }
   \                     ??SRData__CheckArray_9: (+1)
   \   000000D2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000D6   0x0040             LSLS     R0,R0,#+1
   \   000000D8   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   000000DC   0xE7E3             B.N      ??SRData__CheckArray_7
    228                      ((uint8 *)ndata)[index] = aux;        // restore inverted data
   \                     ??SRData__CheckArray_8: (+1)
   \   000000DE   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   000000E2   0x5578             STRB     R0,[R7, R5]
    229          
    230                  }
    231              }
   \                     ??SRData__CheckArray_2: (+1)
   \   000000E4   0x1C7F             ADDS     R7,R7,#+1
   \   000000E6   0xE79A             B.N      ??SRData__CheckArray_0
    232          
    233          
    234              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();                           // Restore the ISR context previously saved.
   \                     ??SRData__CheckArray_1: (+1)
   \   000000E8   0xF388 0x8810      MSR      PRIMASK,R8
    235              //-----------------------------------------------------------------------------------------------------------------
    236              return (response);
   \   000000EC   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000000F0   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    237          
    238          }
    239          #endif
    240          
    241          
    242          
    243          #if (SRDATA_ARRAY_NON_BLOCKING_FEATURE == ENABLED)
    244          #ifdef __IAR_SYSTEMS_ICC__
    245              #pragma optimize = none
    246          #endif
    247          //---------------------------------------------------------------------------------------------------------------------
    248          /**
    249           * @brief This method updates a Safety Array of Byte Variable and it's backup
    250           * * @details This method will update byte by byte a SR array but it allows interrupts in between bytes. So if there is
    251           * any change of a Array be used by 2 different places where one place can interrupt the other it should be used the set of
    252           * functions that are blocking: SRData__UpdateArray() and SRData__CheckArray();
    253           * @param data pointer to the data array
    254           * @param ndata pointer to the backup of the data array
    255           * @param value pointer to the content to be stored in the data
    256           * @param size defines size of the arrays
    257           */

   \                                 In section .text, align 2, keep-with-next
    258          void SRData__UpdateArrayNonBlocking(void * data,void * ndata,void * value,size_t size)
    259          {
   \                     SRData__UpdateArrayNonBlocking: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    260              size_t index;
    261              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    262          
    263              for (index =0; index < size; index++)
   \   00000002   0x2600             MOVS     R6,#+0
   \   00000004   0x0034             MOVS     R4,R6
   \                     ??SRData__UpdateArrayNonBlocking_0: (+1)
   \   00000006   0x429C             CMP      R4,R3
   \   00000008   0xD20C             BCS.N    ??SRData__UpdateArrayNonBlocking_1
    264              {
    265                  //------- ISR Protected Code --------------------------------------------------------------------------------------
    266                  MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();                              // Save context and disable ISRs
   \   0000000A   0xF3EF 0x8610      MRS      R6,PRIMASK
   \   0000000E   0x0035             MOVS     R5,R6
   \   00000010   0xB672             CPSID    I
    267                  ((uint8 *)data)[index] = ((uint8 *)value)[index];   // write variable data
   \   00000012   0x5CA6             LDRB     R6,[R4, R2]
   \   00000014   0x5426             STRB     R6,[R4, R0]
    268                  ((uint8 *)ndata)[index] = SRDATA__COMPLEMENT(((uint8 *)value)[index]); // write inverted variable data
                                                   ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \   00000016   0x5CA6             LDRB     R6,[R4, R2]
   \   00000018   0x43F6             MVNS     R6,R6
   \   0000001A   0x5466             STRB     R6,[R4, R1]
    269                  MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();                           // Restore the ISR context previously saved.
   \   0000001C   0xF385 0x8810      MSR      PRIMASK,R5
    270                  //-----------------------------------------------------------------------------------------------------------------
    271              }
   \   00000020   0x1C64             ADDS     R4,R4,#+1
   \   00000022   0xE7F0             B.N      ??SRData__UpdateArrayNonBlocking_0
    272          }
   \                     ??SRData__UpdateArrayNonBlocking_1: (+1)
   \   00000024   0xBC70             POP      {R4-R6}
   \   00000026   0x4770             BX       LR               ;; return
    273          
    274          //---------------------------------------------------------------------------------------------------------------------
    275          #ifdef __IAR_SYSTEMS_ICC__
    276              #pragma optimize = none
    277          #endif
    278          /**
    279           * @brief This method checks the data array and it's backup.
    280           * @details This method will check byte by byte a SR array but it allows interrupts in between bytes. So if there is
    281           * any change of a Array be used by 2 different places where one place can interrupt the other it should be used the set of
    282           * functions that are blocking: SRData__UpdateArray() and SRData__CheckArray();
    283           * @param data pointer to the data array
    284           * @param ndata pointer to the backup of the data array
    285           * @param size defines size of the arrays
    286           * @return SRDATA_CHECK_TYPE
    287           */

   \                                 In section .text, align 2, keep-with-next
    288          SRDATA_CHECK_TYPE SRData__CheckArrayNonBlocking(void * data, void * ndata, size_t size)
    289          {
   \                     SRData__CheckArrayNonBlocking: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    290              SRDATA_CHECK_TYPE response;
    291              volatile size_t index;
    292              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    293              response = SRDATA_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0007             MOVS     R7,R0
    294          
    295          
    296              for (index=0; index< size; index++)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9000             STR      R0,[SP, #+0]
   \                     ??SRData__CheckArrayNonBlocking_0: (+1)
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0x42B0             CMP      R0,R6
   \   00000018   0xD263             BCS.N    ??SRData__CheckArrayNonBlocking_1
    297              {
    298                  //------- ISR Protected Code --------------------------------------------------------------------------------------
    299                  MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();                              // Save context and disable ISRs
   \   0000001A   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   0000001E   0x4680             MOV      R8,R0
   \   00000020   0xB672             CPSID    I
    300          
    301                  uint8 aux = SRDATA__COMPLEMENT(((uint8 *)data)[index]);
                                     ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0x5D00             LDRB     R0,[R0, R4]
   \   00000026   0xEA7F 0x0900      MVNS     R9,R0
    302                  if (aux !=  ((uint8 *)ndata)[index]  )    // Test each position of data against its inverted position
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
   \   0000002C   0x5D40             LDRB     R0,[R0, R5]
   \   0000002E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000032   0x4581             CMP      R9,R0
   \   00000034   0xD04F             BEQ.N    ??SRData__CheckArrayNonBlocking_2
    303                  {
    304                      if(response == SRDATA_OK)               // Make sure we don't overwrite a BAD memory exception
   \   00000036   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000038   0x2F00             CMP      R7,#+0
   \   0000003A   0xD108             BNE.N    ??SRData__CheckArrayNonBlocking_3
    305                      {
    306                          SRException__Queue(SREXCEPTION_SRDATA_NOISE,(uint32)data,(uint32)ndata);
   \   0000003C   0x002A             MOVS     R2,R5
   \   0000003E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000040   0x0021             MOVS     R1,R4
   \   00000042   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x.... 0x....      BL       SRException__Queue
    307                          response = SRDATA_CORRUPT_NOISE;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x0007             MOVS     R7,R0
    308                      }
    309                      aux = ((uint8 *)data)[index];         // backup data
   \                     ??SRData__CheckArrayNonBlocking_3: (+1)
   \   0000004E   0x9800             LDR      R0,[SP, #+0]
   \   00000050   0x5D00             LDRB     R0,[R0, R4]
   \   00000052   0x4681             MOV      R9,R0
    310                      for (uint8 mask=1;mask>0;mask = (mask<<1))
   \   00000054   0xF05F 0x0A01      MOVS     R10,#+1
   \                     ??SRData__CheckArrayNonBlocking_4: (+1)
   \   00000058   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000005C   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000060   0xD014             BEQ.N    ??SRData__CheckArrayNonBlocking_5
    311                      {
    312                          ((uint8 *)data)[index] = mask;
   \   00000062   0x9800             LDR      R0,[SP, #+0]
   \   00000064   0xF800 0xA004      STRB     R10,[R0, R4]
    313                          if (((uint8 *)data)[index] != mask)   // test bit by bit
   \   00000068   0x9800             LDR      R0,[SP, #+0]
   \   0000006A   0x5D00             LDRB     R0,[R0, R4]
   \   0000006C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000070   0x4550             CMP      R0,R10
   \   00000072   0xD008             BEQ.N    ??SRData__CheckArrayNonBlocking_6
    314                          {
    315                              SRException__Queue(SREXCEPTION_SRDATA_BAD_MEMORY,(uint32)data,(uint32)ndata);
   \   00000074   0x002A             MOVS     R2,R5
   \   00000076   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000078   0x0021             MOVS     R1,R4
   \   0000007A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000007C   0x2002             MOVS     R0,#+2
   \   0000007E   0x.... 0x....      BL       SRException__Queue
    316                              response = SRDATA_CORRUPT_BAD_MEMORY;
   \   00000082   0x2002             MOVS     R0,#+2
   \   00000084   0x0007             MOVS     R7,R0
    317                          }
    318                      }
   \                     ??SRData__CheckArrayNonBlocking_6: (+1)
   \   00000086   0xEA5F 0x0A4A      LSLS     R10,R10,#+1
   \   0000008A   0xE7E5             B.N      ??SRData__CheckArrayNonBlocking_4
    319                      ((uint8 *)data)[index] = aux;         // restore data
   \                     ??SRData__CheckArrayNonBlocking_5: (+1)
   \   0000008C   0x9800             LDR      R0,[SP, #+0]
   \   0000008E   0xF800 0x9004      STRB     R9,[R0, R4]
    320          
    321                      aux = ((uint8 *)ndata)[index];        // backup inverted data
   \   00000092   0x9800             LDR      R0,[SP, #+0]
   \   00000094   0x5D40             LDRB     R0,[R0, R5]
   \   00000096   0x4681             MOV      R9,R0
    322                      for (uint8 mask=1;mask>0;mask = (mask<<1))
   \   00000098   0xF05F 0x0A01      MOVS     R10,#+1
   \                     ??SRData__CheckArrayNonBlocking_7: (+1)
   \   0000009C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000A0   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000A4   0xD014             BEQ.N    ??SRData__CheckArrayNonBlocking_8
    323                      {
    324                          ((uint8 *)ndata)[index] = mask;
   \   000000A6   0x9800             LDR      R0,[SP, #+0]
   \   000000A8   0xF800 0xA005      STRB     R10,[R0, R5]
    325                          if (((uint8 *)ndata)[index] != mask)  // test bit by bit
   \   000000AC   0x9800             LDR      R0,[SP, #+0]
   \   000000AE   0x5D40             LDRB     R0,[R0, R5]
   \   000000B0   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000B4   0x4550             CMP      R0,R10
   \   000000B6   0xD008             BEQ.N    ??SRData__CheckArrayNonBlocking_9
    326                          {
    327                              SRException__Queue(SREXCEPTION_SRDATA_BAD_MEMORY,(uint32)data,(uint32)ndata);
   \   000000B8   0x002A             MOVS     R2,R5
   \   000000BA   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000BC   0x0021             MOVS     R1,R4
   \   000000BE   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000C0   0x2002             MOVS     R0,#+2
   \   000000C2   0x.... 0x....      BL       SRException__Queue
    328                              response = SRDATA_CORRUPT_BAD_BACKUP_MEMORY;
   \   000000C6   0x2003             MOVS     R0,#+3
   \   000000C8   0x0007             MOVS     R7,R0
    329                          }
    330                      }
   \                     ??SRData__CheckArrayNonBlocking_9: (+1)
   \   000000CA   0xEA5F 0x0A4A      LSLS     R10,R10,#+1
   \   000000CE   0xE7E5             B.N      ??SRData__CheckArrayNonBlocking_7
    331                      ((uint8 *)ndata)[index] = aux;        // restore inverted data
   \                     ??SRData__CheckArrayNonBlocking_8: (+1)
   \   000000D0   0x9800             LDR      R0,[SP, #+0]
   \   000000D2   0xF800 0x9005      STRB     R9,[R0, R5]
    332          
    333                  }
    334                  MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();                           // Restore the ISR context previously saved.
   \                     ??SRData__CheckArrayNonBlocking_2: (+1)
   \   000000D6   0xF388 0x8810      MSR      PRIMASK,R8
    335                  //-----------------------------------------------------------------------------------------------------------------
    336              }
   \   000000DA   0x9800             LDR      R0,[SP, #+0]
   \   000000DC   0x1C40             ADDS     R0,R0,#+1
   \   000000DE   0x9000             STR      R0,[SP, #+0]
   \   000000E0   0xE798             B.N      ??SRData__CheckArrayNonBlocking_0
    337          
    338              return (response);
   \                     ??SRData__CheckArrayNonBlocking_1: (+1)
   \   000000E2   0x0038             MOVS     R0,R7
   \   000000E4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E6   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    339          }
    340          #endif
    341          
    342          
    343          #if (SRDATA_SHORT_FEATURE == ENABLED)
    344          #ifdef __IAR_SYSTEMS_ICC__
    345              #pragma optimize = none
    346          #endif
    347          //---------------------------------------------------------------------------------------------------------------------
    348          /**
    349           * @brief This method updates a Safety Short Variable and it's backup variable
    350           *
    351           * @param data pointer to the SR data
    352           * @param ndata pointer to the complementary SR data
    353           * @param value value to be updated in the SR variable
    354           */

   \                                 In section .text, align 2, keep-with-next
    355          void SRData__UpdateShort(uint16 PACKED * data,uint16 PACKED * ndata,uint16 value)
    356          {
   \                     SRData__UpdateShort: (+1)
   \   00000000   0xB410             PUSH     {R4}
    357              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    358          
    359              //------- ISR Protected Code --------------------------------------------------------------------------------------
    360              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();                              // Save context and disable ISRs
   \   00000002   0xF3EF 0x8410      MRS      R4,PRIMASK
   \   00000006   0x0023             MOVS     R3,R4
   \   00000008   0xB672             CPSID    I
    361              *data = value;                                  // write data
   \   0000000A   0x8002             STRH     R2,[R0, #+0]
    362              *ndata = SRDATA__COMPLEMENT(value);             // write inverted data
                              ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \   0000000C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000E   0x43D4             MVNS     R4,R2
   \   00000010   0x800C             STRH     R4,[R1, #+0]
    363              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();                           // Restore the ISR context previously saved.
   \   00000012   0xF383 0x8810      MSR      PRIMASK,R3
    364              //-----------------------------------------------------------------------------------------------------------------
    365          }
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return
    366          
    367          #ifdef __IAR_SYSTEMS_ICC__
    368              #pragma optimize = none
    369          #endif
    370          //---------------------------------------------------------------------------------------------------------------------
    371          /**
    372           * @brief This method checks the integrity of a Safety Short Variable and it's backup
    373           *
    374           * @param data pointer to the SR data
    375           * @param ndata pointer to the complementary SR data
    376           * @return Result of the verification
    377           */

   \                                 In section .text, align 2, keep-with-next
    378          SRDATA_CHECK_TYPE SRData__CheckShort(uint16 PACKED * data, uint16 PACKED * ndata)
    379          {
   \                     SRData__CheckShort: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    380              volatile uint16 aux;
    381              volatile SRDATA_CHECK_TYPE response;
    382              volatile uint16 mask;
    383              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    384              response = SRDATA_OK;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF88D 0x0004      STRB     R0,[SP, #+4]
    385          
    386              //------- ISR Protected Code --------------------------------------------------------------------------------------
    387              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();                              // Save context and disable ISRs
   \   0000000C   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000010   0x0006             MOVS     R6,R0
   \   00000012   0xB672             CPSID    I
    388              aux = SRDATA__COMPLEMENT(*data);
                           ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \   00000014   0x8820             LDRH     R0,[R4, #+0]
   \   00000016   0x43C0             MVNS     R0,R0
   \   00000018   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    389              if (aux != (*ndata) )                           // test variable against the inverted variable
   \   0000001C   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000020   0x8829             LDRH     R1,[R5, #+0]
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD053             BEQ.N    ??SRData__CheckShort_0
    390              {
    391                  SRException__Queue(SREXCEPTION_SRDATA_NOISE,(uint32)data,(uint32)ndata);    //lint !e923 Suppress Info: cast from pointer to unsigned long [Encompasses MISRA 2004 Rule 11.1], [MISRA 2004 Rule 11.3]
   \   00000026   0x002A             MOVS     R2,R5
   \   00000028   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000002A   0x0021             MOVS     R1,R4
   \   0000002C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x.... 0x....      BL       SRException__Queue
    392                  response = SRDATA_CORRUPT_NOISE;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xF88D 0x0004      STRB     R0,[SP, #+4]
    393                  aux = *data;                                // backup variable data
   \   0000003A   0x8820             LDRH     R0,[R4, #+0]
   \   0000003C   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    394                  for (mask=1;mask>0;mask = (mask<<1))
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \                     ??SRData__CheckShort_1: (+1)
   \   00000046   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD017             BEQ.N    ??SRData__CheckShort_2
    395                  {
    396                      *data = mask;
   \   0000004E   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000052   0x8020             STRH     R0,[R4, #+0]
    397                      if (*data != mask)                      // test bit by bit
   \   00000054   0x8820             LDRH     R0,[R4, #+0]
   \   00000056   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD009             BEQ.N    ??SRData__CheckShort_3
    398                      {
    399                          SRException__Queue(SREXCEPTION_SRDATA_BAD_MEMORY,(uint32)data,(uint32)ndata);   //lint !e923 Suppress Info: cast from pointer to unsigned long [Encompasses MISRA 2004 Rule 11.1], [MISRA 2004 Rule 11.3]
   \   0000005E   0x002A             MOVS     R2,R5
   \   00000060   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000062   0x0021             MOVS     R1,R4
   \   00000064   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000066   0x2002             MOVS     R0,#+2
   \   00000068   0x.... 0x....      BL       SRException__Queue
    400                          response = SRDATA_CORRUPT_BAD_MEMORY;
   \   0000006C   0x2002             MOVS     R0,#+2
   \   0000006E   0xF88D 0x0004      STRB     R0,[SP, #+4]
    401                      }
    402                  }
   \                     ??SRData__CheckShort_3: (+1)
   \   00000072   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000076   0x0040             LSLS     R0,R0,#+1
   \   00000078   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   0000007C   0xE7E3             B.N      ??SRData__CheckShort_1
    403                  *data = aux;                                // restore variable data
   \                     ??SRData__CheckShort_2: (+1)
   \   0000007E   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000082   0x8020             STRH     R0,[R4, #+0]
    404          
    405                  aux = *ndata;                               // backup inverted variable data
   \   00000084   0x8828             LDRH     R0,[R5, #+0]
   \   00000086   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    406                  for (mask=1;mask>0;mask = (mask<<1))
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \                     ??SRData__CheckShort_4: (+1)
   \   00000090   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD017             BEQ.N    ??SRData__CheckShort_5
    407                  {
    408                      *ndata = mask;
   \   00000098   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000009C   0x8028             STRH     R0,[R5, #+0]
    409                      if (*ndata != mask)                     // test bit by bit
   \   0000009E   0x8828             LDRH     R0,[R5, #+0]
   \   000000A0   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   000000A4   0x4288             CMP      R0,R1
   \   000000A6   0xD009             BEQ.N    ??SRData__CheckShort_6
    410                      {
    411                          SRException__Queue(SREXCEPTION_SRDATA_BAD_MEMORY,(uint32)data,(uint32)ndata);   //lint !e923 Suppress Info: cast from pointer to unsigned long [Encompasses MISRA 2004 Rule 11.1], [MISRA 2004 Rule 11.3]
   \   000000A8   0x002A             MOVS     R2,R5
   \   000000AA   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000AC   0x0021             MOVS     R1,R4
   \   000000AE   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000B0   0x2002             MOVS     R0,#+2
   \   000000B2   0x.... 0x....      BL       SRException__Queue
    412                          response = SRDATA_CORRUPT_BAD_BACKUP_MEMORY;
   \   000000B6   0x2003             MOVS     R0,#+3
   \   000000B8   0xF88D 0x0004      STRB     R0,[SP, #+4]
    413                      }
    414                  }
   \                     ??SRData__CheckShort_6: (+1)
   \   000000BC   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000C0   0x0040             LSLS     R0,R0,#+1
   \   000000C2   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   000000C6   0xE7E3             B.N      ??SRData__CheckShort_4
    415                  *ndata = aux;                               // restore inverted variable data
   \                     ??SRData__CheckShort_5: (+1)
   \   000000C8   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   000000CC   0x8028             STRH     R0,[R5, #+0]
    416          
    417              }
    418              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();                           // Restore the ISR context previously saved.
   \                     ??SRData__CheckShort_0: (+1)
   \   000000CE   0xF386 0x8810      MSR      PRIMASK,R6
    419              //-----------------------------------------------------------------------------------------------------------------
    420              return (response);
   \   000000D2   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000D6   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    421          }
    422          #endif
    423          
    424          #if (SRDATA_LONG_FEATURE == ENABLED)
    425          #ifdef __IAR_SYSTEMS_ICC__
    426              #pragma optimize = none
    427          #endif
    428          //---------------------------------------------------------------------------------------------------------------------
    429          /**
    430           * @brief This method updates a Safety Long Variable and it's backup variable
    431           *
    432           * @param data pointer to the SR data
    433           * @param ndata pointer to the complementary SR data
    434           * @param value value to be updated in the SR variable
    435           */

   \                                 In section .text, align 2, keep-with-next
    436          void SRData__UpdateLong(uint32 PACKED * data,uint32 PACKED * ndata,uint32 value)
    437          {
   \                     SRData__UpdateLong: (+1)
   \   00000000   0xB410             PUSH     {R4}
    438              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    439          
    440              //------- ISR Protected Code --------------------------------------------------------------------------------------
    441              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();                              // Save context and disable ISRs
   \   00000002   0xF3EF 0x8410      MRS      R4,PRIMASK
   \   00000006   0x0023             MOVS     R3,R4
   \   00000008   0xB672             CPSID    I
    442              *data = value;
   \   0000000A   0x6002             STR      R2,[R0, #+0]
    443              *ndata = SRDATA__COMPLEMENT(value);
   \   0000000C   0x43D4             MVNS     R4,R2
   \   0000000E   0x600C             STR      R4,[R1, #+0]
    444              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();                           // Restore the ISR context previously saved.
   \   00000010   0xF383 0x8810      MSR      PRIMASK,R3
    445              //-----------------------------------------------------------------------------------------------------------------
    446          }
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return
    447          
    448          #ifdef __IAR_SYSTEMS_ICC__
    449              #pragma optimize = none
    450          #endif
    451          //---------------------------------------------------------------------------------------------------------------------
    452          /**
    453           * @brief This method checks the integrity of a Safety Long Variable and it's backup
    454           *
    455           * @param data pointer to the SR data
    456           * @param ndata pointer to the complementary SR data
    457           * @return Result of the verification
    458           */

   \                                 In section .text, align 2, keep-with-next
    459          SRDATA_CHECK_TYPE SRData__CheckLong(uint32 PACKED * data,uint32 PACKED * ndata)
    460          {
   \                     SRData__CheckLong: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    461              uint32 aux;
    462              SRDATA_CHECK_TYPE response;
    463              uint32 mask;
    464              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    465              response = SRDATA_OK;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0007             MOVS     R7,R0
    466          
    467              //------- ISR Protected Code --------------------------------------------------------------------------------------
    468              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();                              // Save context and disable ISRs
   \   0000000C   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000010   0x4681             MOV      R9,R0
   \   00000012   0xB672             CPSID    I
    469              aux = SRDATA__COMPLEMENT(*data);
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x43C0             MVNS     R0,R0
   \   00000018   0x0006             MOVS     R6,R0
    470              if (aux != (*ndata) )
   \   0000001A   0x6828             LDR      R0,[R5, #+0]
   \   0000001C   0x4286             CMP      R6,R0
   \   0000001E   0xD03A             BEQ.N    ??SRData__CheckLong_0
    471              {
    472                  SRException__Queue(SREXCEPTION_SRDATA_NOISE,(uint32)data,(uint32)ndata);    //lint !e923 Suppress Info: cast from pointer to unsigned long [Encompasses MISRA 2004 Rule 11.1], [MISRA 2004 Rule 11.3]
   \   00000020   0x002A             MOVS     R2,R5
   \   00000022   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000024   0x0021             MOVS     R1,R4
   \   00000026   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x.... 0x....      BL       SRException__Queue
    473                  response = SRDATA_CORRUPT_NOISE;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x0007             MOVS     R7,R0
    474          
    475                  aux = *data;                                // backup variable data
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x0006             MOVS     R6,R0
    476                  for (mask=1;mask>0;mask = (mask<<1))
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x4680             MOV      R8,R0
   \                     ??SRData__CheckLong_1: (+1)
   \   0000003A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000003E   0xD010             BEQ.N    ??SRData__CheckLong_2
    477                  {
    478                      *data = mask;
   \   00000040   0xF8C4 0x8000      STR      R8,[R4, #+0]
    479                      if (*data != mask)                      // test bit by bit
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x4540             CMP      R0,R8
   \   00000048   0xD008             BEQ.N    ??SRData__CheckLong_3
    480                      {
    481                          SRException__Queue(SREXCEPTION_SRDATA_BAD_MEMORY,(uint32)data,(uint32)ndata);   //lint !e923 Suppress Info: cast from pointer to unsigned long [Encompasses MISRA 2004 Rule 11.1], [MISRA 2004 Rule 11.3]
   \   0000004A   0x002A             MOVS     R2,R5
   \   0000004C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000004E   0x0021             MOVS     R1,R4
   \   00000050   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0x.... 0x....      BL       SRException__Queue
    482                          response = SRDATA_CORRUPT_BAD_MEMORY;
   \   00000058   0x2002             MOVS     R0,#+2
   \   0000005A   0x0007             MOVS     R7,R0
    483                      }
    484                  }
   \                     ??SRData__CheckLong_3: (+1)
   \   0000005C   0xEA5F 0x0848      LSLS     R8,R8,#+1
   \   00000060   0xE7EB             B.N      ??SRData__CheckLong_1
    485                  *data = aux;                                // restore variable data
   \                     ??SRData__CheckLong_2: (+1)
   \   00000062   0x6026             STR      R6,[R4, #+0]
    486          
    487          
    488                  aux = *ndata;                               // backup inverted variable data
   \   00000064   0x6828             LDR      R0,[R5, #+0]
   \   00000066   0x0006             MOVS     R6,R0
    489                  for (mask=1;mask>0;mask = (mask<<1))
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0x4680             MOV      R8,R0
   \                     ??SRData__CheckLong_4: (+1)
   \   0000006C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000070   0xD010             BEQ.N    ??SRData__CheckLong_5
    490                  {
    491                      *ndata = mask;
   \   00000072   0xF8C5 0x8000      STR      R8,[R5, #+0]
    492                      if (*ndata != mask)                     // test bit by bit
   \   00000076   0x6828             LDR      R0,[R5, #+0]
   \   00000078   0x4540             CMP      R0,R8
   \   0000007A   0xD008             BEQ.N    ??SRData__CheckLong_6
    493                      {
    494                          SRException__Queue(SREXCEPTION_SRDATA_BAD_MEMORY,(uint32)data,(uint32)ndata);   //lint !e923 Suppress Info: cast from pointer to unsigned long [Encompasses MISRA 2004 Rule 11.1], [MISRA 2004 Rule 11.3]
   \   0000007C   0x002A             MOVS     R2,R5
   \   0000007E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000080   0x0021             MOVS     R1,R4
   \   00000082   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000084   0x2002             MOVS     R0,#+2
   \   00000086   0x.... 0x....      BL       SRException__Queue
    495                          response = SRDATA_CORRUPT_BAD_BACKUP_MEMORY;
   \   0000008A   0x2003             MOVS     R0,#+3
   \   0000008C   0x0007             MOVS     R7,R0
    496                      }
    497                  }
   \                     ??SRData__CheckLong_6: (+1)
   \   0000008E   0xEA5F 0x0848      LSLS     R8,R8,#+1
   \   00000092   0xE7EB             B.N      ??SRData__CheckLong_4
    498                  *ndata = aux;                               // restore inverted variable data
   \                     ??SRData__CheckLong_5: (+1)
   \   00000094   0x602E             STR      R6,[R5, #+0]
    499              }
    500              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();                           // Restore the ISR context previously saved.
   \                     ??SRData__CheckLong_0: (+1)
   \   00000096   0xF389 0x8810      MSR      PRIMASK,R9
    501              //-----------------------------------------------------------------------------------------------------------------
    502              return (response);
   \   0000009A   0x0038             MOVS     R0,R7
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    503          }
    504          #endif
    505          
    506          
    507          #if (SRDATA_FLOAT_FEATURE == ENABLED)
    508          #ifdef __IAR_SYSTEMS_ICC__
    509              #pragma optimize = none
    510          #endif
    511          //---------------------------------------------------------------------------------------------------------------------
    512          /**
    513           * @brief This method updates a Safety Long Variable and it's backup variable
    514           *
    515           * @param data pointer to the SR data
    516           * @param ndata pointer to the complementary SR data
    517           * @param value value to be updated in the SR variable
    518           */

   \                                 In section .text, align 2, keep-with-next
    519          void SRData__UpdateFloat(float32 PACKED * data,float32 PACKED * ndata,float32 value)
    520          {
   \                     SRData__UpdateFloat: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    521              SRDATA_CONVERTION_F_L_TYPE aux;
    522              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    523              aux.vfloat = value;                             // load the float size of the union
   \   00000002   0xED8D 0x0A00      VSTR     S0,[SP, #+0]
    524              aux.vlong = SRDATA__COMPLEMENT(aux.vlong);      // use the data as long
   \   00000006   0x9B00             LDR      R3,[SP, #+0]
   \   00000008   0x43DB             MVNS     R3,R3
   \   0000000A   0x9300             STR      R3,[SP, #+0]
    525          
    526              //------- ISR Protected Code --------------------------------------------------------------------------------------
    527              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();                              // Save context and disable ISRs
   \   0000000C   0xF3EF 0x8310      MRS      R3,PRIMASK
   \   00000010   0x001A             MOVS     R2,R3
   \   00000012   0xB672             CPSID    I
    528              *data = value;                                  // update variable
   \   00000014   0xEE10 0x3A10      VMOV     R3,S0
   \   00000018   0x6003             STR      R3,[R0, #+0]
    529              *ndata = aux.vfloat;                            // take the inverted data as a float and load into the inverted variable
   \   0000001A   0x9B00             LDR      R3,[SP, #+0]
   \   0000001C   0x600B             STR      R3,[R1, #+0]
    530              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();                           // Restore the ISR context previously saved.
   \   0000001E   0xF382 0x8810      MSR      PRIMASK,R2
    531              //-----------------------------------------------------------------------------------------------------------------
    532          }
   \   00000022   0xB001             ADD      SP,SP,#+4
   \   00000024   0x4770             BX       LR               ;; return
    533          
    534          #ifdef __IAR_SYSTEMS_ICC__
    535              #pragma optimize = none
    536          #endif
    537          //---------------------------------------------------------------------------------------------------------------------
    538          /**
    539           * @brief This method checks the integrity of a Safety Long Variable and it's backup
    540           *
    541           * @param data pointer to the SR data
    542           * @param ndata pointer to the complementary SR data
    543           * @return Result of the verification
    544           */

   \                                 In section .text, align 2, keep-with-next
    545          SRDATA_CHECK_TYPE SRData__CheckFloat(float32 PACKED * data, float32 PACKED * ndata)
    546          {
   \                     SRData__CheckFloat: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    547              SRDATA_CONVERTION_F_L_TYPE aux;
    548              SRDATA_CHECK_TYPE response;
    549              uint32 mask;
    550              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    551          
    552              response = SRDATA_OK;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0006             MOVS     R6,R0
    553          
    554              //------- ISR Protected Code --------------------------------------------------------------------------------------
    555              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();                              // Save context and disable ISRs
   \   0000000E   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000012   0x4680             MOV      R8,R0
   \   00000014   0xB672             CPSID    I
    556              aux.vfloat = *data;                             // load the variable as float
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x9000             STR      R0,[SP, #+0]
    557              aux.vlong = SRDATA__COMPLEMENT(aux.vlong);      // calculates it's complement
   \   0000001A   0x9800             LDR      R0,[SP, #+0]
   \   0000001C   0x43C0             MVNS     R0,R0
   \   0000001E   0x9000             STR      R0,[SP, #+0]
    558          
    559              if (aux.vlong != (*((uint32 *)(void*)ndata)))   // test the inverted variable with the data  complement
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x6829             LDR      R1,[R5, #+0]
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD036             BEQ.N    ??SRData__CheckFloat_0
    560              {
    561                  SRException__Queue(SREXCEPTION_SRDATA_NOISE,(uint32)data,(uint32)ndata);    //lint !e923 Suppress Info: cast from pointer to unsigned long [Encompasses MISRA 2004 Rule 11.1], [MISRA 2004 Rule 11.3]
   \   00000028   0x002A             MOVS     R2,R5
   \   0000002A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000002C   0x0021             MOVS     R1,R4
   \   0000002E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x.... 0x....      BL       SRException__Queue
    562                  response = SRDATA_CORRUPT_NOISE;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x0006             MOVS     R6,R0
    563          
    564                  aux.vfloat = *data;                         // backup variable data
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x9000             STR      R0,[SP, #+0]
    565                  for (mask=1;mask>0;mask = (mask<<1))
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x0007             MOVS     R7,R0
   \                     ??SRData__CheckFloat_1: (+1)
   \   00000042   0x2F00             CMP      R7,#+0
   \   00000044   0xD00E             BEQ.N    ??SRData__CheckFloat_2
    566                  {
    567                      *(uint32 *)(void*)data = mask;
   \   00000046   0x6027             STR      R7,[R4, #+0]
    568                      if (*(uint32 *)(void*)data != mask) // test bit by bit of the variable
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x42B8             CMP      R0,R7
   \   0000004C   0xD008             BEQ.N    ??SRData__CheckFloat_3
    569                      {
    570                          SRException__Queue(SREXCEPTION_SRDATA_BAD_MEMORY,(uint32)data,(uint32)ndata);   //lint !e923 Suppress Info: cast from pointer to unsigned long [Encompasses MISRA 2004 Rule 11.1], [MISRA 2004 Rule 11.3]
   \   0000004E   0x002A             MOVS     R2,R5
   \   00000050   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000052   0x0021             MOVS     R1,R4
   \   00000054   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000056   0x2002             MOVS     R0,#+2
   \   00000058   0x.... 0x....      BL       SRException__Queue
    571                          response = SRDATA_CORRUPT_BAD_MEMORY;
   \   0000005C   0x2002             MOVS     R0,#+2
   \   0000005E   0x0006             MOVS     R6,R0
    572                      }
    573                  }
   \                     ??SRData__CheckFloat_3: (+1)
   \   00000060   0x007F             LSLS     R7,R7,#+1
   \   00000062   0xE7EE             B.N      ??SRData__CheckFloat_1
    574                  *data = aux.vfloat;                         // restore inverted variable data
   \                     ??SRData__CheckFloat_2: (+1)
   \   00000064   0x9800             LDR      R0,[SP, #+0]
   \   00000066   0x6020             STR      R0,[R4, #+0]
    575          
    576          
    577                  aux.vfloat = *ndata;                        // save inverted variable data
   \   00000068   0x6828             LDR      R0,[R5, #+0]
   \   0000006A   0x9000             STR      R0,[SP, #+0]
    578                  for (mask=1;mask>0;mask = (mask<<1))
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x0007             MOVS     R7,R0
   \                     ??SRData__CheckFloat_4: (+1)
   \   00000070   0x2F00             CMP      R7,#+0
   \   00000072   0xD00E             BEQ.N    ??SRData__CheckFloat_5
    579                  {
    580                      *(uint32 *)(void*)ndata = mask;
   \   00000074   0x602F             STR      R7,[R5, #+0]
    581                      if (*(uint32 *)(void*)ndata != mask)// test bit by bit
   \   00000076   0x6828             LDR      R0,[R5, #+0]
   \   00000078   0x42B8             CMP      R0,R7
   \   0000007A   0xD008             BEQ.N    ??SRData__CheckFloat_6
    582                      {
    583                          SRException__Queue(SREXCEPTION_SRDATA_BAD_MEMORY,(uint32)data,(uint32)ndata);   //lint !e923 Suppress Info: cast from pointer to unsigned long [Encompasses MISRA 2004 Rule 11.1], [MISRA 2004 Rule 11.3]
   \   0000007C   0x002A             MOVS     R2,R5
   \   0000007E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000080   0x0021             MOVS     R1,R4
   \   00000082   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000084   0x2002             MOVS     R0,#+2
   \   00000086   0x.... 0x....      BL       SRException__Queue
    584                          response = SRDATA_CORRUPT_BAD_BACKUP_MEMORY;
   \   0000008A   0x2003             MOVS     R0,#+3
   \   0000008C   0x0006             MOVS     R6,R0
    585                      }
    586                  }
   \                     ??SRData__CheckFloat_6: (+1)
   \   0000008E   0x007F             LSLS     R7,R7,#+1
   \   00000090   0xE7EE             B.N      ??SRData__CheckFloat_4
    587                  *ndata = aux.vfloat;                        // restore inverted variable data
   \                     ??SRData__CheckFloat_5: (+1)
   \   00000092   0x9800             LDR      R0,[SP, #+0]
   \   00000094   0x6028             STR      R0,[R5, #+0]
    588              }
    589              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();                           // Restore the ISR context previously saved.
   \                     ??SRData__CheckFloat_0: (+1)
   \   00000096   0xF388 0x8810      MSR      PRIMASK,R8
    590              //-----------------------------------------------------------------------------------------------------------------
    591          
    592              return (response);
   \   0000009A   0x0030             MOVS     R0,R6
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009E   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    593          }
    594          #endif
    595          
    596          
    597          #ifdef __IAR_SYSTEMS_ICC__
    598              #pragma optimize = none
    599          #endif
    600          //---------------------------------------------------------------------------------------------------------------------
    601          /**
    602           * Fill a memory block with a fill value.
    603           * @param data = Pointer to the block with non-inverted data.
    604           * @param ndata = Pointer to the block with inverted data.
    605           * @param fill_value = The non-inverted data value to fill.
    606           * @param size = The number of bytes to fill in the memory block.
    607           */

   \                                 In section .text, align 2, keep-with-next
    608          void SRData__Fill(void* data, void* ndata, uint8 fill_value, size_t size)
    609          {
   \                     SRData__Fill: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    610              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    611              uint8* ptr = data;
   \   00000002   0x0005             MOVS     R5,R0
    612              uint8* nptr = ndata;
   \   00000004   0x000E             MOVS     R6,R1
    613              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();           // Save context and disable ISRs
   \   00000006   0xF3EF 0x8710      MRS      R7,PRIMASK
   \   0000000A   0x003C             MOVS     R4,R7
   \   0000000C   0xB672             CPSID    I
    614              for (size_t i = 0; i < size; i++)
   \   0000000E   0x2700             MOVS     R7,#+0
   \                     ??SRData__Fill_0: (+1)
   \   00000010   0x429F             CMP      R7,R3
   \   00000012   0xD209             BCS.N    ??SRData__Fill_1
    615              {
    616                  *ptr++ = fill_value;
   \   00000014   0x702A             STRB     R2,[R5, #+0]
   \   00000016   0x1C6D             ADDS     R5,R5,#+1
    617                  *nptr++ = SRDATA__COMPLEMENT(fill_value);
                                   ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \   00000018   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001A   0xEA7F 0x0C02      MVNS     R12,R2
   \   0000001E   0xF886 0xC000      STRB     R12,[R6, #+0]
   \   00000022   0x1C76             ADDS     R6,R6,#+1
    618              }
   \   00000024   0x1C7F             ADDS     R7,R7,#+1
   \   00000026   0xE7F3             B.N      ??SRData__Fill_0
    619              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();        // Restore the ISR context previously saved.
   \                     ??SRData__Fill_1: (+1)
   \   00000028   0xF384 0x8810      MSR      PRIMASK,R4
    620          }
   \   0000002C   0xBCF0             POP      {R4-R7}
   \   0000002E   0x4770             BX       LR               ;; return
    621          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   SRData__CheckArray
        32   -> SRException__Queue
      40   SRData__CheckArrayNonBlocking
        40   -> SRException__Queue
      24   SRData__CheckByte
        24   -> SRException__Queue
      32   SRData__CheckFloat
        32   -> SRException__Queue
      32   SRData__CheckLong
        32   -> SRException__Queue
      24   SRData__CheckShort
        24   -> SRException__Queue
      16   SRData__Fill
      12   SRData__UpdateArray
      12   SRData__UpdateArrayNonBlocking
       4   SRData__UpdateByte
       4   SRData__UpdateFloat
       4   SRData__UpdateLong
       4   SRData__UpdateShort


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     244  SRData__CheckArray
     234  SRData__CheckArrayNonBlocking
     218  SRData__CheckByte
     162  SRData__CheckFloat
     162  SRData__CheckLong
     216  SRData__CheckShort
      48  SRData__Fill
      40  SRData__UpdateArray
      40  SRData__UpdateArrayNonBlocking
      26  SRData__UpdateByte
      38  SRData__UpdateFloat
      24  SRData__UpdateLong
      26  SRData__UpdateShort

 
 1 478 bytes in section .text
 
 1 478 bytes of CODE memory

Errors: none
Warnings: none
