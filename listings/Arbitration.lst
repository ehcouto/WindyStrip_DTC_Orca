###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        13/Mar/2025  15:30:56
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        Category\Application\ApplicationWasherMcu\Arbitration\Arbitration.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        Arbitration.obj -l ..\listings\Arbitration.lst
#        Category\Application\ApplicationWasherMcu\Arbitration\Arbitration.c
#    List file    =  ..\listings\Arbitration.lst
#    Object file  =  Arbitration.obj
#
###############################################################################

C:\Data\Repository\WindyStrip_DTC_Orca\source\Category\Application\ApplicationWasherMcu\Arbitration\Arbitration.c
      1          /**
      2           * @file
      3           * @brief       Manages conflicting requests from multiple controllers to set a single output.
      4           *
      5           * @details
      6           *
      7           * The Arbitration module has the following interface:
      8           *
      9           * @image html arbitration_cl.png "Class diagram for the Arbitration Module."
     10           *
     11           * The Arbitration module provides a service to Subject modules that control an output. The
     12           * Subject module establishes a priority scheme for the requests made by external controlling
     13           * modules. The arbitration module uses the priority scheme to resolve all the requests to a
     14           * single prioritized output. The following sequence diagram shows an example:
     15           *
     16           * @image html arbitration_sq_conflicting_requests.png "Arbitration of conflicting requests for outputs"
     17           *
     18           * Multiple Subject modules can use the Arbitration module simultaneously since the RAM is located
     19           * in the scope of the Subject modules.
     20           *
     21           *  $Header: Arbitration.c 1.4 2015/08/19 10:32:24EDT Nelson Ferragut II (FERRANJ) Exp  $
     22           *
     23           *  @copyright  Copyright 2013 - $Date: 2015/08/19 10:32:24EDT $  Whirlpool Corporation.  All rights reserved - CONFIDENTIAL.
     24           */
     25          
     26          //  --- Include Files -------------------------------------------------------------------------------------------------
     27          
     28          // -- This Module --
     29          #include "C_Extensions.h"
     30          #include "Arbitration.h"
     31          #include "Arbitration_prv.h"
     32          
     33          // -- Other Modules --
     34          #include <string.h>
     35          #include "Utilities.h"
     36          
     37          
     38          //  --- Public Variables ----------------------------------------------------------------------------------------------
     39          
     40          
     41          //  --- Private Properties --------------------------------------------------------------------------------------------
     42          
     43          
     44          //  --- Private Function Prototypes -----------------------------------------------------------------------------------
     45          
     46          static void *GetActionPointer(ARB_CONTROL_TYPE *control, unsigned char requestor);
     47          static void GetPrioritizedAction(ARB_CONTROL_TYPE *control, void *action, unsigned char *requestor);
     48          
     49          //=====================================================================================================================
     50          //  --- Public Functions ----------------------------------------------------------------------------------------------
     51          //=====================================================================================================================
     52          
     53          
     54          //---------------------------------------------------------------------------------------------------------------------
     55          /**
     56           * Initialize the arbitration control structure.
     57           *
     58           * After initialization, the control structure has all requestors deferring to the default output.
     59           *
     60           * @param control = Pointer to the arbitration control structure to initialize.
     61           */

   \                                 In section .text, align 2, keep-with-next
     62          void Arbitration__Initialize(ARB_CONTROL_TYPE *control)
     63          {
     64              if (control != NULL)
   \                     Arbitration__Initialize: (+1)
   \   00000000   0xB140             CBZ.N    R0,??Arbitration__Initialize_0
     65              {
     66                  // Set all requestors for controlling the output to inactive.
     67                  memset(control->Active_Bits, FALSE, (control->Number_Of_Requestors + 7) / 8);
   \   00000002   0x7901             LDRB     R1,[R0, #+4]
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0x1DC9             ADDS     R1,R1,#+7
   \   00000008   0x108A             ASRS     R2,R1,#+2
   \   0000000A   0xEB01 0x7152      ADD      R1,R1,R2, LSR #+29
   \   0000000E   0x10C9             ASRS     R1,R1,#+3
   \   00000010   0x.... 0x....      B.W      __aeabi_memclr
     68              }
     69              else
     70              {
     71                  DEBUG_UNINITIALIZED_POINTER(Arbitration__Initialize);
     72              }
     73          }
   \                     ??Arbitration__Initialize_0: (+1)
   \   00000014   0x4770             BX       LR               ;; return
     74          
     75          
     76          //---------------------------------------------------------------------------------------------------------------------
     77          /**
     78           * Get the current action that should be taken based on the load arbitration.
     79           *
     80           * @param control = Pointer to the arbitration control structure.
     81           * @param action = Pointer to a structure to fill with the current arbitrated action for the load.
     82           */

   \                                 In section .text, align 2, keep-with-next
     83          void Arbitration__GetPrioritizedAction(ARB_CONTROL_TYPE *control, void *action)
     84          {
   \                     Arbitration__GetPrioritizedAction: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x460D             MOV      R5,R1
     85              unsigned char requestor;
     86          
     87              if (( control == NULL ) ||
     88                  ( action == NULL ))
   \   00000006   0xBF18             IT       NE 
   \   00000008   0x2D00             CMPNE    R5,#+0
   \   0000000A   0xD019             BEQ.N    ??Arbitration__GetPrioritizedAction_0
     89              {
     90                  DEBUG_UNINITIALIZED_POINTER(Arbitration__GetPrioritizedAction);
     91              }
     92              else
     93              {
     94                  GetPrioritizedAction(control, action, &requestor);
   \   0000000C   0x2600             MOVS     R6,#+0
   \   0000000E   0xE000             B.N      ??Arbitration__GetPrioritizedAction_1
   \                     ??Arbitration__GetPrioritizedAction_2: (+1)
   \   00000010   0x1C76             ADDS     R6,R6,#+1
   \                     ??Arbitration__GetPrioritizedAction_1: (+1)
   \   00000012   0x7920             LDRB     R0,[R4, #+4]
   \   00000014   0xB2F6             UXTB     R6,R6
   \   00000016   0x4286             CMP      R6,R0
   \   00000018   0xD20B             BCS.N    ??Arbitration__GetPrioritizedAction_3
   \   0000001A   0x68E0             LDR      R0,[R4, #+12]
   \   0000001C   0x4631             MOV      R1,R6
   \   0000001E   0x.... 0x....      BL       Utilities__GetBitInArray
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD1F4             BNE.N    ??Arbitration__GetPrioritizedAction_2
   \   00000026   0x7960             LDRB     R0,[R4, #+5]
   \   00000028   0x68A1             LDR      R1,[R4, #+8]
   \   0000002A   0x4602             MOV      R2,R0
   \   0000002C   0xFB10 0x1106      SMLABB   R1,R0,R6,R1
   \   00000030   0xE001             B.N      ??Arbitration__GetPrioritizedAction_4
   \                     ??Arbitration__GetPrioritizedAction_3: (+1)
   \   00000032   0x7962             LDRB     R2,[R4, #+5]
   \   00000034   0x6821             LDR      R1,[R4, #+0]
   \                     ??Arbitration__GetPrioritizedAction_4: (+1)
   \   00000036   0x4628             MOV      R0,R5
   \   00000038   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000003C   0x.... 0x....      B.W      __aeabi_memcpy
     95              }
     96          }
   \                     ??Arbitration__GetPrioritizedAction_0: (+1)
   \   00000040   0xBD70             POP      {R4-R6,PC}       ;; return
     97          
     98          
     99          //---------------------------------------------------------------------------------------------------------------------
    100          /**
    101           * Get the current action that should be taken based on the load arbitration.
    102           *
    103           * @param control = Pointer to the arbitration control structure.
    104           * @param action = Pointer to a structure to fill with the current arbitrated action for the load.
    105           * @param requestor = Pointer to the variable to write the current active requestor to.
    106           */

   \                                 In section .text, align 2, keep-with-next
    107          void Arbitration__GetPrioritizedActionAndRequestor(ARB_CONTROL_TYPE *control, void *action, unsigned char *requestor)
    108          {
    109              if (( control == NULL ) ||
    110                  ( action == NULL ) ||
    111                  ( requestor == NULL ))
   \                     Arbitration__GetPrioritizedActionAndRequestor: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xBF18             IT       NE 
   \   00000004   0x2900             CMPNE    R1,#+0
   \   00000006   0xD003             BEQ.N    ??Arbitration__GetPrioritizedActionAndRequestor_0
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xBF18             IT       NE 
    112              {
    113                  DEBUG_UNINITIALIZED_POINTER(Arbitration__GetPrioritizedActionAndRequestor);
    114              }
    115              else
    116              {
    117                  GetPrioritizedAction(control, action, requestor);
   \   0000000C   0x.... 0x....      BNE.W    GetPrioritizedAction
    118              }
    119          }
   \                     ??Arbitration__GetPrioritizedActionAndRequestor_0: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    120          
    121          
    122          //---------------------------------------------------------------------------------------------------------------------
    123          /**
    124           * Update the arbitration based on a new release of control of the output action.
    125           *
    126           * @param control = Pointer to the arbitration control structure.
    127           * @param requestor = The requestor releasing control of the output.
    128           */

   \                                 In section .text, align 2, keep-with-next
    129          void Arbitration__ReleaseControl(ARB_CONTROL_TYPE *control, unsigned char requestor)
    130          {
    131              if (control != NULL)
   \                     Arbitration__ReleaseControl: (+1)
   \   00000000   0xB130             CBZ.N    R0,??Arbitration__ReleaseControl_0
    132              {
    133                  if (requestor < control->Number_Of_Requestors)
   \   00000002   0x7902             LDRB     R2,[R0, #+4]
   \   00000004   0x4291             CMP      R1,R2
   \   00000006   0xD203             BCS.N    ??Arbitration__ReleaseControl_0
    134                  {
    135                      // Release control of any action by the 'requestor'.
    136                      Utilities__SetBitInArray(control->Active_Bits, requestor, FALSE);
   \   00000008   0x68C0             LDR      R0,[R0, #+12]
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x.... 0x....      B.W      Utilities__SetBitInArray
    137                  }
    138                  else
    139                  {
    140                      DEBUG_INVALID_REQUESTOR(requestor);
    141                  }
    142              }
    143              else
    144              {
    145                  DEBUG_UNINITIALIZED_POINTER(Arbitration__ReleaseControl);
    146              }
    147          }
   \                     ??Arbitration__ReleaseControl_0: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    148          
    149          
    150          //---------------------------------------------------------------------------------------------------------------------
    151          /**
    152           * Update the arbitration based on a new request for control of the output action.
    153           *
    154           * @param control = Pointer to the arbitration control structure.
    155           * @param action = Pointer to a structure that contains the requested action.
    156           * @param requestor = The requestor asking for control of the output.
    157           */

   \                                 In section .text, align 2, keep-with-next
    158          void Arbitration__RequestControl(ARB_CONTROL_TYPE *control, void *action, unsigned char requestor)
    159          {
   \                     Arbitration__RequestControl: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    160              if ((control != NULL) && (action != NULL))
   \   00000008   0xBF18             IT       NE 
   \   0000000A   0x2D00             CMPNE    R5,#+0
   \   0000000C   0xD011             BEQ.N    ??Arbitration__RequestControl_0
    161              {
    162                  if (requestor < control->Number_Of_Requestors)
   \   0000000E   0x7920             LDRB     R0,[R4, #+4]
   \   00000010   0x4286             CMP      R6,R0
   \   00000012   0xD20E             BCS.N    ??Arbitration__RequestControl_0
    163                  {
    164                      // Record the request of the 'action' for the 'requestor' given.
    165                      Utilities__SetBitInArray(control->Active_Bits, requestor, TRUE);
   \   00000014   0x68E0             LDR      R0,[R4, #+12]
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x4631             MOV      R1,R6
   \   0000001A   0x.... 0x....      BL       Utilities__SetBitInArray
    166                      memcpy(GetActionPointer(control, requestor), action, control->Size_Of_Action_Type);
   \   0000001E   0x7960             LDRB     R0,[R4, #+5]
   \   00000020   0x68A3             LDR      R3,[R4, #+8]
   \   00000022   0x4602             MOV      R2,R0
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0xFB10 0x3006      SMLABB   R0,R0,R6,R3
   \   0000002A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000002E   0x.... 0x....      B.W      __aeabi_memcpy
    167                  }
    168                  else
    169                  {
    170                      DEBUG_INVALID_REQUESTOR(requestor);
    171                  }
    172              }
    173              else
    174              {
    175                  DEBUG_UNINITIALIZED_POINTER(Arbitration__RequestControl);
    176              }
    177          }
   \                     ??Arbitration__RequestControl_0: (+1)
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return
    178          
    179          
    180          //=====================================================================================================================
    181          //  --- Private Functions ---------------------------------------------------------------------------------------------
    182          //=====================================================================================================================
    183          
    184          //---------------------------------------------------------------------------------------------------------------------
    185          /**
    186           * Get the current action that should be taken based on the load arbitration.
    187           *
    188           * @param control = Pointer to the arbitration control structure.
    189           * @param action = Pointer to a structure to fill with the current arbitrated action for the load.
    190           * @param requestor = Pointer to the variable to write the current active requestor to.
    191           */

   \                                 In section .text, align 2, keep-with-next
    192          static void GetPrioritizedAction(ARB_CONTROL_TYPE *control, void *action, unsigned char *requestor)
    193          {
   \                     GetPrioritizedAction: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    194              unsigned char req;
    195          
    196              // Assume that there is no active request and the default action will be used.
    197              for (req = 0; req < control->Number_Of_Requestors; req++)
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xE000             B.N      ??GetPrioritizedAction_0
   \                     ??GetPrioritizedAction_1: (+1)
   \   0000000E   0x1C7F             ADDS     R7,R7,#+1
   \                     ??GetPrioritizedAction_0: (+1)
   \   00000010   0x7920             LDRB     R0,[R4, #+4]
   \   00000012   0xB2FF             UXTB     R7,R7
   \   00000014   0x4287             CMP      R7,R0
   \   00000016   0xD210             BCS.N    ??GetPrioritizedAction_2
    198              {
    199                  // Look for the first (highest priority) active request
    200                  if (Utilities__GetBitInArray(control->Active_Bits, req) == TRUE)
   \   00000018   0x68E0             LDR      R0,[R4, #+12]
   \   0000001A   0x4639             MOV      R1,R7
   \   0000001C   0x.... 0x....      BL       Utilities__GetBitInArray
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD1F4             BNE.N    ??GetPrioritizedAction_1
    201                  {
    202                      // Determine the address of the prioritized action.
    203                      memcpy(action, GetActionPointer(control, req), control->Size_Of_Action_Type);
   \   00000024   0x7962             LDRB     R2,[R4, #+5]
   \   00000026   0x68A0             LDR      R0,[R4, #+8]
   \   00000028   0x4611             MOV      R1,R2
   \   0000002A   0xFB11 0x0107      SMLABB   R1,R1,R7,R0
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x.... 0x....      BL       __aeabi_memcpy
    204                      *requestor = req;
   \   00000034   0x7037             STRB     R7,[R6, #+0]
    205                      return;
    206                  }
    207              }
    208              // All requestors released control -- use the default action.
    209              memcpy(action, control->Default_Action, control->Size_Of_Action_Type);
    210              *requestor = control->Number_Of_Requestors;
    211          }
   \   00000036   0xB001             ADD      SP,SP,#+4
   \   00000038   0xBDF0             POP      {R4-R7,PC}
   \                     ??GetPrioritizedAction_2: (+1)
   \   0000003A   0x7962             LDRB     R2,[R4, #+5]
   \   0000003C   0x6821             LDR      R1,[R4, #+0]
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x.... 0x....      BL       __aeabi_memcpy
   \   00000044   0x7920             LDRB     R0,[R4, #+4]
   \   00000046   0x7030             STRB     R0,[R6, #+0]
   \   00000048   0xB001             ADD      SP,SP,#+4
   \   0000004A   0xBDF0             POP      {R4-R7,PC}       ;; return
    212          
    213          //---------------------------------------------------------------------------------------------------------------------
    214          /**
    215           * Get the address of the last action requested by the specified requestor.
    216           *
    217           * Note, this function is for internal use only.
    218           * It does not check whether or not the requestor has released control.
    219           *
    220           * @param control = Pointer to the arbitration control structure.
    221           * @param requestor = The requestor that asked for an action.
    222           */
    223          static void *GetActionPointer(ARB_CONTROL_TYPE *control, unsigned char requestor)
    224          {
    225              return ((unsigned char*)(control->Actions) + (requestor * control->Size_Of_Action_Type));
    226          }
    227          
    228          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   Arbitration__GetPrioritizedAction
        16   -> Utilities__GetBitInArray
         0   -> __aeabi_memcpy
       0   Arbitration__GetPrioritizedActionAndRequestor
         0   -> GetPrioritizedAction
       0   Arbitration__Initialize
         0   -> __aeabi_memclr
       0   Arbitration__ReleaseControl
         0   -> Utilities__SetBitInArray
      16   Arbitration__RequestControl
        16   -> Utilities__SetBitInArray
         0   -> __aeabi_memcpy
      24   GetPrioritizedAction
        24   -> Utilities__GetBitInArray
        24   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      66  Arbitration__GetPrioritizedAction
      18  Arbitration__GetPrioritizedActionAndRequestor
      22  Arbitration__Initialize
      18  Arbitration__ReleaseControl
      52  Arbitration__RequestControl
      76  GetPrioritizedAction

 
 252 bytes in section .text
 
 252 bytes of CODE memory

Errors: none
Warnings: none
