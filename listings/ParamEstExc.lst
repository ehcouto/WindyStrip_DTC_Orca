###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        19/Nov/2024  13:15:26
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  Category\Application\ParamEstExc\ParamEstExc.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        ParamEstExc.obj -l ..\listings\ParamEstExc.lst
#        Category\Application\ParamEstExc\ParamEstExc.c
#    List file    =  ..\listings\ParamEstExc.lst
#    Object file  =  ParamEstExc.obj
#
###############################################################################

C:\Data\Python\Windy_sBpm_Floating\source\Category\Application\ParamEstExc\ParamEstExc.c
      1          /**
      2           *  @file       
      3           *
      4           *  @brief      Source file for the ParamEstExc (Parameter Estimation Excitation) module.
      5           *
      6           *  @details    Creates oscillations in the motor rpm to produce variation in the torque signal.
      7           *
      8           *  @software owner     Paul Spindler
      9           *  @technology owner   Stephen Keres
     10           *
     11          
     12              @startuml{ParamEstExc_state_machine.png}
     13          
     14                  title Parameter Estimation Excitation State machine
     15          
     16                  [*] --> Idle
     17          
     18                  Idle : do / MonitorApiCommand
     19                  Idle --> Active : ev_enable
     20          
     21                  Active : enter / EnableModule
     22                  Active : do / ModuleActive
     23                  Active --> RpmOutOfRange : ev_rpm_out_of_range
     24                  Active --> Stop : ev_disable
     25          
     26                  Stop : enter / DisableModule
     27                  Stop : do / ModuleDisabling
     28                  Stop --> Idle : ev_module_disabled
     29          
     30                  RpmOutOfRange : enter / DisableModule
     31                  RpmOutOfRange : do / ModuleDisabling
     32                  RpmOutOfRange --> StoppedForRpmOutOfRange : ev_module_disabled
     33                  RpmOutOfRange --> Stop : ev_disable
     34          
     35                  StoppedForRpmOutOfRange : do / CheckRpmRange
     36                  StoppedForRpmOutOfRange --> Idle : ev_disable
     37                  StoppedForRpmOutOfRange --> Active : ev_rpm_in_range
     38          
     39              @enduml
     40          
     41           *
     42           *  $Header: ParamEstExc.c 1.5 2015/04/07 13:22:04EDT Paul F Spindler (SPINDPF) Exp  $
     43           *
     44           *  @copyright  Copyright 2014-$Date: 2015/04/07 13:22:04EDT $. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     45           */
     46          //---------------------------------------------------------------------------------------------------------------------
     47          //---------------------------------------------------------------------------------------------------------------------
     48          
     49          
     50          //-------------------------------------- Include Files ----------------------------------------------------------------
     51          #include "C_Extensions.h"
     52          
     53          #include "ParamEstExc.h"
     54          #include "ParamEstExc_prv.h"
     55          
     56          #include "limits.h"
     57          #include "math.h"
     58          #include "string.h"
     59          
     60          //=====================================================================================================================
     61          //=== StateEngineCrank (v1.5) Auto-Generated Definitions for Parameter Estimation Excitation State Machine
     62          //=====================================================================================================================
     63          // !! StateEngineCrank cannot update this code if you change the header !!
     64          
     65          
     66          //! Unique names used to identify states of the Parameter Estimation Excitation state machine.
     67          typedef enum PARAMETER_ESTIMATION_EXCITATION_STATE_ENUM
     68          {
     69              STATE_NONE                         = 0,
     70          
     71              STATE_IDLE                         = 1,         //!< (initial_state)
     72              STATE_ACTIVE                       = 2,
     73              STATE_RPM_OUT_OF_RANGE             = 3,
     74              STATE_STOP                         = 4,
     75              STATE_STOPPED_FOR_RPM_OUT_OF_RANGE = 5,
     76          
     77              STATE_PARAMETER_ESTIMATION_EXCITATION_END = 6
     78          } PARAMETER_ESTIMATION_EXCITATION_STATE_TYPE;
     79          
     80          //! The state variable for the Parameter Estimation Excitation state machine.
     81          //! State machines with a history pseudostate may write to this variable during initialization.
     82          //! Other state machines must only write to this variable through auto-generated functions.
     83          static PARAMETER_ESTIMATION_EXCITATION_STATE_TYPE Parameter_Estimation_Excitation_State;
     84          
     85          // -- Private Function Prototypes used by the state machine for customization functions --
     86          static void CheckRpmRange(void);
     87          static void DisableModule(void);
     88          static void EnableModule(void);
     89          static void ModuleActive(void);
     90          static void ModuleDisabling(void);
     91          static void MonitorApiCommand(void);
     92          
     93          // -- Private Function Prototypes used by the state machine for standard state machine functions --
     94          static void EventDisable(void);
     95          static void EventEnable(void);
     96          static void EventModuleDisabled(void);
     97          static void EventRpmInRange(void);
     98          static void EventRpmOutOfRange(void);
     99          static void ParameterEstimationExcitationExecute(void);
    100          static void ParameterEstimationExcitationInitialize(void);
    101          
    102          // !! StateEngineCrank cannot update this code if you change the footer !!
    103          // End of StateEngineCrank Auto-Generated Code.
    104          
    105          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
    106          
    107          typedef unsigned char   DOWN_SAMPLER_COUNTER_TYPE;          // 1 = 1 call of the API ParamIDExcitation__Handler()
    108          CT_ASSERT(INPUT_HANDLER_SLOT_PERIODS <= UCHAR_MAX);
    109          
    110          #define MSEC_TO_SEC(msec)           ((msec) / 1000.0f)                           //!< Conversion from milliseconds to seconds
    111          
    112          //! The sample rate of the Excitation generator. The possible combinations of slot options and
    113          //! integer downsample ratios will dictate the sample rates which may be achieved.
    114          #define TS_EXCITATION               MSEC_TO_SEC(INPUT_HANDLER_TIME_SLOT * INPUT_HANDLER_SLOT_PERIODS)
    115          
    116          #define SIGN(in)                    (((in) > 0) ? 1 : (((in) < 0) ? -1 : 0))    //!< Signum (sign function) macro
    117          
    118          /**
    119           *  Variable type definition for the module motor speed.
    120           *  Resolution: 1.0 = 1.0 rpm
    121           */
    122          typedef float MOTOR_SPEED_TYPE;
    123          
    124          //! Pseudo-random sequence from rand() normalized to be between 0 and 1. The random numbers are stored so there is
    125          //! consistency in testing from run-to-run, and across microcontrollers, since rand() and srand() implementations vary.

   \                                 In section .text, align 4, keep-with-next
    126          static const float RANDOM_SEQUENCE[] =
   \                     RANDOM_SEQUENCE:
   \   00000000   0x3EE0A31A         DC32 3EE0A31AH, 3EC35BA1H, 3F43F8E9H, 3F4B9239H, 3E3F5B88H, 3EFAC266H
   \              0x3EC35BA1   
   \              0x3F43F8E9   
   \              0x3F4B9239   
   \              0x3E3F5B88   
   \              0x3EFAC266   
   \   00000018   0x3EE423E0         DC32 3EE423E0H, 3F2574C5H, 3F3598EFH, 3F413325H, 3E8D5329H, 3F2E00FFH
   \              0x3F2574C5   
   \              0x3F3598EF   
   \              0x3F413325   
   \              0x3E8D5329   
   \              0x3F2E00FF   
   \   00000030   0x3F27B481         DC32 3F27B481H, 3E2683B1H, 3DF3B50EH, 3EFF2993H, 3F75B1C8H, 3EAE470AH
   \              0x3E2683B1   
   \              0x3DF3B50E   
   \              0x3EFF2993   
   \              0x3F75B1C8   
   \              0x3EAE470A   
   \   00000048   0x3F15D41B         DC32 3F15D41BH, 3E652EF5H
   \              0x3E652EF5   

   \                                 In section .bss, align 4
    127          {
    128              0.43874437f,
    129              0.38155845f,
    130              0.76551682f,
    131              0.79519993f,
    132              0.18687260f,
    133              0.48976439f,
    134              0.44558620f,
    135              0.64631301f,
    136              0.70936483f,
    137              0.75468665f,
    138              0.27602509f,
    139              0.67970270f,
    140              0.65509802f,
    141              0.16261174f,
    142              0.11899768f,
    143              0.49836406f,
    144              0.95974398f,
    145              0.34038574f,
    146              0.58526772f,
    147              0.22381194f
    148          };
    149          #define RANDOM_SEQUENCE_LENGTH  (sizeof(RANDOM_SEQUENCE) / sizeof(RANDOM_SEQUENCE[0]) )   //!< Length of pseudo-random sequence for use in excitation generation
    150          
    151          //! list of API commands the module will react to
    152          typedef enum
    153          {
    154              API_CMD_DISABLE = 0,
    155              API_CMD_ENABLE
    156          } API_CMD_TYPE;
    157          
    158          static const PARAM_EST_EXC_SETUP_TYPE*    Setup_Parameters;              //!< Internal storage of Excitation configuration parameters address
    159          
    160          //! definition of module static variables
    161          static struct
    162          {
    163              float                       Accel;                          //!< Acceleration excitation (RPM/s)
    164              MOTOR_SPEED_TYPE            W;                              //!< Speed excitation
    165              unsigned short              Generation_Counter;             //!< Counter for Excitation Generation
    166              signed char                 Sign_PRBS;                      //!< Current sign of PRBS acceleration
    167              unsigned char               Random_Sequence_Index;          //!< Current index in random sequence
    168              DOWN_SAMPLER_COUNTER_TYPE   Handler_Down_Sample_Counter;    //!< down sampler counter for the module execution
    169              API_CMD_TYPE                Api_Command;                    //!< Excitation enable/disable flag from user request
    170          } Exc;  // Excitation
   \                     Exc:
   \   00000000                      DS8 16
   \   00000010                      DS8 1
   \   00000011                      DS8 3
   \   00000014                      DS8 4
    171          
    172          
    173          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
    174          
    175          static void DecrementGenerationCounter(void);
    176          static BOOL_TYPE IsModuleActive(void);
    177          static void OutputSpeedReferenceGeneratorOffset(void);
    178          
    179          //=====================================================================================================================
    180          //-------------------------------------- Public Functions -------------------------------------------------------------
    181          //=====================================================================================================================
    182          
    183          //---------------------------------------------------------------------------------------------------------------------
    184          /**
    185           *  @brief      It Initializes the module ParamEstExc and its variables
    186           *
    187           */

   \                                 In section .text, align 2, keep-with-next
    188          void ParamEstExc__Initialize(void)
    189          {
    190              memset(&Exc, 0, sizeof(Exc));
   \                     ParamEstExc__Initialize: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x460B             MOV      R3,R1
   \   0000000A   0x468C             MOV      R12,R1
   \   0000000C   0xE8A0 0x100E      STM      R0!,{R1-R3,R12}
   \   00000010   0x3810             SUBS     R0,R0,#+16
    191              Setup_Parameters = NULL;
   \   00000012   0x6141             STR      R1,[R0, #+20]
    192              ParameterEstimationExcitationInitialize();
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x7401             STRB     R1,[R0, #+16]
    193          }
   \   00000018   0x4770             BX       LR               ;; return
    194          
    195          //---------------------------------------------------------------------------------------------------------------------
    196          /**
    197           *  @brief      The Parameter Estimation Excitation handler.
    198           *  @details    Shall be called from the slot defined by INPUT_HANDLER_SLOT_PERIODS.
    199           */

   \                                 In section .text, align 4, keep-with-next
    200          void ParamEstExc__Handler(void)
    201          {
   \                     ParamEstExc__Handler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    202              Exc.Handler_Down_Sample_Counter = (Exc.Handler_Down_Sample_Counter > 0) ? Exc.Handler_Down_Sample_Counter - 1 : 0;      // decrement and prevent underflow
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable9_4
   \   00000006   0x7B20             LDRB     R0,[R4, #+12]
   \   00000008   0xB100             CBZ.N    R0,??ParamEstExc__Handler_1
   \   0000000A   0x1E40             SUBS     R0,R0,#+1
   \                     ??ParamEstExc__Handler_1: (+1)
   \   0000000C   0x7320             STRB     R0,[R4, #+12]
   \   0000000E   0x7C20             LDRB     R0,[R4, #+16]
   \   00000010   0x1E41             SUBS     R1,R0,#+1
   \   00000012   0x2904             CMP      R1,#+4
   \   00000014   0xD85C             BHI.N    ??ParamEstExc__Handler_2
   \   00000016   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??ParamEstExc__Handler_0:
   \   0000001A   0x4E 0x4B          DC8      0x4E,0x4B,0x1E,0x1E
   \              0x1E 0x1E    
   \   0000001E   0x03 0x00          DC8      0x3,0x0
    203              ParameterEstimationExcitationExecute();
   \                     ??ParamEstExc__Handler_3: (+1)
   \   00000020   0x7B60             LDRB     R0,[R4, #+13]
   \   00000022   0xB910             CBNZ.N   R0,??ParamEstExc__Handler_4
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x7420             STRB     R0,[R4, #+16]
   \   00000028   0xBD10             POP      {R4,PC}
   \                     ??ParamEstExc__Handler_4: (+1)
   \   0000002A   0x2102             MOVS     R1,#+2
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x.... 0x....      BL       Mci__GetAnalog
   \   00000032   0xEE00 0x0A10      VMOV     S0,R0
   \   00000036   0xEEBA 0x0AC8      VCVT.F32.S32 S0,S0,#+16
   \   0000003A   0x....             LDR.N    R0,??DataTable9_5  ;; 0x41f00000
   \   0000003C   0xEEB0 0x0AC0      VABS.F32 S0,S0
   \   00000040   0xEE00 0x0A90      VMOV     S1,R0
   \   00000044   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000048   0xEEF1 0xFA10      FMSTAT   
   \   0000004C   0xDB40             BLT.N    ??ParamEstExc__Handler_2
   \   0000004E   0x7C20             LDRB     R0,[R4, #+16]
   \   00000050   0x2805             CMP      R0,#+5
   \   00000052   0xD13D             BNE.N    ??ParamEstExc__Handler_2
   \   00000054   0xE032             B.N      ??ParamEstExc__Handler_5
   \                     ??ParamEstExc__Handler_6: (+1)
   \   00000056   0x7B21             LDRB     R1,[R4, #+12]
   \   00000058   0x2900             CMP      R1,#+0
   \   0000005A   0xD139             BNE.N    ??ParamEstExc__Handler_2
   \   0000005C   0x2101             MOVS     R1,#+1
   \   0000005E   0x7321             STRB     R1,[R4, #+12]
   \   00000060   0x8921             LDRH     R1,[R4, #+8]
   \   00000062   0xB101             CBZ.N    R1,??ParamEstExc__Handler_7
   \   00000064   0x1E49             SUBS     R1,R1,#+1
   \                     ??ParamEstExc__Handler_7: (+1)
   \   00000066   0x8121             STRH     R1,[R4, #+8]
   \   00000068   0x8921             LDRH     R1,[R4, #+8]
   \   0000006A   0xB939             CBNZ.N   R1,??ParamEstExc__Handler_8
   \   0000006C   0x2803             CMP      R0,#+3
   \   0000006E   0xD003             BEQ.N    ??ParamEstExc__Handler_9
   \   00000070   0x2804             CMP      R0,#+4
   \   00000072   0xD103             BNE.N    ??ParamEstExc__Handler_8
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xE000             B.N      ??ParamEstExc__Handler_10
   \                     ??ParamEstExc__Handler_9: (+1)
   \   00000078   0x2005             MOVS     R0,#+5
   \                     ??ParamEstExc__Handler_10: (+1)
   \   0000007A   0x7420             STRB     R0,[R4, #+16]
   \                     ??ParamEstExc__Handler_8: (+1)
   \   0000007C   0xED94 0x0A00      VLDR     S0,[R4, #0]
   \   00000080   0xED94 0x1A01      VLDR     S2,[R4, #+4]
   \   00000084   0xEDDF 0x....      VLDR.W   S1,??DataTable9  ;; 0x3a83126f
   \   00000088   0xEE00 0x1A20      VMLA.F32 S2,S0,S1
   \   0000008C   0xED84 0x1A01      VSTR     S2,[R4, #+4]
   \   00000090   0x.... 0x....      BL       MciSensorsWm__GetTransmissionRatio
   \   00000094   0x2107             MOVS     R1,#+7
   \   00000096   0xEDD4 0x0A01      VLDR     S1,[R4, #+4]
   \   0000009A   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000009E   0xE8BD 0x4010      POP      {R4,LR}
   \   000000A2   0xEEBE 0x0AC8      VCVT.S32.F32 S0,S0,#+16
   \   000000A6   0xEE10 0x2A10      VMOV     R2,S0
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x.... 0x....      B.W      Mci__SetAnalog
   \                     ??ParamEstExc__Handler_11: (+1)
   \   000000B0   0xE8BD 0x4010      POP      {R4,LR}
   \   000000B4   0x....             B.N      ModuleActive
   \                     ??ParamEstExc__Handler_12: (+1)
   \   000000B6   0x7B60             LDRB     R0,[R4, #+13]
   \   000000B8   0x2801             CMP      R0,#+1
   \   000000BA   0xD109             BNE.N    ??ParamEstExc__Handler_2
   \                     ??ParamEstExc__Handler_5: (+1)
   \   000000BC   0x2002             MOVS     R0,#+2
   \   000000BE   0x7420             STRB     R0,[R4, #+16]
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x7320             STRB     R0,[R4, #+12]
   \   000000C4   0x8120             STRH     R0,[R4, #+8]
   \   000000C6   0x72E0             STRB     R0,[R4, #+11]
   \   000000C8   0x6020             STR      R0,[R4, #+0]
   \   000000CA   0x6060             STR      R0,[R4, #+4]
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0x72A0             STRB     R0,[R4, #+10]
    204          }
   \                     ??ParamEstExc__Handler_2: (+1)
   \   000000D0   0xBD10             POP      {R4,PC}          ;; return
    205          
    206          //---------------------------------------------------------------------------------------------------------------------
    207          /**
    208           *  @brief  Enables the Parameter Estimation Excitation module.
    209           */

   \                                 In section .text, align 2, keep-with-next
    210          void ParamEstExc__Enable(void)
    211          {
    212          	if ( Setup_Parameters == NULL )
   \                     ParamEstExc__Enable: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable9_4
   \   00000002   0x6941             LDR      R1,[R0, #+20]
   \   00000004   0xB109             CBZ.N    R1,??ParamEstExc__Enable_0
    213          	{
    214          		DEBUG_SETUP_PARAMETER_IS_NULL();
    215          	}
    216          	else
    217          	{
    218          		Exc.Api_Command = API_CMD_ENABLE;
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x7341             STRB     R1,[R0, #+13]
    219          	}
    220          }
   \                     ??ParamEstExc__Enable_0: (+1)
   \   0000000A   0x4770             BX       LR               ;; return
    221          
    222          //---------------------------------------------------------------------------------------------------------------------
    223          /**
    224           * @brief   Disables the Parameter Estimation Excitation module.
    225           */

   \                                 In section .text, align 2, keep-with-next
    226          void ParamEstExc__Disable(void)
    227          {
    228              Exc.Api_Command = API_CMD_DISABLE;
   \                     ParamEstExc__Disable: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable9_4
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x7348             STRB     R0,[R1, #+13]
    229          }
   \   00000006   0x4770             BX       LR               ;; return
    230          
    231          //---------------------------------------------------------------------------------------------------------------------
    232          /**
    233           * @brief   Return the status of the Parameter Estimation Excitation module.
    234           *
    235           * @return  TRUE = module is active; FALSE = module is inactive
    236           */

   \                                 In section .text, align 2, keep-with-next
    237          BOOL_TYPE ParamEstExc__IsRunning(void)
    238          {
    239              return ( IsModuleActive() );
   \                     ParamEstExc__IsRunning: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable9_4
   \   00000002   0x7C00             LDRB     R0,[R0, #+16]
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD101             BNE.N    ??ParamEstExc__IsRunning_0
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4770             BX       LR
   \                     ??ParamEstExc__IsRunning_0: (+1)
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x4770             BX       LR               ;; return
    240          }
    241          
    242          //---------------------------------------------------------------------------------------------------------------------
    243          /**
    244           *  @brief  Returns the current Parameter Estimation Excitation Setup.
    245           *  @param  setup   pointer to the Environment definition of the PARAM_EST_EXC_SETUP_TYPE
    246           *  @return The current Setup is not NULL
    247           */

   \                                 In section .text, align 2, keep-with-next
    248          BOOL_TYPE ParamEstExc__GetSetup(PARAM_EST_EXC_SETUP_TYPE *parameters)
    249          {
   \                     ParamEstExc__GetSetup: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    250          	BOOL_TYPE ret = FALSE;
   \   00000002   0x....             LDR.N    R1,??DataTable9_4
   \   00000004   0x6949             LDR      R1,[R1, #+20]
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xBF1F             ITTTT    NE 
    251              if ( Setup_Parameters != NULL )
    252              {
    253              	ret = TRUE;
   \   0000000C   0x2401             MOVNE    R4,#+1
    254              	if ( parameters != NULL )
   \   0000000E   0x2800             CMPNE    R0,#+0
    255              		memcpy(parameters, Setup_Parameters, sizeof(PARAM_EST_EXC_SETUP_TYPE));
   \   00000010   0x2209             MOVNE    R2,#+9
   \   00000012   0x.... 0x....      BLNE     __aeabi_memcpy
    256              }
    257              return ret;
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    258          }
    259          
    260          //---------------------------------------------------------------------------------------------------------------------
    261          /**
    262           *  @brief  Set the module's functional parameters
    263           *  @param  parameters  Environment specific setup.
    264           *  @return Is the new ParamEstExc setup valid?
    265           */

   \                                 In section .text, align 4, keep-with-next
    266          BOOL_TYPE ParamEstExc__SetSetup(const PARAM_EST_EXC_SETUP_TYPE *parameters)
    267          {
    268              BOOL_TYPE config_valid = TRUE;
   \                     ParamEstExc__SetSetup: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
    269              if ( parameters == NULL )
   \   00000002   0xB198             CBZ.N    R0,??ParamEstExc__SetSetup_0
    270              {
    271                  DEBUG_SETUP_PARAMETER_IS_NULL();
    272                  return config_valid = FALSE;
    273              }
    274              else
    275              {
    276                  if ( parameters->Time < INPUT_EXCITATION_MIN_TIME )
   \   00000004   0x6842             LDR      R2,[R0, #+4]
   \   00000006   0xEE00 0x2A10      VMOV     S0,R2
   \   0000000A   0xEDDF 0x....      VLDR.W   S1,??DataTable9_1  ;; 0x3dcccccd
   \   0000000E   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000012   0xEEF1 0xFA10      FMSTAT   
   \   00000016   0xBF48             IT       MI 
    277                  {
    278                      DEBUG_INVALID_EXC_TIME(parameters->Time);
    279                      config_valid = FALSE;
   \   00000018   0x2100             MOVMI    R1,#+0
    280                  }
    281                  // else parameters.Time >= INPUT_EXCITATION_MIN_TIME, time is valid, do nothing
    282          
    283                  // If the user selects an invalid excitation method, reject the configuration.
    284                  if ( parameters->Method >= NUM_OF_PARAM_EXC_METHODS )
   \   0000001A   0x7A02             LDRB     R2,[R0, #+8]
   \   0000001C   0x2A02             CMP      R2,#+2
   \   0000001E   0xBFA8             IT       GE 
    285                  {
    286                      DEBUG_INVALID_EXC_METHOD(parameters->Method);
    287                      config_valid = FALSE;
   \   00000020   0x2100             MOVGE    R1,#+0
   \   00000022   0xDA02             BGE.N    ??ParamEstExc__SetSetup_1
    288                  }
    289          
    290                  if ( config_valid == TRUE )
   \   00000024   0xB109             CBZ.N    R1,??ParamEstExc__SetSetup_1
    291                  {
    292                      Setup_Parameters = parameters;
   \   00000026   0x....             LDR.N    R2,??DataTable9_4
   \   00000028   0x6150             STR      R0,[R2, #+20]
    293                  }
    294              }
    295          
    296              return config_valid;
   \                     ??ParamEstExc__SetSetup_1: (+1)
   \   0000002A   0x4608             MOV      R0,R1
   \                     ??ParamEstExc__SetSetup_0: (+1)
   \   0000002C   0x4770             BX       LR               ;; return
    297          }
    298          
    299          
    300          //=====================================================================================================================
    301          //-------------------------------------- Private Functions ------------------------------------------------------------
    302          //=====================================================================================================================
    303          
    304          //---------------------------------------------------------------------------------------------------------------------
    305          /**
    306           *  @brief      Decrement the static variable Generation_Counter and prevent underflow.
    307           */
    308          static void DecrementGenerationCounter(void)
    309          {
    310              Exc.Generation_Counter = (Exc.Generation_Counter > 0) ? Exc.Generation_Counter - 1 : 0;
    311          }
    312          
    313          //---------------------------------------------------------------------------------------------------------------------
    314          /**
    315           *  @brief  Returns if the module is inactive or active
    316           *
    317           *  @return TRUE = module is active; FALSE = module is inactive
    318           */
    319          BOOL_TYPE IsModuleActive(void)
    320          {
    321              return ( (Parameter_Estimation_Excitation_State == STATE_IDLE) ? FALSE : TRUE );
    322          }
    323          
    324          //---------------------------------------------------------------------------------------------------------------------
    325          /**
    326           *  @brief      Calculates and outputs the speed offset.
    327           */
    328          static void OutputSpeedReferenceGeneratorOffset(void)
    329          {
    330              Exc.W += Exc.Accel * TS_EXCITATION;     // Integrate acceleration reference to get speed reference
    331              OUTPUT_SPEED_REF_GEN_OFFSET(Exc.W);     // Send excitation to speed reference generator
    332          }
    333          
    334          
    335          //=====================================================================================================================
    336          //-- Private State Machine Customization Functions --------------------------------------------------------------------
    337          //=====================================================================================================================
    338          
    339          //---------------------------------------------------------------------------------------------------------------------
    340          /**
    341           *  @brief      Monitors the static variable Api_Command to determine if the module should be enabled.
    342           */
    343          static void MonitorApiCommand(void)
    344          {
    345              switch ( Exc.Api_Command )
    346              {
    347                  case API_CMD_DISABLE:
    348                      break;
    349                  case API_CMD_ENABLE:
    350                      EventEnable();
    351                      break;
    352                  default:
    353                      break;
    354              }
    355          }
    356          
    357          //---------------------------------------------------------------------------------------------------------------------
    358          /**
    359           *  @brief      Definition of the necessary tasks to enable the algorithm.
    360           */
    361          static void EnableModule(void)
    362          {
    363              Exc.Handler_Down_Sample_Counter = 0;
    364              Exc.Generation_Counter = 0;
    365              Exc.Random_Sequence_Index = 0;
    366              Exc.Accel = 0.0f;
    367              Exc.W = 0.0f;
    368              Exc.Sign_PRBS = 1;
    369          }
    370          
    371          //---------------------------------------------------------------------------------------------------------------------
    372          /**
    373           *  @brief      Performs the necessary tasks when the algorithm is active.
    374           */

   \                                 In section .text, align 4, keep-with-next
    375          static void ModuleActive(void)
    376          {
   \                     ModuleActive: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    377              if ( Exc.Handler_Down_Sample_Counter == 0 )
   \   00000002   0x....             LDR.N    R4,??DataTable9_4
   \   00000004   0x7B20             LDRB     R0,[R4, #+12]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xF040 0x80D9      BNE.W    ??ModuleActive_0
    378              {
    379                  Exc.Handler_Down_Sample_Counter = INPUT_HANDLER_SLOT_PERIODS;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x7320             STRB     R0,[R4, #+12]
    380          
    381                  MOTOR_SPEED_TYPE motor_speed = fabsf(INPUT_MOTOR_SPEED());
   \   00000010   0x2102             MOVS     R1,#+2
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       Mci__GetAnalog
   \   00000018   0xEE00 0x0A10      VMOV     S0,R0
   \   0000001C   0xEEBA 0x0AC8      VCVT.F32.S32 S0,S0,#+16
    382                  // Perform check to stop the module if the speed drops too low
    383                  if ( motor_speed < fabsf(INPUT_MIN_SPEED) )
   \   00000020   0x....             LDR.N    R0,??DataTable9_5  ;; 0x41f00000
   \   00000022   0xEEB0 0x0AC0      VABS.F32 S0,S0
   \   00000026   0xEE00 0x0A90      VMOV     S1,R0
   \   0000002A   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000002E   0xEEF1 0xFA10      FMSTAT   
   \   00000032   0xD505             BPL.N    ??ModuleActive_1
    384                  {
    385                      DEBUG_MIN_SPEED_VIOLATION(motor_speed);
    386                      EventRpmOutOfRange();
   \   00000034   0x7C20             LDRB     R0,[R4, #+16]
   \   00000036   0x2802             CMP      R0,#+2
   \   00000038   0xF040 0x80C1      BNE.W    ??ModuleActive_0
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0xE00C             B.N      ??ModuleActive_2
    387                  }
    388                  else if ( Exc.Api_Command == API_CMD_DISABLE )
   \                     ??ModuleActive_1: (+1)
   \   00000040   0x7B60             LDRB     R0,[R4, #+13]
   \   00000042   0xB970             CBNZ.N   R0,??ModuleActive_3
    389                  {
    390                      EventDisable();
   \   00000044   0x7C20             LDRB     R0,[R4, #+16]
   \   00000046   0x1E80             SUBS     R0,R0,#+2
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD905             BLS.N    ??ModuleActive_4
   \   0000004C   0x1EC0             SUBS     R0,R0,#+3
   \   0000004E   0xF040 0x80B6      BNE.W    ??ModuleActive_0
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x7420             STRB     R0,[R4, #+16]
   \   00000056   0xBD10             POP      {R4,PC}
   \                     ??ModuleActive_4: (+1)
   \   00000058   0x2004             MOVS     R0,#+4
   \                     ??ModuleActive_2: (+1)
   \   0000005A   0x7420             STRB     R0,[R4, #+16]
   \   0000005C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000060   0x....             B.N      DisableModule
    391                  }
    392                  else
    393                  {
    394                      DecrementGenerationCounter();
   \                     ??ModuleActive_3: (+1)
   \   00000062   0x8920             LDRH     R0,[R4, #+8]
   \   00000064   0xB100             CBZ.N    R0,??ModuleActive_5
   \   00000066   0x1E40             SUBS     R0,R0,#+1
   \                     ??ModuleActive_5: (+1)
   \   00000068   0x8120             STRH     R0,[R4, #+8]
    395                      if ( Exc.Generation_Counter == 0 )
   \   0000006A   0x8920             LDRH     R0,[R4, #+8]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xF040 0x808C      BNE.W    ??ModuleActive_6
    396                      {                                           // go to the next random number in the sequence
    397                          if ( Exc.Random_Sequence_Index < RANDOM_SEQUENCE_LENGTH )
   \   00000072   0x7AE0             LDRB     R0,[R4, #+11]
   \   00000074   0x2814             CMP      R0,#+20
   \   00000076   0xD25A             BCS.N    ??ModuleActive_7
    398                          {                                                       // choose the next number in the random sequence
    399                              switch ( Setup_Parameters->Method )
   \   00000078   0x6960             LDR      R0,[R4, #+20]
   \   0000007A   0x7A01             LDRB     R1,[R0, #+8]
   \   0000007C   0xB381             CBZ.N    R1,??ModuleActive_8
   \   0000007E   0x2901             CMP      R1,#+1
   \   00000080   0xD151             BNE.N    ??ModuleActive_9
    400                              {
    401                                  case PARAM_EXC_METHOD_PRBS:          // Pseudorandom Binary Sequence (random time two-level excitation)
    402                                      Exc.Accel = Exc.Sign_PRBS * Setup_Parameters->Amplitude;
   \   00000082   0x6801             LDR      R1,[R0, #+0]
   \   00000084   0xF994 0x000A      LDRSB    R0,[R4, #+10]
   \   00000088   0xEE00 0x0A90      VMOV     S1,R0
    403                                      Exc.Sign_PRBS = -Exc.Sign_PRBS;     // flip the acceleration to the other level
   \   0000008C   0x4240             RSBS     R0,R0,#+0
   \   0000008E   0x72A0             STRB     R0,[R4, #+10]
   \   00000090   0xEE00 0x1A10      VMOV     S0,R1
   \   00000094   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
    404          
    405                                      // The time to next switch is chosen randomly as U[INPUT_EXC_MIN_TIME, Time]
    406                                      // Mod_Exc is the number of periods of exc. gen. corresponding to this time
    407                                      Exc.Generation_Counter = (unsigned short)((((Setup_Parameters->Time - INPUT_EXCITATION_MIN_TIME) * RANDOM_SEQUENCE[Exc.Random_Sequence_Index]) + INPUT_EXCITATION_MIN_TIME) / TS_EXCITATION);
   \   00000098   0x6960             LDR      R0,[R4, #+20]
   \   0000009A   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   0000009E   0xED84 0x0A00      VSTR     S0,[R4, #0]
   \   000000A2   0xEDDF 0x....      VLDR.W   S1,??DataTable9_2  ;; 0xbdcccccd
   \   000000A6   0x6841             LDR      R1,[R0, #+4]
   \   000000A8   0x.... 0x....      ADR.W    R0,RANDOM_SEQUENCE
   \   000000AC   0xEE00 0x1A10      VMOV     S0,R1
   \   000000B0   0x7AE1             LDRB     R1,[R4, #+11]
   \   000000B2   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   000000B6   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   000000BA   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   000000BE   0xED9F 0x....      VLDR.W   S2,??DataTable9_1  ;; 0x3dcccccd
   \   000000C2   0xEE00 0x1A20      VMLA.F32 S2,S0,S1
   \   000000C6   0xED9F 0x....      VLDR.W   S0,??DataTable9  ;; 0x3a83126f
   \   000000CA   0xEE81 0x0A00      VDIV.F32 S0,S2,S0
   \   000000CE   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   000000D2   0xEE10 0x0A10      VMOV     R0,S0
   \   000000D6   0x8120             STRH     R0,[R4, #+8]
    408                                      break;
    409                                  case PARAM_EXC_METHOD_WN:            // White noise (fixed-time random amplitude excitation)
    410                                      // The time to next switch is fixed.
    411                                      // Define is the number of periods of exc. gen. corresponding to this time
    412                                      Exc.Generation_Counter = (unsigned short)(Setup_Parameters->Time / TS_EXCITATION);
    413          
    414                                      // The next acceleration rate is a random number U(-Amplitude, Amplitude)
    415                                      Exc.Accel = 2.0f * Setup_Parameters->Amplitude * (RANDOM_SEQUENCE[Exc.Random_Sequence_Index] - 0.5f);
    416                                      break;
    417                                  default:        // Code should never get here, invalid excitation method
    418                                      // an invalid excitation method is posted by macro DEBUG_INVALID_EXCITATION_METHOD in ParamEstExc__Start()
    419                                      break;
    420                              }
    421                              Exc.Random_Sequence_Index++;
   \   000000D8   0x7AE0             LDRB     R0,[R4, #+11]
   \   000000DA   0x1C40             ADDS     R0,R0,#+1
   \   000000DC   0x72E0             STRB     R0,[R4, #+11]
   \   000000DE   0xE054             B.N      ??ModuleActive_6
   \                     ??ModuleActive_8: (+1)
   \   000000E0   0xEDDF 0x....      VLDR.W   S1,??DataTable9  ;; 0x3a83126f
   \   000000E4   0x6841             LDR      R1,[R0, #+4]
   \   000000E6   0xEE00 0x1A10      VMOV     S0,R1
   \   000000EA   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   000000EE   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   000000F2   0xEE10 0x0A10      VMOV     R0,S0
   \   000000F6   0x8120             STRH     R0,[R4, #+8]
   \   000000F8   0xEEF0 0x0A00      VMOV.F32 S1,#2.0
   \   000000FC   0x6960             LDR      R0,[R4, #+20]
   \   000000FE   0x6801             LDR      R1,[R0, #+0]
   \   00000100   0x.... 0x....      ADR.W    R0,RANDOM_SEQUENCE
   \   00000104   0xEE00 0x1A10      VMOV     S0,R1
   \   00000108   0x7AE1             LDRB     R1,[R4, #+11]
   \   0000010A   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   0000010E   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000112   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000116   0xEEBE 0x1A00      VMOV.F32 S2,#-0.5
   \   0000011A   0xEE70 0x0A81      VADD.F32 S1,S1,S2
   \   0000011E   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000122   0xED84 0x0A00      VSTR     S0,[R4, #0]
   \                     ??ModuleActive_9: (+1)
   \   00000126   0x7AE0             LDRB     R0,[R4, #+11]
   \   00000128   0x1C40             ADDS     R0,R0,#+1
   \   0000012A   0x72E0             STRB     R0,[R4, #+11]
   \   0000012C   0xE02D             B.N      ??ModuleActive_6
    422                          }
    423                          else // Random_Sequence_Index >= RANDOM_SEQUENCE_LENGTH
    424                          {
    425                              // the excitation random sequence has been completed, bring W_Exc back to zero
    426                              if ( Exc.Random_Sequence_Index != 0 )
    427                              {
    428                                  // the if statement is required due to the IAR Compiler optimizing out the following line of code
    429                                  Exc.Random_Sequence_Index = 0;
   \                     ??ModuleActive_7: (+1)
   \   0000012E   0x2000             MOVS     R0,#+0
    430                              }
    431                              Exc.Accel = - SIGN(Exc.W) * Setup_Parameters->Amplitude;                        // Accelerate back to W_Ref = 0
   \   00000130   0xED94 0x0A01      VLDR     S0,[R4, #+4]
   \   00000134   0x72E0             STRB     R0,[R4, #+11]
   \   00000136   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000013A   0xEEF1 0xFA10      FMSTAT   
   \   0000013E   0xBFC8             IT       GT 
   \   00000140   0x2001             MOVGT    R0,#+1
   \   00000142   0xDC06             BGT.N    ??ModuleActive_10
   \   00000144   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000148   0xEEF1 0xFA10      FMSTAT   
   \   0000014C   0xBF48             IT       MI 
   \   0000014E   0xF04F 0x30FF      MOVMI    R0,#-1
   \                     ??ModuleActive_10: (+1)
   \   00000152   0x4240             RSBS     R0,R0,#+0
   \   00000154   0xEE00 0x0A10      VMOV     S0,R0
   \   00000158   0x6960             LDR      R0,[R4, #+20]
   \   0000015A   0x6801             LDR      R1,[R0, #+0]
   \   0000015C   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000160   0xEE00 0x1A90      VMOV     S1,R1
   \   00000164   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000168   0xED84 0x0A00      VSTR     S0,[R4, #0]
    432                              Exc.Generation_Counter = (unsigned int)((-Exc.W / Exc.Accel) / TS_EXCITATION);  // This time will result in zeroing the W_Ref to correct for any drift
   \   0000016C   0xED94 0x0A01      VLDR     S0,[R4, #+4]
   \   00000170   0xEDD4 0x0A00      VLDR     S1,[R4, #0]
   \   00000174   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000178   0xEDDF 0x....      VLDR.W   S1,??DataTable9_3  ;; 0xba83126f
   \   0000017C   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000180   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \   00000184   0xEE10 0x0A10      VMOV     R0,S0
   \   00000188   0x8120             STRH     R0,[R4, #+8]
    433                          }
    434                      }
    435                      // else Exc.Generation_Counter > 0, do nothing
    436                      OutputSpeedReferenceGeneratorOffset();
   \                     ??ModuleActive_6: (+1)
   \   0000018A   0xEDDF 0x....      VLDR.W   S1,??DataTable9  ;; 0x3a83126f
   \   0000018E   0xED94 0x0A00      VLDR     S0,[R4, #0]
   \   00000192   0xED94 0x1A01      VLDR     S2,[R4, #+4]
   \   00000196   0xEE00 0x1A20      VMLA.F32 S2,S0,S1
   \   0000019A   0xED84 0x1A01      VSTR     S2,[R4, #+4]
   \   0000019E   0x.... 0x....      BL       MciSensorsWm__GetTransmissionRatio
   \   000001A2   0x2107             MOVS     R1,#+7
   \   000001A4   0xEDD4 0x0A01      VLDR     S1,[R4, #+4]
   \   000001A8   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000001AC   0xE8BD 0x4010      POP      {R4,LR}
   \   000001B0   0xEEBE 0x0AC8      VCVT.S32.F32 S0,S0,#+16
   \   000001B4   0xEE10 0x2A10      VMOV     R2,S0
   \   000001B8   0x2000             MOVS     R0,#+0
   \   000001BA   0x.... 0x....      B.W      Mci__SetAnalog
    437                  }
    438              }
    439              // else Exc.Handler_Down_Sample_Counter > 0, do nothing
    440          }
   \                     ??ModuleActive_0: (+1)
   \   000001BE   0xBD10             POP      {R4,PC}          ;; return
    441          
    442          //---------------------------------------------------------------------------------------------------------------------
    443          /**
    444           *  @brief      Definition of the necessary tasks to disable the algorithm.
    445           */

   \                                 In section .text, align 4, keep-with-next
    446          static void DisableModule(void)
    447          {
    448              if ( Exc.W != 0 )
   \                     DisableModule: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable9_4
   \   00000002   0xED90 0x0A01      VLDR     S0,[R0, #+4]
   \   00000006   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000000A   0xEEF1 0xFA10      FMSTAT   
   \   0000000E   0xD02A             BEQ.N    ??DisableModule_0
    449              {
    450                  Exc.Accel = - SIGN(Exc.W) * Setup_Parameters->Amplitude;                            // Accelerate back to W_Ref = 0
   \   00000010   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000014   0xEEF1 0xFA10      FMSTAT   
   \   00000018   0xBFC8             IT       GT 
   \   0000001A   0x2101             MOVGT    R1,#+1
   \   0000001C   0xDC07             BGT.N    ??DisableModule_1
   \   0000001E   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000022   0xEEF1 0xFA10      FMSTAT   
   \   00000026   0xBF4C             ITE      MI 
   \   00000028   0xF04F 0x31FF      MOVMI    R1,#-1
   \   0000002C   0x2100             MOVPL    R1,#+0
   \                     ??DisableModule_1: (+1)
   \   0000002E   0x4249             RSBS     R1,R1,#+0
   \   00000030   0xEE00 0x1A10      VMOV     S0,R1
   \   00000034   0x6941             LDR      R1,[R0, #+20]
   \   00000036   0x680A             LDR      R2,[R1, #+0]
   \   00000038   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000003C   0xEE00 0x2A90      VMOV     S1,R2
   \   00000040   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000044   0xED80 0x0A00      VSTR     S0,[R0, #0]
    451                  Exc.Generation_Counter = (unsigned short)((-Exc.W / Exc.Accel) / TS_EXCITATION);    // This time will result in zeroing the W_Ref to correct for any drift.
   \   00000048   0xED90 0x0A01      VLDR     S0,[R0, #+4]
   \   0000004C   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000050   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000054   0xEDDF 0x....      VLDR.W   S1,??DataTable9_3  ;; 0xba83126f
   \   00000058   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   0000005C   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000060   0xEE10 0x1A10      VMOV     R1,S0
   \   00000064   0xE000             B.N      ??DisableModule_2
    452              }
    453              else
    454              {
    455                  Exc.Generation_Counter = 0;
   \                     ??DisableModule_0: (+1)
   \   00000066   0x2100             MOVS     R1,#+0
   \                     ??DisableModule_2: (+1)
   \   00000068   0x8101             STRH     R1,[R0, #+8]
    456              }
    457          
    458              if ( Exc.Generation_Counter == 0 )
   \   0000006A   0x8901             LDRH     R1,[R0, #+8]
   \   0000006C   0xB941             CBNZ.N   R1,??DisableModule_3
    459              {
    460                  EventModuleDisabled();
   \   0000006E   0x7C01             LDRB     R1,[R0, #+16]
   \   00000070   0x2903             CMP      R1,#+3
   \   00000072   0xD003             BEQ.N    ??DisableModule_4
   \   00000074   0x2904             CMP      R1,#+4
   \   00000076   0xD103             BNE.N    ??DisableModule_3
   \   00000078   0x2101             MOVS     R1,#+1
   \   0000007A   0xE000             B.N      ??DisableModule_5
   \                     ??DisableModule_4: (+1)
   \   0000007C   0x2105             MOVS     R1,#+5
   \                     ??DisableModule_5: (+1)
   \   0000007E   0x7401             STRB     R1,[R0, #+16]
    461              }
    462              // else stay in state
    463          }
   \                     ??DisableModule_3: (+1)
   \   00000080   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x3A83126F         DC32     0x3a83126f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x3DCCCCCD         DC32     0x3dcccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0xBDCCCCCD         DC32     0xbdcccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0xBA83126F         DC32     0xba83126f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     Exc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x41F00000         DC32     0x41f00000
    464          
    465          //---------------------------------------------------------------------------------------------------------------------
    466          /**
    467           *  @brief      Performs the necessary tasks to disable the algorithm.
    468           */
    469          static void ModuleDisabling(void)
    470          {
    471              if ( Exc.Handler_Down_Sample_Counter == 0 )
    472              {
    473                  Exc.Handler_Down_Sample_Counter = INPUT_HANDLER_SLOT_PERIODS;
    474                  DecrementGenerationCounter();
    475                  if ( Exc.Generation_Counter == 0 )
    476                  {
    477                      EventModuleDisabled();
    478                  }
    479                  // else Exc.Generation_Counter > 0, do nothing
    480                  OutputSpeedReferenceGeneratorOffset();
    481              }
    482              // else Exc.Handler_Down_Sample_Counter > 0, do nothing
    483          }
    484          
    485          //---------------------------------------------------------------------------------------------------------------------
    486          /**
    487           *  @brief      Monitors the rpm and re-enables the module when the rpm is greater than the minimum.
    488           */
    489          static void CheckRpmRange(void)
    490          {
    491              if ( Exc.Api_Command == API_CMD_DISABLE )
    492              {
    493                  EventDisable();
    494              }
    495              else if ( fabsf(INPUT_MOTOR_SPEED()) >= fabsf(INPUT_MIN_SPEED) )
    496              {
    497                  EventRpmInRange();
    498              }
    499              // else stay in state, min speed not met
    500          }
    501          
    502          
    503          //=====================================================================================================================
    504          //=== StateEngineCrank (v1.5) Auto-Generated Functions for Parameter Estimation Excitation State Machine
    505          //=====================================================================================================================
    506          // !! StateEngineCrank cannot update this code if you change the header !!
    507          
    508          
    509          //---------------------------------------------------------------------------------------------------------------------
    510          /**
    511           * Process the Ev Disable Event for the Parameter Estimation Excitation state machine.
    512           *
    513           *              >>> DO NOT MODIFY THIS FUNCTION <<<
    514           *
    515           * This function was auto-generated and must not be edited manually.
    516           * Change the UML used to generate this function and regenerate the source code.
    517           */
    518          static void EventDisable(void)
    519          {
    520              switch (Parameter_Estimation_Excitation_State)
    521              {
    522                  case STATE_ACTIVE:
    523                      Parameter_Estimation_Excitation_State = STATE_STOP;
    524                      DisableModule();                        // STATE_STOP enter function.
    525                      break;
    526          
    527                  case STATE_RPM_OUT_OF_RANGE:
    528                      Parameter_Estimation_Excitation_State = STATE_STOP;
    529                      DisableModule();                        // STATE_STOP enter function.
    530                      break;
    531          
    532                  case STATE_STOPPED_FOR_RPM_OUT_OF_RANGE:
    533                      Parameter_Estimation_Excitation_State = STATE_IDLE;
    534                      break;
    535          
    536                  default:
    537                      // Event is ignored for all other values of Parameter_Estimation_Excitation_State.
    538                      break;
    539              }
    540          }
    541          
    542          
    543          //---------------------------------------------------------------------------------------------------------------------
    544          /**
    545           * Process the Ev Enable Event for the Parameter Estimation Excitation state machine.
    546           *
    547           *              >>> DO NOT MODIFY THIS FUNCTION <<<
    548           *
    549           * This function was auto-generated and must not be edited manually.
    550           * Change the UML used to generate this function and regenerate the source code.
    551           */
    552          static void EventEnable(void)
    553          {
    554              switch (Parameter_Estimation_Excitation_State)
    555              {
    556                  case STATE_IDLE:
    557                      Parameter_Estimation_Excitation_State = STATE_ACTIVE;
    558                      EnableModule();                         // STATE_ACTIVE enter function.
    559                      break;
    560          
    561                  default:
    562                      // Event is ignored for all other values of Parameter_Estimation_Excitation_State.
    563                      break;
    564              }
    565          }
    566          
    567          
    568          //---------------------------------------------------------------------------------------------------------------------
    569          /**
    570           * Process the Ev Module Disabled Event for the Parameter Estimation Excitation state machine.
    571           *
    572           *              >>> DO NOT MODIFY THIS FUNCTION <<<
    573           *
    574           * This function was auto-generated and must not be edited manually.
    575           * Change the UML used to generate this function and regenerate the source code.
    576           */
    577          static void EventModuleDisabled(void)
    578          {
    579              switch (Parameter_Estimation_Excitation_State)
    580              {
    581                  case STATE_RPM_OUT_OF_RANGE:
    582                      Parameter_Estimation_Excitation_State = STATE_STOPPED_FOR_RPM_OUT_OF_RANGE;
    583                      break;
    584          
    585                  case STATE_STOP:
    586                      Parameter_Estimation_Excitation_State = STATE_IDLE;
    587                      break;
    588          
    589                  default:
    590                      // Event is ignored for all other values of Parameter_Estimation_Excitation_State.
    591                      break;
    592              }
    593          }
    594          
    595          
    596          //---------------------------------------------------------------------------------------------------------------------
    597          /**
    598           * Process the Ev Rpm In Range Event for the Parameter Estimation Excitation state machine.
    599           *
    600           *              >>> DO NOT MODIFY THIS FUNCTION <<<
    601           *
    602           * This function was auto-generated and must not be edited manually.
    603           * Change the UML used to generate this function and regenerate the source code.
    604           */
    605          static void EventRpmInRange(void)
    606          {
    607              switch (Parameter_Estimation_Excitation_State)
    608              {
    609                  case STATE_STOPPED_FOR_RPM_OUT_OF_RANGE:
    610                      Parameter_Estimation_Excitation_State = STATE_ACTIVE;
    611                      EnableModule();                         // STATE_ACTIVE enter function.
    612                      break;
    613          
    614                  default:
    615                      // Event is ignored for all other values of Parameter_Estimation_Excitation_State.
    616                      break;
    617              }
    618          }
    619          
    620          
    621          //---------------------------------------------------------------------------------------------------------------------
    622          /**
    623           * Process the Ev Rpm Out Of Range Event for the Parameter Estimation Excitation state machine.
    624           *
    625           *              >>> DO NOT MODIFY THIS FUNCTION <<<
    626           *
    627           * This function was auto-generated and must not be edited manually.
    628           * Change the UML used to generate this function and regenerate the source code.
    629           */
    630          static void EventRpmOutOfRange(void)
    631          {
    632              switch (Parameter_Estimation_Excitation_State)
    633              {
    634                  case STATE_ACTIVE:
    635                      Parameter_Estimation_Excitation_State = STATE_RPM_OUT_OF_RANGE;
    636                      DisableModule();                        // STATE_RPM_OUT_OF_RANGE enter function.
    637                      break;
    638          
    639                  default:
    640                      // Event is ignored for all other values of Parameter_Estimation_Excitation_State.
    641                      break;
    642              }
    643          }
    644          
    645          
    646          //---------------------------------------------------------------------------------------------------------------------
    647          /**
    648           * The main execution function for the Parameter Estimation Excitation state machine.
    649           * This function should be called periodically while the state machine is running.
    650           *
    651           *              >>> DO NOT MODIFY THIS FUNCTION <<<
    652           *
    653           * This function was auto-generated and must not be edited manually.
    654           * Change the UML used to generate this function and regenerate the source code.
    655           */
    656          static void ParameterEstimationExcitationExecute(void)
    657          {
    658              switch (Parameter_Estimation_Excitation_State)
    659              {
    660                  case STATE_IDLE:
    661                      MonitorApiCommand();                    // STATE_IDLE do function.
    662                      break;
    663          
    664                  case STATE_ACTIVE:
    665                      ModuleActive();                         // STATE_ACTIVE do function.
    666                      break;
    667          
    668                  case STATE_RPM_OUT_OF_RANGE:
    669                      ModuleDisabling();                      // STATE_RPM_OUT_OF_RANGE do function.
    670                      break;
    671          
    672                  case STATE_STOP:
    673                      ModuleDisabling();                      // STATE_STOP do function.
    674                      break;
    675          
    676                  case STATE_STOPPED_FOR_RPM_OUT_OF_RANGE:
    677                      CheckRpmRange();                        // STATE_STOPPED_FOR_RPM_OUT_OF_RANGE do function.
    678                      break;
    679          
    680                  default:
    681                      // There is nothing to do for all other values of Parameter_Estimation_Excitation_State.
    682                      break;
    683              }
    684          }
    685          
    686          
    687          //---------------------------------------------------------------------------------------------------------------------
    688          /**
    689           * The initialization function for the Parameter Estimation Excitation state machine.
    690           * This function resets the state machine to the initial state.
    691           *
    692           *              >>> DO NOT MODIFY THIS FUNCTION <<<
    693           *
    694           * This function was auto-generated and must not be edited manually.
    695           * Change the UML used to generate this function and regenerate the source code.
    696           */
    697          static void ParameterEstimationExcitationInitialize(void)
    698          {
    699              Parameter_Estimation_Excitation_State = STATE_IDLE;
    700          }
    701          
    702          
    703          // !! StateEngineCrank cannot update this code if you change the footer !!
    704          // End of StateEngineCrank Auto-Generated Code.

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DisableModule
       8   ModuleActive
         0   -> DisableModule
         8   -> MciSensorsWm__GetTransmissionRatio
         8   -> Mci__GetAnalog
         0   -> Mci__SetAnalog
       0   ParamEstExc__Disable
       0   ParamEstExc__Enable
       8   ParamEstExc__GetSetup
         8   -> __aeabi_memcpy
       8   ParamEstExc__Handler
         8   -> MciSensorsWm__GetTransmissionRatio
         8   -> Mci__GetAnalog
         0   -> Mci__SetAnalog
         0   -> ModuleActive
       0   ParamEstExc__Initialize
       0   ParamEstExc__IsRunning
       0   ParamEstExc__SetSetup


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
     130  DisableModule
      24  Exc
          Parameter_Estimation_Excitation_State
          Setup_Parameters
     448  ModuleActive
       8  ParamEstExc__Disable
      12  ParamEstExc__Enable
      26  ParamEstExc__GetSetup
     210  ParamEstExc__Handler
      26  ParamEstExc__Initialize
      16  ParamEstExc__IsRunning
      46  ParamEstExc__SetSetup
      80  RANDOM_SEQUENCE

 
    24 bytes in section .bss
 1 026 bytes in section .text
 
 1 026 bytes of CODE memory
    24 bytes of DATA memory

Errors: none
Warnings: none
