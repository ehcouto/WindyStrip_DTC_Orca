###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        13/Mar/2025  15:31:55
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  XCategory\Service\Win\Win.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        Win.obj -l ..\listings\Win.lst XCategory\Service\Win\Win.c
#    List file    =  ..\listings\Win.lst
#    Object file  =  Win.obj
#
###############################################################################

C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Service\Win\Win.c
      1          /**
      2           *  @file       
      3           *
      4           *  @brief      WIN Protocol Module implementation
      5           *
      6           *  @details    This module implements the code to handle the WIN communication protocol using Uart driver from Vortex.
      7           *              This module is designed to operate with all micro controllers supported by Vortex.
      8           *
      9           *  @section    Applicable_Documents
     10           *                  List here all the applicable documents if needed. <tr>
     11           *
     12           *  $Header: $
     13           *
     14           *  @copyright  Copyright 2019-$Date$. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     15           */
     16          //---------------------------------------------------------------------------------------------------------------------
     17          //---------------------------------------------------------------------------------------------------------------------
     18          //-------------------------------------- Include Files ----------------------------------------------------------------
     19          #include "C_Extensions.h"
     20          #include "Win.h" 
     21          #include "Win_prv.h"
     22          #include "Crc8.h"
     23          #include "Uart.h"
     24          #include "String.h"
     25          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     26          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     27          #ifndef WIN_DEBUG
     28              #define WIN_DEBUG DISABLED
     29          #endif
     30          
     31          #ifndef WIN_NODE_STATUS
     32              #define WIN_NODE_STATUS  DISABLED
     33          #endif
     34          
     35          #ifndef WIN_DATA_SEGMENT1
     36              #define WIN_DATA_SEGMENT1
     37          #endif
     38          
     39          #ifndef WIN_DATA_SEGMENT2
     40              #define WIN_DATA_SEGMENT2
     41          #endif
     42          
     43          #ifndef WIN_DATA_SEGMENT3
     44              #define WIN_DATA_SEGMENT3
     45          #endif
     46          
     47          #ifndef WIN_NODE
     48              #error: "WIN_NODE must be defined in Win_prm.h as 0 to 13, 14 is reserved for the PC and 15 is broadcast."
     49          #else
     50              #if (WIN_NODE > 13)
     51              #error: "WIN_NODE must be defined in Win_prm.h as 0 to 13, 14 is reserved for the PC and 15 is broadcast."
     52              #endif
     53          #endif
     54          
     55          #ifndef WIN_COM
     56              #error: "WIN_COM must be defined in Win_prm.h as COM0, COM1 ..4"
     57          #endif
     58          
     59          
     60          #if (WIN_MAX_OUTGOING_DATA_SIZE >  WIN_MAX_INCOMING_DATA_SIZE)
     61              #error: "WIN_MAX_INCOMING_DATA_SIZE must be define equal or greater than WIN_MAX_OUTGOING_DATA_SIZE"
     62          #endif
     63          
     64          #if ((WIN_MAX_OUTGOING_DATA_SIZE > 255) || (WIN_MAX_OUTGOING_DATA_SIZE < 15))
     65              #error: "WIN_MAX_OUTGOING_DATA_SIZE has to be defined from 15 to 255"
     66          #endif
     67          
     68          #if ((WIN_MAX_INCOMING_DATA_SIZE > 255) || (WIN_MAX_INCOMING_DATA_SIZE < 15))
     69              #error: "WIN_MAX_INCOMING_DATA_SIZE has to be defined from 15 to 255"
     70          #endif
     71          
     72          #ifndef WIN_DEFAULT_BREAK_SIGNAL_TIME_IN_MILLI_SECONDS
     73              #define WIN_DEFAULT_BREAK_SIGNAL_TIME_IN_MILLI_SECONDS       (1000)
     74          #elif (WIN_DEFAULT_BREAK_SIGNAL_TIME_IN_MILLI_SECONDS < 350)
     75              #error : "The minimum break signal shall be more then 350ms"
     76          #endif
     77          
     78          #if  (WIN_DYNAMIC_ADDRESS == DISABLED)
     79              #define Win_Node    WIN_NODE
     80          #else
     81              static uint8 Win_Node;
     82          #endif
     83          
     84          /**
     85           * Defines the interval time in between 2 nodes in ms.
     86           */
     87          #define WIN_DELTA_TIME      2
     88          
     89          /**
     90           * Defines the base time for the time for each node in ms.
     91           */
     92          #define WIN_OFFSET_TIME     4
     93          
     94          /**
     95           * Defines the time for which no data in the bus will consider the bus in idle (no node sending any data)
     96           */
     97          #define WIN_IDLE_TIME       3
     98          
     99          /**
    100           * The math for the timer for each node is basically   (node address * WIN_DELTA_TIME) + WIN_OFFSET_TIME.\n
    101           * For instance: Node 2 = (2 * 2) + 4 = 8ms
    102           */
    103          #define WIN_NODE_TIME           ((Win_Node * WIN_DELTA_TIME) + WIN_OFFSET_TIME) //((Win_Node * 2)+4)
    104          
    105          /**
    106           * When a node fail and requires uart reconfiguration the node will stay away from the bus for (15 *2) + 4 = 34ms
    107           */
    108          #define WIN_NODE_MAX_TIME   ((15 * WIN_DELTA_TIME) + WIN_OFFSET_TIME) //((Win_Node * 2)+4)
    109          
    110          #ifndef WIN_MAX_RX_PARSER_TIMEOUT
    111              #define WIN_MAX_RX_PARSER_TIMEOUT   25        // 25ms time to alow overwrite in the RX buffer if the application doesn't get it.
    112          #endif
    113          
    114          /**
    115           * After reset the node will stay out of the bus for 150ms
    116           */
    117          #ifndef WIN_POWERUP_TIME
    118              #define WIN_POWERUP_TIME    (150)
    119          #endif
    120          
    121          #if (WIN_POWERUP_TIME > 220)
    122              #error: "WIN_POWERUP_TIME must be defined from 0 to 220ms since the time used will be 220 + Node Bus Time limited to a uint8";
    123          #endif
    124          
    125          /**
    126           * This configuration limits the amount of data managed in each interaction.
    127           */
    128          #ifndef WIN_MAX_BYTES_HANDLED_AT_ONCE
    129              #define WIN_MAX_BYTES_HANDLED_AT_ONCE   (5)
    130          #endif
    131          

   \                                 In section .bss, align 4
    132          WIN_DATA_SEGMENT1 static uint8 Win_Timer;
    133          static uint8 * Win_Tx_Pointer;
    134          static uint8 * Win_Check_Tx_Pointer;
    135          WIN_DATA_SEGMENT3 static uint16 Win_Check_Index;
    136          WIN_DATA_SEGMENT1 static uint16 Win_Remaining_Data;
    137          
    138          static WIN_OUTGOING_MESSAGE_TYPE Win_Tx_Buffer;
   \                     Win_Tx_Buffer:
   \   00000000                      DS8 76
   \   0000004C                      DS8 76
   \   00000098                      DS8 8
   \   000000A0                      DS8 1
   \   000000A1                      DS8 1
   \   000000A2                      DS8 1
   \   000000A3                      DS8 1
   \   000000A4                      DS8 1
   \   000000A5                      DS8 1
   \   000000A6                      DS8 1
   \   000000A7                      DS8 1
    139          static WIN_INCOMING_MESSAGE_TYPE Win_Rx_Buffer;
    140          WIN_DATA_SEGMENT3 static uint16  Win_Rx_Index;                // We did use short instead of char because of 255 + crc could potentially get to 256
    141          WIN_DATA_SEGMENT3 static uint8 Win_Rx_Crc;
    142          WIN_DATA_SEGMENT1 static uint8 Win_Bus_Idle;
    143          WIN_DATA_SEGMENT1 static uint8 Win_Bus_Idle_Timer;
    144          
    145          #define WIN_NUM_RETRIES     3
    146          static uint8 Win_Retry;
    147          
    148          #ifndef WIN_NUM_RETRIES_COLLISION
    149              #define WIN_NUM_RETRIES_COLLISION     10
    150          #endif
    151          
    152          #if ((WIN_NUM_RETRIES_COLLISION < 10) || (WIN_NUM_RETRIES_COLLISION > 255))
    153              #error: "The number of Retries due to collision must be from 10 to 255"
    154          #endif
    155          static uint8 Win_Retry_Collision;
    156          
    157          #if (WIN_DEBUG == ENABLED)
    158              static uint16 Win_Ack_Error_Counter;
    159              static uint16 Win_Echo_Error_Counter;
    160          #endif
    161          
    162          typedef enum
    163          {
    164              WIN_TX_STATE_IDLE,
    165              WIN_TX_STATE_GRANT_BUS,
    166              WIN_TX_STATE_SENDING
    167          }WIN_TX_STATE_TYPE;
    168          WIN_DATA_SEGMENT2 static WIN_TX_STATE_TYPE Win_Tx_State;
    169          
    170          typedef enum
    171          {
    172              WIN_RX_STATE_IDLE,
    173              WIN_RX_STATE_STX,
    174              WIN_RX_STATE_ADDRESS,
    175              WIN_RX_STATE_SAP,
    176              WIN_RX_STATE_SIZE,
    177              WIN_RX_STATE_DATA,
    178              WIN_RX_STATE_CRC,
    179              WIN_RX_STATE_WAIT_FOR_IDLE
    180          }WIN_RX_STATE_TYPE;
    181          WIN_DATA_SEGMENT2 static WIN_RX_STATE_TYPE Win_Rx_State;
    182          static WIN_HEADER_TYPE Win_Header;
    183          
    184          typedef enum
    185          {
    186              WIN_MESSAGE_FREE,
    187              WIN_MESSAGE_PROCESSING,
    188              WIN_MESSAGE_READY,
    189              WIN_MESSAGE_SENDING
    190          } WIN_MESSAGE_STATE_TYPE;
    191          WIN_DATA_SEGMENT2 WIN_MESSAGE_STATE_TYPE Win_Rx_Message_State;
   \                     Win_Rx_Message_State:
   \   000000A8                      DS8 1
    192          WIN_DATA_SEGMENT2 WIN_MESSAGE_STATE_TYPE Win_Tx_Message_State;
   \                     Win_Tx_Message_State:
   \   000000A9                      DS8 1
   \   000000AA                      DS8 1
   \   000000AB                      DS8 1
   \   000000AC                      DS8 1
   \   000000AD                      DS8 1
    193          
    194          #define WIN_DLE         0x10                        // DLE
    195          #define WIN_STX         0x02                        // Start of text which means being of the package
    196          #define WIN_ACK         0x06                        // ACK
    197          
    198          typedef enum
    199          {
    200              WIN_TX_STATUS_FREE,
    201              WIN_TX_STATUS_SENDING,
    202              WIN_TX_STATUS_COLLISION,
    203              WIN_TX_STATUS_SENT
    204          } WIN_TX_STATUS_TYPE;
    205          static WIN_TX_STATUS_TYPE Win_Tx_Status;
    206          
    207          #define WIN_MSG_COUNTER_LIMIT   15
    208          #define WIN_MSG_COUNTER_START   1
    209          #define WIN_MSG_COUNTER_RESET   0
    210          static uint8 Msg_Count;
    211          
    212          #ifndef WIN_TIME_HOLDING_MSG
    213              #define WIN_TIME_HOLDING_MSG    100
    214          #endif
    215          
    216          #if ((WIN_TIME_HOLDING_MSG < 1) || (WIN_TIME_HOLDING_MSG > 255))
    217              #error "WIN_TIME_HOLDING_MSG must be defined from 1 to 255"
    218          #endif
    219          
    220          #ifndef WIN_MAX_NUM_MESSAGES
    221              #define WIN_MAX_NUM_MESSAGES    20
    222          #endif
    223          #if ((WIN_MAX_NUM_MESSAGES < 1) || (WIN_MAX_NUM_MESSAGES > 255))
    224              #error "WIN_MAX_NUM_MESSAGES must be defined from 1 to 255"
    225          #endif
    226          static uint8 Node_Sent_Counter;             // counter used to engage the node bus contention.
    227          static uint8 Node_Not_Sending_Timer;        // Max timer which the node will stay with the bus access contention feature enabled.
    228          static uint8 Prev_Rx_Msg_Count[15];
    229          
    230          volatile uint8 Uart_Data;
   \                     Uart_Data:
   \   000000AE                      DS8 1
    231          volatile uint8 Uart_Error;
   \                     Uart_Error:
   \   000000AF                      DS8 1
   \   000000B0                      DS8 1
   \   000000B1                      DS8 1
   \   000000B2                      DS8 2
   \   000000B4                      DS8 2
   \   000000B6                      DS8 2
   \   000000B8                      DS8 2
   \   000000BA                      DS8 2
   \   000000BC                      DS8 4
   \   000000C0                      DS8 4
   \   000000C4                      DS8 16
    232          
    233          #define WIN_PC_NODE      14
    234          
    235          static uint8 Win_Rx_Message_Time;
    236          #if (WIN_NODE_STATUS == ENABLED)
    237              static uint16 Win_Node_Status;
    238          #endif
    239          
    240          static uint16 Win_Break_Counter;
    241          
    242          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
    243          static void WinOutgoingProcess(void);
    244          static void WinIncomingProcess(void);
    245          static void SendData(void);
    246          static void DropSendingMessage(void);
    247          //=====================================================================================================================
    248          //-------------------------------------- Public Functions -------------------------------------------------------------
    249          //=====================================================================================================================
    250          
    251          //---------------------------------------------------------------------------------------------------------------------
    252          /**
    253           *  @brief      It Initializes the module Win and its variables
    254           *
    255           */

   \                                 In section .text, align 2, keep-with-next
    256          void Win__Initialize(void)
    257          {
   \                     Win__Initialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    258          #if  (WIN_DYNAMIC_ADDRESS == ENABLED)
    259              Win_Node = WIN_NODE;
    260          #endif
    261              Win_Tx_Status = WIN_TX_STATUS_FREE;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable12
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF884 0x00AA      STRB     R0,[R4, #+170]
    262              Win_Timer = WIN_NODE_TIME + WIN_POWERUP_TIME;   // initial timer for which the node will be off the bus.
    263              Win_Tx_State = WIN_TX_STATE_IDLE;
    264              Win_Rx_State = WIN_RX_STATE_IDLE;
    265              Win_Rx_Message_State = WIN_MESSAGE_FREE;
    266              Win_Tx_Message_State = WIN_MESSAGE_FREE;
    267              Msg_Count = WIN_MSG_COUNTER_RESET;
    268              Win_Tx_Buffer.dle = WIN_DLE;
    269              Win_Tx_Buffer.stx = WIN_STX;
    270              Win_Tx_Buffer.source = Win_Node;
    271              Node_Sent_Counter = 0;
    272              Win_Bus_Idle_Timer = 0;
    273              Win_Bus_Idle = 0;
    274              Node_Not_Sending_Timer = 0;
    275              memset(&Prev_Rx_Msg_Count, 0, sizeof(Prev_Rx_Msg_Count));
   \   0000000C   0x210F             MOVS     R1,#+15
   \   0000000E   0x209A             MOVS     R0,#+154
   \   00000010   0xF884 0x00A0      STRB     R0,[R4, #+160]
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF884 0x00A6      STRB     R0,[R4, #+166]
   \   0000001A   0xF884 0x00A7      STRB     R0,[R4, #+167]
   \   0000001E   0xF884 0x00A8      STRB     R0,[R4, #+168]
   \   00000022   0xF884 0x00A9      STRB     R0,[R4, #+169]
   \   00000026   0xF884 0x00AB      STRB     R0,[R4, #+171]
   \   0000002A   0x2010             MOVS     R0,#+16
   \   0000002C   0x7020             STRB     R0,[R4, #+0]
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0x7060             STRB     R0,[R4, #+1]
   \   00000032   0x78A0             LDRB     R0,[R4, #+2]
   \   00000034   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000038   0x70A0             STRB     R0,[R4, #+2]
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x00AC      STRB     R0,[R4, #+172]
   \   00000040   0xF884 0x00A3      STRB     R0,[R4, #+163]
   \   00000044   0xF884 0x00A2      STRB     R0,[R4, #+162]
   \   00000048   0xF884 0x00AD      STRB     R0,[R4, #+173]
   \   0000004C   0xF104 0x00C4      ADD      R0,R4,#+196
   \   00000050   0x.... 0x....      BL       __aeabi_memclr4
    276              Uart__Initialize(WIN_COM,WIN_SPEED,UART_STOP_BIT_1,UART_PARITY_NONE);
   \   00000054   0x2200             MOVS     R2,#+0
   \   00000056   0x2300             MOVS     R3,#+0
   \   00000058   0x2105             MOVS     R1,#+5
   \   0000005A   0x4610             MOV      R0,R2
   \   0000005C   0x.... 0x....      BL       Uart__Initialize
    277              Uart_Data =0;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xF884 0x00AE      STRB     R0,[R4, #+174]
    278              Uart_Error = 0;
   \   00000066   0xF884 0x00AF      STRB     R0,[R4, #+175]
    279              Win_Retry = 0;                                  // Retry for no ack
   \   0000006A   0xF884 0x00A4      STRB     R0,[R4, #+164]
    280              Win_Retry_Collision = 0;                        // retry for collision.
   \   0000006E   0xF884 0x00A5      STRB     R0,[R4, #+165]
    281              Win_Check_Index = 0;
   \   00000072   0xF8A4 0x00B2      STRH     R0,[R4, #+178]
    282          #if (WIN_DEBUG == ENABLED)
    283              Win_Ack_Error_Counter = 0;
    284              Win_Echo_Error_Counter = 0;
    285          #endif
    286              Win_Rx_Message_Time = 0;
   \   00000076   0xF884 0x00B0      STRB     R0,[R4, #+176]
    287              Win_Break_Counter = 0;
   \   0000007A   0xF8A4 0x00BA      STRH     R0,[R4, #+186]
    288          #if (WIN_NODE_STATUS == ENABLED)
    289              Win_Node_Status = (uint16)((uint16)1 << Win_Node);
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xF8A4 0x00B8      STRH     R0,[R4, #+184]
    290          #endif
    291          }
   \   00000084   0xBD10             POP      {R4,PC}          ;; return
    292          
    293          //---------------------------------------------------------------------------------------------------------------------
    294          /**
    295           * @brief This method is used to set the address of this node.
    296           * @details This method only takes effect if the feature WIN_DYNAMIC_ADDRESS is enabled in Win_prm.h
    297           * @param address from 0 to 13.
    298           */

   \                                 In section .text, align 2, keep-with-next
    299          void Win__SetAddress(uint8 address)
                                            ^
Remark[Pe826]: parameter "address" was never referenced
    300          {
    301              #if (WIN_DYNAMIC_ADDRESS == ENABLED)
    302              if (address < WIN_PC_NODE)
    303              {
    304                  Win_Node = address;
    305              }
    306              #endif
    307          }
   \                     Win__SetAddress: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    308          
    309          //---------------------------------------------------------------------------------------------------------------------
    310          /**
    311           * @brief This method exposes the current address of this node
    312           * @return address from 0 to 13
    313           */

   \                                 In section .text, align 2, keep-with-next
    314          uint8 Win__GetAddress(void)
    315          {
    316              return (Win_Node);
   \                     Win__GetAddress: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    317          }
    318          
    319          //---------------------------------------------------------------------------------------------------------------------
    320          /**
    321           * @brief This Handler Win Communication
    322           * @details Shall be called periodically from 1 milli second task/thread
    323           *
    324           */

   \                                 In section .text, align 2, keep-with-next
    325          void Win__Handle1ms(void)
    326          {
   \                     Win__Handle1ms: (+1)
   \   00000000   0xB500             PUSH     {LR}
    327              if (Win_Break_Counter > 0)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000006   0xF8B0 0x10BA      LDRH     R1,[R0, #+186]
   \   0000000A   0xB081             SUB      SP,SP,#+4
   \   0000000C   0xB131             CBZ.N    R1,??Win__Handle1ms_0
    328              {
    329                  Win_Break_Counter--;
   \   0000000E   0x1E49             SUBS     R1,R1,#+1
   \   00000010   0xF8A0 0x10BA      STRH     R1,[R0, #+186]
    330                  Win_Tx_State = WIN_TX_STATE_IDLE;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0xF880 0x10A6      STRB     R1,[R0, #+166]
   \   0000001A   0xE001             B.N      ??Win__Handle1ms_1
    331              }
    332              else
    333              {
    334                  WinOutgoingProcess();
   \                     ??Win__Handle1ms_0: (+1)
   \   0000001C   0x.... 0x....      BL       WinOutgoingProcess
    335              }
    336          
    337              WinIncomingProcess();
   \                     ??Win__Handle1ms_1: (+1)
   \   00000020   0x.... 0x....      BL       WinIncomingProcess
    338              Uart__Handler();
   \   00000024   0xB001             ADD      SP,SP,#+4
   \   00000026   0xF85D 0xEB04      POP      {LR}
   \   0000002A   0x.... 0x....      B.W      Uart__Handler
    339          }
    340          
    341          //---------------------------------------------------------------------------------------------------------------------
    342          /**
    343           * @brief This method checks for a pending incoming message that should be parsed by the application protocol
    344           * @param sap define the application protocol used in this message
    345           * @return WIN_INCOMING_MESSAGE_TYPE * that points to the buffer or NULL if there's no message pening
    346           */

   \                                 In section .text, align 2, keep-with-next
    347          WIN_INCOMING_MESSAGE_TYPE * Win__GetIncomingMessage(uint8 sap)
    348          {
    349              WIN_INCOMING_MESSAGE_TYPE * pt;
    350              pt = (WIN_INCOMING_MESSAGE_TYPE *)NULL;
    351              if ( Win_Rx_Message_State == WIN_MESSAGE_READY) // if a message is received and ready for parsing
   \                     Win__GetIncomingMessage: (+1)
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable12
   \   00000004   0xF892 0x30A8      LDRB     R3,[R2, #+168]
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x2B02             CMP      R3,#+2
   \   0000000C   0xBF02             ITTT     EQ 
    352              {
    353                  if (Win_Rx_Buffer.sap == sap)               // if the sap matches who is requesting
   \   0000000E   0xF892 0x304F      LDRBEQ   R3,[R2, #+79]
   \   00000012   0xF003 0x030F      ANDEQ    R3,R3,#0xF
   \   00000016   0x4283             CMPEQ    R3,R0
   \   00000018   0xD104             BNE.N    ??Win__GetIncomingMessage_0
    354                  {
    355                      pt = &Win_Rx_Buffer;                    // get the message
    356                      Win_Rx_Message_State = WIN_MESSAGE_PROCESSING;  // change the message to processing state
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xF102 0x014C      ADD      R1,R2,#+76
   \   00000020   0xF882 0x00A8      STRB     R0,[R2, #+168]
    357                  }
    358              }
    359              return (pt);
   \                     ??Win__GetIncomingMessage_0: (+1)
   \   00000024   0x4608             MOV      R0,R1
   \   00000026   0x4770             BX       LR               ;; return
    360          }
    361          
    362          //---------------------------------------------------------------------------------------------------------------------
    363          /**
    364           * @brief This method frees the pending message after the application protocol had parsed it
    365           * @param sap define the application protocol used in this message
    366           */

   \                                 In section .text, align 2, keep-with-next
    367          void Win__FreeIncomingMessage(uint8 sap)
    368          {
    369              if ( Win_Rx_Message_State == WIN_MESSAGE_PROCESSING)    // if the message is being processed
   \                     Win__FreeIncomingMessage: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable12
   \   00000004   0xF891 0x20A8      LDRB     R2,[R1, #+168]
   \   00000008   0x2A01             CMP      R2,#+1
   \   0000000A   0xBF02             ITTT     EQ 
    370              {
    371                  if (Win_Rx_Buffer.sap == sap)                       // and the sap matches
   \   0000000C   0xF891 0x204F      LDRBEQ   R2,[R1, #+79]
   \   00000010   0xF002 0x020F      ANDEQ    R2,R2,#0xF
   \   00000014   0x4282             CMPEQ    R2,R0
   \   00000016   0xBF04             ITT      EQ 
    372                  {
    373                      Win_Rx_Message_State = WIN_MESSAGE_FREE;        // clear the message as parsed.
   \   00000018   0x2000             MOVEQ    R0,#+0
   \   0000001A   0xF881 0x00A8      STRBEQ   R0,[R1, #+168]
    374                  }
    375              }
    376          }
   \   0000001E   0x4770             BX       LR               ;; return
    377          
    378          //---------------------------------------------------------------------------------------------------------------------
    379          /**
    380           * @brief This method is used by the upper layer to allocated the buffer to send a message out.
    381           * @return the pointer to the buffer
    382           *  @retval NULL if the buffer can not be allocated
    383           *  @retval WIN_OUTGOING_MESSAGE_TYPE * pointing to the buffer if the method managed to allocated the buffer.
    384           */

   \                                 In section .text, align 2, keep-with-next
    385          WIN_OUTGOING_MESSAGE_TYPE * Win__AllocateMessage(void)
    386          {
    387              WIN_OUTGOING_MESSAGE_TYPE * pt;
    388              pt = (WIN_OUTGOING_MESSAGE_TYPE *)NULL;
    389              if (Win_Tx_Message_State == WIN_MESSAGE_FREE)           // if the buffer is free
   \                     Win__AllocateMessage: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable12
   \   00000004   0xF891 0x20A9      LDRB     R2,[R1, #+169]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xB91A             CBNZ.N   R2,??Win__AllocateMessage_0
    390              {
    391                  Win_Tx_Message_State = WIN_MESSAGE_PROCESSING;      // allocate the buffer
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xF881 0x00A9      STRB     R0,[R1, #+169]
    392                  pt = &Win_Tx_Buffer;                                // return it.
   \   00000012   0x4608             MOV      R0,R1
    393              }
    394              return (pt);
   \                     ??Win__AllocateMessage_0: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    395          }
    396          
    397          //---------------------------------------------------------------------------------------------------------------------
    398          /**
    399           * @brief This method queues a message to be sent.
    400           * @details The message has to be build by Win__AllocateMessage, them the application will fill up the data and call this procedure.
    401           * @return WIN_OPER_TYPE
    402           *  @retval WIN_OPER_SUCCEED if the message is successfully composed and queued
    403           *  @retval WIN_OPER_INVALID_ADDRESS if the destination is set to the sender address
    404           *  @retval WIN_OPER_INVALID_SIZE is the size is bigger than the buffer or size = 0
    405           *  @retval WIN_OPER_BUFFER_NOT_ALLOCATED is the buffer wan't allocated and the application is trying to queue the message.
    406           */

   \                                 In section .text, align 2, keep-with-next
    407          WIN_OPER_TYPE Win__QueueMessage(void)
    408          {
   \                     Win__QueueMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    409              WIN_OPER_TYPE retval;
    410              uint8 *pt;
    411          
    412              if (WIN_MESSAGE_PROCESSING == Win_Tx_Message_State) // the message state must be PROCESSING to be able to be queued
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable12
   \   00000006   0xF894 0x00A9      LDRB     R0,[R4, #+169]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD13D             BNE.N    ??Win__QueueMessage_0
    413              {
    414                 if ((Win_Tx_Buffer.sdu_length <= WIN_MAX_OUTGOING_DATA_SIZE) &&  // address must in the range to be able to be queued
    415                     (Win_Tx_Buffer.sdu_length != 0))
   \   0000000E   0x7920             LDRB     R0,[R4, #+4]
   \   00000010   0x2847             CMP      R0,#+71
   \   00000012   0xDA35             BGE.N    ??Win__QueueMessage_1
   \   00000014   0xB3A0             CBZ.N    R0,??Win__QueueMessage_1
    416                 {
    417                     if (Win_Tx_Buffer.destination != Win_Node)   // the message can no be to this node itself
   \   00000016   0x78A1             LDRB     R1,[R4, #+2]
   \   00000018   0x220F             MOVS     R2,#+15
   \   0000001A   0x4211             TST      R1,R2
   \   0000001C   0xD02B             BEQ.N    ??Win__QueueMessage_2
    418                     {
    419                         // ensure the package formating
    420                         Win_Tx_Buffer.dle = WIN_DLE;
   \   0000001E   0x2210             MOVS     R2,#+16
   \   00000020   0x7022             STRB     R2,[R4, #+0]
    421                         Win_Tx_Buffer.stx = WIN_STX;
    422                         Win_Tx_Buffer.source = Win_Node;
   \   00000022   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000026   0x2202             MOVS     R2,#+2
   \   00000028   0x70A1             STRB     R1,[R4, #+2]
   \   0000002A   0x7062             STRB     R2,[R4, #+1]
    423                         Win_Tx_Buffer.msg_count = Msg_Count;
   \   0000002C   0x78E1             LDRB     R1,[R4, #+3]
   \   0000002E   0xF894 0x20AB      LDRB     R2,[R4, #+171]
   \   00000032   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000036   0xEA41 0x1102      ORR      R1,R1,R2, LSL #+4
   \   0000003A   0x70E1             STRB     R1,[R4, #+3]
    424          
    425                         pt = (uint8 *)&Win_Tx_Buffer;    //lint !e928  Lint: 928 cast from pointer to pointer [MISRA 2004 Rule 11.4]
    426                         pt++;                                // Skip DLE
    427                         pt++;                                // Skip STX
    428                         Win_Tx_Buffer.payload[Win_Tx_Buffer.sdu_length] = Crc8(0xFF,pt,(uint8)(Win_Tx_Buffer.sdu_length + 3));
   \   0000003C   0x1CC2             ADDS     R2,R0,#+3
   \   0000003E   0xB2D2             UXTB     R2,R2
   \   00000040   0x1CA1             ADDS     R1,R4,#+2
   \   00000042   0x20FF             MOVS     R0,#+255
   \   00000044   0x.... 0x....      BL       Crc8
   \   00000048   0x7921             LDRB     R1,[R4, #+4]
   \   0000004A   0x1909             ADDS     R1,R1,R4
   \   0000004C   0x7148             STRB     R0,[R1, #+5]
    429          
    430                         // counts from 1 to 15, 0 is used when the system powers up
    431                         Msg_Count++;
   \   0000004E   0xF894 0x00AB      LDRB     R0,[R4, #+171]
   \   00000052   0x1C40             ADDS     R0,R0,#+1
    432          
    433                         if (Msg_Count > WIN_MSG_COUNTER_LIMIT)
   \   00000054   0xB2C0             UXTB     R0,R0
   \   00000056   0x2810             CMP      R0,#+16
   \   00000058   0xBFA8             IT       GE 
    434                         {
    435                             Msg_Count = WIN_MSG_COUNTER_START;
   \   0000005A   0x2001             MOVGE    R0,#+1
   \   0000005C   0xF884 0x00AB      STRB     R0,[R4, #+171]
    436                         }
    437                         Win_Retry = WIN_NUM_RETRIES;
   \   00000060   0x2003             MOVS     R0,#+3
   \   00000062   0xF884 0x00A4      STRB     R0,[R4, #+164]
    438                         Win_Retry_Collision = WIN_NUM_RETRIES_COLLISION;
   \   00000066   0x200A             MOVS     R0,#+10
   \   00000068   0xF884 0x00A5      STRB     R0,[R4, #+165]
    439                         Win_Tx_Message_State = WIN_MESSAGE_READY;
   \   0000006C   0x2002             MOVS     R0,#+2
   \   0000006E   0xF884 0x00A9      STRB     R0,[R4, #+169]
    440                         retval = WIN_OPER_SUCCEED;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xBD10             POP      {R4,PC}
    441                     }
    442                     else
    443                     {
    444                         retval = WIN_OPER_INVALID_ADDRESS;
    445                         Win_Tx_Message_State = WIN_MESSAGE_FREE;
    446                     }
    447                 }
    448                 else
    449                 {
    450                     retval = WIN_OPER_INVALID_SIZE;
    451                     Win_Tx_Message_State = WIN_MESSAGE_FREE;
   \                     ??Win__QueueMessage_2: (+1)
   \   00000076   0x2100             MOVS     R1,#+0
   \   00000078   0x2003             MOVS     R0,#+3
   \   0000007A   0xF884 0x10A9      STRB     R1,[R4, #+169]
   \   0000007E   0xBD10             POP      {R4,PC}
   \                     ??Win__QueueMessage_1: (+1)
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0x2002             MOVS     R0,#+2
   \   00000084   0xF884 0x10A9      STRB     R1,[R4, #+169]
   \   00000088   0xBD10             POP      {R4,PC}
    452                 }
    453              }
    454              else
    455              {
    456                  retval = WIN_OPER_BUFFER_NOT_ALLOCATED;
   \                     ??Win__QueueMessage_0: (+1)
   \   0000008A   0x2001             MOVS     R0,#+1
    457              }
    458              return (retval);
   \   0000008C   0xBD10             POP      {R4,PC}          ;; return
    459          }
    460          
    461          /**
    462           * @brief This method initializes the Node status variable.
    463           */

   \                                 In section .text, align 2, keep-with-next
    464          void Win__ClearNodeStatus(void)
    465          {
    466              #if (WIN_NODE_STATUS == ENABLED)
    467                  Win_Node_Status = (uint16)((uint16)1 << Win_Node);
   \                     Win__ClearNodeStatus: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable12
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xF8A1 0x00B8      STRH     R0,[R1, #+184]
    468              #endif
    469          }
   \   0000000A   0x4770             BX       LR               ;; return
    470          
    471          //---------------------------------------------------------------------------------------------------------------------
    472          /**
    473           * @brief This method exposes a 16bits variable where each bit represents the state of a node in the bus
    474           * @return 16bits node bus status
    475           */

   \                                 In section .text, align 2, keep-with-next
    476          uint16 Win__GetNodeStatus(void)
    477          {
    478              #if (WIN_NODE_STATUS == ENABLED)
    479                  return(Win_Node_Status);
   \                     Win__GetNodeStatus: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000004   0xF8B0 0x00B8      LDRH     R0,[R0, #+184]
   \   00000008   0x4770             BX       LR               ;; return
    480              #else
    481                  return (0);
    482              #endif
    483          }
    484          
    485          //---------------------------------------------------------------------------------------------------------------------
    486          /**
    487           * @brief This method starts sending the Break signal on the COM port
    488           * @details Sends a break signal till WIN_DEFAULT_BREAK_SIGNAL_TIME_IN_MILLI_SECONDS time expires.
    489           *          If the application needs to send for more then this time then they need to call the API before the timer expires
    490           *
    491           */

   \                                 In section .text, align 2, keep-with-next
    492          void Win__SendBreak(void)
    493          {
    494              Win_Break_Counter = WIN_DEFAULT_BREAK_SIGNAL_TIME_IN_MILLI_SECONDS;
   \                     Win__SendBreak: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable12
   \   00000004   0xF44F 0x707A      MOV      R0,#+1000
   \   00000008   0xF8A1 0x00BA      STRH     R0,[R1, #+186]
    495              Uart__SendBreak(WIN_COM);
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      B.W      Uart__SendBreak
    496          }
    497          
    498          //---------------------------------------------------------------------------------------------------------------------
    499          /**
    500           * @brief This method stops sending the Break signal on the COM port
    501           */

   \                                 In section .text, align 2, keep-with-next
    502          void Win__StopBreak(void)
    503          {
   \                     Win__StopBreak: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    504              Uart__StopBreak(WIN_COM);
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       Uart__StopBreak
    505              Win_Break_Counter = 0;
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable12
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF8A1 0x00BA      STRH     R0,[R1, #+186]
    506          }
   \   00000014   0xB001             ADD      SP,SP,#+4
   \   00000016   0xBD00             POP      {PC}             ;; return
    507          
    508          //---------------------------------------------------------------------------------------------------------------------
    509          /**
    510           * @brief This method used to read the COM bus status like receive Pin Status or Break signal status
    511           *
    512           * @param bus_status - WIN_BUS_STATUS_TYPE
    513           *
    514           * @return BOOL_TYPE
    515           *  @retval TRUE(1)
    516           *  @retval FALSE(0)
    517           */

   \                                 In section .text, align 2, keep-with-next
    518          BOOL_TYPE Win__GetBusStatus(WIN_BUS_STATUS_TYPE bus_status)
    519          {
   \                     Win__GetBusStatus: (+1)
   \   00000000   0x4601             MOV      R1,R0
    520              BOOL_TYPE response;
    521          
    522              response = FALSE;
   \   00000002   0x2000             MOVS     R0,#+0
    523          
    524              if (bus_status == WIN_BUS_STATUS_BREAK_OUT)
   \   00000004   0xB909             CBNZ.N   R1,??Win__GetBusStatus_0
    525              {
    526                  response = (BOOL_TYPE)Uart__GetStatus(WIN_COM, UART_STATUS_BREAK_OUT);
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0xE002             B.N      ??Win__GetBusStatus_1
    527              }
    528              else if (bus_status == WIN_BUS_STATUS_RX_PIN)
   \                     ??Win__GetBusStatus_0: (+1)
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD102             BNE.N    ??Win__GetBusStatus_2
    529              {
    530                  response = (BOOL_TYPE)Uart__GetStatus(WIN_COM, UART_STATUS_RX_PIN);
   \   0000000E   0x2106             MOVS     R1,#+6
   \                     ??Win__GetBusStatus_1: (+1)
   \   00000010   0x.... 0x....      B.W      Uart__GetStatus
    531              }
    532          
    533              return response;
   \                     ??Win__GetBusStatus_2: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    534          }
    535          
    536          //=====================================================================================================================
    537          //-------------------------------------- Private Functions ------------------------------------------------------------
    538          //=====================================================================================================================
    539          
    540          //---------------------------------------------------------------------------------------------------------------------
    541          /**
    542           * @brief  Handler that manages the process to send messages
    543           * @details This procedure must be executed every 1m (or from on TimerInterrupt Slot)
    544           */

   \                                 In section .text, align 2, keep-with-next
    545          static void WinOutgoingProcess(void)
    546          {
   \                     WinOutgoingProcess: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    547              uint8 bytes_to_read;
    548              bytes_to_read = Uart__GetStatus(WIN_COM,UART_STATUS_RX_AVAILABLE);
   \   00000002   0x2104             MOVS     R1,#+4
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       Uart__GetStatus
    549          
    550              if (bytes_to_read > 0)                          // if there is any byte in the Uart driver to be parsed
   \   0000000A   0x.... 0x....      LDR.W    R4,??DataTable12
   \   0000000E   0xB168             CBZ.N    R0,??WinOutgoingProcess_0
    551              {
    552                  Win_Bus_Idle_Timer = WIN_NODE_MAX_TIME;     // This timer times 34ms which is used to detect situations of the bus is really in idle and no other nodes want to send data.
   \   00000010   0x2122             MOVS     R1,#+34
   \   00000012   0xF884 0x10A3      STRB     R1,[R4, #+163]
    553                  Win_Bus_Idle = WIN_IDLE_TIME;               // This timer is used to make sure the ack is detected within the 3ms window after the message has being sent.
   \   00000016   0x2103             MOVS     R1,#+3
   \   00000018   0xF884 0x10A2      STRB     R1,[R4, #+162]
    554                  if (Win_Timer < WIN_NODE_TIME)              // make sure the reload doesn't overwrite a previews bigger value (power up for instance).
   \   0000001C   0xF894 0x10A0      LDRB     R1,[R4, #+160]
   \   00000020   0x2904             CMP      R1,#+4
   \   00000022   0xDA06             BGE.N    ??WinOutgoingProcess_1
   \   00000024   0x2104             MOVS     R1,#+4
   \   00000026   0xF884 0x10A0      STRB     R1,[R4, #+160]
   \   0000002A   0xE002             B.N      ??WinOutgoingProcess_1
    555                  {
    556                      Win_Timer = WIN_NODE_TIME;              // reload node timer which depends on the node address.
    557                  }
    558              }
    559          
    560              if (Win_Bus_Idle_Timer > 0)
   \                     ??WinOutgoingProcess_0: (+1)
   \   0000002C   0xF894 0x10A3      LDRB     R1,[R4, #+163]
   \   00000030   0xB149             CBZ.N    R1,??WinOutgoingProcess_2
    561              {
    562                  Win_Bus_Idle_Timer--;
   \                     ??WinOutgoingProcess_1: (+1)
   \   00000032   0xF894 0x10A3      LDRB     R1,[R4, #+163]
   \   00000036   0x1E49             SUBS     R1,R1,#+1
   \   00000038   0xF884 0x10A3      STRB     R1,[R4, #+163]
    563                  if (Win_Bus_Idle_Timer == 0)                // if the bus is in idle for 34 ms
   \   0000003C   0xB2C9             UXTB     R1,R1
   \   0000003E   0xB911             CBNZ.N   R1,??WinOutgoingProcess_2
    564                  {
    565                      Node_Not_Sending_Timer = 0;             // if the bus idle is detected it will force the bus access contention to disengage.
   \   00000040   0xF884 0x10AD      STRB     R1,[R4, #+173]
    566                      Node_Sent_Counter = 0;
   \   00000044   0xE007             B.N      ??WinOutgoingProcess_3
    567                  }
    568              }
    569          
    570              if (Node_Not_Sending_Timer > 0)                 // This is the maximum time for which this node can be prevented to send messages in the bus due to the bus access contention feature.
   \                     ??WinOutgoingProcess_2: (+1)
   \   00000046   0xF894 0x10AD      LDRB     R1,[R4, #+173]
   \   0000004A   0xB131             CBZ.N    R1,??WinOutgoingProcess_4
    571              {
    572                  Node_Not_Sending_Timer--;
   \   0000004C   0x1E49             SUBS     R1,R1,#+1
   \   0000004E   0xF884 0x10AD      STRB     R1,[R4, #+173]
    573                  if (Node_Not_Sending_Timer == 0)
   \   00000052   0xB2C9             UXTB     R1,R1
   \   00000054   0xB909             CBNZ.N   R1,??WinOutgoingProcess_4
    574                  {
    575                      Node_Sent_Counter = 0;                  // when the timer expires the bus access contention feature is disabled by clear the message counter.
   \                     ??WinOutgoingProcess_3: (+1)
   \   00000056   0xF884 0x10AC      STRB     R1,[R4, #+172]
    576                  }
    577              }
    578          
    579              switch (Win_Tx_State)
   \                     ??WinOutgoingProcess_4: (+1)
   \   0000005A   0xF894 0x10A6      LDRB     R1,[R4, #+166]
   \   0000005E   0xB119             CBZ.N    R1,??WinOutgoingProcess_5
   \   00000060   0x2902             CMP      R1,#+2
   \   00000062   0xD04F             BEQ.N    ??WinOutgoingProcess_6
   \   00000064   0xD314             BCC.N    ??WinOutgoingProcess_7
   \   00000066   0xE096             B.N      ??WinOutgoingProcess_8
    580              {
    581                  case WIN_TX_STATE_IDLE:
    582                      if (Win_Timer == 0)                     // if the node is allowed to access the bus
   \                     ??WinOutgoingProcess_5: (+1)
   \   00000068   0xF894 0x00A0      LDRB     R0,[R4, #+160]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xBF04             ITT      EQ 
    583                      {
    584                          if ((Win_Tx_Message_State == WIN_MESSAGE_READY) &&  // if there is a message to be sent
    585                              (Node_Sent_Counter < WIN_MAX_NUM_MESSAGES))     // and the bus access contention is not active.
   \   00000070   0xF894 0x00A9      LDRBEQ   R0,[R4, #+169]
   \   00000074   0x2802             CMPEQ    R0,#+2
   \   00000076   0xF040 0x8091      BNE.W    ??WinOutgoingProcess_9
   \   0000007A   0xF894 0x00AC      LDRB     R0,[R4, #+172]
   \   0000007E   0x2814             CMP      R0,#+20
   \   00000080   0xF280 0x808C      BGE.W    ??WinOutgoingProcess_9
    586                          {
    587                              Uart__WriteByte(WIN_COM,(uint8)(~Win_Node));    // send the bus grant byte
   \   00000084   0x21FF             MOVS     R1,#+255
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x.... 0x....      BL       Uart__WriteByte
    588                              Win_Tx_State = WIN_TX_STATE_GRANT_BUS;
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0xE083             B.N      ??WinOutgoingProcess_10
    589                          }
    590                      }
    591                      break;
    592                  case WIN_TX_STATE_GRANT_BUS:
    593                      Win_Tx_State = WIN_TX_STATE_IDLE;       // by default it consider collision
   \                     ??WinOutgoingProcess_7: (+1)
   \   00000090   0x2100             MOVS     R1,#+0
   \   00000092   0xF884 0x10A6      STRB     R1,[R4, #+166]
    594                      if (bytes_to_read == 0)                 // if there is no data in the Uart buffer (received)
   \   00000096   0xB970             CBNZ.N   R0,??WinOutgoingProcess_11
    595                      {
    596                          if (Win_Timer < WIN_NODE_MAX_TIME)
   \   00000098   0xF894 0x00A0      LDRB     R0,[R4, #+160]
   \   0000009C   0x2822             CMP      R0,#+34
   \   0000009E   0xBFBC             ITT      LT 
    597                          {
    598                              Win_Timer = WIN_NODE_MAX_TIME;  // reload node timer to prevent the module to take over the bus
   \   000000A0   0x2022             MOVLT    R0,#+34
   \   000000A2   0xF884 0x00A0      STRBLT   R0,[R4, #+160]
    599                          }
    600                          Uart__Initialize(WIN_COM,WIN_SPEED,UART_STOP_BIT_1,UART_PARITY_NONE);
   \   000000A6   0xE8BD 0x4010      POP      {R4,LR}
   \   000000AA   0x460A             MOV      R2,R1
   \   000000AC   0x2300             MOVS     R3,#+0
   \   000000AE   0x2105             MOVS     R1,#+5
   \   000000B0   0x4610             MOV      R0,R2
   \   000000B2   0x.... 0x....      B.W      Uart__Initialize
    601                      }
    602                      else                                    // if there is some data in the Uart buffer
    603                      {
    604                          if (bytes_to_read == 1)             // if the amount of data is exactly 1 byte, the echo of the bus grant byte.
   \                     ??WinOutgoingProcess_11: (+1)
   \   000000B6   0x2801             CMP      R0,#+1
   \   000000B8   0xD170             BNE.N    ??WinOutgoingProcess_9
    605                          {
    606                              Uart_Data = Uart__ReadByte(WIN_COM);        // receive the data
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x.... 0x....      BL       Uart__ReadByte
   \   000000C0   0xF884 0x00AE      STRB     R0,[R4, #+174]
    607                              Uart_Error = Uart__GetStatus(WIN_COM,UART_STATUS_ERROR);
   \   000000C4   0x2105             MOVS     R1,#+5
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x.... 0x....      BL       Uart__GetStatus
   \   000000CC   0xF884 0x00AF      STRB     R0,[R4, #+175]
    608                              if ((Uart_Error == FALSE) &&
    609                                  (Uart_Data == (uint8)(~Win_Node)))       // bus granted
   \   000000D0   0xF894 0x00AF      LDRB     R0,[R4, #+175]
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xBF04             ITT      EQ 
   \   000000D8   0xF894 0x00AE      LDRBEQ   R0,[R4, #+174]
   \   000000DC   0x28FF             CMPEQ    R0,#+255
   \   000000DE   0xD15D             BNE.N    ??WinOutgoingProcess_9
    610                              {
    611                                  Win_Tx_Pointer = (uint8 *)&Win_Tx_Buffer;   //lint !e928 Lint: 928 cast from pointer to pointer [MISRA 2004 Rule 11.4]
    612                                  Win_Check_Tx_Pointer = Win_Tx_Pointer;
    613                                  Win_Check_Index = 0;
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0xF8A4 0x00B2      STRH     R0,[R4, #+178]
   \   000000E6   0xF8C4 0x40BC      STR      R4,[R4, #+188]
   \   000000EA   0xF8C4 0x40C0      STR      R4,[R4, #+192]
    614                                  // data size + 2 bytes of header, address, sap, size, crc
    615                                  Win_Remaining_Data = ((uint16)Win_Tx_Buffer.sdu_length) + 6;
   \   000000EE   0x7920             LDRB     R0,[R4, #+4]
   \   000000F0   0x1D80             ADDS     R0,R0,#+6
   \   000000F2   0xF8A4 0x00B4      STRH     R0,[R4, #+180]
    616                                  Win_Tx_Status = WIN_TX_STATUS_SENDING;
   \   000000F6   0x2001             MOVS     R0,#+1
   \   000000F8   0xF884 0x00AA      STRB     R0,[R4, #+170]
    617                                  SendData();                 // start to send the message
   \   000000FC   0x.... 0x....      BL       SendData
    618                                  Win_Tx_State = WIN_TX_STATE_SENDING;
   \   00000100   0x2002             MOVS     R0,#+2
   \   00000102   0xE049             B.N      ??WinOutgoingProcess_10
    619                              }
    620                          }
    621                      }
    622                      break;
    623                  case WIN_TX_STATE_SENDING:
    624                      if (Win_Tx_Status == WIN_TX_STATUS_COLLISION)   // check if there is collision on the echo reception
   \                     ??WinOutgoingProcess_6: (+1)
   \   00000104   0xF894 0x00AA      LDRB     R0,[R4, #+170]
   \   00000108   0x2802             CMP      R0,#+2
   \   0000010A   0xD116             BNE.N    ??WinOutgoingProcess_12
    625                      {
    626                          Win_Tx_State = WIN_TX_STATE_IDLE;
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0xF884 0x00A6      STRB     R0,[R4, #+166]
    627                          if (Win_Retry_Collision > 0)        // this is the retry procedure due to collision.
   \   00000112   0xF894 0x00A5      LDRB     R0,[R4, #+165]
   \   00000116   0xB130             CBZ.N    R0,??WinOutgoingProcess_13
    628                          {
    629                              Win_Retry_Collision--;
   \   00000118   0x1E40             SUBS     R0,R0,#+1
   \   0000011A   0xF884 0x00A5      STRB     R0,[R4, #+165]
    630                              Win_Tx_Message_State = WIN_MESSAGE_READY;
   \   0000011E   0x2002             MOVS     R0,#+2
   \   00000120   0xF884 0x00A9      STRB     R0,[R4, #+169]
   \   00000124   0xBD10             POP      {R4,PC}
    631                              WIN_RETRY_OUTGOING_MESSAGE(&Win_Tx_Buffer);
    632                          }
    633                          else
    634                          {                                   // when the number of retries expires the message is dropped.
    635                              WIN_DROPPED_OUTGOING_MESSAGE(&Win_Tx_Buffer);
    636                              DropSendingMessage();
   \                     ??WinOutgoingProcess_13: (+1)
   \   00000126   0xF884 0x00A9      STRB     R0,[R4, #+169]
   \   0000012A   0xF894 0x00AC      LDRB     R0,[R4, #+172]
   \   0000012E   0x28FF             CMP      R0,#+255
   \   00000130   0xD034             BEQ.N    ??WinOutgoingProcess_9
   \   00000132   0x1C40             ADDS     R0,R0,#+1
   \   00000134   0xF884 0x00AC      STRB     R0,[R4, #+172]
   \   00000138   0xBD10             POP      {R4,PC}
    637                          }
    638                      }
    639                      else
    640                      {
    641                          SendData();                         // keep sending message while there are remaining data to be sent.
   \                     ??WinOutgoingProcess_12: (+1)
   \   0000013A   0x.... 0x....      BL       SendData
    642                          if (Win_Bus_Idle == 0)              // if the bus is in idle it means idle for 3ms after sent a message
   \   0000013E   0xF894 0x00A2      LDRB     R0,[R4, #+162]
   \   00000142   0xBB58             CBNZ.N   R0,??WinOutgoingProcess_9
    643                          {
    644                              if (Win_Tx_Status == WIN_TX_STATUS_SENT)    // if the message want't acknowledged
   \   00000144   0xF894 0x00AA      LDRB     R0,[R4, #+170]
   \   00000148   0x2803             CMP      R0,#+3
   \   0000014A   0xD121             BNE.N    ??WinOutgoingProcess_14
    645                              {
    646                                  if ((Win_Tx_Buffer.destination == WIN_BROADCAST)||  // broadcast messages or messages targeted to the pc node doesn't require ACK.
    647                                      (Win_Tx_Buffer.destination == WIN_PC_NODE))
   \   0000014C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000014E   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000152   0x280F             CMP      R0,#+15
   \   00000154   0xBF18             IT       NE 
   \   00000156   0x280E             CMPNE    R0,#+14
   \   00000158   0xD00F             BEQ.N    ??WinOutgoingProcess_15
    648                                  {
    649                                      // Broadcast of PC don't not send ack
    650                                      DropSendingMessage();
    651                                  }
    652                                  else
    653                                  {
    654                                      // ack  expected and not received.
    655                                      #if (WIN_DEBUG == ENABLED)
    656                                          Win_Ack_Error_Counter++;
    657                                      #endif
    658                                      if (Win_Retry > 0)      // this is the retry procedure for messages not ack from the target
   \   0000015A   0xF894 0x10A4      LDRB     R1,[R4, #+164]
   \   0000015E   0xB119             CBZ.N    R1,??WinOutgoingProcess_16
    659                                      {
    660                                          Win_Retry--;
   \   00000160   0x1E48             SUBS     R0,R1,#+1
   \   00000162   0xF884 0x00A4      STRB     R0,[R4, #+164]
    661                                          Win_Tx_Message_State = WIN_MESSAGE_READY;
   \   00000166   0xE013             B.N      ??WinOutgoingProcess_14
    662                                          WIN_RETRY_OUTGOING_MESSAGE(&Win_Tx_Buffer);
    663                                      }
    664                                      else
    665                                      {
    666                                          #if (WIN_NODE_STATUS == ENABLED)
    667                                                  BIT_CLR(Win_Node_Status,Win_Tx_Buffer.destination);
   \                     ??WinOutgoingProcess_16: (+1)
   \   00000168   0x2201             MOVS     R2,#+1
   \   0000016A   0xF8B4 0x10B8      LDRH     R1,[R4, #+184]
   \   0000016E   0xFA02 0xF000      LSL      R0,R2,R0
   \   00000172   0xEA21 0x0000      BIC      R0,R1,R0
   \   00000176   0xF8A4 0x00B8      STRH     R0,[R4, #+184]
    668                                          #endif
    669          
    670                                          // when the number of retries expires the message is dropped.
    671                                          WIN_DROPPED_OUTGOING_MESSAGE(&Win_Tx_Buffer);
    672                                          DropSendingMessage();
   \                     ??WinOutgoingProcess_15: (+1)
   \   0000017A   0x2000             MOVS     R0,#+0
   \   0000017C   0xF884 0x00A9      STRB     R0,[R4, #+169]
   \   00000180   0xF894 0x00AC      LDRB     R0,[R4, #+172]
   \   00000184   0x28FF             CMP      R0,#+255
   \   00000186   0xD006             BEQ.N    ??WinOutgoingProcess_8
   \   00000188   0x1C40             ADDS     R0,R0,#+1
   \   0000018A   0xF884 0x00AC      STRB     R0,[R4, #+172]
   \   0000018E   0xE002             B.N      ??WinOutgoingProcess_8
    673                                      }
    674                                  }
    675                              }
    676                              else
    677                              {
    678                                  Win_Tx_Message_State = WIN_MESSAGE_READY;
   \                     ??WinOutgoingProcess_14: (+1)
   \   00000190   0x2002             MOVS     R0,#+2
   \   00000192   0xF884 0x00A9      STRB     R0,[R4, #+169]
    679                              }
    680                              Win_Tx_State = WIN_TX_STATE_IDLE;
    681                          }
    682                      }
    683                      break;
    684                  default:
    685                      Win_Tx_State = WIN_TX_STATE_IDLE;
   \                     ??WinOutgoingProcess_8: (+1)
   \   00000196   0x2000             MOVS     R0,#+0
   \                     ??WinOutgoingProcess_10: (+1)
   \   00000198   0xF884 0x00A6      STRB     R0,[R4, #+166]
    686                      break;
    687              }
    688          }
   \                     ??WinOutgoingProcess_9: (+1)
   \   0000019C   0xBD10             POP      {R4,PC}          ;; return
    689          
    690          
    691          
    692          //---------------------------------------------------------------------------------------------------------------------
    693          /**
    694           * @brief  Handler that manages the process to Receive messages
    695           * @details This procedure must be executed every 1m (or from on TimerInterrupt Slot)
    696           */

   \                                 In section .text, align 4, keep-with-next
    697          static void WinIncomingProcess(void)
    698          {
   \                     WinIncomingProcess: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    699              uint8 bytes_to_read;
    700              uint16 aux_short;
    701          
    702              bytes_to_read = Uart__GetStatus(WIN_COM,UART_STATUS_RX_AVAILABLE);
   \   00000004   0x2104             MOVS     R1,#+4
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       Uart__GetStatus
   \   0000000C   0x0005             MOVS     R5,R0
    703          
    704              if (bytes_to_read > 0)                          // if there are bytes in the Uart driver meaning bus activity
   \   0000000E   0x....             LDR.N    R4,??DataTable12
   \   00000010   0xD00C             BEQ.N    ??WinIncomingProcess_1
    705              {
    706                  Win_Bus_Idle_Timer = WIN_NODE_MAX_TIME;     // This timer times 34ms which is used to detect situations of the bus is really in idle and no other nodes want to send data.
   \   00000012   0x2022             MOVS     R0,#+34
   \   00000014   0xF884 0x00A3      STRB     R0,[R4, #+163]
    707                  Win_Bus_Idle = WIN_IDLE_TIME;               // This timer is used to make sure the ack is detected within the 3ms window after the message has being sent.
   \   00000018   0x2003             MOVS     R0,#+3
   \   0000001A   0xF884 0x00A2      STRB     R0,[R4, #+162]
    708                  if (Win_Timer < WIN_NODE_TIME)              // make sure the reload doesn't overwrite a previews bigger value (power up for instance).
   \   0000001E   0xF894 0x00A0      LDRB     R0,[R4, #+160]
   \   00000022   0x2804             CMP      R0,#+4
   \   00000024   0xBFBC             ITT      LT 
    709                  {
    710                      Win_Timer = WIN_NODE_TIME;              // reload node timer which depends on the node address.
   \   00000026   0x2004             MOVLT    R0,#+4
   \   00000028   0xF884 0x00A0      STRBLT   R0,[R4, #+160]
    711                  }
    712              }
    713          
    714              if (Win_Rx_Message_Time > 0)                    // timer to detect stuck message ifor parser
   \                     ??WinIncomingProcess_1: (+1)
   \   0000002C   0xF894 0x00B0      LDRB     R0,[R4, #+176]
   \   00000030   0xB150             CBZ.N    R0,??WinIncomingProcess_2
    715              {
    716                  Win_Rx_Message_Time--;
   \   00000032   0x1E40             SUBS     R0,R0,#+1
   \   00000034   0xF884 0x00B0      STRB     R0,[R4, #+176]
    717                  if (Win_Rx_Message_Time == 0)
   \   00000038   0xB2C0             UXTB     R0,R0
   \   0000003A   0xB928             CBNZ.N   R0,??WinIncomingProcess_2
    718                  {
    719                      if ( Win_Rx_Message_State != WIN_MESSAGE_FREE)  // if the timer expire and still not Free
   \   0000003C   0xF894 0x00A8      LDRB     R0,[R4, #+168]
   \   00000040   0xB110             CBZ.N    R0,??WinIncomingProcess_2
    720                      {
    721                          Win_Rx_Message_State = WIN_MESSAGE_FREE;    // free the message
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF884 0x00A8      STRB     R0,[R4, #+168]
    722                      }
    723                  }
    724              }
    725          
    726              if (Win_Timer > 0)                              // decrement the node bus timer
   \                     ??WinIncomingProcess_2: (+1)
   \   00000048   0xF894 0x00A0      LDRB     R0,[R4, #+160]
   \   0000004C   0xB110             CBZ.N    R0,??WinIncomingProcess_3
    727              {
    728                  Win_Timer--;
   \   0000004E   0x1E40             SUBS     R0,R0,#+1
   \   00000050   0xF884 0x00A0      STRB     R0,[R4, #+160]
    729              }
    730          
    731              if (Win_Bus_Idle > 0)                           // decrement the bus idle for more than 3ms timer.
   \                     ??WinIncomingProcess_3: (+1)
   \   00000054   0xF894 0x00A2      LDRB     R0,[R4, #+162]
   \   00000058   0xB118             CBZ.N    R0,??WinIncomingProcess_4
    732              {
    733                  Win_Bus_Idle--;
   \   0000005A   0x1E40             SUBS     R0,R0,#+1
   \   0000005C   0xF884 0x00A2      STRB     R0,[R4, #+162]
   \   00000060   0xE005             B.N      ??WinIncomingProcess_5
    734              }
    735              else
    736              {
    737                  if (Win_Rx_State != WIN_RX_STATE_IDLE)      // if the RX state machine got stuck in the middle of a process and the bus is idle for more than 3ms it will be re-initialized.
   \                     ??WinIncomingProcess_4: (+1)
   \   00000062   0xF894 0x00A7      LDRB     R0,[R4, #+167]
   \   00000066   0xB110             CBZ.N    R0,??WinIncomingProcess_5
    738                  {
    739                      Win_Rx_State = WIN_RX_STATE_IDLE;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xF884 0x00A7      STRB     R0,[R4, #+167]
    740                  }
    741              }
    742          
    743              if (Win_Tx_State != WIN_TX_STATE_GRANT_BUS)
   \                     ??WinIncomingProcess_5: (+1)
   \   0000006E   0xF894 0x00A6      LDRB     R0,[R4, #+166]
   \   00000072   0x2801             CMP      R0,#+1
   \   00000074   0xD107             BNE.N    ??WinIncomingProcess_6
    744              {
    745                  // reception
    746                  while (bytes_to_read > 0)
    747                  {
    748                      bytes_to_read--;
    749                      Uart_Data = Uart__ReadByte(WIN_COM);        // receive the data, byte by byte
    750                      Uart_Error = Uart__GetStatus(WIN_COM,UART_STATUS_ERROR);
    751          
    752                      if (Win_Tx_Status == WIN_TX_STATUS_SENDING)
    753                      {
    754                          // Collision evaluation, checking the echo of the trasmitted data
    755                          Win_Rx_State = WIN_RX_STATE_IDLE;
    756                          if ((Uart_Data != Win_Check_Tx_Pointer[Win_Check_Index]) || // if data doesn't match or error reported by the Uart
    757                              (Uart_Error == TRUE))
    758                          {
    759                              #if (WIN_DEBUG == ENABLED)
    760                                  if (Win_Check_Index > 4)
    761                                  {
    762                                      Win_Echo_Error_Counter++;
    763                                  }
    764                              #endif
    765          
    766                              Win_Tx_Status = WIN_TX_STATUS_COLLISION; // set the collision state
    767                              Uart__ClearTx(WIN_COM);         // stop the transmission
    768                          }
    769                          else
    770                          {
    771                              Win_Check_Index++;
    772                              aux_short = (uint16)Win_Tx_Buffer.sdu_length;
    773                              aux_short += 6;
    774                              if (Win_Check_Index >= aux_short)
    775                              {
    776                                  Win_Tx_Status = WIN_TX_STATUS_SENT; // transmission end with no issues.
    777                              }
    778                          }
    779                      }
    780                      else
    781                      {
    782                          // reception of messages comming from other nodes.
    783                          if (Uart_Error == FALSE)
    784                          {
    785                              // Reception state
    786                              switch (Win_Rx_State)
    787                              {
    788                                  case WIN_RX_STATE_IDLE:
    789                                      Win_Header.dle = Uart_Data;
    790                                      if (Win_Header.dle == WIN_DLE)      // waiting for the dle
    791                                      {
    792                                          Win_Rx_State = WIN_RX_STATE_STX;
    793                                      }
    794                                      break;
    795                                  case WIN_RX_STATE_STX:
    796                                      Win_Rx_State = WIN_RX_STATE_IDLE;   // by default it goes back to wait for the DLE
    797                                      Win_Header.stx = Uart_Data;
    798                                      if (Win_Header.stx == WIN_STX)     // if the received data is the start of text them move to the next state
    799                                      {
    800                                          Win_Rx_State = WIN_RX_STATE_ADDRESS;
    801                                          Win_Rx_Crc = 0xFF;
    802                                      }
    803                                      else if (Win_Header.stx == WIN_ACK)   // if the received data is the ack
    804                                      {
    805                                          // ack message
    806                                          if (Win_Tx_State == WIN_TX_STATE_SENDING)   // and we are waiting for a ack
    807                                          {
    808                                              #if (WIN_NODE_STATUS == ENABLED)
    809                                                  BIT_SET(Win_Node_Status,Win_Tx_Buffer.destination);
    810                                              #endif
    811          
    812                                              DropSendingMessage();       // drop the sending message
    813                                              Win_Tx_State = WIN_TX_STATE_IDLE;   // go back to wait for the DLE
    814                                          }
    815                                      }
    816                                      break;
    817                                  case WIN_RX_STATE_ADDRESS:
    818                                      Win_Header.address.byte = Uart_Data;
    819                                      Win_Rx_Crc = Crc8__ProcessByte(Win_Rx_Crc,Uart_Data);
    820          
    821                                      #if (WIN_NODE_STATUS == ENABLED)
    822                                          BIT_SET(Win_Node_Status,Win_Header.address.bits.source);
    823                                      #endif
    824          
    825                                      if ((Win_Header.address.bits.destination == Win_Node) ||    // checking for direct message or broadcast
    826                                          (Win_Header.address.bits.destination == WIN_BROADCAST))
    827                                      {
    828                                          // copy the data from the temporary buffer to the main reception buffer
    829                                          Win_Rx_State = WIN_RX_STATE_SAP;
    830                                      }
    831                                      else
    832                                      {
    833                                          // If the message is not for this node or a broadcast.
    834                                          Win_Rx_State = WIN_RX_STATE_WAIT_FOR_IDLE;
    835                                          // to ensure the next message from this source target to this node won't be ignored.
    836                                          // Prevent also buffer overflow due to a wrong source address
    837                                          if (Win_Header.address.bits.source < ELEMENTS_IN_ARRAY(Prev_Rx_Msg_Count))
    838                                          {
    839                                              Prev_Rx_Msg_Count[Win_Header.address.bits.source] = 0;
    840                                          }
    841                                      }
    842                                      break;
    843                                  case WIN_RX_STATE_SAP:
    844                                      Win_Header.sap.byte = Uart_Data;
    845                                      Win_Rx_Crc = Crc8__ProcessByte(Win_Rx_Crc,Uart_Data);
    846                                      Win_Rx_State = WIN_RX_STATE_SIZE;
    847                                      break;
    848                                  case WIN_RX_STATE_SIZE:
    849                                      Win_Header.sdu_length = Uart_Data;
    850                                      Win_Rx_Crc = Crc8__ProcessByte(Win_Rx_Crc,Uart_Data);
    851                                      if ((Win_Header.sdu_length <= WIN_MAX_INCOMING_DATA_SIZE) && // Check if the message is not bigger than the maximum size allowed.
    852                                          (Win_Rx_Message_State == WIN_MESSAGE_FREE))             // also check if the previews received message was parsed.
    853                                      {
    854                                          memcpy(&Win_Rx_Buffer,&Win_Header,sizeof(Win_Header));   // transfer the header from the initial reception buffer to the real reeption buffer.
    855                                          Win_Rx_State = WIN_RX_STATE_DATA;
    856                                          Win_Rx_Index = 0;
    857                                      }
    858                                      else
    859                                      {
    860                                          WIN_DROP_INCOMING_MESSAGE(Win_Tx_Buffer.header);        // if the message is too big or the previews message is not parser yet it will dropped.
    861                                          Win_Rx_State = WIN_RX_STATE_WAIT_FOR_IDLE;
    862                                      }
    863                                      break;
    864                                  case WIN_RX_STATE_DATA:
    865                                      Win_Rx_Buffer.payload[Win_Rx_Index] = Uart_Data;            // receiving the payload
    866                                      Win_Rx_Crc = Crc8__ProcessByte(Win_Rx_Crc,Uart_Data);
    867                                      Win_Rx_Index++;
    868                                      if (Win_Rx_Index >= Win_Rx_Buffer.sdu_length)
    869                                      {
    870                                          Win_Rx_State = WIN_RX_STATE_CRC;
    871                                      }
    872                                      break;
    873                                  case WIN_RX_STATE_CRC:
    874                                      Win_Rx_Buffer.payload[Win_Rx_Index] = Uart_Data;
    875                                      if ((Uart_Data == Win_Rx_Crc) &&                                              // Check the CRC of the received message
    876                                          (Win_Header.address.bits.source < ELEMENTS_IN_ARRAY(Prev_Rx_Msg_Count)))  // Prevent buffer overflow due to wrong source address
    877                                      {
    878                                          // Check the message counter, if it is a repeated message it won't be parsed.
    879                                          if((Win_Header.sap.bits.msg_count != Prev_Rx_Msg_Count[Win_Header.address.bits.source]) ||
    880                                              (Win_Header.sap.bits.msg_count == 0))
    881                                          {
    882                                              // set the message to be parsed.
    883                                              if (Win_Rx_Buffer.sdu_length > 0)
    884                                              {
    885                                                  Win_Rx_Message_Time = WIN_MAX_RX_PARSER_TIMEOUT;    // load the max time for the application to get the message
    886                                                  Win_Rx_Message_State = WIN_MESSAGE_READY;
    887                                              }
    888                                          }
    889                                          Prev_Rx_Msg_Count[Win_Header.address.bits.source] = Win_Header.sap.bits.msg_count;
    890          
    891          
    892                                          // if this is a direct message targeted to this node replay with ACK.
    893                                          if (Win_Header.address.bits.destination == Win_Node)
    894                                          {
    895                                              // send ACK back
    896                                              Uart__WriteByte(WIN_COM,WIN_DLE);
    897                                              Uart__WriteByte(WIN_COM,WIN_ACK);
    898                                          }
    899                                      }
    900                                      else
    901                                      {
    902                                          // if the crc doesn't match
    903                                          WIN_BAD_CRC_INCOMING_MESSAGE(Win_Rx_Buffer.header,Uart_Data,Win_Rx_Crc);
    904                                      }
    905                                      Win_Rx_State = WIN_RX_STATE_IDLE;
    906                                      break;
    907                                  case WIN_RX_STATE_WAIT_FOR_IDLE:
    908                                      // waiting for the end of the transmission
    909                                      break;
    910                                  default:
    911                                      Win_Rx_State = WIN_RX_STATE_IDLE;
    912                                      break;
    913                              }
    914                          }
    915                          else
    916                          {
    917                              Win_Rx_State = WIN_RX_STATE_IDLE;
    918                          }
    919                      }
    920                  }
    921              }
    922          }
   \                     ??WinIncomingProcess_7: (+1)
   \   00000076   0xB001             ADD      SP,SP,#+4
   \   00000078   0xBD30             POP      {R4,R5,PC}       ;; return
   \                     ??WinIncomingProcess_8: (+1)
   \   0000007A   0x2002             MOVS     R0,#+2
   \   0000007C   0xF884 0x00AA      STRB     R0,[R4, #+170]
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x.... 0x....      BL       Uart__ClearTx
   \                     ??WinIncomingProcess_6: (+1)
   \   00000086   0xB2ED             UXTB     R5,R5
   \   00000088   0x2D00             CMP      R5,#+0
   \   0000008A   0xD0F4             BEQ.N    ??WinIncomingProcess_7
   \   0000008C   0x1E6D             SUBS     R5,R5,#+1
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x.... 0x....      BL       Uart__ReadByte
   \   00000094   0xF884 0x00AE      STRB     R0,[R4, #+174]
   \   00000098   0x2105             MOVS     R1,#+5
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x.... 0x....      BL       Uart__GetStatus
   \   000000A0   0xF884 0x00AF      STRB     R0,[R4, #+175]
   \   000000A4   0xF894 0x00AA      LDRB     R0,[R4, #+170]
   \   000000A8   0x2801             CMP      R0,#+1
   \   000000AA   0xD11C             BNE.N    ??WinIncomingProcess_9
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0xF884 0x00A7      STRB     R0,[R4, #+167]
   \   000000B2   0xF8B4 0x00B2      LDRH     R0,[R4, #+178]
   \   000000B6   0xF894 0x10AE      LDRB     R1,[R4, #+174]
   \   000000BA   0xF8D4 0x20C0      LDR      R2,[R4, #+192]
   \   000000BE   0x5C82             LDRB     R2,[R0, R2]
   \   000000C0   0x4291             CMP      R1,R2
   \   000000C2   0xD1DA             BNE.N    ??WinIncomingProcess_8
   \   000000C4   0xF894 0x10AF      LDRB     R1,[R4, #+175]
   \   000000C8   0x2901             CMP      R1,#+1
   \   000000CA   0xD0D6             BEQ.N    ??WinIncomingProcess_8
   \   000000CC   0x1C40             ADDS     R0,R0,#+1
   \   000000CE   0x7921             LDRB     R1,[R4, #+4]
   \   000000D0   0xF8A4 0x00B2      STRH     R0,[R4, #+178]
   \   000000D4   0x1D89             ADDS     R1,R1,#+6
   \   000000D6   0xB280             UXTH     R0,R0
   \   000000D8   0xB289             UXTH     R1,R1
   \   000000DA   0x4288             CMP      R0,R1
   \   000000DC   0xD3D3             BCC.N    ??WinIncomingProcess_6
   \   000000DE   0x2003             MOVS     R0,#+3
   \   000000E0   0xF884 0x00AA      STRB     R0,[R4, #+170]
   \   000000E4   0xE7CF             B.N      ??WinIncomingProcess_6
   \                     ??WinIncomingProcess_9: (+1)
   \   000000E6   0xF894 0x00AF      LDRB     R0,[R4, #+175]
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xF040 0x80FC      BNE.W    ??WinIncomingProcess_10
   \   000000F0   0xF894 0x00A7      LDRB     R0,[R4, #+167]
   \   000000F4   0x2807             CMP      R0,#+7
   \   000000F6   0xF200 0x80F7      BHI.W    ??WinIncomingProcess_10
   \   000000FA   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??WinIncomingProcess_0:
   \   000000FE   0x05 0x0F          DC8      0x5,0xF,0x3C,0x68
   \              0x3C 0x68    
   \   00000102   0x78 0x9D          DC8      0x78,0x9D,0xBB,0x4
   \              0xBB 0x04    
   \                     ??WinIncomingProcess_11: (+1)
   \   00000106   0xE7BE             B.N      ??WinIncomingProcess_6
   \                     ??WinIncomingProcess_12: (+1)
   \   00000108   0xF894 0x00AE      LDRB     R0,[R4, #+174]
   \   0000010C   0xF884 0x0098      STRB     R0,[R4, #+152]
   \   00000110   0x2810             CMP      R0,#+16
   \   00000112   0xD1B8             BNE.N    ??WinIncomingProcess_6
   \   00000114   0x2001             MOVS     R0,#+1
   \                     ??WinIncomingProcess_13: (+1)
   \   00000116   0xF884 0x00A7      STRB     R0,[R4, #+167]
   \   0000011A   0xE7B4             B.N      ??WinIncomingProcess_6
   \                     ??WinIncomingProcess_14: (+1)
   \   0000011C   0x2000             MOVS     R0,#+0
   \   0000011E   0xF884 0x00A7      STRB     R0,[R4, #+167]
   \   00000122   0xF894 0x00AE      LDRB     R0,[R4, #+174]
   \   00000126   0xF884 0x0099      STRB     R0,[R4, #+153]
   \   0000012A   0x2802             CMP      R0,#+2
   \   0000012C   0xD105             BNE.N    ??WinIncomingProcess_15
   \   0000012E   0xF884 0x00A7      STRB     R0,[R4, #+167]
   \   00000132   0x20FF             MOVS     R0,#+255
   \   00000134   0xF884 0x00A1      STRB     R0,[R4, #+161]
   \   00000138   0xE7A5             B.N      ??WinIncomingProcess_6
   \                     ??WinIncomingProcess_15: (+1)
   \   0000013A   0x2806             CMP      R0,#+6
   \   0000013C   0xBF04             ITT      EQ 
   \   0000013E   0xF894 0x00A6      LDRBEQ   R0,[R4, #+166]
   \   00000142   0x2802             CMPEQ    R0,#+2
   \   00000144   0xD19F             BNE.N    ??WinIncomingProcess_6
   \   00000146   0x2101             MOVS     R1,#+1
   \   00000148   0x78A2             LDRB     R2,[R4, #+2]
   \   0000014A   0xF8B4 0x00B8      LDRH     R0,[R4, #+184]
   \   0000014E   0xF002 0x020F      AND      R2,R2,#0xF
   \   00000152   0x4091             LSLS     R1,R1,R2
   \   00000154   0x4308             ORRS     R0,R1,R0
   \   00000156   0xF8A4 0x00B8      STRH     R0,[R4, #+184]
   \   0000015A   0x2000             MOVS     R0,#+0
   \   0000015C   0xF884 0x00A9      STRB     R0,[R4, #+169]
   \   00000160   0xF894 0x00AC      LDRB     R0,[R4, #+172]
   \   00000164   0x28FF             CMP      R0,#+255
   \   00000166   0xBF1C             ITT      NE 
   \   00000168   0x1C40             ADDNE    R0,R0,#+1
   \   0000016A   0xF884 0x00AC      STRBNE   R0,[R4, #+172]
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0xF884 0x00A6      STRB     R0,[R4, #+166]
   \   00000174   0xE787             B.N      ??WinIncomingProcess_6
   \                     ??WinIncomingProcess_16: (+1)
   \   00000176   0xF894 0x00AE      LDRB     R0,[R4, #+174]
   \   0000017A   0xF884 0x009A      STRB     R0,[R4, #+154]
   \   0000017E   0xF894 0x10AE      LDRB     R1,[R4, #+174]
   \   00000182   0xF894 0x00A1      LDRB     R0,[R4, #+161]
   \   00000186   0x.... 0x....      BL       Crc8__ProcessByte
   \   0000018A   0xF894 0x209A      LDRB     R2,[R4, #+154]
   \   0000018E   0xF884 0x00A1      STRB     R0,[R4, #+161]
   \   00000192   0x2101             MOVS     R1,#+1
   \   00000194   0xF8B4 0x00B8      LDRH     R0,[R4, #+184]
   \   00000198   0x0912             LSRS     R2,R2,#+4
   \   0000019A   0x4091             LSLS     R1,R1,R2
   \   0000019C   0x4308             ORRS     R0,R1,R0
   \   0000019E   0xF8A4 0x00B8      STRH     R0,[R4, #+184]
   \   000001A2   0xF894 0x009A      LDRB     R0,[R4, #+154]
   \   000001A6   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000001AA   0xBF14             ITE      NE 
   \   000001AC   0x280F             CMPNE    R0,#+15
   \   000001AE   0x2003             MOVEQ    R0,#+3
   \   000001B0   0xD0B1             BEQ.N    ??WinIncomingProcess_13
   \   000001B2   0x2007             MOVS     R0,#+7
   \   000001B4   0xF884 0x00A7      STRB     R0,[R4, #+167]
   \   000001B8   0xF894 0x009A      LDRB     R0,[R4, #+154]
   \   000001BC   0x0900             LSRS     R0,R0,#+4
   \   000001BE   0x280F             CMP      R0,#+15
   \   000001C0   0xF4BF 0xAF61      BCS.W    ??WinIncomingProcess_6
   \   000001C4   0x1900             ADDS     R0,R0,R4
   \   000001C6   0x2100             MOVS     R1,#+0
   \   000001C8   0xF880 0x10C4      STRB     R1,[R0, #+196]
   \   000001CC   0xE75B             B.N      ??WinIncomingProcess_6
   \                     ??WinIncomingProcess_17: (+1)
   \   000001CE   0xF894 0x00AE      LDRB     R0,[R4, #+174]
   \   000001D2   0xF884 0x009B      STRB     R0,[R4, #+155]
   \   000001D6   0xF894 0x10AE      LDRB     R1,[R4, #+174]
   \   000001DA   0xF894 0x00A1      LDRB     R0,[R4, #+161]
   \   000001DE   0x.... 0x....      BL       Crc8__ProcessByte
   \   000001E2   0xF884 0x00A1      STRB     R0,[R4, #+161]
   \   000001E6   0x2004             MOVS     R0,#+4
   \   000001E8   0xF884 0x00A7      STRB     R0,[R4, #+167]
   \   000001EC   0xE74B             B.N      ??WinIncomingProcess_6
   \                     ??WinIncomingProcess_18: (+1)
   \   000001EE   0xF894 0x00AE      LDRB     R0,[R4, #+174]
   \   000001F2   0xF884 0x009C      STRB     R0,[R4, #+156]
   \   000001F6   0xF894 0x10AE      LDRB     R1,[R4, #+174]
   \   000001FA   0xF894 0x00A1      LDRB     R0,[R4, #+161]
   \   000001FE   0x.... 0x....      BL       Crc8__ProcessByte
   \   00000202   0xF884 0x00A1      STRB     R0,[R4, #+161]
   \   00000206   0xF894 0x009C      LDRB     R0,[R4, #+156]
   \   0000020A   0x2847             CMP      R0,#+71
   \   0000020C   0xDA10             BGE.N    ??WinIncomingProcess_19
   \   0000020E   0xF894 0x00A8      LDRB     R0,[R4, #+168]
   \   00000212   0xB968             CBNZ.N   R0,??WinIncomingProcess_19
   \   00000214   0x2205             MOVS     R2,#+5
   \   00000216   0xF104 0x0198      ADD      R1,R4,#+152
   \   0000021A   0xF104 0x004C      ADD      R0,R4,#+76
   \   0000021E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000222   0x2005             MOVS     R0,#+5
   \   00000224   0xF884 0x00A7      STRB     R0,[R4, #+167]
   \   00000228   0x2000             MOVS     R0,#+0
   \   0000022A   0xF8A4 0x00B6      STRH     R0,[R4, #+182]
   \   0000022E   0xE72A             B.N      ??WinIncomingProcess_6
   \                     ??WinIncomingProcess_19: (+1)
   \   00000230   0x2007             MOVS     R0,#+7
   \   00000232   0xF884 0x00A7      STRB     R0,[R4, #+167]
   \   00000236   0xE726             B.N      ??WinIncomingProcess_6
   \                     ??WinIncomingProcess_20: (+1)
   \   00000238   0xF894 0x00AE      LDRB     R0,[R4, #+174]
   \   0000023C   0xF8B4 0x10B6      LDRH     R1,[R4, #+182]
   \   00000240   0x1909             ADDS     R1,R1,R4
   \   00000242   0xF881 0x0051      STRB     R0,[R1, #+81]
   \   00000246   0xF894 0x10AE      LDRB     R1,[R4, #+174]
   \   0000024A   0xF894 0x00A1      LDRB     R0,[R4, #+161]
   \   0000024E   0x.... 0x....      BL       Crc8__ProcessByte
   \   00000252   0xF894 0x1050      LDRB     R1,[R4, #+80]
   \   00000256   0xF884 0x00A1      STRB     R0,[R4, #+161]
   \   0000025A   0xF8B4 0x00B6      LDRH     R0,[R4, #+182]
   \   0000025E   0x1C40             ADDS     R0,R0,#+1
   \   00000260   0xF8A4 0x00B6      STRH     R0,[R4, #+182]
   \   00000264   0xB280             UXTH     R0,R0
   \   00000266   0x4288             CMP      R0,R1
   \   00000268   0xF4FF 0xAF0D      BCC.W    ??WinIncomingProcess_6
   \   0000026C   0x2006             MOVS     R0,#+6
   \   0000026E   0xF884 0x00A7      STRB     R0,[R4, #+167]
   \   00000272   0xE708             B.N      ??WinIncomingProcess_6
   \                     ??WinIncomingProcess_21: (+1)
   \   00000274   0xF894 0x00AE      LDRB     R0,[R4, #+174]
   \   00000278   0xF8B4 0x10B6      LDRH     R1,[R4, #+182]
   \   0000027C   0x1909             ADDS     R1,R1,R4
   \   0000027E   0xF881 0x0051      STRB     R0,[R1, #+81]
   \   00000282   0xF894 0x00AE      LDRB     R0,[R4, #+174]
   \   00000286   0xF894 0x10A1      LDRB     R1,[R4, #+161]
   \   0000028A   0x4288             CMP      R0,R1
   \   0000028C   0xD12C             BNE.N    ??WinIncomingProcess_10
   \   0000028E   0xF894 0x009A      LDRB     R0,[R4, #+154]
   \   00000292   0x0900             LSRS     R0,R0,#+4
   \   00000294   0x280F             CMP      R0,#+15
   \   00000296   0xD227             BCS.N    ??WinIncomingProcess_10
   \   00000298   0x1900             ADDS     R0,R0,R4
   \   0000029A   0xF894 0x109B      LDRB     R1,[R4, #+155]
   \   0000029E   0xF890 0x00C4      LDRB     R0,[R0, #+196]
   \   000002A2   0x0909             LSRS     R1,R1,#+4
   \   000002A4   0x4281             CMP      R1,R0
   \   000002A6   0xD100             BNE.N    ??WinIncomingProcess_22
   \   000002A8   0xB941             CBNZ.N   R1,??WinIncomingProcess_23
   \                     ??WinIncomingProcess_22: (+1)
   \   000002AA   0xF894 0x0050      LDRB     R0,[R4, #+80]
   \   000002AE   0xB128             CBZ.N    R0,??WinIncomingProcess_23
   \   000002B0   0x2019             MOVS     R0,#+25
   \   000002B2   0xF884 0x00B0      STRB     R0,[R4, #+176]
   \   000002B6   0x2002             MOVS     R0,#+2
   \   000002B8   0xF884 0x00A8      STRB     R0,[R4, #+168]
   \                     ??WinIncomingProcess_23: (+1)
   \   000002BC   0xF894 0x009A      LDRB     R0,[R4, #+154]
   \   000002C0   0xF894 0x109B      LDRB     R1,[R4, #+155]
   \   000002C4   0xEB04 0x1010      ADD      R0,R4,R0, LSR #+4
   \   000002C8   0x0909             LSRS     R1,R1,#+4
   \   000002CA   0xF880 0x10C4      STRB     R1,[R0, #+196]
   \   000002CE   0x210F             MOVS     R1,#+15
   \   000002D0   0xF894 0x009A      LDRB     R0,[R4, #+154]
   \   000002D4   0x4208             TST      R0,R1
   \   000002D6   0xD107             BNE.N    ??WinIncomingProcess_10
   \   000002D8   0x2110             MOVS     R1,#+16
   \   000002DA   0x2000             MOVS     R0,#+0
   \   000002DC   0x.... 0x....      BL       Uart__WriteByte
   \   000002E0   0x2106             MOVS     R1,#+6
   \   000002E2   0x2000             MOVS     R0,#+0
   \   000002E4   0x.... 0x....      BL       Uart__WriteByte
   \                     ??WinIncomingProcess_10: (+1)
   \   000002E8   0x2000             MOVS     R0,#+0
   \   000002EA   0xF884 0x00A7      STRB     R0,[R4, #+167]
   \   000002EE   0xE6CA             B.N      ??WinIncomingProcess_6
    923          
    924          
    925          //---------------------------------------------------------------------------------------------------------------------
    926          /**
    927           * @brief This method sends data from the transmission buffer controlling the flow depending on the availability on
    928           * the Uart driver
    929           */

   \                                 In section .text, align 2, keep-with-next
    930          static void SendData(void)
    931          {
   \                     SendData: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    932              uint8 space_available;
    933              if (Win_Remaining_Data > 0)                     // if only perform the action if still bytes to be sent.
   \   00000002   0x....             LDR.N    R4,??DataTable12
   \   00000004   0xF8B4 0x00B4      LDRH     R0,[R4, #+180]
   \   00000008   0xB081             SUB      SP,SP,#+4
   \   0000000A   0xB1F0             CBZ.N    R0,??SendData_0
    934              {
    935                  Node_Not_Sending_Timer = WIN_TIME_HOLDING_MSG;
   \   0000000C   0x2064             MOVS     R0,#+100
   \   0000000E   0xF884 0x00AD      STRB     R0,[R4, #+173]
    936          
    937                  // make sure still having data to send
    938                  space_available = Uart__GetStatus(WIN_COM,UART_STATUS_TX_AVAILABLE);
   \   00000012   0x2103             MOVS     R1,#+3
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      BL       Uart__GetStatus
   \   0000001A   0x4605             MOV      R5,R0
    939                
    940                  // The following code limits the amount of bytes we send to the UART driver at once.
    941                  if(space_available > WIN_MAX_BYTES_HANDLED_AT_ONCE)
   \   0000001C   0x2D06             CMP      R5,#+6
   \   0000001E   0xBFA8             IT       GE 
    942                  {
    943                      space_available = WIN_MAX_BYTES_HANDLED_AT_ONCE;
   \   00000020   0x2505             MOVGE    R5,#+5
    944                  }
    945                  
    946                  // The following code checks if the remaining data to be sent is less that the limits the Uart driver can take.
    947                  if (space_available > Win_Remaining_Data)
   \   00000022   0xF8B4 0x00B4      LDRH     R0,[R4, #+180]
   \   00000026   0x42A8             CMP      R0,R5
   \   00000028   0xBF38             IT       CC 
    948                  {
    949                      space_available = (uint8)Win_Remaining_Data;
   \   0000002A   0x4605             MOVCC    R5,R0
    950                  }
    951                  Win_Remaining_Data -= space_available;
   \   0000002C   0xB2ED             UXTB     R5,R5
   \   0000002E   0x1B40             SUBS     R0,R0,R5
   \   00000030   0xF8A4 0x00B4      STRH     R0,[R4, #+180]
    952                  Uart__Write(WIN_COM,Win_Tx_Pointer,space_available);
   \   00000034   0x462A             MOV      R2,R5
   \   00000036   0xF8D4 0x10BC      LDR      R1,[R4, #+188]
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x.... 0x....      BL       Uart__Write
    953                  Win_Tx_Pointer += space_available;
   \   00000040   0xF8D4 0x00BC      LDR      R0,[R4, #+188]
   \   00000044   0x1828             ADDS     R0,R5,R0
   \   00000046   0xF8C4 0x00BC      STR      R0,[R4, #+188]
    954              }
    955          }
   \                     ??SendData_0: (+1)
   \   0000004A   0xB001             ADD      SP,SP,#+4
   \   0000004C   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     Win_Tx_Buffer
    956          
    957          //---------------------------------------------------------------------------------------------------------------------
    958          /**
    959           * @brief This method change the state of a sending message to free which means message sent or dropped.
    960           */
    961          static void DropSendingMessage(void)
    962          {
    963              Win_Tx_Message_State = WIN_MESSAGE_FREE;
    964              if (Node_Sent_Counter < 0xFF)
    965              {
    966                  Node_Sent_Counter++;
    967              }
    968          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   SendData
        16   -> Uart__GetStatus
        16   -> Uart__Write
      16   WinIncomingProcess
        16   -> Crc8__ProcessByte
        16   -> Uart__ClearTx
        16   -> Uart__GetStatus
        16   -> Uart__ReadByte
        16   -> Uart__WriteByte
        16   -> __aeabi_memcpy4
       8   WinOutgoingProcess
         8   -> SendData
         8   -> Uart__GetStatus
         0   -> Uart__Initialize
         8   -> Uart__ReadByte
         8   -> Uart__WriteByte
       0   Win__AllocateMessage
       0   Win__ClearNodeStatus
       0   Win__FreeIncomingMessage
       0   Win__GetAddress
       0   Win__GetBusStatus
         0   -> Uart__GetStatus
       0   Win__GetIncomingMessage
       0   Win__GetNodeStatus
       8   Win__Handle1ms
         0   -> Uart__Handler
         8   -> WinIncomingProcess
         8   -> WinOutgoingProcess
       8   Win__Initialize
         8   -> Uart__Initialize
         8   -> __aeabi_memclr4
       8   Win__QueueMessage
         8   -> Crc8
       0   Win__SendBreak
         0   -> Uart__SendBreak
       0   Win__SetAddress
       8   Win__StopBreak
         8   -> Uart__StopBreak


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
      78  SendData
     752  WinIncomingProcess
     414  WinOutgoingProcess
     212  Win_Tx_Buffer
          Win_Rx_Buffer
          Win_Header
          Win_Timer
          Win_Rx_Crc
          Win_Bus_Idle
          Win_Bus_Idle_Timer
          Win_Retry
          Win_Retry_Collision
          Win_Tx_State
          Win_Rx_State
          Win_Rx_Message_State
          Win_Tx_Message_State
          Win_Tx_Status
          Msg_Count
          Node_Sent_Counter
          Node_Not_Sending_Timer
          Uart_Data
          Uart_Error
          Win_Rx_Message_Time
          Win_Check_Index
          Win_Remaining_Data
          Win_Rx_Index
          Win_Node_Status
          Win_Break_Counter
          Win_Tx_Pointer
          Win_Check_Tx_Pointer
          Prev_Rx_Msg_Count
      22  Win__AllocateMessage
      12  Win__ClearNodeStatus
      32  Win__FreeIncomingMessage
       4  Win__GetAddress
      22  Win__GetBusStatus
      40  Win__GetIncomingMessage
      10  Win__GetNodeStatus
      46  Win__Handle1ms
     134  Win__Initialize
     142  Win__QueueMessage
      18  Win__SendBreak
       2  Win__SetAddress
      24  Win__StopBreak

 
   212 bytes in section .bss
 1 756 bytes in section .text
 
 1 756 bytes of CODE memory
   212 bytes of DATA memory

Errors: none
Warnings: none
