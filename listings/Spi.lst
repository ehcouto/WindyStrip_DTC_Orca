###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        13/Mar/2025  15:31:44
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  XCategory\Driver\Spi\Spi.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        Spi.obj -l ..\listings\Spi.lst XCategory\Driver\Spi\Spi.c
#    List file    =  ..\listings\Spi.lst
#    Object file  =  Spi.obj
#
###############################################################################

C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Spi\Spi.c
      1          /**
      2           *  @file
      3           *  @brief      Spi GDM module for MV31x and MKV30x implements the Spi Standard API (Application Programming Interface).
      4           *  @details    This module provides the synchronous serial communication services to the application,
      5           *              such as initialization of Spi module, transmission/reception of byte and multiple bytes
      6           *              via Spi and status of Spi communication.
      7           * <pre>
      8           * The Spi0 is available in the below port pins in MKV3x Controllers
      9           * ------------------------------------------------------         ----------------------------------------
     10           * |                    MKV03x_FAMILY                   |        |              MKV03x_FAMILY            |
     11           * |----------------------------------------------------|        |---------------------------------------|
     12           * |SPI com      | REMAP 0 | REMAP 1 | REMAP 2 |REMAP 3 |        |SPI com     |REMAP 0| REMAP 1 |   NA   |
     13           * |-------------|---------|---------|---------|--------|        |------------|-------|---------|--------|
     14           * |      | MOSI |PORTE 19 |PORTA 16 | PORTC 6 |PORTD 2 |        |     | MOSI |PORTE 1| PORTB 16|PORTD 7 |
     15           * |      |------|---------|---------|---------|--------|        |     |------|-------|---------|--------|
     16           * |      | MISO |PORTE 18 |PORTA 17 | PORTC 7 |PORTD 3 |        |     | MISO |PORTE 3| PORTB 17|PORTD 6 |
     17           * | SPI0 |------|---------|---------|---------|--------|        |SPI1 |------|-------|---------|--------|
     18           * |      | SCK  |PORTE 17 |PORTA 15 | PORTC 5 |PORTD 1 |        |     | SCK  |PORTE 2| PORTB 1 |PORTD 5 |
     19           * |      |------|--------------------------------------|        |     |------|--------------------------|
     20           * |      | SS   |          UNUSED                      |        |     | SS   |         UNUSED           |
     21           * -----------------------------------------------------          --------------------------------------- </pre>
     22           *
     23           *
     24           *  $Header: Spi.c 1.10 2014/12/11 21:33:33IST Natak Rahul (NATAKRB) Exp  $
     25           *
     26           *   @copyright  Copyright 2007-2012-$Date: 2014/12/11 21:33:33IST $. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     27           */
     28          //-------------------------------------- Include Files ----------------------------------------------------------------
     29          #include "C_Extensions.h"
     30          #include "Spi.h"
     31          #include "uc.h"
     32          #include "Micro.h"
     33          #include "Gpio.h"

  extern const volatile GPIO_DEF * GPIO_PORT_LIST[];
  ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Gpio\Gpio_macros.h",34  Remark[Pe083]: 
          type qualifier specified more than once

  PACKED typedef struct
         ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\API\Gpio\Gpio.h",41  Remark[Pe082]: 
          storage class is not first
     34          #include "string.h"
     35          #include "Dma.h"

  }DMA_INIT_TYPE;;
                 ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Dma\Dma_def.h",84  Remark[Pe381]: 
          extra ";" ignored
     36          #include "Spi_prm.h"
     37          
     38          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     39          //=====================================================================================================================
     40          //Compiler directive
     41          //=====================================================================================================================
     42          #ifndef SPI0_TX_RX_MODE
     43              #define SPI0_TX_RX_MODE        ENABLED
     44          #endif
     45          
     46          #if (SPI0_BUFFER_SIZE == 0)
     47              #error : " SPI0_BUFFER_SIZE macro value must be non-zero in the Spi_prm.h file"
     48          #endif
     49          
     50          #if (SPI0_REMAP > 3)
     51              #error : " SPI0_REMAP macro value must be either 0 or 1 in the Spi_prm.h file"
     52          #endif
     53          
     54          //=====================================================================================================================
     55          // Spi and Dma Configuration
     56          //=====================================================================================================================
     57          #define DSPI_MASTER_BASEADDR                            SPI_0
     58          #define DSPI_MASTER_DMA_RX_REQUEST_SOURCE               kDmaRequestMux0SPI0Rx
     59          #define DSPI_MASTER_DMA_TX_REQUEST_SOURCE               kDmaRequestMux0SPI0Tx
     60          #define DSPI_MASTER_PCS_FOR_INIT                        kDSPI_Pcs0
     61          #define DSPI_MASTER_PCS_FOR_TRANSFER                    kDSPI_MasterPcs0
     62          #define DSPI_MASTER_DMA_MUX_BASEADDR                    ((DMAMUX_Type *)(EXAMPLE_DSPI_MASTER_DMA_MUX_BASE))
     63          #define TRANSFER_baud_rate                               6000000U /*! Transfer baud_rate - 6M */
     64          #define DSPI_CTAR0                                      0U  //DSPI Clock and Transfer Attributes Register (CTAR) selection.
     65          #define DSPI_PCS_ACTIVE_HIGH                            0U  //DSPI Peripheral Chip Select (Pcs) Polarity configuration
     66          #define DSPI_SCK_TO_SIN0_CLOCK                          0U /*!< 0 system clocks between SCK edge and SIN sample.*/
     67          #define DSPI_MASTER_PCS_CONTINUOS                       1U << 20      /*!< Indicates whether the PCS signal is continuous. */
     68          #define DSPI_MASTER_ACTIVE_AFTER_TRANSFER               1U << 21 /*!< Indicates whether the PCS signal is active after the last frame transfer.*/
     69          #define FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(x) ((x) == DSPI0 ? (1) : \
     70                                                                  ((x) == DSPI1 ? (0) : (-1)))  /* @brief Has separate DMA RX and TX requests. */
     71          
     72          #define FSL_FEATURE_DSPI_FIFO_SIZEn(x)                  ((x) == DSPI0 ? (4) : \
     73                                                                  ((x) == DSPI1 ? (1) : (-1))) //specifies the size for the fifo buffer
     74          
     75          #define DSPI_BUSY                                       1
     76          #define DSPI_DUMMY_DATA                                 0
     77          
     78          
     79          #define SPI_DMA_FEATURE                                 ENABLED
     80          #define DSPI_MASTER                                     1
     81          
     82          #define HANDLE_COMMAND                                  0x00000004 //used for communication start
     83          #define HANDLE_LAST_COMMAND                             0x00000007 //This comand is used to send the last byte of data
     84          
     85          
     86          //=====================================================================================================================
     87          //Variable section
     88          //=====================================================================================================================
     89          /* Defines constant value arrays for the baud rate pre-scalar and scalar divider values.*/

   \                                 In section .text, align 4, keep-with-next
     90          static const uint32 BAUD_RATE_PRESCALAR[] = {2, 3, 5, 7};
   \                     BAUD_RATE_PRESCALAR:
   \   00000000   0x00000002         DC32 2, 3, 5, 7
   \              0x00000003   
   \              0x00000005   
   \              0x00000007   

   \                                 In section .text, align 4, keep-with-next
     91          static const uint32 BAUD_RATE_SCALAR[] = {2,4,6,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768};
   \                     BAUD_RATE_SCALAR:
   \   00000000   0x00000002         DC32 2, 4, 6, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192
   \              0x00000004   
   \              0x00000006   
   \              0x00000008   
   \              0x00000010   
   \              0x00000020   
   \              0x00000040   
   \              0x00000080   
   \              0x00000100   
   \              0x00000200   
   \              0x00000400   
   \              0x00000800   
   \              0x00001000   
   \              0x00002000   
   \   00000038   0x00004000         DC32 16384, 32768
   \              0x00008000   
     92          /*! @brief DSPI clock polarity configuration for a given CTAR.*/
     93          typedef enum
     94          {
     95              DSPI_CLOCK_POLARITY_ACTIVE_HIGH = 0U, /*!< CPOL=0. Active-high DSPI clock (idles low).*/
     96              DSPI_CLOCK_POLARITY_ACTIVE_LOW = 1U   /*!< CPOL=1. Active-low DSPI clock (idles high).*/
     97          } DSPI_CLOCK_POLARITY;
     98          
     99          /*! @brief DSPI clock phase configuration for a given CTAR.*/
    100          typedef enum
    101          {
    102              DSPI_CLOCK_PHASE_FIRST_EDGE = 0U, /*!< CPHA=0. Data is captured on the leading edge of the SCK and changed on the
    103                                                   following edge.*/
    104              DSPI_ClLOCK_PHASE_SECOND_EDGE = 1U /*!< CPHA=1. Data is changed on the leading edge of the SCK and captured on the
    105                                                  following edge.*/
    106          } DSPI_CLOCK_PHASE;
    107          
    108          /*! @brief DSPI data shifter direction options for a given CTAR.*/
    109          typedef enum
    110          {
    111              DSPI_MSB_FIRST = 0U, /*!< Data transfers start with the most significant bit.*/
    112              DSPI_LSB_FIRST = 1U  /*!< Data transfers start with the least significant bit.*/
    113          } DSPI_SHIFT_DIRECTION;
    114          
    115          /*! @brief eDMA transfer configuration */
    116          typedef enum
    117          {
    118              DMA_TRANSFER_SIZE_ONE_BYTE = 0x0U,  /*!< Source/Destination data transfer size is 1 byte every time */
    119              DMA_TRANSFER_SIZE_TWO_BYTE = 0x1U,  /*!< Source/Destination data transfer size is 2 bytes every time */
    120              DMA_TRANSFER_SIZE_FOUR_BYTE = 0x2U,  /*!< Source/Destination data transfer size is 4 bytes every time */
    121              DMA_TRANSFER_SIZE_SIXTEEN_BYTE = 0x4U, /*!< Source/Destination data transfer size is 16 bytes every time */
    122              DMA_TRANSFER_SIZE_THIRTY_TWO_BYTE = 0x5U, /*!< Source/Destination data transfer size is 32 bytes every time */
    123          } EDMA_TRANSFER_SIZE;
    124          
    125          /*!
    126           * @brief eDMA TCD.
    127           *
    128           * This structure is the same as the TCD register, which is described in the chip reference manual
    129           * and is used to configure scatter/gather feature as a next hardware TCD.
    130           */
    131          typedef struct
    132          {
    133              volatile uint32 SADDR;     /*!< SADDR register, used to save source address */
    134              volatile uint16 SOFF;      /*!< SOFF register, save offset bytes every transfer */
    135              volatile uint16 ATTR;      /*!< ATTR register, source/destination transfer size and modulo */
    136              volatile uint32 NBYTES;    /*!< Nbytes register, minor loop length in bytes */
    137              volatile uint32 SLAST;     /*!< SLAST register */
    138              volatile uint32 DADDR;     /*!< DADDR register, used for destination address */
    139              volatile uint16 DOFF;      /*!< DOFF register, used for destination offset */
    140              volatile uint16 CITER;     /*!< CITER register, current minor loop numbers, for unfinished minor loop.*/
    141              volatile uint32 DLAST_SGA; /*!< DLASTSGA register, next stcd address used in scatter-gather mode */
    142              volatile uint16 CSR;       /*!< CSR register, for TCD control status */
    143              volatile uint16 BITER;     /*!< BITER register, begin minor loop count. */
    144          } EDMA_TCD;
    145          /*! @brief eDMA transfer handle structure */
    146          typedef struct
    147          {
    148              void *userdata;          /*!< Callback function parameter. */
    149              DMA_TYPE *base;          /*!< eDMA peripheral base address. */
    150              EDMA_TCD *tcd_pool;     /*!< Pointer to memory stored TCDs. */
    151              uint8 channel;         /*!< eDMA channel number. */
    152              volatile uint8 header;  /*!< The first TCD index. */
    153              volatile uint8 tail;    /*!< The last TCD index. */
    154              volatile uint8 tcd_used; /*!< The number of used TCD slots. */
    155              volatile uint8 tcd_size; /*!< The total number of TCD slots in the queue. */
    156              uint8 flags;           /*!< The status of the current channel. */
    157          } EDMA_HANDLE;
    158          /*!
    159           * @brief eDMA TCD.
    160           *
    161           * This structure is the same as the TCD register, which is described in the chip reference manual
    162           * and is used to configure scatter/gather feature as a next hardware TCD.
    163           */
    164          /*! @brief DSPI master eDMA transfer handle structure used for the transactional API. */
    165          typedef struct
    166          {
    167              uint32 bits_per_frame;         /*!< The desired number of bits per frame. */
    168              volatile uint32 command;     /*!< The desired data command. */
    169              volatile uint32 last_command; /*!< The desired last data command. */
    170          
    171              uint8 fifoSize; /*!< FIFO data_size. */
    172          
    173              BOOL_TYPE is_pcs_active_after_transfer; /*!< Indicates whether the PCS signal keeps active after the last frame transfer.*/
    174              BOOL_TYPE is_there_extra_byte;         /*!< Indicates whether there is an extra byte.*/
    175          
    176              uint8 *volatile tx_data;                  /*!< Send buffer. */
    177              uint8 *volatile rx_data;                  /*!< Receive buffer. */
    178              volatile size_t remaining_send_byte_count;    /*!< A number of bytes remaining to send.*/
    179              volatile size_t remaining_receive_byte_count; /*!< A number of bytes remaining to receive.*/
    180              size_t total_byte_count;                     /*!< A number of transfer bytes*/
    181          
    182              uint32 rx_buff_If_null; /*!< Used if there is not rx_data for DMA purpose.*/
    183              uint32 tx_buff_if_null; /*!< Used if there is not tx_data for DMA purpose.*/
    184          
    185              volatile uint8 state; /*!< DSPI transfer state, see _dspi_transfer_state.*/
    186          
    187              void *userdata;                                /*!< Callback user data. */
    188          
    189              EDMA_HANDLE *edma_rx_reg_to_rx_data_handle;        /*!<EDMA_HANDLE_t handle point used for RxReg to rx_data buff*/
    190              EDMA_HANDLE *edma_tx_data_to_intermediary_handle; /*!<EDMA_HANDLE_t handle point used for tx_data to Intermediary*/
    191              EDMA_HANDLE *edma_intermediary_to_tx_reg_handle;  /*!<EDMA_HANDLE_t handle point used for Intermediary to TxReg*/
    192          
    193              EDMA_TCD dspi_software_tcd[2]; /*!<software_tcd , internal used*/
    194          }SPI_MASTER_DMA_HANDLE;
    195          /*! @brief DSPI master/slave transfer structure.*/
    196          typedef struct DSPI_TRANSFER
    197          {
    198              uint8 *tx_data;          /*!< Send buffer. */
    199              uint8 *rx_data;          /*!< Receive buffer. */
    200              volatile size_t data_size; /*!< Transfer bytes. */
    201          
    202              uint32 config_flags; /*!< Transfer transfer configuration flags; set from _dspi_transfer_config_flag_for_master if the
    203                                  transfer is used for master or _dspi_transfer_config_flag_for_slave enumeration if the transfer
    204                                  is used for slave.*/
    205          } dspi_transfer;
    206          /*!
    207           * @brief eDMA transfer configuration
    208           *
    209           * This structure configures the source/destination transfer attribute.
    210           * This figure shows the eDMA's transfer model:
    211           *  _________________________________________________
    212           *              | Transfer Size |                    |
    213           *   Minor Loop |_______________| Major loop Count 1 |
    214           *     Bytes    | Transfer Size |                    |
    215           *  ____________|_______________|____________________|--> Minor loop complete
    216           *               ____________________________________
    217           *              |               |                    |
    218           *              |_______________| Major Loop Count 2 |
    219           *              |               |                    |
    220           *              |_______________|____________________|--> Minor loop  Complete
    221           *
    222           *               ---------------------------------------------------------> Transfer complete
    223           */
    224          /*! @brief DSPI master command data configuration used for the SPIx_PUSHR.*/
    225          typedef struct
    226          {
    227              BOOL_TYPE is_pcs_continuous;            /*!< Option to enable the continuous assertion of the chip select between transfers.*/
    228              BOOL_TYPE is_end_of_queue;               /*!< Signals that the current transfer is the last in the queue.*/
    229              BOOL_TYPE clear_transfer_count;         /*!< Clears the SPI Transfer Counter (SPI_TCNT) before transmission starts.*/
    230          } DSPI_COMMAND_DATA_CONFIG;
    231          
    232          /*! @brief DSPI master transfer data configuration used for the transfer*/
    233          typedef struct
    234          {
    235              uint32 src_addr;                      /*!< Source data address. */
    236              uint32 dest_addr;                     /*!< Destination data address. */
    237              EDMA_TRANSFER_SIZE source_transfer_size;  /*!< Source data transfer size. */
    238              EDMA_TRANSFER_SIZE dest_transfer_size; /*!< Destination data transfer size. */
    239              uint16 source_offset;                     /*!< Sign-extended offset applied to the current source address to
    240                                                          form the next-state value as each source read is completed. */
    241              uint16 dest_offset;                    /*!< Sign-extended offset applied to the current destination address to
    242                                                          form the next-state value as each destination write is completed. */
    243              uint32 minor_loop_bytes;               /*!< Bytes to transfer in a minor loop*/
    244              uint32 major_loop_counts;              /*!< Major loop iteration count. */
    245          }EDMA_TRANSFER_CONFIG;
    246          
    247          /*! @brief DSPI master ctar configuration structure.*/
    248          typedef struct
    249          {
    250              uint32 baud_rate;                /*!< Baud Rate for DSPI. */
    251              uint32 bits_per_frame;            /*!< Bits per frame, minimum 4, maximum 16.*/
    252              DSPI_CLOCK_POLARITY cpol;       /*!< Clock polarity. */
    253              DSPI_CLOCK_PHASE cpha;          /*!< Clock phase. */
    254              DSPI_SHIFT_DIRECTION direction; /*!< MSB or LSB data shift direction. */
    255          
    256              uint32 pcs_to_sck_delay_in_nano_sec;        /*!< PCS to SCK delay time in nanoseconds; setting to 0 sets the minimum
    257                                                         delay. It also sets the boundary value if out of range.*/
    258              uint32 last_sck_to_pcs_delay_nano_sec;    /*!< The last SCK to PCS delay time in nanoseconds; setting to 0 sets the
    259                                                         minimum delay. It also sets the boundary value if out of range.*/
    260          
    261              uint32 between_transfer_delay_in_nano_sec; /*!< After the SCK delay time in nanoseconds; setting to 0 sets the minimum
    262                                                       delay. It also sets the boundary value if out of range.*/
    263          }DSPI_MASTER_CTAR_CONFIG;
    264          
    265          /*! @brief DSPI master configuration structure.*/
    266          typedef struct
    267          {
    268              DSPI_MASTER_CTAR_CONFIG ctar_config; /*!< Set the ctar_config to the desired CTAR. */
    269              BOOL_TYPE enable_continuos_sck;   /*!< CONT_SCKE, continuous SCK enable. Note that the continuous SCK is only
    270                                               supported for CPHA = 1.*/
    271              BOOL_TYPE enable_rx_fifo_over_write; /*!< ROOE, receive FIFO overflow overwrite enable. If ROOE = 0, the incoming
    272                                               data is ignored and the data from the transfer that generated the overflow
    273                                               is also ignored. If ROOE = 1, the incoming data is shifted to the
    274                                               shift register. */
    275          
    276              BOOL_TYPE enable_modified_timing_format;        /*!< Enables a modified transfer format to be used if true.*/
    277          }DSPI_MASTER_CONFIG;
    278          
    279          #if ((SPI0_BUFFER_SIZE > 255) || (SPI1_BUFFER_SIZE > 255))
    280              typedef uint16 SPI_BUFFER_TYPE;
    281          #else
    282              typedef uint8 SPI_BUFFER_TYPE;
    283          #endif
    284          
    285          #if (SPI0_FEATURE == ENABLED)

   \                                 In section .bss, align 4
    286              static uint8 Spi0_Tx_Buffer[SPI0_BUFFER_SIZE];
    287              static SPI_BUFFER_TYPE Spi0_Tx_Write;
    288              static SPI_BUFFER_TYPE Spi0_Tx_Read;
    289              static BOOL_TYPE Spi0_Busy;
    290          
    291              #if (SPI0_TX_RX_MODE == ENABLED)
    292                  static uint8 Spi0_Rx_Buffer[SPI0_BUFFER_SIZE];
    293                  static SPI_BUFFER_TYPE Spi0_Rx_Write;
    294                  static SPI_BUFFER_TYPE Spi0_Rx_Read;
    295              #endif
    296          #endif
    297          
    298          static    uint32 masterRxChannel , masterTxChannel;
    299          static    DSPI_MASTER_CONFIG masterConfig;
   \                     masterConfig:
   \   00000000                      DS8 28
   \   0000001C                      DS8 24
   \   00000034                      DS8 24
   \   0000004C                      DS8 24
   \   00000064                      DS8 16
   \   00000074                      DS8 1
   \   00000075                      DS8 1
   \   00000076                      DS8 1
   \   00000077                      DS8 1
   \   00000078                      DS8 2
   \   0000007A                      DS8 2
   \   0000007C                      DS8 52
   \   000000B0                      DS8 52
   \   000000E4                      DS8 128

   \                                 In section .bss, align 1
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   00000000                      DS8 4
    300          
    301          #if(SPI_DMA_FEATURE==ENABLED)
    302          
    303              static uint16 word_to_send;

   \                                 In section .bss, align 1
   \   00000000                      DS8 1
    304              static uint8 dummy_data;

   \                                 In section .bss, align 4
   \   00000000                      DS8 4
    305              static uint32 rxAddr;

   \                                 In section .bss, align 4
   \   00000000                      DS8 4
    306              static uint32 txAddr;

   \                                 In section .bss, align 4
   \   00000000                      DS8 4
    307              static uint32 tmpreg;
    308          
    309              static SPI_MASTER_DMA_HANDLE  Spi_Master_Dma_Handle;
    310              static dspi_transfer master_transfer;
    311          
    312          
    313          
    314              static EDMA_TRANSFER_CONFIG transfer_config_a;
    315              static EDMA_TRANSFER_CONFIG transfer_config_b;
    316              static EDMA_TRANSFER_CONFIG transfer_config_c;
    317          
    318          #endif
    319          
    320          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
    321          void DspiMasterTransferEdma(SPI_TYPE *base, SPI_MASTER_DMA_HANDLE *handle, dspi_transfer *transfer);
    322          void DspiSetConfig(DMA_ENGINE_TYPE dma_engine,DMA_CHANNEL_TYPE channel,EDMA_TRANSFER_CONFIG *transfer_config, EDMA_TCD *next_tcd);
    323          void EdmaTcdReset( EDMA_TCD *tcd);
    324          void EdmaTcdSetTransferConfig( EDMA_TCD *tcd, const EDMA_TRANSFER_CONFIG *config);
    325          void EdmaStartTransfer(EDMA_HANDLE *handle);
    326          void DspiMasterInit(SPI_TYPE *base, const DSPI_MASTER_CONFIG *masterConfig, uint32 src_clock_hz);
    327          uint32 DspiMasterSetBaudrate(SPI_TYPE *base,uint32  which_ctar,uint32 baud_rate_bps,uint32 src_clock_hz);
    328          void   DspiDisable(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel);
    329          
    330          //=====================================================================================================================
    331          //-------------------------------------- Public Functions -------------------------------------------------------------
    332          //=====================================================================================================================
    333          //---------------------------------------------------------------------------------------------------------------------
    334          //---------------------------------------------------------------------------------------------------------------------
    335          /**
    336           *    @brief    This method initializes a specific SPI module by reading the Spi Configuration parameters
    337           *              defined in the Spi_prm.h file.
    338           *    @details  Before using Spi module this method should be called to initialize specific Spi module.
    339           *              To make use of this API the following configuration macros must be defined in the Spi_prm.h file-
    340           *              "#define SPI_x_pre_scaler"\n
    341           *              "#define SPI_x_LSBFIRST"\n
    342           *              "#define SPI_x_POL"\n
    343           *              "#define SPI_x_CPHA_EDGE"
    344           *    @param    spi : specific SPI module
    345           *    @image    html    Spi__Initialize.jpg
    346           */

   \                                 In section .text, align 2, keep-with-next
    347          void Spi__Initialize(SPI_ENUM_DEF spi)
    348          {
   \                     Spi__Initialize: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    349          
    350          	Spi__Clear(spi);														//Clear the buffers
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0x4004803c
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable13_1
   \   0000000C   0xB990             CBNZ.N   R0,??Spi__Initialize_0
   \   0000000E   0xF884 0x0074      STRB     R0,[R4, #+116]
   \   00000012   0xF884 0x0075      STRB     R0,[R4, #+117]
   \   00000016   0xF884 0x0076      STRB     R0,[R4, #+118]
   \   0000001A   0xF44F 0x7200      MOV      R2,#+512
    351          
    352          	#if (SPI0_FEATURE == ENABLED)
    353          		if (spi == SPI0)													//Initialize SPI0
    354          		{
    355          			SIM.SCGC6 |= SIM_SCGC6_SPI0_MASK;								//Enable the clock for Spi0 module
   \   0000001E   0x6808             LDR      R0,[R1, #+0]
   \   00000020   0x.... 0x....      LDR.W    R3,??DataTable13_2  ;; 0x4004d048
   \   00000024   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   00000028   0x6008             STR      R0,[R1, #+0]
    356          
    357          			if (SPI0_REMAP == 0)
    358          			{
    359          				PCIPORTE.PCR[17] = PORT_PCR_MUX(2);							//Set PortE pin 17 of SPI0 com: SCK
    360          				PCIPORTE.PCR[18] = PORT_PCR_MUX(2);							//Set PortE pin 18 of SPI0 com: SOUT(MOSI)
    361          				PCIPORTE.PCR[19] = PORT_PCR_MUX(2);							//Set PortE pin 19 of SPI0 com: SIN (MISO)
    362          			}
    363          			else if (SPI0_REMAP == 1)
    364          			{
    365          				PCIPORTA.PCR[15] = PORT_PCR_MUX(2);							//Set PortA pin 15 of SPI0 com: SCK
    366          				PCIPORTA.PCR[16] = PORT_PCR_MUX(2);							//Set PortA pin 16 of SPI0 com: SOUT(MOSI)
    367          				PCIPORTA.PCR[17] = PORT_PCR_MUX(2);							//Set PortA pin 17 of SPI0 com: SIN (MISO)
    368          			}
    369          			else if (SPI0_REMAP == 2)
    370          			{
    371          				PCIPORTC.PCR[5] = PORT_PCR_MUX(2);							//Set PortC pin 5 of SPI0 com: SCK
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable13_3  ;; 0x4004b014
   \   0000002E   0x6002             STR      R2,[R0, #+0]
    372          				PCIPORTE.PCR[18] = PORT_PCR_MUX(2);							//Set PortC pin 6 of SPI0 com: SOUT(MOSI)
   \   00000030   0x601A             STR      R2,[R3, #+0]
    373          				PCIPORTC.PCR[7] = PORT_PCR_MUX(2);							//Set PortC pin 7 of SPI0 com: SIN (MISO)
   \   00000032   0x6082             STR      R2,[R0, #+8]
    374          			}
    375          			else
    376          			{
    377          				PCIPORTD.PCR[1] = PORT_PCR_MUX(2);							//Set PortD pin 1 of SPI0 com: SCK
    378          				PCIPORTD.PCR[2] = PORT_PCR_MUX(2);							//Set PortD pin 2 of SPI0 com: SOUT(MOSI)
    379          				PCIPORTD.PCR[3] = PORT_PCR_MUX(2);							//Set PortD pin 3 of SPI0 com: SIN (MISO)
    380          			}
    381          		}
    382                  #if(SPI_DMA_FEATURE==ENABLED)
    383                      masterRxChannel = 0U;
    384                      masterTxChannel = 2U;
    385                      /*Master config*/
    386                      masterConfig.ctar_config.baud_rate = TRANSFER_baud_rate;
   \                     ??Spi__Initialize_0: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x5b8d80
   \   00000038   0x6020             STR      R0,[R4, #+0]
    387                      masterConfig.ctar_config.bits_per_frame = 8U;
   \   0000003A   0x2008             MOVS     R0,#+8
   \   0000003C   0x6060             STR      R0,[R4, #+4]
    388                      masterConfig.ctar_config.cpol = DSPI_CLOCK_POLARITY_ACTIVE_HIGH;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x8120             STRH     R0,[R4, #+8]
    389                      masterConfig.ctar_config.cpha = DSPI_CLOCK_PHASE_FIRST_EDGE;
    390                      masterConfig.ctar_config.direction = DSPI_MSB_FIRST;
   \   00000042   0x72A0             STRB     R0,[R4, #+10]
    391                      masterConfig.ctar_config.pcs_to_sck_delay_in_nano_sec = 1000000000U / TRANSFER_baud_rate;
   \   00000044   0x20A6             MOVS     R0,#+166
   \   00000046   0x60E0             STR      R0,[R4, #+12]
    392                      masterConfig.ctar_config.last_sck_to_pcs_delay_nano_sec = 1000000000U / TRANSFER_baud_rate;
   \   00000048   0x6120             STR      R0,[R4, #+16]
    393                      masterConfig.ctar_config.between_transfer_delay_in_nano_sec = 1000000000U / TRANSFER_baud_rate;
   \   0000004A   0x6160             STR      R0,[R4, #+20]
    394                      masterConfig.enable_continuos_sck = FALSE;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x8320             STRH     R0,[R4, #+24]
    395                      masterConfig.enable_rx_fifo_over_write = FALSE;
    396                      masterConfig.enable_modified_timing_format = FALSE;
   \   00000050   0x76A0             STRB     R0,[R4, #+26]
    397                      /* DMA MUX init */
    398                      SIM.SCGC6 |= SIM_SCGC6_DMAMUX_MASK;
   \   00000052   0x6808             LDR      R0,[R1, #+0]
   \   00000054   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000058   0x6008             STR      R0,[R1, #+0]
    399                      DMAMUX->CHCFG[masterRxChannel] = ((DMAMUX->CHCFG[masterRxChannel] & ~DMAMUX_CHCFG_SOURCE_MASK) | DMAMUX_CHCFG_SOURCE(DSPI_MASTER_DMA_RX_REQUEST_SOURCE));
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable13_5  ;; 0x40021000
   \   0000005E   0x7801             LDRB     R1,[R0, #+0]
   \   00000060   0xF001 0x01C0      AND      R1,R1,#0xC0
   \   00000064   0xF041 0x010E      ORR      R1,R1,#0xE
   \   00000068   0x7001             STRB     R1,[R0, #+0]
    400                      DMAMUX->CHCFG[masterRxChannel] |= DMAMUX_CHCFG_ENBL_MASK;
   \   0000006A   0x7801             LDRB     R1,[R0, #+0]
   \   0000006C   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000070   0x7001             STRB     R1,[R0, #+0]
    401                      DMAMUX->CHCFG[masterTxChannel] = ((DMAMUX->CHCFG[masterTxChannel] & ~DMAMUX_CHCFG_SOURCE_MASK)| DMAMUX_CHCFG_SOURCE(DSPI_MASTER_DMA_TX_REQUEST_SOURCE));
   \   00000072   0x7881             LDRB     R1,[R0, #+2]
   \   00000074   0xF001 0x01C0      AND      R1,R1,#0xC0
   \   00000078   0xF041 0x010F      ORR      R1,R1,#0xF
   \   0000007C   0x7081             STRB     R1,[R0, #+2]
    402                      DMAMUX->CHCFG[masterTxChannel] |= DMAMUX_CHCFG_ENBL_MASK;
   \   0000007E   0x7881             LDRB     R1,[R0, #+2]
   \   00000080   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000084   0x7081             STRB     R1,[R0, #+2]
    403          
    404                      DspiMasterInit(DSPI_MASTER_BASEADDR, &masterConfig, Micro__GetClock()->SYSCLK_Frequency);
   \   00000086   0x.... 0x....      BL       Micro__GetClock
   \   0000008A   0x6803             LDR      R3,[R0, #+0]
   \   0000008C   0x.... 0x....      LDR.W    R5,??DataTable13_6  ;; 0x4002c000
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable13_7  ;; 0xbaffccff
   \   00000094   0x6828             LDR      R0,[R5, #+0]
   \   00000096   0xF420 0x4080      BIC      R0,R0,#0x4000
   \   0000009A   0x6028             STR      R0,[R5, #+0]
   \   0000009C   0x6828             LDR      R0,[R5, #+0]
   \   0000009E   0xF040 0x0001      ORR      R0,R0,#0x1
   \   000000A2   0x6028             STR      R0,[R5, #+0]
   \   000000A4   0x6828             LDR      R0,[R5, #+0]
   \   000000A6   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \   000000AA   0x6028             STR      R0,[R5, #+0]
   \   000000AC   0x6828             LDR      R0,[R5, #+0]
   \   000000AE   0x4008             ANDS     R0,R1,R0
   \   000000B0   0x7E21             LDRB     R1,[R4, #+24]
   \   000000B2   0x0789             LSLS     R1,R1,#+30
   \   000000B4   0xF001 0x4180      AND      R1,R1,#0x40000000
   \   000000B8   0x4308             ORRS     R0,R1,R0
   \   000000BA   0x7EA1             LDRB     R1,[R4, #+26]
   \   000000BC   0x0689             LSLS     R1,R1,#+26
   \   000000BE   0xF001 0x6180      AND      R1,R1,#0x4000000
   \   000000C2   0x4308             ORRS     R0,R1,R0
   \   000000C4   0x7E61             LDRB     R1,[R4, #+25]
   \   000000C6   0x0609             LSLS     R1,R1,#+24
   \   000000C8   0xF001 0x7180      AND      R1,R1,#0x1000000
   \   000000CC   0x4308             ORRS     R0,R1,R0
   \   000000CE   0x6028             STR      R0,[R5, #+0]
   \   000000D0   0x2100             MOVS     R1,#+0
   \   000000D2   0x6828             LDR      R0,[R5, #+0]
   \   000000D4   0x6028             STR      R0,[R5, #+0]
   \   000000D6   0x4628             MOV      R0,R5
   \   000000D8   0x6822             LDR      R2,[R4, #+0]
   \   000000DA   0x.... 0x....      BL       DspiMasterSetBaudrate
   \   000000DE   0x68E8             LDR      R0,[R5, #+12]
   \   000000E0   0x6861             LDR      R1,[R4, #+4]
   \   000000E2   0x1E49             SUBS     R1,R1,#+1
   \   000000E4   0x06C9             LSLS     R1,R1,#+27
   \   000000E6   0xF020 0x40FE      BIC      R0,R0,#0x7F000000
   \   000000EA   0xF001 0x41F0      AND      R1,R1,#0x78000000
   \   000000EE   0x4308             ORRS     R0,R1,R0
   \   000000F0   0x7A21             LDRB     R1,[R4, #+8]
   \   000000F2   0x0689             LSLS     R1,R1,#+26
   \   000000F4   0xF001 0x6180      AND      R1,R1,#0x4000000
   \   000000F8   0x4308             ORRS     R0,R1,R0
   \   000000FA   0x7A61             LDRB     R1,[R4, #+9]
   \   000000FC   0x0649             LSLS     R1,R1,#+25
   \   000000FE   0xF001 0x7100      AND      R1,R1,#0x2000000
   \   00000102   0x4308             ORRS     R0,R1,R0
   \   00000104   0x7AA1             LDRB     R1,[R4, #+10]
   \   00000106   0x0609             LSLS     R1,R1,#+24
   \   00000108   0xF001 0x7180      AND      R1,R1,#0x1000000
   \   0000010C   0x4308             ORRS     R0,R1,R0
   \   0000010E   0x60E8             STR      R0,[R5, #+12]
   \   00000110   0x6828             LDR      R0,[R5, #+0]
   \   00000112   0x0840             LSRS     R0,R0,#+1
   \   00000114   0x0040             LSLS     R0,R0,#+1
   \   00000116   0x6028             STR      R0,[R5, #+0]
    405          
    406                  #endif
    407              #endif
    408          }
   \   00000118   0xB001             ADD      SP,SP,#+4
   \   0000011A   0xBD30             POP      {R4,R5,PC}       ;; return
    409          
    410          //---------------------------------------------------------------------------------------------------------------------
    411          /**
    412           *    @brief    It enables a specific Spi device.
    413           *    @details  This method should be called after disabling the Spi module.
    414           *    @param    spi : specific spi device
    415           */

   \                                 In section .text, align 2, keep-with-next
    416          void Spi__Enable(SPI_ENUM_DEF spi)
    417          {
    418              #if (SPI0_FEATURE == ENABLED)
    419                  if (spi == SPI0)
   \                     Spi__Enable: (+1)
   \   00000000   0xB928             CBNZ.N   R0,??Spi__Enable_0
    420                  {
    421                      SPI_0->MCR &= ~SPI_MCR_HALT_MASK;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable13_6  ;; 0x4002c000
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x0849             LSRS     R1,R1,#+1
   \   0000000A   0x0049             LSLS     R1,R1,#+1
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    422                  }
    423              #endif
    424          }
   \                     ??Spi__Enable_0: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    425          
    426          //---------------------------------------------------------------------------------------------------------------------
    427          /**
    428           *    @brief    It disables a specific Spi device.
    429           *    @details  The Spi must be enabled by calling Spi_Enable() after disable before performing the Spi communication.
    430           *    @param    spi : specific spi device
    431           */

   \                                 In section .text, align 2, keep-with-next
    432          void Spi__Disable(SPI_ENUM_DEF spi)
    433          {
    434              #if (SPI0_FEATURE == ENABLED)
    435                  if (spi == SPI0)
   \                     Spi__Disable: (+1)
   \   00000000   0xB928             CBNZ.N   R0,??Spi__Disable_0
    436                  {
    437                      SPI_0->MCR |= SPI_MCR_HALT_MASK;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable13_6  ;; 0x4002c000
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    438                  }
    439              #endif
    440          }
   \                     ??Spi__Disable_0: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    441          
    442          //---------------------------------------------------------------------------------------------------------------------
    443          /**
    444           *    @brief    This method clears transmit and receive buffers of a specific Spi.
    445           *    @param    spi : specific spi device
    446           *    @image    html    Spi__Clear.jpg
    447           */

   \                                 In section .text, align 2, keep-with-next
    448          void Spi__Clear(SPI_ENUM_DEF spi)
    449          {
    450          	#if (SPI0_FEATURE == ENABLED)
    451          		if (spi == SPI0)
   \                     Spi__Clear: (+1)
   \   00000000   0xB940             CBNZ.N   R0,??Spi__Clear_0
    452          		{
    453          			Spi0_Tx_Write = 0;
    454          			Spi0_Tx_Read = 0;
    455          			Spi0_Busy=FALSE;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0xF880 0x1074      STRB     R1,[R0, #+116]
    456          
    457          			#if (SPI0_TX_RX_MODE == ENABLED)
    458          				Spi0_Rx_Write = 0;
   \   0000000C   0xF880 0x1075      STRB     R1,[R0, #+117]
    459          				Spi0_Rx_Read = 0;
   \   00000010   0xF880 0x1076      STRB     R1,[R0, #+118]
    460          			#endif
    461          
    462          			Spi0_Busy = FALSE;
    463          
    464          		}
    465          	#endif
    466          }
   \                     ??Spi__Clear_0: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    467          
    468          //---------------------------------------------------------------------------------------------------------------------
    469          /**
    470           *    @brief    This method writes data from "source" (buffer address mentioned by the Application)
    471           *              to the "destination" (Transmitter FIFO) as per the size mentioned to the specific Spi and also
    472           *              returns the response for the write operation.
    473           *    @details  The data in the Transmitter FIFO is sent to other Spi node through the specified Spi COM port
    474           *              whenever the Transmitter is free. Before writing into the Transmitter FIFO check for the
    475           *              FIFO availability using Spi__GetStatus() API to avoid the over writing on the existing data.
    476           *    @param    spi  : specific Spi device
    477           *    @param    buf  : source buffer from where the data to be sent
    478           *    @param    size : defines the amount of data to be sent
    479           *      @return   uint8
    480           *      @retval   True  : desired request is successfully executed
    481           *                False : desired request is not successfully executed
    482           *    @image    html    Spi__Write.jpg
    483           */

   \                                 In section .text, align 2, keep-with-next
    484          BOOL_TYPE Spi__Write(SPI_ENUM_DEF spi ,uint8 * buf ,uint16 size )
    485          {
   \                     Spi__Write: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    486              #if(SPI_DMA_FEATURE==ENABLED)
    487                  Spi0_Busy=TRUE;
   \   00000002   0x.... 0x....      LDR.W    R5,??DataTable13_1
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF885 0x0074      STRB     R0,[R5, #+116]
   \   0000000C   0xB081             SUB      SP,SP,#+4
   \   0000000E   0x4614             MOV      R4,R2
    488                  /* Start master transfer */
    489                  memcpy(Spi0_Tx_Buffer, buf, size);
   \   00000010   0xF105 0x007C      ADD      R0,R5,#+124
   \   00000014   0x.... 0x....      BL       __aeabi_memcpy
    490                  master_transfer.tx_data = Spi0_Tx_Buffer;
   \   00000018   0xF105 0x007C      ADD      R0,R5,#+124
   \   0000001C   0x6668             STR      R0,[R5, #+100]
   \   0000001E   0xF105 0x0264      ADD      R2,R5,#+100
    491                  master_transfer.rx_data = Spi0_Rx_Buffer;
   \   00000022   0xF105 0x00B0      ADD      R0,R5,#+176
   \   00000026   0x66A8             STR      R0,[R5, #+104]
    492                  master_transfer.data_size = size;
   \   00000028   0x66EC             STR      R4,[R5, #+108]
   \   0000002A   0xF105 0x01E4      ADD      R1,R5,#+228
    493                  Spi0_Rx_Write=master_transfer.data_size;
   \   0000002E   0x6EE8             LDR      R0,[R5, #+108]
   \   00000030   0xF885 0x0075      STRB     R0,[R5, #+117]
    494          
    495                  DspiMasterTransferEdma(DSPI_MASTER_BASEADDR, &Spi_Master_Dma_Handle, &master_transfer);
   \   00000034   0xB001             ADD      SP,SP,#+4
   \   00000036   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable13_6  ;; 0x4002c000
   \   0000003E   0x....             B.N      DspiMasterTransferEdma
    496              #endif
    497          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "Spi__Write"

  BOOL_TYPE Spi__Write(SPI_ENUM_DEF spi ,uint8 * buf ,uint16 size )
                                    ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Spi\Spi.c",484  Remark[Pe826]: 
          parameter "spi" was never referenced
    498          
    499          //---------------------------------------------------------------------------------------------------------------------
    500          /**
    501           *    @brief    This method reads data from "receive FIFO" and copies to the "address of the buffer" mentioned by the
    502           *              Application as per the size and also returns the response for the read operation.
    503           *    @details  Before reading the Receiver FIFO check for the
    504           *              data availability in the Receiver FIFO using Spi__GetStatus() API.
    505           *    @param    spi : specific spi device
    506           *    @param    buf : Indicates the buffers address where the read data is stored
    507           *    @param    size : defines the amount of data to be read
    508           *    @return   True(1)   : desired request is successfully executed
    509           *              False(0)  : desired request is not successfully executed
    510           *    @image    html    Spi__Read.jpg
    511           */

   \                                 In section .text, align 2, keep-with-next
    512          BOOL_TYPE Spi__Read(SPI_ENUM_DEF spi, uint8 * buf, uint16 size)
    513           {
   \                     Spi__Read: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4603             MOV      R3,R0
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x4614             MOV      R4,R2
    514          	BOOL_TYPE response;
    515          	response = FALSE;
   \   0000000A   0x2100             MOVS     R1,#+0
    516          
    517          	#if (SPI0_FEATURE == ENABLED)					//Read SPI0
    518          		if (spi == SPI0)
   \   0000000C   0xB99B             CBNZ.N   R3,??Spi__Read_0
    519          		{
    520          			if (size <= (Spi0_Rx_Write - Spi0_Rx_Read))
   \   0000000E   0x.... 0x....      LDR.W    R5,??DataTable13_1
   \   00000012   0xF895 0x3076      LDRB     R3,[R5, #+118]
   \   00000016   0xF895 0x2075      LDRB     R2,[R5, #+117]
   \   0000001A   0x1AD2             SUBS     R2,R2,R3
   \   0000001C   0x42A2             CMP      R2,R4
   \   0000001E   0xDB0A             BLT.N    ??Spi__Read_0
    521          			{
    522          				memcpy(buf, (Spi0_Rx_Buffer + Spi0_Rx_Read), size);
   \   00000020   0x1959             ADDS     R1,R3,R5
   \   00000022   0x4622             MOV      R2,R4
   \   00000024   0x31B0             ADDS     R1,R1,#+176
   \   00000026   0x.... 0x....      BL       __aeabi_memcpy
    523          
    524          				Spi0_Rx_Read = Spi0_Rx_Read + size;
   \   0000002A   0xF895 0x0076      LDRB     R0,[R5, #+118]
   \   0000002E   0x1820             ADDS     R0,R4,R0
   \   00000030   0xF885 0x0076      STRB     R0,[R5, #+118]
    525          
    526          				response = TRUE;
   \   00000034   0x2101             MOVS     R1,#+1
    527          			}
    528          
    529          		}
    530          	#endif
    531          
    532          		return (response);
   \                     ??Spi__Read_0: (+1)
   \   00000036   0x4608             MOV      R0,R1
   \   00000038   0xB001             ADD      SP,SP,#+4
   \   0000003A   0xBD30             POP      {R4,R5,PC}       ;; return
    533          
    534          }
    535          
    536          //---------------------------------------------------------------------------------------------------------------------
    537          /**
    538           *    @brief    This method gets the status of a specific SPI device.
    539           *    @details  This method is used to get status from specific SPI module.
    540           *    @param    spi : specific spi device
    541           *    @param    index : Index would be SPI_STATUS_STATE or SPI_STATUS_BUFFER_IN
    542           *    @return   For SPI_STATUS_STATE the return would be-
    543           *               SPI_STATE_BUSY  The Spi communication is going on
    544           *               SPI_STATE_IDLE  The Spi is ready to transfer the data
    545           *               SPI_STATE_ERROR  The Spi module encounter an error
    546           *               For SPI_STATUS_BUFFER_IN it returns the number of data bytes available to read
    547           */

   \                                 In section .text, align 2, keep-with-next
    548          uint16 Spi__GetStatus(SPI_ENUM_DEF spi, SPI_STATUS_DEF index)
    549          {
    550          	uint16 response;
    551          
    552              response = FALSE;
   \                     Spi__GetStatus: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    553          	#if (SPI0_FEATURE == ENABLED)
    554          		if(spi == SPI0)
   \   00000002   0xB968             CBNZ.N   R0,??Spi__GetStatus_0
    555          		{
    556          			if (index == SPI_STATUS_STATE)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000008   0xB929             CBNZ.N   R1,??Spi__GetStatus_1
    557          			{
    558          				if (Spi0_Busy == FALSE)
   \   0000000A   0xF890 0x0074      LDRB     R0,[R0, #+116]
   \   0000000E   0xB938             CBNZ.N   R0,??Spi__GetStatus_0
    559          				{
    560          					response = SPI_STATE_IDLE;
   \   00000010   0x2201             MOVS     R2,#+1
    561          				}
    562          				else
    563          				{
    564          					response = SPI_STATE_BUSY;
    565          				}
    566          			}
    567          			#if (SPI0_TX_RX_MODE == ENABLED)
    568          				else
    569          				{
    570          					response = Spi0_Rx_Write - Spi0_Rx_Read;
    571          				}
    572          			#endif
    573          		}
    574          
    575          	#endif
    576          
    577              return (response);
   \   00000012   0xB290             UXTH     R0,R2
   \   00000014   0x4770             BX       LR
   \                     ??Spi__GetStatus_1: (+1)
   \   00000016   0xF890 0x1075      LDRB     R1,[R0, #+117]
   \   0000001A   0xF890 0x0076      LDRB     R0,[R0, #+118]
   \   0000001E   0x1A0A             SUBS     R2,R1,R0
   \                     ??Spi__GetStatus_0: (+1)
   \   00000020   0xB290             UXTH     R0,R2
   \   00000022   0x4770             BX       LR               ;; return
    578          
    579          }
    580          
    581          //---------------------------------------------------------------------------------------------------------------------
    582          /**
    583           *  @brief      Reconfigure a specific Spi for a customised setting
    584           *
    585           *  @details    This function changes the configureation of a specific SPI and must called after the Spi has being initialzie
    586           *              Every time that the Spi is initialized it starts with the default parameters
    587           *
    588           *  @param      spi the specific spi device
    589           *  @param      pol defines the polarity of SCK signal
    590           *  @param      edge defines the the edge of action for the SCK line
    591           *  @param      order defines if the MSB bit goes first or the LSB bit goes first
    592           *  @image    html    Spi__SetConfiguration.jpg
    593           */

   \                                 In section .text, align 2, keep-with-next
    594          void Spi__SetConfiguration(SPI_ENUM_DEF spi, SPI_POLARITY_TYPE pol,SPI_EDGE_TYPE edge, SPI_ORDER_TYPE order)
                                                         ^
Remark[Pe826]: parameter "spi" was never referenced

  void Spi__SetConfiguration(SPI_ENUM_DEF spi, SPI_POLARITY_TYPE pol,SPI_EDGE_TYPE edge, SPI_ORDER_TYPE order)
                                                                 ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Spi\Spi.c",594  Remark[Pe826]: 
          parameter "pol" was never referenced

  void Spi__SetConfiguration(SPI_ENUM_DEF spi, SPI_POLARITY_TYPE pol,SPI_EDGE_TYPE edge, SPI_ORDER_TYPE order)
                                                                                   ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Spi\Spi.c",594  Remark[Pe826]: 
          parameter "edge" was never referenced

  void Spi__SetConfiguration(SPI_ENUM_DEF spi, SPI_POLARITY_TYPE pol,SPI_EDGE_TYPE edge, SPI_ORDER_TYPE order)
                                                                                                        ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Spi\Spi.c",594  Remark[Pe826]: 
          parameter "order" was never referenced
    595          {
    596          
    597          }
   \                     Spi__SetConfiguration: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    598          //=====================================================================================================================
    599          //-------------------------------------- Private Functions ------------------------------------------------------------
    600          //=====================================================================================================================
    601          
    602          //---------------------------------------------------------------------------------------------------------------------
    603          /**
    604           *  @brief      This API is used for SPI DMA Master communication
    605           *
    606           *  @details    This function  must be called to complete the SPI DMA configuration either for receiver and transmitter
    607           *
    608           *  @param      base     defines  the base address of device
    609           *  @param      handle   defines DSPI master eDMA transfer handle structure variable  used for the transactional API
    610           *  @param      transfer defines DSPI master/slave transfer structure
    611          */

   \                                 In section .text, align 2, keep-with-next
    612          void DspiMasterTransferEdma(SPI_TYPE *base, SPI_MASTER_DMA_HANDLE *handle, dspi_transfer *transfer)
    613          {
   \                     DspiMasterTransferEdma: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    614          
    615              word_to_send = 0;
   \   00000004   0xF04F 0x0C00      MOV      R12,#+0
    616              dummy_data = 0;
    617              rxAddr =(uint32)&(base->POPR);
    618              txAddr =(uint32)&(base->PUSHR);
    619              EDMA_TCD *software_tcd = ( EDMA_TCD*)((uint32)(&handle->dspi_software_tcd[1]) & (~0x1FU));
    620              handle->tx_buff_if_null = ((uint32)DSPI_DUMMY_DATA << 8) | DSPI_DUMMY_DATA;
   \   00000008   0xF8C1 0xC028      STR      R12,[R1, #+40]
    621              handle->state = DSPI_BUSY;
   \   0000000C   0x2501             MOVS     R5,#+1
   \   0000000E   0xF881 0x502C      STRB     R5,[R1, #+44]
   \   00000012   0xF101 0x0460      ADD      R4,R1,#+96
    622              base->MCR |= SPI_MCR_HALT_MASK;   //DSPI stop transfer
   \   00000016   0x6805             LDR      R5,[R0, #+0]
   \   00000018   0xF045 0x0501      ORR      R5,R5,#0x1
   \   0000001C   0x6005             STR      R5,[R0, #+0]
   \   0000001E   0x0964             LSRS     R4,R4,#+5
    623              base->MCR = (base->MCR & (~(SPI_MCR_CLR_TXF_MASK | SPI_MCR_CLR_RXF_MASK))) | SPI_MCR_CLR_TXF(TRUE) |
    624                          SPI_MCR_CLR_RXF(TRUE); //flush fifo
   \   00000020   0x6805             LDR      R5,[R0, #+0]
   \   00000022   0xF445 0x6540      ORR      R5,R5,#0xC00
   \   00000026   0x6005             STR      R5,[R0, #+0]
   \   00000028   0x0164             LSLS     R4,R4,#+5
    625              base->SR = SPI_SR_TCF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TFUF_MASK | SPI_SR_TFFF_MASK | SPI_SR_RFOF_MASK |SPI_SR_RFDF_MASK | SPI_SR_TXRXS_MASK;/*!< The status flags are cleared by writing 1 (w1c).*/
   \   0000002A   0x.... 0x....      LDR.W    R5,??DataTable13_8  ;; 0xda0a0000
   \   0000002E   0x62C5             STR      R5,[R0, #+44]
   \   00000030   0xF100 0x0638      ADD      R6,R0,#+56
    626              handle->command=(uint32)HANDLE_COMMAND;
   \   00000034   0x2504             MOVS     R5,#+4
   \   00000036   0x604D             STR      R5,[R1, #+4]
   \   00000038   0xF100 0x0334      ADD      R3,R0,#+52
    627              handle->last_command=(uint32)HANDLE_LAST_COMMAND;
   \   0000003C   0x2507             MOVS     R5,#+7
   \   0000003E   0x608D             STR      R5,[R1, #+8]
    628              handle->bits_per_frame = ((base->CTAR[DSPI_CTAR0] & SPI_CTAR_FMSZ_MASK) >> SPI_CTAR_FMSZ_SHIFT) + 1;
   \   00000040   0x68C5             LDR      R5,[R0, #+12]
   \   00000042   0xF3C5 0x65C3      UBFX     R5,R5,#+27,#+4
   \   00000046   0x1C6D             ADDS     R5,R5,#+1
   \   00000048   0x600D             STR      R5,[R1, #+0]
    629              if ((base->MCR & SPI_MCR_DIS_RXF_MASK) || (base->MCR & SPI_MCR_DIS_TXF_MASK))
   \   0000004A   0x6807             LDR      R7,[R0, #+0]
   \   0000004C   0x.... 0x....      LDR.W    R5,??DataTable13_6  ;; 0x4002c000
   \   00000050   0x04FF             LSLS     R7,R7,#+19
   \   00000052   0xD402             BMI.N    ??DspiMasterTransferEdma_0
   \   00000054   0x6807             LDR      R7,[R0, #+0]
   \   00000056   0x04BF             LSLS     R7,R7,#+18
   \   00000058   0xD502             BPL.N    ??DspiMasterTransferEdma_1
    630              {
    631                  handle->fifoSize = 1;
   \                     ??DspiMasterTransferEdma_0: (+1)
   \   0000005A   0x2701             MOVS     R7,#+1
   \   0000005C   0x730F             STRB     R7,[R1, #+12]
   \   0000005E   0xE00E             B.N      ??DspiMasterTransferEdma_2
    632              }
    633              else
    634              {
    635                  handle->fifoSize = FSL_FEATURE_DSPI_FIFO_SIZEn(base);
   \                     ??DspiMasterTransferEdma_1: (+1)
   \   00000060   0x42A8             CMP      R0,R5
   \   00000062   0xBF08             IT       EQ 
   \   00000064   0xF04F 0x0E04      MOVEQ    LR,#+4
   \   00000068   0xD007             BEQ.N    ??DspiMasterTransferEdma_3
   \   0000006A   0x.... 0x....      LDR.W    R7,??DataTable13_9  ;; 0x4002d000
   \   0000006E   0x42B8             CMP      R0,R7
   \   00000070   0xBF0C             ITE      EQ 
   \   00000072   0xF04F 0x0E01      MOVEQ    LR,#+1
   \   00000076   0xF04F 0x0EFF      MOVNE    LR,#+255
   \                     ??DspiMasterTransferEdma_3: (+1)
   \   0000007A   0xF881 0xE00C      STRB     LR,[R1, #+12]
    636              }
    637              handle->tx_data = transfer->tx_data;
   \                     ??DspiMasterTransferEdma_2: (+1)
   \   0000007E   0x6817             LDR      R7,[R2, #+0]
   \   00000080   0x610F             STR      R7,[R1, #+16]
    638              handle->rx_data = transfer->rx_data;
   \   00000082   0x6857             LDR      R7,[R2, #+4]
   \   00000084   0x614F             STR      R7,[R1, #+20]
    639              handle->remaining_send_byte_count = transfer->data_size;
   \   00000086   0x6897             LDR      R7,[R2, #+8]
   \   00000088   0x618F             STR      R7,[R1, #+24]
    640              handle->remaining_receive_byte_count = transfer->data_size;
   \   0000008A   0x6897             LDR      R7,[R2, #+8]
   \   0000008C   0x61CF             STR      R7,[R1, #+28]
    641              handle->total_byte_count = transfer->data_size;
   \   0000008E   0x6892             LDR      R2,[R2, #+8]
    642              base->RSER &= ~((SPI_RSER_TFFF_RE_MASK | SPI_RSER_TFFF_DIRS_MASK)| (SPI_RSER_RFDF_RE_MASK | SPI_RSER_RFDF_DIRS_MASK));
   \   00000090   0x.... 0x....      LDR.W    R7,??DataTable13_10  ;; 0xfcfcffff
   \   00000094   0x620A             STR      R2,[R1, #+32]
   \   00000096   0x6B02             LDR      R2,[R0, #+48]
   \   00000098   0x403A             ANDS     R2,R7,R2
   \   0000009A   0x6302             STR      R2,[R0, #+48]
    643              handle->is_there_extra_byte = FALSE;
   \   0000009C   0xF881 0xC00E      STRB     R12,[R1, #+14]
    644              #if (SPI0_FEATURE == ENABLED)
    645                  if (handle->bits_per_frame > 8)
   \   000000A0   0x680A             LDR      R2,[R1, #+0]
   \   000000A2   0x2A09             CMP      R2,#+9
   \   000000A4   0xD31C             BCC.N    ??DspiMasterTransferEdma_4
    646                  {
    647                      /* If it's the last word */
    648                      if (handle->remaining_send_byte_count <= 2)
   \   000000A6   0x698A             LDR      R2,[R1, #+24]
   \   000000A8   0x2A03             CMP      R2,#+3
   \   000000AA   0x690A             LDR      R2,[R1, #+16]
   \   000000AC   0xD20A             BCS.N    ??DspiMasterTransferEdma_5
    649                      {
    650                          if (handle->tx_data)
   \   000000AE   0xB312             CBZ.N    R2,??DspiMasterTransferEdma_6
    651                          {
    652                              if (handle->is_there_extra_byte)
    653                              {
    654                                  word_to_send = *(handle->tx_data) | ((uint32) dummy_data << 8);
    655                              }
    656                              else
    657                              {
    658                                  word_to_send = *(handle->tx_data);
   \   000000B0   0x690A             LDR      R2,[R1, #+16]
   \   000000B2   0x7812             LDRB     R2,[R2, #+0]
    659                                  ++handle->tx_data; /* increment to next data byte */
   \   000000B4   0x690F             LDR      R7,[R1, #+16]
   \   000000B6   0x1C7F             ADDS     R7,R7,#+1
   \   000000B8   0x610F             STR      R7,[R1, #+16]
    660                                  word_to_send |= (unsigned) (*(handle->tx_data)) << 8U;
   \   000000BA   0x690F             LDR      R7,[R1, #+16]
   \   000000BC   0x783F             LDRB     R7,[R7, #+0]
   \   000000BE   0xEA42 0x2C07      ORR      R12,R2,R7, LSL #+8
    661                              }
    662                          }
    663                          else
    664                          {
    665                              word_to_send = ((uint32) dummy_data << 8) | dummy_data;
    666                          }
    667                          handle->last_command = (handle->last_command & 0xffff0000U) | word_to_send;
   \   000000C2   0xE018             B.N      ??DspiMasterTransferEdma_6
    668                      }
    669                      else /* For all words except the last word , frame > 8bits */
    670                      {
    671                          if (handle->tx_data)
   \                     ??DspiMasterTransferEdma_5: (+1)
   \   000000C4   0xB1EA             CBZ.N    R2,??DspiMasterTransferEdma_7
    672                          {
    673                              word_to_send = *(handle->tx_data);
   \   000000C6   0x690A             LDR      R2,[R1, #+16]
   \   000000C8   0x7812             LDRB     R2,[R2, #+0]
    674                              ++handle->tx_data; /* increment to next data byte */
   \   000000CA   0x690F             LDR      R7,[R1, #+16]
   \   000000CC   0x1C7F             ADDS     R7,R7,#+1
   \   000000CE   0x610F             STR      R7,[R1, #+16]
    675                              word_to_send |= (unsigned) (*(handle->tx_data)) << 8U;
   \   000000D0   0x690F             LDR      R7,[R1, #+16]
   \   000000D2   0x783F             LDRB     R7,[R7, #+0]
   \   000000D4   0xEA42 0x2C07      ORR      R12,R2,R7, LSL #+8
    676                              ++handle->tx_data; /* increment to next data byte */
   \   000000D8   0x690A             LDR      R2,[R1, #+16]
   \   000000DA   0x1C52             ADDS     R2,R2,#+1
   \   000000DC   0x610A             STR      R2,[R1, #+16]
    677                          }
    678                          else
    679                          {
    680                              word_to_send = ((uint32) dummy_data << 8) | dummy_data;
    681                          }
    682                          handle->command = (handle->command & 0xffff0000U) | word_to_send;
   \   000000DE   0xE010             B.N      ??DspiMasterTransferEdma_7
    683                      }
    684                  }
    685                  else /* Optimized for bits/frame less than or equal to one byte. */
    686                  {
    687                      if (handle->tx_data)
   \                     ??DspiMasterTransferEdma_4: (+1)
   \   000000E0   0x690A             LDR      R2,[R1, #+16]
   \   000000E2   0xB12A             CBZ.N    R2,??DspiMasterTransferEdma_8
    688                      {
    689                          word_to_send = *(handle->tx_data);
   \   000000E4   0x690A             LDR      R2,[R1, #+16]
   \   000000E6   0xF892 0xC000      LDRB     R12,[R2, #+0]
    690                          ++handle->tx_data; /* increment to next data word*/
   \   000000EA   0x690A             LDR      R2,[R1, #+16]
   \   000000EC   0x1C52             ADDS     R2,R2,#+1
   \   000000EE   0x610A             STR      R2,[R1, #+16]
    691                      }
    692                      else
    693                      {
    694                          word_to_send = dummy_data;
    695                      }
    696          
    697                      if (handle->remaining_send_byte_count == 1)
   \                     ??DspiMasterTransferEdma_8: (+1)
   \   000000F0   0x698A             LDR      R2,[R1, #+24]
   \   000000F2   0x2A01             CMP      R2,#+1
   \   000000F4   0xD105             BNE.N    ??DspiMasterTransferEdma_7
    698                      {
    699                          handle->last_command = (handle->last_command & 0xffff0000U) | word_to_send;
   \                     ??DspiMasterTransferEdma_6: (+1)
   \   000000F6   0x688A             LDR      R2,[R1, #+8]
   \   000000F8   0x0C12             LSRS     R2,R2,#+16
   \   000000FA   0xEA4C 0x4202      ORR      R2,R12,R2, LSL #+16
   \   000000FE   0x608A             STR      R2,[R1, #+8]
   \   00000100   0xE004             B.N      ??DspiMasterTransferEdma_9
    700                      }
    701                      else
    702                      {
    703                          handle->command = (handle->command & 0xffff0000U) | word_to_send;
   \                     ??DspiMasterTransferEdma_7: (+1)
   \   00000102   0x684A             LDR      R2,[R1, #+4]
   \   00000104   0x0C12             LSRS     R2,R2,#+16
   \   00000106   0xEA4C 0x4202      ORR      R2,R12,R2, LSL #+16
   \   0000010A   0x604A             STR      R2,[R1, #+4]
    704                      }
    705                  }
    706              #endif
    707              DspiDisable(DMA_ENGINE1, DMA_CH0);
   \                     ??DspiMasterTransferEdma_9: (+1)
   \   0000010C   0x2700             MOVS     R7,#+0
   \   0000010E   0x.... 0x....      LDR.W    R2,??DataTable13_11  ;; 0x4000801b
   \   00000112   0x.... 0x....      LDR.W    R12,??DataTable13_12  ;; 0x4000901c
   \   00000116   0x.... 0x....      LDR.W    LR,??DataTable13_1
   \   0000011A   0xF8C2 0x7FE5      STR      R7,[R2, #+4069]
   \   0000011E   0xF8A2 0x7FE9      STRH     R7,[R2, #+4073]
   \   00000122   0xF8A2 0x7FEB      STRH     R7,[R2, #+4075]
   \   00000126   0xF8C2 0x7FED      STR      R7,[R2, #+4077]
   \   0000012A   0xF8C2 0x7FF1      STR      R7,[R2, #+4081]
   \   0000012E   0xF8C2 0x7FF5      STR      R7,[R2, #+4085]
   \   00000132   0xF8A2 0x7FF9      STRH     R7,[R2, #+4089]
   \   00000136   0xF8A2 0x7FFB      STRH     R7,[R2, #+4091]
   \   0000013A   0xF8C2 0x7FFD      STR      R7,[R2, #+4093]
   \   0000013E   0x2708             MOVS     R7,#+8
   \   00000140   0xF8AC 0x7000      STRH     R7,[R12, #+0]
   \   00000144   0x2700             MOVS     R7,#+0
   \   00000146   0xF8AC 0x7002      STRH     R7,[R12, #+2]
    708              transfer_config_a.src_addr = (uint32) rxAddr;
    709              transfer_config_a.source_offset = 0;
   \   0000014A   0xF8AE 0x7026      STRH     R7,[LR, #+38]
   \   0000014E   0xF8CE 0x601C      STR      R6,[LR, #+28]
    710          
    711              if (handle->rx_data)
   \   00000152   0x694F             LDR      R7,[R1, #+20]
   \   00000154   0x2F00             CMP      R7,#+0
   \   00000156   0xBF19             ITTEE    NE 
    712              {
    713                  transfer_config_a.dest_addr = (uint32) &(handle->rx_data[0]);
   \   00000158   0x694F             LDRNE    R7,[R1, #+20]
    714                  transfer_config_a.dest_offset = 1;
   \   0000015A   0xF04F 0x0801      MOVNE    R8,#+1
    715              }
    716              else
    717              {
    718                  transfer_config_a.dest_addr = (uint32) &(handle->rx_buff_If_null);
   \   0000015E   0xF101 0x0724      ADDEQ    R7,R1,#+36
    719                  transfer_config_a.dest_offset = 0;
   \   00000162   0xF04F 0x0800      MOVEQ    R8,#+0
   \   00000166   0xF8CE 0x7020      STR      R7,[LR, #+32]
   \   0000016A   0xF8AE 0x8028      STRH     R8,[LR, #+40]
    720              }
    721          
    722              transfer_config_a.dest_transfer_size = DMA_TRANSFER_SIZE_ONE_BYTE;
   \   0000016E   0x2700             MOVS     R7,#+0
   \   00000170   0xF88E 0x7025      STRB     R7,[LR, #+37]
    723          
    724              if (handle->bits_per_frame <= 8)
   \   00000174   0x680F             LDR      R7,[R1, #+0]
   \   00000176   0x2F09             CMP      R7,#+9
   \   00000178   0xD207             BCS.N    ??DspiMasterTransferEdma_10
    725              {
    726                  transfer_config_a.source_transfer_size = DMA_TRANSFER_SIZE_ONE_BYTE;
   \   0000017A   0x2700             MOVS     R7,#+0
   \   0000017C   0xF88E 0x7024      STRB     R7,[LR, #+36]
    727                  transfer_config_a.minor_loop_bytes = 1;
   \   00000180   0x2701             MOVS     R7,#+1
   \   00000182   0xF8CE 0x702C      STR      R7,[LR, #+44]
    728                  transfer_config_a.major_loop_counts = handle->remaining_receive_byte_count;
   \   00000186   0x69CF             LDR      R7,[R1, #+28]
   \   00000188   0xE007             B.N      ??DspiMasterTransferEdma_11
    729              }
    730              else
    731              {
    732                  transfer_config_a.source_transfer_size = DMA_TRANSFER_SIZE_TWO_BYTE;
   \                     ??DspiMasterTransferEdma_10: (+1)
   \   0000018A   0x2701             MOVS     R7,#+1
   \   0000018C   0xF88E 0x7024      STRB     R7,[LR, #+36]
    733                  transfer_config_a.minor_loop_bytes = 2;
   \   00000190   0x2702             MOVS     R7,#+2
   \   00000192   0xF8CE 0x702C      STR      R7,[LR, #+44]
    734                  transfer_config_a.major_loop_counts = handle->remaining_receive_byte_count / 2;
   \   00000196   0x69CF             LDR      R7,[R1, #+28]
   \   00000198   0x087F             LSRS     R7,R7,#+1
   \                     ??DspiMasterTransferEdma_11: (+1)
   \   0000019A   0xF8CE 0x7030      STR      R7,[LR, #+48]
    735              }
    736               DspiSetConfig(DMA_ENGINE1,DMA_CH0,&transfer_config_a,(EDMA_TCD *)NULL);
   \   0000019E   0xF8C2 0x6FE5      STR      R6,[R2, #+4069]
   \   000001A2   0xF8DE 0x6020      LDR      R6,[LR, #+32]
   \   000001A6   0xF8C2 0x6FF5      STR      R6,[R2, #+4085]
   \   000001AA   0xF89E 0x6024      LDRB     R6,[LR, #+36]
   \   000001AE   0xF89E 0x7025      LDRB     R7,[LR, #+37]
   \   000001B2   0x0236             LSLS     R6,R6,#+8
   \   000001B4   0xF406 0x66E0      AND      R6,R6,#0x700
   \   000001B8   0xF007 0x0707      AND      R7,R7,#0x7
   \   000001BC   0x433E             ORRS     R6,R7,R6
   \   000001BE   0xF8A2 0x6FEB      STRH     R6,[R2, #+4075]
   \   000001C2   0xF8BE 0x6026      LDRH     R6,[LR, #+38]
   \   000001C6   0xF8A2 0x6FE9      STRH     R6,[R2, #+4073]
   \   000001CA   0xF8BE 0x6028      LDRH     R6,[LR, #+40]
   \   000001CE   0xF8A2 0x6FF9      STRH     R6,[R2, #+4089]
   \   000001D2   0xF8DE 0x602C      LDR      R6,[LR, #+44]
   \   000001D6   0xF8C2 0x6FED      STR      R6,[R2, #+4077]
   \   000001DA   0xF8DE 0x6030      LDR      R6,[LR, #+48]
   \   000001DE   0xF8A2 0x6FFB      STRH     R6,[R2, #+4091]
   \   000001E2   0xF8DE 0x6030      LDR      R6,[LR, #+48]
   \   000001E6   0xF8AC 0x6002      STRH     R6,[R12, #+2]
    737               DspiDisable(DMA_ENGINE1, DMA_CH1);
   \   000001EA   0x2600             MOVS     R6,#+0
   \   000001EC   0xF8CC 0x6004      STR      R6,[R12, #+4]
   \   000001F0   0xF8AC 0x6008      STRH     R6,[R12, #+8]
   \   000001F4   0xF8AC 0x600A      STRH     R6,[R12, #+10]
   \   000001F8   0xF8CC 0x600C      STR      R6,[R12, #+12]
   \   000001FC   0xF8CC 0x6010      STR      R6,[R12, #+16]
   \   00000200   0xF8CC 0x6014      STR      R6,[R12, #+20]
   \   00000204   0xF8AC 0x6018      STRH     R6,[R12, #+24]
   \   00000208   0xF8AC 0x601A      STRH     R6,[R12, #+26]
   \   0000020C   0xF8CC 0x601C      STR      R6,[R12, #+28]
   \   00000210   0x2608             MOVS     R6,#+8
   \   00000212   0xF8AC 0x6020      STRH     R6,[R12, #+32]
   \   00000216   0x2600             MOVS     R6,#+0
   \   00000218   0xF8AC 0x6022      STRH     R6,[R12, #+34]
    738          
    739              if (handle->remaining_send_byte_count > 0)
   \   0000021C   0x698E             LDR      R6,[R1, #+24]
   \   0000021E   0x2E00             CMP      R6,#+0
   \   00000220   0xD059             BEQ.N    ??DspiMasterTransferEdma_12
    740              {
    741                  if (handle->tx_data)
   \   00000222   0x690E             LDR      R6,[R1, #+16]
   \   00000224   0x2E00             CMP      R6,#+0
   \   00000226   0xBF19             ITTEE    NE 
    742                  {
    743                      transfer_config_b.src_addr = (uint32) (handle->tx_data);
   \   00000228   0x690E             LDRNE    R6,[R1, #+16]
    744                      transfer_config_b.source_offset = 1;
   \   0000022A   0x2701             MOVNE    R7,#+1
    745                  }
    746                  else
    747                  {
    748                      transfer_config_b.src_addr = (uint32) (&handle->tx_buff_if_null);
   \   0000022C   0xF101 0x0628      ADDEQ    R6,R1,#+40
    749                      transfer_config_b.source_offset = 0;
   \   00000230   0x2700             MOVEQ    R7,#+0
   \   00000232   0xF8CE 0x6034      STR      R6,[LR, #+52]
   \   00000236   0xF8AE 0x703E      STRH     R7,[LR, #+62]
    750                  }
    751          
    752                  transfer_config_b.dest_addr = (uint32) (&handle->command);
   \   0000023A   0x1D0E             ADDS     R6,R1,#+4
   \   0000023C   0xF8CE 0x6038      STR      R6,[LR, #+56]
    753                  transfer_config_b.dest_offset = 0;
   \   00000240   0x2600             MOVS     R6,#+0
   \   00000242   0xF8AE 0x6040      STRH     R6,[LR, #+64]
    754          
    755                  transfer_config_b.source_transfer_size = DMA_TRANSFER_SIZE_ONE_BYTE;
   \   00000246   0xF88E 0x603C      STRB     R6,[LR, #+60]
    756          
    757                  if (handle->bits_per_frame <= 8)
   \   0000024A   0x680E             LDR      R6,[R1, #+0]
   \   0000024C   0x2E09             CMP      R6,#+9
   \   0000024E   0xD20A             BCS.N    ??DspiMasterTransferEdma_13
    758                  {
    759                      transfer_config_b.dest_transfer_size = DMA_TRANSFER_SIZE_ONE_BYTE;
   \   00000250   0x2600             MOVS     R6,#+0
   \   00000252   0xF88E 0x603D      STRB     R6,[LR, #+61]
    760                      transfer_config_b.minor_loop_bytes = 1;
   \   00000256   0x2601             MOVS     R6,#+1
   \   00000258   0xF8CE 0x6044      STR      R6,[LR, #+68]
    761          
    762                      if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
   \   0000025C   0x42A8             CMP      R0,R5
   \   0000025E   0x698E             LDR      R6,[R1, #+24]
   \   00000260   0xD10E             BNE.N    ??DspiMasterTransferEdma_14
    763                      {
    764                          /*already prepared the first data in "intermediary" , so minus 1 */
    765                          transfer_config_b.major_loop_counts = handle->remaining_send_byte_count - 1;
   \   00000262   0x1E76             SUBS     R6,R6,#+1
   \   00000264   0xE00D             B.N      ??DspiMasterTransferEdma_15
    766                      }
    767                      else
    768                      {
    769                          /*Only enable channel_B minorlink to channel_C , so need to add one count due to the last time is
    770                           majorlink , the majorlink would not trigger the channel_C*/
    771                          transfer_config_b.major_loop_counts = handle->remaining_send_byte_count + 1;
    772                      }
    773                  }
    774                  else
    775                  {
    776                      transfer_config_b.dest_transfer_size = DMA_TRANSFER_SIZE_TWO_BYTE;
   \                     ??DspiMasterTransferEdma_13: (+1)
   \   00000266   0x2601             MOVS     R6,#+1
   \   00000268   0xF88E 0x603D      STRB     R6,[LR, #+61]
    777                      transfer_config_b.minor_loop_bytes = 2;
   \   0000026C   0x2602             MOVS     R6,#+2
   \   0000026E   0xF8CE 0x6044      STR      R6,[LR, #+68]
    778                      if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
   \   00000272   0x42A8             CMP      R0,R5
   \   00000274   0x698E             LDR      R6,[R1, #+24]
   \   00000276   0xD102             BNE.N    ??DspiMasterTransferEdma_16
    779                      {
    780                          /*already prepared the first data in "intermediary" , so minus 1 */
    781                          transfer_config_b.major_loop_counts = handle->remaining_send_byte_count / 2 - 1;
   \   00000278   0x0876             LSRS     R6,R6,#+1
   \   0000027A   0x1E76             SUBS     R6,R6,#+1
   \   0000027C   0xE001             B.N      ??DspiMasterTransferEdma_15
    782                      }
    783                      else
    784                      {
    785                          /*Only enable channel_B minorlink to channel_C , so need to add one count due to the last time is
    786                           * majorlink*/
    787                          transfer_config_b.major_loop_counts = handle->remaining_send_byte_count / 2 + 1;
   \                     ??DspiMasterTransferEdma_16: (+1)
   \   0000027E   0x0876             LSRS     R6,R6,#+1
   \                     ??DspiMasterTransferEdma_14: (+1)
   \   00000280   0x1C76             ADDS     R6,R6,#+1
   \                     ??DspiMasterTransferEdma_15: (+1)
   \   00000282   0xF8CE 0x6048      STR      R6,[LR, #+72]
    788                      }
    789                  }
    790          
    791                  DspiSetConfig(DMA_ENGINE1, DMA_CH1, &transfer_config_b, NULL);
   \   00000286   0xF8DE 0x6034      LDR      R6,[LR, #+52]
   \   0000028A   0xF8CC 0x6004      STR      R6,[R12, #+4]
   \   0000028E   0xF8DE 0x6038      LDR      R6,[LR, #+56]
   \   00000292   0xF8CC 0x6014      STR      R6,[R12, #+20]
   \   00000296   0xF89E 0x603C      LDRB     R6,[LR, #+60]
   \   0000029A   0xF89E 0x703D      LDRB     R7,[LR, #+61]
   \   0000029E   0x0236             LSLS     R6,R6,#+8
   \   000002A0   0xF406 0x66E0      AND      R6,R6,#0x700
   \   000002A4   0xF007 0x0707      AND      R7,R7,#0x7
   \   000002A8   0x433E             ORRS     R6,R7,R6
   \   000002AA   0xF8AC 0x600A      STRH     R6,[R12, #+10]
   \   000002AE   0xF8BE 0x603E      LDRH     R6,[LR, #+62]
   \   000002B2   0xF8AC 0x6008      STRH     R6,[R12, #+8]
   \   000002B6   0xF8BE 0x6040      LDRH     R6,[LR, #+64]
   \   000002BA   0xF8AC 0x6018      STRH     R6,[R12, #+24]
   \   000002BE   0xF8DE 0x6044      LDR      R6,[LR, #+68]
   \   000002C2   0xF8CC 0x600C      STR      R6,[R12, #+12]
   \   000002C6   0xF8DE 0x6048      LDR      R6,[LR, #+72]
   \   000002CA   0xF8AC 0x601A      STRH     R6,[R12, #+26]
   \   000002CE   0xF8DE 0x6048      LDR      R6,[LR, #+72]
   \   000002D2   0xF8AC 0x6022      STRH     R6,[R12, #+34]
    792              }
    793          
    794              /***channel_C ***carry the "intermediary" to SPIx_PUSHR. used the edma Scatter Gather function on channel_C to
    795               handle the last data */
    796              DspiDisable(DMA_ENGINE1, DMA_CH2);
   \                     ??DspiMasterTransferEdma_12: (+1)
   \   000002D6   0x2600             MOVS     R6,#+0
   \   000002D8   0xF8CC 0x6024      STR      R6,[R12, #+36]
   \   000002DC   0xF8AC 0x6028      STRH     R6,[R12, #+40]
   \   000002E0   0xF8AC 0x602A      STRH     R6,[R12, #+42]
   \   000002E4   0xF8CC 0x602C      STR      R6,[R12, #+44]
   \   000002E8   0xF8CC 0x6030      STR      R6,[R12, #+48]
   \   000002EC   0xF8CC 0x6034      STR      R6,[R12, #+52]
   \   000002F0   0xF8AC 0x6038      STRH     R6,[R12, #+56]
   \   000002F4   0xF8AC 0x603A      STRH     R6,[R12, #+58]
   \   000002F8   0xF8CC 0x603C      STR      R6,[R12, #+60]
   \   000002FC   0x2608             MOVS     R6,#+8
   \   000002FE   0xF8AC 0x6040      STRH     R6,[R12, #+64]
   \   00000302   0x2600             MOVS     R6,#+0
   \   00000304   0xF8AC 0x6042      STRH     R6,[R12, #+66]
    797          
    798              if (((handle->remaining_send_byte_count > 0) && (1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base)))
    799               || ((((handle->remaining_send_byte_count > 1) && (handle->bits_per_frame <= 8))
    800               || ((handle->remaining_send_byte_count > 2) && (handle->bits_per_frame > 8)))
    801               && (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))))
   \   00000308   0x698E             LDR      R6,[R1, #+24]
   \   0000030A   0x2E00             CMP      R6,#+0
   \   0000030C   0xBF18             IT       NE 
   \   0000030E   0x42A8             CMPNE    R0,R5
   \   00000310   0xD10D             BNE.N    ??DspiMasterTransferEdma_17
   \   00000312   0x698E             LDR      R6,[R1, #+24]
   \   00000314   0x2E02             CMP      R6,#+2
   \   00000316   0xD302             BCC.N    ??DspiMasterTransferEdma_18
   \   00000318   0x680E             LDR      R6,[R1, #+0]
   \   0000031A   0x2E09             CMP      R6,#+9
   \   0000031C   0xD305             BCC.N    ??DspiMasterTransferEdma_19
   \                     ??DspiMasterTransferEdma_18: (+1)
   \   0000031E   0x698E             LDR      R6,[R1, #+24]
   \   00000320   0x2E03             CMP      R6,#+3
   \   00000322   0xBF24             ITT      CS 
   \   00000324   0x680E             LDRCS    R6,[R1, #+0]
   \   00000326   0x2E09             CMPCS    R6,#+9
   \   00000328   0xD33D             BCC.N    ??DspiMasterTransferEdma_20
   \                     ??DspiMasterTransferEdma_19: (+1)
   \   0000032A   0x42A8             CMP      R0,R5
   \   0000032C   0xD13B             BNE.N    ??DspiMasterTransferEdma_20
    802              {
    803                  if (handle->tx_data)
   \                     ??DspiMasterTransferEdma_17: (+1)
   \   0000032E   0x690E             LDR      R6,[R1, #+16]
   \   00000330   0xB39E             CBZ.N    R6,??DspiMasterTransferEdma_21
    804                  {
    805                      uint32 bufferIndex = 0;
    806          
    807                      if (1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
   \   00000332   0x42A8             CMP      R0,R5
   \   00000334   0xD113             BNE.N    ??DspiMasterTransferEdma_22
    808                      {
    809                          if (handle->bits_per_frame <= 8)
   \   00000336   0x680E             LDR      R6,[R1, #+0]
   \   00000338   0x2E09             CMP      R6,#+9
   \   0000033A   0x698E             LDR      R6,[R1, #+24]
   \   0000033C   0xBF38             IT       CC 
    810                          {
    811                              bufferIndex = handle->remaining_send_byte_count - 1;
   \   0000033E   0x1E76             SUBCC    R6,R6,#+1
   \   00000340   0xD311             BCC.N    ??DspiMasterTransferEdma_23
    812                          }
    813                          else
    814                          {
    815                              bufferIndex = handle->remaining_send_byte_count - 2;
   \   00000342   0x1EB6             SUBS     R6,R6,#+2
    816                          }
    817                      }
    818                      else
    819                      {
    820                          bufferIndex = handle->remaining_send_byte_count;
    821                      }
    822          
    823                      if (handle->bits_per_frame <= 8)
    824                      {
    825                          handle->last_command = (handle->last_command & 0xffff0000U) | handle->tx_data[bufferIndex - 1];
    826                      }
    827                      else
    828                      {
    829                          if (handle->is_there_extra_byte)
   \                     ??DspiMasterTransferEdma_24: (+1)
   \   00000344   0x7B8F             LDRB     R7,[R1, #+14]
   \   00000346   0x2F00             CMP      R7,#+0
   \   00000348   0x688F             LDR      R7,[R1, #+8]
   \   0000034A   0xD016             BEQ.N    ??DspiMasterTransferEdma_25
    830                          {
    831                              handle->last_command = (handle->last_command & 0xffff0000U) | handle->tx_data[bufferIndex - 2]
    832                              | ((uint32) dummy_data << 8);
   \   0000034C   0xF8D1 0x8010      LDR      R8,[R1, #+16]
   \   00000350   0x4446             ADD      R6,R6,R8
   \   00000352   0x0C3F             LSRS     R7,R7,#+16
   \   00000354   0xF816 0x6C02      LDRB     R6,[R6, #-2]
   \   00000358   0xEA46 0x4607      ORR      R6,R6,R7, LSL #+16
   \   0000035C   0xE022             B.N      ??DspiMasterTransferEdma_26
    833                          }
   \                     ??DspiMasterTransferEdma_22: (+1)
   \   0000035E   0x698E             LDR      R6,[R1, #+24]
   \   00000360   0x680F             LDR      R7,[R1, #+0]
   \   00000362   0x2F09             CMP      R7,#+9
   \   00000364   0xD2EE             BCS.N    ??DspiMasterTransferEdma_24
   \                     ??DspiMasterTransferEdma_23: (+1)
   \   00000366   0x688F             LDR      R7,[R1, #+8]
   \   00000368   0xF8D1 0x8010      LDR      R8,[R1, #+16]
   \   0000036C   0x4446             ADD      R6,R6,R8
   \   0000036E   0x0C3F             LSRS     R7,R7,#+16
   \   00000370   0xF816 0x6C01      LDRB     R6,[R6, #-1]
   \   00000374   0xEA46 0x4607      ORR      R6,R6,R7, LSL #+16
   \   00000378   0xE014             B.N      ??DspiMasterTransferEdma_26
    834                          else
    835                          {
    836                              handle->last_command = (handle->last_command & 0xffff0000U)
    837                              | ((uint32) handle->tx_data[bufferIndex - 1] << 8) | handle->tx_data[bufferIndex - 2];
   \                     ??DspiMasterTransferEdma_25: (+1)
   \   0000037A   0xF8D1 0x8010      LDR      R8,[R1, #+16]
   \   0000037E   0x44B0             ADD      R8,R6,R8
   \   00000380   0x0C3F             LSRS     R7,R7,#+16
   \   00000382   0xF818 0x8C01      LDRB     R8,[R8, #-1]
   \   00000386   0x043F             LSLS     R7,R7,#+16
   \   00000388   0xEA47 0x2708      ORR      R7,R7,R8, LSL #+8
   \   0000038C   0xF8D1 0x8010      LDR      R8,[R1, #+16]
   \   00000390   0x4446             ADD      R6,R6,R8
   \   00000392   0xF816 0x6C02      LDRB     R6,[R6, #-2]
   \   00000396   0x433E             ORRS     R6,R6,R7
   \   00000398   0xE004             B.N      ??DspiMasterTransferEdma_26
    838                          }
    839                      }
    840                  }
   \                     ??DspiMasterTransferEdma_21: (+1)
   \   0000039A   0xF8AE 0x6078      STRH     R6,[LR, #+120]
    841                  else
    842                  {
    843                      if (handle->bits_per_frame <= 8)
    844                      {
    845                          word_to_send = dummy_data;
    846                      }
    847                      else
    848                      {
    849                          word_to_send = ((uint32) dummy_data << 8) | dummy_data;
    850                      }
    851                      handle->last_command = (handle->last_command & 0xffff0000U) | word_to_send;
   \   0000039E   0x688E             LDR      R6,[R1, #+8]
   \   000003A0   0x0C36             LSRS     R6,R6,#+16
   \   000003A2   0x0436             LSLS     R6,R6,#+16
   \                     ??DspiMasterTransferEdma_26: (+1)
   \   000003A4   0x608E             STR      R6,[R1, #+8]
    852                  }
    853              }
    854              if ((1 == FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base))
    855               || ((1 != FSL_FEATURE_DSPI_HAS_SEPARATE_DMA_RX_TX_REQn(base)) && (handle->remaining_send_byte_count > 0)))
   \                     ??DspiMasterTransferEdma_20: (+1)
   \   000003A6   0x42A8             CMP      R0,R5
   \   000003A8   0xD002             BEQ.N    ??DspiMasterTransferEdma_27
   \   000003AA   0x698D             LDR      R5,[R1, #+24]
   \   000003AC   0x2D00             CMP      R5,#+0
   \   000003AE   0xD043             BEQ.N    ??DspiMasterTransferEdma_28
    856              {
    857                  transfer_config_c.src_addr = (uint32) &(handle->last_command);
   \                     ??DspiMasterTransferEdma_27: (+1)
   \   000003B0   0xF101 0x0508      ADD      R5,R1,#+8
   \   000003B4   0xF8CE 0x504C      STR      R5,[LR, #+76]
    858                  transfer_config_c.dest_addr = (uint32) txAddr;
   \   000003B8   0xF8CE 0x3050      STR      R3,[LR, #+80]
    859                  transfer_config_c.source_transfer_size = DMA_TRANSFER_SIZE_FOUR_BYTE;
   \   000003BC   0x2502             MOVS     R5,#+2
   \   000003BE   0xF88E 0x5054      STRB     R5,[LR, #+84]
    860                  transfer_config_c.dest_transfer_size = DMA_TRANSFER_SIZE_FOUR_BYTE;
   \   000003C2   0xF88E 0x5055      STRB     R5,[LR, #+85]
    861                  transfer_config_c.source_offset = 0;
   \   000003C6   0x2500             MOVS     R5,#+0
   \   000003C8   0xF8AE 0x5056      STRH     R5,[LR, #+86]
    862                  transfer_config_c.dest_offset = 0;
   \   000003CC   0xF8AE 0x5058      STRH     R5,[LR, #+88]
    863                  transfer_config_c.minor_loop_bytes = 4;
   \   000003D0   0x2504             MOVS     R5,#+4
   \   000003D2   0xF8CE 0x505C      STR      R5,[LR, #+92]
    864                  transfer_config_c.major_loop_counts = 1;
   \   000003D6   0x2501             MOVS     R5,#+1
   \   000003D8   0xF8CE 0x5060      STR      R5,[LR, #+96]
    865          
    866                  EdmaTcdReset(software_tcd);
   \   000003DC   0x2500             MOVS     R5,#+0
   \   000003DE   0x6025             STR      R5,[R4, #+0]
   \   000003E0   0x80A5             STRH     R5,[R4, #+4]
   \   000003E2   0x80E5             STRH     R5,[R4, #+6]
   \   000003E4   0x60A5             STR      R5,[R4, #+8]
   \   000003E6   0x60E5             STR      R5,[R4, #+12]
   \   000003E8   0x6125             STR      R5,[R4, #+16]
   \   000003EA   0x82A5             STRH     R5,[R4, #+20]
   \   000003EC   0x82E5             STRH     R5,[R4, #+22]
   \   000003EE   0x61A5             STR      R5,[R4, #+24]
   \   000003F0   0x2508             MOVS     R5,#+8
   \   000003F2   0x83A5             STRH     R5,[R4, #+28]
   \   000003F4   0x2500             MOVS     R5,#+0
   \   000003F6   0x83E5             STRH     R5,[R4, #+30]
    867                  EdmaTcdSetTransferConfig(software_tcd, &transfer_config_c);
   \   000003F8   0xF8DE 0x504C      LDR      R5,[LR, #+76]
   \   000003FC   0x6025             STR      R5,[R4, #+0]
   \   000003FE   0xF8DE 0x5050      LDR      R5,[LR, #+80]
   \   00000402   0x6125             STR      R5,[R4, #+16]
   \   00000404   0xF89E 0x5054      LDRB     R5,[LR, #+84]
   \   00000408   0xF89E 0x6055      LDRB     R6,[LR, #+85]
   \   0000040C   0x022D             LSLS     R5,R5,#+8
   \   0000040E   0xF405 0x65E0      AND      R5,R5,#0x700
   \   00000412   0xF006 0x0607      AND      R6,R6,#0x7
   \   00000416   0x4335             ORRS     R5,R6,R5
   \   00000418   0x80E5             STRH     R5,[R4, #+6]
   \   0000041A   0xF8BE 0x5056      LDRH     R5,[LR, #+86]
   \   0000041E   0x80A5             STRH     R5,[R4, #+4]
   \   00000420   0xF8BE 0x5058      LDRH     R5,[LR, #+88]
   \   00000424   0x82A5             STRH     R5,[R4, #+20]
   \   00000426   0xF8DE 0x505C      LDR      R5,[LR, #+92]
   \   0000042A   0x60A5             STR      R5,[R4, #+8]
   \   0000042C   0xF8DE 0x5060      LDR      R5,[LR, #+96]
   \   00000430   0x82E5             STRH     R5,[R4, #+22]
   \   00000432   0xF8DE 0x5060      LDR      R5,[LR, #+96]
   \   00000436   0x83E5             STRH     R5,[R4, #+30]
    868              }
    869              if (((handle->remaining_send_byte_count > 1) && (handle->bits_per_frame <= 8))
    870               || ((handle->remaining_send_byte_count > 2) && (handle->bits_per_frame > 8)))
   \                     ??DspiMasterTransferEdma_28: (+1)
   \   00000438   0x698D             LDR      R5,[R1, #+24]
   \   0000043A   0x2D02             CMP      R5,#+2
   \   0000043C   0xD302             BCC.N    ??DspiMasterTransferEdma_29
   \   0000043E   0x680D             LDR      R5,[R1, #+0]
   \   00000440   0x2D09             CMP      R5,#+9
   \   00000442   0xD305             BCC.N    ??DspiMasterTransferEdma_30
   \                     ??DspiMasterTransferEdma_29: (+1)
   \   00000444   0x698D             LDR      R5,[R1, #+24]
   \   00000446   0x2D03             CMP      R5,#+3
   \   00000448   0xBF24             ITT      CS 
   \   0000044A   0x680D             LDRCS    R5,[R1, #+0]
   \   0000044C   0x2D09             CMPCS    R5,#+9
   \   0000044E   0xD353             BCC.N    ??DspiMasterTransferEdma_31
    871              {
    872                  transfer_config_c.src_addr = (uint32) (&(handle->command));
    873                  transfer_config_c.dest_addr = (uint32) txAddr;
   \                     ??DspiMasterTransferEdma_30: (+1)
   \   00000450   0xF8CE 0x3050      STR      R3,[LR, #+80]
   \   00000454   0x1D0D             ADDS     R5,R1,#+4
    874          
    875                  transfer_config_c.source_transfer_size = DMA_TRANSFER_SIZE_FOUR_BYTE;
   \   00000456   0x2302             MOVS     R3,#+2
   \   00000458   0xF88E 0x3054      STRB     R3,[LR, #+84]
    876                  transfer_config_c.dest_transfer_size = DMA_TRANSFER_SIZE_FOUR_BYTE;
   \   0000045C   0xF88E 0x3055      STRB     R3,[LR, #+85]
   \   00000460   0xF8CE 0x504C      STR      R5,[LR, #+76]
    877                  transfer_config_c.source_offset = 0;
   \   00000464   0x2300             MOVS     R3,#+0
   \   00000466   0xF8AE 0x3056      STRH     R3,[LR, #+86]
    878                  transfer_config_c.dest_offset = 0;
   \   0000046A   0xF8AE 0x3058      STRH     R3,[LR, #+88]
    879                  transfer_config_c.minor_loop_bytes = 4;
   \   0000046E   0x2304             MOVS     R3,#+4
   \   00000470   0xF8CE 0x305C      STR      R3,[LR, #+92]
    880          
    881                  if (handle->bits_per_frame <= 8)
   \   00000474   0x680B             LDR      R3,[R1, #+0]
   \   00000476   0x2B09             CMP      R3,#+9
   \   00000478   0x698B             LDR      R3,[R1, #+24]
   \   0000047A   0xBF28             IT       CS 
    882                  {
    883                      transfer_config_c.major_loop_counts = handle->remaining_send_byte_count - 1;
    884                  }
    885                  else
    886                  {
    887                      transfer_config_c.major_loop_counts = handle->remaining_send_byte_count / 2 - 1;
   \   0000047C   0x085B             LSRCS    R3,R3,#+1
   \   0000047E   0x1E5B             SUBS     R3,R3,#+1
   \   00000480   0xF8CE 0x3060      STR      R3,[LR, #+96]
    888                  }
    889          
    890                  DspiSetConfig(DMA_ENGINE1, DMA_CH2, &transfer_config_c, software_tcd);
   \   00000484   0xF8CC 0x5024      STR      R5,[R12, #+36]
   \   00000488   0xF8DE 0x3050      LDR      R3,[LR, #+80]
   \   0000048C   0xF8CC 0x3034      STR      R3,[R12, #+52]
   \   00000490   0xF89E 0x3054      LDRB     R3,[LR, #+84]
   \   00000494   0xF89E 0x5055      LDRB     R5,[LR, #+85]
   \   00000498   0x021B             LSLS     R3,R3,#+8
   \   0000049A   0xF403 0x63E0      AND      R3,R3,#0x700
   \   0000049E   0xF005 0x0507      AND      R5,R5,#0x7
   \   000004A2   0x432B             ORRS     R3,R5,R3
   \   000004A4   0xF8AC 0x302A      STRH     R3,[R12, #+42]
   \   000004A8   0xF8BE 0x3056      LDRH     R3,[LR, #+86]
   \   000004AC   0xF8AC 0x3028      STRH     R3,[R12, #+40]
   \   000004B0   0xF8BE 0x3058      LDRH     R3,[LR, #+88]
   \   000004B4   0xF8AC 0x3038      STRH     R3,[R12, #+56]
   \   000004B8   0xF8DE 0x305C      LDR      R3,[LR, #+92]
   \   000004BC   0xF8CC 0x302C      STR      R3,[R12, #+44]
   \   000004C0   0xF8DE 0x3060      LDR      R3,[LR, #+96]
   \   000004C4   0xF8AC 0x303A      STRH     R3,[R12, #+58]
   \   000004C8   0xF8DE 0x3060      LDR      R3,[LR, #+96]
   \   000004CC   0xF8AC 0x3042      STRH     R3,[R12, #+66]
   \   000004D0   0xB154             CBZ.N    R4,??DspiMasterTransferEdma_32
   \   000004D2   0xF8CC 0x403C      STR      R4,[R12, #+60]
   \   000004D6   0xF64F 0x74F7      MOVW     R4,#+65527
   \   000004DA   0xF8BC 0x3040      LDRH     R3,[R12, #+64]
   \   000004DE   0x4023             ANDS     R3,R4,R3
   \   000004E0   0xF043 0x0310      ORR      R3,R3,#0x10
   \   000004E4   0xF8AC 0x3040      STRH     R3,[R12, #+64]
    891                  //Enable auto stop request
    892                  DMA0->TCD[DMA_CH2].CSR = (DMA0->TCD[DMA_CH2].CSR & (~DMA_CSR_DREQ_MASK)) | DMA_CSR_DREQ(FALSE);
   \                     ??DspiMasterTransferEdma_32: (+1)
   \   000004E8   0xF64F 0x74F7      MOVW     R4,#+65527
   \   000004EC   0xF8BC 0x3040      LDRH     R3,[R12, #+64]
   \   000004F0   0x4023             ANDS     R3,R4,R3
   \   000004F2   0xF8AC 0x3040      STRH     R3,[R12, #+64]
   \   000004F6   0xE027             B.N      ??DspiMasterTransferEdma_33
    893          
    894              }
    895              else
    896              {
    897                  DspiSetConfig(DMA_ENGINE1, DMA_CH2, &transfer_config_c, NULL);
   \                     ??DspiMasterTransferEdma_31: (+1)
   \   000004F8   0xF8DE 0x304C      LDR      R3,[LR, #+76]
   \   000004FC   0xF8CC 0x3024      STR      R3,[R12, #+36]
   \   00000500   0xF8DE 0x3050      LDR      R3,[LR, #+80]
   \   00000504   0xF8CC 0x3034      STR      R3,[R12, #+52]
   \   00000508   0xF89E 0x3054      LDRB     R3,[LR, #+84]
   \   0000050C   0xF89E 0x4055      LDRB     R4,[LR, #+85]
   \   00000510   0x021B             LSLS     R3,R3,#+8
   \   00000512   0xF403 0x63E0      AND      R3,R3,#0x700
   \   00000516   0xF004 0x0407      AND      R4,R4,#0x7
   \   0000051A   0x4323             ORRS     R3,R4,R3
   \   0000051C   0xF8AC 0x302A      STRH     R3,[R12, #+42]
   \   00000520   0xF8BE 0x3056      LDRH     R3,[LR, #+86]
   \   00000524   0xF8AC 0x3028      STRH     R3,[R12, #+40]
   \   00000528   0xF8BE 0x3058      LDRH     R3,[LR, #+88]
   \   0000052C   0xF8AC 0x3038      STRH     R3,[R12, #+56]
   \   00000530   0xF8DE 0x305C      LDR      R3,[LR, #+92]
   \   00000534   0xF8CC 0x302C      STR      R3,[R12, #+44]
   \   00000538   0xF8DE 0x3060      LDR      R3,[LR, #+96]
   \   0000053C   0xF8AC 0x303A      STRH     R3,[R12, #+58]
   \   00000540   0xF8DE 0x3060      LDR      R3,[LR, #+96]
   \   00000544   0xF8AC 0x3042      STRH     R3,[R12, #+66]
    898              }
    899              //EdmaStartTransfer(handle->edma_rx_reg_to_rx_data_handle);
    900              DMA0->SERQ = DMA_SERQ_SERQ(DMA_CH0);
   \                     ??DspiMasterTransferEdma_33: (+1)
   \   00000548   0x2300             MOVS     R3,#+0
   \   0000054A   0x7013             STRB     R3,[R2, #+0]
    901              DMA0->SERQ = DMA_SERQ_SERQ(DMA_CH1);
   \   0000054C   0x2301             MOVS     R3,#+1
   \   0000054E   0x7013             STRB     R3,[R2, #+0]
    902              DMA0->SERQ = DMA_SERQ_SERQ(DMA_CH2);
   \   00000550   0x2302             MOVS     R3,#+2
   \   00000552   0x7013             STRB     R3,[R2, #+0]
    903              #if (SPI0_FEATURE == ENABLED)
    904                   /*if there is Tx DMA request , carry the 32bits data (handle->command) to PUSHR first , then link to channelB
    905                   to prepare the next 32bits data (User_send_buffer to handle->command) */
    906                   if (handle->remaining_send_byte_count > 1)
   \   00000554   0x6989             LDR      R1,[R1, #+24]
   \   00000556   0x2902             CMP      R1,#+2
   \   00000558   0xD31B             BCC.N    ??DspiMasterTransferEdma_34
    907                   {
    908                     /* Enable minor link */
    909                       DMA0->TCD[DMA_CH2].CITER_ELINKNO |= DMA_CITER_ELINKYES_ELINK_MASK;
   \   0000055A   0xF8BC 0x103A      LDRH     R1,[R12, #+58]
   \   0000055E   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000562   0xF8AC 0x103A      STRH     R1,[R12, #+58]
   \   00000566   0xF24E 0x12FF      MOVW     R2,#+57855
    910                       DMA0->TCD[DMA_CH2].BITER_ELINKNO  |= DMA_BITER_ELINKYES_ELINK_MASK;
   \   0000056A   0xF8BC 0x1042      LDRH     R1,[R12, #+66]
   \   0000056E   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000572   0xF8AC 0x1042      STRH     R1,[R12, #+66]
    911                       /* Set likned channel */
    912                       tmpreg = DMA0->TCD[DMA_CH2].CITER_ELINKNO  & (~DMA_CITER_ELINKYES_LINKCH_MASK);
   \   00000576   0xF8BC 0x103A      LDRH     R1,[R12, #+58]
    913                       tmpreg |= DMA_CITER_ELINKYES_LINKCH(DMA_CH1);
    914                       DMA0->TCD[DMA_CH2].CITER_ELINKNO  = tmpreg;
   \   0000057A   0x4011             ANDS     R1,R2,R1
   \   0000057C   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000580   0xF8AC 0x103A      STRH     R1,[R12, #+58]
    915                       tmpreg = DMA0->TCD[DMA_CH2].BITER_ELINKNO & (~DMA_BITER_ELINKYES_LINKCH_MASK);
   \   00000584   0xF8BC 0x1042      LDRH     R1,[R12, #+66]
    916                       tmpreg |= DMA_BITER_ELINKYES_LINKCH(DMA_CH1);
    917                       DMA0->TCD[DMA_CH2].BITER_ELINKNO  = tmpreg;
   \   00000588   0x4011             ANDS     R1,R2,R1
   \   0000058A   0xF441 0x7100      ORR      R1,R1,#0x200
   \   0000058E   0xF8AC 0x1042      STRH     R1,[R12, #+66]
    918                   }
    919                  base->RSER |= (SPI_RSER_RFDF_RE_MASK | SPI_RSER_RFDF_DIRS_MASK)|(SPI_RSER_TFFF_RE_MASK | SPI_RSER_TFFF_DIRS_MASK);
   \                     ??DspiMasterTransferEdma_34: (+1)
   \   00000592   0x6B01             LDR      R1,[R0, #+48]
   \   00000594   0x....             LDR.N    R2,??DataTable13_13  ;; 0x3030000
   \   00000596   0x4311             ORRS     R1,R2,R1
   \   00000598   0x6301             STR      R1,[R0, #+48]
    920              #endif
    921              base->MCR &= ~SPI_MCR_HALT_MASK;
   \   0000059A   0x6801             LDR      R1,[R0, #+0]
   \   0000059C   0x0849             LSRS     R1,R1,#+1
   \   0000059E   0x0049             LSLS     R1,R1,#+1
   \   000005A0   0x6001             STR      R1,[R0, #+0]
    922              Spi0_Busy = FALSE;
   \   000005A2   0x2000             MOVS     R0,#+0
   \   000005A4   0xF88E 0x0074      STRB     R0,[LR, #+116]
    923          }
   \   000005A8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    924          //---------------------------------------------------------------------------------------------------------------------
    925          /**
    926           *  @brief      This API is used for SPI set TCD register configuration for  Master communication
    927           *
    928           *  @details    TThis API is used for SPI set TCD register source address,destination address,Number of bytes for  Master communication
    929           *
    930           *  @param      dma_engine          :this variable is used to to select which DMA ENGINE is using
    931           *  @param      channel             :this variable is used to to select which channel is  using
    932           *  @param      transfer_config     :DSPI master transfer data configuration used for the transfer*
    933           *  @param      next_tcd            :is used to configure scatter/gather feature as a next hardware TCD.
    934          */

   \                                 In section .text, align 2, keep-with-next
    935          void DspiSetConfig(DMA_ENGINE_TYPE dma_engine,DMA_CHANNEL_TYPE channel,EDMA_TRANSFER_CONFIG *transfer_config, EDMA_TCD *next_tcd)
                                                    ^
Remark[Pe826]: parameter "dma_engine" was never referenced
    936          {
    937              DMA0->TCD[channel].SADDR = transfer_config->src_addr;
   \                     DspiSetConfig: (+1)
   \   00000000   0x0148             LSLS     R0,R1,#+5
   \   00000002   0x....             LDR.N    R1,??DataTable13_14  ;; 0x40009000
   \   00000004   0xF8D2 0xC000      LDR      R12,[R2, #+0]
   \   00000008   0xF840 0xC001      STR      R12,[R0, R1]
    938               /* destination address */
    939              DMA0->TCD[channel].DADDR = transfer_config->dest_addr;
   \   0000000C   0x1840             ADDS     R0,R0,R1
   \   0000000E   0x6851             LDR      R1,[R2, #+4]
   \   00000010   0x6101             STR      R1,[R0, #+16]
    940               /* Source data and destination data transfer size */
    941               DMA0->TCD[channel].ATTR = DMA_ATTR_SSIZE(transfer_config->source_transfer_size) | DMA_ATTR_DSIZE(transfer_config->dest_transfer_size);
   \   00000012   0x7A11             LDRB     R1,[R2, #+8]
   \   00000014   0xF892 0xC009      LDRB     R12,[R2, #+9]
   \   00000018   0x0209             LSLS     R1,R1,#+8
   \   0000001A   0xF401 0x61E0      AND      R1,R1,#0x700
   \   0000001E   0xF00C 0x0C07      AND      R12,R12,#0x7
   \   00000022   0xEA4C 0x0101      ORR      R1,R12,R1
   \   00000026   0x80C1             STRH     R1,[R0, #+6]
    942               /* Source address signed offset */
    943               DMA0->TCD[channel].SOFF = transfer_config->source_offset;
   \   00000028   0x8951             LDRH     R1,[R2, #+10]
   \   0000002A   0x8081             STRH     R1,[R0, #+4]
    944               /* Destination address signed offset */
    945               DMA0->TCD[channel].DOFF =transfer_config->dest_offset;
   \   0000002C   0x8991             LDRH     R1,[R2, #+12]
   \   0000002E   0x8281             STRH     R1,[R0, #+20]
    946               /* Minor byte transfer count */
    947               DMA0->TCD[channel].NBYTES_MLNO = transfer_config->minor_loop_bytes;
   \   00000030   0x6911             LDR      R1,[R2, #+16]
   \   00000032   0x6081             STR      R1,[R0, #+8]
    948               /* Current major iteration count */
    949               DMA0->TCD[channel].CITER_ELINKNO = transfer_config->major_loop_counts;
   \   00000034   0x6951             LDR      R1,[R2, #+20]
   \   00000036   0x82C1             STRH     R1,[R0, #+22]
    950               /* Starting major iteration count */
    951               DMA0->TCD[channel].BITER_ELINKNO = transfer_config->major_loop_counts;
   \   00000038   0x6951             LDR      R1,[R2, #+20]
   \   0000003A   0x83C1             STRH     R1,[R0, #+30]
    952               if (next_tcd != NULL)
   \   0000003C   0xB13B             CBZ.N    R3,??DspiSetConfig_0
    953               {
    954                   DMA0->TCD[channel].DLAST_SGA = (uint32)next_tcd;
   \   0000003E   0x6183             STR      R3,[R0, #+24]
    955                   /*
    956                       Before call EdmaTcdSetTransferConfig or EDMA_SetTransferConfig,
    957                       user must call EdmaTcdReset or EDMA_ResetChannel which will set
    958                       DREQ, so must use "|" or "&" rather than "=".
    959          
    960                       Clear the DREQ bit because scatter gather has been enabled, so the
    961                       previous transfer is not the last transfer, and channel request should
    962                       be enabled at the next transfer(the next TCD).
    963                   */
    964                   DMA0->TCD[channel].CSR = (DMA0->TCD[channel].CSR | DMA_CSR_ESG_MASK) & ~DMA_CSR_DREQ_MASK;
   \   00000040   0xF64F 0x72F7      MOVW     R2,#+65527
   \   00000044   0x8B81             LDRH     R1,[R0, #+28]
   \   00000046   0x4011             ANDS     R1,R2,R1
   \   00000048   0xF041 0x0110      ORR      R1,R1,#0x10
   \   0000004C   0x8381             STRH     R1,[R0, #+28]
    965               }
    966          }
   \                     ??DspiSetConfig_0: (+1)
   \   0000004E   0x4770             BX       LR               ;; return
    967          //---------------------------------------------------------------------------------------------------------------------
    968          /**
    969           *  @brief      This API is used for  TCD registers reset
    970           *  @param      tcd            :is used to configure scatter/gather feature as a next hardware TCD.
    971          */
    972          

   \                                 In section .text, align 2, keep-with-next
    973          void EdmaTcdReset( EDMA_TCD *tcd)
    974          {
    975          
    976              /* Reset channel TCD */
    977              tcd->SADDR = 0U;
   \                     EdmaTcdReset: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    978              tcd->SOFF = 0U;
   \   00000004   0x8081             STRH     R1,[R0, #+4]
    979              tcd->ATTR = 0U;
   \   00000006   0x80C1             STRH     R1,[R0, #+6]
    980              tcd->NBYTES = 0U;
   \   00000008   0x6081             STR      R1,[R0, #+8]
    981              tcd->SLAST = 0U;
   \   0000000A   0x60C1             STR      R1,[R0, #+12]
    982              tcd->DADDR = 0U;
   \   0000000C   0x6101             STR      R1,[R0, #+16]
    983              tcd->DOFF = 0U;
   \   0000000E   0x8281             STRH     R1,[R0, #+20]
    984              tcd->CITER = 0U;
   \   00000010   0x82C1             STRH     R1,[R0, #+22]
    985              tcd->DLAST_SGA = 0U;
   \   00000012   0x6181             STR      R1,[R0, #+24]
    986              /* Enable auto disable request feature */
    987              tcd->CSR = DMA_CSR_DREQ(TRUE);
   \   00000014   0x2108             MOVS     R1,#+8
   \   00000016   0x8381             STRH     R1,[R0, #+28]
    988              tcd->BITER = 0U;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x83C1             STRH     R1,[R0, #+30]
    989          }
   \   0000001C   0x4770             BX       LR               ;; return
    990          //---------------------------------------------------------------------------------------------------------------------
    991          /**
    992           *  @brief      This API is used for  configure TCD registers
    993           *  @details    This API is used for  configure TCD registers based on the  requirement like source address,destination address,and number of bytes etc
    994           *  @param      tcd            :is used to configure scatter/gather feature as a next hardware TCD.
    995           *  @param      config         :DSPI master transfer data configuration used for the transfer
    996           *
    997          */

   \                                 In section .text, align 2, keep-with-next
    998          void EdmaTcdSetTransferConfig( EDMA_TCD *tcd, const EDMA_TRANSFER_CONFIG *config)
    999          {
   1000              /* source address */
   1001              tcd->SADDR = config->src_addr;
   \                     EdmaTcdSetTransferConfig: (+1)
   \   00000000   0x680A             LDR      R2,[R1, #+0]
   \   00000002   0x6002             STR      R2,[R0, #+0]
   1002              /* destination address */
   1003              tcd->DADDR = config->dest_addr;
   \   00000004   0x684A             LDR      R2,[R1, #+4]
   \   00000006   0x6102             STR      R2,[R0, #+16]
   1004              /* Source data and destination data transfer size */
   1005              tcd->ATTR = DMA_ATTR_SSIZE(config->source_transfer_size) | DMA_ATTR_DSIZE(config->dest_transfer_size);
   \   00000008   0x7A0A             LDRB     R2,[R1, #+8]
   \   0000000A   0x7A4B             LDRB     R3,[R1, #+9]
   \   0000000C   0x0212             LSLS     R2,R2,#+8
   \   0000000E   0xF402 0x62E0      AND      R2,R2,#0x700
   \   00000012   0xF003 0x0307      AND      R3,R3,#0x7
   \   00000016   0x431A             ORRS     R2,R3,R2
   \   00000018   0x80C2             STRH     R2,[R0, #+6]
   1006              /* Source address signed offset */
   1007              tcd->SOFF = config->source_offset;
   \   0000001A   0x894A             LDRH     R2,[R1, #+10]
   \   0000001C   0x8082             STRH     R2,[R0, #+4]
   1008              /* Destination address signed offset */
   1009              tcd->DOFF = config->dest_offset;
   \   0000001E   0x898A             LDRH     R2,[R1, #+12]
   \   00000020   0x8282             STRH     R2,[R0, #+20]
   1010              /* Minor byte transfer count */
   1011              tcd->NBYTES = config->minor_loop_bytes;
   \   00000022   0x690A             LDR      R2,[R1, #+16]
   \   00000024   0x6082             STR      R2,[R0, #+8]
   1012              /* Current major iteration count */
   1013              tcd->CITER = config->major_loop_counts;
   \   00000026   0x694A             LDR      R2,[R1, #+20]
   \   00000028   0x82C2             STRH     R2,[R0, #+22]
   1014              /* Starting major iteration count */
   1015              tcd->BITER = config->major_loop_counts;
   \   0000002A   0x6949             LDR      R1,[R1, #+20]
   \   0000002C   0x83C1             STRH     R1,[R0, #+30]
   1016              /* Enable scatter/gather processing */
   1017          }
   \   0000002E   0x4770             BX       LR               ;; return
   1018          //---------------------------------------------------------------------------------------------------------------------
   1019          /**
   1020           *  @brief      This API is used  to start DMA transfer
   1021           *  @details    This API is used  to start DMA transfer
   1022           *  @param      handle            :it is a DMA transfer handle structure variable
   1023          */
   1024          

   \                                 In section .text, align 2, keep-with-next
   1025          void EdmaStartTransfer(EDMA_HANDLE *handle)
   1026          {
   1027          
   1028              handle->base->SERQ = DMA_SERQ_SERQ(handle->channel);
   \                     EdmaStartTransfer: (+1)
   \   00000000   0x7B01             LDRB     R1,[R0, #+12]
   \   00000002   0x6840             LDR      R0,[R0, #+4]
   \   00000004   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000008   0x76C1             STRB     R1,[R0, #+27]
   1029          }
   \   0000000A   0x4770             BX       LR               ;; return
   1030          //---------------------------------------------------------------------------------------------------------------------
   1031          /**
   1032           *  @brief      This API is used  to initialize DMA_SPI Master initialization
   1033           *  @details    This API is used  to start DMA transfer
   1034           *  @param      base            :This variable contains base address of SPI
   1035           *  @param      masterConfig    :DSPI master configuration structure variable
   1036           *  @param      src_clock_hz    :This variable contains clock frequency of source
   1037          */
   1038          

   \                                 In section .text, align 2, keep-with-next
   1039          void DspiMasterInit(SPI_TYPE *base, const DSPI_MASTER_CONFIG  *masterConfig, uint32 src_clock_hz)
   1040          {
   \                     DspiMasterInit: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   1041          
   1042              uint32 temp;
   1043              base->MCR &= ~SPI_MCR_MDIS_MASK;
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0xF420 0x4080      BIC      R0,R0,#0x4000
   \   0000000C   0x6020             STR      R0,[R4, #+0]
   \   0000000E   0x460D             MOV      R5,R1
   1044              base->MCR |= SPI_MCR_HALT_MASK;
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x....             LDR.N    R1,??DataTable13_7  ;; 0xbaffccff
   \   00000014   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000018   0x6020             STR      R0,[R4, #+0]
   \   0000001A   0x4613             MOV      R3,R2
   1045              base->MCR = (base->MCR & (~SPI_MCR_MSTR_MASK)) | SPI_MCR_MSTR(DSPI_MASTER);
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \   00000022   0x6020             STR      R0,[R4, #+0]
   1046          
   1047          
   1048              temp = base->MCR & (~(SPI_MCR_CONT_SCKE_MASK | SPI_MCR_MTFE_MASK | SPI_MCR_ROOE_MASK | SPI_MCR_SMPL_PT_MASK |
   1049                                    SPI_MCR_DIS_TXF_MASK | SPI_MCR_DIS_RXF_MASK));
   1050          
   1051              base->MCR = temp | SPI_MCR_CONT_SCKE(masterConfig->enable_continuos_sck) |
   1052                          SPI_MCR_MTFE(masterConfig->enable_modified_timing_format) |
   1053                          SPI_MCR_ROOE(masterConfig->enable_rx_fifo_over_write) | SPI_MCR_SMPL_PT(DSPI_SCK_TO_SIN0_CLOCK) |
   1054                          SPI_MCR_DIS_TXF(FALSE) | SPI_MCR_DIS_RXF(FALSE);
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x4008             ANDS     R0,R1,R0
   \   00000028   0x7E29             LDRB     R1,[R5, #+24]
   \   0000002A   0x0789             LSLS     R1,R1,#+30
   \   0000002C   0xF001 0x4180      AND      R1,R1,#0x40000000
   \   00000030   0x4308             ORRS     R0,R1,R0
   \   00000032   0x7EA9             LDRB     R1,[R5, #+26]
   \   00000034   0x0689             LSLS     R1,R1,#+26
   \   00000036   0xF001 0x6180      AND      R1,R1,#0x4000000
   \   0000003A   0x4308             ORRS     R0,R1,R0
   \   0000003C   0x7E69             LDRB     R1,[R5, #+25]
   \   0000003E   0x0609             LSLS     R1,R1,#+24
   \   00000040   0xF001 0x7180      AND      R1,R1,#0x1000000
   \   00000044   0x4308             ORRS     R0,R1,R0
   \   00000046   0x6020             STR      R0,[R4, #+0]
   \   00000048   0x2100             MOVS     R1,#+0
   1055          
   1056              base->MCR |= SPI_MCR_PCSIS(DSPI_PCS_ACTIVE_HIGH );
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6020             STR      R0,[R4, #+0]
   1057              if (0 == DspiMasterSetBaudrate(base, DSPI_CTAR0, masterConfig->ctar_config.baud_rate, src_clock_hz))
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x682A             LDR      R2,[R5, #+0]
   \   00000052   0x.... 0x....      BL       DspiMasterSetBaudrate
   1058              {
   1059              }
   1060          
   1061              temp = base->CTAR[DSPI_CTAR0] &
   1062                     ~(SPI_CTAR_FMSZ_MASK | SPI_CTAR_CPOL_MASK | SPI_CTAR_CPHA_MASK | SPI_CTAR_LSBFE_MASK);
   1063          
   1064              base->CTAR[DSPI_CTAR0] =
   1065                  temp | SPI_CTAR_FMSZ(masterConfig->ctar_config.bits_per_frame - 1) | SPI_CTAR_CPOL(masterConfig->ctar_config.cpol) |
   1066                  SPI_CTAR_CPHA(masterConfig->ctar_config.cpha) | SPI_CTAR_LSBFE(masterConfig->ctar_config.direction);
   \   00000056   0x68E0             LDR      R0,[R4, #+12]
   \   00000058   0x6869             LDR      R1,[R5, #+4]
   \   0000005A   0x1E49             SUBS     R1,R1,#+1
   \   0000005C   0x06C9             LSLS     R1,R1,#+27
   \   0000005E   0xF020 0x40FE      BIC      R0,R0,#0x7F000000
   \   00000062   0xF001 0x41F0      AND      R1,R1,#0x78000000
   \   00000066   0x4308             ORRS     R0,R1,R0
   \   00000068   0x7A29             LDRB     R1,[R5, #+8]
   \   0000006A   0x0689             LSLS     R1,R1,#+26
   \   0000006C   0xF001 0x6180      AND      R1,R1,#0x4000000
   \   00000070   0x4308             ORRS     R0,R1,R0
   \   00000072   0x7A69             LDRB     R1,[R5, #+9]
   \   00000074   0x0649             LSLS     R1,R1,#+25
   \   00000076   0xF001 0x7100      AND      R1,R1,#0x2000000
   \   0000007A   0x4308             ORRS     R0,R1,R0
   \   0000007C   0x7AA9             LDRB     R1,[R5, #+10]
   \   0000007E   0x0609             LSLS     R1,R1,#+24
   \   00000080   0xF001 0x7180      AND      R1,R1,#0x1000000
   \   00000084   0x4308             ORRS     R0,R1,R0
   \   00000086   0x60E0             STR      R0,[R4, #+12]
   1067          
   1068              base->MCR &= ~SPI_MCR_HALT_MASK;
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x0840             LSRS     R0,R0,#+1
   \   0000008C   0x0040             LSLS     R0,R0,#+1
   \   0000008E   0x6020             STR      R0,[R4, #+0]
   1069          }
   \   00000090   0xB001             ADD      SP,SP,#+4
   \   00000092   0xBD30             POP      {R4,R5,PC}       ;; return
   1070          //---------------------------------------------------------------------------------------------------------------------
   1071          /**
   1072           *  @brief      This API is used  to set  DMA_SPI baud rate
   1073           *  @details    This API is used  to set  DMA_SPI baud rate
   1074           *  @param      base             :This variable contains base address of SPI
   1075           *  @param      baud_rate_bps    :This variable is used to select the baud rate defined by the user
   1076           *  @param      src_clock_hz     :This variable contains clock frequency of source
   1077          */

   \                                 In section .text, align 4, keep-with-next
   1078          uint32 DspiMasterSetBaudrate(SPI_TYPE *base,uint32  which_ctar,uint32 baud_rate_bps,uint32 src_clock_hz)
                                                                     ^
Remark[Pe826]: parameter "which_ctar" was never referenced
   1079          {
   \                     DspiMasterSetBaudrate: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   1080              uint32 temp;
   1081              uint32 pre_scaler, best_pre_scaler;
   1082              uint32 scaler, best_scaler;
   1083              uint32 dbr, best_dbr;
   1084              uint32 real_baud_rate, best_baud_rate;
   1085              uint32 diff, min_diff;
   1086              uint32 baud_rate = baud_rate_bps;
   1087          
   1088              /* find combination of pre_scaler and scaler resulting in baud_rate closest to the requested value */
   1089              min_diff = 0xFFFFFFFFU;
   1090              best_pre_scaler = 0;
   \   00000004   0xF04F 0x0C00      MOV      R12,#+0
   1091              best_scaler = 0;
   1092              best_dbr = 1;
   1093              best_baud_rate = 0; /* required to avoid compilation warning */
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF04F 0x37FF      MOV      R7,#-1
   \   0000000E   0x46E6             MOV      LR,R12
   \   00000010   0x2601             MOVS     R6,#+1
   1094          
   1095              /* In all for loops, if min_diff = 0, the exit for loop*/
   1096              for (pre_scaler = 0; (pre_scaler < 4) && min_diff; pre_scaler++)
   \   00000012   0x4601             MOV      R1,R0
   \   00000014   0x.... 0x....      ADR.W    R4,BAUD_RATE_PRESCALAR
   1097              {
   1098                  for (scaler = 0; (scaler < 16) && min_diff; scaler++)
   \                     ??DspiMasterSetBaudrate_0: (+1)
   \   00000018   0xF05F 0x0500      MOVS.W   R5,#+0
   \   0000001C   0x.... 0x....      ADR.W    R8,BAUD_RATE_SCALAR
   1099                  {
   1100                      for (dbr = 1; (dbr < 3) && min_diff; dbr++)
   \                     ??DspiMasterSetBaudrate_1: (+1)
   \   00000020   0xF8D4 0x9000      LDR      R9,[R4, #+0]
   \   00000024   0xF8D8 0xA000      LDR      R10,[R8, #+0]
   \   00000028   0xFB0A 0xF909      MUL      R9,R10,R9
   1101                      {
   1102                          real_baud_rate = ((src_clock_hz * dbr) / (BAUD_RATE_PRESCALAR[pre_scaler] * (BAUD_RATE_SCALAR[scaler])));
   \   0000002C   0xFBB3 0xFAF9      UDIV     R10,R3,R9
   1103          
   1104                          /* calculate the baud rate difference based on the conditional statement that states that the calculated
   1105                          * baud rate must not exceed the desired baud rate.
   1106                          */
   1107                          if (baud_rate >= real_baud_rate)
   \   00000030   0x4552             CMP      R2,R10
   \   00000032   0xD309             BCC.N    ??DspiMasterSetBaudrate_2
   1108                          {
   1109                              diff = baud_rate - real_baud_rate;
   \   00000034   0xEBA2 0x0B0A      SUB      R11,R2,R10
   1110                              if (min_diff > diff)
   \   00000038   0x45BB             CMP      R11,R7
   \   0000003A   0xD205             BCS.N    ??DspiMasterSetBaudrate_2
   1111                              {
   1112                                  /* a better match found */
   1113                                  min_diff = diff;
   \   0000003C   0x465F             MOV      R7,R11
   1114                                  best_pre_scaler = pre_scaler;
   \   0000003E   0x468C             MOV      R12,R1
   1115                                  best_scaler = scaler;
   \   00000040   0x46AE             MOV      LR,R5
   1116                                  best_baud_rate = real_baud_rate;
   \   00000042   0x4650             MOV      R0,R10
   1117                                  best_dbr = dbr;
   \   00000044   0x2601             MOVS     R6,#+1
   \   00000046   0xB177             CBZ.N    R7,??DspiMasterSetBaudrate_3
   \                     ??DspiMasterSetBaudrate_2: (+1)
   \   00000048   0xEA4F 0x0A43      LSL      R10,R3,#+1
   \   0000004C   0xFBBA 0xF9F9      UDIV     R9,R10,R9
   \   00000050   0x454A             CMP      R2,R9
   \   00000052   0xD308             BCC.N    ??DspiMasterSetBaudrate_3
   \   00000054   0xEBA2 0x0A09      SUB      R10,R2,R9
   \   00000058   0x45BA             CMP      R10,R7
   \   0000005A   0xD204             BCS.N    ??DspiMasterSetBaudrate_3
   \   0000005C   0x4657             MOV      R7,R10
   \   0000005E   0x468C             MOV      R12,R1
   \   00000060   0x46AE             MOV      LR,R5
   \   00000062   0x4648             MOV      R0,R9
   \   00000064   0x2602             MOVS     R6,#+2
   1118                              }
   1119                          }
   1120                      }
   1121                  }
   \                     ??DspiMasterSetBaudrate_3: (+1)
   \   00000066   0x1C6D             ADDS     R5,R5,#+1
   \   00000068   0xF108 0x0804      ADD      R8,R8,#+4
   \   0000006C   0x2D10             CMP      R5,#+16
   \   0000006E   0xD201             BCS.N    ??DspiMasterSetBaudrate_4
   \   00000070   0x2F00             CMP      R7,#+0
   \   00000072   0xD1D5             BNE.N    ??DspiMasterSetBaudrate_1
   1122              }
   \                     ??DspiMasterSetBaudrate_4: (+1)
   \   00000074   0x1C49             ADDS     R1,R1,#+1
   \   00000076   0x1D24             ADDS     R4,R4,#+4
   \   00000078   0x2904             CMP      R1,#+4
   \   0000007A   0xD201             BCS.N    ??DspiMasterSetBaudrate_5
   \   0000007C   0x2F00             CMP      R7,#+0
   \   0000007E   0xD1CB             BNE.N    ??DspiMasterSetBaudrate_0
   1123          
   1124              /* write the best dbr, prescalar, and baud rate scalar to the CTAR */
   1125              temp = base->CTAR[DSPI_CTAR0] & ~(SPI_CTAR_DBR_MASK | SPI_CTAR_PBR_MASK | SPI_CTAR_BR_MASK);
   1126          
   1127              base->CTAR[DSPI_CTAR0] = temp | ((best_dbr - 1) << SPI_CTAR_DBR_SHIFT) | (best_pre_scaler << SPI_CTAR_PBR_SHIFT) |
   1128                                      (best_scaler << SPI_CTAR_BR_SHIFT);
   \                     ??DspiMasterSetBaudrate_5: (+1)
   \   00000080   0x9900             LDR      R1,[SP, #+0]
   \   00000082   0x....             LDR.N    R2,??DataTable13_15  ;; 0x7ffcfff0
   \   00000084   0x68C9             LDR      R1,[R1, #+12]
   \   00000086   0x4011             ANDS     R1,R2,R1
   \   00000088   0x1E72             SUBS     R2,R6,#+1
   \   0000008A   0xEA41 0x71C2      ORR      R1,R1,R2, LSL #+31
   \   0000008E   0x9A00             LDR      R2,[SP, #+0]
   \   00000090   0xEA41 0x410C      ORR      R1,R1,R12, LSL #+16
   \   00000094   0xEA4E 0x0101      ORR      R1,LR,R1
   \   00000098   0x60D1             STR      R1,[R2, #+12]
   1129          
   1130              /* return the actual calculated baud rate */
   1131              return best_baud_rate;
   \   0000009A   0xB001             ADD      SP,SP,#+4
   \   0000009C   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1132          }
   1133          //---------------------------------------------------------------------------------------------------------------------
   1134          /**
   1135            * @brief  Disables the specified DMAy Channelx.
   1136            * @param  channel: Defines the specific Dma channel from the DMA_CHANNEL_TYPE
   1137            */

   \                                 In section .text, align 2, keep-with-next
   1138          void DspiDisable(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel)
                                                  ^
Remark[Pe826]: parameter "dma_engine" was never referenced

      static SPI_BUFFER_TYPE Spi0_Tx_Write;
                             ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Spi\Spi.c",287  Warning[Pe550]: 
          variable "Spi0_Tx_Write" was set but never used

      static SPI_BUFFER_TYPE Spi0_Tx_Read;
                             ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Spi\Spi.c",288  Warning[Pe550]: 
          variable "Spi0_Tx_Read" was set but never used

                  handle->last_command = (handle->last_command & 0xffff0000U) | handle->tx_data[bufferIndex - 1];
                  ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Spi\Spi.c",825  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

                      handle->last_command = (handle->last_command & 0xffff0000U) | handle->tx_data[bufferIndex - 2]
                      ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Spi\Spi.c",831  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

                      handle->last_command = (handle->last_command & 0xffff0000U)
                      ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Spi\Spi.c",836  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement
   1139          {
   1140              /* Reset channel TCD */
   1141               DMA0->TCD[channel].SADDR = 0U;
   \                     DspiDisable: (+1)
   \   00000000   0x0148             LSLS     R0,R1,#+5
   \   00000002   0x....             LDR.N    R1,??DataTable13_14  ;; 0x40009000
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x5042             STR      R2,[R0, R1]
   1142               DMA0->TCD[channel].SOFF = 0U;
   \   00000008   0x1840             ADDS     R0,R0,R1
   \   0000000A   0x2108             MOVS     R1,#+8
   \   0000000C   0x8082             STRH     R2,[R0, #+4]
   1143               DMA0->TCD[channel].ATTR = 0U;
   \   0000000E   0x80C2             STRH     R2,[R0, #+6]
   1144               DMA0->TCD[channel].NBYTES_MLNO = 0U;
   \   00000010   0x6082             STR      R2,[R0, #+8]
   1145               DMA0->TCD[channel].SLAST = 0U;
   \   00000012   0x60C2             STR      R2,[R0, #+12]
   1146               DMA0->TCD[channel].DADDR = 0U;
   \   00000014   0x6102             STR      R2,[R0, #+16]
   1147               DMA0->TCD[channel].DOFF = 0U;
   \   00000016   0x8282             STRH     R2,[R0, #+20]
   1148               DMA0->TCD[channel].CITER_ELINKNO = 0U;
   \   00000018   0x82C2             STRH     R2,[R0, #+22]
   1149               DMA0->TCD[channel].DLAST_SGA = 0U;
   \   0000001A   0x6182             STR      R2,[R0, #+24]
   1150               /* Enable auto disable request feature */
   1151               DMA0->TCD[channel].CSR = DMA_CSR_DREQ(TRUE);
   \   0000001C   0x8381             STRH     R1,[R0, #+28]
   1152               DMA0->TCD[channel].BITER_ELINKNO = 0U;
   \   0000001E   0x83C2             STRH     R2,[R0, #+30]
   1153          }
   \   00000020   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     masterConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x4004D048         DC32     0x4004d048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x4004B014         DC32     0x4004b014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x005B8D80         DC32     0x5b8d80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x4002C000         DC32     0x4002c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0xBAFFCCFF         DC32     0xbaffccff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0xDA0A0000         DC32     0xda0a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x4002D000         DC32     0x4002d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0xFCFCFFFF         DC32     0xfcfcffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   0x4000801B         DC32     0x4000801b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \   00000000   0x4000901C         DC32     0x4000901c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \   00000000   0x03030000         DC32     0x3030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_14:
   \   00000000   0x40009000         DC32     0x40009000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_15:
   \   00000000   0x7FFCFFF0         DC32     0x7ffcfff0
   1154          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DspiDisable
      16   DspiMasterInit
        16   -> DspiMasterSetBaudrate
      40   DspiMasterSetBaudrate
      24   DspiMasterTransferEdma
       0   DspiSetConfig
       0   EdmaStartTransfer
       0   EdmaTcdReset
       0   EdmaTcdSetTransferConfig
       0   Spi__Clear
       0   Spi__Disable
       0   Spi__Enable
       0   Spi__GetStatus
      16   Spi__Initialize
        16   -> DspiMasterSetBaudrate
        16   -> Micro__GetClock
      16   Spi__Read
        16   -> __aeabi_memcpy
       0   Spi__SetConfiguration
      16   Spi__Write
         0   -> DspiMasterTransferEdma
        16   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_15
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
      16  BAUD_RATE_PRESCALAR
      64  BAUD_RATE_SCALAR
      34  DspiDisable
     148  DspiMasterInit
     160  DspiMasterSetBaudrate
    1452  DspiMasterTransferEdma
      80  DspiSetConfig
      12  EdmaStartTransfer
      30  EdmaTcdReset
      48  EdmaTcdSetTransferConfig
       1  Spi0_Tx_Read
       1  Spi0_Tx_Write
      22  Spi__Clear
      16  Spi__Disable
      16  Spi__Enable
      36  Spi__GetStatus
     284  Spi__Initialize
      60  Spi__Read
       2  Spi__SetConfiguration
      64  Spi__Write
       1  dummy_data
     356  masterConfig
          transfer_config_a
          transfer_config_b
          transfer_config_c
          master_transfer
          Spi0_Busy
          Spi0_Rx_Write
          Spi0_Rx_Read
          word_to_send
          Spi0_Tx_Buffer
          Spi0_Rx_Buffer
          Spi_Master_Dma_Handle
       4  masterRxChannel
       4  masterTxChannel
       4  rxAddr
       4  tmpreg
       4  txAddr

 
   379 bytes in section .bss
 2 608 bytes in section .text
 
 2 608 bytes of CODE memory
   379 bytes of DATA memory

Errors: none
Warnings: 6
