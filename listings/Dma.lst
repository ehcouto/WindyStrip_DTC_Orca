###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        13/Mar/2025  15:31:41
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  XCategory\Driver\Dma\Dma.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        Dma.obj -l ..\listings\Dma.lst XCategory\Driver\Dma\Dma.c
#    List file    =  ..\listings\Dma.lst
#    Object file  =  Dma.obj
#
###############################################################################

C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Dma\Dma.c
      1          /**
      2           *  @file       
      3           *
      4           *  @brief      Direct memory access (DMA) is used in order to provide high-speed data transfer between
      5           *              peripherals and memory as well as memory to memory. Data can be quickly moved by DMA
      6           *              without any CPU actions. This keeps CPU resources free for other operations.
      7           *
      8           *  @details    MKV03x supports 16 channels
      9           *
     10           *  @section    Applicable_Documents
     11           *					List here all the applicable documents if needed. <tr>	
     12           *
     13           */
     14          //-------------------------------------- Include Files ----------------------------------------------------------------
     15          #include "C_Extensions.h"
     16          #include "uc.h"
     17          #include "Micro.h"
     18          #include "Dma.h"

  }DMA_INIT_TYPE;;
                 ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Dma\Dma_def.h",84  Remark[Pe381]: 
          extra ";" ignored
     19          #include "Dma_def.h"
     20          #include "Dma_prm.h"
     21          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     22          
     23          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     24          #define DMA_MAX_CHANNEL					15				//DMA Channel from DMA0 to DMA15
     25          
     26          #define DMA1_MAX_ENGINE					1
     27          //Dummy Dma channel is created to match the index of the Cortex-M3 hardware Dma channel with 'DMA_CHANNEL_TYPE'
     28          #define DMA1_CHANNEL0					(*(DMA1_CHANNEL_DEF *) NULL)
     29          
     30          
     31          #define CCR_CLEAR_MASK					((uint32)0xFFFF800F) // DMA Channel configuration registers Masks
     32          
     33          //This array holds all the Dma channel. Cortex-M3 doesn't consists of Dma channel 0. In-order to match the index of hardware Dma channel with 'DMA_CHANNEL_TYPE'
     34          // a DMA1_CHANNEL0 is added at the beginning of the array
     35          //static DMA1_CHANNEL_DEF * const DMA_CHANNEL[DMA_MAX_CHANNEL+1] =
     36          //                                                    {   &DMA1_CHANNEL0,
     37          //                                                        &DMA1_CHANNEL1,
     38          //                                                        &DMA1_CHANNEL2,
     39          //                                                        &DMA1_CHANNEL3,
     40          //                                                        &DMA1_CHANNEL4,
     41          //                                                        &DMA1_CHANNEL5
     42          //                                                    };
     43          
     44          #define FSL_FEATURE_EDMA_MODULE_CHANNEL                16
     45          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
     46          
     47          
     48          //=====================================================================================================================
     49          //-------------------------------------- Public Functions -------------------------------------------------------------
     50          //=====================================================================================================================
     51          
     52          //---------------------------------------------------------------------------------------------------------------------
     53          /**
     54           *  @brief      It Initializes the module DMA and its variables.
     55           *  @details    The engine is not enabled if its previously enabled to prevent the reset of the configuration.
     56           *
     57           */

   \                                 In section .text, align 4, keep-with-next
     58          void Dma__EngineInitialize(void)
     59           {
     60          
     61          	uint8 i;
     62          
     63          	//Enable the DMA device in the AHB bus
     64          	SIM.SCGC6 |= SIM_SCGC6_DMAMUX_MASK;									//Enable DMAMUX
   \                     Dma__EngineInitialize: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable0  ;; 0x4004803c
   \   00000002   0x....             LDR.N    R2,??DataTable0_1  ;; 0x40009004
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0x2308             MOVS     R3,#+8
     65          	SIM.SCGC7 |= SIM_SCGC7_DMA_MASK;									//Enable DMA clock
   \   0000000E   0x6841             LDR      R1,[R0, #+4]
   \   00000010   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000014   0x6041             STR      R1,[R0, #+4]
     66          
     67          	/* Init eDMA module in hardware level. */
     68          	DMA0->CR = 0x00000000;												//Clear all the flags
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x....             LDR.N    R0,??DataTable0_2  ;; 0x40008000
   \   0000001A   0x6001             STR      R1,[R0, #+0]
     69          
     70          	for (i = 0; i < FSL_FEATURE_EDMA_MODULE_CHANNEL; i++)
   \   0000001C   0xF04F 0x0C00      MOV      R12,#+0
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable0_3
     71          	{
     72          		//Clear all TCDn channel field
     73          		DMA0->TCD[i].SADDR = 0x00000000;
   \                     ??Dma__EngineInitialize_0: (+1)
   \   00000024   0xF842 0xCC04      STR      R12,[R2, #-4]
     74          		DMA0->TCD[i].SOFF = 0x0000;
   \   00000028   0xF8A2 0xC000      STRH     R12,[R2, #+0]
     75          		DMA0->TCD[i].ATTR = 0x0000;
   \   0000002C   0xF8A2 0xC002      STRH     R12,[R2, #+2]
     76          		DMA0->TCD[i].NBYTES_MLNO = 0x0000;
   \   00000030   0xF8C2 0xC004      STR      R12,[R2, #+4]
     77          		DMA0->TCD[i].SLAST = 0x00;
   \   00000034   0xF8C2 0xC008      STR      R12,[R2, #+8]
     78          		DMA0->TCD[i].DADDR = 0x00;
   \   00000038   0xF8C2 0xC00C      STR      R12,[R2, #+12]
     79          		DMA0->TCD[i].DOFF = 0x00;
   \   0000003C   0xF8A2 0xC010      STRH     R12,[R2, #+16]
     80          		DMA0->TCD[i].CITER_ELINKNO = 0x00;
   \   00000040   0xF8A2 0xC012      STRH     R12,[R2, #+18]
     81          		DMA0->TCD[i].DLAST_SGA = 0x00;
   \   00000044   0xF8C2 0xC014      STR      R12,[R2, #+20]
     82                  DMA0->TCD[i].CSR = 0;
   \   00000048   0xF8A2 0xC018      STRH     R12,[R2, #+24]
     83          
     84          //		DMA.TCD[i].CSR = DMA_CSR_ESG_MASK;
     85          		DMA0->TCD[i].BITER_ELINKNO = 0x00;
   \   0000004C   0xF8A2 0xC01A      STRH     R12,[R2, #+26]
     86          		DMAMUX->CHCFG[i] = 0x00;
   \   00000050   0xF801 0xCB01      STRB     R12,[R1], #+1
   \   00000054   0xF8C2 0xC01C      STR      R12,[R2, #+28]
   \   00000058   0xF8A2 0xC020      STRH     R12,[R2, #+32]
   \   0000005C   0xF8A2 0xC022      STRH     R12,[R2, #+34]
   \   00000060   0xF8C2 0xC024      STR      R12,[R2, #+36]
   \   00000064   0xF8C2 0xC028      STR      R12,[R2, #+40]
   \   00000068   0xF8C2 0xC02C      STR      R12,[R2, #+44]
   \   0000006C   0xF8A2 0xC030      STRH     R12,[R2, #+48]
   \   00000070   0xF8A2 0xC032      STRH     R12,[R2, #+50]
   \   00000074   0xF8C2 0xC034      STR      R12,[R2, #+52]
   \   00000078   0xF8A2 0xC038      STRH     R12,[R2, #+56]
   \   0000007C   0xF8A2 0xC03A      STRH     R12,[R2, #+58]
   \   00000080   0x3240             ADDS     R2,R2,#+64
   \   00000082   0xF801 0xCB01      STRB     R12,[R1], #+1
     87          	}
   \   00000086   0x1E5B             SUBS     R3,R3,#+1
   \   00000088   0xD1CC             BNE.N    ??Dma__EngineInitialize_0
     88          
     89          	//Set Channel Priority
     90          	DMA0->DCHPRI0 = DMA_CHPRI0 << DMA_DCHPRI0_CHPRI_SHIFT;
   \   0000008A   0x2105             MOVS     R1,#+5
   \   0000008C   0xF880 0x1103      STRB     R1,[R0, #+259]
     91          	DMA0->DCHPRI1 = DMA_CHPRI1 << DMA_DCHPRI1_CHPRI_SHIFT;
   \   00000090   0x2101             MOVS     R1,#+1
   \   00000092   0xF880 0x1102      STRB     R1,[R0, #+258]
     92          	DMA0->DCHPRI2 = DMA_CHPRI2 << DMA_DCHPRI2_CHPRI_SHIFT;
   \   00000096   0x2102             MOVS     R1,#+2
   \   00000098   0xF880 0x1101      STRB     R1,[R0, #+257]
     93          	DMA0->DCHPRI3 = DMA_CHPRI3 << DMA_DCHPRI3_CHPRI_SHIFT;
   \   0000009C   0x2103             MOVS     R1,#+3
   \   0000009E   0xF880 0x1100      STRB     R1,[R0, #+256]
     94          	DMA0->DCHPRI4 = DMA_CHPRI4 << DMA_DCHPRI4_CHPRI_SHIFT;
   \   000000A2   0x2104             MOVS     R1,#+4
   \   000000A4   0xF880 0x1107      STRB     R1,[R0, #+263]
     95          	DMA0->DCHPRI5 = DMA_CHPRI5 << DMA_DCHPRI5_CHPRI_SHIFT;
   \   000000A8   0xF880 0xC106      STRB     R12,[R0, #+262]
     96          	DMA0->DCHPRI6 = DMA_CHPRI6 << DMA_DCHPRI6_CHPRI_SHIFT;
   \   000000AC   0x2106             MOVS     R1,#+6
   \   000000AE   0xF880 0x1105      STRB     R1,[R0, #+261]
     97          	DMA0->DCHPRI7 = DMA_CHPRI7 << DMA_DCHPRI7_CHPRI_SHIFT;
   \   000000B2   0x2107             MOVS     R1,#+7
   \   000000B4   0xF880 0x1104      STRB     R1,[R0, #+260]
     98          	DMA0->DCHPRI8 = DMA_CHPRI8 << DMA_DCHPRI8_CHPRI_SHIFT;
   \   000000B8   0x2108             MOVS     R1,#+8
   \   000000BA   0xF880 0x110B      STRB     R1,[R0, #+267]
     99          	DMA0->DCHPRI9 = DMA_CHPRI9 << DMA_DCHPRI9_CHPRI_SHIFT;
   \   000000BE   0x2109             MOVS     R1,#+9
   \   000000C0   0xF880 0x110A      STRB     R1,[R0, #+266]
    100          	DMA0->DCHPRI10 = DMA_CHPRI10 << DMA_DCHPRI10_CHPRI_SHIFT;
   \   000000C4   0x210A             MOVS     R1,#+10
   \   000000C6   0xF880 0x1109      STRB     R1,[R0, #+265]
    101          	DMA0->DCHPRI11 = DMA_CHPRI11 << DMA_DCHPRI11_CHPRI_SHIFT;
   \   000000CA   0x210B             MOVS     R1,#+11
   \   000000CC   0xF880 0x1108      STRB     R1,[R0, #+264]
    102          	DMA0->DCHPRI12 = DMA_CHPRI12 << DMA_DCHPRI12_CHPRI_SHIFT;
   \   000000D0   0x210C             MOVS     R1,#+12
   \   000000D2   0xF880 0x110F      STRB     R1,[R0, #+271]
    103          	DMA0->DCHPRI13 = DMA_CHPRI13 << DMA_DCHPRI13_CHPRI_SHIFT;
   \   000000D6   0x210D             MOVS     R1,#+13
   \   000000D8   0xF880 0x110E      STRB     R1,[R0, #+270]
    104          	DMA0->DCHPRI14 = DMA_CHPRI14 << DMA_DCHPRI14_CHPRI_SHIFT;
   \   000000DC   0x210E             MOVS     R1,#+14
   \   000000DE   0xF880 0x110D      STRB     R1,[R0, #+269]
    105          	DMA0->DCHPRI15 = DMA_CHPRI15 << DMA_DCHPRI15_CHPRI_SHIFT;
   \   000000E2   0x210F             MOVS     R1,#+15
   \   000000E4   0xF880 0x110C      STRB     R1,[R0, #+268]
    106          }
   \   000000E8   0x4770             BX       LR               ;; return
    107          
    108          //---------------------------------------------------------------------------------------------------------------------
    109          /**
    110            * @brief  Initializes the Dma channel according to the specified parameters
    111            *         in the DMA_InitStruct.
    112            * @param  channel: Defines the specific Dma channel from the DMA_CHANNEL_TYPE
    113            * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that contains
    114            *         the configuration information for the specified DMA Channel.
    115            * @retval DMA_RETURN_TYPE
    116           *      @retval DMA_RETURN_FAIL(0)      : Dma channel was fail to initialize
    117           *      @retval DMA_RETURN_SUCCESS(1)   : Dma channel was successfully initialized
    118            */

   \                                 In section .text, align 2, keep-with-next
    119          DMA_RETURN_TYPE Dma__Initialize(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel, DMA_INIT_TYPE* DMA_InitStruct)
    120          {
    121          
    122          #if 0
    123              DMA_RETURN_TYPE ret;
    124          
    125              ret = DMA_RETURN_FAIL;
    126          
    127              if ((channel <= DMA_MAX_CHANNEL) && (channel))
    128              {
    129          		//Set the channel in Arbitration or pripority mode
    130          		#if (CHANNEL_ARBITRATION == 1)
    131          			DMA.CR |= DMA_CR_ERCA_MASK;									//Round Robin Arbitration is used for channel selection
    132          		#else
    133          			DMA.CR &= ~(DMA_CR_ERCA_MASK); 								//Fixed Priority Arbitration is used for channel selection
    134          		#endif
    135          
    136          		//Clear the source and enable bit
    137                  Dma__Disable(dma_engine, channel);
    138          
    139          		DMA.EEI = 0x00000000;											//Enable Error Interrupt register - '0'
    140          		DMA.CDNE |= DMA_CDNE_NOP_MASK;									//No operation, ignore the other bits in this DMA_CDNE register
    141          		DMA.SSRT |= DMA_SSRT_NOP_MASK;									//No operation, ignore the other bits in this DMA_SSRT register
    142          
    143          
    144          
    145          
    146          //        DMA.TCD[channel].BITER_ELINKNO = 4;
    147          //        DMA.TCD[channel].CITER_ELINKNO = 4;
    148          //        DMA.TCD[channel].NBYTES_MLNO = 0;                               // Write to DMA Channel Counter
    149          //        DMA.TCD[channel].SADDR = DMA_InitStruct->DMA_MemBaseAddr;       // Write to DMA Channel SADDR
    150          //        DMA.TCD[channel].SOFF = 1;
    151          //
    152          ////      if (DMA_InitStruct->DMA_PeriDataSize == DMA_DATA_WIDTH_HALFWORD)
    153          //        {
    154          //            DMA.TCD[channel].ATTR |= 0 << DMA_ATTR_SSIZE_SHIFT;
    155          //        }
    156          ////      else if (DMA_InitStruct->DMA_PeriDataSize == DMA_DATA_WIDTH_WORD)
    157          ////      {
    158          ////          DMA.TCD[channel].ATTR |= 1 << DMA_ATTR_SSIZE_SHIFT;
    159          ////      }
    160          //        DMA.TCD[channel].SLAST = 1;
    161          //
    162          //        DMA.TCD[channel].DADDR = DMA_InitStruct->DMA_PeriBaseAddr;      // Write to DMA Channel DADDR
    163          //        DMA.TCD[channel].DOFF = 0;
    164          //
    165          ////      if (DMA_InitStruct->DMA_PeriDataSize == DMA_DATA_WIDTH_HALFWORD)
    166          //        {
    167          //            DMA.TCD[channel].ATTR |= 0 << DMA_ATTR_DSIZE_SHIFT;
    168          //        }
    169          ////      else if (DMA_InitStruct->DMA_PeriDataSize == DMA_DATA_WIDTH_WORD)
    170          ////      {
    171          ////          DMA.TCD[channel].ATTR |= 1 << DMA_ATTR_DSIZE_SHIFT;
    172          ////      }
    173          //
    174          //        DMAMUX.CHCFG[channel].BIT.SOURCE = DMA_InitStruct->DMA_Mux_Source;
    175          //
    176          //        DMA.TCD[channel].DLAST_SGA = 1;
    177          //        ret = DMA_RETURN_SUCCESS;
    178          //
    179          //
    180          //
    181          //
    182          
    183          //		if (DMA_DATA_DIRECTION_PERIPH_TO_MEM)
    184          //		{
    185          //	        DMA_SADDR_REG(DMA_BASE_PTR, channel)          = DMA_InitStruct->DMA_PeriBaseAddr;                  // Source address
    186          //	        DMA_DADDR_REG(DMA_BASE_PTR, channel)          = DMA_InitStruct->DMA_MemBaseAddr;                   // Destination address
    187          //		}
    188          //		else
    189          //		{
    190          //            DMA_SADDR_REG(DMA_BASE_PTR, channel)          = DMA_InitStruct->DMA_MemBaseAddr;                    // Source address
    191          //            DMA_DADDR_REG(DMA_BASE_PTR, channel)          = DMA_InitStruct->DMA_PeriBaseAddr;                   // Destination address
    192          //		}
    193          //
    194          //
    195          //        DMA_SOFF_REG(DMA_BASE_PTR, channel)           = 1;                                                  // Source address increments by number of bytes per transfer
    196          //        DMA_SLAST_REG(DMA_BASE_PTR, channel)          = 0;                                                  // After the major loop ends, reset pointer to beginning of buffer
    197          //        DMA_DOFF_REG(DMA_BASE_PTR, channel)           = 0x0;                                                // Destination offset increments 0 bytes (uint32)
    198          //        DMA_DLAST_SGA_REG(DMA_BASE_PTR, channel)      = 0;                                                  // Destination address shift
    199          //        DMA_NBYTES_MLNO_REG(DMA_BASE_PTR, channel)    = 0;                                                  // The minor loop moves 32 bytes per transfer
    200          //        DMA_BITER_ELINKNO_REG(DMA_BASE_PTR, channel)  = 1;                                                  // Major loop iterations
    201          //        DMA_CITER_ELINKNO_REG(DMA_BASE_PTR, channel)  = 1;                                                  // Set current iteration count
    202          //        DMA_ATTR_REG(DMA_BASE_PTR, channel)           = (DMA_ATTR_SSIZE(0) | DMA_ATTR_DSIZE(0));            // Source a destination size 0:8bit; 1:16-bit, 2:32-bit, 5:16-byte, 6:32-byte
    203          //        //DMA_CSR_REG(DMA_BASE_PTR, channel)            = DMA_CSR_INTMAJOR_MASK | DMA_CSR_DREQ_MASK;        // Enable end of loop DMA interrupt; clear ERQ @ end of major iteration
    204          //
    205          //        // Configure the DMAMUX to link the desired DMA channel to the peripheral request
    206          //        DMAMUX_CHCFG_REG(DMAMUX_BASE_PTR,channel)    = (DMAMUX_CHCFG_ENBL_MASK | DMAMUX_CHCFG_SOURCE(DMA_InitStruct->DMA_Mux_Source));     // DMA source DMA Mux
    207          
    208          
    209                      if (DMA_InitStruct->DMA_DIR == DMA_DATA_DIRECTION_PERIPH_TO_MEM)
    210                      {
    211                         DMA_SADDR_REG(DMA_BASE_PTR, channel)          = DMA_InitStruct->DMA_PeriBaseAddr;                  // Source address
    212                         DMA_DADDR_REG(DMA_BASE_PTR, channel)          = DMA_InitStruct->DMA_MemBaseAddr;                   // Destination address
    213                         DMA_SOFF_REG(DMA_BASE_PTR, channel)           = 0;                                                  // Source address increments by number of bytes per transfer
    214                         DMA_SLAST_REG(DMA_BASE_PTR, channel)          = 0;                                                  // After the major loop ends, reset pointer to beginning of buffer
    215                         DMA_DOFF_REG(DMA_BASE_PTR, channel)           = 1;                                                  // Destination offset increments 0 bytes (uint32)
    216                         DMA_DLAST_SGA_REG(DMA_BASE_PTR, channel)      = 0;                                                  // Destination address shift
    217                      }
    218                      else
    219                      {
    220                          DMA_SADDR_REG(DMA_BASE_PTR, channel)          = DMA_InitStruct->DMA_MemBaseAddr;                    // Source address
    221                          DMA_DADDR_REG(DMA_BASE_PTR, channel)          = DMA_InitStruct->DMA_PeriBaseAddr;                   // Destination address
    222                          DMA_SOFF_REG(DMA_BASE_PTR, channel)           = 1;                                                  // Source address increments by number of bytes per transfer
    223                          DMA_DOFF_REG(DMA_BASE_PTR, channel)           = 0;                                                  // Destination offset increments 0 bytes (uint32)
    224                          DMA_SLAST_REG(DMA_BASE_PTR, channel)          = 0;                                                  // After the major loop ends, reset pointer to beginning of buffer
    225                          DMA_DLAST_SGA_REG(DMA_BASE_PTR, channel)      = 0;                                                  // Destination address shift
    226                      }
    227          
    228                      DMA_NBYTES_MLNO_REG(DMA_BASE_PTR, channel)    = 0;                                                  // The minor loop moves 32 bytes per transfer
    229                      DMA_BITER_ELINKNO_REG(DMA_BASE_PTR, channel)  = 1;                                                  // Major loop iterations
    230          
    231                      DMA_BITER_ELINKNO_REG(DMA_BASE_PTR, channel)  = DMA_BITER_ELINKNO_BITER(1);                             // Major loop iterations
    232                      DMA_CITER_ELINKNO_REG(DMA_BASE_PTR, channel)  = DMA_CITER_ELINKNO_CITER(1);                             // Set current iteration count
    233                      DMA_ATTR_REG(DMA_BASE_PTR, channel)           = (DMA_ATTR_SSIZE(0) | DMA_ATTR_DSIZE(0));            // Source a destination size 0:8bit; 1:16-bit, 2:32-bit, 5:16-byte, 6:32-byte
    234          
    235                      //DMA_CSR_REG(DMA_BASE_PTR, channel)            = DMA_CSR_INTMAJOR_MASK | DMA_CSR_DREQ_MASK;        // Enable end of loop DMA interrupt; clear ERQ @ end of major iteration
    236          
    237                      // Configure the DMAMUX to link the desired DMA channel to the peripheral request
    238          //            DMAMUX_CHCFG_REG(DMAMUX_BASE_PTR,channel)    = (DMAMUX_CHCFG_ENBL_MASK | DMAMUX_CHCFG_SOURCE(DMA_InitStruct->DMA_Mux_Source));     // DMA source DMA Mux
    239                      DMAMUX_CHCFG_REG(DMAMUX_BASE_PTR,channel)    = (DMAMUX_CHCFG_SOURCE(DMA_InitStruct->DMA_Mux_Source));     // DMA source DMA Mux
    240                      ret = DMA_RETURN_SUCCESS;
    241          	}
    242          
    243              return (ret);
    244          
    245          #endif
    246          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "Dma__Initialize"

  DMA_RETURN_TYPE Dma__Initialize(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel, DMA_INIT_TYPE* DMA_InitStruct)
                                                  ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Dma\Dma.c",119  Remark[Pe826]: 
          parameter "dma_engine" was never referenced

  DMA_RETURN_TYPE Dma__Initialize(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel, DMA_INIT_TYPE* DMA_InitStruct)
                                                                               ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Dma\Dma.c",119  Remark[Pe826]: 
          parameter "channel" was never referenced

  DMA_RETURN_TYPE Dma__Initialize(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel, DMA_INIT_TYPE* DMA_InitStruct)
                                                                                                       ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Dma\Dma.c",119  Remark[Pe826]: 
          parameter "DMA_InitStruct" was never referenced
   \                     Dma__Initialize: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    247          
    248          //---------------------------------------------------------------------------------------------------------------------
    249          /**
    250           * @brief    Starts the Dma transfer.
    251           * @details  Before calling this Channel should be initialized by calling Dma__Initialize() API
    252           * @param    channel: Defines the specific Dma channel from the DMA_CHANNEL_TYPE
    253           * @param    DataNumber  : Number of data to be transfer
    254           * @return   BOOL_TYPE
    255           *      @retval TRUE : Dma data transfer started.
    256           *      @retval FALSE: Dma data transfer failed.
    257           */

   \                                 In section .text, align 2, keep-with-next
    258          BOOL_TYPE Dma__StartTransfer(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel, DMA_SIZE_TYPE DataNumber)
    259          {
    260          
    261          #if 0
    262              BOOL_TYPE status;
    263          
    264              status = FALSE;
    265          
    266              if ((channel <= DMA_MAX_CHANNEL) && (channel))
    267              {
    268          
    269          			if (channel == DMA_CH5)
    270          			{
    271          				DMA.TCD[channel].SLAST = -DataNumber;   //it uses 2's complement
    272                          DMA.TCD[channel].DLAST_SGA = -0; //it uses 2's complement
    273          			}
    274          			if (channel == DMA_CH4)
    275          			{
    276                          DMA.TCD[channel].SLAST = -0;   //it uses 2's complement
    277          				DMA.TCD[channel].DLAST_SGA = -DataNumber; //it uses 2's complement
    278          			}
    279          
    280          			DMA.TCD[channel].NBYTES_MLNO = DataNumber; 				//Set the data size to be transfered
    281          
    282          //            DMA_BITER_ELINKNO_REG(DMA_BASE_PTR, channel)  = DMA_BITER_ELINKNO_BITER(1);                             // Major loop iterations
    283          //            DMA_CITER_ELINKNO_REG(DMA_BASE_PTR, channel)  = DMA_CITER_ELINKNO_CITER(1);                             // Set current iteration count
    284          
    285          			Dma__Enable(dma_engine,channel);
    286                      DMA.TCD[channel].CSR |= DMA_CSR_START_MASK;             // Software Trigger to initiate the transfer
    287          
    288          			status = TRUE;
    289          	}
    290          
    291                return (status);
    292          
    293          #endif
    294          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "Dma__StartTransfer"

  BOOL_TYPE Dma__StartTransfer(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel, DMA_SIZE_TYPE DataNumber)
                                               ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Dma\Dma.c",258  Remark[Pe826]: 
          parameter "dma_engine" was never referenced

  BOOL_TYPE Dma__StartTransfer(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel, DMA_SIZE_TYPE DataNumber)
                                                                            ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Dma\Dma.c",258  Remark[Pe826]: 
          parameter "channel" was never referenced

  BOOL_TYPE Dma__StartTransfer(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel, DMA_SIZE_TYPE DataNumber)
                                                                                                   ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Dma\Dma.c",258  Remark[Pe826]: 
          parameter "DataNumber" was never referenced
   \                     Dma__StartTransfer: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    295          
    296          //---------------------------------------------------------------------------------------------------------------------
    297          /**
    298           * @brief    Stops the Dma transfer.
    299           * @details
    300           * @param  channel: Defines the specific Dma channel from the DMA_CHANNEL_TYPE
    301           */

   \                                 In section .text, align 2, keep-with-next
    302          void Dma__StopTransfer(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel)
                                                        ^
Remark[Pe826]: parameter "dma_engine" was never referenced

  void Dma__StopTransfer(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel)
                                                                      ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Dma\Dma.c",302  Remark[Pe826]: 
          parameter "channel" was never referenced
    303          {
    304          #if 0
    305          	if ((channel <= DMA_MAX_CHANNEL) && (channel))
    306          	{
    307          		DMA.TCD[channel].CSR &= (~DMA_CSR_START_MASK); 		//Disable the DMA channel to initiate the new transfer
    308          		DMA.TCD[channel].NBYTES_MLNO = 0; 					//Set the data size to be transfered
    309          	}
    310          #endif
    311          }
   \                     Dma__StopTransfer: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    312          
    313          //---------------------------------------------------------------------------------------------------------------------
    314          /**
    315            * @brief  Enables the specified DMA channel
    316            * @param  channel: Defines the specific Dma channel from the DMA_CHANNEL_TYPE
    317            */

   \                                 In section .text, align 2, keep-with-next
    318          void Dma__Enable(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel)
                                                  ^
Remark[Pe826]: parameter "dma_engine" was never referenced

  void Dma__Enable(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel)
                                                                ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Dma\Dma.c",318  Remark[Pe826]: 
          parameter "channel" was never referenced
    319          {
    320          #if 0
    321              if ((channel <= DMA_MAX_CHANNEL) &&
    322                  (channel))
    323              {
    324              	DMA.SERQ = channel & DMA_SERQ_SERQ_MASK;
    325          //    	DMA.ERQ |= 1<< channel;           		//The DMA request signal for the corresponding channel is enabled
    326          //    	DMA.INT |= 1<< channel;
    327          
    328                  DMAMUX.CHCFG[channel].BIT.ENBL = TRUE;
    329              }
    330          
    331          #endif
    332          }
   \                     Dma__Enable: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    333          
    334          //---------------------------------------------------------------------------------------------------------------------
    335          /**
    336            * @brief  Disables the specified DMAy Channelx.
    337            * @param  channel: Defines the specific Dma channel from the DMA_CHANNEL_TYPE
    338            */

   \                                 In section .text, align 2, keep-with-next
    339          void Dma__Disable(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel)
                                                   ^
Remark[Pe826]: parameter "dma_engine" was never referenced

  void Dma__Disable(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel)
                                                                 ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Dma\Dma.c",339  Remark[Pe826]: 
          parameter "channel" was never referenced
    340          {
    341          #if 0
    342              if ((channel <= DMA_MAX_CHANNEL) && (channel))
    343              {
    344              	DMAMUX.CHCFG[channel].BIT.ENBL = FALSE;
    345              	DMA.ERQ |= 0<< channel;              //The DMA request signal for the corresponding channel is disabled
    346              }
    347          
    348          #endif
    349          }
   \                     Dma__Disable: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    350          
    351          //---------------------------------------------------------------------------------------------------------------------
    352          /**
    353            * @brief  Returns the number of remaining data units in the current
    354            *         DMAy Channelx transfer.
    355            * @param  channel: Defines the specific Dma channel from the DMA_CHANNEL_TYPE
    356            * @retval The number of remaining data units in the current DMAy Channelx
    357            *         transfer.
    358            */

   \                                 In section .text, align 2, keep-with-next
    359          DMA_SIZE_TYPE Dma__GetCurrDataCounter(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel)
    360           {
    361          #if 0
    362          
    363          	DMA_SIZE_TYPE ret;
    364          
    365          	ret = 0;
    366          
    367          	if ((channel <= DMA_MAX_CHANNEL) && (channel))
    368          	{
    369          		//Return the number of remaining data units for DMAy Channelx
    370          		return ((DMA_SIZE_TYPE) (DMA.TCD[channel].NBYTES_MLNO));
    371          	}
    372          	else
    373          	{
    374          		return (ret);
    375          	}
    376          #endif
    377          
    378          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "Dma__GetCurrDataCounter"

  DMA_SIZE_TYPE Dma__GetCurrDataCounter(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel)
                                                        ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Dma\Dma.c",359  Remark[Pe826]: 
          parameter "dma_engine" was never referenced

  DMA_SIZE_TYPE Dma__GetCurrDataCounter(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel)
                                                                                     ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Dma\Dma.c",359  Remark[Pe826]: 
          parameter "channel" was never referenced
   \                     Dma__GetCurrDataCounter: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    379          
    380          //---------------------------------------------------------------------------------------------------------------------
    381          /**
    382            * @brief  Returns the status of the specified Dma channel.
    383            * @param  channel: Defines the specific Dma channel from the DMA_CHANNEL_TYPE
    384            * @retval DMA_TRANSFER_STATUS_TYPE-
    385            *      @retval DMA_TRANSFER_IDLE      : Dma channel is in idle state
    386            *      @retval DMA_TRANSFER_ERROR     : Dma channel encountered data transfer error
    387            *      @retval DMA_TRANSFER_ONGOING   : Dma channel is transferring data
    388            *      @retval DMA_TRANSFER_COMPLETE  : Dma channel completed data transfer
    389            */

   \                                 In section .text, align 2, keep-with-next
    390          DMA_TRANSFER_STATUS_TYPE Dma__GetFlagStatus(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel)
    391          {
    392          
    393          #if 0
    394              DMA_TRANSFER_STATUS_TYPE status;
    395              uint16 csr_status;
    396          
    397              status = DMA_TRANSFER_IDLE;
    398              csr_status = 0;
    399              csr_status = DMA.TCD[channel].CSR;
    400          
    401              if ((channel <= DMA_MAX_CHANNEL) && (channel))
    402              {
    403          //        if ((DMA_CHANNEL[channel]->CNDTR) != 0)
    404             	  if((csr_status & DMA_CSR_ACTIVE_MASK) != 0)		//Check Channel is currently in execution
    405                  {
    406                      status = DMA_TRANSFER_ONGOING;
    407                  }
    408                  // Check the status of the specified DMA flag
    409          //        else if ((DMA1.ISR & (DMA_ISR_TEIF1 <<channel*4)) != FALSE)
    410          //        {
    411          //            status = DMA_TRANSFER_ERROR;
    412          //        }
    413                  else if ((csr_status & DMA_CSR_DONE_MASK) != FALSE)		//eDMA has completed the major loop
    414                  {
    415                      status = DMA_TRANSFER_COMPLETE;
    416                  }
    417          
    418                  //Clear all the flags
    419                  DMA.TCD[channel].CSR =0x0000;
    420              }
    421          
    422              // Return the DMA_FLAG status
    423              return  status;
    424          
    425          #endif
    426          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "Dma__GetFlagStatus"

  DMA_TRANSFER_STATUS_TYPE Dma__GetFlagStatus(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel)
                                                              ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Dma\Dma.c",390  Remark[Pe826]: 
          parameter "dma_engine" was never referenced

  DMA_TRANSFER_STATUS_TYPE Dma__GetFlagStatus(DMA_ENGINE_TYPE dma_engine, DMA_CHANNEL_TYPE channel)
                                                                                           ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Dma\Dma.c",390  Remark[Pe826]: 
          parameter "channel" was never referenced
   \                     Dma__GetFlagStatus: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x40009004         DC32     0x40009004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   0x40008000         DC32     0x40008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_3:
   \   00000000   0x40021000         DC32     0x40021000
    427          
    428          //=====================================================================================================================
    429          //-------------------------------------- Private Functions ------------------------------------------------------------
    430          //=====================================================================================================================
    431          
    432          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Dma__Disable
       0   Dma__Enable
       0   Dma__EngineInitialize
       0   Dma__GetCurrDataCounter
       0   Dma__GetFlagStatus
       0   Dma__Initialize
       0   Dma__StartTransfer
       0   Dma__StopTransfer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       4  ??DataTable0_3
       2  Dma__Disable
       2  Dma__Enable
     234  Dma__EngineInitialize
       2  Dma__GetCurrDataCounter
       2  Dma__GetFlagStatus
       2  Dma__Initialize
       2  Dma__StartTransfer
       2  Dma__StopTransfer

 
 264 bytes in section .text
 
 264 bytes of CODE memory

Errors: none
Warnings: 4
