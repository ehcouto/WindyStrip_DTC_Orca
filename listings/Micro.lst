###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        13/Mar/2025  15:31:43
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  XCategory\Driver\Micro\Micro.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        Micro.obj -l ..\listings\Micro.lst XCategory\Driver\Micro\Micro.c
#    List file    =  ..\listings\Micro.lst
#    Object file  =  Micro.obj
#
###############################################################################

C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Micro\Micro.c
      1          /**
      2           *  @file
      3           *  @defgroup   CLASS_B
      4           *
      5           *  @brief      This module implements the standard API (Application Programming Interface) for
      6           *              Freescale Kintes Motor control series MKV03x Micro module.
      7           *
      8           *  @details    This module provides the interface to the application to configure the controller and to perform the
      9           *              CLASSB safety relevant controller tests.
     10           *
     11           *              Configuring the Controller such as-
     12           *              Initializing microcontroller bus clock, configuring clock for microcontroller,
     13           *              Configures the controller to work either in slow, normal or sleep mode of operation,
     14           *              servicing Window and Independent watchdog,
     15           *              enabling/disabling or store/restoring of the interrupts,
     16           *              Providing FLASH size ,RAM size and ID of microcontroller,
     17           *              provision to detect Low voltage.
     18           *
     19           *              CLASS B safety-relevant controller test during boot as well as run time such as -
     20           *              CPU Register Test,
     21           *              Watchdog test,
     22           *              RAM test,
     23           *              Flash test
     24           *              stack test
     25           *
     26           *  $Header: Micro.c 1.5 2015/08/21 13:56:18EDT Natak Rahul (NATAKRB) Exp  $
     27           *
     28           *  @copyright  Copyright 2011-$Date: 2015/08/21 13:56:18EDT $. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     29           */
     30          //-------------------------------------- Include Files ----------------------------------------------------------------
     31          #include "C_Extensions.h"
     32          #include "uc.h"
     33          #include "Micro.h"
     34          #include "Micro_prv.h"
     35          #include "SRSystemConfig.h"
     36          #include "SRException.h"
     37          #include "Crc8.h"
     38          #include "string.h"
     39          #include "SRData.h"
     40          
     41          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     42          //---------------------------------------------------------------------------------------------------------------------
     43          /**
     44           *    @brief  - Defines the Enabling or disabling of the Safety relevant test features
     45           *    @details-
     46           *
     47           *    Below are the tests to be performed during boot and run-time -
     48           *    CPU Register test,
     49           *    Stack Test
     50           *    RAM Test(at boot time)
     51           *    Flash Test
     52           *    Watchdog Test
     53           *
     54           *    @param  - ENABLED(1)    - Which Enables the ClassB Test. ClassB software shall enable this macro
     55           *              DISABLED(0)   – Which Disables the ClassB Test. ClassA software can disables this macro
     56           *
     57           *    @note -   "#define MICRO_SR_FEATURE_TEST                   ENABLED"
     58           *              "#define MICRO_SR_FEATURE_TEST                   DISABLED"
     59           */
     60          #if (CLASSB_FEATURE == ENABLED)
     61              #ifndef MICRO_SR_FEATURE_TEST
     62                  #define MICRO_SR_FEATURE_TEST                               ENABLED
     63              #endif
     64          #else
     65              #ifndef MICRO_SR_FEATURE_TEST
     66                  #define MICRO_SR_FEATURE_TEST                               DISABLED
     67              #endif
     68          #endif
     69          
     70          //---------------------------------------------------------------------------------------------------------------------
     71          //Memory alignment access protection
     72          //Mis aligned access across 0x2000000 boundary are not supported in the ARM Cortex Architecture
     73          #pragma location=0x1FFFFFFC

   \                                 In section .bss, at 0x1ffffffc, root
   \   00000000                      DS8 4
     74          static __root uint32 Ram0_Page_End_Protection;
     75          
     76          #pragma location=0x20000000

   \                                 In section .bss, at 0x20000000, root
   \   00000000                      DS8 4
     77          static __root uint32 Ram1_Page_Start_Protection;
     78          
     79          //---------------------------------------------------------------------------------------------------------------------
     80          /**
     81           *    @brief  - Option Bit/ Fuse Bit /Flash Configuration Fields
     82           *    @details- This configurations are programmed at the location of 0x400 to till 0x40F.
     83           *              The contents are loaded at the boot time by the micro internal code into the appropriate registers
     84           *
     85           *              Some of the Configurations are forced to default configurations
     86           *
     87           */
     88          PACKED typedef struct
                        ^
Remark[Pe082]: storage class is not first
     89          {
     90              /**
     91               * @brief If the project decided to secure the flash memory access then they shall define the Access Key
     92               */
     93              uint8 BackDoor_Access_Key[8];
     94          
     95              /**
     96               * @brief Define which program flash regions are protected from program and erase operations.
     97               * Protected flash regions cannot have their content changed; that is, these regions cannot be programmed and cannot be erased.
     98               * Unprotected regions can be changed by program and erase operations.
     99               *
    100               * This feature is disabled as we do not have a requirement or use case to protect the selective Flash regions from program and erase operations
    101               */
    102              uint32 Flash_Protection_Regions;
    103          
    104              /**
    105               * @brief - Flash Security
    106               *
    107               * KEYEN - Back door key access is Enabled or Disabled
    108               * Bit 7-6          : 11 Backdoor key access disabled
    109               *                  : 10 Backdoor key access enabled
    110               *
    111               * Mass Erase Enable
    112               * Bit 5-4          : 11 Mass erase is enabled
    113               *
    114               * Factory Security Level Access Code Granted
    115               * Bit 3-2          : 11 Factory access granted
    116               *
    117               * Flash Security
    118               * Bit 1-0          : 10 MCU security status is unsecure
    119               *
    120               */
    121              uint8 Security;
    122          
    123              /**
    124               * @brief Allows the user to customize the operation of the MCU at boot time.
    125               *
    126               * Boot From Flash Memory
    127               * Bit 7 BOOTSRC_SEL    - 0
    128               * Bit 1 BOOTPIN_OPT    - 1
    129               *
    130               *
    131               * Below are reserved and written as 1 by default
    132               * Bit 6 - 4            - 1
    133               *
    134               *
    135               * RESET PIN Configuration - RESET_b pin is dedicated. The port is configured with pullup enabled, open drain, passive filter enabled.
    136               * Bit 3 RESET_PIN_CFG  - 1
    137               *
    138               *
    139               * Disable the NMI interrupts generated by the dedicated pin -
    140               * The associated pin continues to default to NMI_b pin controls with internal pullup enabled. When NMI_b pin function is
    141               * disabled, it cannot be used as a source for low-power mode wake-up.
    142               * If the NMI function is not required, either for an interrupt or wake up source, it is
    143               * recommended that the NMI function be disabled by clearing NMI_DIS.
    144               * Bit 2 NMI_DIS        - 0
    145               *
    146               *
    147               * LPBOOT - Normal boot: Core and system clock divider (DIVCORE) is 0x0 (divide by 1).
    148               * Bit 0                - 1
    149               *
    150               */
    151              uint8 Boot_options;
    152          
    153              /**
    154               * @brief The FEPROT register defines which EEPROM regions of the FlexRAM are protected against program and erase operations.
    155               * Protected EEPROM regions cannot have their content changed by writing to it.
    156               * Unprotected regions can be changed by writing to the FlexRAM.
    157               *
    158               * This feature is disabled as we do not have a requirement or use case to protect the EEPROM regions from program and erase operations
    159               */
    160              uint8 EEPROM_Protection;
    161          
    162              /**
    163               * @brief Defines which data flash regions are protected against program and erase operations.
    164               * Protected Flash regions cannot have their content changed; that is, these regions cannot be programmed and cannot be erased.
    165               * Unprotected regions can be changed by both program and erase operations.
    166               *
    167               * This feature is disabled as we do not have a requirement or use case to protect the Data Flash regions from program and erase operations
    168               */
    169              uint8 DataFlash_Protection;
    170          } MICRO_FLASH_CONFIGURATION_TYPE;
    171          
    172          
    173          //---------------------------------------------------------------------------------------------------------------------
    174          /**
    175           *    @brief  - Enable or Disable the Flash security by back door key access
    176           *    @details- If this feature is enabled then the micro can be programmed or read the Flash memory only by providing the correct access key
    177           *
    178           *    The Access key is defined in the MICRO_FLASH_CONFIGURATION_BACKDOOR_ACCESS_KEY macro
    179           *
    180           *    By default disabling this feature
    181           */
    182          #ifndef MICRO_FLASH_SECUTIRY_BY_BACK_DOOR_KEY_ACCESS_FEATURE
    183              #define MICRO_FLASH_SECUTIRY_BY_BACK_DOOR_KEY_ACCESS_FEATURE        DISABLED
    184          #endif
    185          
    186          //---------------------------------------------------------------------------------------------------------------------
    187          /**
    188           *    @brief  - Flash Access key to secure the Flash read
    189           *    @details- The key shall be of 8 bytes only
    190           *              The feature is disabled if all the bits of the key are either 0 or 1
    191           *
    192           *              Default value will be as below which disables the feature
    193           *              #define MICRO_FLASH_CONFIGURATION_BACKDOOR_ACCESS_KEY       {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}
    194           *
    195           */
    196          #if (MICRO_FLASH_SECUTIRY_BY_BACK_DOOR_KEY_ACCESS_FEATURE == ENABLED)
    197              #ifndef MICRO_FLASH_CONFIGURATION_BACKDOOR_ACCESS_KEY
    198                  #error : "User shall define the MICRO_FLASH_CONFIGURATION_BACKDOOR_ACCESS_KEY if the MICRO_FLASH_SECUTIRY_BY_BACK_DOOR_KEY_ACCESS_FEATURE is ENABLED";
    199              #endif
    200          #endif
    201          
    202          #ifndef MICRO_FLASH_CONFIGURATION_BACKDOOR_ACCESS_KEY
    203              #define MICRO_FLASH_CONFIGURATION_BACKDOOR_ACCESS_KEY       {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}
    204          #endif
    205          
    206          //!  Allows all the Flash regions to be re-programmed
    207          #define MICRO_FLASH_CONFIGURATION_FLASH_PROTECTION_REGIONS      ((uint32)0xFFFFFFFF)
    208          
    209          //!  Allows Data Flash regions to be re-programmed
    210          #define MICRO_FLASH_CONFIGURATION_DATAFLASH_PROTECTION          ((uint8)0xFF)
    211          
    212          //!  Allows EEPROM regions to be re-programmed
    213          #define MICRO_FLASH_CONFIGURATION_EEPROM_PROTECTION             ((uint8)0xFF)
    214          
    215          //! Boot From Flash Memory,
    216          //! Dedicated Reset Pin can not be used for alternate purpose
    217          //! Disable NMI interrupt generation from the pin
    218          //! Normal Boot
    219          #define MICRO_FLASH_CONFIGURATION_BOOT_OPTION                   ((uint8)0x7B)
    220          
    221          #if (MICRO_FLASH_SECUTIRY_BY_BACK_DOOR_KEY_ACCESS_FEATURE == DISABLED)
    222              #define MICRO_FLASH_SECURITY                                ((uint8)0xFE)
    223          #else
    224              #define MICRO_FLASH_SECURITY                                ((uint8)0xBE)
    225          #endif
    226          
    227          #pragma location = "FlashConfig"

   \                                 In section FlashConfig, align 4, root
   \   00000000   0xFF 0xFF          DC8 255, 255, 255, 255, 255, 255, 255, 255
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \   00000008   0xFFFFFFFF         DC32 4294967295
   \   0000000C   0xFE 0x7B          DC8 254, 123, 255, 255
   \              0xFF 0xFF    
    228          __root static const MICRO_FLASH_CONFIGURATION_TYPE MICRO_FLASH_CONFIGURATION =
                        ^
Remark[Pe082]: storage class is not first
    229          {   /* BackDoor_Access_Key          */      MICRO_FLASH_CONFIGURATION_BACKDOOR_ACCESS_KEY,
    230              /* Flash_Protection_Regions     */      MICRO_FLASH_CONFIGURATION_FLASH_PROTECTION_REGIONS,
    231              /* Security                     */      MICRO_FLASH_SECURITY,
    232              /* Boot_options                 */      MICRO_FLASH_CONFIGURATION_BOOT_OPTION,
    233              /* EEPROM_Protection            */      MICRO_FLASH_CONFIGURATION_EEPROM_PROTECTION,
    234              /* DataFlash_Protection         */      MICRO_FLASH_CONFIGURATION_DATAFLASH_PROTECTION,
    235          };
    236          
    237          
    238          
    239          //=====================================================================================================================
    240          // The following MACROS handle generation of the register offset and byte masks
    241          #define IRQ_BIT_SHIFT(IRQn)                         ( (((uint32)(IRQn)       )    &  0x03) * 8 )
    242          #define IRQ_SHP_IDX(IRQn)                           (((((uint32)(IRQn) & 0x0F)-8) >>    2)     )
    243          #define IRQ_IP_IDX(IRQn)                            (  ((uint32)(IRQn)            >>    2)     )
    244          
    245          #ifndef MICRO_STOP_MODE
    246              #define MICRO_STOP_MODE                         DISABLED
    247          #endif
    248          
    249          #define U_ID      ((uint16 *)0x1FFFF7AC)
    250          
    251          #define MICRO_SCB_CPACR_ENABLE_CP10_CP11_CO_PROCESSOR       ((uint32)0x00F00000)
    252          
    253          
    254          //*********************Watchodog macro's ******************************************************************
    255          // Watchdog
    256          #ifndef MICRO_WATCHDOG_FEATURE
    257              #define MICRO_WATCHDOG_FEATURE    					ENABLED
    258          #endif
    259          
    260          #ifndef MICRO_WATCHDOG_DEBUG_MODE
    261          	#define MICRO_WATCHDOG_DEBUG_MODE				DISABLED
    262          #endif
    263          
    264          #define WDOG_Unlock()                               {WDOG.UNLOCK = 0xC520; WDOG.UNLOCK = 0xD928;}    // Write 0xC520 to the unlock register: Key1
    265          																						 // Followed by 0xD928 to complete the unlock: Key2
    266          //********************* End of Watchodog macro's ************************************************************
    267          typedef enum
    268          {
    269          	CLKS_FLL_SELECT = 0,							//Output of FLL is selected FLL Engaged for internal and external Clock
    270          	CLKS_HSI_SELECT = 1,							//Internal reference Clock is selected
    271          	CLKS_HSE_SELECT = 2,							//External reference Clock is selected
    272          	CLKS_PLL_SELECT = 3,							//Output of PLL is selected
    273          }CLOCK_MODE;										//Clock mode Status
    274          
    275          
    276          #define OUTPUT_CLOCK_OF_FLL_OR_PLL			0
    277          #define INTERNAL_REF_CLOCK					1
    278          #define EXTERNAL_REF_CLOCK					2
    279          
    280          //=====================================================================================================================
    281          //Compiler directive
    282          //=====================================================================================================================
    283          
    284          //Check HSE frequency range
    285          #if((HSE_VALUE < 3000) || (HSE_VALUE > 32000000))
    286          	#error : "High Speed External Clock frequency value should be in between 3Khz to 32Mhz range in the Micro_prm.h file"
    287          #endif
    288          
    289          //High gain oscillator - Controls the OSC mode of operations (
    290          #ifndef MICRO_OSC_HGO
    291          	#define MICRO_OSC_HGO							0			//0 - configure crystal oscillator low power operation.
    292          #endif		
    293          
    294          #ifndef MICRO_HIGHSPEEDRUN_MODE
    295          	#define MICRO_HIGHSPEEDRUN_MODE          		DISABLED
    296          #endif													//1 - configure crystal oscillator high-gain operation.
    297          
    298          //The LPTimer can measure the cycle of the frequency-divided LPO clock used for the independent watchdog timer (IWDT)
    299          //in the MKV03x. By this function, the main clock oscillation frequency errors can be detected.
    300          #ifndef MICRO_LPTIMER_EXTCLOCKSOURCE
    301          	#define MICRO_LPTIMER_EXTCLOCKSOURCE			DISABLED
    302          #endif
    303          
    304          #ifndef MICRO_LPTIMER_COMPARE_VAL
    305          	#define MICRO_LPTIMER_COMPARE_VAL				200
    306          #endif
    307          
    308          //SIM_OUTDIV1 Clock 1 output divider value : divide value for the core/system clock from MCGOUTCLK.
    309          #if(SIM_OUTDIV1 == 0)
    310          	#define SIM_OUTDIVIDER1                          SIM_PRE_OUTDIV1_DIV0
    311          #elif(SIM_OUTDIV1 == 1)
    312          	#define SIM_OUTDIVIDER1                          SIM_PRE_OUTDIV1_DIV1
    313          #elif(SIM_OUTDIV1 == 2)
    314          	#define SIM_OUTDIVIDER1                          SIM_PRE_OUTDIV1_DIV2
    315          #elif(SIM_OUTDIV1 == 3)
    316          	#define SIM_OUTDIVIDER1                          SIM_PRE_OUTDIV1_DIV3
    317          #elif(SIM_OUTDIV1 == 4)
    318          	#define SIM_OUTDIVIDER1                          SIM_PRE_OUTDIV1_DIV4
    319          #elif(SIM_OUTDIV1 == 5)
    320          	#define SIM_OUTDIVIDER1                          SIM_PRE_OUTDIV1_DIV5
    321          #elif(SIM_OUTDIV1 == 6)
    322          	#define SIM_OUTDIVIDER1                          SIM_PRE_OUTDIV1_DIV6
    323          #elif(SIM_OUTDIV1 == 7)
    324          	#define SIM_OUTDIVIDER1                          SIM_PRE_OUTDIV1_DIV7
    325          #elif(SIM_OUTDIV1 == 8)
    326          	#define SIM_OUTDIVIDER1                          SIM_PRE_OUTDIV1_DIV8
    327          #elif(SIM_OUTDIV1 == 9)
    328          	#define SIM_OUTDIVIDER1                          SIM_PRE_OUTDIV1_DIV9
    329          #elif(SIM_OUTDIV1 == 10)
    330          	#define SIM_OUTDIVIDER1                          SIM_PRE_OUTDIV1_DIV10
    331          #elif(SIM_OUTDIV1 == 11)
    332          	#define SIM_OUTDIVIDER1                          SIM_PRE_OUTDIV1_DIV11
    333          #elif(SIM_OUTDIV1 == 12)
    334          	#define SIM_OUTDIVIDER1                          SIM_PRE_OUTDIV1_DIV12
    335          #elif(SIM_OUTDIV1 == 13)
    336          	#define SIM_OUTDIVIDER1                          SIM_PRE_OUTDIV1_DIV13
    337          #elif(SIM_OUTDIV1 == 14)
    338          	#define SIM_OUTDIVIDER1                          SIM_PRE_OUTDIV1_DIV14
    339          #elif(SIM_OUTDIV1 == 15)
    340          	#define SIM_OUTDIVIDER1                          SIM_PRE_OUTDIV1_DIV15
    341          #else
    342          	#error : "SIM OUTDIV1 macro value should be either 0,1..... 15 in the Micro_prm.h file"
    343          #endif
    344          
    345          
    346          //SIM_OUTDIV2 Clock2  output divider value : divide value for the Bus clock from MCGOUTCLK.
    347          #if(SIM_OUTDIV2 == 0)
    348          	#define SIM_OUTDIVIDER2                          SIM_PRE_OUTDIV2_DIV0
    349          #elif(SIM_OUTDIV2 == 1)
    350          	#define SIM_OUTDIVIDER2                          SIM_PRE_OUTDIV2_DIV1
    351          #elif(SIM_OUTDIV2 == 2)
    352          	#define SIM_OUTDIVIDER2                          SIM_PRE_OUTDIV2_DIV2
    353          #elif(SIM_OUTDIV2 == 3)
    354          	#define SIM_OUTDIVIDER2                          SIM_PRE_OUTDIV2_DIV3
    355          #elif(SIM_OUTDIV2 == 4)
    356          	#define SIM_OUTDIVIDER2                          SIM_PRE_OUTDIV2_DIV4
    357          #elif(SIM_OUTDIV2 == 5)
    358          	#define SIM_OUTDIVIDER2                          SIM_PRE_OUTDIV2_DIV5
    359          #elif(SIM_OUTDIV2 == 6)
    360          	#define SIM_OUTDIVIDER2                          SIM_PRE_OUTDIV2_DIV6
    361          #elif(SIM_OUTDIV2 == 7)
    362          	#define SIM_OUTDIVIDER2                          SIM_PRE_OUTDIV2_DIV7
    363          #elif(SIM_OUTDIV2 == 8)
    364          	#define SIM_OUTDIVIDER2                          SIM_PRE_OUTDIV2_DIV8
    365          #elif(SIM_OUTDIV2 == 9)
    366          	#define SIM_OUTDIVIDER2                          SIM_PRE_OUTDIV2_DIV9
    367          #elif(SIM_OUTDIV2 == 10)
    368          	#define SIM_OUTDIVIDER2                          SIM_PRE_OUTDIV2_DIV10
    369          #elif(SIM_OUTDIV2 == 11)
    370          	#define SIM_OUTDIVIDER2                          SIM_PRE_OUTDIV2_DIV11
    371          #elif(SIM_OUTDIV2 == 12)
    372          	#define SIM_OUTDIVIDER2                          SIM_PRE_OUTDIV2_DIV12
    373          #elif(SIM_OUTDIV2 == 13)
    374          	#define SIM_OUTDIVIDER2                          SIM_PRE_OUTDIV2_DIV13
    375          #elif(SIM_OUTDIV2 == 14)
    376          	#define SIM_OUTDIVIDER2                          SIM_PRE_OUTDIV2_DIV14
    377          #elif(SIM_OUTDIV2 == 15)
    378          	#define SIM_OUTDIVIDER2                          SIM_PRE_OUTDIV2_DIV15
    379          #else
    380          	#error : "SIM OUTDIV2 macro value should be either 0,1..... 15  in the Micro_prm.h file"
    381          #endif
    382          
    383          
    384          //SIM_OUTDIV1 Clock 3 output divider value : divide value for the FlexBus clock from MCGOUTCLK.
    385          #if(SIM_OUTDIV3 == 0)
    386          	#define SIM_OUTDIVIDER3                          SIM_PRE_OUTDIV3_DIV0
    387          #elif(SIM_OUTDIV3 == 1)
    388          	#define SIM_OUTDIVIDER3                          SIM_PRE_OUTDIV3_DIV1
    389          #elif(SIM_OUTDIV3 == 2)
    390          	#define SIM_OUTDIVIDER3                          SIM_PRE_OUTDIV3_DIV2
    391          #elif(SIM_OUTDIV3 == 3)
    392          	#define SIM_OUTDIVIDER3                          SIM_PRE_OUTDIV3_DIV3
    393          #elif(SIM_OUTDIV3 == 4)
    394          	#define SIM_OUTDIVIDER3                          SIM_PRE_OUTDIV3_DIV4
    395          #elif(SIM_OUTDIV3 == 5)
    396          	#define SIM_OUTDIVIDER3                          SIM_PRE_OUTDIV3_DIV5
    397          #elif(SIM_OUTDIV3 == 6)
    398          	#define SIM_OUTDIVIDER3                          SIM_PRE_OUTDIV3_DIV6
    399          #elif(SIM_OUTDIV3 == 7)
    400          	#define SIM_OUTDIVIDER3                          SIM_PRE_OUTDIV3_DIV7
    401          #elif(SIM_OUTDIV3 == 8)
    402          	#define SIM_OUTDIVIDER3                          SIM_PRE_OUTDIV3_DIV8
    403          #elif(SIM_OUTDIV3 == 9)
    404          	#define SIM_OUTDIVIDER3                          SIM_PRE_OUTDIV3_DIV9
    405          #elif(SIM_OUTDIV3 == 10)
    406          	#define SIM_OUTDIVIDER3                          SIM_PRE_OUTDIV3_DIV10
    407          #elif(SIM_OUTDIV3 == 11)
    408          	#define SIM_OUTDIVIDER3                          SIM_PRE_OUTDIV3_DIV11
    409          #elif(SIM_OUTDIV3 == 12)
    410          	#define SIM_OUTDIVIDER3                          SIM_PRE_OUTDIV3_DIV12
    411          #elif(SIM_OUTDIV3 == 13)
    412          	#define SIM_OUTDIVIDER3                          SIM_PRE_OUTDIV3_DIV13
    413          #elif(SIM_OUTDIV3 == 14)
    414          	#define SIM_OUTDIVIDER3                          SIM_PRE_OUTDIV3_DIV14
    415          #elif(SIM_OUTDIV3 == 15)
    416          	#define SIM_OUTDIVIDER3                          SIM_PRE_OUTDIV3_DIV15
    417          #else
    418          	#error : "SIM OUTDIV3 macro value should be either 0,1..... 15  in the Micro_prm.h file"
    419          #endif
    420          
    421          
    422          //SIM_OUTDIV1 Clock 1 output divider value : divide value for the Flash clock from MCGOUTCLK.
    423          #if(SIM_OUTDIV4 == 0)
    424          	#define SIM_OUTDIVIDER4                          SIM_PRE_OUTDIV4_DIV0
    425          #elif(SIM_OUTDIV4 == 1)
    426          	#define SIM_OUTDIVIDER4                          SIM_PRE_OUTDIV4_DIV1
    427          #elif(SIM_OUTDIV4 == 2)
    428          	#define SIM_OUTDIVIDER4                          SIM_PRE_OUTDIV4_DIV2
    429          #elif(SIM_OUTDIV4 == 3)
    430          	#define SIM_OUTDIVIDER4                          SIM_PRE_OUTDIV4_DIV3
    431          #elif(SIM_OUTDIV4 == 4)
    432          	#define SIM_OUTDIVIDER4                          SIM_PRE_OUTDIV4_DIV4
    433          #elif(SIM_OUTDIV4 == 5)
    434          	#define SIM_OUTDIVIDER4                          SIM_PRE_OUTDIV4_DIV5
    435          #elif(SIM_OUTDIV4 == 6)
    436          	#define SIM_OUTDIVIDER4                          SIM_PRE_OUTDIV4_DIV6
    437          #elif(SIM_OUTDIV4 == 7)
    438          	#define SIM_OUTDIVIDER4                          SIM_PRE_OUTDIV4_DIV7
    439          #elif(SIM_OUTDIV4 == 8)
    440          	#define SIM_OUTDIVIDER4                          SIM_PRE_OUTDIV4_DIV8
    441          #elif(SIM_OUTDIV4 == 9)
    442          	#define SIM_OUTDIVIDER4                          SIM_PRE_OUTDIV4_DIV9
    443          #elif(SIM_OUTDIV4 == 10)
    444          	#define SIM_OUTDIVIDER4                          SIM_PRE_OUTDIV4_DIV10
    445          #elif(SIM_OUTDIV4 == 11)
    446          	#define SIM_OUTDIVIDER4                          SIM_PRE_OUTDIV4_DIV11
    447          #elif(SIM_OUTDIV4 == 12)
    448          	#define SIM_OUTDIVIDER4                          SIM_PRE_OUTDIV4_DIV12
    449          #elif(SIM_OUTDIV4 == 13)
    450          	#define SIM_OUTDIVIDER4                          SIM_PRE_OUTDIV4_DIV13
    451          #elif(SIM_OUTDIV4 == 14)
    452          	#define SIM_OUTDIVIDER4                          SIM_PRE_OUTDIV4_DIV14
    453          #elif(SIM_OUTDIV4 == 15)
    454          	#define SIM_OUTDIVIDER4                          SIM_PRE_OUTDIV4_DIV15
    455          #else
    456          	#error : "SIM OUTDIV4 macro value should be either 0,1..... 15  in the Micro_prm.h file"
    457          #endif
    458          
    459          #if(DCO_RANGE == 0)
    460          	#define DCO_FREQUENCY								24000000
    461          #elif (DCO_RANGE == 1)
    462          	#define DCO_FREQUENCY								48000000
    463          #elif (DCO_RANGE == 2)
    464          	#define DCO_FREQUENCY								72000000
    465          #elif (DCO_RANGE == 3)
    466          	#define DCO_FREQUENCY								96000000
    467          #else
    468          	#error : "DCO_FREQUENCY macro value should be either 0,1,2 or 3  in the Micro_prm.h file"
    469          #endif
    470          
    471          #if(DCO_RANGE_INT == 0)
    472              #define DCO_FREQUENCY_INT                               24000000
    473          #elif (DCO_RANGE_INT == 1)
    474              #define DCO_FREQUENCY_INT                               48000000
    475          #elif (DCO_RANGE_INT == 2)
    476              #define DCO_FREQUENCY_INT                               72000000
    477          #elif (DCO_RANGE_INT == 3)
    478              #define DCO_FREQUENCY_INT                               96000000
    479          #else
    480              #error : "DCO_FREQUENCY_INT macro value should be either 0,1,2 or 3  in the Micro_prm.h file"
    481          #endif
    482          
    483          // Low voltage detector
    484          #ifndef LOW_VOLTAGE_MONITOR_FEATURE
    485              #define LOW_VOLTAGE_MONITOR_FEATURE        DISABLED
    486          #endif
    487          
    488          #if (LOW_VOLTAGE_MONITOR_FEATURE == ENABLED)
    489              #ifndef LOW_VOLTAGE_LEVEL
    490           //       #error:"LOW_VOLTAGE_LEVEL macro must be defined in the Micro_prm.h file"
    491              #else
    492                  #if LOW_VOLTAGE_LEVEL > 7
    493                      #error:"LOW_VOLTAGE_LEVEL macro value must be within 0 to 3  and should be defined in the Micro_prm.h file"
    494                  #endif
    495              #endif
    496          #ifndef CLOCK_OUT
    497          	#define CLOCK_OUT 				DISABLED
    498          #endif
    499              // PVD(Programmable Voltage detector) interrupt priority
    500              #ifndef PVD_PREEMPTION_PRIORITY
    501                  #define PVD_PREEMPTION_PRIORITY     3  //The PVD(Programmable Voltage detector) is in interrupt group 0 having highest priority
    502              #elif (PVD_PREEMPTION_PRIORITY > 3)
    503                  #error:"PVD_PREEMPTION_PRIORITY macro value must be either 0,1,2,3"
    504              #endif
    505          
    506          	#ifndef PVD_PREEMPTION_SUB_PRIORITY
    507          		#define PVD_PREEMPTION_SUB_PRIORITY     3  //The PVD(Programmable Voltage detector) is in interrupt group 0 having highest priority
    508          	#elif (PVD_PREEMPTION_SUB_PRIORITY > 3)
    509          		#error:"PVD_PREEMPTION_PRIORITY macro value must be either 0,1,2,3"
    510          	#endif
    511          #endif
    512          
    513          

   \                                 In section .rodata, align 4, keep-with-next
    514          static const uint8 MICRO_ID[] = {'M','K','V','3','x'};
   \                     MICRO_ID:
   \   00000000   0x4D 0x4B          DC8 77, 75, 86, 51, 120, 0, 0, 0
   \              0x56 0x33    
   \              0x78 0x00    
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
    515          static const MICRO_ID_TYPE MICRO_CPU_IDENTIFICATION = {(uint8 *)MICRO_ID,5};
   \                     MICRO_CPU_IDENTIFICATION:
   \   00000000   0x........         DC32 MICRO_ID
   \   00000004   0x05 0x00          DC8 5, 0, 0, 0
   \              0x00 0x00    
    516          
    517          #define MICRO_FLASH_SIZE()                  (5822)
    518          #define MICRO_RAM_SIZE()                    (16)
    519          #define MICRO_CPU_ID()                      ((MICRO_ID_TYPE * )(&MICRO_CPU_IDENTIFICATION))
    520          #define MICRO_BOOT_SEQUENCE_1               3
    521          #define MICRO_BOOT_SEQUENCE_2               5
    522          #define MICRO_BOOT_SEQUENCE_3               11
    523          
    524          //---------------------------------------------------------------------------------------------------------------------
    525          /**
    526           * List all the generic structures, variable, private function prototype
    527           */
    528          #ifndef MICRO_SRPOWERMGR_FEATURE
    529              #define MICRO_SRPOWERMGR_FEATURE    DISABLED
    530          #endif
    531          
    532          #if (MICRO_SRPOWERMGR_FEATURE == ENABLED)
    533              #include "SRPowerMgr.h"
    534          #endif
    535          
    536          #define MICRO_RESETINFO_STRING_SIZE             44
    537          
    538          PACKED typedef struct
                        ^
Remark[Pe082]: storage class is not first
    539          {
    540              uint8 Header[MICRO_RESETINFO_STRING_SIZE];
    541              MICRO_LAST_RESET_TYPE Reset;
    542              MICRO_LAST_RESET_TYPE Actual_Reset;
    543              MICRO_RESET_MODE_TYPE Mode;
    544              MICRO_WARM_RESET_ACTION_TYPE Warm_Reset_Actions;
    545              BOOL_TYPE Force_Cold_Reset;
    546              uint8 Warm_Reset_Count;
    547              //This variable shall always be at the end of the structure
    548              uint8 Crc8_Data_Integrator;
    549          }MICRO_RESET_INFO_HEADER_TYPE;
    550          
    551          //! Holds the Clock status

   \                                 In section .bss, align 4
    552          static MICRO_CLOCK_DEF  Micro_ClocksStatus;
   \                     Micro_ClocksStatus:
   \   00000000                      DS8 24
    553          

   \                                 In section .text, align 4, keep-with-next
    554          const uint8 MICRO_RESETINFO_HEADER[MICRO_RESETINFO_STRING_SIZE] =      {"Dream is not the thing you see in sleep but"};
   \                     MICRO_RESETINFO_HEADER:
   \   00000000   0x44 0x72          DC8 "Dream is not the thing you see in sleep but"
   \              0x65 0x61    
   \              0x6D 0x20    
   \              0x69 0x73    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x74    
   \              0x68 0x69    
   \              0x6E 0x67    
   \              0x20 0x79    
   \              0x6F 0x75    
   \              0x20 0x73    
   \              0x65 0x65    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x73 0x6C    
   \              0x65 0x65    
   \              0x70 0x20    
   \              0x62 0x75    
   \              0x74 0x00    

   \                                 In section .text, align 4, keep-with-next
    555          const uint8 MICRO_RESETINFO_FOOTER[MICRO_RESETINFO_STRING_SIZE] =      {"it is that thing that doesn't let you sleep"};
   \                     MICRO_RESETINFO_FOOTER:
   \   00000000   0x69 0x74          DC8 "it is that thing that doesn't let you sleep"
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x74 0x68    
   \              0x61 0x74    
   \              0x20 0x74    
   \              0x68 0x69    
   \              0x6E 0x67    
   \              0x20 0x74    
   \              0x68 0x61    
   \              0x74 0x20    
   \              0x64 0x6F    
   \              0x65 0x73    
   \              0x6E 0x27    
   \              0x74 0x20    
   \              0x6C 0x65    
   \              0x74 0x20    
   \              0x79 0x6F    
   \              0x75 0x20    
   \              0x73 0x6C    
   \              0x65 0x65    
   \              0x70 0x00    
    556          
    557          #pragma location = ".RESET_INFO_HEADER"

   \                                 In section .RESET_INFO_HEADER, align 4
    558          static NO_INIT MICRO_RESET_INFO_HEADER_TYPE Micro_ResetInfo;
   \                     Micro_ResetInfo:
   \   00000000                      DS8 52
    559          
    560          #pragma location = ".RESET_INFO_FOOTER"

   \                                 In section .RESET_INFO_FOOTER, align 4
    561          static NO_INIT uint8 Micro_ResetInfo_Footer[MICRO_RESETINFO_STRING_SIZE];
   \                     Micro_ResetInfo_Footer:
   \   00000000                      DS8 44
    562          
    563          //=====================================================================================================================
    564          //! ClassB Related
    565          //=====================================================================================================================
    566          
    567          #define MICRO_RESETINFO_CLASSB_DATA_FROM      ((uint8 *)&Micro_ResetInfo.Reset)
    568          #define MICRO_RESETINFO_CLASSB_DATA_SIZE      (sizeof(Micro_ResetInfo) - MICRO_RESETINFO_STRING_SIZE - 1)       // -1 to exclude the Crc location
    569          
    570          //! Stack test patterns
    571          #define STACK_TEST_PATTERN                    0x55
    572          #define STACK_TEST_PATTERN_INV                0xAA
    573          #define STACK_TEST_BKD                        0x00
    574          #define STACK_TEST_BKD_INV                    0xFF
    575          
    576          //"Whirlpool100Year"
    577          #define STACK_TEST_PATTERN1                 0x72696857
    578          #define STACK_TEST_PATTERN2                 0x6F6F706C
    579          #define STACK_TEST_PATTERN3                 0x3030316C
    580          #define STACK_TEST_PATTERN4                 0x72616559
    581          
    582          //"EES Organization"
    583          #define STACK_TEST_PATTERN5                 0x20534545
    584          #define STACK_TEST_PATTERN6                 0x6167724F
    585          #define STACK_TEST_PATTERN7                 0x617A696E
    586          #define STACK_TEST_PATTERN8                 0x6E6F6974
    587          
    588          
    589          #ifndef MICRO_CALLBACK_BEFORE_WATCHDOG_INIT
    590              #define MICRO_CALLBACK_BEFORE_WATCHDOG_INIT()
    591          #endif
    592          
    593          #define MICRO_BOOT_SEQUENCE_1               3
    594          #define MICRO_BOOT_SEQUENCE_2               5
    595          #define MICRO_BOOT_SEQUENCE_3               11
    596          
    597          #define RUN_TIME_STACK_TEST_TRUE              0x00000080
    598          #define RUN_TIME_STACK_TEST_COUNT_MASK        0x0000007F
    599          #define RUN_TIME_STACK_TEST_PROP_MASK         0x000000FF
    600          
    601          #ifndef MICRO_WARM_RESET_COUNTER_LIMIT
    602              #define MICRO_WARM_RESET_COUNTER_LIMIT  20
    603          #endif
    604          
    605          // Below symbols are exported from the linker file (config.icf)
    606          
    607          #pragma section = "STACK_UNDERFLOW_SIGNATURE"
    608          #pragma section = "STACK_OVERFLOW_SIGNATURE"
    609          
    610          extern uint32  __ICFEDIT_region_RAM_start__;
    611          extern uint32  __ICFEDIT_region_RAM_end__;
    612          
    613          #define MICRO_RAM_START_ADDRESS         ((uint32)&__ICFEDIT_region_RAM_start__)
    614          #define MICRO_RAM_END_ADDRESS           ((uint32)&__ICFEDIT_region_RAM_end__)
    615          
    616          #define MICRO_STACK_TEST_START_ADDRESS         ((uint32)__section_begin("STACK_OVERFLOW_SIGNATURE"))
    617          #define MICRO_STACK_TEST_END_ADDRESS           ((uint32)__section_begin("STACK_UNDERFLOW_SIGNATURE"))
    618          
    619          extern uint32  MICRO_FLASH_START;
    620          extern uint32  MICRO_FLASH_END;
    621          
    622          #define MICRO_FLASH_START_ADDRESS   ((uint32 *)&MICRO_FLASH_START)
    623          #define MICRO_FLASH_END_ADDRESS     ((uint32 *)&MICRO_FLASH_END)
    624          
    625          #ifndef MICRO_SR_FEATURE_TEST
    626              #define MICRO_SR_FEATURE_TEST  DISABLED
    627          #elif (MICRO_SR_FEATURE_TEST == ENABLED)
    628          
    629              /**
    630               * Ram Periodic Test
    631               */
    632          #ifndef MICRO_NUM_BYTE_FOR_RAM_CONTINUOUS_TEST
    633          //When 4 words are processed per call then time taken to detect the fault is 25.6 seconds for 1KB Stack memory.
    634                  #define MICRO_NUM_BYTE_FOR_RAM_CONTINUOUS_TEST  4
    635              #elif (MICRO_NUM_BYTE_FOR_RAM_CONTINUOUS_TEST > 127)
    636                  #error :"MICRO_NUM_BYTE_FOR_RAM_CONTINUOUS_TEST macro value should not be more than 127 bytes per call"
    637              #endif
    638          
    639              // Below symbols are exported from the linker file (config.icf)

   \                                 In section .bss, align 4
    640          uint32 *Run_Time_Stack_Pointer;
    641          uint32 *Run_Time_Stack_Pointer_Inv;
    642              /**
    643               * Flash Periodic Test
    644               *
    645               * The time taken for 1 word test is 5.9us were the system clock is 72MHz by the Inbuilt tool.
    646               * The time taken for 10 word test is 56.9us were the system clock is 72MHz by the Inbuilt tool.
    647               */
    648              #ifndef MICRO_NUM_BYTE_FOR_FLASH_CONTINUOUS_TEST
    649                  #define MICRO_NUM_BYTE_FOR_FLASH_CONTINUOUS_TEST  4
    650              #elif (MICRO_NUM_BYTE_FOR_FLASH_CONTINUOUS_TEST > 255)
    651                  #error :"MICRO_NUM_BYTE_FOR_FLASH_CONTINUOUS_TEST macro value should not be more than 255 bytes per call"
    652              #endif
    653          
    654              // crc GDM should be included if the Flash test is enabled.
    655              #ifndef CRC_H
    656                  #include "Crc16.h"
    657              #endif
    658          
    659              // symbol MICRO_FLASH_CRC created by the IELF tool, this holds the calculated CRC value on the flash memory.
    660              extern uint16 MICRO_FLASH_CRC;
    661          
    662              static uint16 Micro_Flash_Crc;
   \                     Micro_Flash_Crc:
   \   00000000                      DS8 2
   \   00000002                      DS8 2
   \                     Run_Time_Stack_Pointer:
   \   00000004                      DS8 4
   \                     Run_Time_Stack_Pointer_Inv:
   \   00000008                      DS8 4
    663              static uint32 * Micro_Flash_Crc_Pt;
   \                     Micro_Flash_Crc_Pt:
   \   0000000C                      DS8 4
    664          
    665              // Below symbols are exported from the linker file (config.icf)
    666          
    667              #define MICRO_CRC_INITIAL           0x0000
    668          #endif
    669          
    670          extern uint32 __ICFEDIT_INTERRUPT_TABLE_start__;
    671          #define NVIC_VECTTAB_FLASH           ((uint32)&__ICFEDIT_INTERRUPT_TABLE_start__)
    672          
    673          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
    674          static void MicroGetClocksStatus(void);
    675          static void MicroHWInit(void);
    676          static void MicroInitClk(void);
    677          static void MicroInitClkLowSpeed(void);
    678          static MICRO_LAST_RESET_TYPE MicroReadActualReset(void);
    679          static void MicroWatchdogDisable(void);
    680          #if (MICRO_SR_FEATURE_TEST == ENABLED)
    681          	static void MicroBootWatchdogTest(void);
    682          #endif
    683          
    684          static void MicroResetHandling(void);
    685          static void MicroClearResetData(void);
    686          static void MicroSetRamSignature(void);
    687          static BOOL_TYPE MicroIsResetSignatureValid(void);
    688          static void MicroValidateResetInfoDataCrc(void);
    689          static void MicroUpdateResetInfoDataCrc(void);
    690          
    691          #if (MICRO_SR_FEATURE_TEST == ENABLED)
    692              static void MicroBootFlashTest(void);
    693              static void MicroFailSafe(void);
    694          #endif
    695          // After boot test __iar_program_start which calls the void main(void)
    696          extern void __iar_program_start( void );
    697          
    698          //Create a lib_init() function, for the C initialization. This function will copy the initial values for
    699          //static and global initialized variables from ROM to RAM, and initialize zero-initialized data to 0
    700          #ifndef RAM_DATA_INITIALIZE
    701              extern void __iar_data_init3(void);
    702              #define RAM_DATA_INITIALIZE()   __iar_data_init3()
    703          #endif
    704          
    705          extern void main(void);
    706          
    707          #define MICRO_BOOTTEST_WDTINIT()                      Micro__ConfigureWDT()
    708          #define MICRO_BOOTTEST_MICROHWINIT()                  MicroHWInit()
    709          #define MICRO_BOOTTEST_RAMTEST()                      __BootTimeRamTest()
    710          #define MICRO_BOOTTEST_REGTEST()                      __StartupRegisterTest()
    711          #define MICRO_BOOTTEST_FLASHTEST()                    MicroBootFlashTest()
    712          #define MICRO_BOOTTEST_WDTEST()                       MicroBootWatchdogTest()
    713          #define MICRO_BOOTTEST_CLKINIT()                      MicroInitClkLowSpeed()
    714          #define MICRO_RUNTIME_REGISTER_TEST()                 __RunRegisterTest()
    715          
    716          //=====================================================================================================================
    717          //-------------------------------------- Public Functions -------------------------------------------------------------
    718          //=====================================================================================================================
    719          //---------------------------------------------------------------------------------------------------------------------
    720          /**
    721           *    @brief    This method initializes the Micro module
    722           *    @details  This method is used to initialize clock, Nested Vectored Interrupt (NVIC) and
    723           *              window watchdog configuration. It should be called prior to any other application method is called
    724           *              since it initializes micro module.
    725           *
    726           *              The Gpio module must be re-initialized if the SRMicro__Initialize() is called in the middle
    727           *              of the Application code.
    728           */

   \                                 In section .text, align 2, keep-with-next
    729          void Micro__Initialize(void)
    730          {
   \                     Micro__Initialize: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB081             SUB      SP,SP,#+4
    731          	uint8 index;
    732          
    733          	#if (MICRO_SR_FEATURE_TEST == ENABLED)
    734          		uint32 * pt_stack_overflow_test;
                 		         ^
Warning[Pe177]: variable "pt_stack_overflow_test" was declared but never
          referenced
    735          		uint32 * pt_stack_underflow_test;
                 		         ^
Warning[Pe177]: variable "pt_stack_underflow_test" was declared but never
          referenced
    736          	#endif
    737          
    738              SR_MICRO_INITIALIZE_FLOW_BEGIN()
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       SRFlow__InitLogEvent
    739          	index = 0;
    740          
    741          //	MicroWatchdogDisable();								//Disable Watchdog          -- For every reset By default Watchdog is enabled
    742          
    743          	Micro__ConfigureWDT();
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable26  ;; 0x40052000
   \   00000010   0xF24C 0x5020      MOVW     R0,#+50464
   \   00000014   0x81E0             STRH     R0,[R4, #+14]
   \   00000016   0xF64D 0x1128      MOVW     R1,#+55592
   \   0000001A   0x81E1             STRH     R1,[R4, #+14]
   \   0000001C   0xF240 0x1211      MOVW     R2,#+273
   \   00000020   0x8022             STRH     R2,[R4, #+0]
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x82E2             STRH     R2,[R4, #+22]
   \   00000026   0x8122             STRH     R2,[R4, #+8]
   \   00000028   0x8162             STRH     R2,[R4, #+10]
   \   0000002A   0x80A2             STRH     R2,[R4, #+4]
   \   0000002C   0xF44F 0x72FA      MOV      R2,#+500
   \   00000030   0x80E2             STRH     R2,[R4, #+6]
   \   00000032   0xF3EF 0x8210      MRS      R2,PRIMASK
   \   00000036   0xB672             CPSID    I
   \   00000038   0xF24A 0x6502      MOVW     R5,#+42498
   \   0000003C   0x81A5             STRH     R5,[R4, #+12]
   \   0000003E   0xF24B 0x4680      MOVW     R6,#+46208
   \   00000042   0x81A6             STRH     R6,[R4, #+12]
   \   00000044   0xF382 0x8810      MSR      PRIMASK,R2
    744          
    745              MicroHWInit();
   \   00000048   0x81E0             STRH     R0,[R4, #+14]
   \   0000004A   0x81E1             STRH     R1,[R4, #+14]
   \   0000004C   0xF64F 0x71FE      MOVW     R1,#+65534
   \   00000050   0x8820             LDRH     R0,[R4, #+0]
   \   00000052   0x.... 0x....      LDR.W    R9,??DataTable26_1  ;; 0xe000e010
   \   00000056   0x.... 0x....      LDR.W    R8,??DataTable26_2  ;; 0xe000e400
   \   0000005A   0x4008             ANDS     R0,R1,R0
   \   0000005C   0x8020             STRH     R0,[R4, #+0]
   \   0000005E   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000062   0x0840             LSRS     R0,R0,#+1
   \   00000064   0x0040             LSLS     R0,R0,#+1
   \   00000066   0xF8C9 0x0000      STR      R0,[R9, #+0]
   \   0000006A   0xF8D8 0x0988      LDR      R0,[R8, #+2440]
   \   0000006E   0xF440 0x0070      ORR      R0,R0,#0xF00000
   \   00000072   0xF8C8 0x0988      STR      R0,[R8, #+2440]
   \   00000076   0xB672             CPSID    I
    746          
    747          	RCM.SSRS0 |= RCM_SSRS0_SWDOG_MASK;							//Clear Watchdog Timeout flag
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable26_3  ;; 0x4007f008
   \   0000007C   0x7801             LDRB     R1,[R0, #+0]
   \   0000007E   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000082   0x7001             STRB     R1,[R0, #+0]
    748          
    749          	// Initialize the interrupt vectors
    750              NVIC.Disable[0] = 0xFFFFFFFF;
   \   00000084   0xF04F 0x30FF      MOV      R0,#-1
   \   00000088   0xF8C9 0x0170      STR      R0,[R9, #+368]
    751              NVIC.Clear[0] = 0xFFFFFFFF;
   \   0000008C   0xF8C9 0x0270      STR      R0,[R9, #+624]
    752          
    753              //Initializes all priorities to 0
    754              for(index = 0; index <= NVIC_INTERRUPT_PRIORITY_ARRAY; index++)
    755              {
    756                  NVIC.Priority[index] = NVIC_INTERRUPT_PRIORITY_CLEAR;
   \   00000090   0x21F1             MOVS     R1,#+241
   \   00000092   0x4640             MOV      R0,R8
   \   00000094   0x.... 0x....      BL       __aeabi_memclr4
    757              }
    758          
    759              // Priority groups configuration - 4 groups, 64 subgroups
    760              SCB.AIRCR = AIRC_VECTKEY_MASK | (0x5 << SCB_AIRCR_PRIGROUP_POS);
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable27  ;; 0x5fa0500
   \   0000009C   0xF8C8 0x090C      STR      R0,[R8, #+2316]
    761          
    762          	#if (CLOCK_OUT == ENABLED)									//Clock out is checked on PTC3(ALT5)
    763          		{
    764          			SIM.SOPT2 = SIM_SOPT2_CLKOUTSEL(CLKOUTSEL);			//(Pin11 of J6 connector on TERboard of KV3x)
    765          			SIM.SCGC5 |= SIM_SCGC5_PORTC_MASK;					//Enable Port C clock
    766          			PCIPORTC.PCR[3] = PORT_PCR_MUX(5);					// Set Pin C3 to ALT 5 clkout function
    767          		}
    768          	#endif
    769          
    770          	// Division by zero shall be trapped
    771          	SCB.CCR |= 0x10;
   \   000000A0   0xF8D8 0x0914      LDR      R0,[R8, #+2324]
   \   000000A4   0xF040 0x0010      ORR      R0,R0,#0x10
   \   000000A8   0xF8C8 0x0914      STR      R0,[R8, #+2324]
    772          	
    773              //Set the Vector Table base address
    774              SCB.VTOR = NVIC_VECTTAB_FLASH;
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   000000B0   0xF8C8 0x0908      STR      R0,[R8, #+2312]
    775          
    776              //Initializes the system clock
    777              MicroInitClkLowSpeed();
   \   000000B4   0x.... 0x....      BL       MicroInitClkLowSpeed
    778          
    779              // This method read the current system clock configuration and update Micro_ClocksStatus
    780              MicroGetClocksStatus();
   \   000000B8   0x.... 0x....      BL       MicroGetClocksStatus
    781          
    782              #if (MICRO_SR_FEATURE_TEST == ENABLED)
    783                  //Initialize the flash periodic test variables.
    784                  Micro_Flash_Crc = MICRO_CRC_INITIAL;
   \   000000BC   0x2100             MOVS     R1,#+0
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable28
    785                  Micro_Flash_Crc_Pt = MICRO_FLASH_START_ADDRESS;
   \   000000C2   0x.... 0x....      LDR.W    R7,??DataTable28_1
   \   000000C6   0x8001             STRH     R1,[R0, #+0]
   \   000000C8   0x463A             MOV      R2,R7
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable28_2
   \   000000CE   0x60C1             STR      R1,[R0, #+12]
   \   000000D0   0xF100 0x0108      ADD      R1,R0,#+8
   \   000000D4   0x1D00             ADDS     R0,R0,#+4
    786          
    787          	    register uint32 * pt_stack_test;
    788          	    //Initialize the Ram periodic test variables.
    789          	    SRData__UpdateLong((uint32 PACKED *)&Run_Time_Stack_Pointer, (uint32 PACKED *)&Run_Time_Stack_Pointer_Inv,MICRO_STACK_TEST_START_ADDRESS);
   \   000000D6   0x.... 0x....      BL       SRData__UpdateLong
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable28_4  ;; 0x72616559
   \   000000E2   0x60C1             STR      R1,[R0, #+12]
    790          
    791                  pt_stack_test = (uint32*)MICRO_STACK_TEST_END_ADDRESS;
    792                  pt_stack_test[3] = STACK_TEST_PATTERN4;
    793                  pt_stack_test[2] = STACK_TEST_PATTERN3;
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable28_5  ;; 0x3030316c
   \   000000E8   0x6081             STR      R1,[R0, #+8]
    794                  pt_stack_test[1] = STACK_TEST_PATTERN2;
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable28_6  ;; 0x6f6f706c
   \   000000EE   0x6041             STR      R1,[R0, #+4]
    795                  pt_stack_test[0] = STACK_TEST_PATTERN1;
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable29  ;; 0x72696857
   \   000000F4   0x6001             STR      R1,[R0, #+0]
    796          
    797                  pt_stack_test = (uint32*)MICRO_STACK_TEST_START_ADDRESS;
    798                  pt_stack_test[0] = STACK_TEST_PATTERN5;
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable29_1  ;; 0x20534545
   \   000000FA   0x6038             STR      R0,[R7, #+0]
    799                  pt_stack_test[1] = STACK_TEST_PATTERN6;
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable29_2  ;; 0x6167724f
   \   00000100   0x6078             STR      R0,[R7, #+4]
    800                  pt_stack_test[2] = STACK_TEST_PATTERN7;
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable29_3  ;; 0x617a696e
   \   00000106   0x60B8             STR      R0,[R7, #+8]
    801                  pt_stack_test[3] = STACK_TEST_PATTERN8;
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable29_4  ;; 0x6e6f6974
   \   0000010C   0x60F8             STR      R0,[R7, #+12]
    802          	#endif
    803          
    804              Micro__ServiceWatchdog();
   \   0000010E   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000112   0xB672             CPSID    I
   \   00000114   0x81A5             STRH     R5,[R4, #+12]
   \   00000116   0x81A6             STRH     R6,[R4, #+12]
   \   00000118   0xF380 0x8810      MSR      PRIMASK,R0
    805          
    806              #if(MICRO_LPTIMER_EXTCLOCKSOURCE == ENABLED)
    807          
    808                  SIM.SCGC5 |= SIM_SCGC5_LPTMR_MASK;									//Enable LPTMR module clock
   \   0000011C   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x40048038
   \   00000120   0x6801             LDR      R1,[R0, #+0]
   \   00000122   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000126   0x6001             STR      R1,[R0, #+0]
    809                  /* Configure LPTMR */
    810                  LPTMR0.CSR = 0;
   \   00000128   0x2100             MOVS     R1,#+0
   \   0000012A   0x.... 0x....      LDR.W    R0,??DataTable32  ;; 0x40040000
   \   0000012E   0x6001             STR      R1,[R0, #+0]
    811                  LPTMR0.CMR = LPTMR_CMR_COMPARE(MICRO_LPTIMER_COMPARE_VAL); 			//Set the compare value to the number of ms to delay
   \   00000130   0x21C8             MOVS     R1,#+200
   \   00000132   0x6081             STR      R1,[R0, #+8]
    812                  LPTMR0.PSR = LPTMR_PSR_PCS(0x1) | LPTMR_PSR_PBYP_MASK; 				//Use LPO clock and bypass prescale
   \   00000134   0x2105             MOVS     R1,#+5
   \   00000136   0x6041             STR      R1,[R0, #+4]
    813                  LPTMR0.CSR |= LPTMR_CSR_TEN_MASK | LPTMR_CSR_TIE_MASK;				//Start the timer
   \   00000138   0x6801             LDR      R1,[R0, #+0]
   \   0000013A   0xF041 0x0141      ORR      R1,R1,#0x41
   \   0000013E   0x6001             STR      R1,[R0, #+0]
   \   00000140   0x2102             MOVS     R1,#+2
    814                  NVIC.Clear[1]|=0x04000000;											//Clear pending IRQ before enabling this IRQ
   \   00000142   0xF8D9 0x0274      LDR      R0,[R9, #+628]
   \   00000146   0xF040 0x6080      ORR      R0,R0,#0x4000000
   \   0000014A   0xF8C9 0x0274      STR      R0,[R9, #+628]
    815                  Micro__NVICEnableIRQ(LOW_POWER_TIMER_IRQ_CHANNEL, LPTIMER0_PREEMPTION_PRIORITY, LPTIMER0_SUB_PRIORITY);
   \   0000014E   0xF8D8 0x090C      LDR      R0,[R8, #+2316]
   \   00000152   0xF400 0x60E0      AND      R0,R0,#0x700
   \   00000156   0xF5C0 0x60E0      RSB      R0,R0,#+1792
   \   0000015A   0x0A00             LSRS     R0,R0,#+8
   \   0000015C   0xF1C0 0x0004      RSB      R0,R0,#+4
   \   00000160   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000164   0x0100             LSLS     R0,R0,#+4
   \   00000166   0xF888 0x003A      STRB     R0,[R8, #+58]
   \   0000016A   0xF04F 0x6080      MOV      R0,#+67108864
   \   0000016E   0xF8C9 0x00F4      STR      R0,[R9, #+244]
    816          
    817              #endif
    818              SR_MICRO_INITIALIZE__FLOW_END()
   \   00000172   0xB001             ADD      SP,SP,#+4
   \   00000174   0xE8BD 0x43F0      POP      {R4-R9,LR}
   \   00000178   0x2001             MOVS     R0,#+1
   \   0000017A   0x.... 0x....      B.W      SRFlow__InitLogEvent
    819          }
    820          
    821          //---------------------------------------------------------------------------------------------------------------------
    822          /**
    823           *    @brief    This method makes the controller to work at low speed
    824           *    @details  The clock speed in the low power mode is depend on the clock source
    825           *
    826           *    Note - 1. The low speed clock should not be set less than 4MHz to run the Wide and time dependent Application.
    827           *           2. For the time precision application its recommend to use the External clock source during the low speed.
    828           */

   \                                 In section .text, align 2, keep-with-next
    829          void Micro__SetLowSpeedMode(void)
    830          {
   \                     Micro__SetLowSpeedMode: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    831          	uint8 temp_reg;
    832          	uint16 i;
    833          	MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    834              //Save and Disable the Interrupts
    835              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   00000004   0xF3EF 0x8410      MRS      R4,PRIMASK
   \   00000008   0xB672             CPSID    I
    836          	#if (MICRO_WATCHDOG_FEATURE == ENABLED)
    837          		SERVICE_WATCHDOG();
                 		^
Remark[Pe1348]: declaration hides variable "local_interrupt_context" (declared
          at line 833)
   \   0000000A   0xF3EF 0x8310      MRS      R3,PRIMASK
   \   0000000E   0xB672             CPSID    I
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable31  ;; 0x4005200c
   \   00000014   0xF24A 0x6102      MOVW     R1,#+42498
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   \   0000001A   0xF24B 0x4280      MOVW     R2,#+46208
   \   0000001E   0x8002             STRH     R2,[R0, #+0]
   \   00000020   0xF383 0x8810      MSR      PRIMASK,R3
    838          	#endif
    839          
    840          		/* Select the desired IRC */
    841          		MCG.MCG_C2.BYTE|= MCG_C2_IRCS_MASK;
   \   00000024   0x.... 0x....      LDR.W    R3,??DataTable32_1  ;; 0x40064000
   \   00000028   0x785D             LDRB     R5,[R3, #+1]
   \   0000002A   0xF045 0x0501      ORR      R5,R5,#0x1
   \   0000002E   0x705D             STRB     R5,[R3, #+1]
    842          
    843          		temp_reg = MCG.MCG_C1.BYTE;
    844          		temp_reg &= ~MCG_C1_CLKS_MASK;							//clear CLKS
    845          		temp_reg |= MCG_C1_CLKS(1);								//select IRC as the MCG clock sourse
    846          		MCG.MCG_C1.BYTE = 1<< MCG_C1_CLKS_SHIFT;
   \   00000030   0x2540             MOVS     R5,#+64
   \   00000032   0x701D             STRB     R5,[R3, #+0]
    847          
    848          		SERVICE_WATCHDOG();
                 		^
Remark[Pe1348]: declaration hides variable "local_interrupt_context" (declared
          at line 833)
   \   00000034   0xF3EF 0x8510      MRS      R5,PRIMASK
   \   00000038   0xB672             CPSID    I
   \   0000003A   0x8001             STRH     R1,[R0, #+0]
   \   0000003C   0x8002             STRH     R2,[R0, #+0]
   \   0000003E   0xF385 0x8810      MSR      PRIMASK,R5
    849          		/* wait until internal reference switches to requested irc. */
    850          		for (i = 0; i < 2000; i++)
   \   00000042   0xF44F 0x65FA      MOV      R5,#+2000
   \   00000046   0x462E             MOV      R6,R5
    851          			{
    852          				if (!(MCG.MCG_S.BYTE & MCG_S_IRCST_MASK))
   \                     ??Micro__SetLowSpeedMode_0: (+1)
   \   00000048   0x799F             LDRB     R7,[R3, #+6]
   \   0000004A   0x07FF             LSLS     R7,R7,#+31
   \   0000004C   0xD501             BPL.N    ??Micro__SetLowSpeedMode_1
    853          					break;										//jump out early if IRCST clears before loop finishes
    854          			}
   \   0000004E   0x1E76             SUBS     R6,R6,#+1
   \   00000050   0xD1FA             BNE.N    ??Micro__SetLowSpeedMode_0
    855          
    856          		SERVICE_WATCHDOG();
                 		^
Remark[Pe1348]: declaration hides variable "local_interrupt_context" (declared
          at line 833)
   \                     ??Micro__SetLowSpeedMode_1: (+1)
   \   00000052   0xF3EF 0x8610      MRS      R6,PRIMASK
   \   00000056   0xB672             CPSID    I
   \   00000058   0x8001             STRH     R1,[R0, #+0]
   \   0000005A   0x8002             STRH     R2,[R0, #+0]
   \   0000005C   0xF386 0x8810      MSR      PRIMASK,R6
    857          		/* Wait for clock status bits to update */
    858          		for (i = 0; i < 2000; i++)
    859          		{
    860          			if (((MCG.MCG_S.BYTE & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)
   \                     ??Micro__SetLowSpeedMode_2: (+1)
   \   00000060   0x799E             LDRB     R6,[R3, #+6]
   \   00000062   0xF3C6 0x0681      UBFX     R6,R6,#+2,#+2
   \   00000066   0x2E01             CMP      R6,#+1
   \   00000068   0xD001             BEQ.N    ??Micro__SetLowSpeedMode_3
    861          				break;											// jump out early if CLKST shows IRC slected before loop finishes
    862          		}
   \   0000006A   0x1E6D             SUBS     R5,R5,#+1
   \   0000006C   0xD1F8             BNE.N    ??Micro__SetLowSpeedMode_2
    863          
    864          		MCG.MCG_C1.BIT.IRCLKEN = TRUE;
   \                     ??Micro__SetLowSpeedMode_3: (+1)
   \   0000006E   0x781D             LDRB     R5,[R3, #+0]
   \   00000070   0xF045 0x0502      ORR      R5,R5,#0x2
   \   00000074   0x701D             STRB     R5,[R3, #+0]
    865          		MCG.MCG_SC.BIT.FCRDIV = 0;
   \   00000076   0x7A1D             LDRB     R5,[R3, #+8]
   \   00000078   0xF005 0x05F1      AND      R5,R5,#0xF1
   \   0000007C   0x721D             STRB     R5,[R3, #+8]
    866          		MCG.MCG_C6.BYTE = 0<<MCG_C6_PLLS_SHIFT;   				//FLL is selected
   \   0000007E   0x2500             MOVS     R5,#+0
   \   00000080   0x715D             STRB     R5,[R3, #+5]
    867          
    868          		SERVICE_WATCHDOG();
                 		^
Remark[Pe1348]: declaration hides variable "local_interrupt_context" (declared
          at line 833)
   \   00000082   0xF3EF 0x8310      MRS      R3,PRIMASK
   \   00000086   0xB672             CPSID    I
   \   00000088   0x8001             STRH     R1,[R0, #+0]
   \   0000008A   0x8002             STRH     R2,[R0, #+0]
   \   0000008C   0xF383 0x8810      MSR      PRIMASK,R3
    869          		MicroGetClocksStatus();
   \   00000090   0x.... 0x....      BL       MicroGetClocksStatus
    870          		
    871          	    //Restore Interrupts
    872          	    MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \   00000094   0xF384 0x8810      MSR      PRIMASK,R4
    873          }
   \   00000098   0xB001             ADD      SP,SP,#+4
   \   0000009A   0xBDF0             POP      {R4-R7,PC}       ;; return
    874          
    875          //---------------------------------------------------------------------------------------------------------------------
    876          /**
    877           * @brief    This method configured the Low Voltage Detection if the feature is available.
    878           * @image    html SRMicro_LVD.jpg
    879           */

   \                                 In section .text, align 2, keep-with-next
    880          void Micro__ConfigureLvd(void)
    881          {
    882          	#if (LOW_VOLTAGE_MONITOR_FEATURE == ENABLED)
    883          
    884          		PMC.LVDSC1.BIT.LVDACK = 1;                      //LVWF must be clear by writing LVWACK first
   \                     Micro__ConfigureLvd: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable32_2  ;; 0x4007d000
   \   00000004   0x7801             LDRB     R1,[R0, #+0]
   \   00000006   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
   \   0000000C   0x2203             MOVS     R2,#+3
    885          
    886          		//LVD interrupt operation
    887          		#if(LOW_VOLTAGE_DETECT_ACTION == ENABLED)
    888          			PMC.LVDSC1.BIT.LVDRE = TRUE;                //Forces an MCU reset when an enabled LVD event occurs
    889          			PMC.LVDSC1.BIT.LVDIE = TRUE;                //Configure interrupt i.e Low-Voltage Detect Interrupt Enable
    890          
    891          		#else
    892          			PMC.LVDSC1.BIT.LVDRE = FALSE;               //LVD events do not generate hardware resets
   \   0000000E   0x7801             LDRB     R1,[R0, #+0]
   \   00000010   0xF001 0x01EF      AND      R1,R1,#0xEF
   \   00000014   0x7001             STRB     R1,[R0, #+0]
    893          			PMC.LVDSC1.BIT.LVDIE = FALSE;               //Configure the interrupt i.e Low-voltage warning Interrupt Disable.
   \   00000016   0x7801             LDRB     R1,[R0, #+0]
   \   00000018   0xF001 0x01DF      AND      R1,R1,#0xDF
   \   0000001C   0x7001             STRB     R1,[R0, #+0]
    894          
    895          		#endif
    896          
    897          		//Configure the threshold voltage level
    898          		PMC.LVDSC1.BYTE |= PMC_LVDSC1_LVDV(LVD_LEVEL);             //Selects Low-Voltage Detect Voltage Select
   \   0000001E   0x7801             LDRB     R1,[R0, #+0]
   \   00000020   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000024   0x7001             STRB     R1,[R0, #+0]
    899          
    900          		//Low-voltage warning (LVW) interrupt operation
    901          		PMC.LVDSC2.BIT.LVWACK = 1;                      //LVWF must be clear by writing LVWACK first
   \   00000026   0x7841             LDRB     R1,[R0, #+1]
   \   00000028   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000002C   0x7041             STRB     R1,[R0, #+1]
    902          
    903          		#if(LOW_VOLTAGE_WARNING_ACTION == ENABLED)
    904          			PMC.LVDSC1.BIT.LVWIE = TRUE;                //Enables hardware interrupt requests for LVWF.
    905          
    906          		#else
    907          			PMC.LVDSC2.BIT.LVWIE = FALSE;               //Enables hardware interrupt requests for LVWF.
   \   0000002E   0x7841             LDRB     R1,[R0, #+1]
   \   00000030   0xF001 0x01DF      AND      R1,R1,#0xDF
   \   00000034   0x7041             STRB     R1,[R0, #+1]
    908          
    909          		#endif
    910          
    911          
    912          
    913          		//Configure the threshold voltage level
    914          		PMC.LVDSC2.BYTE |= PMC_LVDSC2_LVWV(LVW_LEVEL);             //Selects Low-Voltage Warning Voltage Select
   \   00000036   0x7841             LDRB     R1,[R0, #+1]
   \   00000038   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000003C   0x7041             STRB     R1,[R0, #+1]
    915          //
    916          //		//Enable the voltage detector - This filed can be written only one time after resets additional writes are ignored
    917          //		PMC.SPMSC1.BIT.LVDE = TRUE;			            //Enabled LVD logic
    918          //
    919          //		PMC.SPMSC1.BIT.LVDSE = FALSE;
    920          
    921          		Micro__NVICEnableIRQ(LVD_LVW_IRQ_CHANNEL,PVD_PREEMPTION_PRIORITY,PVD_PREEMPTION_SUB_PRIORITY);
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable32_3  ;; 0xe000e100
   \   00000042   0xF8D0 0x1C0C      LDR      R1,[R0, #+3084]
   \   00000046   0xF401 0x61E0      AND      R1,R1,#0x700
   \   0000004A   0xF5C1 0x61E0      RSB      R1,R1,#+1792
   \   0000004E   0x0A09             LSRS     R1,R1,#+8
   \   00000050   0xF1C1 0x0304      RSB      R3,R1,#+4
   \   00000054   0x409A             LSLS     R2,R2,R3
   \   00000056   0x230F             MOVS     R3,#+15
   \   00000058   0xFA23 0xF101      LSR      R1,R3,R1
   \   0000005C   0xF001 0x0103      AND      R1,R1,#0x3
   \   00000060   0x4311             ORRS     R1,R1,R2
   \   00000062   0x0109             LSLS     R1,R1,#+4
   \   00000064   0xF880 0x1314      STRB     R1,[R0, #+788]
   \   00000068   0xF44F 0x1180      MOV      R1,#+1048576
   \   0000006C   0x6001             STR      R1,[R0, #+0]
    922          
    923          	#else
    924          
    925          //		PMC.SPMSC1.BIT.LVDE = FALSE;			        //Disable the voltage detector
    926                                                                  //This filed can be written only one time after resets additional writes are ignored
    927          	#endif
    928          }
   \   0000006E   0x4770             BX       LR               ;; return
    929          
    930          //---------------------------------------------------------------------------------------------------------------------
    931          /**
    932           * @brief This method should be called from the Low Voltage detection interrupt handle which is application specific.
    933           *        This function only clear the register related to the interruption if need.
    934           *        This is not the handler for the interrupt, this code should be managed by the Application specific code which knows
    935           *        what must be done during the LVD ISR.
    936           */

   \                                 In section .text, align 2, keep-with-next
    937          void Micro__ClearLvdIsrRegisters(void)
    938          {
    939              #if (LOW_VOLTAGE_MONITOR_FEATURE == ENABLED)
    940                      PMC.LVDSC2.BIT.LVWACK = 1;
   \                     Micro__ClearLvdIsrRegisters: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable32_4  ;; 0x4007d001
   \   00000004   0x7801             LDRB     R1,[R0, #+0]
   \   00000006   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
    941              #endif
    942          }
   \   0000000C   0x4770             BX       LR               ;; return
    943          
    944          //---------------------------------------------------------------------------------------------------------------------
    945          /**
    946           * @brief This method returns the current status of the LVD.
    947           *
    948           *    @return   MICRO_LVD_STATUS_TYPE :
    949           *               MICRO_LVD_DISABLED              - If the LVD is disabled
    950           *               MICRO_LVD_ENABLED_NOT_DETECTING - The LVD is enabled and low voltage threshold condition not happened
    951           *               MICRO_LVD_ENABLED_DETECTING     - The LVD is enabled and low voltage threshold condition is occured
    952           */

   \                                 In section .text, align 2, keep-with-next
    953          MICRO_LVD_STATUS_TYPE  Micro__GetLvdStatus(void)
    954          {
    955              MICRO_LVD_STATUS_TYPE lvdreturn;
    956          
    957              lvdreturn = MICRO_LVD_DISABLED;
    958          
    959              #if (LOW_VOLTAGE_MONITOR_FEATURE == ENABLED)
    960                  if(PMC.LVDSC1.BIT.LVDRE == TRUE)
   \                     Micro__GetLvdStatus: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable32_2  ;; 0x4007d000
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \   0000000A   0xB108             CBZ.N    R0,??Micro__GetLvdStatus_0
    961                  {
    962                      lvdreturn = MICRO_LVD_ENABLED_DETECTING;
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0x4770             BX       LR
    963                  }
    964                  else
    965                  {
    966                      lvdreturn = MICRO_LVD_ENABLED_NOT_DETECTING;
   \                     ??Micro__GetLvdStatus_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
    967                  }
    968              #endif
    969          
    970              return (lvdreturn);
   \   00000012   0x4770             BX       LR               ;; return
    971          
    972          }
    973          
    974          //---------------------------------------------------------------------------------------------------------------------
    975          /**
    976           *    @brief    This function enables and sets priority for a device specific interrupt in the NVIC interrupt controller.
    977           *    @details
    978           *    @param	irqchnl		: Defines the IRQ Channel number should be from the "IRQ_CHANNEL_TYPE" enum list.
    979           *    @param	priority	: Should range from 0 to 3.
    980           *    						  0 is the Highest priority and 3 is the lowest priority.
    981           *
    982           *    Note: The priority cannot be set for every core interrupt.
    983           */

   \                                 In section .text, align 2, keep-with-next
    984          void Micro__NVICEnableIRQ(IRQ_CHANNEL_TYPE irqchnl, uint8 premption_priority, uint8 sub_priority)
    985          {
    986              uint32 tmppriority;
    987              uint32 tmppre;
    988              uint32 tmpsub;
    989          
    990              tmppriority = 0x00;
    991              tmppre = 0x00;
    992              tmpsub = 0x0F;
    993          
    994              //if (irqchnl != INVALID_IRQ_CHANNEL)
    995              {
    996              //Compute the Corresponding IRQ Priority --------------------------------
    997              tmppriority = (0x700 - ((SCB.AIRCR) & (uint32)0x700))>> 0x08;
   \                     Micro__NVICEnableIRQ: (+1)
   \   00000000   0x.... 0x....      LDR.W    R3,??DataTable32_5  ;; 0xe000ed0c
   \   00000004   0x681B             LDR      R3,[R3, #+0]
   \   00000006   0xF403 0x63E0      AND      R3,R3,#0x700
   \   0000000A   0xF5C3 0x63E0      RSB      R3,R3,#+1792
   \   0000000E   0x0A1B             LSRS     R3,R3,#+8
    998              tmppre = (0x4 - tmppriority);
    999              tmpsub = tmpsub >> tmppriority;
   1000          
   1001              tmppriority = (uint32)(premption_priority << tmppre);
   1002              tmppriority |=  sub_priority & tmpsub;
   1003              tmppriority = tmppriority << 0x04;
   \   00000010   0xF1C3 0x0C04      RSB      R12,R3,#+4
   \   00000014   0xFA01 0xF10C      LSL      R1,R1,R12
   \   00000018   0xF04F 0x0C0F      MOV      R12,#+15
   \   0000001C   0xFA2C 0xF303      LSR      R3,R12,R3
   \   00000020   0x401A             ANDS     R2,R3,R2
   \   00000022   0x4311             ORRS     R1,R2,R1
   \   00000024   0x0109             LSLS     R1,R1,#+4
   1004          
   1005          	if(irqchnl < 0)
   \   00000026   0x0002             MOVS     R2,R0
   \   00000028   0xD507             BPL.N    ??Micro__NVICEnableIRQ_0
   1006          	{
   1007          	    SCB.SHP[((uint32)(irqchnl) & 0xF)-4] = tmppriority;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable32_6  ;; 0xe000ed18
   \   0000002E   0xF002 0x020F      AND      R2,R2,#0xF
   \   00000032   0x1810             ADDS     R0,R2,R0
   \   00000034   0xF800 0x1C04      STRB     R1,[R0, #-4]
   \   00000038   0x4770             BX       LR
   1008          	}
   \                     ??Micro__NVICEnableIRQ_0: (+1)
   \   0000003A   0x0952             LSRS     R2,R2,#+5
   1009          	else
   1010          	{
   1011          	    NVIC.Priority[(uint32)(irqchnl)] = tmppriority;
   \   0000003C   0x.... 0x....      LDR.W    R12,??DataTable26_2  ;; 0xe000e400
   \   00000040   0xF800 0x100C      STRB     R1,[R0, R12]
   1012          
   1013          	    // Enable the Selected IRQ Channels --------------------------------------
   1014                  NVIC.Enable[(uint32)((uint32)irqchnl) >> 5] = (uint32)(1 << ((uint32)((uint32)irqchnl) & (uint32)0x1F));
   \   00000044   0xF000 0x001F      AND      R0,R0,#0x1F
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0xFA01 0xF000      LSL      R0,R1,R0
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable32_3  ;; 0xe000e100
   \   00000052   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
   1015          	}
   1016          	}
   1017          }
   \   00000056   0x4770             BX       LR               ;; return
   1018          
   1019          //---------------------------------------------------------------------------------------------------------------------
   1020          /**
   1021           *    @brief    Disable External Interrupt
   1022           *    @details	This function disables a device specific interrupt in the NVIC interrupt controller.
   1023           *    			The interrupt number cannot be a negative value.
   1024           *
   1025           *    @param	irqchnl		: Defines the IRQ Channel number should be from the "IRQ_CHANNEL_TYPE" enum list.
   1026           */

   \                                 In section .text, align 2, keep-with-next
   1027          void Micro__NVICDisableIRQ(IRQ_CHANNEL_TYPE irqchnl)
   1028          {
   1029              if(irqchnl > 0)
   \                     Micro__NVICDisableIRQ: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xDB08             BLT.N    ??Micro__NVICDisableIRQ_0
   1030              {
   1031          		// Disable the Selected IRQ Channels 
   1032          	   	NVIC.Disable[((uint32)(irqchnl) >> 5)] = (1 << ((uint32)(irqchnl) & 0x1F));
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF000 0x021F      AND      R2,R0,#0x1F
   \   0000000A   0x4091             LSLS     R1,R1,R2
   \   0000000C   0x.... 0x....      LDR.W    R2,??DataTable34  ;; 0xe000e180
   \   00000010   0x0940             LSRS     R0,R0,#+5
   \   00000012   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   1033              }
   1034          }
   \                     ??Micro__NVICDisableIRQ_0: (+1)
   \   00000016   0x4770             BX       LR               ;; return
   1035          
   1036          //---------------------------------------------------------------------------------------------------------------------
   1037          /**
   1038           *    @brief    Handler for a Hard Fault exception.
   1039           *    @details
   1040           *    @remarks  Currently only division by zero exception is handled.
   1041           */

   \                                 In section .text, align 2, keep-with-next
   1042          INTERRUPT_DIRECTIVE void Micro__HardfaultHdlr(void)
   1043          {
   1044              if ((SCB.HFSR & (1 << 30)) != 0)
   \                     Micro__HardfaultHdlr: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable32_5  ;; 0xe000ed0c
   \   00000004   0x6A01             LDR      R1,[R0, #+32]
   \   00000006   0x0049             LSLS     R1,R1,#+1
   \   00000008   0xBF48             IT       MI 
   1045              {
   1046                  if ((SCB.CFSR & (1UL << 25)) != 0)
   \   0000000A   0x69C1             LDRMI    R1,[R0, #+28]
   1047                  {
   1048                      //SRException__Queue(EXCEPTION_DIVISION_BY_ZERO, 0, 0);
   1049                  }
   1050              }
   1051              SYSTEM_RESET();
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable34_1  ;; 0x5fa0004
   \   00000010   0x6001             STR      R1,[R0, #+0]
   1052          }
   \   00000012   0x4770             BX       LR               ;; return
   1053          
   1054          
   1055          //------------------------------------------------------------------------------------------------------------------------------
   1056          /**
   1057          *    @brief    This method is used for Core/System clock oscillation frequency errors can be detected.
   1058          *    @details  This ISR function measure the cycle of the frequency-divided LPO clock used for the independent watchdog timer (IWDT)
   1059          *              in the MKV03x. By this function, the main Core/System clock oscillation frequency errors can be detected.
   1060          *              This needs to be configured in the SRInterruptVector_prm.h & SRClockMonitor_prv.h file as below
   1061          *
   1062          *              #define LOW_POWER_TIMER                             Micro__LPTimerInterrupt
   1063          *
   1064          *              It defines the maximum number of TimerInterrupt counts above the expected is acceptable for the external clock source base
   1065          *              #define SRCLOCKMONITOR_CLK_TICKS_ABOVE       5
   1066          *
   1067          *              It defines the minimum number of TimerInterrupt counts below the expected is acceptable for the external clock source base
   1068          *              #define SRCLOCKMONITOR_CLK_TICKS_BELOW       5
   1069          *
   1070          *              example: for by default LPTIMER = 1Khz  & Prescaler is disabled  = 1msec
   1071          *              #define MICRO_LPTIMER_COMPARE_VAL    50 (i.e 50msec )
   1072          *              For every 50 msec LPTimer will generate an interrupt so compare this with SR Clockmonitor
   1073          *              to test Core/System clock by keeping min and max limits
   1074          *
   1075          */

   \                                 In section .text, align 2, keep-with-next
   1076          INTERRUPT_DIRECTIVE void Micro__LPTimerInterrupt(void)
   1077          {
   1078              #if(MICRO_LPTIMER_EXTCLOCKSOURCE == ENABLED)
   1079          
   1080                  /* write 1 to TCF to clear the LPT timer compare flag */
   1081                  LPTMR0.CSR |= LPTMR_CSR_TCF_MASK;
   \                     Micro__LPTimerInterrupt: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable32  ;; 0x40040000
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF041 0x0180      ORR      R1,R1,#0x80
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   1082                  LPTMR0.CSR = (LPTMR_CSR_TEN_MASK | LPTMR_CSR_TIE_MASK | LPTMR_CSR_TCF_MASK);
   \   0000000C   0x21C1             MOVS     R1,#+193
   \   0000000E   0x6001             STR      R1,[R0, #+0]
   1083          
   1084                  SRMICRO_EXCEPTION_CONTINUOUS_LPTIMER_HANDLER();
   \   00000010   0x20C8             MOVS     R0,#+200
   \   00000012   0x.... 0x....      B.W      SRClockMonitor__MonitorExtClk
   1085              #endif
   1086          }
   1087          
   1088          //---------------------------------------------------------------------------------------------------------------------
   1089          /**
   1090           * List all the generic API's used across different micro
   1091           */
   1092          
   1093          //---------------------------------------------------------------------------------------------------------------------
   1094          /**
   1095           *    @brief    This method performs the Boot test during the system boot.
   1096           *    @details  This method is the first function to be executed in the system and from this function the code
   1097           *              goes to the main function.
   1098           *
   1099           *              This method is responsible for:
   1100           *              CPU Register Boot Test,
   1101           *              Watchdog Boot test,
   1102           *              RAM MarchC test,
   1103           *              Flash Boot test
   1104           *              and writing stack test pattern at the boundaries of stack memory.
   1105           *              After this it calls the system startup routine.
   1106           *
   1107           *
   1108           *              Note-1. The Independent watchdog refresh time should be big enough to perform the boot test
   1109           *                   2. The boot test should not be performed when the application is running.
   1110           */
   1111          #pragma optimize=none

   \                                 In section .text, align 2, keep-with-next
   1112          INTERRUPT_DIRECTIVE void Micro__BootTest(void)
   1113          {
   \                     Micro__BootTest: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   1114              #if (MICRO_SR_FEATURE_TEST == ENABLED)
   1115          		register uint8 sr_boot_test_counter = 0;       //Variable used for testing whether the flow is correct or incorrect
   \   00000004   0xF05F 0x0800      MOVS     R8,#+0
   1116                  register uint8 result;
   1117                  register uint32 counter;
   1118                  register uint32 mask;
   1119              #endif
   1120          
   1121              //Byte 1 - save_reset_status
   1122              //Byte 0 - save_reset_sync
   1123              register uint32 save_reset_value;
   1124          
   1125              MICRO_BOOTTEST_MICROHWINIT();
   \   00000008   0x.... 0x....      BL       MicroHWInit
   1126              #if (MICRO_SR_FEATURE_TEST == ENABLED)
   1127                  //-----------------------------------------------------------------------------------------------------------------
   1128                  // CLASSB Test : Full register test
   1129                  //
   1130                  //Its mandatory to test all the CPU register test
   1131                  //-----------------------------------------------------------------------------------------------------------------
   1132                  if (FALSE == MICRO_BOOTTEST_REGTEST())
   \   0000000C   0x.... 0x....      BL       __StartupRegisterTest
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD105             BNE.N    ??Micro__BootTest_0
   1133                  {
   1134                      //This is the routine where the application will end up if a test fails during the boot time.
   1135                      while(1)
   1136                      {
   1137                         #ifdef MICRO_SR_BOOTTEST_FAILURE_TASK
   1138                             SERVICE_WATCHDOG();
   1139                             MICRO_SR_BOOTTEST_FAILURE_TASK();
   1140                         #else
   1141                              SYSTEM_RESET();
   \                     ??Micro__BootTest_1: (+1)
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable36  ;; 0x5fa0004
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable32_5  ;; 0xe000ed0c
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   \   0000001E   0xE7F9             B.N      ??Micro__BootTest_1
   1142                         #endif
   1143                      }
   1144                  }
   1145              #endif
   1146          
   1147              //This function realizes the reset mode
   1148              MicroResetHandling();
   \                     ??Micro__BootTest_0: (+1)
   \   00000020   0x.... 0x....      BL       MicroResetHandling
   1149              #if (MICRO_SR_FEATURE_TEST == ENABLED)
   1150                  sr_boot_test_counter++;
   \   00000024   0xF118 0x0801      ADDS     R8,R8,#+1
   1151              #endif
   1152          
   1153              if (Micro__GetResetMode() == MICRO_RESET_MODE_COLD)
   \   00000028   0x.... 0x....      BL       Micro__GetResetMode
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD101             BNE.N    ??Micro__BootTest_2
   1154              {
   1155                  RAM_DATA_INITIALIZE();
   \   00000030   0x.... 0x....      BL       __iar_data_init3
   1156              }
   1157          
   1158              #if (MICRO_SRPOWERMGR_FEATURE == ENABLED)
   1159                  #if (MICRO_SR_FEATURE_TEST == ENABLED)
   1160                      Micro_Flow = MICRO_FLOW_SRPOWERMGR_INIT;
   1161                      N_Micro_Flow = (uint8)MICRO_SRDATA__COMPLEMENT(MICRO_FLOW_SRPOWERMGR_INIT);
   1162                  #endif
   1163                  SRPowerMgr__Initialize();
   1164              #endif
   1165          
   1166              MICRO_CALLBACK_BEFORE_WATCHDOG_INIT();
   \                     ??Micro__BootTest_2: (+1)
   \   00000034   0x.... 0x....      BL       SRMCPwm__Initialize_Before_Boot
   1167          
   1168              //Initialize the watchdog
   1169              MICRO_BOOTTEST_WDTINIT();
   \   00000038   0x.... 0x....      BL       Micro__ConfigureWDT
   1170          	#if (MICRO_SR_FEATURE_TEST == ENABLED)
   1171          		sr_boot_test_counter++;
   \   0000003C   0xF118 0x0801      ADDS     R8,R8,#+1
   1172          	#endif
   1173          
   1174              //Initializes the system clock
   1175              MICRO_BOOTTEST_CLKINIT();
   \   00000040   0x.... 0x....      BL       MicroInitClkLowSpeed
   1176          	#if (MICRO_SR_FEATURE_TEST == ENABLED)
   1177          		sr_boot_test_counter++;
   \   00000044   0xF118 0x0801      ADDS     R8,R8,#+1
   1178                  MicroValidateResetInfoDataCrc();
   \   00000048   0x.... 0x....      BL       MicroValidateResetInfoDataCrc
   1179                  if ((Micro_ResetInfo.Warm_Reset_Actions & MICRO_WARM_RESET_ACTION_SKIP_CLASSB_TEST) == 0)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable36_1
   \   00000050   0xF890 0x002F      LDRB     R0,[R0, #+47]
   \   00000054   0x0740             LSLS     R0,R0,#+29
   \   00000056   0xD435             BMI.N    ??Micro__BootTest_3
   1180                  {
   1181          
   1182                      if (sr_boot_test_counter != MICRO_BOOT_SEQUENCE_1)
   \   00000058   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000005C   0xF1B8 0x0F03      CMP      R8,#+3
   \   00000060   0xD001             BEQ.N    ??Micro__BootTest_4
   1183                      {
   1184                        MicroFailSafe();
   \   00000062   0x.... 0x....      BL       MicroFailSafe
   1185                      }
   1186          
   1187                      //Skip storing the reset reason as this is the intended reset for test
   1188                      Micro__EnableWarmResetAction(MICRO_WARM_RESET_ACTION_SKIP_WATCHDOG_TEST);
   \                     ??Micro__BootTest_4: (+1)
   \   00000066   0x2008             MOVS     R0,#+8
   \   00000068   0x.... 0x....      BL       Micro__EnableWarmResetAction
   1189          
   1190                      //-----------------------------------------------------------------------------------------------------------------
   1191                      // CLASSB Test : Watchdog Test
   1192                      //
   1193                      //It's mandatory to use the Independent watchdog for the CLASSB test
   1194                      //-----------------------------------------------------------------------------------------------------------------
   1195                      MICRO_BOOTTEST_WDTEST();
   \   0000006C   0x.... 0x....      BL       MicroBootWatchdogTest
   1196                      sr_boot_test_counter++;
   \   00000070   0xF118 0x0801      ADDS     R8,R8,#+1
   1197                      SERVICE_WATCHDOG();
   \   00000074   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000078   0x4681             MOV      R9,R0
   \   0000007A   0xB672             CPSID    I
   \   0000007C   0xF24A 0x6002      MOVW     R0,#+42498
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable36_2  ;; 0x4005200c
   \   00000084   0x8008             STRH     R0,[R1, #+0]
   \   00000086   0xF24B 0x4080      MOVW     R0,#+46208
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable36_2  ;; 0x4005200c
   \   0000008E   0x8008             STRH     R0,[R1, #+0]
   \   00000090   0xF389 0x8810      MSR      PRIMASK,R9
   1198          
   1199                      //-----------------------------------------------------------------------------------------------------------------
   1200                      // CLASSB Test : Flash CRC test
   1201                      //
   1202                      //This test is used to validate the non-volatile memory consistency
   1203                      //-----------------------------------------------------------------------------------------------------------------
   1204                      MICRO_BOOTTEST_FLASHTEST();
   \   00000094   0x.... 0x....      BL       MicroBootFlashTest
   1205                      sr_boot_test_counter++;
   \   00000098   0xF118 0x0801      ADDS     R8,R8,#+1
   1206                      SERVICE_WATCHDOG();
   \   0000009C   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   000000A0   0x4682             MOV      R10,R0
   \   000000A2   0xB672             CPSID    I
   \   000000A4   0xF24A 0x6002      MOVW     R0,#+42498
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable36_2  ;; 0x4005200c
   \   000000AC   0x8008             STRH     R0,[R1, #+0]
   \   000000AE   0xF24B 0x4080      MOVW     R0,#+46208
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable36_2  ;; 0x4005200c
   \   000000B6   0x8008             STRH     R0,[R1, #+0]
   \   000000B8   0xF38A 0x8810      MSR      PRIMASK,R10
   1207          
   1208                      //Skip the ClassB test during warm reset
   1209                      Micro__EnableWarmResetAction(MICRO_WARM_RESET_ACTION_SKIP_CLASSB_TEST);
   \   000000BC   0x2004             MOVS     R0,#+4
   \   000000BE   0x.... 0x....      BL       Micro__EnableWarmResetAction
   \   000000C2   0xE001             B.N      ??Micro__BootTest_5
   1210                  }
   1211                  else
   1212                  {
   1213                      sr_boot_test_counter += 2;
   \                     ??Micro__BootTest_3: (+1)
   \   000000C4   0xF118 0x0802      ADDS     R8,R8,#+2
   1214                  }
   1215          
   1216                  if (sr_boot_test_counter != MICRO_BOOT_SEQUENCE_2)
   \                     ??Micro__BootTest_5: (+1)
   \   000000C8   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000CC   0xF1B8 0x0F05      CMP      R8,#+5
   \   000000D0   0xD001             BEQ.N    ??Micro__BootTest_6
   1217                  {
   1218                    MicroFailSafe();
   \   000000D2   0x.... 0x....      BL       MicroFailSafe
   1219                  }
   1220              #endif
   1221          
   1222              MicroValidateResetInfoDataCrc();
   \                     ??Micro__BootTest_6: (+1)
   \   000000D6   0x.... 0x....      BL       MicroValidateResetInfoDataCrc
   1223              if (Micro_ResetInfo.Mode == MICRO_RESET_MODE_COLD)
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable36_1
   \   000000DE   0xF890 0x002E      LDRB     R0,[R0, #+46]
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xF040 0x810C      BNE.W    ??Micro__BootTest_7
   1224              {
   1225                  MicroValidateResetInfoDataCrc();
   \   000000E8   0x.... 0x....      BL       MicroValidateResetInfoDataCrc
   1226          
   1227                  //Save reset status on Auto register as March C test will screw the all ram memory content
   1228                  save_reset_value    =   (*(uint8 *)(&Micro_ResetInfo.Actual_Reset));
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable36_1
   \   000000F0   0xF890 0x002D      LDRB     R0,[R0, #+45]
   \   000000F4   0x0006             MOVS     R6,R0
   1229                  save_reset_value   |=   ((*(uint8 *)(&Micro_ResetInfo.Reset)) << 8);
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable36_1
   \   000000FA   0xF890 0x002C      LDRB     R0,[R0, #+44]
   \   000000FE   0xEA56 0x2600      ORRS     R6,R6,R0, LSL #+8
   1230          
   1231                  //-----------------------------------------------------------------------------------------------------------------
   1232                  // CLASSB Test : RAM MARCH C Test and Bit coupling test
   1233                  //
   1234                  // This test is used to validate the volatile memory by using the MARCH C test and bit coupling test
   1235                  //-----------------------------------------------------------------------------------------------------------------
   1236                  //-----------------------------------------------------------------------------------------------------------------
   1237                  // CLASSB Test : RAM MARCH C Test
   1238                  //
   1239                  //This test is used to validate the volatile memory by using the MARCH C test
   1240                  //-----------------------------------------------------------------------------------------------------------------
   1241                  #if (MICRO_SR_FEATURE_TEST == ENABLED)
   1242                      SERVICE_WATCHDOG();
   \   00000102   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   00000106   0x0008             MOVS     R0,R1
   \   00000108   0xB672             CPSID    I
   \   0000010A   0xF24A 0x6102      MOVW     R1,#+42498
   \   0000010E   0x.... 0x....      LDR.W    R2,??DataTable36_2  ;; 0x4005200c
   \   00000112   0x8011             STRH     R1,[R2, #+0]
   \   00000114   0xF24B 0x4180      MOVW     R1,#+46208
   \   00000118   0x.... 0x....      LDR.W    R2,??DataTable36_2  ;; 0x4005200c
   \   0000011C   0x8011             STRH     R1,[R2, #+0]
   \   0000011E   0xF380 0x8810      MSR      PRIMASK,R0
   1243          
   1244                      result = TRUE;
   \   00000122   0x2101             MOVS     R1,#+1
   \   00000124   0x000C             MOVS     R4,R1
   1245          
   1246                      //=>W0
   1247                      for (counter = MICRO_RAM_START_ADDRESS; counter <= MICRO_RAM_END_ADDRESS; counter++)
   \   00000126   0x.... 0x....      LDR.W    R1,??DataTable34_2
   \   0000012A   0x000F             MOVS     R7,R1
   \                     ??Micro__BootTest_8: (+1)
   \   0000012C   0x.... 0x....      LDR.W    R0,??DataTable34_3
   \   00000130   0x42B8             CMP      R0,R7
   \   00000132   0xD303             BCC.N    ??Micro__BootTest_9
   1248                      {
   1249                          *((uint8 *)counter) = 0;
   \   00000134   0x2000             MOVS     R0,#+0
   \   00000136   0x7038             STRB     R0,[R7, #+0]
   1250                      }
   \   00000138   0x1C7F             ADDS     R7,R7,#+1
   \   0000013A   0xE7F7             B.N      ??Micro__BootTest_8
   1251                          sr_boot_test_counter++;
   \                     ??Micro__BootTest_9: (+1)
   \   0000013C   0xF118 0x0801      ADDS     R8,R8,#+1
   1252                      //=>(R0, W1)
   1253                      for (counter = MICRO_RAM_START_ADDRESS; counter <= MICRO_RAM_END_ADDRESS; counter++)
   \   00000140   0x.... 0x....      LDR.W    R0,??DataTable34_2
   \   00000144   0x0007             MOVS     R7,R0
   \                     ??Micro__BootTest_10: (+1)
   \   00000146   0x.... 0x....      LDR.W    R0,??DataTable34_3
   \   0000014A   0x42B8             CMP      R0,R7
   \   0000014C   0xD308             BCC.N    ??Micro__BootTest_11
   1254                      {
   1255                          if (*((uint8 *)counter) != 0)
   \   0000014E   0x7838             LDRB     R0,[R7, #+0]
   \   00000150   0x2800             CMP      R0,#+0
   \   00000152   0xD001             BEQ.N    ??Micro__BootTest_12
   1256                          {
   1257                              result = FALSE;
   \   00000154   0x2000             MOVS     R0,#+0
   \   00000156   0x0004             MOVS     R4,R0
   1258                          }
   1259                          *((uint8 *)counter) = 0xFF;
   \                     ??Micro__BootTest_12: (+1)
   \   00000158   0x20FF             MOVS     R0,#+255
   \   0000015A   0x7038             STRB     R0,[R7, #+0]
   1260                      }
   \   0000015C   0x1C7F             ADDS     R7,R7,#+1
   \   0000015E   0xE7F2             B.N      ??Micro__BootTest_10
   1261                          sr_boot_test_counter++;
   \                     ??Micro__BootTest_11: (+1)
   \   00000160   0xF118 0x0801      ADDS     R8,R8,#+1
   1262                      SERVICE_WATCHDOG();
   \   00000164   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   00000168   0x0008             MOVS     R0,R1
   \   0000016A   0xB672             CPSID    I
   \   0000016C   0xF24A 0x6102      MOVW     R1,#+42498
   \   00000170   0x.... 0x....      LDR.W    R2,??DataTable36_2  ;; 0x4005200c
   \   00000174   0x8011             STRH     R1,[R2, #+0]
   \   00000176   0xF24B 0x4180      MOVW     R1,#+46208
   \   0000017A   0x.... 0x....      LDR.W    R2,??DataTable36_2  ;; 0x4005200c
   \   0000017E   0x8011             STRH     R1,[R2, #+0]
   \   00000180   0xF380 0x8810      MSR      PRIMASK,R0
   1263          
   1264                      //=>(R1, W0)
   1265                      for (counter = MICRO_RAM_START_ADDRESS; counter <= MICRO_RAM_END_ADDRESS; counter++)
   \   00000184   0x.... 0x....      LDR.W    R1,??DataTable34_2
   \   00000188   0x000F             MOVS     R7,R1
   \                     ??Micro__BootTest_13: (+1)
   \   0000018A   0x.... 0x....      LDR.W    R0,??DataTable34_3
   \   0000018E   0x42B8             CMP      R0,R7
   \   00000190   0xD308             BCC.N    ??Micro__BootTest_14
   1266                      {
   1267                          if (*((uint8 *)counter) != 0xFF)
   \   00000192   0x7838             LDRB     R0,[R7, #+0]
   \   00000194   0x28FF             CMP      R0,#+255
   \   00000196   0xD001             BEQ.N    ??Micro__BootTest_15
   1268                          {
   1269                              result = FALSE;
   \   00000198   0x2000             MOVS     R0,#+0
   \   0000019A   0x0004             MOVS     R4,R0
   1270                          }
   1271                          *((uint8 *)counter) = 0x0;
   \                     ??Micro__BootTest_15: (+1)
   \   0000019C   0x2000             MOVS     R0,#+0
   \   0000019E   0x7038             STRB     R0,[R7, #+0]
   1272                      }
   \   000001A0   0x1C7F             ADDS     R7,R7,#+1
   \   000001A2   0xE7F2             B.N      ??Micro__BootTest_13
   1273                          sr_boot_test_counter++;
   \                     ??Micro__BootTest_14: (+1)
   \   000001A4   0xF118 0x0801      ADDS     R8,R8,#+1
   1274                      //<=(R0, W1)
   1275                      for (counter = MICRO_RAM_END_ADDRESS; counter >= MICRO_RAM_START_ADDRESS; counter--)
   \   000001A8   0x.... 0x....      LDR.W    R0,??DataTable34_3
   \   000001AC   0x0007             MOVS     R7,R0
   \                     ??Micro__BootTest_16: (+1)
   \   000001AE   0x.... 0x....      LDR.W    R0,??DataTable34_2
   \   000001B2   0x4287             CMP      R7,R0
   \   000001B4   0xD308             BCC.N    ??Micro__BootTest_17
   1276                      {
   1277                          if (*((uint8 *)counter) != 0)
   \   000001B6   0x7838             LDRB     R0,[R7, #+0]
   \   000001B8   0x2800             CMP      R0,#+0
   \   000001BA   0xD001             BEQ.N    ??Micro__BootTest_18
   1278                          {
   1279                              result = FALSE;
   \   000001BC   0x2000             MOVS     R0,#+0
   \   000001BE   0x0004             MOVS     R4,R0
   1280                          }
   1281                          *((uint8 *)counter) = 0xFF;
   \                     ??Micro__BootTest_18: (+1)
   \   000001C0   0x20FF             MOVS     R0,#+255
   \   000001C2   0x7038             STRB     R0,[R7, #+0]
   1282                      }
   \   000001C4   0x1E7F             SUBS     R7,R7,#+1
   \   000001C6   0xE7F2             B.N      ??Micro__BootTest_16
   1283                          sr_boot_test_counter++;
   \                     ??Micro__BootTest_17: (+1)
   \   000001C8   0xF118 0x0801      ADDS     R8,R8,#+1
   1284          
   1285                      SERVICE_WATCHDOG();
   \   000001CC   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   000001D0   0x0008             MOVS     R0,R1
   \   000001D2   0xB672             CPSID    I
   \   000001D4   0xF24A 0x6102      MOVW     R1,#+42498
   \   000001D8   0x.... 0x....      LDR.W    R2,??DataTable36_2  ;; 0x4005200c
   \   000001DC   0x8011             STRH     R1,[R2, #+0]
   \   000001DE   0xF24B 0x4180      MOVW     R1,#+46208
   \   000001E2   0x.... 0x....      LDR.W    R2,??DataTable36_2  ;; 0x4005200c
   \   000001E6   0x8011             STRH     R1,[R2, #+0]
   \   000001E8   0xF380 0x8810      MSR      PRIMASK,R0
   1286          
   1287                      //<=(R1, W0)
   1288                      for (counter = MICRO_RAM_END_ADDRESS; counter >= MICRO_RAM_START_ADDRESS; counter--)
   \   000001EC   0x.... 0x....      LDR.W    R1,??DataTable34_3
   \   000001F0   0x000F             MOVS     R7,R1
   \                     ??Micro__BootTest_19: (+1)
   \   000001F2   0x.... 0x....      LDR.W    R0,??DataTable34_2
   \   000001F6   0x4287             CMP      R7,R0
   \   000001F8   0xD308             BCC.N    ??Micro__BootTest_20
   1289                      {
   1290                          if (*((uint8 *)counter) != 0xFF)
   \   000001FA   0x7838             LDRB     R0,[R7, #+0]
   \   000001FC   0x28FF             CMP      R0,#+255
   \   000001FE   0xD001             BEQ.N    ??Micro__BootTest_21
   1291                          {
   1292                              result = FALSE;
   \   00000200   0x2000             MOVS     R0,#+0
   \   00000202   0x0004             MOVS     R4,R0
   1293                          }
   1294                          *((uint8 *)counter) = 0x0;
   \                     ??Micro__BootTest_21: (+1)
   \   00000204   0x2000             MOVS     R0,#+0
   \   00000206   0x7038             STRB     R0,[R7, #+0]
   1295                      }
   \   00000208   0x1E7F             SUBS     R7,R7,#+1
   \   0000020A   0xE7F2             B.N      ??Micro__BootTest_19
   1296                          sr_boot_test_counter++;
   \                     ??Micro__BootTest_20: (+1)
   \   0000020C   0xF118 0x0801      ADDS     R8,R8,#+1
   1297          
   1298                      //=>R0
   1299                      for (counter = MICRO_RAM_START_ADDRESS; counter <= MICRO_RAM_END_ADDRESS; counter++)
   \   00000210   0x.... 0x....      LDR.W    R0,??DataTable34_2
   \   00000214   0x0007             MOVS     R7,R0
   \                     ??Micro__BootTest_22: (+1)
   \   00000216   0x.... 0x....      LDR.W    R0,??DataTable34_3
   \   0000021A   0x42B8             CMP      R0,R7
   \   0000021C   0xD306             BCC.N    ??Micro__BootTest_23
   1300                      {
   1301                          if (*((uint8 *)counter) != 0)
   \   0000021E   0x7838             LDRB     R0,[R7, #+0]
   \   00000220   0x2800             CMP      R0,#+0
   \   00000222   0xD001             BEQ.N    ??Micro__BootTest_24
   1302                          {
   1303                              result = FALSE;
   \   00000224   0x2000             MOVS     R0,#+0
   \   00000226   0x0004             MOVS     R4,R0
   1304                          }
   1305                      }
   \                     ??Micro__BootTest_24: (+1)
   \   00000228   0x1C7F             ADDS     R7,R7,#+1
   \   0000022A   0xE7F4             B.N      ??Micro__BootTest_22
   1306                          sr_boot_test_counter++;
   \                     ??Micro__BootTest_23: (+1)
   \   0000022C   0xF118 0x0801      ADDS     R8,R8,#+1
   1307                      if (result == FALSE)
   \   00000230   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000232   0x2C00             CMP      R4,#+0
   \   00000234   0xD101             BNE.N    ??Micro__BootTest_25
   1308                      {
   1309                          //If the test fails
   1310                          MicroFailSafe();
   \   00000236   0x.... 0x....      BL       MicroFailSafe
   1311                      }
   1312          
   1313                      SERVICE_WATCHDOG();
   \                     ??Micro__BootTest_25: (+1)
   \   0000023A   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   0000023E   0x0008             MOVS     R0,R1
   \   00000240   0xB672             CPSID    I
   \   00000242   0xF24A 0x6102      MOVW     R1,#+42498
   \   00000246   0x.... 0x....      LDR.W    R2,??DataTable36_2  ;; 0x4005200c
   \   0000024A   0x8011             STRH     R1,[R2, #+0]
   \   0000024C   0xF24B 0x4180      MOVW     R1,#+46208
   \   00000250   0x.... 0x....      LDR.W    R2,??DataTable36_2  ;; 0x4005200c
   \   00000254   0x8011             STRH     R1,[R2, #+0]
   \   00000256   0xF380 0x8810      MSR      PRIMASK,R0
   1314          
   1315                      for (counter = MICRO_RAM_START_ADDRESS; counter <= MICRO_RAM_END_ADDRESS; counter += 4)
   \   0000025A   0x.... 0x....      LDR.W    R1,??DataTable34_2
   \   0000025E   0x000F             MOVS     R7,R1
   \                     ??Micro__BootTest_26: (+1)
   \   00000260   0x.... 0x....      LDR.W    R0,??DataTable34_3
   \   00000264   0x42B8             CMP      R0,R7
   \   00000266   0xD321             BCC.N    ??Micro__BootTest_27
   1316                      {
   1317                          SERVICE_WATCHDOG();
   \   00000268   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   0000026C   0x0008             MOVS     R0,R1
   \   0000026E   0xB672             CPSID    I
   \   00000270   0xF24A 0x6102      MOVW     R1,#+42498
   \   00000274   0x.... 0x....      LDR.W    R2,??DataTable36_2  ;; 0x4005200c
   \   00000278   0x8011             STRH     R1,[R2, #+0]
   \   0000027A   0xF24B 0x4180      MOVW     R1,#+46208
   \   0000027E   0x.... 0x....      LDR.W    R2,??DataTable36_2  ;; 0x4005200c
   \   00000282   0x8011             STRH     R1,[R2, #+0]
   \   00000284   0xF380 0x8810      MSR      PRIMASK,R0
   1318          
   1319                          result = *((uint32 *) counter);
   \   00000288   0x6839             LDR      R1,[R7, #+0]
   \   0000028A   0x000C             MOVS     R4,R1
   1320          
   1321                          for (mask = 1; mask > 0; mask = (mask << 1))
   \   0000028C   0x2101             MOVS     R1,#+1
   \   0000028E   0x000D             MOVS     R5,R1
   \                     ??Micro__BootTest_28: (+1)
   \   00000290   0x2D00             CMP      R5,#+0
   \   00000292   0xD007             BEQ.N    ??Micro__BootTest_29
   1322                          {
   1323                              *((uint32 *) counter) = mask;
   \   00000294   0x603D             STR      R5,[R7, #+0]
   1324                              if (*((uint32 *) counter) != mask)
   \   00000296   0x6838             LDR      R0,[R7, #+0]
   \   00000298   0x42A8             CMP      R0,R5
   \   0000029A   0xD001             BEQ.N    ??Micro__BootTest_30
   1325                              {
   1326                                  MicroFailSafe();
   \   0000029C   0x.... 0x....      BL       MicroFailSafe
   1327          
   1328                              }
   1329                          }
   \                     ??Micro__BootTest_30: (+1)
   \   000002A0   0x006D             LSLS     R5,R5,#+1
   \   000002A2   0xE7F5             B.N      ??Micro__BootTest_28
   1330                          *((uint32 *) counter) = result;
   \                     ??Micro__BootTest_29: (+1)
   \   000002A4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002A6   0x603C             STR      R4,[R7, #+0]
   1331                      }
   \   000002A8   0x1D3F             ADDS     R7,R7,#+4
   \   000002AA   0xE7D9             B.N      ??Micro__BootTest_26
   1332          
   1333                      //refresh the watch dog
   1334                      SERVICE_WATCHDOG();
   \                     ??Micro__BootTest_27: (+1)
   \   000002AC   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   000002B0   0x0008             MOVS     R0,R1
   \   000002B2   0xB672             CPSID    I
   \   000002B4   0xF24A 0x6102      MOVW     R1,#+42498
   \   000002B8   0x.... 0x....      LDR.W    R2,??DataTable36_2  ;; 0x4005200c
   \   000002BC   0x8011             STRH     R1,[R2, #+0]
   \   000002BE   0xF24B 0x4180      MOVW     R1,#+46208
   \   000002C2   0x.... 0x....      LDR.W    R2,??DataTable36_2  ;; 0x4005200c
   \   000002C6   0x8011             STRH     R1,[R2, #+0]
   \   000002C8   0xF380 0x8810      MSR      PRIMASK,R0
   1335          
   1336                  if (sr_boot_test_counter != MICRO_BOOT_SEQUENCE_3)
   \   000002CC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000002D0   0xF1B8 0x0F0B      CMP      R8,#+11
   \   000002D4   0xD001             BEQ.N    ??Micro__BootTest_31
   1337                  {
   1338                      MicroFailSafe();
   \   000002D6   0x.... 0x....      BL       MicroFailSafe
   1339                  }
   1340          #endif
   1341          
   1342                  //restore the reset status
   1343                  MicroClearResetData();
   \                     ??Micro__BootTest_31: (+1)
   \   000002DA   0x.... 0x....      BL       MicroClearResetData
   1344                  (*(uint8 *)(&Micro_ResetInfo.Reset))        = (save_reset_value >> 8) & 0xFF;
   \   000002DE   0x0A30             LSRS     R0,R6,#+8
   \   000002E0   0x.... 0x....      LDR.W    R1,??DataTable36_1
   \   000002E4   0xF881 0x002C      STRB     R0,[R1, #+44]
   1345                  (*(uint8 *)(&Micro_ResetInfo.Actual_Reset)) = save_reset_value & 0xFF;
   \   000002E8   0x.... 0x....      LDR.W    R0,??DataTable36_1
   \   000002EC   0xF880 0x602D      STRB     R6,[R0, #+45]
   1346          
   1347                  MicroUpdateResetInfoDataCrc();
   \   000002F0   0x.... 0x....      BL       MicroUpdateResetInfoDataCrc
   1348          
   1349                  Micro__EnableWarmResetAction(MICRO_WARM_RESET_ACTION_SKIP_CLASSB_TEST);
   \   000002F4   0x2004             MOVS     R0,#+4
   \   000002F6   0x.... 0x....      BL       Micro__EnableWarmResetAction
   1350          
   1351                  // Go to compiler startup
   1352                  __iar_program_start();
   \   000002FA   0x.... 0x....      BL       __iar_program_start
   \   000002FE   0xE001             B.N      ??Micro__BootTest_32
   1353              }
   1354              else
   1355              {
   1356                  main();
   \                     ??Micro__BootTest_7: (+1)
   \   00000300   0x.... 0x....      BL       main
   1357              }
   1358          }
   \                     ??Micro__BootTest_32: (+1)
   \   00000304   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1359          
   1360          //---------------------------------------------------------------------------------------------------------------------
   1361          /**
   1362           *    @brief    This method performs volatile memory (CPU register, Stack) test periodically.
   1363           *    @details  This method is responsible for:
   1364           *              CPU Registers Test,
   1365           *              Stack memory complete test
   1366           *              Stack overflow and underflow test.
   1367           *
   1368           *              MICRO_NUM_BYTE_FOR_RAM_CONTINUOUS_TEST configuration macro defined in the SRMicro_prv.h file
   1369           *              Defines how many bytes will be processed during each interaction of the Continuous stack memory Test.
   1370           *
   1371           *
   1372           *              The time taken for complete stack memory test is calculated below-
   1373           *              FULL RAM TEST (in ms) = (Stack Size/ MICRO_NUM_BYTE_FOR_RAM_CONTINUOUS_TEST) *
   1374           *                                       Call rate(of Micro__RamTest())
   1375           *
   1376           *             For example-
   1377           *              Stack memory  size is 2048bytes,  number of bytes processed in each call are 4 and the call rate is 100ms then,
   1378           *              FULL  Stack memory(in ms) =  (2048/4)*100 ms
   1379           *                                        =  51200 ms
   1380           *
   1381           *              Along with this it provides the flow control log and exception control for each tests.
   1382           *
   1383           *              This API is been called from ApplienceMgr Thread at every 100ms
   1384           */
   1385          #pragma optimize=none

   \                                 In section .text, align 2, keep-with-next
   1386          void Micro__SRRamTest(void)
   1387          {
   \                     Micro__SRRamTest: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   1388              #if (MICRO_SR_FEATURE_TEST == ENABLED)
   1389                  //Maximum 4 variables can be assigned as register type. More than that could cause problem.
   1390                  //Used to point the Ram location and its adjacent location  on which DC coupling RAM test is performed
   1391          	   register uint8 *stack_test_ptr;
   1392          	   register uint8 *stack_next_location_ptr;
   1393          	   register uint8 *stack_previous_location_ptr;
   1394          
   1395                  //Used to hold the data of a RAM memory location on which the RAM test is conducted
   1396                  //Byte3 - ram_next_location_data
   1397                  //Byte2 - ram_current_location_data
   1398                  //Byte1 - ram_previous_location_data
   1399                  //Byte 0 - BIT7      - result - test result
   1400                  //       - BIT6-BIT0 - counter, number of bytes processed
   1401          	    register uint32 stack_test_data;
   1402          
   1403                   register uint32 * pt_stack_test;
   1404          
   1405                  MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
   1406          
   1407                  //-----------------------------------------------------------------------------------------------------------------
   1408                  // CLASSB Test : CPU run time Test
   1409                  //
   1410                  //Tests the R0-R7 registers
   1411                  //If any error is found an exception will be thrown.
   1412                  //-----------------------------------------------------------------------------------------------------------------
   1413                  MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   00000004   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000008   0x4681             MOV      R9,R0
   \   0000000A   0xB672             CPSID    I
   1414          
   1415                  if (FALSE == MICRO_RUNTIME_REGISTER_TEST())
   \   0000000C   0x.... 0x....      BL       __RunRegisterTest
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD104             BNE.N    ??Micro__SRRamTest_0
   1416                  {
   1417                      //If the test fails throw test fail exception
   1418                      MICRO_SR_EXCEPTION_RUNTIME_CPU_REGISTER();
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0x.... 0x....      BL       SRException__Queue
   1419                  }
   1420          
   1421                  //Restore Interrupts
   1422                  MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \                     ??Micro__SRRamTest_0: (+1)
   \   0000001E   0xF389 0x8810      MSR      PRIMASK,R9
   1423          
   1424                  //-----------------------------------------------------------------------------------------------------------------
   1425                  // CLASSB Test : RAM periodic Test
   1426                  //
   1427                  // This test is used to validate the volatile memory
   1428                  //-----------------------------------------------------------------------------------------------------------------
   1429          
   1430                  SR_RAMTEST_FLOW_BEGIN()
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0x.... 0x....      BL       SRFlow__MainLogEvent
   1431          
   1432                  //Refresh the watchdog
   1433                  Micro__ServiceWatchdog();
   \   00000028   0x.... 0x....      BL       Micro__ServiceWatchdog
   1434          
   1435                  // Check if ram pointer is not corrupted
   1436                  if(SRData__CheckLong((uint32 PACKED *)&Run_Time_Stack_Pointer,(uint32 PACKED *)&Run_Time_Stack_Pointer_Inv)== SRDATA_OK)
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable36_3
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable36_4
   \   00000034   0x.... 0x....      BL       SRData__CheckLong
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD176             BNE.N    ??Micro__SRRamTest_1
   1437                  {
   1438                      //Disable the interrupt during test
   1439                      MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   0000003C   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000040   0x4681             MOV      R9,R0
   \   00000042   0xB672             CPSID    I
   1440          
   1441                      stack_test_data       = RUN_TIME_STACK_TEST_TRUE;
   \   00000044   0x2080             MOVS     R0,#+128
   \   00000046   0x0007             MOVS     R7,R0
   1442          
   1443                      //assign the ram location to be tested to the register variable
   1444                      stack_test_ptr = (uint8 *)Run_Time_Stack_Pointer;
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable36_4
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x0004             MOVS     R4,R0
   1445                      stack_next_location_ptr = (uint8 *)stack_test_ptr+1;
   \   00000050   0x1C60             ADDS     R0,R4,#+1
   \   00000052   0x0005             MOVS     R5,R0
   1446                      stack_previous_location_ptr = (uint8 *)(stack_test_ptr - 1);
   \   00000054   0x1E60             SUBS     R0,R4,#+1
   \   00000056   0x0006             MOVS     R6,R0
   1447          
   1448                      for(stack_test_data &= ~RUN_TIME_STACK_TEST_COUNT_MASK; (stack_test_data & RUN_TIME_STACK_TEST_COUNT_MASK) < MICRO_NUM_BYTE_FOR_RAM_CONTINUOUS_TEST; stack_test_data++)
                                                    ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \   00000058   0x09FF             LSRS     R7,R7,#+7
   \   0000005A   0x01FF             LSLS     R7,R7,#+7
   \                     ??Micro__SRRamTest_2: (+1)
   \   0000005C   0xF017 0x0F7F      TST      R7,#0x7F
   \   00000060   0xD157             BNE.N    ??Micro__SRRamTest_3
   1449                      {
   1450                          //Check for the RAM boundaries
   1451                          if ( stack_test_ptr == (uint8 *)MICRO_STACK_TEST_START_ADDRESS)
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \   00000066   0x4284             CMP      R4,R0
   \   00000068   0xD103             BNE.N    ??Micro__SRRamTest_4
   1452                          {
   1453                              stack_next_location_ptr = (uint8 *)(stack_test_ptr + 1);
   \   0000006A   0x1C60             ADDS     R0,R4,#+1
   \   0000006C   0x0005             MOVS     R5,R0
   1454                              stack_previous_location_ptr = (uint8 *)(stack_test_ptr + 2);
   \   0000006E   0x1CA0             ADDS     R0,R4,#+2
   \   00000070   0x0006             MOVS     R6,R0
   1455                          }
   1456          
   1457                          if ( stack_test_ptr == (uint8 *)MICRO_STACK_TEST_END_ADDRESS)
   \                     ??Micro__SRRamTest_4: (+1)
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \   00000076   0x4284             CMP      R4,R0
   \   00000078   0xD103             BNE.N    ??Micro__SRRamTest_5
   1458                          {
   1459                              stack_next_location_ptr = (uint8 *)(stack_test_ptr - 2);
   \   0000007A   0x1EA0             SUBS     R0,R4,#+2
   \   0000007C   0x0005             MOVS     R5,R0
   1460                              stack_previous_location_ptr = (uint8 *)(stack_test_ptr - 1);
   \   0000007E   0x1E60             SUBS     R0,R4,#+1
   \   00000080   0x0006             MOVS     R6,R0
   1461                          }
   1462          
   1463                          //store the data value into registers on which RAM test is done
   1464                          stack_test_data = ((*stack_test_ptr) << 16)  | (((*stack_next_location_ptr) << 24)) | ((*stack_previous_location_ptr) << 8) | (stack_test_data & RUN_TIME_STACK_TEST_PROP_MASK);
   \                     ??Micro__SRRamTest_5: (+1)
   \   00000082   0x7820             LDRB     R0,[R4, #+0]
   \   00000084   0x7829             LDRB     R1,[R5, #+0]
   \   00000086   0x0609             LSLS     R1,R1,#+24
   \   00000088   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   0000008C   0x7831             LDRB     R1,[R6, #+0]
   \   0000008E   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000092   0xB2F9             UXTB     R1,R7            ;; ZeroExt  R1,R7,#+24,#+24
   \   00000094   0xEA51 0x0700      ORRS     R7,R1,R0
   1465          
   1466                          //========================================================================
   1467                          // Actual engine of calculation
   1468          
   1469                          //Write the test location with 0x55 value and the neighbors by 0
   1470                          *(stack_test_ptr) = STACK_TEST_PATTERN;
   \   00000098   0x2055             MOVS     R0,#+85
   \   0000009A   0x7020             STRB     R0,[R4, #+0]
   1471                          *(stack_next_location_ptr) = STACK_TEST_BKD;
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x7028             STRB     R0,[R5, #+0]
   1472                          *(stack_previous_location_ptr) = STACK_TEST_BKD;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x7030             STRB     R0,[R6, #+0]
   1473          
   1474                          //Check if the Ram test location is changed because of the neighborhood pattern
   1475                          if (*(stack_test_ptr) != STACK_TEST_PATTERN)
   \   000000A4   0x7820             LDRB     R0,[R4, #+0]
   \   000000A6   0x2855             CMP      R0,#+85
   \   000000A8   0xD001             BEQ.N    ??Micro__SRRamTest_6
   1476                          {
   1477                              stack_test_data  &= ~RUN_TIME_STACK_TEST_TRUE;
                                                         ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \   000000AA   0xF037 0x0780      BICS     R7,R7,#0x80
   1478                          }
   1479          
   1480                          //change the neighborhood location value to 0xff and do not change the Ram test value
   1481                          *(stack_next_location_ptr) = STACK_TEST_BKD_INV;
   \                     ??Micro__SRRamTest_6: (+1)
   \   000000AE   0x20FF             MOVS     R0,#+255
   \   000000B0   0x7028             STRB     R0,[R5, #+0]
   1482                          *(stack_previous_location_ptr) = STACK_TEST_BKD_INV;
   \   000000B2   0x20FF             MOVS     R0,#+255
   \   000000B4   0x7030             STRB     R0,[R6, #+0]
   1483          
   1484                          //Check if the Ram test location is changed because of the neighborhood pattern
   1485                          if (*(stack_test_ptr) != STACK_TEST_PATTERN)
   \   000000B6   0x7820             LDRB     R0,[R4, #+0]
   \   000000B8   0x2855             CMP      R0,#+85
   \   000000BA   0xD001             BEQ.N    ??Micro__SRRamTest_7
   1486                          {
   1487                              stack_test_data  &= ~RUN_TIME_STACK_TEST_TRUE;
                                                         ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \   000000BC   0xF037 0x0780      BICS     R7,R7,#0x80
   1488                          }
   1489          
   1490                          //Write the test location with 0xAA value and the neighbors by 0
   1491                          *(stack_test_ptr) = STACK_TEST_PATTERN_INV;
   \                     ??Micro__SRRamTest_7: (+1)
   \   000000C0   0x20AA             MOVS     R0,#+170
   \   000000C2   0x7020             STRB     R0,[R4, #+0]
   1492                          *(stack_next_location_ptr) = STACK_TEST_BKD;
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x7028             STRB     R0,[R5, #+0]
   1493                          *(stack_previous_location_ptr) = STACK_TEST_BKD;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x7030             STRB     R0,[R6, #+0]
   1494          
   1495                          //Check if the Ram test location is changed because of the neighborhood pattern
   1496                          if (*(stack_test_ptr) != STACK_TEST_PATTERN_INV)
   \   000000CC   0x7820             LDRB     R0,[R4, #+0]
   \   000000CE   0x28AA             CMP      R0,#+170
   \   000000D0   0xD001             BEQ.N    ??Micro__SRRamTest_8
   1497                          {
   1498                              stack_test_data  &= ~RUN_TIME_STACK_TEST_TRUE;
                                                         ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \   000000D2   0xF037 0x0780      BICS     R7,R7,#0x80
   1499                          }
   1500          
   1501                          //change the neighborhood location value to 0xff and do not change the Ram test value
   1502                          *(stack_next_location_ptr) = STACK_TEST_BKD_INV;
   \                     ??Micro__SRRamTest_8: (+1)
   \   000000D6   0x20FF             MOVS     R0,#+255
   \   000000D8   0x7028             STRB     R0,[R5, #+0]
   1503                          *(stack_previous_location_ptr) = STACK_TEST_BKD_INV;
   \   000000DA   0x20FF             MOVS     R0,#+255
   \   000000DC   0x7030             STRB     R0,[R6, #+0]
   1504          
   1505                          //Check if the Ram test location is changed because of the neighborhood pattern
   1506                          if (*(stack_test_ptr) != STACK_TEST_PATTERN_INV)
   \   000000DE   0x7820             LDRB     R0,[R4, #+0]
   \   000000E0   0x28AA             CMP      R0,#+170
   \   000000E2   0xD001             BEQ.N    ??Micro__SRRamTest_9
   1507                          {
   1508                              stack_test_data  &= ~RUN_TIME_STACK_TEST_TRUE;
                                                         ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \   000000E4   0xF037 0x0780      BICS     R7,R7,#0x80
   1509                          }
   1510          
   1511                          //Restore the value
   1512                          *stack_next_location_ptr = (stack_test_data >> 24) & 0xFF;
   \                     ??Micro__SRRamTest_9: (+1)
   \   000000E8   0x0E38             LSRS     R0,R7,#+24
   \   000000EA   0x7028             STRB     R0,[R5, #+0]
   1513                          *stack_previous_location_ptr = (stack_test_data >> 8) & 0xFF;
   \   000000EC   0x0A38             LSRS     R0,R7,#+8
   \   000000EE   0x7030             STRB     R0,[R6, #+0]
   1514                          *stack_test_ptr = (stack_test_data >> 16) & 0xFF;;
   \   000000F0   0x0C38             LSRS     R0,R7,#+16
   \   000000F2   0x7020             STRB     R0,[R4, #+0]
   1515          
   1516                         //Is the RAM test reached the end of the RAM memory
   1517                          if ( stack_test_ptr == (uint8 *)MICRO_STACK_TEST_END_ADDRESS)
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \   000000F8   0x4284             CMP      R4,R0
   \   000000FA   0xD103             BNE.N    ??Micro__SRRamTest_10
   1518                          {
   1519                              stack_test_ptr = (uint8 *)MICRO_STACK_TEST_START_ADDRESS;
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \   00000100   0x0004             MOVS     R4,R0
   \   00000102   0xE004             B.N      ??Micro__SRRamTest_11
   1520                          }
   1521                          else
   1522                          {
   1523                              //or else go to the next memory location
   1524                              stack_test_ptr++;
   \                     ??Micro__SRRamTest_10: (+1)
   \   00000104   0x1C64             ADDS     R4,R4,#+1
   1525                              stack_next_location_ptr = (uint8 *)(stack_test_ptr + 1);
   \   00000106   0x1C60             ADDS     R0,R4,#+1
   \   00000108   0x0005             MOVS     R5,R0
   1526                              stack_previous_location_ptr = (uint8 *)(stack_test_ptr - 1);
   \   0000010A   0x1E60             SUBS     R0,R4,#+1
   \   0000010C   0x0006             MOVS     R6,R0
   1527                          }
   1528                      }//End of for loop for RAM_CONTINUOUS_TEST
   \                     ??Micro__SRRamTest_11: (+1)
   \   0000010E   0x1C7F             ADDS     R7,R7,#+1
   \   00000110   0xE7A4             B.N      ??Micro__SRRamTest_2
   1529          
   1530                      //Restore the RAM test pointer
   1531                      Run_Time_Stack_Pointer = (uint32 *)stack_test_ptr;
   \                     ??Micro__SRRamTest_3: (+1)
   \   00000112   0x.... 0x....      LDR.W    R0,??DataTable36_4
   \   00000116   0x6004             STR      R4,[R0, #+0]
   1532                      Run_Time_Stack_Pointer_Inv = ((uint32 *)~((uint32)Run_Time_Stack_Pointer));
   \   00000118   0x.... 0x....      LDR.W    R0,??DataTable36_4
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0x43C0             MVNS     R0,R0
   \   00000120   0x.... 0x....      LDR.W    R1,??DataTable36_3
   \   00000124   0x6008             STR      R0,[R1, #+0]
   1533          
   1534                      MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \   00000126   0xF389 0x8810      MSR      PRIMASK,R9
   1535                  }//End of if loop
   1536          
   1537                  if ((stack_test_data & RUN_TIME_STACK_TEST_TRUE) == 0)
   \                     ??Micro__SRRamTest_1: (+1)
   \   0000012A   0x0638             LSLS     R0,R7,#+24
   \   0000012C   0xD408             BMI.N    ??Micro__SRRamTest_12
   1538                    {
   1539                        //If the test fails throw test fail exception
   1540                      MICRO_SR_EXCEPTION_CONTINUOUS_RAM(Run_Time_Stack_Pointer);
                             ^
Warning[Pe767]: conversion from pointer to smaller integer
   \   0000012E   0x2200             MOVS     R2,#+0
   \   00000130   0x.... 0x....      LDR.W    R0,??DataTable36_4
   \   00000134   0x6801             LDR      R1,[R0, #+0]
   \   00000136   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000138   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000013A   0x2020             MOVS     R0,#+32
   \   0000013C   0x.... 0x....      BL       SRException__Queue
   1541                    }
   1542          
   1543                  //-----------------------------------------------------------------------------------------------------------------
   1544                  // CLASSB Test : Stack Underflow and overflow test
   1545                  //
   1546                  //This is used to validate the Stack operation
   1547                  //-----------------------------------------------------------------------------------------------------------------
   1548                  //check Stack underflow pattern
   1549          
   1550                  #define SREXCEPTION_DATA1               ((uint32)1)     //1 represents that the exception is from Micro module
   1551                  #define SREXCEPTION_DATA0_OVERFLOW      ((uint32)0)     //0 represents that the exception is because of the stack overflow
   1552                  #define SREXCEPTION_DATA0_UNDERFLOW     ((uint32)1)     //1 represents that the exception is because of the stack underflow
   1553          
   1554                  pt_stack_test = (uint32*)MICRO_STACK_TEST_END_ADDRESS;
   \                     ??Micro__SRRamTest_12: (+1)
   \   00000140   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \   00000144   0x4680             MOV      R8,R0
   1555          
   1556                  if ((pt_stack_test[0] != STACK_TEST_PATTERN1) ||
   1557                      (pt_stack_test[1] != STACK_TEST_PATTERN2) ||
   1558                      (pt_stack_test[2] != STACK_TEST_PATTERN3) ||
   1559                      (pt_stack_test[3] != STACK_TEST_PATTERN4))
   \   00000146   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000014A   0x.... 0x....      LDR.W    R1,??DataTable29  ;; 0x72696857
   \   0000014E   0x4288             CMP      R0,R1
   \   00000150   0xD111             BNE.N    ??Micro__SRRamTest_13
   \   00000152   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000156   0x.... 0x....      LDR.W    R1,??DataTable28_6  ;; 0x6f6f706c
   \   0000015A   0x4288             CMP      R0,R1
   \   0000015C   0xD10B             BNE.N    ??Micro__SRRamTest_13
   \   0000015E   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   00000162   0x.... 0x....      LDR.W    R1,??DataTable28_5  ;; 0x3030316c
   \   00000166   0x4288             CMP      R0,R1
   \   00000168   0xD105             BNE.N    ??Micro__SRRamTest_13
   \   0000016A   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \   0000016E   0x.... 0x....      LDR.W    R1,??DataTable28_4  ;; 0x72616559
   \   00000172   0x4288             CMP      R0,R1
   \   00000174   0xD004             BEQ.N    ??Micro__SRRamTest_14
   1560                  {
   1561                      //If the test fails throw test fail exception
   1562                      MICRO_SR_EXCEPTION_STACK_UNDERFLOW();
   \                     ??Micro__SRRamTest_13: (+1)
   \   00000176   0x2200             MOVS     R2,#+0
   \   00000178   0x2100             MOVS     R1,#+0
   \   0000017A   0x201D             MOVS     R0,#+29
   \   0000017C   0x.... 0x....      BL       SRException__Queue
   1563                  }
   1564          
   1565                  //check Stack overflow pattern
   1566                  pt_stack_test = (uint32*)MICRO_STACK_TEST_START_ADDRESS;
   \                     ??Micro__SRRamTest_14: (+1)
   \   00000180   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \   00000184   0x4680             MOV      R8,R0
   1567          
   1568                  if ((pt_stack_test[0] != STACK_TEST_PATTERN5) ||
   1569                      (pt_stack_test[1] != STACK_TEST_PATTERN6) ||
   1570                      (pt_stack_test[2] != STACK_TEST_PATTERN7) ||
   1571                      (pt_stack_test[3] != STACK_TEST_PATTERN8))
   \   00000186   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000018A   0x.... 0x....      LDR.W    R1,??DataTable29_1  ;; 0x20534545
   \   0000018E   0x4288             CMP      R0,R1
   \   00000190   0xD111             BNE.N    ??Micro__SRRamTest_15
   \   00000192   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000196   0x.... 0x....      LDR.W    R1,??DataTable29_2  ;; 0x6167724f
   \   0000019A   0x4288             CMP      R0,R1
   \   0000019C   0xD10B             BNE.N    ??Micro__SRRamTest_15
   \   0000019E   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   000001A2   0x.... 0x....      LDR.W    R1,??DataTable29_3  ;; 0x617a696e
   \   000001A6   0x4288             CMP      R0,R1
   \   000001A8   0xD105             BNE.N    ??Micro__SRRamTest_15
   \   000001AA   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \   000001AE   0x.... 0x....      LDR.W    R1,??DataTable29_4  ;; 0x6e6f6974
   \   000001B2   0x4288             CMP      R0,R1
   \   000001B4   0xD004             BEQ.N    ??Micro__SRRamTest_16
   1572                  {
   1573                      //If the test fails throw test fail exception
   1574                      MICRO_SR_EXCEPTION_STACK_OVERFLOW();
   \                     ??Micro__SRRamTest_15: (+1)
   \   000001B6   0x2200             MOVS     R2,#+0
   \   000001B8   0x2100             MOVS     R1,#+0
   \   000001BA   0x201C             MOVS     R0,#+28
   \   000001BC   0x.... 0x....      BL       SRException__Queue
   1575                  }
   1576                  SR_RAMTEST_FLOW_END()
   \                     ??Micro__SRRamTest_16: (+1)
   \   000001C0   0x2003             MOVS     R0,#+3
   \   000001C2   0x.... 0x....      BL       SRFlow__MainLogEvent
   1577               #endif
   1578          }
   \   000001C6   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   1579          
   1580          
   1581          //---------------------------------------------------------------------------------------------------------------------
   1582          /**
   1583           *    @brief    This method makes the controller to work at Normal speed or resumes the controller from Low Speed mode
   1584           *    @details  This method provides a way to switch from slow to normal mode of operation
   1585           */

   \                                 In section .text, align 2, keep-with-next
   1586          void Micro__SetNormalSpeedMode(void)
   1587          {
   \                     Micro__SetNormalSpeedMode: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1588              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
   1589              uint32 i;
   1590          
   1591              //Save and Disable the Interrupts
   1592              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   00000002   0xF3EF 0x8410      MRS      R4,PRIMASK
   \   00000006   0xB672             CPSID    I
   1593          
   1594              MicroInitClk();
   \   00000008   0x.... 0x....      BL       MicroInitClk
   1595              MicroGetClocksStatus();
   \   0000000C   0x.... 0x....      BL       MicroGetClocksStatus
   1596          
   1597              #if(MICRO_HIGHSPEEDRUN_MODE == ENABLED)
   1598              {
   1599          
   1600                  /* The PMPROT register may have already been written by init code
   1601                   If so then this next write is not done.
   1602                   PMPROT is write once after RESET
   1603                   this write-once bit allows the MCU to enter High Speed Run Mode (HSRUN)*/
   1604                  SMC.PMPROT.BIT.AHSRUN = 1;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable36_5  ;; 0x4007e000
   \   00000014   0x7801             LDRB     R1,[R0, #+0]
   \   00000016   0xF041 0x0180      ORR      R1,R1,#0x80
   \   0000001A   0x7001             STRB     R1,[R0, #+0]
   1605          
   1606                  /* Set the RUNM bits to 0b011 for HSRUN mode */
   1607                  SMC.PMCTRL = SMC_PMCTRL_RUNM(3);
   \   0000001C   0x2160             MOVS     R1,#+96
   \   0000001E   0x7041             STRB     R1,[R0, #+1]
   1608          
   1609                  /* Wait for HSRUN regulator mode to be confirmed */
   1610                  for (i = 0; i < 10000; i++)
   \   00000020   0xF242 0x7110      MOVW     R1,#+10000
   1611                  { /* check that the value of SMC_PMSTAT is not 0x80 once it is 0x80, we can stop checking */
   1612                      if (SMC.PMSTAT != 0x80)
   \                     ??Micro__SetNormalSpeedMode_0: (+1)
   \   00000024   0x78C2             LDRB     R2,[R0, #+3]
   \   00000026   0x2A80             CMP      R2,#+128
   \   00000028   0xD001             BEQ.N    ??Micro__SetNormalSpeedMode_1
   1613                      {
   1614                          // 0x01 Current mode is normal run
   1615                          // 0x80 Current mode is high speed run
   1616                      }
   1617                      else
   1618                          break;
   1619                  }
   \   0000002A   0x1E49             SUBS     R1,R1,#+1
   \   0000002C   0xD1FA             BNE.N    ??Micro__SetNormalSpeedMode_0
   1620              }
   1621              #endif
   1622          
   1623              //Restore Interrupts
   1624              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \                     ??Micro__SetNormalSpeedMode_1: (+1)
   \   0000002E   0xF384 0x8810      MSR      PRIMASK,R4
   1625          }
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
   1626          
   1627          //---------------------------------------------------------------------------------------------------------------------
   1628          /**
   1629           *    @brief    This method puts the micro in WAIT mode
   1630           *    @details  The CPU clock is stopped, reducing the power consumption of the microcontroller.
   1631           *              When an internal or external interrupt request occurs,
   1632           *              the CPU wakes-up from Wait mode and resumes processing
   1633           */

   \                                 In section .text, align 4, keep-with-next
   1634          void Micro__GoSleep(void)
   1635          {
   \                     Micro__GoSleep: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1636              Micro__EnableWarmResetAction(MICRO_WARM_RESET_ACTION_ENTER_LOWPOWER);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable36_1
   \   00000006   0x.... 0x....      ADR.W    R1,MICRO_RESETINFO_HEADER
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable36_6
   \   0000000E   0x.... 0x....      ADR.W    R3,MICRO_RESETINFO_FOOTER
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xF05F 0x050B      MOVS.W   R5,#+11
   \                     ??Micro__GoSleep_0: (+1)
   \   00000018   0xF811 0x6B01      LDRB     R6,[R1], #+1
   \   0000001C   0xF800 0x6B01      STRB     R6,[R0], #+1
   \   00000020   0x1E6D             SUBS     R5,R5,#+1
   \   00000022   0xF813 0x6B01      LDRB     R6,[R3], #+1
   \   00000026   0xF802 0x6B01      STRB     R6,[R2], #+1
   \   0000002A   0xF811 0x6B01      LDRB     R6,[R1], #+1
   \   0000002E   0xF800 0x6B01      STRB     R6,[R0], #+1
   \   00000032   0xF813 0x6B01      LDRB     R6,[R3], #+1
   \   00000036   0xF802 0x6B01      STRB     R6,[R2], #+1
   \   0000003A   0xF811 0x6B01      LDRB     R6,[R1], #+1
   \   0000003E   0xF800 0x6B01      STRB     R6,[R0], #+1
   \   00000042   0xF813 0x6B01      LDRB     R6,[R3], #+1
   \   00000046   0xF802 0x6B01      STRB     R6,[R2], #+1
   \   0000004A   0xF811 0x6B01      LDRB     R6,[R1], #+1
   \   0000004E   0xF800 0x6B01      STRB     R6,[R0], #+1
   \   00000052   0xF813 0x6B01      LDRB     R6,[R3], #+1
   \   00000056   0xF802 0x6B01      STRB     R6,[R2], #+1
   \   0000005A   0xD1DD             BNE.N    ??Micro__GoSleep_0
   \   0000005C   0x2206             MOVS     R2,#+6
   \   0000005E   0xF104 0x012C      ADD      R1,R4,#+44
   \   00000062   0x20FF             MOVS     R0,#+255
   \   00000064   0x.... 0x....      BL       Crc8
   \   00000068   0xF894 0x1032      LDRB     R1,[R4, #+50]
   \   0000006C   0x4281             CMP      R1,R0
   \   0000006E   0xD004             BEQ.N    ??Micro__GoSleep_1
   \   00000070   0x22FF             MOVS     R2,#+255
   \   00000072   0x21FF             MOVS     R1,#+255
   \   00000074   0x2027             MOVS     R0,#+39
   \   00000076   0x.... 0x....      BL       SRException__Queue
   \                     ??Micro__GoSleep_1: (+1)
   \   0000007A   0xF894 0x002F      LDRB     R0,[R4, #+47]
   \   0000007E   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000082   0xF884 0x002F      STRB     R0,[R4, #+47]
   \   00000086   0x2206             MOVS     R2,#+6
   \   00000088   0xF104 0x012C      ADD      R1,R4,#+44
   \   0000008C   0x20FF             MOVS     R0,#+255
   \   0000008E   0x.... 0x....      BL       Crc8
   \   00000092   0xF884 0x0032      STRB     R0,[R4, #+50]
   1637              Micro__ForceReset(MICRO_RESET_MODE_WARM);
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable32_5  ;; 0xe000ed0c
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable36  ;; 0x5fa0004
   \   0000009E   0x6008             STR      R0,[R1, #+0]
   1638          }
   \   000000A0   0xBD70             POP      {R4-R6,PC}       ;; return
   1639          
   1640          //---------------------------------------------------------------------------------------------------------------------
   1641          /**
   1642           * @brief   This method refreshes the watchdog
   1643           * @details This method should be called periodically to refresh the WWDG (window watchdog)
   1644           *          and/or IWDG (Independent watchdog) depending on the configuration.
   1645           *
   1646           *          Can be used to resolve processor malfunctions due to hardware or software failures.
   1647           *          Watchdog should be refreshed at every 5ms
   1648           */

   \                                 In section .text, align 2, keep-with-next
   1649          void Micro__ServiceWatchdog(void)
   1650          {
   1651          	#if (MICRO_WATCHDOG_FEATURE == ENABLED)
   1652          		SERVICE_WATCHDOG();
   \                     Micro__ServiceWatchdog: (+1)
   \   00000000   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000004   0xB672             CPSID    I
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable36_2  ;; 0x4005200c
   \   0000000A   0xF24A 0x6202      MOVW     R2,#+42498
   \   0000000E   0x800A             STRH     R2,[R1, #+0]
   \   00000010   0xF24B 0x4280      MOVW     R2,#+46208
   \   00000014   0x800A             STRH     R2,[R1, #+0]
   \   00000016   0xF380 0x8810      MSR      PRIMASK,R0
   1653          	#endif
   1654          }
   \   0000001A   0x4770             BX       LR               ;; return
   1655          
   1656          //---------------------------------------------------------------------------------------------------------------------
   1657          /**
   1658           *    @brief    It reset the micro when a not handled interruption occurs
   1659           *    @details  This method is used to reset the micro when an interrupt appears which was not handled
   1660           */

   \                                 In section .text, align 2, keep-with-next
   1661          INTERRUPT_DIRECTIVE void Micro__Trap(void)
   1662          {
   1663              SYSTEM_RESET();
   \                     Micro__Trap: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable32_5  ;; 0xe000ed0c
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable36  ;; 0x5fa0004
   \   00000008   0x6008             STR      R0,[R1, #+0]
   1664          }
   \   0000000A   0x4770             BX       LR               ;; return
   1665          
   1666          //---------------------------------------------------------------------------------------------------------------------
   1667          /**
   1668           *    @brief    This method provides information about the clocks
   1669           *    @details  This method provides information about clocks such as
   1670           *              System clock frequency (SYSCLK_Frequency),
   1671           *              AHB Clock frequency (HCLK_Frequency),
   1672           *              APB1 Clock frequency( PCLK1_Frequency),
   1673           *              APB2 Clock frequency( PCLK2_Frequency),
   1674           *              And HSE(High speed External) initialization status.
   1675           *
   1676           *    @return   MICRO_CLOCK_DEF* : pointer to the clock registers structure
   1677           */

   \                                 In section .text, align 2, keep-with-next
   1678          MICRO_CLOCK_DEF * Micro__GetClock(void)
   1679          {
   1680              return (&Micro_ClocksStatus);
   \                     Micro__GetClock: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable36_7
   \   00000004   0x4770             BX       LR               ;; return
   1681          }
   1682          
   1683          //---------------------------------------------------------------------------------------------------------------------
   1684          /**
   1685           *    @brief    This method adds the delay to the execution
   1686           *    @details  Adds the delay by executing the NOP(No Operation)
   1687           *    @param    delay : Defines the number times the NOP opcode is executed
   1688           */

   \                                 In section .text, align 4, keep-with-next
   1689          void Micro__DelayNumNops(uint16 delay)
   1690          {
   1691              uint16 count;
   1692          
   1693              for(count =0; count < delay; count++)
   \                     Micro__DelayNumNops: (+1)
   \   00000000   0xB168             CBZ.N    R0,??Micro__DelayNumNops_0
   \   00000002   0xF010 0x0103      ANDS     R1,R0,#0x3
   \   00000006   0xD002             BEQ.N    ??Micro__DelayNumNops_1
   1694              {
   1695                  NOP();
   \                     ??Micro__DelayNumNops_2: (+1)
   \   00000008   0xBF00             nop 
   \   0000000A   0x1E49             SUBS     R1,R1,#+1
   \   0000000C   0xD1FC             BNE.N    ??Micro__DelayNumNops_2
   \                     ??Micro__DelayNumNops_1: (+1)
   \   0000000E   0x0880             LSRS     R0,R0,#+2
   \   00000010   0xD005             BEQ.N    ??Micro__DelayNumNops_0
   \                     ??Micro__DelayNumNops_3: (+1)
   \   00000012   0xBF00             nop 
   \   00000014   0xBF00             nop 
   \   00000016   0xBF00             nop 
   \   00000018   0xBF00             nop 
   1696              }
   \   0000001A   0x1E40             SUBS     R0,R0,#+1
   \   0000001C   0xD1F9             BNE.N    ??Micro__DelayNumNops_3
   1697          }
   \                     ??Micro__DelayNumNops_0: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
   1698          
   1699          //---------------------------------------------------------------------------------------------------------------------
   1700          /**
   1701           *    @brief    This method provides a reason for last system reset.
   1702           *    @details  This method is used to provides information about the source from where reset to system occurs
   1703           *    @return   MICRO_LAST_RESET_TYPE* : pointer to system reset status register structure
   1704           *                                      Reset by Debugger,
   1705           *                                      Reset by Low Voltage Detector (LVD),
   1706           *                                      Reset by Clock failure,
   1707           *                                      Reset by EMC,
   1708           *                                      Reset by illegal opcode execution,
   1709           *                                      Reset by watchdog,
   1710           *                                      Reset by External,
   1711           *                                      And Power on reset.
   1712           */

   \                                 In section .text, align 2, keep-with-next
   1713          MICRO_LAST_RESET_TYPE * Micro__GetLastResetstatus(void)
   1714          {
   \                     Micro__GetLastResetstatus: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1715              MicroValidateResetInfoDataCrc();
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable36_1
   \   00000006   0x2206             MOVS     R2,#+6
   \   00000008   0xF104 0x012C      ADD      R1,R4,#+44
   \   0000000C   0x20FF             MOVS     R0,#+255
   \   0000000E   0x.... 0x....      BL       Crc8
   \   00000012   0xF894 0x1032      LDRB     R1,[R4, #+50]
   \   00000016   0x4281             CMP      R1,R0
   \   00000018   0xD004             BEQ.N    ??Micro__GetLastResetstatus_0
   \   0000001A   0x22FF             MOVS     R2,#+255
   \   0000001C   0x21FF             MOVS     R1,#+255
   \   0000001E   0x2027             MOVS     R0,#+39
   \   00000020   0x.... 0x....      BL       SRException__Queue
   1716              return (&(Micro_ResetInfo.Actual_Reset));
   \                     ??Micro__GetLastResetstatus_0: (+1)
   \   00000024   0xF104 0x002D      ADD      R0,R4,#+45
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
   1717          }
   1718          
   1719          //---------------------------------------------------------------------------------------------------------------------
   1720          /**
   1721           * @brief - This API assert the reset
   1722           *
   1723           * @param reset_mode
   1724           *
   1725           */

   \                                 In section .text, align 2, keep-with-next
   1726          void Micro__ForceReset(MICRO_RESET_MODE_TYPE reset_mode)
   1727          {
   1728              if (reset_mode == MICRO_RESET_MODE_WARM)
   \                     Micro__ForceReset: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable32_5  ;; 0xe000ed0c
   \   00000004   0x.... 0x....      LDR.W    R2,??DataTable34_1  ;; 0x5fa0004
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD006             BEQ.N    ??Micro__ForceReset_0
   1729              {
   1730                  //warm reset
   1731                  SYSTEM_RESET();
   1732              }
   1733              else
   1734              {
   1735                  //Cold reset
   1736                  //Corrupt the signature
   1737                  Micro_ResetInfo.Header[0] = 0;
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable36_1
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x7018             STRB     R0,[R3, #+0]
   1738                  Micro_ResetInfo_Footer[0] = 0;
   \   00000014   0x.... 0x....      LDR.W    R3,??DataTable36_6
   \   00000018   0x7018             STRB     R0,[R3, #+0]
   1739          
   1740                  SYSTEM_RESET();
   \                     ??Micro__ForceReset_0: (+1)
   \   0000001A   0x600A             STR      R2,[R1, #+0]
   1741              }
   1742          }
   \   0000001C   0x4770             BX       LR               ;; return
   1743          
   1744          //---------------------------------------------------------------------------------------------------------------------
   1745          /**
   1746           * @brief - This API reads the reset mode
   1747           * @return MICRO_RESET_MODE_TYPE:
   1748           *
   1749           */

   \                                 In section .text, align 2, keep-with-next
   1750          MICRO_RESET_MODE_TYPE Micro__GetResetMode(void)
   1751          {
   \                     Micro__GetResetMode: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1752              MicroValidateResetInfoDataCrc();
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable36_1
   \   00000006   0x2206             MOVS     R2,#+6
   \   00000008   0xF104 0x012C      ADD      R1,R4,#+44
   \   0000000C   0x20FF             MOVS     R0,#+255
   \   0000000E   0x.... 0x....      BL       Crc8
   \   00000012   0xF894 0x1032      LDRB     R1,[R4, #+50]
   \   00000016   0x4281             CMP      R1,R0
   \   00000018   0xD004             BEQ.N    ??Micro__GetResetMode_0
   \   0000001A   0x22FF             MOVS     R2,#+255
   \   0000001C   0x21FF             MOVS     R1,#+255
   \   0000001E   0x2027             MOVS     R0,#+39
   \   00000020   0x.... 0x....      BL       SRException__Queue
   1753              return(Micro_ResetInfo.Mode);
   \                     ??Micro__GetResetMode_0: (+1)
   \   00000024   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
   1754          }
   1755          
   1756          //---------------------------------------------------------------------------------------------------------------------
   1757          /**
   1758           * @brief - This API is used to Enable the warm reset action if the next reset is warn reset type
   1759           * @param warm_reset_action
   1760           */
   1761          #pragma inline=forced

   \                                 In section .text, align 4
   1762          void Micro__EnableWarmResetAction(MICRO_WARM_RESET_ACTION_TYPE warm_reset_action)
   1763          {
   \                     Micro__EnableWarmResetAction: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   1764              MicroSetRamSignature();
   \   00000004   0x4D23             LDR.N    R5,??Micro__EnableWarmResetAction_0
   \   00000006   0x4924             LDR.N    R1,??Micro__EnableWarmResetAction_0+0x4
   \   00000008   0x4A24             LDR.N    R2,??Micro__EnableWarmResetAction_0+0x8
   \   0000000A   0x4B25             LDR.N    R3,??Micro__EnableWarmResetAction_0+0xC
   \   0000000C   0xB081             SUB      SP,SP,#+4
   \   0000000E   0x4628             MOV      R0,R5
   \   00000010   0xF05F 0x060B      MOVS.W   R6,#+11
   \                     ??Micro__EnableWarmResetAction_1: (+1)
   \   00000014   0xF811 0x7B01      LDRB     R7,[R1], #+1
   \   00000018   0xF800 0x7B01      STRB     R7,[R0], #+1
   \   0000001C   0x1E76             SUBS     R6,R6,#+1
   \   0000001E   0xF813 0x7B01      LDRB     R7,[R3], #+1
   \   00000022   0xF802 0x7B01      STRB     R7,[R2], #+1
   \   00000026   0xF811 0x7B01      LDRB     R7,[R1], #+1
   \   0000002A   0xF800 0x7B01      STRB     R7,[R0], #+1
   \   0000002E   0xF813 0x7B01      LDRB     R7,[R3], #+1
   \   00000032   0xF802 0x7B01      STRB     R7,[R2], #+1
   \   00000036   0xF811 0x7B01      LDRB     R7,[R1], #+1
   \   0000003A   0xF800 0x7B01      STRB     R7,[R0], #+1
   \   0000003E   0xF813 0x7B01      LDRB     R7,[R3], #+1
   \   00000042   0xF802 0x7B01      STRB     R7,[R2], #+1
   \   00000046   0xF811 0x7B01      LDRB     R7,[R1], #+1
   \   0000004A   0xF800 0x7B01      STRB     R7,[R0], #+1
   \   0000004E   0xF813 0x7B01      LDRB     R7,[R3], #+1
   \   00000052   0xF802 0x7B01      STRB     R7,[R2], #+1
   \   00000056   0xD1DD             BNE.N    ??Micro__EnableWarmResetAction_1
   1765              MicroValidateResetInfoDataCrc();
   \   00000058   0x2206             MOVS     R2,#+6
   \   0000005A   0xF105 0x012C      ADD      R1,R5,#+44
   \   0000005E   0x20FF             MOVS     R0,#+255
   \   00000060   0x.... 0x....      BL       Crc8
   \   00000064   0xF895 0x1032      LDRB     R1,[R5, #+50]
   \   00000068   0x4281             CMP      R1,R0
   \   0000006A   0xD004             BEQ.N    ??Micro__EnableWarmResetAction_2
   \   0000006C   0x22FF             MOVS     R2,#+255
   \   0000006E   0x21FF             MOVS     R1,#+255
   \   00000070   0x2027             MOVS     R0,#+39
   \   00000072   0x.... 0x....      BL       SRException__Queue
   1766              Micro_ResetInfo.Warm_Reset_Actions |= warm_reset_action;
   \                     ??Micro__EnableWarmResetAction_2: (+1)
   \   00000076   0xF895 0x002F      LDRB     R0,[R5, #+47]
   \   0000007A   0x4320             ORRS     R0,R4,R0
   \   0000007C   0xF885 0x002F      STRB     R0,[R5, #+47]
   1767              MicroUpdateResetInfoDataCrc();
   \   00000080   0x2206             MOVS     R2,#+6
   \   00000082   0xF105 0x012C      ADD      R1,R5,#+44
   \   00000086   0x20FF             MOVS     R0,#+255
   \   00000088   0x.... 0x....      BL       Crc8
   \   0000008C   0xF885 0x0032      STRB     R0,[R5, #+50]
   1768          }
   \   00000090   0xB001             ADD      SP,SP,#+4
   \   00000092   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??Micro__EnableWarmResetAction_0:
   \   00000094   0x........         DC32     Micro_ResetInfo
   \   00000098   0x........         DC32     MICRO_RESETINFO_HEADER
   \   0000009C   0x........         DC32     Micro_ResetInfo_Footer
   \   000000A0   0x........         DC32     MICRO_RESETINFO_FOOTER
   1769          
   1770          //---------------------------------------------------------------------------------------------------------------------
   1771          /**
   1772           * @brief - This API is used to Disable the warm reset action if the next reset is warn reset type
   1773           * @param warm_reset_action
   1774           */
   1775          #pragma inline=forced
   1776          void Micro__DisableWarmResetAction(MICRO_WARM_RESET_ACTION_TYPE warm_reset_action)
   1777          {
   1778              MicroSetRamSignature();
   1779              MicroValidateResetInfoDataCrc();
   1780              Micro_ResetInfo.Warm_Reset_Actions &= ~warm_reset_action;
                                                           ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   1781              MicroUpdateResetInfoDataCrc();
   1782          }
   1783          
   1784          //---------------------------------------------------------------------------------------------------------------------
   1785          /**
   1786           * @brief - This API is used to read the warm reset actions set
   1787           * @return MICRO_WARM_RESET_ACTION_TYPE
   1788           */

   \                                 In section .text, align 4, keep-with-next
   1789          MICRO_WARM_RESET_ACTION_TYPE Micro__GetWarmResetAction(void)
   1790          {
   \                     Micro__GetWarmResetAction: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   1791              if (MicroIsResetSignatureValid() == TRUE)
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable36_1
   \   00000006   0x.... 0x....      ADR.W    R1,MICRO_RESETINFO_HEADER
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable36_6
   \   0000000E   0x.... 0x....      ADR.W    R3,MICRO_RESETINFO_FOOTER
   \   00000012   0xB081             SUB      SP,SP,#+4
   \   00000014   0x2500             MOVS     R5,#+0
   \   00000016   0x4620             MOV      R0,R4
   \                     ??Micro__GetWarmResetAction_0: (+1)
   \   00000018   0xF810 0x6B01      LDRB     R6,[R0], #+1
   \   0000001C   0xF811 0x7B01      LDRB     R7,[R1], #+1
   \   00000020   0x42BE             CMP      R6,R7
   \   00000022   0xBF02             ITTT     EQ 
   \   00000024   0xF812 0x6B01      LDRBEQ   R6,[R2], #+1
   \   00000028   0xF813 0x7B01      LDRBEQ   R7,[R3], #+1
   \   0000002C   0x42BE             CMPEQ    R6,R7
   \   0000002E   0xD140             BNE.N    ??Micro__GetWarmResetAction_1
   \   00000030   0xF810 0x6B01      LDRB     R6,[R0], #+1
   \   00000034   0xF811 0x7B01      LDRB     R7,[R1], #+1
   \   00000038   0x1C6D             ADDS     R5,R5,#+1
   \   0000003A   0xB2ED             UXTB     R5,R5
   \   0000003C   0x42BE             CMP      R6,R7
   \   0000003E   0xBF02             ITTT     EQ 
   \   00000040   0xF812 0x6B01      LDRBEQ   R6,[R2], #+1
   \   00000044   0xF813 0x7B01      LDRBEQ   R7,[R3], #+1
   \   00000048   0x42BE             CMPEQ    R6,R7
   \   0000004A   0xD132             BNE.N    ??Micro__GetWarmResetAction_1
   \   0000004C   0xF810 0x6B01      LDRB     R6,[R0], #+1
   \   00000050   0xF811 0x7B01      LDRB     R7,[R1], #+1
   \   00000054   0x1C6D             ADDS     R5,R5,#+1
   \   00000056   0xB2ED             UXTB     R5,R5
   \   00000058   0x42BE             CMP      R6,R7
   \   0000005A   0xBF02             ITTT     EQ 
   \   0000005C   0xF812 0x6B01      LDRBEQ   R6,[R2], #+1
   \   00000060   0xF813 0x7B01      LDRBEQ   R7,[R3], #+1
   \   00000064   0x42BE             CMPEQ    R6,R7
   \   00000066   0xD124             BNE.N    ??Micro__GetWarmResetAction_1
   \   00000068   0xF810 0x6B01      LDRB     R6,[R0], #+1
   \   0000006C   0xF811 0x7B01      LDRB     R7,[R1], #+1
   \   00000070   0x1C6D             ADDS     R5,R5,#+1
   \   00000072   0xB2ED             UXTB     R5,R5
   \   00000074   0x42BE             CMP      R6,R7
   \   00000076   0xBF02             ITTT     EQ 
   \   00000078   0xF812 0x6B01      LDRBEQ   R6,[R2], #+1
   \   0000007C   0xF813 0x7B01      LDRBEQ   R7,[R3], #+1
   \   00000080   0x42BE             CMPEQ    R6,R7
   \   00000082   0xD116             BNE.N    ??Micro__GetWarmResetAction_1
   \   00000084   0x1C6D             ADDS     R5,R5,#+1
   \   00000086   0xB2ED             UXTB     R5,R5
   \   00000088   0x2D2C             CMP      R5,#+44
   \   0000008A   0xDBC5             BLT.N    ??Micro__GetWarmResetAction_0
   1792              {
   1793                  MicroValidateResetInfoDataCrc();
   \   0000008C   0x2206             MOVS     R2,#+6
   \   0000008E   0xF104 0x012C      ADD      R1,R4,#+44
   \   00000092   0x20FF             MOVS     R0,#+255
   \   00000094   0x.... 0x....      BL       Crc8
   \   00000098   0xF894 0x1032      LDRB     R1,[R4, #+50]
   \   0000009C   0x4281             CMP      R1,R0
   \   0000009E   0xD004             BEQ.N    ??Micro__GetWarmResetAction_2
   \   000000A0   0x22FF             MOVS     R2,#+255
   \   000000A2   0x21FF             MOVS     R1,#+255
   \   000000A4   0x2027             MOVS     R0,#+39
   \   000000A6   0x.... 0x....      BL       SRException__Queue
   1794                  return(Micro_ResetInfo.Warm_Reset_Actions);
   \                     ??Micro__GetWarmResetAction_2: (+1)
   \   000000AA   0xF894 0x002F      LDRB     R0,[R4, #+47]
   \   000000AE   0xB001             ADD      SP,SP,#+4
   \   000000B0   0xBDF0             POP      {R4-R7,PC}       ;; return
   1795              }
   1796              else
   1797              {
   1798                  return((MICRO_WARM_RESET_ACTION_TYPE)0);
   \                     ??Micro__GetWarmResetAction_1: (+1)
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xB001             ADD      SP,SP,#+4
   \   000000B6   0xBDF0             POP      {R4-R7,PC}
   1799              }
   1800          }
   1801          
   1802          //---------------------------------------------------------------------------------------------------------------------
   1803          /**
   1804           *    @brief    This method performs non-volatile memory (FLASH) test periodically.
   1805           *    @details  This method is responsible for checking the FLASH memory consistency.
   1806           *              Run time Flash Test which calculates CRC couple bytes each time and keeps on continuing until it
   1807           *              reaches the FLASH memory end and compare the calculated CRC against a CRC value stored
   1808           *              in FLASH memory.
   1809           *
   1810           *              INBUILT_FLASH_CRC_CALCULATOR macro defines the CRC calculation engine either Inbuilt or External.
   1811           *
   1812           *              MICRO_NUM_BYTE_FOR_FLASH_CONTINUOUS_TEST configuration macro defined in the SRMicro_prv.h file
   1813           *              Defines how many words will be processed each interaction of the Continuous Flash Test.
   1814           *
   1815           *              The time taken for complete FLASH test is calculated below-
   1816           *              For the inbuilt CRC tool(IELF) -
   1817           *              FULL FLASH TEST (in ms) =
   1818           *                 (((FLASH Size in words)-4)/ MICRO_NUM_BYTE_FOR_FLASH_CONTINUOUS_TEST) * Call rate(of Micro__FlashTest())
   1819           *
   1820           *              If the external CRC tool(IELF) is used-
   1821           *              FULL FLASH TEST (in ms) =
   1822           *                  (((FLASH Size in bytes)-4)/ MICRO_NUM_BYTE_FOR_FLASH_CONTINUOUS_TEST) * Call rate(of Micro__FlashTest())
   1823           *
   1824           *              In the calculation FLASH Size-4 because the last 4- bytes of the flash memory is used to
   1825           *              hold the calculated CRC value on which the Flash test is not performed.
   1826           *
   1827           *
   1828           *              For example
   1829           *              Flash size is 32768 in words,  number of bytes processed in each call are 4 and the call rate is 5ms
   1830           *              then time taken by the inbuilt CRC calculator is-
   1831           *              FULL FLASH TEST (in ms) =  ((32768-4) /4)  * 5 ms
   1832           *                                      = 2047.75ms
   1833           *
   1834           *              Along with this it provides the flow control log and exception control for each tests.
   1835           *              Note- Should be called at every 5ms or 25ms slot.
   1836           */
   1837          #pragma optimize=none

   \                                 In section .text, align 2, keep-with-next
   1838          void Micro__SRFlashTest(void)
   1839          {
   \                     Micro__SRFlashTest: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1840              #if (MICRO_SR_FEATURE_TEST == ENABLED)
   1841                  uint8 count;
   1842          
   1843                  SR_FLASHTEST_FLOW_BEGIN()
   \   00000002   0x2004             MOVS     R0,#+4
   \   00000004   0x.... 0x....      BL       SRFlow__MainLogEvent
   1844                  for (count=0; count< MICRO_NUM_BYTE_FOR_FLASH_CONTINUOUS_TEST;count++)
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0004             MOVS     R4,R0
   \                     ??Micro__SRFlashTest_0: (+1)
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C04             CMP      R4,#+4
   \   00000010   0xDA2F             BGE.N    ??Micro__SRFlashTest_1
   1845                  {
   1846                      //Calculate the CRC16 CCIT
   1847                      Micro_Flash_Crc = Crc16__ConstRangeProcess((uint8 *)Micro_Flash_Crc_Pt,Micro_Flash_Crc,4);
   \   00000012   0x2204             MOVS     R2,#+4
   \   00000014   0x....             LDR.N    R0,??DataTable28
   \   00000016   0x8801             LDRH     R1,[R0, #+0]
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable36_8
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x.... 0x....      BL       Crc16__ConstRangeProcess
   \   00000022   0x....             LDR.N    R1,??DataTable28
   \   00000024   0x8008             STRH     R0,[R1, #+0]
   1848          
   1849                      Micro_Flash_Crc_Pt++;
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable36_8
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x1D00             ADDS     R0,R0,#+4
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable36_8
   \   00000032   0x6008             STR      R0,[R1, #+0]
   1850          
   1851                      //If the test reached the end of memory
   1852                      if (Micro_Flash_Crc_Pt >= (uint32 *)MICRO_FLASH_END_ADDRESS)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable36_8
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable36_9
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD315             BCC.N    ??Micro__SRFlashTest_2
   1853                      {
   1854                          //compare the calculated CRC against a CRC value stored in FLASH memory by the IELF tool.
   1855                          if ((uint16)MICRO_FLASH_CRC !=  Micro_Flash_Crc)
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable36_10
   \   00000046   0x8800             LDRH     R0,[R0, #+0]
   \   00000048   0x....             LDR.N    R1,??DataTable28
   \   0000004A   0x8809             LDRH     R1,[R1, #+0]
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xD007             BEQ.N    ??Micro__SRFlashTest_3
   1856                          {
   1857                              //If the test fails throw test fail exception
   1858                              MICRO_SR_EXCEPTION_CONTINUOUS_FLASH(Micro_Flash_Crc, (uint16)MICRO_FLASH_CRC);
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable36_10
   \   00000054   0x8802             LDRH     R2,[R0, #+0]
   \   00000056   0x....             LDR.N    R0,??DataTable28
   \   00000058   0x8801             LDRH     R1,[R0, #+0]
   \   0000005A   0x201E             MOVS     R0,#+30
   \   0000005C   0x.... 0x....      BL       SRException__Queue
   1859                          }
   1860          
   1861                          Micro_Flash_Crc = MICRO_CRC_INITIAL;
   \                     ??Micro__SRFlashTest_3: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x....             LDR.N    R1,??DataTable28
   \   00000064   0x8008             STRH     R0,[R1, #+0]
   1862                          Micro_Flash_Crc_Pt = (uint32 *)MICRO_FLASH_START_ADDRESS;
   \   00000066   0x....             LDR.N    R0,??DataTable28_2
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable36_8
   \   0000006C   0x6008             STR      R0,[R1, #+0]
   1863                      }
   1864                  }
   \                     ??Micro__SRFlashTest_2: (+1)
   \   0000006E   0x1C64             ADDS     R4,R4,#+1
   \   00000070   0xE7CC             B.N      ??Micro__SRFlashTest_0
   1865              #endif
   1866                  SR_FLASHTEST_FLOW_END()
   \                     ??Micro__SRFlashTest_1: (+1)
   \   00000072   0x2005             MOVS     R0,#+5
   \   00000074   0x.... 0x....      BL       SRFlow__MainLogEvent
   1867          }
   \   00000078   0xBD10             POP      {R4,PC}          ;; return
   1868          
   1869          //---------------------------------------------------------------------------------------------------------------------
   1870          /**
   1871           *    @brief    This method returns the Flash size of microcontroller
   1872           *    @return   uint16 : Returns the flash size
   1873           */

   \                                 In section .text, align 2, keep-with-next
   1874          uint32 Micro__GetFlashSize(void)
   1875          {
   1876              return (MICRO_FLASH_SIZE());
   \                     Micro__GetFlashSize: (+1)
   \   00000000   0xF241 0x60BE      MOVW     R0,#+5822
   \   00000004   0x4770             BX       LR               ;; return
   1877          }
   1878          
   1879          //---------------------------------------------------------------------------------------------------------------------
   1880          /**
   1881           *    @brief    This method returns the RAM size of microcontroller.
   1882           *    @return   uint32 : It returns the ram size.
   1883           */

   \                                 In section .text, align 2, keep-with-next
   1884          uint32 Micro__GetRamSize(void)
   1885          {
   1886              return (MICRO_RAM_SIZE());
   \                     Micro__GetRamSize: (+1)
   \   00000000   0x2010             MOVS     R0,#+16
   \   00000002   0x4770             BX       LR               ;; return
   1887          }
   1888          //---------------------------------------------------------------------------------------------------------------------
   1889          /**
   1890           *  @brief      This method returns the revision of the microcontrollers core.
   1891           *  @return     uint8 : Revision of the Microcontroller Core
   1892           */

   \                                 In section .text, align 2, keep-with-next
   1893          MICRO_ID_TYPE * Micro__GetCoreID(void)
   1894          {
   1895              return (MICRO_CPU_ID());
   \                     Micro__GetCoreID: (+1)
   \   00000000   0x.... 0x....      ADR.W    R0,MICRO_CPU_IDENTIFICATION
   \   00000004   0x4770             BX       LR               ;; return
   1896          }
   1897          
   1898          //=====================================================================================================================
   1899          //-------------------------------------- Private Functions ------------------------------------------------------------
   1900          //=====================================================================================================================
   1901          //---------------------------------------------------------------------------------------------------------------------
   1902          /**
   1903           *    @brief    This method initializes system clock.
   1904           *    @details  It uses the PLL as the system clock.
   1905           *              This internal function is called from the Micro__Initialize() API.
   1906           */

   \                                 In section .text, align 4, keep-with-next
   1907          static void MicroInitClk(void)
   1908          {
   1909          	uint16 i;
   1910          	uint8 temp_reg;
   1911          	//uint8 hgo_val;
   1912          	uint32 temp2_reg;
   1913          	#if(ICS_CLK_MODE_FEI == DISABLED)
   1914          		uint8 irc_select;
   1915          		irc_select = 0;
   1916          	#endif
   1917          
   1918          	temp2_reg = 0;
   1919          	temp_reg = 0;
   1920          
   1921          	/*
   1922          	 * Ramp up the system clock, Set the system dividers
   1923          	 * NOTE: The PLL init will not configure the system clock dividers, so they must be configured appropriately before calling the PLL
   1924          	 * init function to ensure that clocks remain in valid ranges.
   1925          	 */
   1926          	if(PMC.REGSC.BYTE & PMC_REGSC_ACKISO_MASK)
   \                     MicroInitClk: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable36_11  ;; 0x4007d002
   \   00000004   0x7801             LDRB     R1,[R0, #+0]
   \   00000006   0x0709             LSLS     R1,R1,#+28
   \   00000008   0xD503             BPL.N    ??MicroInitClk_0
   1927          	{
   1928          		PMC.REGSC.BYTE |= PMC_REGSC_ACKISO_MASK;
   \   0000000A   0x7801             LDRB     R1,[R0, #+0]
   \   0000000C   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000010   0x7001             STRB     R1,[R0, #+0]
   1929          	}
   1930          
   1931          	temp2_reg = SIM.CLKDIV1;
   \                     ??MicroInitClk_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable36_12  ;; 0x40048044
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   1932          	temp2_reg &= ~(SIM_CLKDIV1_OUTDIV1_MASK | SIM_CLKDIV1_OUTDIV2_MASK | SIM_CLKDIV1_OUTDIV3_MASK | SIM_CLKDIV1_OUTDIV4_MASK);
   1933          								// Core/system						// Busclk							// FlexBus						//Flash
   1934          	temp2_reg |= (0 | SIM_CLKDIV1_OUTDIV1(SIM_OUTDIV1) | SIM_CLKDIV1_OUTDIV2(SIM_OUTDIV2) | SIM_CLKDIV1_OUTDIV3(SIM_OUTDIV3) | SIM_CLKDIV1_OUTDIV4(SIM_OUTDIV4));
   1935          	SIM.CLKDIV1 = temp2_reg;
   \   00000018   0xF2C0 0x1163      MOVT     R1,#+355
   \   0000001C   0x6001             STR      R1,[R0, #+0]
   1936          
   1937              #if ((MICRO_EXTERNAL_OSCILATOR == ENABLED))
   1938                  {
   1939                      //hgo_val = 1; 			//Configured crystal oscilllator for high gain operation.
   1940          
   1941                  #if(MICRO_CLOCK_MODE_USED_FLL == ENABLED)
   1942          
   1943                      #if(ICS_CLK_MODE_FEE == ENABLED)
   1944                              {
   1945                                  //FEE: For FLL Bypassed External Reference Clock
   1946                                  //1 External reference clock is enabled and Configures the oscillator load.
   1947                                  OSC.OSC_CR |= (OSC_CR_ERCLKEN_MASK) | (MICRO_OSC_SC2P << OSC_CR_SC2P_SHIFT) | (MICRO_OSC_SC4P << OSC_CR_SC4P_SHIFT) | \
   1948                                                      (MICRO_OSC_SC8P << OSC_CR_SC8P_SHIFT) | (MICRO_OSC_SC16P << OSC_CR_SC16P_SHIFT);
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable36_13  ;; 0x40065000
   \   00000022   0x7801             LDRB     R1,[R0, #+0]
   \   00000024   0xF041 0x0183      ORR      R1,R1,#0x83
   \   00000028   0x7001             STRB     R1,[R0, #+0]
   1949          
   1950          
   1951                                  /*Configure the MCG_C2 register : the RANGE value is determined by the external frequency.
   1952                                   * Since the RANGE parameter affects the FRDIV divide value it still needs to be set correctly even if the oscillator is not being used */
   1953                                  MCG.MCG_C2.BYTE = 0;
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable36_14  ;; 0x40064000
   \   00000030   0x7041             STRB     R1,[R0, #+1]
   1954                                  temp_reg = MCG.MCG_C2.BYTE;
   1955                                  temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK	| MCG_C2_EREFS0_MASK);	//clear fields before writing new values
   1956          
   1957                                  if (HSE_VALUE <= 40000)
   1958                                  {
   1959                                      temp_reg |= (MCG_C2_RANGE0(0) | (MICRO_OSC_HGO << MCG_C2_HGO0_SHIFT) | (1 << MCG_C2_EREFS0_SHIFT));
   1960                                  }
   1961                                  else if (HSE_VALUE <= 8000000)
   1962                                  {
   1963                                      temp_reg |= (MCG_C2_RANGE0(1) | (MICRO_OSC_HGO << MCG_C2_HGO0_SHIFT) | (1 << MCG_C2_EREFS0_SHIFT));
   1964                                  }
   1965                                  else
   1966                                  {
   1967                                      temp_reg |= (MCG_C2_RANGE0(2) | (MICRO_OSC_HGO << MCG_C2_HGO0_SHIFT) | (1 << MCG_C2_EREFS0_SHIFT));
   1968                                  }
   1969          
   1970                                  MCG.MCG_C2.BYTE = temp_reg;
   \   00000032   0x210C             MOVS     R1,#+12
   \   00000034   0x7041             STRB     R1,[R0, #+1]
   1971          
   1972                                  /* Select external oscilator and Reference Divider and clear IREFS to start ext osc If IRCLK is required it must be enabled outside of
   1973                                   * this driver, existing state will be maintained CLKS=0, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0 */
   1974                                  temp_reg = MCG.MCG_C1.BYTE;
   1975                                  temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK);	//Clear values in these fields
   1976                                  temp_reg = MCG_C1_CLKS(0) | MCG_C1_FRDIV(FRDIV_DEF);							//Set the required CLKS and FRDIV values
   1977                                  MCG.MCG_C1.BYTE = temp_reg;
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x7001             STRB     R1,[R0, #+0]
   1978          
   1979                                  /* if the external oscillator is used need to wait for OSCINIT to set */
   1980                                  for (i = 0; i < 10000; i++)
   \   0000003A   0xF242 0x7110      MOVW     R1,#+10000
   1981                                  {
   1982                                      if (MCG.MCG_S.BYTE & MCG_S_OSCINIT0_MASK)
   \                     ??MicroInitClk_1: (+1)
   \   0000003E   0x7982             LDRB     R2,[R0, #+6]
   \   00000040   0x0792             LSLS     R2,R2,#+30
   \   00000042   0xD401             BMI.N    ??MicroInitClk_2
   1983                                          break;																//jump out early if OSCINIT sets before loop finishes
   1984                                  }
   \   00000044   0x1E49             SUBS     R1,R1,#+1
   \   00000046   0xD1FA             BNE.N    ??MicroInitClk_1
   1985          
   1986                                  /* wait for Reference clock Status bit to clear */
   1987                                  for (i = 0; i < 2000; i++)
   \                     ??MicroInitClk_2: (+1)
   \   00000048   0xF44F 0x61FA      MOV      R1,#+2000
   \   0000004C   0x460A             MOV      R2,R1
   1988                                  {
   1989                                      if (!(MCG.MCG_S.BYTE & MCG_S_IREFST_MASK))
   \                     ??MicroInitClk_3: (+1)
   \   0000004E   0x7983             LDRB     R3,[R0, #+6]
   \   00000050   0x06DB             LSLS     R3,R3,#+27
   \   00000052   0xD501             BPL.N    ??MicroInitClk_4
   1990                                          break;																// jump out early if IREFST clears before loop finishes
   1991                                  }
   \   00000054   0x1E52             SUBS     R2,R2,#+1
   \   00000056   0xD1FA             BNE.N    ??MicroInitClk_3
   1992          
   1993                                  /* Wait for clock status bits to show clock source is ext ref clk */
   1994                                  for (i = 0; i < 2000; i++)
   1995                                  {
   1996                                      if (((MCG.MCG_S.BYTE & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)
   \                     ??MicroInitClk_4: (+1)
   \   00000058   0x7982             LDRB     R2,[R0, #+6]
   \   0000005A   0xF3C2 0x0281      UBFX     R2,R2,#+2,#+2
   \   0000005E   0x2A02             CMP      R2,#+2
   \   00000060   0xD001             BEQ.N    ??MicroInitClk_5
   1997                                          break;																//jump out early if CLKST shows EXT CLK slected before loop finishes
   1998                                  }
   \   00000062   0x1E49             SUBS     R1,R1,#+1
   \   00000064   0xD1F8             BNE.N    ??MicroInitClk_4
   1999          
   2000                                  /* Now in FBE: It is recommended that the clock monitor is enabled when using an
   2001                                   * external clock as the clock source/reference. It is enabled here but can be removed if this is not required.*/
   2002                                  MCG.MCG_C6.BYTE |= MCG_C6_CME0_MASK;
   \                     ??MicroInitClk_5: (+1)
   \   00000066   0x7941             LDRB     R1,[R0, #+5]
   \   00000068   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000006C   0x7141             STRB     R1,[R0, #+5]
   2003          
   2004                                  MCG.MCG_C4.BIT.DMX32 = 1;
   \   0000006E   0x78C1             LDRB     R1,[R0, #+3]
   \   00000070   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000074   0x70C1             STRB     R1,[R0, #+3]
   2005                                  MCG.MCG_C4.BIT.DRST_DRS = DCO_RANGE;
   \   00000076   0x78C1             LDRB     R1,[R0, #+3]
   \   00000078   0xF041 0x0160      ORR      R1,R1,#0x60
   \   0000007C   0x70C1             STRB     R1,[R0, #+3]
   2006                                  for (i = 0; i < 5000; i++)
   \   0000007E   0xF241 0x3088      MOVW     R0,#+5000
   2007                                  {
   2008                                      NOP();
   \                     ??MicroInitClk_6: (+1)
   \   00000082   0xBF00             nop 
   2009                                  }
   \   00000084   0x1E40             SUBS     R0,R0,#+1
   \   00000086   0xD1FC             BNE.N    ??MicroInitClk_6
   2010          
   2011                              }
   2012                      #else
   2013                              //FBE: For FLL Bypassed External Reference Clock
   2014                              //1 External reference clock is enabled.
   2015                              OSC.OSC_CR |= (OSC_CR_ERCLKEN_MASK) | (MICRO_OSC_SC2P << OSC_CR_SC2P_SHIFT) | (MICRO_OSC_SC4P << OSC_CR_SC4P_SHIFT) | \
   2016                                                  (MICRO_OSC_SC8P << OSC_CR_SC8P_SHIFT) | (MICRO_OSC_SC16P << OSC_CR_SC16P_SHIFT);
   2017          
   2018                              OSC.OSC_DIV = OSC_DIV_ERPS(MICRO_ERPS_OSCERCLK); 			// OSC CLock divider register.
   2019                              MCG.MCG_C2.BYTE = 0x2C;										//High frequency range selected for the crystal oscillator & high-gain.
   2020                              MCG.MCG_C2.BYTE |= (MICRO_OSC_HGO << MCG_C2_HGO0_SHIFT);
   2021          
   2022                              temp_reg = MCG_C1_CLKS(2) | MCG_C1_FRDIV(FRDIV_DEF); 			//External reference clock selected
   2023                              MCG.MCG_C1.BYTE = temp_reg;
   2024          
   2025                              /* if the external oscillator is used need to wait for OSCINIT to set */
   2026                              for (i = 0; i < 10000; i++)
   2027                              {
   2028                                  if (MCG.MCG_S.BYTE & MCG_S_OSCINIT0_MASK)
   2029                                      break; 												//jump out early if OSCINIT sets before loop finishes
   2030                              }
   2031          
   2032                              /* wait for Reference clock Status bit to clear */
   2033                              for (i = 0; i < 2000; i++)
   2034                              {
   2035                                  if (!(MCG.MCG_S.BYTE & MCG_S_IREFST_MASK))
   2036                                      break; 												//jump out early if IREFST clears before loop finishes
   2037                              }
   2038          
   2039                              /* Wait for clock status bits to show clock source is ext ref clk */
   2040                              for (i = 0; i < 2000; i++)
   2041                              {
   2042                                  if (((MCG.MCG_S.BYTE & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT)== 0x2)
   2043                                      break; 												//jump out early if CLKST shows EXT CLK slected before loop finishes
   2044                              }
   2045          
   2046                              // Now in FBE: It is recommended that the clock monitor is enabled when using an external clock as the clock source/reference.
   2047                              MCG.MCG_C6.BYTE |= MCG_C6_CME0_MASK;
   2048          
   2049                      #endif
   2050          
   2051          
   2052                  #else
   2053                          #if(ICS_CLK_MODE_PEE == ENABLED)
   2054                          {
   2055                              //PEE: For PLL Engaged External Reference Clock
   2056                              //hgo_val = 0; 												//Configured crystal oscilllator for high gain operation.
   2057                              //1 External reference clock is enabled.
   2058                              OSC.OSC_CR |= (OSC_CR_ERCLKEN_MASK) | (MICRO_OSC_SC2P << OSC_CR_SC2P_SHIFT) | (MICRO_OSC_SC4P << OSC_CR_SC4P_SHIFT) | \
   2059                                                  (MICRO_OSC_SC8P << OSC_CR_SC8P_SHIFT) | (MICRO_OSC_SC16P << OSC_CR_SC16P_SHIFT);
   2060          
   2061                              temp_reg = MCG.MCG_C2.BYTE;
   2062                              temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK	| MCG_C2_EREFS0_MASK);	//clear fields before writing new values
   2063          
   2064                              if (HSE_VALUE <= 40000)
   2065                              {
   2066                                  temp_reg |= (MCG_C2_RANGE0(0) | (MICRO_OSC_HGO << MCG_C2_HGO0_SHIFT) | (1 << MCG_C2_EREFS0_SHIFT));
   2067                              }
   2068                              else if (HSE_VALUE <= 8000000)
   2069                              {
   2070                                  temp_reg |= (MCG_C2_RANGE0(1) | (MICRO_OSC_HGO << MCG_C2_HGO0_SHIFT) | (1 << MCG_C2_EREFS0_SHIFT));
   2071                              }
   2072                              else
   2073                              {
   2074                                  temp_reg |= (MCG_C2_RANGE0(2) | (MICRO_OSC_HGO << MCG_C2_HGO0_SHIFT) | (1 << MCG_C2_EREFS0_SHIFT));
   2075                              }
   2076          
   2077                              MCG.MCG_C2.BYTE = temp_reg;
   2078                              MCG.MCG_C1.BYTE = 0x98;										//External reference clock selected
   2079          
   2080                              for (i = 0; i < 10000; i++)									//if the external oscillator is used need to wait for OSCINIT to set
   2081                              {
   2082                                  if (MCG.MCG_S.BYTE & MCG_S_OSCINIT0_MASK)
   2083                                      break;												//jump out early if OSCINIT sets before loop finishes
   2084                              }
   2085          
   2086                              for (i = 0; i < 2000; i++)									//wait for Reference clock Status bit to clear
   2087                              {
   2088                                  if (!(MCG.MCG_S.BYTE & MCG_S_IREFST_MASK))
   2089                                      break;												//jump out early if IREFST clears before loop finishes
   2090                              }
   2091          
   2092                              for (i = 0; i < 2000; i++)									//Wait for clock status bits to show clock source is ext ref clk
   2093                              {
   2094                                  if (((MCG.MCG_S.BYTE & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2)
   2095                                      break;												// jump out early if CLKST shows EXT CLK slected before loop finishes
   2096                              }
   2097          
   2098                              //Now in FBE: It is recommended that the clock monitor is enabled when using an external clock as the clock source/reference.
   2099                              MCG.MCG_C6.BYTE |= MCG_C6_CME0_MASK;
   2100          
   2101                              //Configure MCG_C5: If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user code.
   2102                              temp_reg = MCG.MCG_C5.BYTE;
   2103                              temp_reg &= ~MCG_C5_PRDIV_MASK;
   2104                              temp_reg |= MCG_C5_PRDIV(PRDIV);							//set PLL ref divider
   2105                              MCG.MCG_C5.BYTE = temp_reg;
   2106          
   2107                              //FBE must transition to PBE mode
   2108                              /* Configure MCG_C6: The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk. The clock monitor is not enabled here as it has likely
   2109                               * been enabled previously and so the value of CME is not altered here. The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6 */
   2110                              temp_reg = MCG.MCG_C6.BYTE;									// store present C6 value
   2111                              temp_reg &= ~MCG_C6_VDIV_MASK;								//clear VDIV settings
   2112                              temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV(VDIV0_DEF);			//write new VDIV and enable PLL
   2113                              MCG.MCG_C6.BYTE = temp_reg;									//update MCG_C6
   2114          
   2115                              for (i = 0; i < 2000; i++)									//wait for PLLST status bit to set
   2116                              {
   2117                                  if (MCG.MCG_S.BYTE & MCG_S_PLLST_MASK)
   2118                                      break;												//jump out early if PLLST sets before loop finishes
   2119                              }
   2120          
   2121                              for (i = 0; i < 2000; i++)									//Wait for LOCK bit to set
   2122                              {
   2123                                  if (MCG.MCG_S.BYTE & MCG_S_LOCK0_MASK)
   2124                                      break;												//jump out early if LOCK sets before loop finishes
   2125                              }
   2126          
   2127                              //PBE mode transition into PEE mode
   2128                              MCG.MCG_C1.BYTE &= ~MCG_C1_CLKS_MASK;						//clear CLKS to switch CLKS mux to select PLL as MCG_OUT
   2129          
   2130                              for (i = 0; i < 2000; i++)									// Wait for clock status bits to update
   2131                              {
   2132                                  NOP();
   2133                              }
   2134          
   2135                              //Now in PEE
   2136                          }
   2137                          #else
   2138                              //For PBE PLL bypass external
   2139                              {
   2140          
   2141                              }
   2142                          #endif
   2143          
   2144                      #endif
   2145                      }
   2146              #else				///////For Internal Oscillator ////////
   2147                  {
   2148                      //FEI: For FLL Engaged Internal
   2149                      #if(ICS_CLK_MODE_FEI == ENABLED)					//Default Mode FEI ( FLL Engaged Internal is the default mode of operation )
   2150                              {
   2151                                  MCG.MCG_C4.BIT.DMX32 = 1;
   2152                                  MCG.MCG_C4.BIT.DRST_DRS = DCO_RANGE;
   2153                                  for (i = 0; i < 5000; i++)				// Wait for clock status bits to update
   2154                                  {
   2155                                      NOP();
   2156                                  }
   2157                              }
   2158                      #else
   2159                      {
   2160                          //FEI: For FLL Bypassed Internal
   2161                          if (IRCS_CLOCK == 1)											//Select the desired IRC
   2162                          {
   2163                              MCG.MCG_C2.BYTE |= MCG_C2_IRCS_MASK; 						//select Fast IRCS
   2164                          }
   2165                          else
   2166                          {
   2167                              MCG.MCG_C2.BYTE &= ~MCG_C2_IRCS_MASK; 						//Select Slow IRCS
   2168                          }
   2169          
   2170                          /* Change the CLKS mux to select the IRC as the MCGOUT */
   2171                          temp_reg = MCG.MCG_C1.BYTE;
   2172                          temp_reg &= ~MCG_C1_CLKS_MASK; 									//clear CLKS
   2173                          temp_reg |= MCG_C1_CLKS(1); 									// select IRC as the MCG clock sourse
   2174                          MCG.MCG_C1.BYTE = temp_reg;
   2175          
   2176                          /* wait until internal reference switches to requested irc. */
   2177                          if (!(irc_select))
   2178                          {
   2179                              for (i = 0; i < 2000; i++)
   2180                              {
   2181                                  if (!(MCG.MCG_S.BYTE & MCG_S_IRCST_MASK))
   2182                                      break; 												//jump out early if IRCST clears before loop finishes
   2183                              }
   2184          
   2185                          }
   2186                          else
   2187                          {
   2188                              for (i = 0; i < 2000; i++)
   2189                              {
   2190                                  if (MCG.MCG_S.BYTE & MCG_S_IRCST_MASK)
   2191                                      break; 												//jump out early if IRCST sets before loop finishes
   2192                              }
   2193          
   2194                          }
   2195          
   2196                          /* Wait for clock status bits to update */
   2197                          for (i = 0; i < 2000; i++)
   2198                          {
   2199                              if (((MCG.MCG_S.BYTE & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1)
   2200                                  break; 													//jump out early if CLKST shows IRC slected before loop finishes
   2201                          }
   2202          
   2203                          MCG.MCG_SC.BYTE = MCG_SC_FCRDIV(FCRDIV_CLOCK);					//Fast Clock Internal Reference Divider
   2204          
   2205                      }
   2206                      #endif
   2207          
   2208                  }
   2209              #endif
   2210          
   2211          }
   \   00000088   0x4770             BX       LR               ;; return
   2212          
   2213          /**
   2214           *    @brief    This method initializes system clock to a Low Speed.
   2215           *    @details  Initialization of the clock based on the internal oscillator.
   2216           *              Tuning of the frequency can be done using the DCO_RANGE_INT parameter.
   2217           *
   2218           */

   \                                 In section .text, align 4, keep-with-next
   2219          static void MicroInitClkLowSpeed(void)
   2220          {
   2221              uint32 i;
   2222              uint32 temp2_reg;
   2223          
   2224              temp2_reg = 0;
   2225              // Set the range
   2226              MCG.MCG_C4.BIT.DRST_DRS = DCO_RANGE_INT;
   \                     MicroInitClkLowSpeed: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable36_15  ;; 0x40064003
   \   00000004   0x7801             LDRB     R1,[R0, #+0]
   \   00000006   0xF001 0x019F      AND      R1,R1,#0x9F
   \   0000000A   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000000E   0x7001             STRB     R1,[R0, #+0]
   2227              for (i = 0; i < 5000; i++)              // Wait for clock status bits to update
   \   00000010   0xF241 0x3188      MOVW     R1,#+5000
   2228              {
   2229                  NOP();
   \                     ??MicroInitClkLowSpeed_0: (+1)
   \   00000014   0xBF00             nop 
   2230              }
   \   00000016   0x1E49             SUBS     R1,R1,#+1
   \   00000018   0xD1FC             BNE.N    ??MicroInitClkLowSpeed_0
   2231              // Set the DMX32 bit to narrow the frequency
   2232              MCG.MCG_C4.BIT.DMX32 = 1;
   \   0000001A   0x7801             LDRB     R1,[R0, #+0]
   \   0000001C   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000020   0x7001             STRB     R1,[R0, #+0]
   2233              temp2_reg |= (0 | SIM_CLKDIV1_OUTDIV1(LOWSPEED_SIM_OUTDIV1) | SIM_CLKDIV1_OUTDIV2(LOWSPEED_SIM_OUTDIV2) | SIM_CLKDIV1_OUTDIV3(LOWSPEED_SIM_OUTDIV3) | SIM_CLKDIV1_OUTDIV4(LOWSPEED_SIM_OUTDIV4));
   2234          	SIM.CLKDIV1 = temp2_reg;
   \   00000022   0xF44F 0x00C6      MOV      R0,#+6488064
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable36_12  ;; 0x40048044
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   2235          
   2236          }
   \   0000002C   0x4770             BX       LR               ;; return
   2237          //---------------------------------------------------------------------------------------------------------------------
   2238          /**
   2239           *    @brief    Update the clock registers with the current clock info.
   2240           *    @details  Updates the Micro_ClocksStatus register.
   2241           */

   \                                 In section .text, align 4, keep-with-next
   2242          static void MicroGetClocksStatus()
   2243           {
   2244          	uint8 tmp;
   2245          	uint32 Mcgoutclock;
   2246          	#if(MICRO_HIGHSPEEDRUN_MODE == ENABLED)
   2247          		uint16 i;
                 		       ^
Warning[Pe177]: variable "i" was declared but never referenced
   2248          	#endif
   2249          
   2250          	tmp = 0;
   2251          	Mcgoutclock = 0;
   2252          	tmp = (MCG.MCG_S.BYTE & MCG_S_CLKST_MASK);					//Get SYSCLK source
   2253          	tmp = tmp >> 2;
   2254          
   2255          	switch (tmp)
   \                     MicroGetClocksStatus: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable32_1  ;; 0x40064000
   \   00000002   0x7988             LDRB     R0,[R1, #+6]
   \   00000004   0x0882             LSRS     R2,R0,#+2
   \   00000006   0xF002 0x0203      AND      R2,R2,#0x3
   \   0000000A   0x2A03             CMP      R2,#+3
   \   0000000C   0xD824             BHI.N    ??MicroGetClocksStatus_1
   \   0000000E   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??MicroGetClocksStatus_0:
   \   00000012   0x02 0x17          DC8      0x2,0x17,0x11,0x14
   \              0x11 0x14    
   2256          	{
   2257          	case CLKS_FLL_SELECT:        								//Output of the FLL is selected (reset default)
   2258          		tmp = (MCG.MCG_C1.BYTE & MCG_C1_IREFS_MASK);
   2259          		tmp = tmp >> 2;
   2260          		if (tmp)
   \                     ??MicroGetClocksStatus_2: (+1)
   \   00000016   0x7809             LDRB     R1,[R1, #+0]
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable36_7
   \   0000001C   0xF001 0x0104      AND      R1,R1,#0x4
   \   00000020   0x0889             LSRS     R1,R1,#+2
   \   00000022   0xBF0C             ITE      EQ 
   2261          		{
   2262          			//FEI - Internal reference clock is selected - HSI used as system clock
   2263          			Micro_ClocksStatus.SYSCLK_Frequency = DCO_FREQUENCY_INT;
   2264          			Micro_ClocksStatus.BUSCLK_Frequency = DCO_FREQUENCY_INT;
   2265          			Micro_ClocksStatus.FLEXBUS_Frequency = DCO_FREQUENCY_INT;
   2266          			Micro_ClocksStatus.FLASH_Frequency = DCO_FREQUENCY_INT;
   2267          		}
   2268          		else
   2269          		{
   2270          			//FEE - External reference clock is selected
   2271          			Micro_ClocksStatus.SYSCLK_Frequency = DCO_FREQUENCY;
   \   00000024   0x.... 0x....      LDREQ.W  R1,??DataTable36_16  ;; 0x5b8d800
   2272          			Micro_ClocksStatus.BUSCLK_Frequency = DCO_FREQUENCY;
   2273          			Micro_ClocksStatus.FLEXBUS_Frequency = DCO_FREQUENCY;
   2274          			Micro_ClocksStatus.FLASH_Frequency = DCO_FREQUENCY;
   2275          		}
   \   00000028   0x.... 0x....      LDRNE.W  R1,??DataTable36_17  ;; 0x2dc6c00
   \   0000002C   0x6081             STR      R1,[R0, #+8]
   2276          		break;
   2277          
   2278          	case CLKS_HSE_SELECT: 										//External reference clock is selected.
   2279          		//FBE - FLL Bypass External Mode
   2280          		Micro_ClocksStatus.SYSCLK_Frequency = HSE_VALUE;
   2281          		Micro_ClocksStatus.BUSCLK_Frequency = HSE_VALUE;
   2282          		Micro_ClocksStatus.FLEXBUS_Frequency = HSE_VALUE;
   2283          		Micro_ClocksStatus.FLASH_Frequency = HSE_VALUE;
   2284          		break;
   2285          
   2286          	case CLKS_PLL_SELECT:										//Output of the PLL is selected.
   2287          		Micro_ClocksStatus.SYSCLK_Frequency = MICRO_HSE_VALUE_PLL_CLK;
   2288          		Micro_ClocksStatus.BUSCLK_Frequency = MICRO_HSE_VALUE_PLL_CLK;
   2289          		Micro_ClocksStatus.FLEXBUS_Frequency = MICRO_HSE_VALUE_PLL_CLK;
   2290          		Micro_ClocksStatus.FLASH_Frequency = MICRO_HSE_VALUE_PLL_CLK;
   2291          		break;
   2292          
   2293          	case CLKS_HSI_SELECT:										//Internal reference clock is selected
   2294          		//FEI - Internal reference clock is selected - HSI used as system clock
   2295          		if (MCG.MCG_S.BIT.IRCST == 1)
   2296          		{
   2297          			Mcgoutclock = MICRO_LSI_FAST_MCGIRCLK_VALUE; 		//Slow internal reference clock selected.
   2298          		}
   2299          		else
   2300          		{
   2301          			Mcgoutclock = MICRO_LSI_SLOW_MCGIRCLK_VALUE; 		//Fast internal reference clock selected.
   2302          		}
   2303          
   2304          		Micro_ClocksStatus.SYSCLK_Frequency = Mcgoutclock;
   2305          		Micro_ClocksStatus.BUSCLK_Frequency = Mcgoutclock;
   2306          		Micro_ClocksStatus.FLEXBUS_Frequency = Mcgoutclock;
   \   0000002E   0x6101             STR      R1,[R0, #+16]
   2307          		Micro_ClocksStatus.FLASH_Frequency = Mcgoutclock;
   \   00000030   0x6141             STR      R1,[R0, #+20]
   2308          		break;
   \   00000032   0xE013             B.N      ??MicroGetClocksStatus_3
   \                     ??MicroGetClocksStatus_4: (+1)
   \   00000034   0xF44F 0x4100      MOV      R1,#+32768
   \   00000038   0xE008             B.N      ??MicroGetClocksStatus_5
   \                     ??MicroGetClocksStatus_6: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable36_18  ;; 0x5f5e100
   \   0000003E   0xE005             B.N      ??MicroGetClocksStatus_5
   \                     ??MicroGetClocksStatus_7: (+1)
   \   00000040   0x07C0             LSLS     R0,R0,#+31
   \   00000042   0xBF4C             ITE      MI 
   \   00000044   0x.... 0x....      LDRMI.W  R1,??DataTable36_19  ;; 0x3d0900
   \   00000048   0xF44F 0x41FA      MOVPL    R1,#+32000
   \                     ??MicroGetClocksStatus_5: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable36_7
   \   00000050   0x6081             STR      R1,[R0, #+8]
   \   00000052   0x6101             STR      R1,[R0, #+16]
   \   00000054   0x6141             STR      R1,[R0, #+20]
   \   00000056   0xE001             B.N      ??MicroGetClocksStatus_3
   2309          
   2310          	default:
   2311          		//FEI - Internal reference clock is selected - HSI used as system clock
   2312          		Micro_ClocksStatus.SYSCLK_Frequency = HSI_VALUE;
   \                     ??MicroGetClocksStatus_1: (+1)
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable36_17  ;; 0x2dc6c00
   2313          		break;
   \                     ??MicroGetClocksStatus_3: (+1)
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable36_7
   \   00000060   0x6001             STR      R1,[R0, #+0]
   2314          	}
   2315          
   2316          	//Core/System Clock
   2317          	Micro_ClocksStatus.SYSCLK_Frequency = (Micro_ClocksStatus.SYSCLK_Frequency / (((SIM.CLKDIV1 & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_SHIFT) + 1));
   \   00000062   0x6802             LDR      R2,[R0, #+0]
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable36_12  ;; 0x40048044
   \   00000068   0x680B             LDR      R3,[R1, #+0]
   \   0000006A   0x0F1B             LSRS     R3,R3,#+28
   \   0000006C   0x1C5B             ADDS     R3,R3,#+1
   \   0000006E   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000072   0x6002             STR      R2,[R0, #+0]
   2318          
   2319          	//Compute HCLK,
   2320          	Micro_ClocksStatus.HCLK_Frequency = Micro_ClocksStatus.SYSCLK_Frequency;
   \   00000074   0x6042             STR      R2,[R0, #+4]
   2321          
   2322          	//Get BUSCLK clock
   2323          	Micro_ClocksStatus.BUSCLK_Frequency = (Micro_ClocksStatus.BUSCLK_Frequency / (((SIM.CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> SIM_CLKDIV1_OUTDIV2_SHIFT) + 1));
   \   00000076   0x6882             LDR      R2,[R0, #+8]
   \   00000078   0x680B             LDR      R3,[R1, #+0]
   \   0000007A   0xF3C3 0x6303      UBFX     R3,R3,#+24,#+4
   \   0000007E   0x1C5B             ADDS     R3,R3,#+1
   \   00000080   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000084   0x6082             STR      R2,[R0, #+8]
   2324          
   2325          	//Get FLEXBUS clock
   2326          	Micro_ClocksStatus.FLEXBUS_Frequency = (Micro_ClocksStatus.FLEXBUS_Frequency / (((SIM.CLKDIV1 & SIM_CLKDIV1_OUTDIV3_MASK) >> SIM_CLKDIV1_OUTDIV3_SHIFT) + 1));
   \   00000086   0x6902             LDR      R2,[R0, #+16]
   \   00000088   0x680B             LDR      R3,[R1, #+0]
   \   0000008A   0xF3C3 0x5303      UBFX     R3,R3,#+20,#+4
   \   0000008E   0x1C5B             ADDS     R3,R3,#+1
   \   00000090   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000094   0x6102             STR      R2,[R0, #+16]
   2327          
   2328          	//Get FLASH clock
   2329          	Micro_ClocksStatus.FLASH_Frequency = (Micro_ClocksStatus.FLASH_Frequency / (((SIM.CLKDIV1 & SIM_CLKDIV1_OUTDIV4_MASK) >> SIM_CLKDIV1_OUTDIV4_SHIFT) + 1));
   \   00000096   0x6942             LDR      R2,[R0, #+20]
   \   00000098   0x6809             LDR      R1,[R1, #+0]
   \   0000009A   0xF3C1 0x4103      UBFX     R1,R1,#+16,#+4
   \   0000009E   0x1C49             ADDS     R1,R1,#+1
   \   000000A0   0xFBB2 0xF1F1      UDIV     R1,R2,R1
   \   000000A4   0x6141             STR      R1,[R0, #+20]
   2330          
   2331          }
   \   000000A6   0x4770             BX       LR               ;; return
   2332          
   2333          
   2334          //---------------------------------------------------------------------------------------------------------------------
   2335          /**
   2336           * @brief - This function initializes the micro hardware
   2337           */
   2338          #pragma inline=forced

   \                                 In section .text, align 2, keep-with-next
   2339          static void MicroHWInit(void)
   2340          {
   2341          	MicroWatchdogDisable();								//Disable Watchdog          -- For every reset By default Watchdog is enabled
   \                     MicroHWInit: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable36_20  ;; 0x40052000
   \   00000004   0xF24C 0x5120      MOVW     R1,#+50464
   \   00000008   0x81C1             STRH     R1,[R0, #+14]
   \   0000000A   0xF64F 0x72FE      MOVW     R2,#+65534
   \   0000000E   0xF64D 0x1128      MOVW     R1,#+55592
   \   00000012   0x81C1             STRH     R1,[R0, #+14]
   \   00000014   0x8801             LDRH     R1,[R0, #+0]
   \   00000016   0x4011             ANDS     R1,R2,R1
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   2342              SYSTICK.CTRL &= SYSTICK_COUNTER_DISABLE;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable36_21  ;; 0xe000e010
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0x0849             LSRS     R1,R1,#+1
   \   00000022   0x0049             LSLS     R1,R1,#+1
   \   00000024   0x6001             STR      R1,[R0, #+0]
   2343          
   2344              // Sequence for enabling the FPU in both privileged and user
   2345              // modes. The processor must be in privileged mode to read from and write to the CPACR
   2346              // Set bits 20-23 to enable CP10 and CP11 co-processors
   2347              SCB.CPACR |= MICRO_SCB_CPACR_ENABLE_CP10_CP11_CO_PROCESSOR;
   \   00000026   0xF8D0 0x1D78      LDR      R1,[R0, #+3448]
   \   0000002A   0xF441 0x0170      ORR      R1,R1,#0xF00000
   \   0000002E   0xF8C0 0x1D78      STR      R1,[R0, #+3448]
   2348          
   2349              DISABLE_INTERRUPTS();
   \   00000032   0xB672             CPSID    I
   2350          }
   \   00000034   0x4770             BX       LR               ;; return
   2351          
   2352          //---------------------------------------------------------------------------------------------------------------------
   2353          /**
   2354           * @brief - This function tests the watchdog during boot time
   2355           */
   2356          #if (MICRO_SR_FEATURE_TEST == ENABLED)
   2357          #pragma inline=forced

   \                                 In section .text, align 2, keep-with-next
   2358          static void MicroBootWatchdogTest(void)
   2359          {
   \                     MicroBootWatchdogTest: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2360              //-----------------------------------------------------------------------------------------------------------------
   2361              // CLASSB Test : Watchdog Test
   2362              //
   2363              //Its mandatory to use the Independent watchdog for the CLASSB test
   2364              //-----------------------------------------------------------------------------------------------------------------
   2365              if (Micro__GetLastResetstatus()->WATCHDOG == FALSE)
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable36_1
   \   00000006   0x2206             MOVS     R2,#+6
   \   00000008   0xF104 0x012C      ADD      R1,R4,#+44
   \   0000000C   0x20FF             MOVS     R0,#+255
   \   0000000E   0x.... 0x....      BL       Crc8
   \   00000012   0xF894 0x1032      LDRB     R1,[R4, #+50]
   \   00000016   0x4281             CMP      R1,R0
   \   00000018   0xD004             BEQ.N    ??MicroBootWatchdogTest_0
   \   0000001A   0x22FF             MOVS     R2,#+255
   \   0000001C   0x21FF             MOVS     R1,#+255
   \   0000001E   0x2027             MOVS     R0,#+39
   \   00000020   0x.... 0x....      BL       SRException__Queue
   \                     ??MicroBootWatchdogTest_0: (+1)
   \   00000024   0xF894 0x302D      LDRB     R3,[R4, #+45]
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable36_2  ;; 0x4005200c
   \   0000002C   0xF3C3 0x1340      UBFX     R3,R3,#+5,#+1
   \   00000030   0x2B00             CMP      R3,#+0
   \   00000032   0xF24B 0x4080      MOVW     R0,#+46208
   \   00000036   0xF24A 0x6202      MOVW     R2,#+42498
   \   0000003A   0xF3EF 0x8310      MRS      R3,PRIMASK
   \   0000003E   0xB672             CPSID    I
   \   00000040   0x800A             STRH     R2,[R1, #+0]
   \   00000042   0x8008             STRH     R0,[R1, #+0]
   \   00000044   0xD102             BNE.N    ??MicroBootWatchdogTest_1
   2366              {
   2367                 Micro__ServiceWatchdog();
   \   00000046   0xF383 0x8810      MSR      PRIMASK,R3
   2368          
   2369                  while (1);  //Force a reset by watchdog
   \                     ??MicroBootWatchdogTest_2: (+1)
   \   0000004A   0xE7FE             B.N      ??MicroBootWatchdogTest_2
   2370              }
   2371          
   2372              SERVICE_WATCHDOG();
   \                     ??MicroBootWatchdogTest_1: (+1)
   \   0000004C   0xF383 0x8810      MSR      PRIMASK,R3
   2373          }
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
   2374          #endif
   2375          
   2376          //---------------------------------------------------------------------------------------------------------------------
   2377          /**
   2378           * @brief - This function initializes the watchdog
   2379           */
   2380          //#pragma inline=forced

   \                                 In section .text, align 2, keep-with-next
   2381          void Micro__ConfigureWDT(void)
   2382          {
   2383          #if (MICRO_WATCHDOG_FEATURE == ENABLED)
   2384          	{
   2385          		//First unlock the watchdog so that we can write to registers
   2386          		WDOG_Unlock();
   \                     Micro__ConfigureWDT: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable36_20  ;; 0x40052000
   \   00000004   0xF24C 0x5120      MOVW     R1,#+50464
   \   00000008   0x81C1             STRH     R1,[R0, #+14]
   \   0000000A   0xF64D 0x1128      MOVW     R1,#+55592
   \   0000000E   0x81C1             STRH     R1,[R0, #+14]
   2387          
   2388          		WDOG.STCTRLH = WDOG_STCTRLH_BYTESEL(0x00) |		// test byte 0 when in byte test mode
   2389          				WDOG_STCTRLH_ALLOWUPDATE_MASK |			// allow further updates
   2390          				WDOG_STCTRLH_WDOGEN_MASK |				// enable watchdog
   2391          			#if (MICRO_WATCHDOG_DEBUG_MODE == ENABLED)
   2392          				WDOG_STCTRLH_DBGEN_MASK |				//Watchdog enabled in debug mode
   2393          			#endif
   2394          				0x0100U;
   \   00000010   0xF240 0x1111      MOVW     R1,#+273
   \   00000014   0x8001             STRH     R1,[R0, #+0]
   2395          
   2396          
   2397          
   2398          
   2399          		WDOG.PRESC = WDOG_PRESC_PRESCVAL(WDG_PRESCALER);			// prescalar = PRESC+1
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x82C1             STRH     R1,[R0, #+22]
   2400          		WDOG.WINH = 0;
   \   0000001A   0x8101             STRH     R1,[R0, #+8]
   2401          		WDOG.WINL = 0;
   \   0000001C   0x8141             STRH     R1,[R0, #+10]
   2402          
   2403          		//Since the prescalar is now 1, for a 100 mSec timeout: load the time-out high (WDOG_TOVALH) register with 0, and the time-out low (WDOG_TOVALL) register with 100.
   2404          		WDOG.TOVALH = 0;
   \   0000001E   0x8081             STRH     R1,[R0, #+4]
   2405          		WDOG.TOVALL = IWDG_RELOAD_VALUE;
   \   00000020   0xF44F 0x71FA      MOV      R1,#+500
   \   00000024   0x80C1             STRH     R1,[R0, #+6]
   2406          		SERVICE_WATCHDOG();
   \   00000026   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   0000002A   0xB672             CPSID    I
   \   0000002C   0xF24A 0x6202      MOVW     R2,#+42498
   \   00000030   0x8182             STRH     R2,[R0, #+12]
   \   00000032   0xF24B 0x4280      MOVW     R2,#+46208
   \   00000036   0x8182             STRH     R2,[R0, #+12]
   \   00000038   0xF381 0x8810      MSR      PRIMASK,R1
   2407          
   2408          }
   2409          #endif
   2410          
   2411          }
   \   0000003C   0x4770             BX       LR               ;; return
   2412          
   2413          //---------------------------------------------------------------------------------------------------------------------
   2414          /**
   2415           * @brief - This function is used to disable watchdog
   2416           * @param none
   2417           */
   2418          #pragma inline=forced
   2419          static void MicroWatchdogDisable(void)
   2420           {
   2421          	/* First unlock the watchdog so that we can write to registers */
   2422          	WDOG_Unlock();
   2423          
   2424          	/* Clear the WDOGEN bit to disable the watchdog */
   2425          	WDOG.STCTRLH &= ~WDOG_STCTRLH_WDOGEN_MASK;
   2426          
   2427          }
   2428          
   2429          //---------------------------------------------------------------------------------------------------------------------
   2430          /**
   2431           * @brief -Reads the actual reset value from the micro and clears it
   2432           * @return
   2433           */
   2434          #pragma inline=forced
   2435          static MICRO_LAST_RESET_TYPE MicroReadActualReset(void)
   2436          {
   2437          	MICRO_LAST_RESET_TYPE reset;
   2438          
   2439          	*((uint8 *) (&reset)) = 0;
   2440          
   2441          	//Watchdog reset flag
   2442          	if ((RCM.SRS0 & RCM_SRS0_WDOG_MASK) || (RCM.SSRS0 & RCM_SSRS0_SWDOG_MASK))				//if ((SIM_CLK.SIM_SRSID & SIM_SRSID_WDOGRSTF) != FALSE)
   2443          	{
   2444          		reset.WATCHDOG = TRUE;
   2445          	}
   2446          
   2447          	//Low-power reset flag
   2448          	if (RCM.SRS0 & RCM_SRS0_LVD_MASK)
   2449          	{
   2450          		reset.LVD = TRUE;
   2451          	}
   2452          
   2453          	//Software reset flag or Option byte loader reset flag
   2454          	if (RCM.SRS1 & RCM_SRS1_SW_MASK)
   2455          	{
   2456          		reset.ILLEGAL_OP = TRUE;				//Reset caused by software setting of SYSRESETREQ bit in AIRCR Register in the Arm Core
   2457          	}
   2458          
   2459          	//POR reset flag
   2460          	if (RCM.SRS0 & RCM_SRS0_POR_MASK)
   2461          	{
   2462          		reset.POR = TRUE;		//This POR bits get set all the time for every power up without debugger
   2463          								//Temporary this is commented to resolve this POR bit issue talking with FAE
   2464          	}
   2465          
   2466              // External reset pin which makes external reset flag to set on all other type of resets.
   2467              // IWDG reset, WWDG reset, Power reset, Software reset and Low power management reset asserts 20us of low signal on the
   2468              // External reset pin which makes external reset flag to set on all other type of resets.
   2469              // Actual External reset can only be differentiated only if no other reset occurs other than external reset.
   2470          	if (RCM.SRS0 & RCM_SRS0_PIN_MASK)
   2471          	{
   2472          		reset.EXTERNAL = TRUE;
   2473          	}
   2474          
   2475          	RCM.SSRS0 = 0x7F;						//Clear System Reset Status Register
   2476          	RCM.SSRS1 = 0x3F;
   2477          
   2478              return(reset);
   2479          }
   2480          
   2481          //---------------------------------------------------------------------------------------------------------------------
   2482          /**
   2483           * List all the generic static functions used
   2484           */
   2485          
   2486          //---------------------------------------------------------------------------------------------------------------------
   2487          /**
   2488           *    @brief    This is the routine where the application will end up if a test fails during the boot time.
   2489           *    @details   MicroFailSafe function execution can be customized which depends on the SRMICRO_HALT_ON_FAIL macro defined
   2490           *              in the SRMicro_prv.h file.
   2491           *              If the SRMICRO_HALT_ON_FAIL is ENABLED then-
   2492           *              User can perform the fail routine task in the MICRO_SR_BOOTTEST_FAILURE_TASK() which is defined in the SRMicro_prv.h file.
   2493           *
   2494           *              If the MICRO_SR_BOOTTEST_FAILURE_TASK is commented then-
   2495           *              System reset
   2496           *
   2497           *              This routine been called if any one of the below boot test fails-
   2498           *              CPU Register test,
   2499           *              MARCH C Ram test,
   2500           *              FLASH CRC test
   2501           */
   2502          #if (MICRO_SR_FEATURE_TEST == ENABLED)

   \                                 In section .text, align 2, keep-with-next
   2503          static void MicroFailSafe(void)
   2504          {
   \                     MicroFailSafe: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable32_5  ;; 0xe000ed0c
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable36  ;; 0x5fa0004
   2505               while(1)
   2506               {
   2507                  #ifdef MICRO_SR_BOOTTEST_FAILURE_TASK
   2508                      SERVICE_WATCHDOG();
   2509                      MICRO_SR_BOOTTEST_FAILURE_TASK();
   2510                  #else
   2511                       SYSTEM_RESET();
   \                     ??MicroFailSafe_0: (+1)
   \   00000006   0x6001             STR      R1,[R0, #+0]
   \   00000008   0xE7FD             B.N      ??MicroFailSafe_0
   2512                  #endif
   2513               }
   2514          }
   2515          #endif
   2516          
   2517          //---------------------------------------------------------------------------------------------------------------------
   2518          /**
   2519           * @brief - This function performs the flash boot test
   2520           */
   2521          #if (MICRO_SR_FEATURE_TEST == ENABLED)
   2522          #pragma inline=forced

   \                                 In section .text, align 4, keep-with-next
   2523          static void MicroBootFlashTest(void)
   2524          {
   \                     MicroBootFlashTest: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   2525              //Maximum 12 variables can be assigned as register type. More than that could cause problem.
   2526              //-----------------------------------------------------------------------------------------------------------------
   2527              // CLASSB Test : Flash CRC test
   2528              //
   2529              //This test is used to validate the non-volatile memory consistency
   2530              //-----------------------------------------------------------------------------------------------------------------
   2531              Micro_Flash_Crc = MICRO_CRC_INITIAL;
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable36_22
   2532          
   2533              // for each word in the block
   2534              for ( Micro_Flash_Crc_Pt = MICRO_FLASH_START_ADDRESS; Micro_Flash_Crc_Pt <= MICRO_FLASH_END_ADDRESS; Micro_Flash_Crc_Pt++ )
   \   00000008   0x.... 0x....      LDR.W    R8,??DataTable36_9
   \   0000000C   0x....             LDR.N    R7,??DataTable36_2  ;; 0x4005200c
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x8020             STRH     R0,[R4, #+0]
   \   00000012   0xF24B 0x4680      MOVW     R6,#+46208
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable36_23
   \   0000001A   0x60E0             STR      R0,[R4, #+12]
   \   0000001C   0xF24A 0x6502      MOVW     R5,#+42498
   \   00000020   0x4580             CMP      R8,R0
   \   00000022   0xD311             BCC.N    ??MicroBootFlashTest_0
   2535              {
   2536                  //Calculates the CRC over a range of memory
   2537                  Micro_Flash_Crc = Crc16__RangeProcess((uint8 *)Micro_Flash_Crc_Pt,Micro_Flash_Crc,4);
   \                     ??MicroBootFlashTest_1: (+1)
   \   00000024   0x8821             LDRH     R1,[R4, #+0]
   \   00000026   0x68E0             LDR      R0,[R4, #+12]
   \   00000028   0x2204             MOVS     R2,#+4
   \   0000002A   0x.... 0x....      BL       Crc16__RangeProcess
   \   0000002E   0x8020             STRH     R0,[R4, #+0]
   2538          
   2539                  //Refresh the independent watchdog
   2540                  SERVICE_WATCHDOG();
   \   00000030   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000034   0xB672             CPSID    I
   \   00000036   0x803D             STRH     R5,[R7, #+0]
   \   00000038   0x803E             STRH     R6,[R7, #+0]
   \   0000003A   0xF380 0x8810      MSR      PRIMASK,R0
   2541              }
   \   0000003E   0x68E0             LDR      R0,[R4, #+12]
   \   00000040   0x1D00             ADDS     R0,R0,#+4
   \   00000042   0x60E0             STR      R0,[R4, #+12]
   \   00000044   0x4580             CMP      R8,R0
   \   00000046   0xD2ED             BCS.N    ??MicroBootFlashTest_1
   2542          
   2543              //compare the calculated CRC against a CRC value stored in FLASH memory by the IELF tool.
   2544              if ((uint16)MICRO_FLASH_CRC !=  Micro_Flash_Crc)
   \                     ??MicroBootFlashTest_0: (+1)
   \   00000048   0x....             LDR.N    R0,??DataTable36_10
   \   0000004A   0x8821             LDRH     R1,[R4, #+0]
   \   0000004C   0x8800             LDRH     R0,[R0, #+0]
   \   0000004E   0x4288             CMP      R0,R1
   \   00000050   0xF000 0x8004      BEQ.W    ??MicroBootFlashTest_2
   \                     ??MicroBootFlashTest_3: (+1)
   \   00000054   0x....             LDR.N    R1,??DataTable32_5  ;; 0xe000ed0c
   \   00000056   0x....             LDR.N    R0,??DataTable36  ;; 0x5fa0004
   \   00000058   0x6008             STR      R0,[R1, #+0]
   \   0000005A   0xE7FB             B.N      ??MicroBootFlashTest_3
   2545              {
   2546                  MicroFailSafe();
   2547              }
   2548          }
   \                     ??MicroBootFlashTest_2: (+1)
   \   0000005C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2549          #endif
   2550          
   2551          //---------------------------------------------------------------------------------------------------------------------
   2552          /**
   2553           * @brief - This method handles the reset and realizes which reset method to be apply
   2554           */
   2555          #pragma inline=forced

   \                                 In section .text, align 4, keep-with-next
   2556          static void MicroResetHandling(void)
   2557          {
   \                     MicroResetHandling: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   2558              MICRO_RESET_INFO_HEADER_TYPE local_reset_info;
   2559          
   2560              //Is Signature present
   2561              if (MicroIsResetSignatureValid() == TRUE)
   \   00000004   0x....             LDR.N    R4,??DataTable36_1
   \   00000006   0x.... 0x....      ADR.W    R0,MICRO_RESETINFO_HEADER
   \   0000000A   0x....             LDR.N    R1,??DataTable36_6
   \   0000000C   0x.... 0x....      ADR.W    R2,MICRO_RESETINFO_FOOTER
   \   00000010   0xB08E             SUB      SP,SP,#+56
   \   00000012   0xF04F 0x0C00      MOV      R12,#+0
   \   00000016   0x4623             MOV      R3,R4
   \   00000018   0x4605             MOV      R5,R0
   \   0000001A   0x460E             MOV      R6,R1
   \   0000001C   0xEA4F 0x0702      MOV.W    R7,R2
   \                     ??MicroResetHandling_0: (+1)
   \   00000020   0xF813 0xEB01      LDRB     LR,[R3], #+1
   \   00000024   0xF815 0x8B01      LDRB     R8,[R5], #+1
   \   00000028   0x45C6             CMP      LR,R8
   \   0000002A   0xBF02             ITTT     EQ 
   \   0000002C   0xF816 0xEB01      LDRBEQ   LR,[R6], #+1
   \   00000030   0xF817 0x8B01      LDRBEQ   R8,[R7], #+1
   \   00000034   0x45C6             CMPEQ    LR,R8
   \   00000036   0xD14A             BNE.N    ??MicroResetHandling_1
   \   00000038   0xF813 0xEB01      LDRB     LR,[R3], #+1
   \   0000003C   0xF815 0x8B01      LDRB     R8,[R5], #+1
   \   00000040   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000044   0xFA5F 0xFC8C      UXTB     R12,R12
   \   00000048   0x45C6             CMP      LR,R8
   \   0000004A   0xBF02             ITTT     EQ 
   \   0000004C   0xF816 0xEB01      LDRBEQ   LR,[R6], #+1
   \   00000050   0xF817 0x8B01      LDRBEQ   R8,[R7], #+1
   \   00000054   0x45C6             CMPEQ    LR,R8
   \   00000056   0xD13A             BNE.N    ??MicroResetHandling_1
   \   00000058   0xF813 0xEB01      LDRB     LR,[R3], #+1
   \   0000005C   0xF815 0x8B01      LDRB     R8,[R5], #+1
   \   00000060   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000064   0xFA5F 0xFC8C      UXTB     R12,R12
   \   00000068   0x45C6             CMP      LR,R8
   \   0000006A   0xBF02             ITTT     EQ 
   \   0000006C   0xF816 0xEB01      LDRBEQ   LR,[R6], #+1
   \   00000070   0xF817 0x8B01      LDRBEQ   R8,[R7], #+1
   \   00000074   0x45C6             CMPEQ    LR,R8
   \   00000076   0xD12A             BNE.N    ??MicroResetHandling_1
   \   00000078   0xF813 0xEB01      LDRB     LR,[R3], #+1
   \   0000007C   0xF815 0x8B01      LDRB     R8,[R5], #+1
   \   00000080   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000084   0xFA5F 0xFC8C      UXTB     R12,R12
   \   00000088   0x45C6             CMP      LR,R8
   \   0000008A   0xBF02             ITTT     EQ 
   \   0000008C   0xF816 0xEB01      LDRBEQ   LR,[R6], #+1
   \   00000090   0xF817 0x8B01      LDRBEQ   R8,[R7], #+1
   \   00000094   0x45C6             CMPEQ    LR,R8
   \   00000096   0xD11A             BNE.N    ??MicroResetHandling_1
   \   00000098   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   0000009C   0xFA5F 0xFC8C      UXTB     R12,R12
   \   000000A0   0xF1BC 0x0F2C      CMP      R12,#+44
   \   000000A4   0xDBBC             BLT.N    ??MicroResetHandling_0
   2562              {
   2563                  MicroValidateResetInfoDataCrc();
   \   000000A6   0x2206             MOVS     R2,#+6
   \   000000A8   0xF104 0x012C      ADD      R1,R4,#+44
   \   000000AC   0x20FF             MOVS     R0,#+255
   \   000000AE   0x.... 0x....      BL       Crc8
   \   000000B2   0xF894 0x1032      LDRB     R1,[R4, #+50]
   \   000000B6   0x4281             CMP      R1,R0
   \   000000B8   0xD004             BEQ.N    ??MicroResetHandling_2
   \   000000BA   0x22FF             MOVS     R2,#+255
   \   000000BC   0x21FF             MOVS     R1,#+255
   \   000000BE   0x2027             MOVS     R0,#+39
   \   000000C0   0x.... 0x....      BL       SRException__Queue
   2564          
   2565                  //Perform the Cold reset if the number of warm resets are more than the MICRO_WARM_RESET_COUNTER_LIMIT
   2566                  if (Micro_ResetInfo.Warm_Reset_Count >= MICRO_WARM_RESET_COUNTER_LIMIT)
   \                     ??MicroResetHandling_2: (+1)
   \   000000C4   0xF894 0x0031      LDRB     R0,[R4, #+49]
   \   000000C8   0x2814             CMP      R0,#+20
   \   000000CA   0xDB4A             BLT.N    ??MicroResetHandling_3
   2567                  {
   2568                      MicroValidateResetInfoDataCrc();
   \   000000CC   0xE02F             B.N      ??MicroResetHandling_4
   2569                      Micro_ResetInfo.Force_Cold_Reset = TRUE;
   2570                      MicroUpdateResetInfoDataCrc();
   2571                  }
   2572              }
   2573              else
   2574              {
   2575                  MicroClearResetData();
   \                     ??MicroResetHandling_1: (+1)
   \   000000CE   0x4623             MOV      R3,R4
   \   000000D0   0xF05F 0x050B      MOVS.W   R5,#+11
   \                     ??MicroResetHandling_5: (+1)
   \   000000D4   0xF810 0x6B01      LDRB     R6,[R0], #+1
   \   000000D8   0xF803 0x6B01      STRB     R6,[R3], #+1
   \   000000DC   0x1E6D             SUBS     R5,R5,#+1
   \   000000DE   0xF812 0x6B01      LDRB     R6,[R2], #+1
   \   000000E2   0xF801 0x6B01      STRB     R6,[R1], #+1
   \   000000E6   0xF810 0x6B01      LDRB     R6,[R0], #+1
   \   000000EA   0xF803 0x6B01      STRB     R6,[R3], #+1
   \   000000EE   0xF812 0x6B01      LDRB     R6,[R2], #+1
   \   000000F2   0xF801 0x6B01      STRB     R6,[R1], #+1
   \   000000F6   0xF810 0x6B01      LDRB     R6,[R0], #+1
   \   000000FA   0xF803 0x6B01      STRB     R6,[R3], #+1
   \   000000FE   0xF812 0x6B01      LDRB     R6,[R2], #+1
   \   00000102   0xF801 0x6B01      STRB     R6,[R1], #+1
   \   00000106   0xF810 0x6B01      LDRB     R6,[R0], #+1
   \   0000010A   0xF803 0x6B01      STRB     R6,[R3], #+1
   \   0000010E   0xF812 0x6B01      LDRB     R6,[R2], #+1
   \   00000112   0xF801 0x6B01      STRB     R6,[R1], #+1
   \   00000116   0xD1DD             BNE.N    ??MicroResetHandling_5
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0x62E0             STR      R0,[R4, #+44]
   \   0000011C   0x8620             STRH     R0,[R4, #+48]
   \   0000011E   0x2206             MOVS     R2,#+6
   \   00000120   0xF104 0x012C      ADD      R1,R4,#+44
   \   00000124   0x20FF             MOVS     R0,#+255
   \   00000126   0x.... 0x....      BL       Crc8
   \   0000012A   0xF884 0x0032      STRB     R0,[R4, #+50]
   2576          
   2577                  MicroValidateResetInfoDataCrc();
   \                     ??MicroResetHandling_4: (+1)
   \   0000012E   0x2206             MOVS     R2,#+6
   \   00000130   0xF104 0x012C      ADD      R1,R4,#+44
   \   00000134   0x20FF             MOVS     R0,#+255
   \   00000136   0x.... 0x....      BL       Crc8
   \   0000013A   0xF894 0x1032      LDRB     R1,[R4, #+50]
   \   0000013E   0x4281             CMP      R1,R0
   \   00000140   0xD004             BEQ.N    ??MicroResetHandling_6
   \   00000142   0x22FF             MOVS     R2,#+255
   \   00000144   0x21FF             MOVS     R1,#+255
   \   00000146   0x2027             MOVS     R0,#+39
   \   00000148   0x.... 0x....      BL       SRException__Queue
   2578                  Micro_ResetInfo.Force_Cold_Reset = TRUE;
   \                     ??MicroResetHandling_6: (+1)
   \   0000014C   0x2001             MOVS     R0,#+1
   \   0000014E   0xF884 0x0030      STRB     R0,[R4, #+48]
   2579                  MicroUpdateResetInfoDataCrc();
   \   00000152   0x2206             MOVS     R2,#+6
   \   00000154   0xF104 0x012C      ADD      R1,R4,#+44
   \   00000158   0x20FF             MOVS     R0,#+255
   \   0000015A   0x.... 0x....      BL       Crc8
   \   0000015E   0xF884 0x0032      STRB     R0,[R4, #+50]
   2580              }
   2581          
   2582          
   2583          
   2584          
   2585              //Validate and store the Micro_ResetInfo value into stack variable
   2586              MicroValidateResetInfoDataCrc();
   \                     ??MicroResetHandling_3: (+1)
   \   00000162   0x2206             MOVS     R2,#+6
   \   00000164   0xF104 0x012C      ADD      R1,R4,#+44
   \   00000168   0x20FF             MOVS     R0,#+255
   \   0000016A   0x.... 0x....      BL       Crc8
   \   0000016E   0xF894 0x1032      LDRB     R1,[R4, #+50]
   \   00000172   0x4281             CMP      R1,R0
   \   00000174   0xD004             BEQ.N    ??MicroResetHandling_7
   \   00000176   0x22FF             MOVS     R2,#+255
   \   00000178   0x21FF             MOVS     R1,#+255
   \   0000017A   0x2027             MOVS     R0,#+39
   \   0000017C   0x.... 0x....      BL       SRException__Queue
   2587              memcpy(&local_reset_info, &Micro_ResetInfo, sizeof(Micro_ResetInfo));
   \                     ??MicroResetHandling_7: (+1)
   \   00000180   0x2233             MOVS     R2,#+51
   \   00000182   0x4621             MOV      R1,R4
   \   00000184   0xA801             ADD      R0,SP,#+4
   \   00000186   0x.... 0x....      BL       __aeabi_memcpy4
   2588          
   2589          
   2590              //Read the actual reset register content
   2591              local_reset_info.Actual_Reset = MicroReadActualReset();
   \   0000018A   0x2000             MOVS     R0,#+0
   \   0000018C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000190   0x....             LDR.N    R0,??DataTable36_24  ;; 0x4007f000
   \   00000192   0x7801             LDRB     R1,[R0, #+0]
   \   00000194   0x0689             LSLS     R1,R1,#+26
   \   00000196   0xD402             BMI.N    ??MicroResetHandling_8
   \   00000198   0x7A01             LDRB     R1,[R0, #+8]
   \   0000019A   0x0689             LSLS     R1,R1,#+26
   \   0000019C   0xD502             BPL.N    ??MicroResetHandling_9
   \                     ??MicroResetHandling_8: (+1)
   \   0000019E   0x2120             MOVS     R1,#+32
   \   000001A0   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \                     ??MicroResetHandling_9: (+1)
   \   000001A4   0x7801             LDRB     R1,[R0, #+0]
   \   000001A6   0x0789             LSLS     R1,R1,#+30
   \   000001A8   0xD505             BPL.N    ??MicroResetHandling_10
   \   000001AA   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000001AE   0xF041 0x0102      ORR      R1,R1,#0x2
   \   000001B2   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \                     ??MicroResetHandling_10: (+1)
   \   000001B6   0x7841             LDRB     R1,[R0, #+1]
   \   000001B8   0x0749             LSLS     R1,R1,#+29
   \   000001BA   0xD505             BPL.N    ??MicroResetHandling_11
   \   000001BC   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000001C0   0xF041 0x0110      ORR      R1,R1,#0x10
   \   000001C4   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \                     ??MicroResetHandling_11: (+1)
   \   000001C8   0x7801             LDRB     R1,[R0, #+0]
   \   000001CA   0x0609             LSLS     R1,R1,#+24
   \   000001CC   0xD505             BPL.N    ??MicroResetHandling_12
   \   000001CE   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000001D2   0xF041 0x0180      ORR      R1,R1,#0x80
   \   000001D6   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \                     ??MicroResetHandling_12: (+1)
   \   000001DA   0x7801             LDRB     R1,[R0, #+0]
   \   000001DC   0x0649             LSLS     R1,R1,#+25
   \   000001DE   0xD505             BPL.N    ??MicroResetHandling_13
   \   000001E0   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000001E4   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000001E8   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \                     ??MicroResetHandling_13: (+1)
   \   000001EC   0x217F             MOVS     R1,#+127
   \   000001EE   0x7201             STRB     R1,[R0, #+8]
   \   000001F0   0x213F             MOVS     R1,#+63
   \   000001F2   0x7241             STRB     R1,[R0, #+9]
   \   000001F4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000001F8   0xF88D 0x0031      STRB     R0,[SP, #+49]
   2592          
   2593              //do not save the reset type if the previous reset was intentional. Intentional reset was done in watch dog testing
   2594              if ((local_reset_info.Warm_Reset_Actions & MICRO_WARM_RESET_ACTION_SKIP_WATCHDOG_TEST) != MICRO_WARM_RESET_ACTION_SKIP_WATCHDOG_TEST)
   \   000001FC   0xF89D 0x0033      LDRB     R0,[SP, #+51]
   \   00000200   0x0701             LSLS     R1,R0,#+28
   \   00000202   0xBF59             ITTEE    PL 
   2595              {
   2596                  local_reset_info.Reset = local_reset_info.Actual_Reset;
   \   00000204   0xF89D 0x0000      LDRBPL   R0,[SP, #+0]
   \   00000208   0xF88D 0x0030      STRBPL   R0,[SP, #+48]
   2597              }
   2598              else
   2599              {
   2600                  //clear the watch dog test
   2601                  local_reset_info.Warm_Reset_Actions &= ~MICRO_WARM_RESET_ACTION_SKIP_WATCHDOG_TEST;
                                                                ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)

          MicroClearResetData();
          ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Micro\Micro.c",1343  Warning[Go005]: 
          Cannot inline function "MicroClearResetData" at this level of
          optimization

          MicroClearResetData();
          ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Micro\Micro.c",1343  Warning[Go004]: 
          Could not inline function "MicroClearResetData" (inlined function is
          too complex or inlining is turned off)

      MicroResetHandling();
      ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Micro\Micro.c",1148  Warning[Go005]: 
          Cannot inline function "MicroResetHandling" at this level of
          optimization

      MicroResetHandling();
      ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Micro\Micro.c",1148  Warning[Go004]: 
          Could not inline function "MicroResetHandling" (inlined function is
          too complex or inlining is turned off)

              MICRO_BOOTTEST_FLASHTEST();
              ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Micro\Micro.c",1204  Warning[Go005]: 
          Cannot inline function "MicroBootFlashTest" at this level of
          optimization

              MICRO_BOOTTEST_FLASHTEST();
              ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Micro\Micro.c",1204  Warning[Go004]: 
          Could not inline function "MicroBootFlashTest" (inlined function is
          too complex or inlining is turned off)

              MICRO_BOOTTEST_WDTEST();
              ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Micro\Micro.c",1195  Warning[Go005]: 
          Cannot inline function "MicroBootWatchdogTest" at this level of
          optimization

              MICRO_BOOTTEST_WDTEST();
              ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Micro\Micro.c",1195  Warning[Go004]: 
          Could not inline function "MicroBootWatchdogTest" (inlined function
          is too complex or inlining is turned off)

      MICRO_BOOTTEST_MICROHWINIT();
      ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Micro\Micro.c",1125  Warning[Go005]: 
          Cannot inline function "MicroHWInit" at this level of optimization

      MICRO_BOOTTEST_MICROHWINIT();
      ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Micro\Micro.c",1125  Warning[Go004]: 
          Could not inline function "MicroHWInit" (inlined function is too
          complex or inlining is turned off)

          Micro__EnableWarmResetAction(MICRO_WARM_RESET_ACTION_SKIP_CLASSB_TEST);
          ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Micro\Micro.c",1349  Warning[Go005]: 
          Cannot inline function "Micro__EnableWarmResetAction" at this level
          of optimization

          Micro__EnableWarmResetAction(MICRO_WARM_RESET_ACTION_SKIP_CLASSB_TEST);
          ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Micro\Micro.c",1349  Warning[Go004]: 
          Could not inline function "Micro__EnableWarmResetAction" (inlined
          function is too complex or inlining is turned off)

              Micro__EnableWarmResetAction(MICRO_WARM_RESET_ACTION_SKIP_CLASSB_TEST);
              ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Micro\Micro.c",1209  Warning[Go005]: 
          Cannot inline function "Micro__EnableWarmResetAction" at this level
          of optimization

              Micro__EnableWarmResetAction(MICRO_WARM_RESET_ACTION_SKIP_CLASSB_TEST);
              ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Micro\Micro.c",1209  Warning[Go004]: 
          Could not inline function "Micro__EnableWarmResetAction" (inlined
          function is too complex or inlining is turned off)

              Micro__EnableWarmResetAction(MICRO_WARM_RESET_ACTION_SKIP_WATCHDOG_TEST);
              ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Micro\Micro.c",1188  Warning[Go005]: 
          Cannot inline function "Micro__EnableWarmResetAction" at this level
          of optimization

              Micro__EnableWarmResetAction(MICRO_WARM_RESET_ACTION_SKIP_WATCHDOG_TEST);
              ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Driver\Micro\Micro.c",1188  Warning[Go004]: 
          Could not inline function "Micro__EnableWarmResetAction" (inlined
          function is too complex or inlining is turned off)
   \   0000020C   0xF000 0x00F7      ANDMI    R0,R0,#0xF7
   \   00000210   0xF88D 0x0033      STRBMI   R0,[SP, #+51]
   2602              }
   2603          
   2604              //What is the reset type?Cold or Warm
   2605              if ((local_reset_info.Reset.POR          == 1) ||
   2606                  (local_reset_info.Reset.LVD          == 1) ||
   2607                  (local_reset_info.Force_Cold_Reset   == TRUE))
   \   00000214   0xF89D 0x0030      LDRB     R0,[SP, #+48]
   \   00000218   0x2182             MOVS     R1,#+130
   \   0000021A   0x4208             TST      R0,R1
   \   0000021C   0xD103             BNE.N    ??MicroResetHandling_14
   \   0000021E   0xF89D 0x0034      LDRB     R0,[SP, #+52]
   \   00000222   0x2801             CMP      R0,#+1
   \   00000224   0xD101             BNE.N    ??MicroResetHandling_15
   2608              {
   2609                  local_reset_info.Mode = MICRO_RESET_MODE_COLD;
   \                     ??MicroResetHandling_14: (+1)
   \   00000226   0x2000             MOVS     R0,#+0
   \   00000228   0xE005             B.N      ??MicroResetHandling_16
   2610              }
   2611              else
   2612              {
   2613                  local_reset_info.Warm_Reset_Count++;
   \                     ??MicroResetHandling_15: (+1)
   \   0000022A   0xF89D 0x0035      LDRB     R0,[SP, #+53]
   \   0000022E   0x1C40             ADDS     R0,R0,#+1
   \   00000230   0xF88D 0x0035      STRB     R0,[SP, #+53]
   2614                  local_reset_info.Mode = MICRO_RESET_MODE_WARM;
   \   00000234   0x2001             MOVS     R0,#+1
   \                     ??MicroResetHandling_16: (+1)
   \   00000236   0xF88D 0x0032      STRB     R0,[SP, #+50]
   2615              }
   2616          
   2617              //Restore and update the Crc of the Micro_ResetInfo
   2618              memcpy(&Micro_ResetInfo, &local_reset_info, sizeof(Micro_ResetInfo));
   \   0000023A   0x2233             MOVS     R2,#+51
   \   0000023C   0xA901             ADD      R1,SP,#+4
   \   0000023E   0x4620             MOV      R0,R4
   \   00000240   0x.... 0x....      BL       __aeabi_memcpy4
   2619              MicroUpdateResetInfoDataCrc();
   \   00000244   0x2206             MOVS     R2,#+6
   \   00000246   0xF104 0x012C      ADD      R1,R4,#+44
   \   0000024A   0x20FF             MOVS     R0,#+255
   \   0000024C   0x.... 0x....      BL       Crc8
   \   00000250   0xF884 0x0032      STRB     R0,[R4, #+50]
   2620          }
   \   00000254   0xB00E             ADD      SP,SP,#+56
   \   00000256   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2621          
   2622          //---------------------------------------------------------------------------------------------------------------------
   2623          /**
   2624           * @brief - This function clears the reset data
   2625           */
   2626          #pragma inline=forced

   \                                 In section .text, align 4, keep-with-next
   2627          static void MicroClearResetData(void)
   2628          {
   \                     MicroClearResetData: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   2629              MicroSetRamSignature();
   \   00000002   0x....             LDR.N    R4,??DataTable36_1
   \   00000004   0x.... 0x....      ADR.W    R1,MICRO_RESETINFO_HEADER
   \   00000008   0x....             LDR.N    R2,??DataTable36_6
   \   0000000A   0x.... 0x....      ADR.W    R3,MICRO_RESETINFO_FOOTER
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0xF05F 0x050B      MOVS.W   R5,#+11
   \                     ??MicroClearResetData_0: (+1)
   \   00000014   0xF811 0x6B01      LDRB     R6,[R1], #+1
   \   00000018   0xF800 0x6B01      STRB     R6,[R0], #+1
   \   0000001C   0x1E6D             SUBS     R5,R5,#+1
   \   0000001E   0xF813 0x6B01      LDRB     R6,[R3], #+1
   \   00000022   0xF802 0x6B01      STRB     R6,[R2], #+1
   \   00000026   0xF811 0x6B01      LDRB     R6,[R1], #+1
   \   0000002A   0xF800 0x6B01      STRB     R6,[R0], #+1
   \   0000002E   0xF813 0x6B01      LDRB     R6,[R3], #+1
   \   00000032   0xF802 0x6B01      STRB     R6,[R2], #+1
   \   00000036   0xF811 0x6B01      LDRB     R6,[R1], #+1
   \   0000003A   0xF800 0x6B01      STRB     R6,[R0], #+1
   \   0000003E   0xF813 0x6B01      LDRB     R6,[R3], #+1
   \   00000042   0xF802 0x6B01      STRB     R6,[R2], #+1
   \   00000046   0xF811 0x6B01      LDRB     R6,[R1], #+1
   \   0000004A   0xF800 0x6B01      STRB     R6,[R0], #+1
   \   0000004E   0xF813 0x6B01      LDRB     R6,[R3], #+1
   \   00000052   0xF802 0x6B01      STRB     R6,[R2], #+1
   \   00000056   0xD1DD             BNE.N    ??MicroClearResetData_0
   2630          
   2631              (*(uint8 *)&(Micro_ResetInfo.Reset))        = 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x62E0             STR      R0,[R4, #+44]
   2632              (*(uint8 *)&(Micro_ResetInfo.Actual_Reset)) = 0;
   2633              Micro_ResetInfo.Mode                        = MICRO_RESET_MODE_COLD;
   2634              Micro_ResetInfo.Warm_Reset_Actions          = (MICRO_WARM_RESET_ACTION_TYPE)0;
   2635              Micro_ResetInfo.Force_Cold_Reset            = FALSE;
   \   0000005C   0x8620             STRH     R0,[R4, #+48]
   2636              Micro_ResetInfo.Warm_Reset_Count            = 0;
   2637          
   2638              MicroUpdateResetInfoDataCrc();
   \   0000005E   0x2206             MOVS     R2,#+6
   \   00000060   0xF104 0x012C      ADD      R1,R4,#+44
   \   00000064   0x20FF             MOVS     R0,#+255
   \   00000066   0x.... 0x....      BL       Crc8
   \   0000006A   0xF884 0x0032      STRB     R0,[R4, #+50]
   2639          }
   \   0000006E   0xBD70             POP      {R4-R6,PC}       ;; return
   2640          
   2641          //---------------------------------------------------------------------------------------------------------------------
   2642          /**
   2643           * @brief - sets the RAM signature
   2644           */
   2645          #pragma inline=forced
   2646          static void MicroSetRamSignature(void)
   2647          {
   2648              uint8 index;
   2649          
   2650              for (index = 0; index < MICRO_RESETINFO_STRING_SIZE; index++)
   2651              {
   2652                  Micro_ResetInfo.Header[index] = MICRO_RESETINFO_HEADER[index];
   2653                  Micro_ResetInfo_Footer[index] = MICRO_RESETINFO_FOOTER[index];
   2654              }
   2655          }
   2656          
   2657          //---------------------------------------------------------------------------------------------------------------------
   2658          /**
   2659           * @brief This function validates the reset signature
   2660           * @return
   2661           */
   2662          #pragma inline=forced
   2663          static BOOL_TYPE MicroIsResetSignatureValid(void)
   2664          {
   2665              BOOL_TYPE sign_valid;
   2666              uint8 index;
   2667          
   2668              sign_valid = TRUE;
   2669          
   2670              for (index = 0; index < MICRO_RESETINFO_STRING_SIZE; index++)
   2671              {
   2672                  if ((Micro_ResetInfo.Header[index] != MICRO_RESETINFO_HEADER[index]) ||
   2673                      (Micro_ResetInfo_Footer[index] != MICRO_RESETINFO_FOOTER[index]))
   2674                  {
   2675                      sign_valid = FALSE;
   2676                      break;
   2677                  }
   2678              }
   2679          
   2680              return(sign_valid);
   2681          }
   2682          
   2683          //---------------------------------------------------------------------------------------------------------------------
   2684          /**
   2685           * @brief - Validates the Data integrity of the Micro_ResetInfo variable
   2686           * @return
   2687           */

   \                                 In section .text, align 2, keep-with-next
   2688          static void MicroValidateResetInfoDataCrc(void)
   2689          {
   \                     MicroValidateResetInfoDataCrc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2690              if (Micro_ResetInfo.Crc8_Data_Integrator != Crc8(0xFF,MICRO_RESETINFO_CLASSB_DATA_FROM, MICRO_RESETINFO_CLASSB_DATA_SIZE)) //lint !e928 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
   \   00000002   0x....             LDR.N    R4,??DataTable36_1
   \   00000004   0x2206             MOVS     R2,#+6
   \   00000006   0xF104 0x012C      ADD      R1,R4,#+44
   \   0000000A   0x20FF             MOVS     R0,#+255
   \   0000000C   0x.... 0x....      BL       Crc8
   \   00000010   0xF894 0x1032      LDRB     R1,[R4, #+50]
   \   00000014   0x4281             CMP      R1,R0
   \   00000016   0xD006             BEQ.N    ??MicroValidateResetInfoDataCrc_0
   2691              {
   2692                  SRException__Queue(SREXCEPTION_MICRO_RESET_SIGNATURE_CORUPTION,0xFF,0xFF);
   \   00000018   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001C   0x22FF             MOVS     R2,#+255
   \   0000001E   0x21FF             MOVS     R1,#+255
   \   00000020   0x2027             MOVS     R0,#+39
   \   00000022   0x.... 0x....      B.W      SRException__Queue
   2693              }
   2694          }
   \                     ??MicroValidateResetInfoDataCrc_0: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   2695          
   2696          //---------------------------------------------------------------------------------------------------------------------
   2697          /**
   2698           * @brief - Update the Data integrity of the Micro_ResetInfo variable
   2699           * @return
   2700           */

   \                                 In section .text, align 2, keep-with-next
   2701          static void MicroUpdateResetInfoDataCrc(void)
   2702          {
   \                     MicroUpdateResetInfoDataCrc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2703              Micro_ResetInfo.Crc8_Data_Integrator = Crc8(0xFF,MICRO_RESETINFO_CLASSB_DATA_FROM, MICRO_RESETINFO_CLASSB_DATA_SIZE); //lint !e928 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
   \   00000002   0x....             LDR.N    R4,??DataTable36_1
   \   00000004   0x2206             MOVS     R2,#+6
   \   00000006   0xF104 0x012C      ADD      R1,R4,#+44
   \   0000000A   0x20FF             MOVS     R0,#+255
   \   0000000C   0x.... 0x....      BL       Crc8
   \   00000010   0xF884 0x0032      STRB     R0,[R4, #+50]
   2704          }
   \   00000014   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x40052000         DC32     0x40052000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0xE000E010         DC32     0xe000e010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \   00000000   0xE000E400         DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_3:
   \   00000000   0x4007F008         DC32     0x4007f008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x05FA0500         DC32     0x5fa0500

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \   00000000   0x........         DC32     __ICFEDIT_INTERRUPT_TABLE_start__

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x........         DC32     Micro_Flash_Crc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \   00000000   0x........         DC32     SFB(STACK_OVERFLOW_SIGNATURE)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \   00000000   0x........         DC32     MICRO_FLASH_START

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \   00000000   0x........         DC32     SFB(STACK_UNDERFLOW_SIGNATURE)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_4:
   \   00000000   0x72616559         DC32     0x72616559

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_5:
   \   00000000   0x3030316C         DC32     0x3030316c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_6:
   \   00000000   0x6F6F706C         DC32     0x6f6f706c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   0x72696857         DC32     0x72696857

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_1:
   \   00000000   0x20534545         DC32     0x20534545

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_2:
   \   00000000   0x6167724F         DC32     0x6167724f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_3:
   \   00000000   0x617A696E         DC32     0x617a696e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_4:
   \   00000000   0x6E6F6974         DC32     0x6e6f6974

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x40048038         DC32     0x40048038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \   00000000   0x4005200C         DC32     0x4005200c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   0x40040000         DC32     0x40040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_1:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_2:
   \   00000000   0x4007D000         DC32     0x4007d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_3:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_4:
   \   00000000   0x4007D001         DC32     0x4007d001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_5:
   \   00000000   0xE000ED0C         DC32     0xe000ed0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_6:
   \   00000000   0xE000ED18         DC32     0xe000ed18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_1:
   \   00000000   0x05FA0004         DC32     0x5fa0004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_2:
   \   00000000   0x........         DC32     __ICFEDIT_region_RAM_start__

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_3:
   \   00000000   0x........         DC32     __ICFEDIT_region_RAM_end__

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36:
   \   00000000   0x05FA0004         DC32     0x5fa0004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_1:
   \   00000000   0x........         DC32     Micro_ResetInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_2:
   \   00000000   0x4005200C         DC32     0x4005200c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_3:
   \   00000000   0x........         DC32     Run_Time_Stack_Pointer_Inv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_4:
   \   00000000   0x........         DC32     Run_Time_Stack_Pointer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_5:
   \   00000000   0x4007E000         DC32     0x4007e000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_6:
   \   00000000   0x........         DC32     Micro_ResetInfo_Footer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_7:
   \   00000000   0x........         DC32     Micro_ClocksStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_8:
   \   00000000   0x........         DC32     Micro_Flash_Crc_Pt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_9:
   \   00000000   0x........         DC32     MICRO_FLASH_END

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_10:
   \   00000000   0x........         DC32     MICRO_FLASH_CRC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_11:
   \   00000000   0x4007D002         DC32     0x4007d002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_12:
   \   00000000   0x40048044         DC32     0x40048044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_13:
   \   00000000   0x40065000         DC32     0x40065000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_14:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_15:
   \   00000000   0x40064003         DC32     0x40064003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_16:
   \   00000000   0x05B8D800         DC32     0x5b8d800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_17:
   \   00000000   0x02DC6C00         DC32     0x2dc6c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_18:
   \   00000000   0x05F5E100         DC32     0x5f5e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_19:
   \   00000000   0x003D0900         DC32     0x3d0900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_20:
   \   00000000   0x40052000         DC32     0x40052000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_21:
   \   00000000   0xE000E010         DC32     0xe000e010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_22:
   \   00000000   0x........         DC32     Micro_Flash_Crc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_23:
   \   00000000   0x........         DC32     MICRO_FLASH_START

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_24:
   \   00000000   0x4007F000         DC32     0x4007f000
   2705          
   2706          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   MicroBootFlashTest
        24   -> Crc16__RangeProcess
       8   MicroBootWatchdogTest
         8   -> Crc8
         8   -> SRException__Queue
      16   MicroClearResetData
        16   -> Crc8
       0   MicroFailSafe
       0   MicroGetClocksStatus
       0   MicroHWInit
       0   MicroInitClk
       0   MicroInitClkLowSpeed
      80   MicroResetHandling
        80   -> Crc8
        80   -> SRException__Queue
        80   -> __aeabi_memcpy4
       8   MicroUpdateResetInfoDataCrc
         8   -> Crc8
       8   MicroValidateResetInfoDataCrc
         8   -> Crc8
         0   -> SRException__Queue
      32   Micro__BootTest
        32   -> MicroBootFlashTest
        32   -> MicroBootWatchdogTest
        32   -> MicroClearResetData
        32   -> MicroFailSafe
        32   -> MicroHWInit
        32   -> MicroInitClkLowSpeed
        32   -> MicroResetHandling
        32   -> MicroUpdateResetInfoDataCrc
        32   -> MicroValidateResetInfoDataCrc
        32   -> Micro__ConfigureWDT
        32   -> Micro__EnableWarmResetAction
        32   -> Micro__GetResetMode
        32   -> SRMCPwm__Initialize_Before_Boot
        32   -> __StartupRegisterTest
        32   -> __iar_data_init3
        32   -> __iar_program_start
        32   -> main
       0   Micro__ClearLvdIsrRegisters
       0   Micro__ConfigureLvd
       0   Micro__ConfigureWDT
       0   Micro__DelayNumNops
      24   Micro__EnableWarmResetAction
        24   -> Crc8
        24   -> SRException__Queue
       0   Micro__ForceReset
       0   Micro__GetClock
       0   Micro__GetCoreID
       0   Micro__GetFlashSize
       8   Micro__GetLastResetstatus
         8   -> Crc8
         8   -> SRException__Queue
       0   Micro__GetLvdStatus
       0   Micro__GetRamSize
       8   Micro__GetResetMode
         8   -> Crc8
         8   -> SRException__Queue
      24   Micro__GetWarmResetAction
        24   -> Crc8
        24   -> SRException__Queue
      16   Micro__GoSleep
        16   -> Crc8
        16   -> SRException__Queue
       0   Micro__HardfaultHdlr
      32   Micro__Initialize
        32   -> MicroGetClocksStatus
        32   -> MicroInitClkLowSpeed
        32   -> SRData__UpdateLong
         0   -> SRFlow__InitLogEvent
        32   -> SRFlow__InitLogEvent
        32   -> __aeabi_memclr4
       0   Micro__LPTimerInterrupt
         0   -> SRClockMonitor__MonitorExtClk
       0   Micro__NVICDisableIRQ
       0   Micro__NVICEnableIRQ
       8   Micro__SRFlashTest
         8   -> Crc16__ConstRangeProcess
         8   -> SRException__Queue
         8   -> SRFlow__MainLogEvent
      32   Micro__SRRamTest
        32   -> Micro__ServiceWatchdog
        32   -> SRData__CheckLong
        32   -> SRException__Queue
        32   -> SRFlow__MainLogEvent
        32   -> __RunRegisterTest
       0   Micro__ServiceWatchdog
      24   Micro__SetLowSpeedMode
        24   -> MicroGetClocksStatus
       8   Micro__SetNormalSpeedMode
         8   -> MicroGetClocksStatus
         8   -> MicroInitClk
       0   Micro__Trap


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_2
       4  ??DataTable28_3
       4  ??DataTable28_4
       4  ??DataTable28_5
       4  ??DataTable28_6
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable29_2
       4  ??DataTable29_3
       4  ??DataTable29_4
       4  ??DataTable30
       4  ??DataTable31
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable32_2
       4  ??DataTable32_3
       4  ??DataTable32_4
       4  ??DataTable32_5
       4  ??DataTable32_6
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable34_2
       4  ??DataTable34_3
       4  ??DataTable36
       4  ??DataTable36_1
       4  ??DataTable36_10
       4  ??DataTable36_11
       4  ??DataTable36_12
       4  ??DataTable36_13
       4  ??DataTable36_14
       4  ??DataTable36_15
       4  ??DataTable36_16
       4  ??DataTable36_17
       4  ??DataTable36_18
       4  ??DataTable36_19
       4  ??DataTable36_2
       4  ??DataTable36_20
       4  ??DataTable36_21
       4  ??DataTable36_22
       4  ??DataTable36_23
       4  ??DataTable36_24
       4  ??DataTable36_3
       4  ??DataTable36_4
       4  ??DataTable36_5
       4  ??DataTable36_6
       4  ??DataTable36_7
       4  ??DataTable36_8
       4  ??DataTable36_9
       8  MICRO_CPU_IDENTIFICATION
      16  MICRO_FLASH_CONFIGURATION
       8  MICRO_ID
      44  MICRO_RESETINFO_FOOTER
      44  MICRO_RESETINFO_HEADER
      96  MicroBootFlashTest
      82  MicroBootWatchdogTest
     112  MicroClearResetData
      10  MicroFailSafe
     168  MicroGetClocksStatus
      54  MicroHWInit
     138  MicroInitClk
      46  MicroInitClkLowSpeed
     602  MicroResetHandling
      22  MicroUpdateResetInfoDataCrc
      40  MicroValidateResetInfoDataCrc
      24  Micro_ClocksStatus
      16  Micro_Flash_Crc
          Run_Time_Stack_Pointer
          Run_Time_Stack_Pointer_Inv
          Micro_Flash_Crc_Pt
      52  Micro_ResetInfo
      44  Micro_ResetInfo_Footer
     776  Micro__BootTest
      14  Micro__ClearLvdIsrRegisters
     112  Micro__ConfigureLvd
      62  Micro__ConfigureWDT
      32  Micro__DelayNumNops
     164  Micro__EnableWarmResetAction
      30  Micro__ForceReset
       6  Micro__GetClock
       6  Micro__GetCoreID
       6  Micro__GetFlashSize
      42  Micro__GetLastResetstatus
      20  Micro__GetLvdStatus
       4  Micro__GetRamSize
      42  Micro__GetResetMode
     184  Micro__GetWarmResetAction
     162  Micro__GoSleep
      20  Micro__HardfaultHdlr
     382  Micro__Initialize
      22  Micro__LPTimerInterrupt
      24  Micro__NVICDisableIRQ
      88  Micro__NVICEnableIRQ
     122  Micro__SRFlashTest
     458  Micro__SRRamTest
      28  Micro__ServiceWatchdog
     156  Micro__SetLowSpeedMode
      52  Micro__SetNormalSpeedMode
      12  Micro__Trap
       4  Ram0_Page_End_Protection
       4  Ram1_Page_Start_Protection

 
    44 bytes in section .RESET_INFO_FOOTER
    52 bytes in section .RESET_INFO_HEADER
    40 bytes in section .bss
     8 bytes in section .bss               (abs)
     8 bytes in section .rodata
 4 716 bytes in section .text
    16 bytes in section FlashConfig
 
 4 552 bytes of CODE  memory (+ 164 bytes shared)
    24 bytes of CONST memory
   144 bytes of DATA  memory

Errors: none
Warnings: 20
