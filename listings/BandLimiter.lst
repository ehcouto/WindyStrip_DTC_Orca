###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        19/Nov/2024  13:15:14
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  Category\Application\BandLimiter\BandLimiter.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        BandLimiter.obj -l ..\listings\BandLimiter.lst
#        Category\Application\BandLimiter\BandLimiter.c
#    List file    =  ..\listings\BandLimiter.lst
#    Object file  =  BandLimiter.obj
#
###############################################################################

C:\Data\Python\Windy_sBpm_Floating\source\Category\Application\BandLimiter\BandLimiter.c
      1          /**
      2           *  @file       
      3           *
      4           *  @brief      BandLimiter module for limiting the bandwidth of signals using digital filters
      5           *
      6           *  @details    Digital signals are characterized by their frequency content. In general, a digital signal's maximum
      7           *              bandwidth (frequency content) is half its sample rate. When downsampling (moving from a high sample rate to
      8           *              a lower one), it is necessary to ensure the source signal (with high sample rate) is band-limited to half the
      9           *              destination sample rate (low sample rate). That is, it must have all frequency content above half the destination
     10           *              sample rate removed before downsampling. This is to avoid a type of corruption in the data called aliasing.
     11           *              Aliasing occurs when a signal is sampled at less than the minimum rate (called the Nyquist rate) to capture all
     12           *              the frequency content in the signal. The purpose of this module is to remove frequency content using digital
     13           *              low-pass filters so that signals may be safely downsampled without aliasing.
     14           *
     15           *  @section    Applicable_Documents
     16           *					List here all the applicable documents if needed. <tr>	
     17           *
     18           *  $Header: BandLimiter.c 1.1 2016/02/02 13:40:32EST Guilherme Bencke Teixeira da Silva (BENCKG1) Exp  $
     19           *
     20           *  @copyright  Copyright 2015-$Date: 2016/02/02 13:40:32EST $. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     21           */
     22          //---------------------------------------------------------------------------------------------------------------------
     23          //---------------------------------------------------------------------------------------------------------------------
     24          
     25          
     26          //-------------------------------------- Include Files ----------------------------------------------------------------
     27          #include "C_Extensions.h"
     28          #include <math.h>
     29          #include "BandLimiter.h" 
     30          #include "DigitalFilter.h"
     31          #include "BandLimiter_prv.h"

   \                                 In section .rodata, align 4, keep-with-next
   \   static __absolute struct <unnamed> const BAND0_COEFFS[1]
   \                     BAND0_COEFFS:
   \   00000000   0x40000000         DC32 40000000H, 3F800000H, 0BFF77901H, 3F6F7ED3H, 3A0CD0DAH
   \              0x3F800000   
   \              0xBFF77901   
   \              0x3F6F7ED3   
   \              0x3A0CD0DA   
     32          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     33          
     34          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     35          //! Band specification structure. Comprised of arrays whose elements correspond to the signals
     36          //! in the Signal_List member.
     37          typedef struct {
     38              const BANDLIMITER_SIGNAL_TYPE   		*Signal_List;       				//!< Pointer to list of signals in band
     39              BOOL_TYPE                       		*Signal_Enable;     				//!< Signal enable array pointer. Each element enables/disables the
     40                                                                  						//!< corresponding entry in the Signal_List.
     41              DIGITAL_FILTER_SOS_TYPE					filter;
     42              BIQUAD_STATE_TYPE						(*States)[BAND0_NUM_SECTIONS];		//!< Filter states storage
     43              float32                         		*Filtered_Signals;  				//!< Filter output array pointer. Each element holds the filtered output
     44                                                                  						//!< for the corresponding element in the Signal_List.
     45              const uint8                    			Num_Signals;        				//!< Number of signals in band (length of all arrays in the structure)
     46          } BAND_SPEC_TYPE;
     47          
     48          //! Array number of elements macro.
     49          #define NUM_ELEMENTS(array) (sizeof(array) / sizeof(array[0]))
     50          
     51          CT_ASSERT ( NUM_ELEMENTS(BAND0_COEFFS) == BAND0_NUM_SECTIONS );
     52          
     53          //! List of signals in Band 0

   \                                 In section .text, align 4, keep-with-next
     54          static const BANDLIMITER_SIGNAL_TYPE BAND0_SIGNAL_LIST[] =
   \                     BAND0_SIGNAL_LIST:
   \   00000000   0x00 0x01          DC8 0, 1, 2, 3
   \              0x02 0x03    
     55          {
     56              BANDLIMITER_SIGNAL_DRUM_TORQUE_NM,
     57              BANDLIMITER_SIGNAL_DRUM_SPEED_RAD_S,
     58              BANDLIMITER_SIGNAL_SIN_DRUM_ANGLE,
     59              BANDLIMITER_SIGNAL_COS_DRUM_ANGLE
     60          };
     61          
     62          #define BAND0_NUM_SIGNALS   NUM_ELEMENTS(BAND0_SIGNAL_LIST)     //!< Number of signals in Band 0
     63          
     64          static BOOL_TYPE                Band0_Signal_Enable[BAND0_NUM_SIGNALS];     //!< Band 0 signal enable array
     65          //! Band 0 filter storage array. First dimension is indexed by signal; second dimension is indexed by filter section.
     66          static BIQUAD_STATE_TYPE        Band0_Filter_States[BAND0_NUM_SIGNALS][BAND0_NUM_SECTIONS];
     67          static float32                  Band0_Filtered_Signals[BAND0_NUM_SIGNALS];  //!< Band 0 filter output storage array
     68          
     69          //! Band specification list. This list contains the operating parameters for each band in the module.

   \                                 In section .text, align 4, keep-with-next
     70          static const BAND_SPEC_TYPE BAND_SPEC_LIST[] =
   \                     BAND_SPEC_LIST:
   \   00000000   0x........         DC32 BAND0_SIGNAL_LIST, Band0_Signal_Enable, BAND0_COEFFS
   \              0x........   
   \              0x........   
   \   0000000C   0x01 0x00          DC8 1, 0, 0, 0
   \              0x00 0x00    
   \   00000010   0x........         DC32 Band0_Filter_States, Band0_Filtered_Signals
   \              0x........   
   \   00000018   0x04 0x00          DC8 4, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .bss, align 4
   \                     Band0_Filtered_Signals:
   \   00000000                      DS8 16
   \                     Band0_Signal_Enable:
   \   00000010                      DS8 4
   \   00000014                      DS8 4
   \   00000018                      DS8 4
   \                     Band0_Filter_States:
   \   0000001C                      DS8 32
     71          {
     72              {   // Band 0
     73                  .Signal_List = BAND0_SIGNAL_LIST,
     74                  .Signal_Enable = Band0_Signal_Enable,
     75                  .Num_Signals = BAND0_NUM_SIGNALS,
     76          		.filter = {
     77          				.Coeffs = (DIGITAL_FILTER_BIQUAD_COEFF_TYPE*)(void*)BAND0_COEFFS,
     78          				.Num_Sections = BAND0_NUM_SECTIONS
     79          		},
     80          		.States = Band0_Filter_States,
     81                  .Filtered_Signals = Band0_Filtered_Signals
     82              }
     83          };
     84          
     85          //! Rotor angle, result of the integration of motor_speed * belt_ratio.
     86          static float32 Rotor_Angle;
     87          //! Previous motor speed, used for trapezoidal integration.
     88          static float32 Previous_Omega;
     89          
     90          CT_ASSERT ( NUM_ELEMENTS(BAND_SPEC_LIST) == BANDLIMITER_NUM_OF_BANDS );
     91          
     92          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
     93          
     94          static float32 FilterSignal(BANDLIMITER_SIGNAL_TYPE signal, DIGITAL_FILTER_SOS_TYPE filter, BIQUAD_STATE_TYPE *states);
     95          static BOOL_TYPE IsSignalInBand(BANDLIMITER_BAND_TYPE band, BANDLIMITER_SIGNAL_TYPE signal);
     96          static void IntegrateSpeed(void);
     97          
     98          //=====================================================================================================================
     99          //-------------------------------------- Public Functions -------------------------------------------------------------
    100          //=====================================================================================================================
    101          
    102          //---------------------------------------------------------------------------------------------------------------------
    103          /**
    104           *  @brief      It Initializes the module BandLimiter and its variables
    105           *
    106           */

   \                                 In section .text, align 2, keep-with-next
    107          void BandLimiter__Initialize(void)
    108          {
   \                     BandLimiter__Initialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    109          	Rotor_Angle = 0.0f;
   \   00000002   0x....             LDR.N    R4,??DataTable14_7
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6160             STR      R0,[R4, #+20]
    110          	Previous_Omega = 0.0f;
   \   00000008   0x61A0             STR      R0,[R4, #+24]
    111          
    112              BandLimiter__ResetAll();
   \   0000000A   0x6020             STR      R0,[R4, #+0]
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF104 0x001C      ADD      R0,R4,#+28
   \   00000012   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x6060             STR      R0,[R4, #+4]
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0xF104 0x0024      ADD      R0,R4,#+36
   \   00000020   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x60A0             STR      R0,[R4, #+8]
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0xF104 0x002C      ADD      R0,R4,#+44
   \   0000002E   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x60E0             STR      R0,[R4, #+12]
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0xF104 0x0034      ADD      R0,R4,#+52
   \   0000003C   0x.... 0x....      BL       DigitalFilter__ResetSOS
    113              BandLimiter__DisableAll();
   \   00000040   0x2104             MOVS     R1,#+4
   \   00000042   0xF104 0x0010      ADD      R0,R4,#+16
   \   00000046   0x.... 0x....      BL       __aeabi_memclr4
    114              BandLimiter__EnableAll(); //TODO Remove this line
   \   0000004A   0xF104 0x0010      ADD      R0,R4,#+16
   \   0000004E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0x2104             MOVS     R1,#+4
   \   00000056   0x.... 0x....      B.W      __aeabi_memset4
    115          }
    116          
    117          /**
    118           *  @brief      Get filtered signal.
    119           *
    120           *  @details    The core function of BandLimiter. Returns a signal which has been filtered according to the filter in
    121           *              #BAND_SPEC_LIST. The filtered signal is said to be "band-limited" to the passband of the filter. The band-
    122           *              limited signal may then be sampled at a frequency no smaller than the Nyquist rate, which is double
    123           *              the bandwidth of the signal. As long as the filtered signal is sampled with a rate above Nyquist, there
    124           *              will not be aliasing in the downsampled data. For example, a filter with significant attenuation above 50Hz
    125           *              will band-limit a signal to 50Hz. The filtered signal may then be sampled at any rate greater than or equal
    126           *              to 100Hz, which is the Nyquist rate for the filtered signal.
    127           *
    128           *  @param      band = Band containing signal to retreive.
    129           *  @param      signal = filtered signal to retrieve.
    130           *
    131           *  @return     The filtered signal. Units depend on the requested signal.
    132           */

   \                                 In section .text, align 4, keep-with-next
    133          float32 BandLimiter__GetSignal(BANDLIMITER_BAND_TYPE band, BANDLIMITER_SIGNAL_TYPE signal)
    134          {
    135              uint8 i;
    136              float32 output = 0.0f;
   \                     BandLimiter__GetSignal: (+1)
   \   00000000   0xED9F 0x....      VLDR.W   S0,??DataTable14  ;; 0x0
    137          
    138              if(band >= BANDLIMITER_NUM_OF_BANDS)    // Invalid band selection by user (not in band list)
   \   00000004   0xB9B0             CBNZ.N   R0,??BandLimiter__GetSignal_0
    139              {
    140                  DEBUG_INVALID_BAND_GET_SELECTION(band);
    141              }
    142              else if(IsSignalInBand(band,signal) == FALSE)   // Queried signal not present in band
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xBF18             IT       NE 
   \   0000000A   0x2901             CMPNE    R1,#+1
   \   0000000C   0xD003             BEQ.N    ??BandLimiter__GetSignal_1
   \   0000000E   0x2902             CMP      R1,#+2
   \   00000010   0xBF18             IT       NE 
   \   00000012   0x2903             CMPNE    R1,#+3
   \   00000014   0xD10E             BNE.N    ??BandLimiter__GetSignal_0
    143              {
    144                  DEBUG_SIGNAL_TO_GET_NOT_IN_BAND(signal,band);
    145              }
    146              else    // requested signal is available
    147              {
    148                  for(i = 0; i < BAND_SPEC_LIST[band].Num_Signals; i++)   // Loop over signals in band to find the requested signal
    149                  {
    150                      if(BAND_SPEC_LIST[band].Signal_List[i] == signal)
   \                     ??BandLimiter__GetSignal_1: (+1)
   \   00000016   0xB929             CBNZ.N   R1,??BandLimiter__GetSignal_2
    151                      {
    152                          output = BAND_SPEC_LIST[band].Filtered_Signals[i];
   \                     ??BandLimiter__GetSignal_3: (+1)
   \   00000018   0x....             LDR.N    R1,??DataTable14_7
   \   0000001A   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   0000001E   0xEE00 0x0A10      VMOV     S0,R0
    153          
    154                          if(BAND_SPEC_LIST[band].Signal_Enable[i] == DISABLED)   // Requested signal is not enabled
    155                          {
    156                              DEBUG_SIGNAL_TO_GET_NOT_ENABLED(signal,band);
    157                          }
    158          
    159                          break;
   \   00000022   0x4770             BX       LR
    160                      }
   \                     ??BandLimiter__GetSignal_2: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x2901             CMP      R1,#+1
   \   00000028   0xBF1F             ITTTT    NE 
   \   0000002A   0x2002             MOVNE    R0,#+2
   \   0000002C   0x2902             CMPNE    R1,#+2
   \   0000002E   0x2003             MOVNE    R0,#+3
   \   00000030   0x2903             CMPNE    R1,#+3
   \   00000032   0xD0F1             BEQ.N    ??BandLimiter__GetSignal_3
    161                  }
    162              }
    163          
    164              return output;
   \                     ??BandLimiter__GetSignal_0: (+1)
   \   00000034   0x4770             BX       LR               ;; return
    165          }
    166          
    167          /**
    168           *  @brief      Reset filter states and filtered output for a signal.
    169           *
    170           *  @param      band = Band containing signal to reset.
    171           *  @param      signal = filtered signal to reset.
    172           */

   \                                 In section .text, align 2, keep-with-next
    173          void BandLimiter__ResetSignal(BANDLIMITER_BAND_TYPE band, BANDLIMITER_SIGNAL_TYPE signal)
    174          {
    175              uint8 i;
    176          
    177              if(band >= BANDLIMITER_NUM_OF_BANDS)    // Invalid band selection by user (not in band list)
   \                     BandLimiter__ResetSignal: (+1)
   \   00000000   0xB9D0             CBNZ.N   R0,??BandLimiter__ResetSignal_0
    178              {
    179                  DEBUG_INVALID_BAND_RESET_SELECTION(band);
    180              }
    181              else if(IsSignalInBand(band,signal) ==  FALSE)   // Queried signal not present in band
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xBF18             IT       NE 
   \   00000006   0x2901             CMPNE    R1,#+1
   \   00000008   0xD003             BEQ.N    ??BandLimiter__ResetSignal_1
   \   0000000A   0x2902             CMP      R1,#+2
   \   0000000C   0xBF18             IT       NE 
   \   0000000E   0x2903             CMPNE    R1,#+3
   \   00000010   0xD112             BNE.N    ??BandLimiter__ResetSignal_0
    182              {
    183                  DEBUG_SIGNAL_TO_RESET_NOT_IN_BAND(signal,band);
    184              }
    185              else        // requested signal is available
    186              {
    187                  for(i = 0; i < BAND_SPEC_LIST[band].Num_Signals; i++)   // Loop over signals in band to find the requested signal
    188                  {
    189                      if(BAND_SPEC_LIST[band].Signal_List[i] == signal)
   \                     ??BandLimiter__ResetSignal_1: (+1)
   \   00000012   0xB949             CBNZ.N   R1,??BandLimiter__ResetSignal_2
    190                      {
    191                          BAND_SPEC_LIST[band].Filtered_Signals[i] = 0.0f;     // Reset filtered signal
   \                     ??BandLimiter__ResetSignal_3: (+1)
   \   00000014   0x....             LDR.N    R2,??DataTable14_7
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    192                          DigitalFilter__ResetSOS(BAND_SPEC_LIST[band].States[i], BAND_SPEC_LIST[band].filter.Num_Sections);   // Reset filter states
   \   0000001C   0xEB02 0x00C0      ADD      R0,R2,R0, LSL #+3
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x301C             ADDS     R0,R0,#+28
   \   00000024   0x.... 0x....      B.W      DigitalFilter__ResetSOS
    193                          break;
    194                      }
   \                     ??BandLimiter__ResetSignal_2: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x2901             CMP      R1,#+1
   \   0000002C   0xBF1F             ITTTT    NE 
   \   0000002E   0x2002             MOVNE    R0,#+2
   \   00000030   0x2902             CMPNE    R1,#+2
   \   00000032   0x2003             MOVNE    R0,#+3
   \   00000034   0x2903             CMPNE    R1,#+3
   \   00000036   0xD0ED             BEQ.N    ??BandLimiter__ResetSignal_3
    195                  }
    196              }
    197          }
   \                     ??BandLimiter__ResetSignal_0: (+1)
   \   00000038   0x4770             BX       LR               ;; return
    198          
    199          /**
    200           *  @brief      Reset filter states and filtered output for all signals in band.
    201           *
    202           *  @param      band = Band whose signals are to be reset
    203           */

   \                                 In section .text, align 2, keep-with-next
    204          void BandLimiter__ResetBand(BANDLIMITER_BAND_TYPE band)
    205          {
   \                     BandLimiter__ResetBand: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    206              uint8 i;
    207          
    208              if(band >= BANDLIMITER_NUM_OF_BANDS)    // Invalid band selection by user (not in band list)
   \   00000002   0xB9E8             CBNZ.N   R0,??BandLimiter__ResetBand_0
    209              {
    210                  DEBUG_INVALID_BAND_RESET_SELECTION(band);
    211              }
    212              else    // Band selection is valid
    213              {
    214                  for(i = 0; i < BAND_SPEC_LIST[band].Num_Signals; i++)   // Loop over signals in band
   \   00000004   0x....             LDR.N    R4,??DataTable14_7
    215                  {
    216                      BAND_SPEC_LIST[band].Filtered_Signals[i] = 0.0f;     // Reset filtered signal
   \   00000006   0x6020             STR      R0,[R4, #+0]
    217                      DigitalFilter__ResetSOS(BAND_SPEC_LIST[band].States[i], BAND_SPEC_LIST[band].filter.Num_Sections);   // Reset filter states
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0xF104 0x001C      ADD      R0,R4,#+28
   \   0000000E   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x6060             STR      R0,[R4, #+4]
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0xF104 0x0024      ADD      R0,R4,#+36
   \   0000001C   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x60A0             STR      R0,[R4, #+8]
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0xF104 0x002C      ADD      R0,R4,#+44
   \   0000002A   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x60E0             STR      R0,[R4, #+12]
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0xF104 0x0034      ADD      R0,R4,#+52
   \   00000038   0xE8BD 0x4010      POP      {R4,LR}
   \   0000003C   0x.... 0x....      B.W      DigitalFilter__ResetSOS
    218                  }
    219              }
    220          }
   \                     ??BandLimiter__ResetBand_0: (+1)
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    221          
    222          /**
    223           *  @brief      Reset filter states and filtered output for all signals in all bands in module
    224           */

   \                                 In section .text, align 2, keep-with-next
    225          void BandLimiter__ResetAll(void)
    226          {
   \                     BandLimiter__ResetAll: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    227              BANDLIMITER_BAND_TYPE i;
    228          
    229              for(i = (BANDLIMITER_BAND_TYPE)0; i < BANDLIMITER_NUM_OF_BANDS; i++)    // Loop over bands in module
   \   00000002   0x....             LDR.N    R4,??DataTable14_7
    230              {
    231                  BandLimiter__ResetBand(i);      // Reset all signals in band
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0xF104 0x001C      ADD      R0,R4,#+28
   \   0000000E   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x6060             STR      R0,[R4, #+4]
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0xF104 0x0024      ADD      R0,R4,#+36
   \   0000001C   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x60A0             STR      R0,[R4, #+8]
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0xF104 0x002C      ADD      R0,R4,#+44
   \   0000002A   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x60E0             STR      R0,[R4, #+12]
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0xF104 0x0034      ADD      R0,R4,#+52
   \   00000038   0xE8BD 0x4010      POP      {R4,LR}
   \   0000003C   0x.... 0x....      B.W      DigitalFilter__ResetSOS
    232              }
    233          }
    234          
    235          /**
    236           *  @brief      Enable filtering for specified signal.
    237           *
    238           *  @param      band = Band containing signal to enable.
    239           *  @param      signal = signal for which to enable filtering.
    240           */

   \                                 In section .text, align 2, keep-with-next
    241          void BandLimiter__EnableSignal(BANDLIMITER_BAND_TYPE band, BANDLIMITER_SIGNAL_TYPE signal)
    242          {
    243              uint8 i;
    244          
    245              if(band >= BANDLIMITER_NUM_OF_BANDS)    // Invalid band selection by user (not in band list)
   \                     BandLimiter__EnableSignal: (+1)
   \   00000000   0xB9A8             CBNZ.N   R0,??BandLimiter__EnableSignal_0
    246              {
    247                  DEBUG_INVALID_BAND_ENABLE_SELECTION(band);
    248              }
    249              else if(IsSignalInBand(band,signal) ==  FALSE)  // Queried signal not present in band
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xBF18             IT       NE 
   \   00000006   0x2901             CMPNE    R1,#+1
   \   00000008   0xD003             BEQ.N    ??BandLimiter__EnableSignal_1
   \   0000000A   0x2902             CMP      R1,#+2
   \   0000000C   0xBF18             IT       NE 
   \   0000000E   0x2903             CMPNE    R1,#+3
   \   00000010   0xD10D             BNE.N    ??BandLimiter__EnableSignal_0
    250              {
    251                  DEBUG_SIGNAL_TO_ENABLE_NOT_IN_BAND(signal,band);
    252              }
    253              else        // requested signal is available
    254              {
    255                  for(i = 0; i < BAND_SPEC_LIST[band].Num_Signals; i++)   // Loop over signals in band to find the requested signal
    256                  {
    257                      if(BAND_SPEC_LIST[band].Signal_List[i] == signal)
   \                     ??BandLimiter__EnableSignal_1: (+1)
   \   00000012   0xB921             CBNZ.N   R1,??BandLimiter__EnableSignal_2
    258                      {
    259                          BAND_SPEC_LIST[band].Signal_Enable[i] = TRUE;   // enable signal
   \                     ??BandLimiter__EnableSignal_3: (+1)
   \   00000014   0x....             LDR.N    R2,??DataTable14_7
   \   00000016   0x1880             ADDS     R0,R0,R2
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x7401             STRB     R1,[R0, #+16]
    260                          break;
   \   0000001C   0x4770             BX       LR
    261                      }
   \                     ??BandLimiter__EnableSignal_2: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x2901             CMP      R1,#+1
   \   00000022   0xBF1F             ITTTT    NE 
   \   00000024   0x2002             MOVNE    R0,#+2
   \   00000026   0x2902             CMPNE    R1,#+2
   \   00000028   0x2003             MOVNE    R0,#+3
   \   0000002A   0x2903             CMPNE    R1,#+3
   \   0000002C   0xD0F2             BEQ.N    ??BandLimiter__EnableSignal_3
    262                  }
    263              }
    264          }
   \                     ??BandLimiter__EnableSignal_0: (+1)
   \   0000002E   0x4770             BX       LR               ;; return
    265          
    266          /**
    267           *  @brief      Enable filtering for all signals in specified band.
    268           *
    269           *  @param      band = Band whose signals are to be enabled
    270           */

   \                                 In section .text, align 2, keep-with-next
    271          void BandLimiter__EnableBand(BANDLIMITER_BAND_TYPE band)
    272          {
    273              uint8 i;
    274          
    275              if(band >= BANDLIMITER_NUM_OF_BANDS)    // Invalid band selection by user (not in band list)
   \                     BandLimiter__EnableBand: (+1)
   \   00000000   0xB920             CBNZ.N   R0,??BandLimiter__EnableBand_0
    276              {
    277                  DEBUG_INVALID_BAND_ENABLE_SELECTION(band);
    278              }
    279              else
    280              {
    281                  for(i = 0; i < BAND_SPEC_LIST[band].Num_Signals; i++)   // Loop over signals in band
    282                  {
    283                      BAND_SPEC_LIST[band].Signal_Enable[i] = TRUE;   // enable signal
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x2104             MOVS     R1,#+4
   \   00000006   0x....             LDR.N    R0,??DataTable14_8
   \   00000008   0x.... 0x....      B.W      __aeabi_memset4
    284                  }
    285              }
    286          }
   \                     ??BandLimiter__EnableBand_0: (+1)
   \   0000000C   0x4770             BX       LR               ;; return
    287          
    288          /**
    289           *  @brief      Enable filtering for all signals in all bands in module
    290           */

   \                                 In section .text, align 2, keep-with-next
    291          void BandLimiter__EnableAll(void)
    292          {
    293              BANDLIMITER_BAND_TYPE i;
    294          
    295              for(i = (BANDLIMITER_BAND_TYPE)0; i < BANDLIMITER_NUM_OF_BANDS; i++)    // Loop over bands in module
    296              {
    297                  BandLimiter__EnableBand(i);     // Enable all signals in band
   \                     BandLimiter__EnableAll: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0x2104             MOVS     R1,#+4
   \   00000004   0x....             LDR.N    R0,??DataTable14_8
   \   00000006   0x.... 0x....      B.W      __aeabi_memset4
    298              }
    299          }
    300          
    301          /**
    302           *  @brief      Disable filtering for specified signal.
    303           *
    304           *  @param      band = Band containing signal to disable.
    305           *  @param      signal = signal for which to disable filtering.
    306           */

   \                                 In section .text, align 2, keep-with-next
    307          void BandLimiter__DisableSignal(BANDLIMITER_BAND_TYPE band, BANDLIMITER_SIGNAL_TYPE signal)
    308          {
    309              uint8 i;
    310          
    311              if(band >= BANDLIMITER_NUM_OF_BANDS)    // Invalid band selection by user (not in band list)
   \                     BandLimiter__DisableSignal: (+1)
   \   00000000   0xB9A8             CBNZ.N   R0,??BandLimiter__DisableSignal_0
    312              {
    313                  DEBUG_INVALID_BAND_DISABLE_SELECTION(band);
    314              }
    315              else if(IsSignalInBand(band,signal) ==  FALSE)  // Queried signal not present in band
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xBF18             IT       NE 
   \   00000006   0x2901             CMPNE    R1,#+1
   \   00000008   0xD003             BEQ.N    ??BandLimiter__DisableSignal_1
   \   0000000A   0x2902             CMP      R1,#+2
   \   0000000C   0xBF18             IT       NE 
   \   0000000E   0x2903             CMPNE    R1,#+3
   \   00000010   0xD10D             BNE.N    ??BandLimiter__DisableSignal_0
    316              {
    317                  DEBUG_SIGNAL_TO_DISABLE_NOT_IN_BAND(signal,band);
    318              }
    319              else        // requested signal is available
    320              {
    321                  for(i = 0; i < BAND_SPEC_LIST[band].Num_Signals; i++)   // Loop over signals in band to find the requested signal
    322                  {
    323                      if(BAND_SPEC_LIST[band].Signal_List[i] == signal)
   \                     ??BandLimiter__DisableSignal_1: (+1)
   \   00000012   0xB921             CBNZ.N   R1,??BandLimiter__DisableSignal_2
    324                      {
    325                          BAND_SPEC_LIST[band].Signal_Enable[i] = FALSE;  // disable signal
   \                     ??BandLimiter__DisableSignal_3: (+1)
   \   00000014   0x....             LDR.N    R2,??DataTable14_7
   \   00000016   0x1880             ADDS     R0,R0,R2
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x7401             STRB     R1,[R0, #+16]
    326                          break;
   \   0000001C   0x4770             BX       LR
    327                      }
   \                     ??BandLimiter__DisableSignal_2: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x2901             CMP      R1,#+1
   \   00000022   0xBF1F             ITTTT    NE 
   \   00000024   0x2002             MOVNE    R0,#+2
   \   00000026   0x2902             CMPNE    R1,#+2
   \   00000028   0x2003             MOVNE    R0,#+3
   \   0000002A   0x2903             CMPNE    R1,#+3
   \   0000002C   0xD0F2             BEQ.N    ??BandLimiter__DisableSignal_3
    328                  }
    329              }
    330          }
   \                     ??BandLimiter__DisableSignal_0: (+1)
   \   0000002E   0x4770             BX       LR               ;; return
    331          
    332          /**
    333           *  @brief      Disable filtering for all signals in specified band.
    334           *
    335           *  @param      band = Band whose signals are to be disabled
    336           */

   \                                 In section .text, align 2, keep-with-next
    337          void BandLimiter__DisableBand(BANDLIMITER_BAND_TYPE band)
    338          {
    339              uint8 i;
    340          
    341              if(band >= BANDLIMITER_NUM_OF_BANDS)    // Invalid band selection by user (not in band list)
   \                     BandLimiter__DisableBand: (+1)
   \   00000000   0xB910             CBNZ.N   R0,??BandLimiter__DisableBand_0
    342              {
    343                  DEBUG_INVALID_BAND_DISABLE_SELECTION(band);
    344              }
    345              else
    346              {
    347                  for(i = 0; i < BAND_SPEC_LIST[band].Num_Signals; i++)   // Loop over signals in band
    348                  {
    349                      BAND_SPEC_LIST[band].Signal_Enable[i] = FALSE;  // disable signal
   \   00000002   0x....             LDR.N    R0,??DataTable14_8
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6001             STR      R1,[R0, #+0]
    350                  }
    351              }
    352          }
   \                     ??BandLimiter__DisableBand_0: (+1)
   \   00000008   0x4770             BX       LR               ;; return
    353          
    354          /**
    355           *  @brief      Disable filtering for all signals in all bands in module
    356           */

   \                                 In section .text, align 2, keep-with-next
    357          void BandLimiter__DisableAll(void)
    358          {
    359              BANDLIMITER_BAND_TYPE i;
    360          
    361              for(i = (BANDLIMITER_BAND_TYPE)0; i < BANDLIMITER_NUM_OF_BANDS; i++)    // Loop over bands in module
    362              {
    363                  BandLimiter__DisableBand(i);        // Disable all signals in band
   \                     BandLimiter__DisableAll: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable14_8
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x6001             STR      R1,[R0, #+0]
    364              }
    365          }
   \   00000006   0x4770             BX       LR               ;; return
    366          
    367          /**
    368           *  @brief      The bandlimiter module handler.
    369           *
    370           *  @details    Must be called at a consistent sample rate. Ideally, the sample rate should be high enough to avoid aliasing
    371           *              before applying the filter. That is, the sample rate should be high enough to capture all native frequency
    372           *              content in the input signals. For example, a signal updated at a rate of 8kHz such as the motor torque can
    373           *              have frequency content up to 4kHz. To sample this content without aliasing, a sample rate of 8kHz would be
    374           *              required. However, since the fastest slot available in vortex is 4kHz, 4kHz (250us) is the desired installation
    375           *              slot for the handler. Regardless of where the handler is installed, the filters configured for the module must be
    376           *              designed with its sample rate in mind. That is, filter coefficients assume a sample rate, and changing the
    377           *              handler time slot will change the filter characteristics.
    378           */

   \                                 In section .text, align 4, keep-with-next
    379          void BandLimiter__Handler(void)
    380          {
   \                     BandLimiter__Handler: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB081             SUB      SP,SP,#+4
    381              BANDLIMITER_BAND_TYPE i;
    382              BANDLIMITER_SIGNAL_TYPE j;
    383          
    384              IntegrateSpeed();
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0xED2D 0x8B02      VPUSH    {D8}
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       MciSensorsWm__GetAnalog
   \   00000012   0xEE00 0x0A10      VMOV     S0,R0
   \   00000016   0x.... 0x....      LDR.W    R8,??DataTable14_7
   \   0000001A   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000001E   0xEDDF 0x....      VLDR.W   S1,??DataTable14_1  ;; 0x49f00000
   \   00000022   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000026   0xED9F 0x....      VLDR.W   S16,??DataTable14_2  ;; 0x40490fdb
   \   0000002A   0xEDD8 0x0A06      VLDR     S1,[R8, #+24]
   \   0000002E   0xEE40 0x0A08      VMLA.F32 S1,S0,S16
   \   00000032   0xED9F 0x....      VLDR.W   S2,??DataTable14_3  ;; 0x3903126f
   \   00000036   0xED98 0x0A05      VLDR     S0,[R8, #+20]
   \   0000003A   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   \   0000003E   0xEDDF 0x....      VLDR.W   S1,??DataTable14_4  ;; 0x40c90fdc
   \   00000042   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000046   0xEEF1 0xFA10      FMSTAT   
   \   0000004A   0xBFA4             ITT      GE 
   \   0000004C   0xEDDF 0x....      VLDRGE.W S1,??DataTable14_5  ;; 0xc0c90fdb
   \   00000050   0xEE30 0x0A20      VADDGE.F32 S0,S0,S1
   \   00000054   0xED88 0x0A05      VSTR     S0,[R8, #+20]
   \   00000058   0x2102             MOVS     R1,#+2
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x.... 0x....      BL       MciSensorsWm__GetAnalog
   \   00000060   0xEE00 0x0A10      VMOV     S0,R0
   \   00000064   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000068   0xEDDF 0x....      VLDR.W   S1,??DataTable14_1  ;; 0x49f00000
   \   0000006C   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000070   0xEE20 0x0A08      VMUL.F32 S0,S0,S16
   \   00000074   0xED88 0x0A06      VSTR     S0,[R8, #+24]
    385          
    386              for(i = (BANDLIMITER_BAND_TYPE)0; i < BANDLIMITER_NUM_OF_BANDS; i++)
   \   00000078   0xEDDF 0x....      VLDR.W   S17,??DataTable14_6  ;; 0x37800000
    387              {
    388                  for(j = (BANDLIMITER_SIGNAL_TYPE)0; j < BAND_SPEC_LIST[i].Num_Signals; j++)
   \   0000007C   0x2500             MOVS     R5,#+0
   \   0000007E   0xF108 0x0610      ADD      R6,R8,#+16
   \   00000082   0x.... 0x....      ADR.W    R7,BAND0_SIGNAL_LIST
   \   00000086   0x4644             MOV      R4,R8
   \   00000088   0xF108 0x091C      ADD      R9,R8,#+28
    389                  {
    390                      if(BAND_SPEC_LIST[i].Signal_Enable[j] == TRUE)  // if the signal is enabled
   \                     ??BandLimiter__Handler_1: (+1)
   \   0000008C   0x7830             LDRB     R0,[R6, #+0]
   \   0000008E   0x2801             CMP      R0,#+1
   \   00000090   0xD134             BNE.N    ??BandLimiter__Handler_2
    391                      {
    392                          BAND_SPEC_LIST[i].Filtered_Signals[j] = FilterSignal(BAND_SPEC_LIST[i].Signal_List[j], BAND_SPEC_LIST[i].filter, BAND_SPEC_LIST[i].States[j]);
   \   00000092   0x.... 0x....      ADR.W    R0,BAND_SPEC_LIST
   \   00000096   0xED9F 0x....      VLDR.W   S0,??DataTable14  ;; 0x0
   \   0000009A   0xE9D0 0xAB02      LDRD     R10,R11,[R0, #+8]
   \   0000009E   0x7838             LDRB     R0,[R7, #+0]
   \   000000A0   0x2803             CMP      R0,#+3
   \   000000A2   0xD824             BHI.N    ??BandLimiter__Handler_3
   \   000000A4   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??BandLimiter__Handler_0:
   \   000000A8   0x19 0x0A          DC8      0x19,0xA,0x4,0x2
   \              0x04 0x02    
   \                     ??BandLimiter__Handler_4: (+1)
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0xE000             B.N      ??BandLimiter__Handler_5
   \                     ??BandLimiter__Handler_6: (+1)
   \   000000B0   0x2000             MOVS     R0,#+0
   \                     ??BandLimiter__Handler_5: (+1)
   \   000000B2   0xED98 0x0A05      VLDR     S0,[R8, #+20]
   \   000000B6   0x.... 0x....      BL       __iar_FSin
   \   000000BA   0xE018             B.N      ??BandLimiter__Handler_3
   \                     ??BandLimiter__Handler_7: (+1)
   \   000000BC   0x2102             MOVS     R1,#+2
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x.... 0x....      BL       MciSensorsWm__GetAnalog
   \   000000C4   0xEE00 0x0A10      VMOV     S0,R0
   \   000000C8   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000000CC   0xEDDF 0x....      VLDR.W   S1,??DataTable14_1  ;; 0x49f00000
   \   000000D0   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   000000D4   0xEE20 0x0A08      VMUL.F32 S0,S0,S16
   \   000000D8   0xE009             B.N      ??BandLimiter__Handler_3
   \                     ??BandLimiter__Handler_8: (+1)
   \   000000DA   0x210A             MOVS     R1,#+10
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x.... 0x....      BL       MciSensorsWm__GetAnalog
   \   000000E2   0xEE00 0x0A10      VMOV     S0,R0
   \   000000E6   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000000EA   0xEE20 0x0A28      VMUL.F32 S0,S0,S17
   \                     ??BandLimiter__Handler_3: (+1)
   \   000000EE   0x464A             MOV      R2,R9
   \   000000F0   0x4650             MOV      R0,R10
   \   000000F2   0x4659             MOV      R1,R11
   \   000000F4   0x.... 0x....      BL       DigitalFilter__DF2TSOS
   \   000000F8   0xED84 0x0A00      VSTR     S0,[R4, #0]
    393                      }
    394                  }
   \                     ??BandLimiter__Handler_2: (+1)
   \   000000FC   0x1C6D             ADDS     R5,R5,#+1
   \   000000FE   0x1D24             ADDS     R4,R4,#+4
   \   00000100   0x1C7F             ADDS     R7,R7,#+1
   \   00000102   0x1C76             ADDS     R6,R6,#+1
   \   00000104   0xF109 0x0908      ADD      R9,R9,#+8
   \   00000108   0x2D04             CMP      R5,#+4
   \   0000010A   0xDBBF             BLT.N    ??BandLimiter__Handler_1
    395              }
    396          }
   \   0000010C   0xECBD 0x8B02      VPOP     {D8}
   \   00000110   0xB001             ADD      SP,SP,#+4
   \   00000112   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x49F00000         DC32     0x49f00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x40490FDB         DC32     0x40490fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x3903126F         DC32     0x3903126f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x40C90FDC         DC32     0x40c90fdc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0xC0C90FDB         DC32     0xc0c90fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x37800000         DC32     0x37800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x........         DC32     Band0_Filtered_Signals

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0x........         DC32     Band0_Filtered_Signals+0x10
    397          
    398          //=====================================================================================================================
    399          //-------------------------------------- Private Functions ------------------------------------------------------------
    400          //=====================================================================================================================
    401          
    402          /**
    403           *  @brief      Filter input signal by filter
    404           *
    405           *  @param      signal = input signal to filter.
    406           *  @param      filter = digital filter to use for filtering.
    407           *
    408           *  @return     The filtered signal. Units depend on requested signal.
    409           */
    410          static float32 FilterSignal(BANDLIMITER_SIGNAL_TYPE signal, DIGITAL_FILTER_SOS_TYPE filter, BIQUAD_STATE_TYPE *states)
    411          {
    412              float32 input = 0.0f;
    413          
    414              switch(signal)
    415              {
    416                  case BANDLIMITER_SIGNAL_DRUM_TORQUE_NM:
    417                      input = INPUT_SIGNAL_DRUM_TORQUE_NM;
    418                      break;
    419                  case BANDLIMITER_SIGNAL_DRUM_SPEED_RAD_S:
    420                      input = INPUT_SIGNAL_DRUM_SPEED_RAD_S;
    421                      break;
    422                  case BANDLIMITER_SIGNAL_SIN_DRUM_ANGLE:
    423                      input = INPUT_SIGNAL_SIN_DRUM_ANGLE;
    424                      break;
    425                  case BANDLIMITER_SIGNAL_COS_DRUM_ANGLE:
    426                      input = INPUT_SIGNAL_COS_DRUM_ANGLE;
    427                      break;
    428                  default:                                            // A case is not present for the input signal; code should
    429                      DEBUG_CASE_MISSING_FOR_INPUT_SIGNAL(signal);    // never get here as there should be a case for each signal.
    430                      break;
    431              }
    432          
    433              return DigitalFilter__DF2TSOS(input, filter, states);
    434          }
    435          
    436          /**
    437           *  @brief      Check whether signal is available in chosen band
    438           *
    439           *  @param      band = band to check against
    440           *  @param      signal = signal to query
    441           *
    442           *  @return     true/false indicating whether the signal is available
    443           */
    444          static BOOL_TYPE IsSignalInBand(BANDLIMITER_BAND_TYPE band, BANDLIMITER_SIGNAL_TYPE signal)
    445          {
    446              uint8 i;
    447              BOOL_TYPE signal_in_band = FALSE;
    448          
    449              for(i = 0; i < BAND_SPEC_LIST[band].Num_Signals; i++)
    450              {
    451                  if(BAND_SPEC_LIST[band].Signal_List[i] == signal)
    452                  {
    453                      signal_in_band = TRUE;
    454                      break;
    455                  }
    456              }
    457          
    458              return signal_in_band;
    459          }
    460          
    461          /**
    462           *  @brief      Integrate the speed signal to calculate position
    463           */
    464          static void IntegrateSpeed(void)
    465          {
    466          	Rotor_Angle = Rotor_Angle + BANDLIMITER_TS*0.5f*(Previous_Omega + INPUT_SIGNAL_DRUM_SPEED_RAD_S);
    467          	if(Rotor_Angle > (2.0f*PI))
    468          	{
    469          		Rotor_Angle = Rotor_Angle - (2.0f*PI);
    470          	}
    471          	Previous_Omega = INPUT_SIGNAL_DRUM_SPEED_RAD_S;
    472          }
    473          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   BandLimiter__DisableAll
       0   BandLimiter__DisableBand
       0   BandLimiter__DisableSignal
       0   BandLimiter__EnableAll
         0   -> __aeabi_memset4
       0   BandLimiter__EnableBand
         0   -> __aeabi_memset4
       0   BandLimiter__EnableSignal
       0   BandLimiter__GetSignal
      48   BandLimiter__Handler
        48   -> DigitalFilter__DF2TSOS
        48   -> MciSensorsWm__GetAnalog
        48   -> __iar_FSin
       8   BandLimiter__Initialize
         8   -> DigitalFilter__ResetSOS
         8   -> __aeabi_memclr4
         0   -> __aeabi_memset4
       8   BandLimiter__ResetAll
         0   -> DigitalFilter__ResetSOS
         8   -> DigitalFilter__ResetSOS
       8   BandLimiter__ResetBand
         0   -> DigitalFilter__ResetSOS
         8   -> DigitalFilter__ResetSOS
       0   BandLimiter__ResetSignal
         0   -> DigitalFilter__ResetSOS


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
      20  BAND0_COEFFS
       4  BAND0_SIGNAL_LIST
      28  BAND_SPEC_LIST
      60  Band0_Filtered_Signals
          Band0_Signal_Enable
          Rotor_Angle
          Previous_Omega
          Band0_Filter_States
       8  BandLimiter__DisableAll
      10  BandLimiter__DisableBand
      48  BandLimiter__DisableSignal
      10  BandLimiter__EnableAll
      14  BandLimiter__EnableBand
      48  BandLimiter__EnableSignal
      54  BandLimiter__GetSignal
     278  BandLimiter__Handler
      90  BandLimiter__Initialize
      64  BandLimiter__ResetAll
      66  BandLimiter__ResetBand
      58  BandLimiter__ResetSignal

 
  60 bytes in section .bss
  20 bytes in section .rodata
 816 bytes in section .text
 
 816 bytes of CODE  memory
  20 bytes of CONST memory
  60 bytes of DATA  memory

Errors: none
Warnings: none
