###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        19/Nov/2024  13:15:42
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  XCategory\Common\SettingFile\SettingFile.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        SettingFile.obj -l ..\listings\SettingFile.lst
#        XCategory\Common\SettingFile\SettingFile.c
#    List file    =  ..\listings\SettingFile.lst
#    Object file  =  SettingFile.obj
#
###############################################################################

C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Common\SettingFile\SettingFile.c
      1          /**
      2           *  @file
      3           *
      4           *  @brief      This module acts as an interface to the Setting File data and also provides some basic information
      5           *              about the setting file and setting file sections. It is written to meet Class B requirements due to
      6           *              the need to locate Class B parameters in the setting file.
      7           *
      8           *  @details    This module has the following responsibilities:
      9           *              - Iterates through all the sections of the setting file and determines if the proper setting file sections
     10           *                are found and validates the checksum of each section.
     11           *              - Provides "hard coded" setting file feature for the ACU and/or HMI sections as an alternative to
     12           *                storing setting file data on the main ACU. This feature only applies to an expansion board
     13           *                that requires one setting file section from the main ACU as well as some setting file data that cannot be modified.expansion boards. The binary
     14           *                output for the "hard coded" setting file(s) shall be merged with the firmware during the build process.
     15           *              - Determines the validity of the overall setting file. The setting file is not valid if: If at least one
     16           *                checksum validation fails, or if the ACU or HMI section is not found for an ACU, or if the HMI section
     17           *                is found for an HMI.
     18           *              - Provides an interface to load data from the setting file based on a pointer and a displacement.
     19           *              - Provides an interface to basic setting file information: CRC of each setting file section, size of each
     20           *                setting file section, size of entire setting file, start address of each setting file section and start
     21           *                address of the entire setting file.
     22           *
     23           *  @defgroup   CLASS_B
     24           *
     25              @startuml{SettingFile_ClassDiagram.png}
     26          
     27                  class "SettingFile" as core {
     28                      +SETTINGFILE_OFFSET_TYPE
     29                      +SETTINGFILE_CROSS_PRODUCT_DISPLACEMENT_TYPE
     30                      +void SettingFile__Initialize(void);
     31                      +BOOL_TYPE SettingFile__IsPlatformPointerUsed(uint8 sf_index, SETTINGFILE_OFFSET_TYPE platform_pointer);
     32                      +BOOL_TYPE SettingFile__IsValid(void);
     33                      +void SettingFile__CheckDataIntegrity(void);
     34                      +uint8 SettingFile__GetNumExtraSF(void);
     35                      +PASS_FAIL_TYPE SettingFile__BasicLoader(SETTINGFILE_OFFSET_TYPE pointer_id, uint16 displacement, SETTINGFILE_LOADER_TYPE * pointer_data_out);
     36                      +PASS_FAIL_TYPE SettingFile__MSettingBasicLoader( uint8 sf_index,  SETTINGFILE_OFFSET_TYPE  pointer_id, uint16 displacement,  SETTINGFILE_LOADER_TYPE * data_pointer);
     37                      +uint16 SettingFile__GetNumDisplacements(uint8 sf_index, SETTINGFILE_OFFSET_TYPE pointer_id);
     38                      +BOOL_TYPE SettingFile__IsExtendedDisplacement(uint8 sf_index,SETTINGFILE_OFFSET_TYPE pointer_id);
     39                      +uint16 SettingFile__GetSettingFileCRC(SF_ID_TYPE sf_id);
     40                      +void * SettingFile__GetSettingFileStart(SF_ID_TYPE sf_id);
     41                      +uint8 SettingFile__GetSectionIDs(SF_ID_TYPE* section_ids);
     42                      +uint32 SettingFile__GetSettingFileSize(SF_ID_TYPE sf_id);
     43                      +void * SettingFile__GetMemorySectionStart(void);
     44                      +uint32 SettingFile__GetMemorySectionSize(void);
     45                      +void * SettingFile__GetSettingFilePointerByIndex(SF_ID_TYPE sf_id,uint32 index);
     46                      +uint16 SettingFile__CalculateCRC(SF_ID_TYPE sf_id);
     47                      }
     48          
     49                 class "SettingFile_defs.h" as defs  <<interface>>{
     50                      +SETTINGFILE_CROSS_CATEGORY_SF_PTR
     51                 }
     52          
     53                 class "SettingFile_prm.h" as cat_dynamic  <<interface>>{
     54                      +SETTINGFILE_APPLICATION_SPECIFIC_SF_PTR
     55                 }
     56          
     57                 class "SettingFile_SRCat.h" as srcat_dynamic   <<interface>>{
     58                      +SETTINGFILE_APPLICATION_SPECIFIC_SR_SF_PTR
     59                 }
     60          	   
     61                 core ..> defs
     62                 core ..> cat_dynamic
     63                 core ..> srcat_dynamic
     64          
     65              @enduml
     66           *  @copyright  Copyright 2015-2017 Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     67           */
     68          //---------------------------------------------------------------------------------------------------------------------
     69          //---------------------------------------------------------------------------------------------------------------------
     70          
     71          //-------------------------------------- Include Files ----------------------------------------------------------------
     72          #include "SRSystemConfig.h"
     73          #include "SystemConfig.h"
     74          #include "SettingFile.h"

  PACKED typedef struct
         ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Common\SettingFile\SettingFile.h",39  Remark[Pe082]: 
          storage class is not first
     75          #include "SettingFile_prv.h"
     76          
     77          #include "Crc16.h"
     78          #include "Log.h"
     79          #include "SRData.h"
     80          #if (SYSTEM_ENABLE_TASKSEQUENCE == ENABLED)
     81              #include "SRTaskSequence.h"
     82          #endif
     83          #include <string.h>
     84          
     85          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     86          
     87          #ifndef SF_START_ADDRESS
     88              //! Linker symbol that must be defined in config.icf The value of the variable should contain the starting address of the setting file.
     89              extern uint16 __SetingFile_Start;
     90          
     91              /**
     92               *  @brief      Start address of the memory that contains the setting file data.
     93               *
     94               *  @details    There are 2 use cases for this macro.
     95               *              1. Typical usage of this macro: Get the setting file address from the linker symbol (__SetingFile_Start)
     96               *              defined in the config.icf file. This will require an extern statement before this macro.
     97               *              (Example: extern uint16 __SetingFile_Start; )
     98               *              2. A GUI project can utilize this macro to look up the address of the setting file data, as the address
     99               *              will change every time the system boots.
    100               */
    101              #define SF_START_ADDRESS   (&__SetingFile_Start)
    102          #endif
    103          
    104          #ifndef SF_SIZE
    105              //! Linker symbol that must be define in config.icf. The value of the variable should contain the maximum size of the setting file.
    106              extern uint32 __SetingFile_Size;
    107          
    108              /**
    109               *  @brief      Size of the memory section that contains the setting file data.
    110               *
    111               *  @details    There are 2 use cases for this macro.
    112               *              1. Typical usage of this macro: Get the setting file size from the linker symbol (__SetingFile_Size)
    113               *              defined in the config.icf file. This will require an extern statement before this macro.
    114               *              (Example: extern uint32 __SetingFile_Size; )
    115               *              2. A GUI project can utilize this macro to return the value of a constant that defines the setting file size.
    116               */
    117              #define SF_SIZE  (&__SetingFile_Size)
    118          #endif
    119          
    120          #ifdef ENDIANU16_STON
    121              // If the setting file endianess conversion macro is defined, then it must be defined for little endian data.
    122              CT_ASSERT(ENDIANU16_STON(0xABCD) == 0xABCD);
    123          #endif
    124          
    125          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
    126          
    127          //-------------------------------------- IDs FOR LOG messages----------------------------------------------------------
    128          //! A list of log message IDs that are generated by this module.
    129          typedef enum MODULE_SETTINGFILE_LOG_MESSAGE_ID_STRUCT
    130          {
    131              UNHANDLED_SECTION_ENDIANNESS,                   // Data: Section ID detected with big endianess.
    132              UNHANDLED_HARDCODED_ENDIANNESS                  // Data: Section ID detected with big endianess.
    133          } MODULE_SETTINGFILE_LOG_MESSAGE_ID_TYPE;
    134          
    135          //! The name of this module for use by the Log module.
    136          #define MODULE_NAME     MODULE_SETTINGFILE
    137          //------------------------------------------
    138          
    139          typedef enum SETTINGFILE_BSLDR_RETURN_ENUM
    140          {
    141              SETTINGFILE_BSLDR_OK                    =   0x00,   //BSLDR_OK                    0x00
    142              SETTINGFILE_BSLDR_INVALID_LENGTH        =   0x02,   //BSLDR_WRN_LENGHT            0x02
    143              SETTINGFILE_BSLDR_ERR_INVALID_DISPL     =   0x82,   //BSLDR_ERR_INVALID_DISPL     0x82
    144          } SETTINGFILE_BSLDR_RETURN_TYPE;
    145          
    146          // Defines the address of a hard coded ACU setting file (if used); Symbol should be defined in makefile.dat
    147          #if (USE_ACU_HARDCODED_SETTING_FILE == ENABLED)
    148              extern uint16 __ACU_Hardcoded_SettingFile_Start;
    149          #endif
    150          
    151          // Defines the address of a hard coded HMI setting file (if used); Symbol should be defined in makefile.dat
    152          #if (USE_HMI_HARDCODED_SETTING_FILE == ENABLED)
    153              extern uint16 __HMI_Hardcoded_SettingFile_Start;
    154          #endif
    155          
    156          #define SETTINGFILE_NULL_VALUE              0x0000
    157          #define SETTINGFILE_MASK_SECTION_ID_TYPE    0x0F
    158          #define SETTINGFILE_INITIAL_CRC             0xFFFF      // Initial value of the CRC to use during the calculation of the CRC
    159          
    160          //! A structure to describe the header of each setting file section.
    161          typedef PACKED struct SF_SECTION_HEADER_STRUCT
    162          {
    163              BOOL_TYPE Endianess : 1;                        //!< 0 = Big endian, 1 = Little endian.
    164              uint8 Unused : 7;
    165              SF_ID_TYPE Section_ID;
    166          } SF_SECTION_HEADER_TYPE;
    167          
    168          //! Validity of the setting file (FALSE if there is something wrong with the setting file, else TRUE)

   \                                 In section .bss, align 4
    169          static BOOL_TYPE Is_Settingfile_Valid;
   \                     Is_Settingfile_Valid:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 2
   \   00000004                      DS8 4
   \   00000008                      DS8 1
   \   00000009                      DS8 1
    170          //! Inverted memory for the Class B variables used by this module.
    171          static BOOL_TYPE N_Is_Settingfile_Valid;
    172          
    173          //! Tracks the current setting file section whose content is being verified
    174          static uint8 Settingfile_Section_Position;
    175          //! Inverted memory for the Class B variable
    176          static uint8 N_Settingfile_Section_Position;
    177          
    178          //! Tracks the calculated CRC for the current setting file section whose content is being verified
    179          static uint16 Settingfile_Flash_Crc;
    180          
    181          //! Points to the current setting file data used during the validation of the CRC for a setting file section
    182          static uint32 * Settingfile_Flash_Crc_Ptr;
    183          
    184          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
    185          static uint16 CalculateSectionCRC(uint16 * section_start_address);
    186          static uint16 * GetSettingFileStartByID(SF_ID_TYPE sf_id);
    187          static uint16 * GetSettingFileStartByPosition(uint8 sf_position);
    188          static uint16 * ExtractAbsPointer(uint16 * data_struct_start_ptr , SETTINGFILE_OFFSET_TYPE pointer_id);
    189          static SETTINGFILE_BSLDR_RETURN_TYPE GetDisplacementData(uint16 * data_start_address, uint16 displacement, SETTINGFILE_LOADER_TYPE * data_out_ptr);
    190          #if ((USE_ACU_HARDCODED_SETTING_FILE == ENABLED) || (USE_HMI_HARDCODED_SETTING_FILE == ENABLED))
    191              static BOOL_TYPE IsHardCodedSettingFileValid(SF_ID_TYPE sf_id);
    192          #endif
    193          
    194          //=====================================================================================================================
    195          //-------------------------------------- Public Functions -------------------------------------------------------------
    196          //=====================================================================================================================
    197          
    198          //---------------------------------------------------------------------------------------------------------------------
    199          /**
    200           *  @brief      It Initializes the module SettingFile and its variables.
    201           *
    202           *  @details    - Iterates through all the sections of the setting file, where the start address is defined by
    203           *                the SF_START_ADDRESS macro.
    204           *              - For each section, assigns a position in a local buffer so it can be referenced later.
    205           *              - For each section, validates the checksum of each section in the setting file.
    206           *              - For each section, validates the endianness compared to the endianness expected by the firmware
    207           *              - If no setting file is found, this function will also search in alternative memory locations for a
    208           *                "hard coded" setting file (one for ACU and one for HMI).
    209           *              - Determines the validity of the setting file. The setting file is not valid if:
    210           *                      - If at least one checksum validation fails, OR
    211           *                      - If the ACU or HMI section is not found for an ACU, OR
    212           *                      - If the HMI section is found for an HMI OR
    213           *                      - The endianness of at least one of the sections does not match the endianness expected by the
    214           *                          firmware
    215           */

   \                                 In section .text, align 4, keep-with-next
    216          void SettingFile__Initialize(void)
    217          {
   \                     SettingFile__Initialize: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
    218              // The 'has_type' variable contains a bit for each possible section type.
    219              // If the bit is set, then at least one valid section of that type was found.
    220              // Bit 0 for ACU sections, Bit 1 for HMI sections, Bit 2 for MCU sections, etc.
    221              uint16 has_type = 0;
    222          
    223              // Start with assumption that setting file is invalid
    224              uint8 is_settingfile_valid = FALSE;
    225          
    226              // Go sequentially through all the setting file sections.
    227              uint16* pt16 = SF_START_ADDRESS;
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable12
   \   00000008   0xB081             SUB      SP,SP,#+4
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x4625             MOV      R5,R4
    228              uint8 section_count = 0;
    229              for (uint8 sf_position = 0; sf_position < SF_MAX_SECTIONS; sf_position++)
   \   0000000E   0x260A             MOVS     R6,#+10
   \   00000010   0xF64F 0x77FF      MOVW     R7,#+65535
    230              {
    231                  SF_ID_TYPE sf_id = ((SF_SECTION_HEADER_TYPE*)(void*)pt16)->Section_ID;
    232                  if (sf_id == SF_ID_END)
   \                     ??SettingFile__Initialize_0: (+1)
   \   00000014   0x7868             LDRB     R0,[R5, #+1]
   \   00000016   0x28FF             CMP      R0,#+255
   \   00000018   0xD027             BEQ.N    ??SettingFile__Initialize_1
    233                  {
    234                      // Reached the end of the setting file (no more sections).
    235                      break;                                  // Break out of the for() loop.
    236                  }
    237                  else if (((SF_SECTION_HEADER_TYPE*)(void*)pt16)->Endianess == 0)
   \   0000001A   0xF815 0x0B02      LDRB     R0,[R5], #+2
   \   0000001E   0x07C0             LSLS     R0,R0,#+31
   \   00000020   0xD522             BPL.N    ??SettingFile__Initialize_2
    238                  {
    239                      // The section endianess is incorrect. Treat the whole setting file as invalid.
    240                      is_settingfile_valid = FALSE;
    241                      LOG_ADD_EXCEPTION(UNHANDLED_SECTION_ENDIANNESS, sf_id);
    242                      break;                                  // Break out of the for() loop.
    243                  }
    244                  else
    245                  {
    246                      pt16++;                                 // Point to the start of the section data.
    247                      uint16 calculated_crc = CalculateSectionCRC(pt16);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xBF1C             ITT      NE 
   \   00000028   0x8869             LDRHNE   R1,[R5, #+2]
   \   0000002A   0x42B9             CMPNE    R1,R7
   \   0000002C   0xD010             BEQ.N    ??SettingFile__Initialize_3
   \   0000002E   0x2900             CMP      R1,#+0
   \   00000030   0xBF18             IT       NE 
   \   00000032   0xEB15 0x0841      ADDSNE   R8,R5,R1, LSL #+1
   \   00000036   0xD00B             BEQ.N    ??SettingFile__Initialize_3
   \   00000038   0xF1A5 0x0902      SUB      R9,R5,#+2
   \   0000003C   0x4638             MOV      R0,R7
   \   0000003E   0x45C1             CMP      R9,R8
   \   00000040   0xF080 0x8006      BCS.W    ??SettingFile__Initialize_3
   \                     ??SettingFile__Initialize_4: (+1)
   \   00000044   0xF819 0x1B01      LDRB     R1,[R9], #+1
   \   00000048   0x.... 0x....      BL       Crc16__ByteProcess
   \   0000004C   0x45C1             CMP      R9,R8
   \   0000004E   0xD3F9             BCC.N    ??SettingFile__Initialize_4
    248                      uint16 stored_crc = pt16[pt16[SF_PTR_ACU_CRC]];
    249                      section_count++;
    250                      if (stored_crc == calculated_crc)       // Verify the integrity of the setting file section by comparing the CRC
   \                     ??SettingFile__Initialize_3: (+1)
   \   00000050   0x8869             LDRH     R1,[R5, #+2]
   \   00000052   0xF835 0x1011      LDRH     R1,[R5, R1, LSL #+1]
   \   00000056   0x4281             CMP      R1,R0
   \   00000058   0xD106             BNE.N    ??SettingFile__Initialize_2
    251                      {
    252                          uint8 sf_type = (sf_id & SETTINGFILE_MASK_SECTION_ID_TYPE);
    253                          BIT_SET(has_type, sf_type);
    254                          is_settingfile_valid = TRUE;        // So far, all sections are good.
    255                      }
    256                      else
    257                      {
    258                          is_settingfile_valid = FALSE;       // This section is corrupt. Treat the whole setting file as corrupt.
    259                          break;                              // Break out of the for() loop.
    260                      }
    261          
    262                      // Point to the next section of the setting file.
    263                      pt16 = &pt16[pt16[SF_PTR_ACU_END_OF_SECTION]];
   \   0000005A   0x8828             LDRH     R0,[R5, #+0]
   \   0000005C   0x2201             MOVS     R2,#+1
   \   0000005E   0xEB05 0x0540      ADD      R5,R5,R0, LSL #+1
   \   00000062   0x1E76             SUBS     R6,R6,#+1
   \   00000064   0xD001             BEQ.N    ??SettingFile__Initialize_1
   \   00000066   0xE7D5             B.N      ??SettingFile__Initialize_0
   \                     ??SettingFile__Initialize_2: (+1)
   \   00000068   0x2200             MOVS     R2,#+0
    264                  }
    265              }
    266          
    267              // Look for hard-coded setting files.
    268              if (is_settingfile_valid == TRUE)
    269              {
    270                  #if (USE_ACU_HARDCODED_SETTING_FILE == ENABLED)
    271                      if ((IsHardCodedSettingFileValid(SF_ID_ACU) == FALSE) ||
    272                          (BIT_TEST(has_type, SF_ID_ACU) == TRUE))
    273                      {
    274                          is_settingfile_valid = FALSE;
    275                      }
    276                  #endif
    277                  #if (USE_HMI_HARDCODED_SETTING_FILE == ENABLED)
    278                      if ((IsHardCodedSettingFileValid(SF_ID_HMI) == FALSE) ||
    279                          (BIT_TEST(has_type, SF_ID_HMI) == TRUE))
    280                      {
    281                          is_settingfile_valid = FALSE;
    282                      }
    283                  #endif
    284              }
    285              else if (section_count == 0)
    286              {
    287                  #if ((USE_ACU_HARDCODED_SETTING_FILE == ENABLED) && (USE_HMI_HARDCODED_SETTING_FILE == ENABLED))
    288                      is_settingfile_valid = (BOOL_TYPE)(IsHardCodedSettingFileValid(SF_ID_ACU) &&
    289                                                         IsHardCodedSettingFileValid(SF_ID_HMI));
    290                  #elif (USE_ACU_HARDCODED_SETTING_FILE == ENABLED)
    291                      is_settingfile_valid = IsHardCodedSettingFileValid(SF_ID_ACU);
    292                  #elif (USE_HMI_HARDCODED_SETTING_FILE == ENABLED)
    293                      is_settingfile_valid = IsHardCodedSettingFileValid(SF_ID_HMI)
    294                  #endif
    295              }
    296          
    297              // Set module variable for validity of the setting file
    298              SRData__UpdateByte((uint8 *)(void *)&Is_Settingfile_Valid, (uint8 *)(void *)&N_Is_Settingfile_Valid, is_settingfile_valid);
   \                     ??SettingFile__Initialize_1: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R5,??DataTable12_1
   \   0000006E   0xF105 0x0108      ADD      R1,R5,#+8
   \   00000072   0x4628             MOV      R0,R5
   \   00000074   0x.... 0x....      BL       SRData__UpdateByte
    299          
    300              // Initialize module variable for setting file position to start with the section at the first position
    301              SRData__UpdateByte(&Settingfile_Section_Position, &N_Settingfile_Section_Position, 0);
   \   00000078   0x2200             MOVS     R2,#+0
   \   0000007A   0xF105 0x0109      ADD      R1,R5,#+9
   \   0000007E   0x1C68             ADDS     R0,R5,#+1
   \   00000080   0x.... 0x....      BL       SRData__UpdateByte
    302          
    303              // Set initial value of the CRC for the setting file section CRC calculation
    304              Settingfile_Flash_Crc = SETTINGFILE_INITIAL_CRC;
   \   00000084   0x806F             STRH     R7,[R5, #+2]
    305          
    306              // Set pointer used during CRC calculation to the first setting file section
    307              Settingfile_Flash_Crc_Ptr = (uint32 *)(void *)SF_START_ADDRESS;
   \   00000086   0x606C             STR      R4,[R5, #+4]
    308          
    309              #if (SYSTEM_ENABLE_TASKSEQUENCE == ENABLED)
    310                  SRTaskSequence__SetSequenceStep(SRTASKSEQUENCE_INIT_PHASE, SRTASKSEQUENCE_INIT_SETTINGFILE);
    311              #endif
    312          }
   \   00000088   0xB001             ADD      SP,SP,#+4
   \   0000008A   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    313          
    314          //---------------------------------------------------------------------------------------------------------------------
    315          /**
    316           * @brief   Validates the integrity of the setting file data by calculating a CRC on each section of the setting file
    317           *          and comparing it to the CRC stored in the setting file data.
    318           *
    319           * @details Each time this function is called, a different section is checked. It starts with the first section. The next
    320           *          time the function is called, it will check the next section. After the last section is reached, the process
    321           *          repeats again starting with the first section.
    322           *          If there is a CRC mismatch, the function sets a variable that will allow external modules to know that the
    323           *          setting file is no longer valid. If a section is invalid, safe behavior shall be implemented outside
    324           *          of this function.
    325           */

   \                                 In section .text, align 2, keep-with-next
    326          void SettingFile__CheckDataIntegrity(void)
    327          {
   \                     SettingFile__CheckDataIntegrity: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    328              // Validate protected variable
    329              if (SR_CHECK_BYTE(Settingfile_Section_Position) == SRDATA_OK)
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable12_1
   \   00000008   0xF104 0x0109      ADD      R1,R4,#+9
   \   0000000C   0x1C60             ADDS     R0,R4,#+1
   \   0000000E   0x.... 0x....      BL       SRData__CheckByte
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD14B             BNE.N    ??SettingFile__CheckDataIntegrity_0
    330              {
    331                  uint8 current_settingfile_position = Settingfile_Section_Position;
   \   00000016   0x7865             LDRB     R5,[R4, #+1]
    332                  uint16 * section_ptr16 = GetSettingFileStartByPosition(current_settingfile_position);           // Point to the start of the section data
   \   00000018   0x.... 0x....      LDR.W    R6,??DataTable12
   \   0000001C   0x4630             MOV      R0,R6
   \   0000001E   0x2100             MOVS     R1,#+0
   \                     ??SettingFile__CheckDataIntegrity_1: (+1)
   \   00000020   0x7842             LDRB     R2,[R0, #+1]
   \   00000022   0x2AFF             CMP      R2,#+255
   \   00000024   0xD101             BNE.N    ??SettingFile__CheckDataIntegrity_2
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE009             B.N      ??SettingFile__CheckDataIntegrity_3
   \                     ??SettingFile__CheckDataIntegrity_2: (+1)
   \   0000002A   0x42A9             CMP      R1,R5
   \   0000002C   0xD007             BEQ.N    ??SettingFile__CheckDataIntegrity_3
   \   0000002E   0xF830 0x2F02      LDRH     R2,[R0, #+2]!
   \   00000032   0x1C49             ADDS     R1,R1,#+1
   \   00000034   0xB2C9             UXTB     R1,R1
   \   00000036   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \   0000003A   0x290A             CMP      R1,#+10
   \   0000003C   0xDBF0             BLT.N    ??SettingFile__CheckDataIntegrity_1
   \                     ??SettingFile__CheckDataIntegrity_3: (+1)
   \   0000003E   0x1C87             ADDS     R7,R0,#+2
    333                  uint16 * data_crc_address = ExtractAbsPointer(section_ptr16, SF_PTR_ACU_CRC);
   \   00000040   0xBF1E             ITTT     NE 
   \   00000042   0x8878             LDRHNE   R0,[R7, #+2]
   \   00000044   0xF64F 0x78FF      MOVWNE   R8,#+65535
   \   00000048   0x4540             CMPNE    R0,R8
   \   0000004A   0xD030             BEQ.N    ??SettingFile__CheckDataIntegrity_0
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xBF18             IT       NE 
   \   00000050   0xEB17 0x0140      ADDSNE   R1,R7,R0, LSL #+1
   \   00000054   0xD02B             BEQ.N    ??SettingFile__CheckDataIntegrity_0
    334          
    335                  // Validate pointers and protected variables before continuing
    336                  if ((section_ptr16 != NULL) &&
    337                      (data_crc_address != NULL))
    338                  {
    339                      uint16 remaining_bytes = (uint8 *)(void *)data_crc_address - (uint8 *)(void *)Settingfile_Flash_Crc_Ptr;
   \   00000056   0x6860             LDR      R0,[R4, #+4]
   \   00000058   0x1A0A             SUBS     R2,R1,R0
    340          
    341                      if (remaining_bytes <= sizeof(uint32))                                                       // If at the end of the section
   \   0000005A   0x8861             LDRH     R1,[R4, #+2]
   \   0000005C   0xB292             UXTH     R2,R2
   \   0000005E   0x2A05             CMP      R2,#+5
   \   00000060   0xD21C             BCS.N    ??SettingFile__CheckDataIntegrity_4
    342                      {
    343                          // Update the CRC of the setting file section based on the remaining byte(s)
    344                          Settingfile_Flash_Crc = Crc16__RangeProcess((uint8 *)(void *)Settingfile_Flash_Crc_Ptr, Settingfile_Flash_Crc, remaining_bytes);
   \   00000062   0x.... 0x....      BL       Crc16__RangeProcess
   \   00000066   0x8060             STRH     R0,[R4, #+2]
    345          
    346                          // Compare the CRC value stored in the section of the setting file to the calculated CRC
    347                          if (section_ptr16[section_ptr16[SF_PTR_ACU_CRC]] !=  Settingfile_Flash_Crc)             // If CRCs do not match, setting file is invalid
   \   00000068   0x8879             LDRH     R1,[R7, #+2]
   \   0000006A   0xF837 0x1011      LDRH     R1,[R7, R1, LSL #+1]
   \   0000006E   0x4281             CMP      R1,R0
   \   00000070   0xD11D             BNE.N    ??SettingFile__CheckDataIntegrity_0
   \   00000072   0x8839             LDRH     R1,[R7, #+0]
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x4541             CMP      R1,R8
   \   00000078   0xBF1C             ITT      NE 
   \   0000007A   0x2900             CMPNE    R1,#+0
   \   0000007C   0xEB07 0x0041      ADDNE    R0,R7,R1, LSL #+1
    348                          {
    349                              // Indicate that the setting file is invalid
    350                              SRData__UpdateByte((uint8 *)(void *)&Is_Settingfile_Valid, (uint8 *)(void *)&N_Is_Settingfile_Valid, FALSE);
    351                          }
    352                          else                                                                                    // If CRCs match, check another section
    353                          {
    354                              uint16 * end_of_section_ptr = ExtractAbsPointer(section_ptr16, SF_PTR_ACU_END_OF_SECTION);
    355                              SF_ID_TYPE section_id = ((SF_SECTION_HEADER_TYPE*)(void*)end_of_section_ptr)->Section_ID;
    356                              if (section_id == SF_ID_END)                                                        // If last section was validated, reset position so the first section is checked on the next iteration
   \   00000080   0x7841             LDRB     R1,[R0, #+1]
   \   00000082   0x29FF             CMP      R1,#+255
   \   00000084   0xBF0E             ITEE     EQ 
    357                              {
    358                                  current_settingfile_position = 0;
   \   00000086   0x2500             MOVEQ    R5,#+0
    359                                  Settingfile_Flash_Crc_Ptr = (uint32 *)(void *)SF_START_ADDRESS;                 // Set pointer used during CRC calculation to the first setting file section
    360                              }
    361                              else                                                                                // If not at the last section, increment position so it is checked on the next iteration
    362                              {
    363                                  current_settingfile_position++;
   \   00000088   0x1C6D             ADDNE    R5,R5,#+1
    364                                  Settingfile_Flash_Crc_Ptr = (uint32 *)(void *)(end_of_section_ptr);             // Adjust pointer to skip over the word that contains the endianness and section ID (not included in CRC)
   \   0000008A   0x4606             MOVNE    R6,R0
    365                              }
   \   0000008C   0x6066             STR      R6,[R4, #+4]
    366          
    367                              // Set initial value of the CRC for the setting file section CRC calculation
    368                              Settingfile_Flash_Crc = SETTINGFILE_INITIAL_CRC;
   \   0000008E   0xF8A4 0x8002      STRH     R8,[R4, #+2]
    369          
    370                              // Update setting file position to check next section
    371                              SRData__UpdateByte(&Settingfile_Section_Position, &N_Settingfile_Section_Position, current_settingfile_position);
   \   00000092   0xB2EA             UXTB     R2,R5
   \   00000094   0xF104 0x0109      ADD      R1,R4,#+9
   \   00000098   0x1C60             ADDS     R0,R4,#+1
   \   0000009A   0xE00C             B.N      ??SettingFile__CheckDataIntegrity_5
    372                          }
    373                      }
    374                      else    // Not at the end of the section yet
    375                      {
    376                          // Update the CRC of the setting file section based on the next bytes
    377                          Settingfile_Flash_Crc = Crc16__RangeProcess((uint8 *)(void *)Settingfile_Flash_Crc_Ptr, Settingfile_Flash_Crc, sizeof(uint32));
   \                     ??SettingFile__CheckDataIntegrity_4: (+1)
   \   0000009C   0x2204             MOVS     R2,#+4
   \   0000009E   0x.... 0x....      BL       Crc16__RangeProcess
   \   000000A2   0x8060             STRH     R0,[R4, #+2]
    378                          Settingfile_Flash_Crc_Ptr++;
   \   000000A4   0x6860             LDR      R0,[R4, #+4]
   \   000000A6   0x1D00             ADDS     R0,R0,#+4
   \   000000A8   0x6060             STR      R0,[R4, #+4]
    379                      }
    380                  }   // else, data_crc_address == NULL || section_ptr16 == NULL
    381                  else
    382                  {
    383                      // Indicate that the setting file is invalid
    384                      SRData__UpdateByte((uint8 *)(void *)&Is_Settingfile_Valid, (uint8 *)(void *)&N_Is_Settingfile_Valid, FALSE);
    385                  }
    386              }   // else, corrupted variable
    387              else
    388              {
    389                  // Indicate that the setting file is invalid
    390                  SRData__UpdateByte((uint8 *)(void *)&Is_Settingfile_Valid, (uint8 *)(void *)&N_Is_Settingfile_Valid, FALSE);
    391              }
    392          
    393              #if (SYSTEM_ENABLE_TASKSEQUENCE == ENABLED)
    394                  SRTaskSequence__SetSequenceStep(SRTASKSEQUENCE_APPL_SAFETY_THREAD, SRTASKSEQUENCE_APPL_SETTINGFILE_EXECUTED);
    395              #endif
    396          }
   \   000000AA   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??SettingFile__CheckDataIntegrity_0: (+1)
   \   000000AE   0x2200             MOVS     R2,#+0
   \   000000B0   0xF104 0x0108      ADD      R1,R4,#+8
   \   000000B4   0x4620             MOV      R0,R4
   \                     ??SettingFile__CheckDataIntegrity_5: (+1)
   \   000000B6   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   000000BA   0x.... 0x....      B.W      SRData__UpdateByte
    397          
    398          //---------------------------------------------------------------------------------------------------------------------
    399          /**
    400           * @brief   Test platform_pointer to check if it is used (not equal to 0xFFFF).
    401           *
    402           * @param   sf_index: Not used, kept from previous idea of mSetting Files (may be removed in future)
    403           * @param   pointer_id: The pointer that specifies which section of the setting file to check.
    404           *
    405           * @return  TRUE if the platform pointer is used, else FALSE
    406           */

   \                                 In section .text, align 4, keep-with-next
    407          BOOL_TYPE SettingFile__IsPlatformPointerUsed(uint8 sf_index, SETTINGFILE_OFFSET_TYPE pointer_id)
                                                                    ^
Remark[Pe826]: parameter "sf_index" was never referenced
    408          {
   \                     SettingFile__IsPlatformPointerUsed: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    409              uint16 * data_start_address;
    410          
    411              data_start_address = GetSettingFileStartByID((SF_ID_TYPE)(pointer_id >> 8));      // Extract upper 8 bits as the setting file id (ACU = 0, HMI = 1)
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable12
   \   00000006   0x7865             LDRB     R5,[R4, #+1]
   \   00000008   0x0A08             LSRS     R0,R1,#+8
   \   0000000A   0xF000 0x020F      AND      R2,R0,#0xF
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x1CA4             ADDS     R4,R4,#+2
   \   00000012   0x260A             MOVS     R6,#+10
   \                     ??SettingFile__IsPlatformPointerUsed_0: (+1)
   \   00000014   0xF005 0x070F      AND      R7,R5,#0xF
   \   00000018   0x4285             CMP      R5,R0
   \   0000001A   0xD00E             BEQ.N    ??SettingFile__IsPlatformPointerUsed_1
   \   0000001C   0x2B00             CMP      R3,#+0
   \   0000001E   0xBF02             ITTT     EQ 
   \   00000020   0x4696             MOVEQ    LR,R2
   \   00000022   0x4577             CMPEQ    R7,LR
   \   00000024   0x4623             MOVEQ    R3,R4
   \   00000026   0xD001             BEQ.N    ??SettingFile__IsPlatformPointerUsed_2
   \   00000028   0x2DFF             CMP      R5,#+255
   \   0000002A   0xD007             BEQ.N    ??SettingFile__IsPlatformPointerUsed_3
   \                     ??SettingFile__IsPlatformPointerUsed_2: (+1)
   \   0000002C   0x8825             LDRH     R5,[R4, #+0]
   \   0000002E   0xEB04 0x0445      ADD      R4,R4,R5, LSL #+1
   \   00000032   0x7865             LDRB     R5,[R4, #+1]
   \   00000034   0x1CA4             ADDS     R4,R4,#+2
   \   00000036   0x1E76             SUBS     R6,R6,#+1
   \   00000038   0xD1EC             BNE.N    ??SettingFile__IsPlatformPointerUsed_0
   \                     ??SettingFile__IsPlatformPointerUsed_1: (+1)
   \   0000003A   0xB924             CBNZ.N   R4,??SettingFile__IsPlatformPointerUsed_4
   \                     ??SettingFile__IsPlatformPointerUsed_3: (+1)
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xBF18             IT       NE 
   \   00000040   0x2801             CMPNE    R0,#+1
   \   00000042   0xD111             BNE.N    ??SettingFile__IsPlatformPointerUsed_5
   \   00000044   0x461C             MOV      R4,R3
    412              data_start_address = ExtractAbsPointer(data_start_address, pointer_id);
   \                     ??SettingFile__IsPlatformPointerUsed_4: (+1)
   \   00000046   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000004A   0x4281             CMP      R1,R0
   \   0000004C   0xBF18             IT       NE 
   \   0000004E   0x2C00             CMPNE    R4,#+0
   \   00000050   0xD00A             BEQ.N    ??SettingFile__IsPlatformPointerUsed_5
   \   00000052   0xB2C9             UXTB     R1,R1
   \   00000054   0xF834 0x1011      LDRH     R1,[R4, R1, LSL #+1]
   \   00000058   0x4281             CMP      R1,R0
   \   0000005A   0xBF1C             ITT      NE 
   \   0000005C   0x2900             CMPNE    R1,#+0
    413          
    414              if (data_start_address != NULL)
   \   0000005E   0xEB14 0x0041      ADDSNE   R0,R4,R1, LSL #+1
   \   00000062   0xD001             BEQ.N    ??SettingFile__IsPlatformPointerUsed_5
    415              {
    416                  return(TRUE);
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xBDF0             POP      {R4-R7,PC}
    417              }
    418              else
    419              {
    420                  return(FALSE);
   \                     ??SettingFile__IsPlatformPointerUsed_5: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xBDF0             POP      {R4-R7,PC}       ;; return
    421              }
    422          }
    423          
    424          //---------------------------------------------------------------------------------------------------------------------
    425          /**
    426           * @brief   Returns the validity of the setting file.
    427           * @return  FALSE if there is something wrong with the setting file or the module variable is corrupt, else TRUE.
    428           */

   \                                 In section .text, align 2, keep-with-next
    429          BOOL_TYPE SettingFile__IsValid(void)
    430          {
   \                     SettingFile__IsValid: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    431              if (SRData__CheckByte((uint8 *)(void *)&Is_Settingfile_Valid, (uint8 *)(void *)&N_Is_Settingfile_Valid) == SRDATA_OK)
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable12_1
   \   00000006   0xF104 0x0108      ADD      R1,R4,#+8
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       SRData__CheckByte
   \   00000010   0xB908             CBNZ.N   R0,??SettingFile__IsValid_0
    432              {
    433                  return (Is_Settingfile_Valid);
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0xBD10             POP      {R4,PC}
    434              }
    435              else
    436              {
    437                  return(FALSE);      // If data integrity check fails, force return value to report that it is an invalid setting file
   \                     ??SettingFile__IsValid_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    438              }
    439          }
    440          
    441          //---------------------------------------------------------------------------------------------------------------------
    442          /**
    443           * @brief   Returns the number of "Extra" setting files
    444           * @details This feature is not currently used.
    445           * @return  Number of "Extra" setting files
    446           */

   \                                 In section .text, align 2, keep-with-next
    447          uint8 SettingFile__GetNumExtraSF(void)
    448          {
    449              return (0);
   \                     SettingFile__GetNumExtraSF: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    450          }
    451          
    452          //---------------------------------------------------------------------------------------------------------------------
    453          /**
    454           * @brief   Loads setting file data for a displacement within a pointer.
    455           * @param   pointer_id: See SETTINGFILE_OFFSET_TYPE
    456           * @param   displacement: The displacement (or offset) into the pointer where the data is located
    457           * @param   sf_data_ptr: Pointer to the setting file data (see SETTINGFILE_LOADER_TYPE)
    458           * @return  TRUE if valid data was found at the given pointer and displacement.
    459           */

   \                                 In section .text, align 2, keep-with-next
    460          PASS_FAIL_TYPE SettingFile__BasicLoader(SETTINGFILE_OFFSET_TYPE pointer_id, uint16 displacement, SETTINGFILE_LOADER_TYPE * sf_data_ptr)
    461          {
   \                     SettingFile__BasicLoader: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    462              uint16 * data_start_address;
    463          
    464              data_start_address = GetSettingFileStartByID((SF_ID_TYPE)(pointer_id >> 8));         // Extract upper 8 bits as the setting file id (ACU = 0, HMI = 1)
   \   00000008   0x0A20             LSRS     R0,R4,#+8
   \   0000000A   0x.... 0x....      BL       GetSettingFileStartByID
    465              data_start_address = ExtractAbsPointer(data_start_address, pointer_id);
   \   0000000E   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000012   0x428C             CMP      R4,R1
   \   00000014   0xBF18             IT       NE 
   \   00000016   0x2800             CMPNE    R0,#+0
   \   00000018   0xD00F             BEQ.N    ??SettingFile__BasicLoader_0
   \   0000001A   0xB2E2             UXTB     R2,R4
   \   0000001C   0xF830 0x2012      LDRH     R2,[R0, R2, LSL #+1]
   \   00000020   0x428A             CMP      R2,R1
   \   00000022   0xBF1C             ITT      NE 
   \   00000024   0x2A00             CMPNE    R2,#+0
   \   00000026   0xEB10 0x0042      ADDSNE   R0,R0,R2, LSL #+1
    466          
    467              if ((data_start_address != NULL) &&
    468                  (GetDisplacementData(data_start_address, displacement, sf_data_ptr) == SETTINGFILE_BSLDR_OK))
   \   0000002A   0xD006             BEQ.N    ??SettingFile__BasicLoader_0
   \   0000002C   0x4632             MOV      R2,R6
   \   0000002E   0x4629             MOV      R1,R5
   \   00000030   0x.... 0x....      BL       GetDisplacementData
   \   00000034   0xB908             CBNZ.N   R0,??SettingFile__BasicLoader_0
    469              {
    470                  return(PASS);
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xBD70             POP      {R4-R6,PC}
    471              }
    472              else
    473              {
    474                  return(FAIL);
   \                     ??SettingFile__BasicLoader_0: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
    475              }
    476          }
    477          
    478          //---------------------------------------------------------------------------------------------------------------------
    479          /**
    480           * @brief   Loads setting file data from an mSetting File. NOTE: mSetting files are currently not supported.
    481           */

   \                                 In section .text, align 2, keep-with-next
    482          PASS_FAIL_TYPE SettingFile__MSettingBasicLoader(uint8 sf_index, SETTINGFILE_OFFSET_TYPE pointer_id, uint16 displacement, SETTINGFILE_LOADER_TYPE * sf_data_ptr)
                                                                       ^
Remark[Pe826]: parameter "sf_index" was never referenced
    483          {
   \                     SettingFile__MSettingBasicLoader: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
   \   00000006   0x461E             MOV      R6,R3
    484              return(SettingFile__BasicLoader(pointer_id, displacement, sf_data_ptr));
   \   00000008   0x0A20             LSRS     R0,R4,#+8
   \   0000000A   0x.... 0x....      BL       GetSettingFileStartByID
   \   0000000E   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000012   0x428C             CMP      R4,R1
   \   00000014   0xBF18             IT       NE 
   \   00000016   0x2800             CMPNE    R0,#+0
   \   00000018   0xD010             BEQ.N    ??SettingFile__MSettingBasicLoader_0
   \   0000001A   0xB2E2             UXTB     R2,R4
   \   0000001C   0xF830 0x2012      LDRH     R2,[R0, R2, LSL #+1]
   \   00000020   0x428A             CMP      R2,R1
   \   00000022   0xBF1C             ITT      NE 
   \   00000024   0x2A00             CMPNE    R2,#+0
   \   00000026   0xEB10 0x0042      ADDSNE   R0,R0,R2, LSL #+1
   \   0000002A   0xD007             BEQ.N    ??SettingFile__MSettingBasicLoader_0
   \   0000002C   0x4632             MOV      R2,R6
   \   0000002E   0x4629             MOV      R1,R5
   \   00000030   0x.... 0x....      BL       GetDisplacementData
   \   00000034   0x1E40             SUBS     R0,R0,#+1
   \   00000036   0x4180             SBCS     R0,R0,R0
   \   00000038   0x0FC0             LSRS     R0,R0,#+31
   \   0000003A   0xBD70             POP      {R4-R6,PC}
   \                     ??SettingFile__MSettingBasicLoader_0: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
    485          }
    486          
    487          //---------------------------------------------------------------------------------------------------------------------
    488          /**
    489           * @brief   Get the number of displacements referenced by a setting file index and a pointer.
    490           * @param   sf_index: The index that specifies which setting file to check. NOTE: mSetting Files not currently supported.
    491           * @param   pointer_id: The pointer that specifies which section of the setting file to check.
    492           * @return  The number of displacements referenced by a setting file index and a pointer.
    493           */

   \                                 In section .text, align 4, keep-with-next
    494          uint16 SettingFile__GetNumDisplacements(uint8 sf_index, SETTINGFILE_OFFSET_TYPE pointer_id)
                                                               ^
Remark[Pe826]: parameter "sf_index" was never referenced
    495          {
   \                     SettingFile__GetNumDisplacements: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    496              uint16 num_of_displacements;
    497              uint16 * data_start_address;
    498              uint8 * byte_ptr;
    499          
    500              num_of_displacements = 0;
    501          
    502              data_start_address = GetSettingFileStartByID((SF_ID_TYPE)(pointer_id >> 8));     // Extract upper 8 bits as the setting file id (ACU = 0, HMI = 1)
   \   00000002   0x....             LDR.N    R2,??DataTable12
   \   00000004   0x7856             LDRB     R6,[R2, #+1]
   \   00000006   0x0A0B             LSRS     R3,R1,#+8
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF003 0x040F      AND      R4,R3,#0xF
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0x1C92             ADDS     R2,R2,#+2
   \   00000012   0x270A             MOVS     R7,#+10
   \                     ??SettingFile__GetNumDisplacements_0: (+1)
   \   00000014   0xF006 0x0E0F      AND      LR,R6,#0xF
   \   00000018   0x429E             CMP      R6,R3
   \   0000001A   0xD00D             BEQ.N    ??SettingFile__GetNumDisplacements_1
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xBF04             ITT      EQ 
   \   00000020   0x45A6             CMPEQ    LR,R4
   \   00000022   0x4615             MOVEQ    R5,R2
   \   00000024   0xD001             BEQ.N    ??SettingFile__GetNumDisplacements_2
   \   00000026   0x2EFF             CMP      R6,#+255
   \   00000028   0xD007             BEQ.N    ??SettingFile__GetNumDisplacements_3
   \                     ??SettingFile__GetNumDisplacements_2: (+1)
   \   0000002A   0x8816             LDRH     R6,[R2, #+0]
   \   0000002C   0xEB02 0x0246      ADD      R2,R2,R6, LSL #+1
   \   00000030   0x7856             LDRB     R6,[R2, #+1]
   \   00000032   0x1C92             ADDS     R2,R2,#+2
   \   00000034   0x1E7F             SUBS     R7,R7,#+1
   \   00000036   0xD1ED             BNE.N    ??SettingFile__GetNumDisplacements_0
   \                     ??SettingFile__GetNumDisplacements_1: (+1)
   \   00000038   0xB922             CBNZ.N   R2,??SettingFile__GetNumDisplacements_4
   \                     ??SettingFile__GetNumDisplacements_3: (+1)
   \   0000003A   0x2B00             CMP      R3,#+0
   \   0000003C   0xBF18             IT       NE 
   \   0000003E   0x2B01             CMPNE    R3,#+1
   \   00000040   0xD121             BNE.N    ??SettingFile__GetNumDisplacements_5
   \   00000042   0x462A             MOV      R2,R5
    503              data_start_address = ExtractAbsPointer(data_start_address, pointer_id);
   \                     ??SettingFile__GetNumDisplacements_4: (+1)
   \   00000044   0xF64F 0x73FF      MOVW     R3,#+65535
   \   00000048   0x4299             CMP      R1,R3
   \   0000004A   0xBF18             IT       NE 
   \   0000004C   0x2A00             CMPNE    R2,#+0
   \   0000004E   0xD01A             BEQ.N    ??SettingFile__GetNumDisplacements_5
   \   00000050   0xB2C9             UXTB     R1,R1
   \   00000052   0xF832 0x1011      LDRH     R1,[R2, R1, LSL #+1]
   \   00000056   0x4299             CMP      R1,R3
   \   00000058   0xBF1C             ITT      NE 
   \   0000005A   0x2900             CMPNE    R1,#+0
   \   0000005C   0xEB12 0x0141      ADDSNE   R1,R2,R1, LSL #+1
    504              if (data_start_address != NULL)
   \   00000060   0xD011             BEQ.N    ??SettingFile__GetNumDisplacements_5
    505              {
    506                  // Check for displacements that use the extended format.
    507                  byte_ptr = (void*)data_start_address;
    508                  if ((byte_ptr[0] & 0x80) == 0)
   \   00000062   0x7808             LDRB     R0,[R1, #+0]
   \   00000064   0x0602             LSLS     R2,R0,#+24
   \   00000066   0xD40C             BMI.N    ??SettingFile__GetNumDisplacements_6
    509                  {
    510                      // Displacements use normal format (1 byte per displacement).
    511                      data_start_address = &data_start_address[byte_ptr[0]];                  // Skip over extra-pointers field.
    512                      byte_ptr = (void*)data_start_address;
   \   00000068   0xEB01 0x0140      ADD      R1,R1,R0, LSL #+1
    513                      num_of_displacements = (2 * byte_ptr[0]) - 1;
   \   0000006C   0x7808             LDRB     R0,[R1, #+0]
   \   0000006E   0x0040             LSLS     R0,R0,#+1
   \   00000070   0x1E40             SUBS     R0,R0,#+1
    514                      if (byte_ptr[num_of_displacements - 1] == byte_ptr[num_of_displacements])
   \   00000072   0xB280             UXTH     R0,R0
   \   00000074   0x1842             ADDS     R2,R0,R1
   \   00000076   0x5C41             LDRB     R1,[R0, R1]
   \   00000078   0xF812 0x2C01      LDRB     R2,[R2, #-1]
   \   0000007C   0x428A             CMP      R2,R1
   \   0000007E   0xD102             BNE.N    ??SettingFile__GetNumDisplacements_5
    515                      {
    516                          num_of_displacements--;             // Don't count last displacement (zero-length).
   \   00000080   0xE000             B.N      ??SettingFile__GetNumDisplacements_7
    517                      }
    518                  }
    519                  else
    520                  {
    521                      // Displacements use extended format (2 bytes per displacement).
    522                      data_start_address = &data_start_address[1];     // Skip over extra-pointers field.
    523                      num_of_displacements = (data_start_address[0]) - 1;
   \                     ??SettingFile__GetNumDisplacements_6: (+1)
   \   00000082   0x8848             LDRH     R0,[R1, #+2]
   \                     ??SettingFile__GetNumDisplacements_7: (+1)
   \   00000084   0x1818             ADDS     R0,R3,R0
    524                  }
    525              }
    526          
    527              return (num_of_displacements);
   \                     ??SettingFile__GetNumDisplacements_5: (+1)
   \   00000086   0xB280             UXTH     R0,R0
   \   00000088   0xBDF0             POP      {R4-R7,PC}       ;; return
    528          }
    529          
    530          //---------------------------------------------------------------------------------------------------------------------
    531          /**
    532           * @brief   Determine whether the specified pointer uses the extended displacement format.
    533           *
    534           * @param   sf_index: The index of the setting file to check.
    535           * @param   pointer_id: The specific section of the setting file to check.
    536           *
    537           * @return TRUE if the specified pointer uses the extended displacement format, else FALSE.
    538           */

   \                                 In section .text, align 4, keep-with-next
    539          BOOL_TYPE SettingFile__IsExtendedDisplacement(uint8 sf_index, SETTINGFILE_OFFSET_TYPE pointer_id)
                                                                     ^
Remark[Pe826]: parameter "sf_index" was never referenced
    540          {
   \                     SettingFile__IsExtendedDisplacement: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    541              uint16 * data_start_address;
    542          
    543              data_start_address = GetSettingFileStartByID((SF_ID_TYPE)(pointer_id >> 8));    // Extract upper 8 bits as the setting file id (ACU = 0, HMI = 1)
   \   00000002   0x....             LDR.N    R4,??DataTable12
   \   00000004   0x7865             LDRB     R5,[R4, #+1]
   \   00000006   0x0A08             LSRS     R0,R1,#+8
   \   00000008   0xF000 0x020F      AND      R2,R0,#0xF
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x1CA4             ADDS     R4,R4,#+2
   \   00000010   0xF05F 0x060A      MOVS.W   R6,#+10
   \                     ??SettingFile__IsExtendedDisplacement_0: (+1)
   \   00000014   0xF005 0x070F      AND      R7,R5,#0xF
   \   00000018   0x4285             CMP      R5,R0
   \   0000001A   0xD00E             BEQ.N    ??SettingFile__IsExtendedDisplacement_1
   \   0000001C   0x2B00             CMP      R3,#+0
   \   0000001E   0xBF02             ITTT     EQ 
   \   00000020   0x4696             MOVEQ    LR,R2
   \   00000022   0x4577             CMPEQ    R7,LR
   \   00000024   0x4623             MOVEQ    R3,R4
   \   00000026   0xD001             BEQ.N    ??SettingFile__IsExtendedDisplacement_2
   \   00000028   0x2DFF             CMP      R5,#+255
   \   0000002A   0xD007             BEQ.N    ??SettingFile__IsExtendedDisplacement_3
   \                     ??SettingFile__IsExtendedDisplacement_2: (+1)
   \   0000002C   0x8825             LDRH     R5,[R4, #+0]
   \   0000002E   0xEB04 0x0445      ADD      R4,R4,R5, LSL #+1
   \   00000032   0x7865             LDRB     R5,[R4, #+1]
   \   00000034   0x1CA4             ADDS     R4,R4,#+2
   \   00000036   0x1E76             SUBS     R6,R6,#+1
   \   00000038   0xD1EC             BNE.N    ??SettingFile__IsExtendedDisplacement_0
   \                     ??SettingFile__IsExtendedDisplacement_1: (+1)
   \   0000003A   0xB924             CBNZ.N   R4,??SettingFile__IsExtendedDisplacement_4
   \                     ??SettingFile__IsExtendedDisplacement_3: (+1)
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xBF18             IT       NE 
   \   00000040   0x2801             CMPNE    R0,#+1
   \   00000042   0xD112             BNE.N    ??SettingFile__IsExtendedDisplacement_5
   \   00000044   0x461C             MOV      R4,R3
    544              data_start_address = ExtractAbsPointer(data_start_address, pointer_id);
   \                     ??SettingFile__IsExtendedDisplacement_4: (+1)
   \   00000046   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000004A   0x4281             CMP      R1,R0
   \   0000004C   0xBF18             IT       NE 
   \   0000004E   0x2C00             CMPNE    R4,#+0
   \   00000050   0xD00B             BEQ.N    ??SettingFile__IsExtendedDisplacement_5
   \   00000052   0xB2C9             UXTB     R1,R1
   \   00000054   0xF834 0x1011      LDRH     R1,[R4, R1, LSL #+1]
   \   00000058   0x4281             CMP      R1,R0
   \   0000005A   0xBF1C             ITT      NE 
   \   0000005C   0x2900             CMPNE    R1,#+0
   \   0000005E   0xEB14 0x0041      ADDSNE   R0,R4,R1, LSL #+1
    545          
    546              if (data_start_address != NULL)
   \   00000062   0xD002             BEQ.N    ??SettingFile__IsExtendedDisplacement_5
    547              {
    548                  uint8* byte_ptr = (void*)data_start_address;
    549                  return ((BOOL_TYPE)((byte_ptr[0] & 0x80) != 0));
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0x09C0             LSRS     R0,R0,#+7
   \   00000068   0xBDF0             POP      {R4-R7,PC}
    550              }
    551              else
    552              {
    553                  return(FALSE);
   \                     ??SettingFile__IsExtendedDisplacement_5: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xBDF0             POP      {R4-R7,PC}       ;; return
    554              }
    555          }
    556          
    557          //---------------------------------------------------------------------------------------------------------------------
    558          /**
    559           * @brief   Get the CRC of a specific setting file section.
    560           * @param   sf_id: ID of the setting file section (See SF_ID_TYPE)
    561           * @return  CRC of a setting file section
    562           */

   \                                 In section .text, align 4, keep-with-next
    563          uint16 SettingFile__GetSettingFileCRC(SF_ID_TYPE sf_id)
    564          {
   \                     SettingFile__GetSettingFileCRC: (+1)
   \   00000000   0xB4B0             PUSH     {R4,R5,R7}
    565              uint16 * data_crc_address;
    566              data_crc_address = ExtractAbsPointer(GetSettingFileStartByID(sf_id), SF_PTR_ACU_CRC);
   \   00000002   0x....             LDR.N    R3,??DataTable12
   \   00000004   0x785C             LDRB     R4,[R3, #+1]
   \   00000006   0xF000 0x010F      AND      R1,R0,#0xF
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x1C9B             ADDS     R3,R3,#+2
   \   0000000E   0x250A             MOVS     R5,#+10
   \                     ??SettingFile__GetSettingFileCRC_0: (+1)
   \   00000010   0xF004 0x070F      AND      R7,R4,#0xF
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD00D             BEQ.N    ??SettingFile__GetSettingFileCRC_1
   \   00000018   0x2A00             CMP      R2,#+0
   \   0000001A   0xBF04             ITT      EQ 
   \   0000001C   0x428F             CMPEQ    R7,R1
   \   0000001E   0x461A             MOVEQ    R2,R3
   \   00000020   0xD001             BEQ.N    ??SettingFile__GetSettingFileCRC_2
   \   00000022   0x2CFF             CMP      R4,#+255
   \   00000024   0xD007             BEQ.N    ??SettingFile__GetSettingFileCRC_3
   \                     ??SettingFile__GetSettingFileCRC_2: (+1)
   \   00000026   0x881C             LDRH     R4,[R3, #+0]
   \   00000028   0xEB03 0x0344      ADD      R3,R3,R4, LSL #+1
   \   0000002C   0x785C             LDRB     R4,[R3, #+1]
   \   0000002E   0x1C9B             ADDS     R3,R3,#+2
   \   00000030   0x1E6D             SUBS     R5,R5,#+1
   \   00000032   0xD1ED             BNE.N    ??SettingFile__GetSettingFileCRC_0
   \                     ??SettingFile__GetSettingFileCRC_1: (+1)
   \   00000034   0xB923             CBNZ.N   R3,??SettingFile__GetSettingFileCRC_4
   \                     ??SettingFile__GetSettingFileCRC_3: (+1)
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xBF18             IT       NE 
   \   0000003A   0x2801             CMPNE    R0,#+1
   \   0000003C   0xD10D             BNE.N    ??SettingFile__GetSettingFileCRC_5
   \   0000003E   0x4613             MOV      R3,R2
   \                     ??SettingFile__GetSettingFileCRC_4: (+1)
   \   00000040   0x2B00             CMP      R3,#+0
   \   00000042   0xBF1E             ITTT     NE 
   \   00000044   0x8858             LDRHNE   R0,[R3, #+2]
   \   00000046   0xF64F 0x71FF      MOVWNE   R1,#+65535
   \   0000004A   0x4288             CMPNE    R0,R1
   \   0000004C   0xD005             BEQ.N    ??SettingFile__GetSettingFileCRC_5
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xBF1C             ITT      NE 
   \   00000052   0xEB13 0x0040      ADDSNE   R0,R3,R0, LSL #+1
    567          
    568              if (data_crc_address != NULL)
    569              {
    570                  return (*data_crc_address);
   \   00000056   0x8800             LDRHNE   R0,[R0, #+0]
   \   00000058   0xD100             BNE.N    ??SettingFile__GetSettingFileCRC_6
    571              }
    572              else
    573              {
    574                  return 0;
   \                     ??SettingFile__GetSettingFileCRC_5: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \                     ??SettingFile__GetSettingFileCRC_6: (+1)
   \   0000005C   0xBCB0             POP      {R4,R5,R7}
   \   0000005E   0x4770             BX       LR               ;; return
    575              }
    576          }
    577          
    578          //---------------------------------------------------------------------------------------------------------------------
    579          /**
    580           * Get a pointer to the start of the setting file.
    581           * @return A pointer to the start of the setting file.
    582           */

   \                                 In section .text, align 2, keep-with-next
    583          void * SettingFile__GetMemorySectionStart(void)
    584          {
    585              return ((void *)SF_START_ADDRESS);
   \                     SettingFile__GetMemorySectionStart: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12
   \   00000002   0x4770             BX       LR               ;; return
    586          }
    587          
    588          //---------------------------------------------------------------------------------------------------------------------
    589          /**
    590           * @return  Size of the memory section reserved for the entire setting file.
    591           */

   \                                 In section .text, align 2, keep-with-next
    592          uint32 SettingFile__GetMemorySectionSize(void)
    593          {
    594              return ((uint32)SF_SIZE);       //lint !e923 cast from pointer to unsigned long [MISRA 2004 Rule 11.1],[MISRA 2004 Rule 11.3]
   \                     SettingFile__GetMemorySectionSize: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_2
   \   00000002   0x4770             BX       LR               ;; return
    595          }
    596          
    597          //---------------------------------------------------------------------------------------------------------------------
    598          /**
    599           * Get a pointer to the data in the specified section of the setting file.
    600           * @param sf_id = The section ID of the requested setting file section.
    601           * @return A pointer to the data in the specified section of the setting file.
    602           *         If the setting file section is not found, then return NULL.
    603           */

   \                                 In section .text, align 4, keep-with-next
    604          void * SettingFile__GetSettingFileStart(SF_ID_TYPE sf_id)
    605          {
   \                     SettingFile__GetSettingFileStart: (+1)
   \   00000000   0xB4B0             PUSH     {R4,R5,R7}
    606              uint16 * pt;
    607              // Get the address of the first pointer
    608              pt = GetSettingFileStartByID(sf_id);
   \   00000002   0x....             LDR.N    R1,??DataTable12
   \   00000004   0x784C             LDRB     R4,[R1, #+1]
   \   00000006   0xF000 0x020F      AND      R2,R0,#0xF
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x1C89             ADDS     R1,R1,#+2
   \   0000000E   0x250A             MOVS     R5,#+10
   \                     ??SettingFile__GetSettingFileStart_0: (+1)
   \   00000010   0xF004 0x070F      AND      R7,R4,#0xF
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD00D             BEQ.N    ??SettingFile__GetSettingFileStart_1
   \   00000018   0x2B00             CMP      R3,#+0
   \   0000001A   0xBF04             ITT      EQ 
   \   0000001C   0x4297             CMPEQ    R7,R2
   \   0000001E   0x460B             MOVEQ    R3,R1
   \   00000020   0xD001             BEQ.N    ??SettingFile__GetSettingFileStart_2
   \   00000022   0x2CFF             CMP      R4,#+255
   \   00000024   0xD010             BEQ.N    ??SettingFile__GetSettingFileStart_3
   \                     ??SettingFile__GetSettingFileStart_2: (+1)
   \   00000026   0x880C             LDRH     R4,[R1, #+0]
   \   00000028   0xEB01 0x0144      ADD      R1,R1,R4, LSL #+1
   \   0000002C   0x784C             LDRB     R4,[R1, #+1]
   \   0000002E   0x1C89             ADDS     R1,R1,#+2
   \   00000030   0x1E6D             SUBS     R5,R5,#+1
   \   00000032   0xD1ED             BNE.N    ??SettingFile__GetSettingFileStart_0
   \                     ??SettingFile__GetSettingFileStart_1: (+1)
   \   00000034   0xB919             CBNZ.N   R1,??SettingFile__GetSettingFileStart_4
   \                     ??SettingFile__GetSettingFileStart_5: (+1)
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xBF14             ITE      NE 
   \   0000003A   0x2801             CMPNE    R0,#+1
   \   0000003C   0x4619             MOVEQ    R1,R3
    609          
    610              if (pt != NULL)
   \                     ??SettingFile__GetSettingFileStart_4: (+1)
   \   0000003E   0xB101             CBZ.N    R1,??SettingFile__GetSettingFileStart_6
    611              {
    612                  //Decrement to include the SF ID
    613                  pt--;
   \   00000040   0x1E89             SUBS     R1,R1,#+2
    614              }
    615              return ((void *)pt);
   \                     ??SettingFile__GetSettingFileStart_6: (+1)
   \   00000042   0xBCB0             POP      {R4,R5,R7}
   \   00000044   0x4608             MOV      R0,R1
   \   00000046   0x4770             BX       LR               ;; return
   \                     ??SettingFile__GetSettingFileStart_3: (+1)
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xE7F4             B.N      ??SettingFile__GetSettingFileStart_5
    616          }
    617          
    618          //---------------------------------------------------------------------------------------------------------------------
    619          /**
    620           * @brief   Determine the section ID of the section at the specified position.
    621           * @param   section_ids: Pointer to a list of section IDs, See SF_ID_TYPE
    622           * @return  The section ID of the section at the specified position.
    623           *          If there is no section at the specified position, then return SF_ID_END.
    624           */

   \                                 In section .text, align 2, keep-with-next
    625          uint8 SettingFile__GetSectionIDs(SF_ID_TYPE * section_ids)
    626          {
   \                     SettingFile__GetSectionIDs: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    627              uint8 position;
    628              memset(section_ids, SF_ID_END, SF_MAX_SECTIONS);
   \   00000004   0x22FF             MOVS     R2,#+255
   \   00000006   0x210A             MOVS     R1,#+10
   \   00000008   0x.... 0x....      BL       __aeabi_memset
    629              uint16* ptr = SF_START_ADDRESS;
   \   0000000C   0x....             LDR.N    R1,??DataTable12
    630              for (position = 0; position < SF_MAX_SECTIONS; position++)
   \   0000000E   0x2000             MOVS     R0,#+0
    631              {
    632                  SF_ID_TYPE section_id = ((SF_SECTION_HEADER_TYPE*)(void*)ptr)->Section_ID;
   \                     ??SettingFile__GetSectionIDs_0: (+1)
   \   00000010   0x784A             LDRB     R2,[R1, #+1]
    633                  if (section_id == SF_ID_END)
   \   00000012   0x2AFF             CMP      R2,#+255
   \   00000014   0xD013             BEQ.N    ??SettingFile__GetSectionIDs_1
    634                  {
    635                      break;                                  // Break out of the for() loop.
    636                  }
    637                  section_ids[position] = section_id;
   \   00000016   0xF804 0x2B01      STRB     R2,[R4], #+1
    638                  ptr++;
    639                  ptr = &ptr[ptr[SF_PTR_ACU_END_OF_SECTION]];
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0xF831 0x2F02      LDRH     R2,[R1, #+2]!
   \   00000020   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \   00000024   0x784A             LDRB     R2,[R1, #+1]
   \   00000026   0x2AFF             CMP      R2,#+255
   \   00000028   0xD009             BEQ.N    ??SettingFile__GetSectionIDs_1
   \   0000002A   0xF804 0x2B01      STRB     R2,[R4], #+1
    640              }
   \   0000002E   0x1C40             ADDS     R0,R0,#+1
   \   00000030   0xF831 0x2F02      LDRH     R2,[R1, #+2]!
   \   00000034   0xB2C0             UXTB     R0,R0
   \   00000036   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \   0000003A   0x280A             CMP      R0,#+10
   \   0000003C   0xDBE8             BLT.N    ??SettingFile__GetSectionIDs_0
    641              return position;
   \                     ??SettingFile__GetSectionIDs_1: (+1)
   \   0000003E   0xB2C0             UXTB     R0,R0
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    642          }
    643          
    644          //---------------------------------------------------------------------------------------------------------------------
    645          /**
    646           * Get the address of a specific byte in a section of the setting file.
    647           * @param sf_id = The section of the setting file that contains the byte.
    648           * @param index = The index of the byte from the beginning of the setting file section.
    649           * @return The address of a specific byte in a section of the setting file.
    650           */

   \                                 In section .text, align 2, keep-with-next
    651          void * SettingFile__GetSettingFilePointerByIndex(SF_ID_TYPE sf_id, uint32 index)
    652          {
   \                     SettingFile__GetSettingFilePointerByIndex: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    653              uint8 * pt;
    654              pt = SettingFile__GetSettingFileStart(sf_id);
   \   00000004   0x.... 0x....      BL       GetSettingFileStartByID
   \   00000008   0xB100             CBZ.N    R0,??SettingFile__GetSettingFilePointerByIndex_0
   \   0000000A   0x1E80             SUBS     R0,R0,#+2
    655          
    656              return ((void *)&pt[index]);
   \                     ??SettingFile__GetSettingFilePointerByIndex_0: (+1)
   \   0000000C   0x1820             ADDS     R0,R4,R0
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    657          }
    658          
    659          //---------------------------------------------------------------------------------------------------------------------
    660          /**
    661           * Get the number of bytes in a the specified section of the setting file.
    662           * @param sf_id = The section ID for the requested section of the setting file.
    663           * @return The number of bytes in a the specified section of the setting file.
    664           *         If the specified section does not exist, then return 0.
    665           */

   \                                 In section .text, align 4, keep-with-next
    666          uint32 SettingFile__GetSettingFileSize(SF_ID_TYPE sf_id)
    667          {
   \                     SettingFile__GetSettingFileSize: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    668              uint16 * data_address;
    669              uint16 size = 0;    // Initialize to zero in case setting file with ID is not found
    670          
    671              // Get the first pointer of the specific setting file
    672              data_address = GetSettingFileStartByID(sf_id);
   \   00000002   0x....             LDR.N    R4,??DataTable12
   \   00000004   0x7865             LDRB     R5,[R4, #+1]
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0xF000 0x020F      AND      R2,R0,#0xF
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x1CA4             ADDS     R4,R4,#+2
   \   00000010   0xF05F 0x060A      MOVS.W   R6,#+10
   \                     ??SettingFile__GetSettingFileSize_0: (+1)
   \   00000014   0xF005 0x070F      AND      R7,R5,#0xF
   \   00000018   0x4285             CMP      R5,R0
   \   0000001A   0xD00E             BEQ.N    ??SettingFile__GetSettingFileSize_1
   \   0000001C   0x2B00             CMP      R3,#+0
   \   0000001E   0xBF02             ITTT     EQ 
   \   00000020   0x4696             MOVEQ    LR,R2
   \   00000022   0x4577             CMPEQ    R7,LR
   \   00000024   0x4623             MOVEQ    R3,R4
   \   00000026   0xD001             BEQ.N    ??SettingFile__GetSettingFileSize_2
   \   00000028   0x2DFF             CMP      R5,#+255
   \   0000002A   0xD007             BEQ.N    ??SettingFile__GetSettingFileSize_3
   \                     ??SettingFile__GetSettingFileSize_2: (+1)
   \   0000002C   0x8825             LDRH     R5,[R4, #+0]
   \   0000002E   0xEB04 0x0445      ADD      R4,R4,R5, LSL #+1
   \   00000032   0x7865             LDRB     R5,[R4, #+1]
   \   00000034   0x1CA4             ADDS     R4,R4,#+2
   \   00000036   0x1E76             SUBS     R6,R6,#+1
   \   00000038   0xD1EC             BNE.N    ??SettingFile__GetSettingFileSize_0
   \                     ??SettingFile__GetSettingFileSize_1: (+1)
   \   0000003A   0xB924             CBNZ.N   R4,??SettingFile__GetSettingFileSize_4
   \                     ??SettingFile__GetSettingFileSize_3: (+1)
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xBF18             IT       NE 
   \   00000040   0x2801             CMPNE    R0,#+1
   \   00000042   0xD104             BNE.N    ??SettingFile__GetSettingFileSize_5
   \   00000044   0x461C             MOV      R4,R3
    673          
    674              if (data_address != NULL)
   \                     ??SettingFile__GetSettingFileSize_4: (+1)
   \   00000046   0xB114             CBZ.N    R4,??SettingFile__GetSettingFileSize_5
    675              {
    676                  // offset by the pointer
    677                  // (Needed in case SF_PTR_ACU_END_OF_SECTION ever changes from 0 to something else.)
    678                  data_address += (SF_PTR_ACU_END_OF_SECTION & 0x00FF);
    679          
    680                  // Get the content
    681                  size = (*data_address);
    682          
    683                  // Convert from number of words to number of bytes.
    684                  size <<= 1;
    685          
    686                  // Add 2 to include the section header.
    687                  size += 2;
   \   00000048   0x8820             LDRH     R0,[R4, #+0]
   \   0000004A   0x0040             LSLS     R0,R0,#+1
   \   0000004C   0x1C81             ADDS     R1,R0,#+2
    688              }
    689          
    690              return (size);
   \                     ??SettingFile__GetSettingFileSize_5: (+1)
   \   0000004E   0xB288             UXTH     R0,R1
   \   00000050   0xBDF0             POP      {R4-R7,PC}       ;; return
    691          }
    692          
    693          //---------------------------------------------------------------------------------------------------------------------
    694          /**
    695           * @brief   Calculates the CRC of a setting file section.
    696           * @param   sf_id: see SF_ID_TYPE
    697           * @return  CRC of a setting file section
    698           */

   \                                 In section .text, align 4, keep-with-next
    699          uint16 SettingFile__CalculateCRC(SF_ID_TYPE sf_id)
    700          {
   \                     SettingFile__CalculateCRC: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    701              return (CalculateSectionCRC(GetSettingFileStartByID(sf_id)));
   \   00000004   0x.... 0x....      BL       GetSettingFileStartByID
   \   00000008   0x4601             MOV      R1,R0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xBF1E             ITTT     NE 
   \   00000010   0x884A             LDRHNE   R2,[R1, #+2]
   \   00000012   0xF64F 0x73FF      MOVWNE   R3,#+65535
   \   00000016   0x429A             CMPNE    R2,R3
   \   00000018   0xD00E             BEQ.N    ??SettingFile__CalculateCRC_0
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xBF18             IT       NE 
   \   0000001E   0xEB11 0x0442      ADDSNE   R4,R1,R2, LSL #+1
   \   00000022   0xD009             BEQ.N    ??SettingFile__CalculateCRC_0
   \   00000024   0x1E8D             SUBS     R5,R1,#+2
   \   00000026   0x4618             MOV      R0,R3
   \   00000028   0x42A5             CMP      R5,R4
   \   0000002A   0xD205             BCS.N    ??SettingFile__CalculateCRC_0
   \                     ??SettingFile__CalculateCRC_1: (+1)
   \   0000002C   0xF815 0x1B01      LDRB     R1,[R5], #+1
   \   00000030   0x.... 0x....      BL       Crc16__ByteProcess
   \   00000034   0x42A5             CMP      R5,R4
   \   00000036   0xD3F9             BCC.N    ??SettingFile__CalculateCRC_1
   \                     ??SettingFile__CalculateCRC_0: (+1)
   \   00000038   0xB001             ADD      SP,SP,#+4
   \   0000003A   0xBD30             POP      {R4,R5,PC}       ;; return
    702          }
    703          
    704          //=====================================================================================================================
    705          //-------------------------------------- Private Functions ------------------------------------------------------------
    706          //=====================================================================================================================
    707          
    708          //---------------------------------------------------------------------------------------------------------------------
    709          /**
    710           * @brief   Calculates the CRC of a setting file section
    711           * @param   section_start_address: Address of the start of the setting file data (does not include first word that
    712           *          contains the section ID and endianness)
    713           * @return  CRC of the setting file section
    714           */
    715          static uint16 CalculateSectionCRC(uint16 * section_start_address)
    716          {
    717              uint16   crc = 0;   // Initialize value to zero in case the setting file with the requested ID is not found
    718              uint16 * data_crc_address;
    719          
    720              data_crc_address = ExtractAbsPointer(section_start_address, SF_PTR_ACU_CRC);
    721          
    722              if (data_crc_address != NULL)
    723              {
    724                  uint8 * byte_ptr = (void*)(section_start_address - 1);
    725                  uint8 * end_of_data_ptr = (void*)data_crc_address;
    726          
    727                  crc = 0xFFFF;
    728          
    729                  while (byte_ptr < end_of_data_ptr)
    730                  {
    731                      crc = Crc16__ByteProcess(crc,*byte_ptr);
    732                      byte_ptr++;
    733                  }
    734              }
    735          
    736              return (crc);
    737          }
    738          
    739          //---------------------------------------------------------------------------------------------------------------------
    740          /**
    741           * @brief   Get the offset to the start of a setting file section
    742           * @param   sf_id: see SF_ID_TYPE
    743           * @return  Number of words offset from the start of the whole setting file to the start of a setting file section
    744           */

   \                                 In section .text, align 4, keep-with-next
    745          static uint16 * GetSettingFileStartByID(SF_ID_TYPE sf_id)
    746          {
   \                     GetSettingFileStartByID: (+1)
   \   00000000   0xB4B0             PUSH     {R4,R5,R7}
    747              uint16 * ptr;
    748              BOOL_TYPE skip_search = FALSE;
    749          
    750              #if (USE_ACU_HARDCODED_SETTING_FILE == ENABLED)
    751                  if (sf_id == SF_ID_ACU)
    752                  {
    753                      ptr = (void*)&__ACU_Hardcoded_SettingFile_Start;
    754                      ptr++;                                  // Adjust pointer to skip over the word for the section ID and point to the End Of Section data
    755                      skip_search = TRUE;
    756                  }
    757              #endif
    758              #if (USE_HMI_HARDCODED_SETTING_FILE == ENABLED)
    759                  if (sf_id == SF_ID_HMI)
    760                  {
    761                      ptr = (void*)&__HMI_Hardcoded_SettingFile_Start;
    762                      ptr++;                                  // Adjust pointer to skip over the word for the section ID and point to the End Of Section data
    763                      skip_search = TRUE;
    764                  }
    765              #endif
    766          
    767              uint8 sf_type = (sf_id & SETTINGFILE_MASK_SECTION_ID_TYPE);
    768              uint16* remember_ptr = NULL;
    769              if (skip_search == FALSE)
    770              {
    771                  ptr = SF_START_ADDRESS;
    772                  SF_ID_TYPE section_id = ((SF_SECTION_HEADER_TYPE*)(void*)ptr)->Section_ID;
   \   00000002   0x....             LDR.N    R1,??DataTable12
   \   00000004   0x784C             LDRB     R4,[R1, #+1]
   \   00000006   0xF000 0x020F      AND      R2,R0,#0xF
   \   0000000A   0x2300             MOVS     R3,#+0
    773                  ptr++;
   \   0000000C   0x1C89             ADDS     R1,R1,#+2
    774                  for (uint8 section_position = 0; section_position < SF_MAX_SECTIONS; section_position++)
   \   0000000E   0x250A             MOVS     R5,#+10
    775                  {
    776                      uint8 section_type = (section_id & SETTINGFILE_MASK_SECTION_ID_TYPE);
   \                     ??GetSettingFileStartByID_0: (+1)
   \   00000010   0xF004 0x070F      AND      R7,R4,#0xF
    777                      if (section_id == sf_id)                // Found the requested setting file section.
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD00B             BEQ.N    ??GetSettingFileStartByID_1
    778                      {
    779                          break;                              // Break out of the for() loop.
    780                      }
    781                      else if ((remember_ptr == NULL) && (section_type == sf_type))
   \   00000018   0x2B00             CMP      R3,#+0
   \   0000001A   0xBF08             IT       EQ 
   \   0000001C   0x4297             CMPEQ    R7,R2
   \   0000001E   0xD10F             BNE.N    ??GetSettingFileStartByID_2
    782                      {
    783                          // This is the main ACU or main HMI section.
    784                          // Save the pointer in case it is what is really requested.
    785                          remember_ptr = ptr;
   \   00000020   0x460B             MOV      R3,R1
    786                      }
    787                      else if (section_id == SF_ID_END)
    788                      {
    789                          ptr = NULL;
    790                          break;                              // Break out of the for() loop.
    791                      }
    792                      ptr = &ptr[ptr[SF_PTR_ACU_END_OF_SECTION]];
   \                     ??GetSettingFileStartByID_3: (+1)
   \   00000022   0x880C             LDRH     R4,[R1, #+0]
   \   00000024   0xEB01 0x0144      ADD      R1,R1,R4, LSL #+1
    793                      section_id = ((SF_SECTION_HEADER_TYPE*)(void*)ptr)->Section_ID;
   \   00000028   0x784C             LDRB     R4,[R1, #+1]
    794                      ptr++;
   \   0000002A   0x1C89             ADDS     R1,R1,#+2
   \   0000002C   0x1E6D             SUBS     R5,R5,#+1
   \   0000002E   0xD1EF             BNE.N    ??GetSettingFileStartByID_0
    795                  }
    796              }
    797              // When an expansion board requests the main ACU or main HMI section, it will get the first ACU or HMI section.
    798              if ((ptr == NULL) && ((sf_id == SF_ID_ACU) || (sf_id == SF_ID_HMI)))
   \                     ??GetSettingFileStartByID_1: (+1)
   \   00000030   0xB919             CBNZ.N   R1,??GetSettingFileStartByID_4
   \                     ??GetSettingFileStartByID_5: (+1)
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xBF14             ITE      NE 
   \   00000036   0x2801             CMPNE    R0,#+1
    799              {
    800                  ptr = remember_ptr;
   \   00000038   0x4619             MOVEQ    R1,R3
    801              }
    802              return (ptr);
   \                     ??GetSettingFileStartByID_4: (+1)
   \   0000003A   0xBCB0             POP      {R4,R5,R7}
   \   0000003C   0x4608             MOV      R0,R1
   \   0000003E   0x4770             BX       LR               ;; return
   \                     ??GetSettingFileStartByID_2: (+1)
   \   00000040   0x2CFF             CMP      R4,#+255
   \   00000042   0xD1EE             BNE.N    ??GetSettingFileStartByID_3
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0xE7F4             B.N      ??GetSettingFileStartByID_5
    803          }
    804          
    805          //---------------------------------------------------------------------------------------------------------------------
    806          /**
    807           * @brief   Returns the start address of the setting file data based on the position of the section in the setting file.
    808           * @param   sf_position: position of the section in the setting file
    809           */
    810          static uint16 * GetSettingFileStartByPosition(uint8 sf_position)
    811          {
    812              uint16* ptr16 = SF_START_ADDRESS;
    813              for (uint8 position = 0; position < SF_MAX_SECTIONS; position++)
    814              {
    815                  SF_ID_TYPE section_id = ((SF_SECTION_HEADER_TYPE*)(void*)ptr16)->Section_ID;
    816                  if (section_id == SF_ID_END)
    817                  {
    818                      ptr16 = NULL;                           // Invalidate the pointer if the end of the setting file is reached
    819                      break;                                  // Break out of the for() loop.
    820                  }
    821                  else if (position == sf_position)
    822                  {
    823                      break;                                  // Reached the desired section so break out of the for() loop
    824                  }
    825          
    826                  ptr16++;                                    // Adjust pointer to point to the beginning of the data (excluded section ID and endianness)
    827                  ptr16 = &ptr16[ptr16[SF_PTR_ACU_END_OF_SECTION]];   // Adjust pointer to point to the start of the next section
    828              }
    829          
    830              ptr16++;                                        // Adjust pointer to point to the beginning of the data (excluded section ID and endianness)
    831          
    832              return(ptr16);
    833          }
    834          
    835          //---------------------------------------------------------------------------------------------------------------------
    836          /**
    837           * @brief   This routine give absolute address in a big endian 16-bit pointers table
    838           * @details former LIB_SEF_GetBEWrdRelShort_Ptr
    839           * @param   data_struct_start_ptr
    840           * @param   pointer_id
    841           * @return
    842           */
    843          static uint16 * ExtractAbsPointer(uint16 * data_struct_start_ptr, SETTINGFILE_OFFSET_TYPE pointer_id)
    844          {
    845              uint16 * retval;
    846              uint16 pointer_offset;
    847          
    848              retval = NULL;
    849          
    850              if ((pointer_id != SF_PTR_INVALID_VALUE) &&
    851                  (data_struct_start_ptr != NULL))
    852              {
    853                  // Find the offset to apply to the start address
    854                  pointer_offset = (data_struct_start_ptr[pointer_id & 0x00FF]);   // Extract lower 8 bits to get the pointer
    855          
    856                  if ((pointer_offset < 0xFFFF) &&
    857                      (SETTINGFILE_NULL_VALUE != pointer_offset) &&
    858                      (SF_PTR_INVALID_VALUE != pointer_offset))
    859                  {
    860                      retval = data_struct_start_ptr + pointer_offset;
    861                  }
    862              }
    863          
    864              return retval;
    865          }
    866          
    867          //---------------------------------------------------------------------------------------------------------------------
    868          /**
    869           *  @brief      Get the address and size of the data block associated with the specified displacement.
    870           *
    871           *  @details    former LIB_SEF_GetDisplData
    872           *
    873           *  @param data_start_address = Address of the start of the data in the setting file referenced by a pointer.
    874           *  @param displacement = The displacement used to get the data block.
    875           *  @param data_out_ptr = A structure to fill with the address and length of the data block.
    876           *
    877           *  @return SETTINGFILE_BSLDR_OK if the data is found and referenced successfully.
    878           */

   \                                 In section .text, align 4, keep-with-next
    879          static SETTINGFILE_BSLDR_RETURN_TYPE GetDisplacementData(uint16 * data_start_address, uint16 displacement, SETTINGFILE_LOADER_TYPE * data_out_ptr)
    880          {
   \                     GetDisplacementData: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
    881              SETTINGFILE_BSLDR_RETURN_TYPE retval;
    882              BOOL_TYPE is_extended_displacement;
    883              uint16 num_page;
    884              uint16 num_page_end;
    885              uint16 num_extra_ptr_word;
    886              uint8 * data_ptr;
    887          
    888              retval = SETTINGFILE_BSLDR_OK;
    889          
    890              uint8* byte_ptr = (void*)data_start_address;
    891              is_extended_displacement = (BOOL_TYPE)((byte_ptr[0] & 0x80) != 0);
    892              if (is_extended_displacement)
   \   00000004   0x7805             LDRB     R5,[R0, #+0]
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0x09ED             LSRS     R5,R5,#+7
   \   0000000C   0xD00F             BEQ.N    ??GetDisplacementData_0
    893              {
    894                  /* Extended Displacement => 16 bit */
    895                  //data_start_address points to the begin of the displacement array
    896                   data_start_address++;
    897          
    898                  // Check for a displacement that is out of range. (This includes a displacement of 0xFFFF.)
    899                  if (displacement >= ((*data_start_address) - 1))
   \   0000000E   0xF830 0x1F02      LDRH     R1,[R0, #+2]!
   \   00000012   0x1E49             SUBS     R1,R1,#+1
   \   00000014   0x428C             CMP      R4,R1
   \   00000016   0xDA2C             BGE.N    ??GetDisplacementData_1
    900                  {
    901                      retval = SETTINGFILE_BSLDR_ERR_INVALID_DISPL;
    902                  }
    903                  else
    904                  {
    905                       // the calculation is valid even in a case where *( EepData + Displacement + 1 ) < *( EepData + Displacement ) which
    906                      // can cause a page overflow
    907                      data_out_ptr->Length = ((data_start_address[displacement + 1]) - (data_start_address[displacement])) * 2;
   \   00000018   0xEB00 0x0144      ADD      R1,R0,R4, LSL #+1
   \   0000001C   0xF830 0x5014      LDRH     R5,[R0, R4, LSL #+1]
   \   00000020   0x8849             LDRH     R1,[R1, #+2]
   \   00000022   0x1B49             SUBS     R1,R1,R5
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x8091             STRH     R1,[R2, #+4]
    908                      data_out_ptr->Data = (void*)&data_start_address[(data_start_address[displacement])];
   \   00000028   0xF830 0x4014      LDRH     R4,[R0, R4, LSL #+1]
   \   0000002C   0xE031             B.N      ??GetDisplacementData_2
    909                      if (0 == data_out_ptr->Length)
    910                      {
    911                          retval = SETTINGFILE_BSLDR_INVALID_LENGTH;
    912                      }
    913                  }
    914              }
    915              else
    916              {
    917                  byte_ptr = (void*)data_start_address;
    918                  num_extra_ptr_word = byte_ptr[0];
   \                     ??GetDisplacementData_0: (+1)
   \   0000002E   0x7807             LDRB     R7,[R0, #+0]
    919          
    920                  // Control the ExtraPointer forcing the safe page
    921                  num_page = 0;
    922                  num_page_end = 0;
   \   00000030   0x2600             MOVS     R6,#+0
    923          
    924                  data_ptr = (void*)(data_start_address);
    925          
    926                  for (uint8 i = 1; i < (2 * num_extra_ptr_word); i++)
   \   00000032   0xEA4F 0x0847      LSL      R8,R7,#+1
   \   00000036   0xF04F 0x0C01      MOV      R12,#+1
   \   0000003A   0xF104 0x0E01      ADD      LR,R4,#+1
   \   0000003E   0xF1B8 0x0F02      CMP      R8,#+2
   \   00000042   0xDB0F             BLT.N    ??GetDisplacementData_3
    927                  {
    928                      /* displacement < 0xFF */
    929                      if (displacement >= data_ptr[i])
   \                     ??GetDisplacementData_4: (+1)
   \   00000044   0xF81C 0x9000      LDRB     R9,[R12, R0]
   \   00000048   0x4549             CMP      R1,R9
   \   0000004A   0xBF28             IT       CS 
    930                      {
    931                          num_page += 0x0100U;
   \   0000004C   0xF505 0x7580      ADDCS    R5,R5,#+256
    932                      }
    933          
    934                      if ((displacement+1) >= data_ptr[i])
   \   00000050   0x45CE             CMP      LR,R9
   \   00000052   0xBFA8             IT       GE 
    935                      {
    936                          num_page_end += 0x0100U;
   \   00000054   0xF506 0x7680      ADDGE    R6,R6,#+256
    937                      }
    938                  }
   \   00000058   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   0000005C   0xFA5F 0xFC8C      UXTB     R12,R12
   \   00000060   0x45C4             CMP      R12,R8
   \   00000062   0xDBEF             BLT.N    ??GetDisplacementData_4
    939                  data_ptr += (2 * num_extra_ptr_word);      /* data_ptr points to the begin of displacement */
   \                     ??GetDisplacementData_3: (+1)
   \   00000064   0xEB00 0x0047      ADD      R0,R0,R7, LSL #+1
    940          
    941                  // Check for a displacement that is out of range. (This includes a displacement of 0xFF.)
    942                  if (displacement >= ((2 * (*data_ptr)) - 1))
   \   00000068   0x7801             LDRB     R1,[R0, #+0]
   \   0000006A   0x0049             LSLS     R1,R1,#+1
   \   0000006C   0x1E49             SUBS     R1,R1,#+1
   \   0000006E   0x428C             CMP      R4,R1
   \   00000070   0xDB03             BLT.N    ??GetDisplacementData_5
    943                  {
    944                      retval = SETTINGFILE_BSLDR_ERR_INVALID_DISPL;
   \                     ??GetDisplacementData_1: (+1)
   \   00000072   0x2382             MOVS     R3,#+130
    945                  }
    946                  else
    947                  {
    948                      data_out_ptr->Length = ( num_page_end + *( data_ptr + displacement + 1 ) - ( *( data_ptr + displacement ) + num_page) ) * 2;
    949          
    950                      data_out_ptr->Data = (data_ptr + (2 * (*(data_ptr + displacement) + num_page)));
    951          
    952                      if (0 == data_out_ptr->Length)
    953                      {
    954                          retval = SETTINGFILE_BSLDR_INVALID_LENGTH;
    955                      }
    956                  }
    957              }
    958          
    959              return (retval);
   \   00000074   0x4618             MOV      R0,R3
   \   00000076   0xE8BD 0x83F0      POP      {R4-R9,PC}
   \                     ??GetDisplacementData_5: (+1)
   \   0000007A   0x1821             ADDS     R1,R4,R0
   \   0000007C   0x7849             LDRB     R1,[R1, #+1]
   \   0000007E   0xFA56 0xF181      UXTAB    R1,R6,R1
   \   00000082   0x5C26             LDRB     R6,[R4, R0]
   \   00000084   0x1B89             SUBS     R1,R1,R6
   \   00000086   0x1B49             SUBS     R1,R1,R5
   \   00000088   0x0049             LSLS     R1,R1,#+1
   \   0000008A   0x8091             STRH     R1,[R2, #+4]
   \   0000008C   0x5C24             LDRB     R4,[R4, R0]
   \   0000008E   0xFA14 0xF485      UXTAH    R4,R4,R5
   \                     ??GetDisplacementData_2: (+1)
   \   00000092   0xEB00 0x0044      ADD      R0,R0,R4, LSL #+1
   \   00000096   0x6010             STR      R0,[R2, #+0]
   \   00000098   0xB289             UXTH     R1,R1
   \   0000009A   0xB901             CBNZ.N   R1,??GetDisplacementData_6
   \   0000009C   0x2302             MOVS     R3,#+2
   \                     ??GetDisplacementData_6: (+1)
   \   0000009E   0x4618             MOV      R0,R3
   \   000000A0   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    960          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     __SetingFile_Start

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     Is_Settingfile_Valid

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x........         DC32     __SetingFile_Size
    961          
    962          #if ((USE_ACU_HARDCODED_SETTING_FILE == ENABLED) || (USE_HMI_HARDCODED_SETTING_FILE == ENABLED))
    963          //---------------------------------------------------------------------------------------------------------------------
    964          /**
    965           * @brief   Checks if the hard coded setting file is valid, if it exists
    966           * @param   sf_id: see SF_ID_TYPE
    967           * @return  TRUE if there is a hard coded setting file for the requested setting file ID and its CRC is valid, else FALSE
    968           */
    969          static BOOL_TYPE IsHardCodedSettingFileValid(SF_ID_TYPE sf_id)
    970          {
    971              BOOL_TYPE crc_matches = FALSE;
    972              uint16 calculated_crc;
    973              uint16 * crc_address = NULL;
    974              uint16 * sf_start_address = NULL;
    975              uint16 stored_crc;
    976          
    977              #if (USE_ACU_HARDCODED_SETTING_FILE == ENABLED) // Note: Intentionally not calling GetSettingFileStartByID() here because this function is limited
    978                  if (sf_id == SF_ID_ACU)                     //       to hard-coded setting files only
    979                  {
    980                      sf_start_address = (void*)&__ACU_Hardcoded_SettingFile_Start;
    981                  }
    982              #endif
    983          
    984              #if (USE_HMI_HARDCODED_SETTING_FILE == ENABLED)
    985                  if (sf_id == SF_ID_HMI)
    986                  {
    987                      sf_start_address = (void*)&__HMI_Hardcoded_SettingFile_Start;
    988                  }
    989              #endif
    990          
    991              if (sf_start_address != NULL)
    992              {
    993                  if (((SF_SECTION_HEADER_TYPE*)(void*)sf_start_address)->Endianess == 0)
    994                  {
    995                      // The section endianess is incorrect. Treat the whole setting file as invalid.
    996                      LOG_ADD_EXCEPTION(UNHANDLED_HARDCODED_ENDIANNESS, sf_id);
    997                  }
    998                  else
    999                  {
   1000                      sf_start_address++;                     // Adjust pointer to skip over the word for the section ID and point to the End Of Section data
   1001                      crc_address = ExtractAbsPointer(sf_start_address, SF_PTR_ACU_CRC);  // Get the address of the CRC stored in the setting file
   1002          
   1003                      if (crc_address != NULL)
   1004                      {
   1005                          calculated_crc = SettingFile__CalculateCRC(sf_id);  // Calculate the CRC based on the data in the setting file memory location
   1006                          stored_crc = (*crc_address);        // Extract the CRC stored in the setting file
   1007          
   1008                          if (stored_crc == calculated_crc)
   1009                          {
   1010                              crc_matches = TRUE;
   1011                          }
   1012                      }
   1013                  }
   1014              }
   1015          
   1016              return(crc_matches);
   1017          }
   1018          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      28   GetDisplacementData
      12   GetSettingFileStartByID
      16   SettingFile__BasicLoader
        16   -> GetDisplacementData
        16   -> GetSettingFileStartByID
      16   SettingFile__CalculateCRC
        16   -> Crc16__ByteProcess
        16   -> GetSettingFileStartByID
      24   SettingFile__CheckDataIntegrity
        24   -> Crc16__RangeProcess
        24   -> SRData__CheckByte
         0   -> SRData__UpdateByte
       0   SettingFile__GetMemorySectionSize
       0   SettingFile__GetMemorySectionStart
      20   SettingFile__GetNumDisplacements
       0   SettingFile__GetNumExtraSF
       8   SettingFile__GetSectionIDs
         8   -> __aeabi_memset
      12   SettingFile__GetSettingFileCRC
       8   SettingFile__GetSettingFilePointerByIndex
         8   -> GetSettingFileStartByID
      20   SettingFile__GetSettingFileSize
      12   SettingFile__GetSettingFileStart
      32   SettingFile__Initialize
        32   -> Crc16__ByteProcess
        32   -> SRData__UpdateByte
      20   SettingFile__IsExtendedDisplacement
      20   SettingFile__IsPlatformPointerUsed
       8   SettingFile__IsValid
         8   -> SRData__CheckByte
      16   SettingFile__MSettingBasicLoader
        16   -> GetDisplacementData
        16   -> GetSettingFileStartByID


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
     164  GetDisplacementData
      72  GetSettingFileStartByID
      10  Is_Settingfile_Valid
          Settingfile_Section_Position
          Settingfile_Flash_Crc
          Settingfile_Flash_Crc_Ptr
          N_Is_Settingfile_Valid
          N_Settingfile_Section_Position
      62  SettingFile__BasicLoader
      60  SettingFile__CalculateCRC
     190  SettingFile__CheckDataIntegrity
       4  SettingFile__GetMemorySectionSize
       4  SettingFile__GetMemorySectionStart
     138  SettingFile__GetNumDisplacements
       4  SettingFile__GetNumExtraSF
      66  SettingFile__GetSectionIDs
      96  SettingFile__GetSettingFileCRC
      16  SettingFile__GetSettingFilePointerByIndex
      82  SettingFile__GetSettingFileSize
      76  SettingFile__GetSettingFileStart
     142  SettingFile__Initialize
     110  SettingFile__IsExtendedDisplacement
     108  SettingFile__IsPlatformPointerUsed
      26  SettingFile__IsValid
      64  SettingFile__MSettingBasicLoader

 
    10 bytes in section .bss
 1 496 bytes in section .text
 
 1 496 bytes of CODE memory
    10 bytes of DATA memory

Errors: none
Warnings: none
