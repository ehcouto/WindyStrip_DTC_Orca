###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        19/Nov/2024  13:15:24
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  Category\Application\MciSensorsWm\MciSensorsWm.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        MciSensorsWm.obj -l ..\listings\MciSensorsWm.lst
#        Category\Application\MciSensorsWm\MciSensorsWm.c
#    List file    =  ..\listings\MciSensorsWm.lst
#    Object file  =  MciSensorsWm.obj
#
###############################################################################

C:\Data\Python\Windy_sBpm_Floating\source\Category\Application\MciSensorsWm\MciSensorsWm.c
      1          /**
      2           *  @file       MciSensorsWm.c
      3           *
      4           *  @brief      Mci Sensors Algorithms for Indesit legacy appliances
      5           *
      6           *  $Header: $
      7           *
      8           *  @copyright  Copyright 2016-$Date$. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
      9           */
     10          //---------------------------------------------------------------------------------------------------------------------
     11          //---------------------------------------------------------------------------------------------------------------------
     12          
     13          
     14          //-------------------------------------- Include Files ----------------------------------------------------------------
     15          #include "MciSensorsWm.h"
     16          #include "Mci.h"
     17          #include "MathCalc.h"
     18          
     19          
     20          
     21          #if (MCI_SENSORS_PARAMETERS_INTERNAL == ENABLED)
     22              #include "MciSensorsWm_prv.h"  //Mca parameters

  #endif  /* MCISENSORSWM_PRV_ */
                                 ^
"C:\Data\Python\Windy_sBpm_Floating\source\ProjectSpecific\Mci\Mcl\MciSensorsWm_prv.h",23  Remark[Pe001]: 
          last line of file ends without a newline
     23          #else
     24          #if (PLATFORM_USED == NUCLEUS_BASED)
     25              #include "string.h"
     26              #include "SettingFile.h"
     27          #else
     28              #include "Params.h"
     29          #endif
     30          #endif
     31          
     32          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     33          
     34          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     35          #ifndef MIN_SINT32
     36              #define MIN_SINT32  -2147483648L
     37          #endif
     38          
     39          #if (MCI_INVERT_DIRECTION == ENABLED)
     40              #define     MOTOR_DIRECTION     -1.0f
     41          #else
     42              #define     MOTOR_DIRECTION      1.0f
     43          #endif
     44          
     45          static BOOL_TYPE ParamsReady;
     46          static MCISENSORSWM_PARAMS_TYPE *MciSensorsWm_Params;
     47          
     48          #if (MCI_MEAN_VALUE_CALC == ENABLED)
     49          // Torque Meaning and Unbalance Index Variables
     50          static uint16 Balance;
     51          static sint16 Torque_Mean;
     52          static float Torque_Mean_F;
     53          static uint16 Mean_Samples_Cnt;
     54          static sint32 Torque_Acc, Vibra_Acc;
     55          static float Torque_Acc_F;
     56          static sint32 Turns_Counter;
     57          static uint16 Unbalance_Cnt;
     58          static uint16 Vibration_Index;
     59          #endif
     60          
     61          #if (MCI_OVERHEATING_WASH == ENABLED)
     62          //Washing Overheating Index Variables
     63          static sint32 IsMotor2_Acc;
     64          static float IsMotor2_Acc_F;
     65          static uint16 OH_Washing_Cnt;
     66          static uint16 OH_Washing_Stop_Flag;
     67          static uint16 OH_Washing_Movement_Flag;
     68          static sint16 OH_Washing_Index;
     69          static float OH_Washing_Index_F;
     70          #endif
     71          
     72          
     73          #if (MCI_POWER_METER == ENABLED)
     74          //Power Meter Variables
     75          static sint16 Motor_Line_Power; 		//W
     76          static sint16 Motor_Line_Energy_Low; 	//Ws
     77          static sint16 Motor_Line_Energy_High; 	//Ws
     78          static sint32 Energy_BackUp; 			//Ws //TODO: put it in back section
     79          static sint32 Energy_K; 				//Ws
     80          static sint32 Energy_K_1; 				//Ws
     81          #endif
     82          
     83          
     84          #if (MCI_DRUM_LOAD_AVERAGE == ENABLED)
     85          // Drum Load Average Variables
     86          static sint64 Drum_Load_Torque_Acc;
     87          static uint32 Drum_Load_Torque_Samples_Cnt;
     88          static float Drum_Load_Torque;
     89          #endif
     90          
     91          
     92          #if (MCI_SENSORS_PARAMETERS_INTERNAL == ENABLED)
     93          
     94          #else
     95          #if (PLATFORM_USED == NUCLEUS_BASED)
     96          #define MCA_SENSORS_WM_PARAMETERS_SIZE              sizeof(MCISENSORSWM_PARAMS_TYPE)
     97          
     98          SETTINGFILE_LOADER_TYPE Mca_Sensors_Wm_Prm_Flash_Ptr;
     99          uint8 Mca_Sensors_Wm_Prm_Ram[MCA_SENSORS_WM_PARAMETERS_SIZE];
    100          #else
    101          PARAMS_LOADER_TYPE Mca_Sensors_Wm_Prm_Ram;
    102          #endif
    103          #endif
    104          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
    105          #if (MCI_MEAN_VALUE_CALC == ENABLED)
    106          static void MeanValueCalc(void);
    107          static void MeanValueCalc_Reset(void);
    108          #endif
    109          
    110          #if (MCI_OVERHEATING_WASH == ENABLED)
    111          static void OverHeating_Washing(void);
    112          #endif
    113          
    114          #if (MCI_POWER_METER == ENABLED)
    115          static void PowerMeter(void);
    116          #endif
    117          
    118          #if (MCI_DRUM_LOAD_AVERAGE == ENABLED)
    119          static void Drum_Load_Average(void);
    120          #endif
    121          //=====================================================================================================================
    122          //-------------------------------------- Public Functions -------------------------------------------------------------
    123          //=====================================================================================================================
    124          
    125          
    126          //---------------------------------------------------------------------------------------------------------------------
    127          /**
    128           *  @brief      It Initializes the module MciSensorsWm and its variables.
    129           *
    130           */

   \                                 In section .text, align 2, keep-with-next
    131          void MciSensorsWm__Initialize(void)
    132          {
    133              ParamsReady = FALSE;
    134          
    135          #if (MCI_SENSORS_PARAMETERS_INTERNAL == ENABLED)
    136              MciSensorsWm_Params = (MCISENSORSWM_PARAMS_TYPE *) (&MciSensorsWm_Params_SF[0]);
   \                     MciSensorsWm__Initialize: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   00000004   0xF100 0x0148      ADD      R1,R0,#+72
   \   00000008   0x61C1             STR      R1,[R0, #+28]
    137              ParamsReady = TRUE;
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x7201             STRB     R1,[R0, #+8]
    138          #else
    139              #if (PLATFORM_USED == NUCLEUS_BASED)
    140              if((SettingFile__IsValid() == TRUE) &&
    141                  (SettingFile__BasicLoader(SF_PTR_MCU_MCA, SF_DISPL_MOTOR_MCI_SENSORS_WM, &Mca_Sensors_Wm_Prm_Flash_Ptr) == PASS))
    142              {
    143                  memcpy(&Mca_Sensors_Wm_Prm_Ram, Mca_Sensors_Wm_Prm_Flash_Ptr.Data, Mca_Sensors_Wm_Prm_Flash_Ptr.Length); //Copy from Flash to RAM
    144                  MciSensorsWm_Params = (MCISENSORSWM_PARAMS_TYPE *) (&Mca_Sensors_Wm_Prm_Ram);
    145                  ParamsReady = TRUE;
    146              }
    147              #else
    148              if(Params__BasicLoader(SF_PTR_MCU_MCA, SF_DISPL_MOTOR_MCI_SENSORS_WM, &Mca_Sensors_Wm_Prm_Ram) == PASS)
    149              {
    150                  MciSensorsWm_Params = (MCISENSORSWM_PARAMS_TYPE *) (Mca_Sensors_Wm_Prm_Ram.Data);
    151                  ParamsReady = TRUE;
    152              }
    153              #endif
    154          #endif
    155          
    156          #if (MCI_MEAN_VALUE_CALC == ENABLED)
    157          	MeanValueCalc_Reset();
   \   0000000E   0x2100             MOVS     R1,#+0
    158          #endif
    159          
    160          #if (MCI_OVERHEATING_WASH == ENABLED)
    161              //Overheating washing initialize
    162              IsMotor2_Acc = 0;
    163              IsMotor2_Acc_F = 0.0f;
    164              OH_Washing_Index = 0;
    165              OH_Washing_Index_F = 0.0f;
    166              OH_Washing_Cnt = 0;
    167              OH_Washing_Stop_Flag = 0;
    168              OH_Washing_Movement_Flag = 0;
    169          #endif
    170          
    171          #if (MCI_POWER_METER == ENABLED)
    172              Energy_BackUp = 0;
    173          #endif
    174          
    175          
    176          #if (MCI_DRUM_LOAD_AVERAGE == ENABLED)
    177              Drum_Load_Torque_Acc = 0;
   \   00000010   0xE9C0 0x1100      STRD     R1,R1,[R0, #+0]
   \   00000014   0x6241             STR      R1,[R0, #+36]
   \   00000016   0x62C1             STR      R1,[R0, #+44]
   \   00000018   0x6281             STR      R1,[R0, #+40]
   \   0000001A   0x6301             STR      R1,[R0, #+48]
   \   0000001C   0x60C1             STR      R1,[R0, #+12]
   \   0000001E   0x6201             STR      R1,[R0, #+32]
   \   00000020   0x8141             STRH     R1,[R0, #+10]
   \   00000022   0x6101             STR      R1,[R0, #+16]
   \   00000024   0x6341             STR      R1,[R0, #+52]
   \   00000026   0x6381             STR      R1,[R0, #+56]
   \   00000028   0x63C1             STR      R1,[R0, #+60]
   \   0000002A   0x6141             STR      R1,[R0, #+20]
   \   0000002C   0x6181             STR      R1,[R0, #+24]
    178              Drum_Load_Torque_Samples_Cnt = 0;
   \   0000002E   0x6401             STR      R1,[R0, #+64]
    179              Drum_Load_Torque = 0.0f;
   \   00000030   0x6441             STR      R1,[R0, #+68]
    180          #endif
    181          
    182          }
   \   00000032   0x4770             BX       LR               ;; return
    183          
    184          
    185          //---------------------------------------------------------------------------------------------------------------------
    186          /**
    187           *  @brief      Feeds back if Mci Set module parameters are loaded.
    188           *
    189           *  @param      none
    190           *  @return     TRUE: parameters are loaded / FALSE: parameters are not loaded
    191           */

   \                                 In section .text, align 2, keep-with-next
    192          BOOL_TYPE MciSensorsWm__IsParamsReady(void)
    193          {
    194              return(ParamsReady);
   \                     MciSensorsWm__IsParamsReady: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   00000004   0x7A00             LDRB     R0,[R0, #+8]
   \   00000006   0x4770             BX       LR               ;; return
    195          }
    196          
    197          
    198          
    199          //---------------------------------------------------------------------------------------------------------------------
    200          /**
    201           *  @brief      Mci Sensors Wm  1ms handler
    202           *
    203           */

   \                                 In section .text, align 2, keep-with-next
    204          void MciSensorsWm__1msHandler(void)
    205          {
    206          	static unsigned char routine_post_scaler = 0;
    207          
    208          	routine_post_scaler++;
   \                     MciSensorsWm__1msHandler: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   00000004   0x7A41             LDRB     R1,[R0, #+9]
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   \   00000008   0x7241             STRB     R1,[R0, #+9]
    209          
    210          	if (ParamsReady == TRUE)
   \   0000000A   0x7A00             LDRB     R0,[R0, #+8]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD103             BNE.N    ??MciSensorsWm__1msHandler_0
    211              {
    212          
    213              	if(routine_post_scaler & 0x01)
   \   00000010   0x07C8             LSLS     R0,R1,#+31
   \   00000012   0xBF48             IT       MI 
    214              	{
    215              		// 2 ms handler
    216              		#if (MCI_MEAN_VALUE_CALC == ENABLED)
    217              		{
    218              			MeanValueCalc();
   \   00000014   0x.... 0x....      BMI.W    MeanValueCalc
    219              		}
    220              		#endif
    221              	}
    222              }
    223          }
   \                     ??MciSensorsWm__1msHandler_0: (+1)
   \   00000018   0x4770             BX       LR               ;; return

   \                                 In section .data, align 8
   \                     Drum_Load_Torque_Acc:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000008   0x00               DC8 0
   \   00000009   0x00               DC8 0
   \   0000000A   0x00 0x00          DC8 0, 0
   \   0000000C   0x00 0x00          DC8 0, 0
   \   0000000E   0x00 0x00          DC8 0, 0
   \   00000010   0x00 0x00          DC8 0, 0
   \   00000012   0x00 0x00          DC8 0, 0
   \   00000014   0x00 0x00          DC8 0, 0
   \   00000016   0x00 0x00          DC8 0, 0
   \   00000018   0x00 0x00          DC8 0, 0
   \   0000001A   0x00 0x00          DC8 0, 0
   \   0000001C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000020   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000024   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000028   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000002C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000030   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000034   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000038   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000003C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000040   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000044   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   __absolute unsigned short MciSensorsWm_Params_SF[6]
   \                     MciSensorsWm_Params_SF:
   \   00000048   0x0118 0x0BA3      DC16 280, 2979, 1035, 0, 15729, 16698
   \              0x040B 0x0000
   \              0x3D71 0x413A
    224          
    225          
    226          //---------------------------------------------------------------------------------------------------------------------
    227          /**
    228           *  @brief      Sensors and Algorithms 5ms handler
    229           *
    230           */

   \                                 In section .text, align 2, keep-with-next
    231          void MciSensorsWm__5msHandler(void)
    232          {
   \                     MciSensorsWm__5msHandler: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    233              if (ParamsReady == TRUE)
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable9_3
   \   00000006   0x7A20             LDRB     R0,[R4, #+8]
   \   00000008   0xB081             SUB      SP,SP,#+4
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD134             BNE.N    ??MciSensorsWm__5msHandler_0
    234              {
    235          
    236          #if (MCI_OVERHEATING_WASH == ENABLED)
    237                  OverHeating_Washing();
   \   0000000E   0x.... 0x....      BL       OverHeating_Washing
    238          #endif
    239          
    240          #if (MCI_POWER_METER == ENABLED)
    241                  PowerMeter();
    242          #endif
    243          
    244          #if (MCI_DRUM_LOAD_AVERAGE == ENABLED)
    245                  Drum_Load_Average();
   \   00000012   0x2104             MOVS     R1,#+4
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      BL       Mci__GetDigital
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD110             BNE.N    ??MciSensorsWm__5msHandler_1
   \   0000001E   0x210A             MOVS     R1,#+10
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      BL       Mci__GetAnalog
   \   00000026   0xE9D4 0x2300      LDRD     R2,R3,[R4, #+0]
   \   0000002A   0x17C1             ASRS     R1,R0,#+31
   \   0000002C   0xEB12 0x10A0      ADDS     R0,R2,R0, ASR #+6
   \   00000030   0x4159             ADCS     R1,R3,R1
   \   00000032   0xE9C4 0x0100      STRD     R0,R1,[R4, #+0]
    246          #endif
    247              }
    248          	else //parameters not loaded
    249              {
    250                  #if (MCI_SENSORS_PARAMETERS_INTERNAL == ENABLED)
    251          
    252                  MciSensorsWm_Params = (MCISENSORSWM_PARAMS_TYPE *) (&MciSensorsWm_Params_SF[0]);
    253                  ParamsReady = TRUE;
    254          
    255                  #else
    256                  #if (PLATFORM_USED == NUCLEUS_BASED)
    257                  if((SettingFile__IsValid() == TRUE) &&
    258                      (SettingFile__BasicLoader(SF_PTR_MCU_MCA, SF_DISPL_MOTOR_MCI_SENSORS_WM, &Mca_Sensors_Wm_Prm_Flash_Ptr) == PASS))
    259                  {
    260                      memcpy(&Mca_Sensors_Wm_Prm_Ram, Mca_Sensors_Wm_Prm_Flash_Ptr.Data, Mca_Sensors_Wm_Prm_Flash_Ptr.Length); //Copy from Flash to RAM
    261                      MciSensorsWm_Params = (MCISENSORSWM_PARAMS_TYPE *) (&Mca_Sensors_Wm_Prm_Ram);
    262                      ParamsReady = TRUE;
    263                  }
    264                  #else
    265                  if(Params__BasicLoader(SF_PTR_MCU_MCA, SF_DISPL_MOTOR_MCI_SENSORS_WM, &Mca_Sensors_Wm_Prm_Ram) == PASS)
    266                  {
    267          
    268                      MciSensorsWm_Params = (MCISENSORSWM_PARAMS_TYPE *) (Mca_Sensors_Wm_Prm_Ram.Data);
    269                      ParamsReady = TRUE;
    270                  }
    271                  #endif
    272                  #endif
    273              }
    274          }
   \   00000036   0xB001             ADD      SP,SP,#+4
   \   00000038   0x6C20             LDR      R0,[R4, #+64]
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \   0000003C   0x6420             STR      R0,[R4, #+64]
   \   0000003E   0xBD30             POP      {R4,R5,PC}
   \                     ??MciSensorsWm__5msHandler_1: (+1)
   \   00000040   0x6C25             LDR      R5,[R4, #+64]
   \   00000042   0xB1F5             CBZ.N    R5,??MciSensorsWm__5msHandler_2
   \   00000044   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \   00000048   0x.... 0x....      BL       __aeabi_l2f
   \   0000004C   0xEE00 0x0A10      VMOV     S0,R0
   \   00000050   0x69E0             LDR      R0,[R4, #+28]
   \   00000052   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   00000056   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000005A   0x02A8             LSLS     R0,R5,#+10
   \   0000005C   0xEE00 0x0A90      VMOV     S1,R0
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \   00000066   0xE9C4 0x0000      STRD     R0,R0,[R4, #+0]
   \   0000006A   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   0000006E   0xED84 0x0A11      VSTR     S0,[R4, #+68]
   \   00000072   0x6420             STR      R0,[R4, #+64]
   \   00000074   0xB001             ADD      SP,SP,#+4
   \   00000076   0xBD30             POP      {R4,R5,PC}
   \                     ??MciSensorsWm__5msHandler_0: (+1)
   \   00000078   0xF104 0x0048      ADD      R0,R4,#+72
   \   0000007C   0x61E0             STR      R0,[R4, #+28]
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0x7220             STRB     R0,[R4, #+8]
   \                     ??MciSensorsWm__5msHandler_2: (+1)
   \   00000082   0xB001             ADD      SP,SP,#+4
   \   00000084   0xBD30             POP      {R4,R5,PC}       ;; return
    275          
    276          
    277          //---------------------------------------------------------------------------------------------------------------------
    278          /**
    279           *  @brief      Read an integer analog value
    280           *
    281           *  @param[in]  read_data Index to the parameter. See the @ref MciSensorsWm.h file
    282           *
    283           *  @return     the parameter value.
    284           *              The default return is zero.
    285           *              Not implemented functions returns -1
    286           */

   \                                 In section .text, align 2, keep-with-next
    287          sint16 MciSensorsWm__GetIndesitAnalog(MCISENSORSWM_AI_TYPE read_data)
    288          {
    289              sint16 ret_val = -32768;
   \                     MciSensorsWm__GetIndesitAnalog: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable9_4  ;; 0xffff8000
    290          
    291              switch(read_data)
   \   00000004   0x2819             CMP      R0,#+25
   \   00000006   0xD009             BEQ.N    ??MciSensorsWm__GetIndesitAnalog_0
   \   00000008   0xD312             BCC.N    ??MciSensorsWm__GetIndesitAnalog_1
   \   0000000A   0x281B             CMP      R0,#+27
   \   0000000C   0xD00C             BEQ.N    ??MciSensorsWm__GetIndesitAnalog_2
   \   0000000E   0xBF3C             ITT      CC 
    292              {
    293          
    294          #if (MCI_MEAN_VALUE_CALC == ENABLED)
    295              	case MCISENSORSWM_AI_TORQUE_MEAN:
    296                      ret_val = (sint16)(Torque_Mean);
    297                      break;
    298          
    299                  case MCISENSORSWM_AI_BALANCE:
    300                      ret_val = (sint16)(Balance);
   \   00000010   0x.... 0x....      LDRCC.W  R0,??DataTable9_3
   \   00000014   0xF9B0 0x100A      LDRSHCC  R1,[R0, #+10]
    301                      break;
    302          #endif
    303          
    304          #if (MCI_OVERHEATING_WASH == ENABLED)
    305                  case MCISENSORSWM_AI_OVERHEATING_WASHING:
    306                      ret_val = (sint16)(OH_Washing_Index);
    307                      break;
    308          #endif
    309          
    310          #if (MCI_POWER_METER == ENABLED)
    311                  case MCISENSORSWM_AI_MOTOR_LINE_POWER:
    312                      ret_val = (sint16)(Motor_Line_Power);
    313                      break;
    314          
    315                  case MCISENSORSWM_AI_MOTOR_LINE_POWER_HI:
    316                  	ret_val = (sint16)(Motor_Line_Energy_High);
    317                  	break;
    318          
    319                  case MCISENSORSWM_AI_MOTOR_LINE_POWER_LO:
    320          		   ret_val = (sint16)(Motor_Line_Energy_Low);
    321          		   break;
    322          #endif
    323          
    324                  default:
    325                      //
    326                      break;
    327              }
    328          
    329              return(ret_val);
   \   00000018   0x4608             MOV      R0,R1
   \   0000001A   0x4770             BX       LR
   \                     ??MciSensorsWm__GetIndesitAnalog_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   00000020   0xF9B0 0x100C      LDRSH    R1,[R0, #+12]
   \   00000024   0x4608             MOV      R0,R1
   \   00000026   0x4770             BX       LR
   \                     ??MciSensorsWm__GetIndesitAnalog_2: (+1)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   0000002C   0xF9B0 0x101A      LDRSH    R1,[R0, #+26]
   \                     ??MciSensorsWm__GetIndesitAnalog_1: (+1)
   \   00000030   0x4608             MOV      R0,R1
   \   00000032   0x4770             BX       LR               ;; return
    330          }
    331          
    332          
    333          
    334          //---------------------------------------------------------------------------------------------------------------------
    335          /**
    336           *  @brief      Read an integer analog value
    337           *
    338           *  @param[in]  read_data Index to the parameter. See the @ref MciSensorsWm.h file
    339           *
    340           *  @return     the parameter value.
    341           *              The default return is zero.
    342           *              Not implemented functions returns -1
    343           */

   \                                 In section .text, align 4, keep-with-next
    344          sint32 MciSensorsWm__GetAnalog(MOTOR_ENUM_TYPE motor, MCISENSORSWM_AI_TYPE read_data)
    345          {
   \                     MciSensorsWm__GetAnalog: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4602             MOV      R2,R0
   \   00000004   0x460C             MOV      R4,R1
    346              sint32 ret_val = MIN_SINT32;
   \   00000006   0xF04F 0x4000      MOV      R0,#-2147483648
    347          
    348              if ((MCI_AI_TYPE) read_data < MCI_AI_NR_OF_AI)
   \   0000000A   0x2C19             CMP      R4,#+25
   \   0000000C   0xBFBC             ITT      LT 
    349              {
    350                  ret_val = Mci__GetAnalog(motor, (MCI_AI_TYPE) read_data);
   \   0000000E   0x4610             MOVLT    R0,R2
   \   00000010   0x.... 0x....      BLLT     Mci__GetAnalog
    351              }
    352          
    353              switch(read_data)
   \   00000014   0x2C1D             CMP      R4,#+29
   \   00000016   0xD84B             BHI.N    ??MciSensorsWm__GetAnalog_1
   \   00000018   0xE8DF 0xF004      TBB      [PC, R4]
   \                     ??MciSensorsWm__GetAnalog_0:
   \   0000001C   0x0F 0x0F          DC8      0xF,0xF,0xF,0xF
   \              0x0F 0x0F    
   \   00000020   0x0F 0x4A          DC8      0xF,0x4A,0x4A,0x4A
   \              0x4A 0x4A    
   \   00000024   0x4A 0x4A          DC8      0x4A,0x4A,0x22,0x4A
   \              0x22 0x4A    
   \   00000028   0x4A 0x4A          DC8      0x4A,0x4A,0x4A,0x4A
   \              0x4A 0x4A    
   \   0000002C   0x4A 0x4A          DC8      0x4A,0x4A,0x4A,0x4A
   \              0x4A 0x4A    
   \   00000030   0x4A 0x4A          DC8      0x4A,0x4A,0x4A,0x4A
   \              0x4A 0x4A    
   \   00000034   0x4A 0x34          DC8      0x4A,0x34,0x38,0x3F
   \              0x38 0x3F    
   \   00000038   0x43 0x3C          DC8      0x43,0x3C
    354              {
    355          
    356                  case MCISENSORSWM_AI_TARGET_SPEED_RPM_S16:
    357                  case MCISENSORSWM_AI_SPEED_REFERENCE_RPM_S16:
    358                  case MCISENSORSWM_AI_ACTUAL_SPEED_S16:
    359                  case MCISENSORSWM_AI_SPEED_ERROR_RPM_S16:
    360                  case MCISENSORSWM_AI_MEAN_SPEED_S16:
    361                      {
    362                          float32 new_val = ret_val / MciSensorsWm__GetTransmissionRatio();
   \                     ??MciSensorsWm__GetAnalog_2: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \   0000003E   0x7A0A             LDRB     R2,[R1, #+8]
   \   00000040   0xEEB7 0x0A00      VMOV.F32 S0,#1.0
   \   00000044   0x2A01             CMP      R2,#+1
   \   00000046   0xBF04             ITT      EQ 
   \   00000048   0x69C9             LDREQ    R1,[R1, #+28]
   \   0000004A   0xED91 0x0A02      VLDREQ   S0,[R1, #+8]
    363                          ret_val = (sint32) new_val;
   \   0000004E   0xEE00 0x0A90      VMOV     S1,R0
   \   00000052   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000056   0xEE80 0x0A80      VDIV.F32 S0,S1,S0
   \   0000005A   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000005E   0xE025             B.N      ??MciSensorsWm__GetAnalog_3
    364                      }
    365                      break;
    366          
    367                  case MCISENSORSWM_AI_LOAD_TORQUE_S16:
    368                      {
    369                          float32 new_val = ret_val * MciSensorsWm__GetTransmissionRatio();
   \                     ??MciSensorsWm__GetAnalog_4: (+1)
   \   00000060   0x....             LDR.N    R1,??DataTable9_3
   \   00000062   0x7A0A             LDRB     R2,[R1, #+8]
   \   00000064   0xEEB7 0x0A00      VMOV.F32 S0,#1.0
   \   00000068   0x2A01             CMP      R2,#+1
   \   0000006A   0xBF04             ITT      EQ 
   \   0000006C   0x69C9             LDREQ    R1,[R1, #+28]
   \   0000006E   0xED91 0x0A02      VLDREQ   S0,[R1, #+8]
    370                          ret_val = (sint32) new_val;
   \   00000072   0xEE00 0x0A90      VMOV     S1,R0
   \   00000076   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   0000007A   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   0000007E   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000082   0xE013             B.N      ??MciSensorsWm__GetAnalog_3
    371                      }
    372                      break;
    373          
    374          #if (MCI_MEAN_VALUE_CALC == ENABLED)
    375                  case MCISENSORSWM_AI_TORQUE_MEAN:
    376                      ret_val = (sint32)(Torque_Mean_F*65536.0f);
   \                     ??MciSensorsWm__GetAnalog_5: (+1)
   \   00000084   0x....             LDR.N    R0,??DataTable9_3
   \   00000086   0xED90 0x0A08      VLDR     S0,[R0, #+32]
   \   0000008A   0xE00D             B.N      ??MciSensorsWm__GetAnalog_6
    377                      break;
    378          
    379                  case MCISENSORSWM_AI_BALANCE:
    380                      ret_val = (sint32)(Balance << 16);
   \                     ??MciSensorsWm__GetAnalog_7: (+1)
   \   0000008C   0x....             LDR.N    R0,??DataTable9_3
   \   0000008E   0x8940             LDRH     R0,[R0, #+10]
   \   00000090   0x0400             LSLS     R0,R0,#+16
    381                      break;
   \   00000092   0xBD10             POP      {R4,PC}
    382          
    383                  case MCISENSORSWM_AI_BALANCE_COUNT:
    384                  	ret_val = (sint32)Unbalance_Cnt;
   \                     ??MciSensorsWm__GetAnalog_8: (+1)
   \   00000094   0x....             LDR.N    R0,??DataTable9_3
   \   00000096   0x8A00             LDRH     R0,[R0, #+16]
    385                  	break;
   \   00000098   0xBD10             POP      {R4,PC}
    386          #endif
    387          
    388          #if (MCI_OVERHEATING_WASH == ENABLED)
    389                  case MCISENSORSWM_AI_OVERHEATING_WASHING:
    390                      ret_val = (sint32)(OH_Washing_Index_F*65536.0f);
   \                     ??MciSensorsWm__GetAnalog_9: (+1)
   \   0000009A   0x....             LDR.N    R0,??DataTable9_3
   \   0000009C   0xED90 0x0A0F      VLDR     S0,[R0, #+60]
   \   000000A0   0xE002             B.N      ??MciSensorsWm__GetAnalog_6
    391                      break;
    392          #endif
    393          
    394          #if (MCI_DRUM_LOAD_AVERAGE == ENABLED)
    395                  case MCISENSORSWM_AI_DRUM_LOAD_AVERAGE:
    396                      ret_val = (sint32)(Drum_Load_Torque*65536.0f);
   \                     ??MciSensorsWm__GetAnalog_10: (+1)
   \   000000A2   0x....             LDR.N    R0,??DataTable9_3
   \   000000A4   0xED90 0x0A11      VLDR     S0,[R0, #+68]
   \                     ??MciSensorsWm__GetAnalog_6: (+1)
   \   000000A8   0xEEBE 0x0AC8      VCVT.S32.F32 S0,S0,#+16
   \                     ??MciSensorsWm__GetAnalog_3: (+1)
   \   000000AC   0xEE10 0x0A10      VMOV     R0,S0
    397                      break;
    398          #endif
    399          
    400                  default:
    401                      //
    402                      break;
    403              }
    404          
    405              return(ret_val);
   \                     ??MciSensorsWm__GetAnalog_1: (+1)
   \   000000B0   0xBD10             POP      {R4,PC}          ;; return
    406          }
    407          
    408          
    409          //---------------------------------------------------------------------------------------------------------------------
    410          /**
    411           *  @brief      Read an float analog value
    412           *
    413           *  @param[in]  read_data Index to the parameter. See the @ref MciSensorsWm.h file
    414           *
    415           *  @return     the parameter value.
    416           *              The default return is zero.
    417           *              Not implemented functions returns -1
    418           */

   \                                 In section .text, align 4, keep-with-next
    419          float MciSensorsWm__GetFloatAnalog(MCISENSORSWM_FLOAT_AI_TYPE read_data)
    420          {
    421              float ret_val;
    422          
    423              ret_val = -32768.0f;
   \                     MciSensorsWm__GetFloatAnalog: (+1)
   \   00000000   0xED9F 0x....      VLDR.W   S0,??DataTable9  ;; 0xc7000000
    424          
    425              switch(read_data)
   \   00000004   0xB118             CBZ.N    R0,??MciSensorsWm__GetFloatAnalog_0
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD009             BEQ.N    ??MciSensorsWm__GetFloatAnalog_1
   \   0000000A   0xD304             BCC.N    ??MciSensorsWm__GetFloatAnalog_2
   \   0000000C   0x4770             BX       LR
    426              {
    427          
    428          #if (MCI_MEAN_VALUE_CALC == ENABLED)
    429                  case MCISENSORSWM_FLOAT_AI_TORQUE_MEAN:
    430                      ret_val = Torque_Mean_F;
   \                     ??MciSensorsWm__GetFloatAnalog_0: (+1)
   \   0000000E   0x....             LDR.N    R0,??DataTable9_3
   \   00000010   0xED90 0x0A08      VLDR     S0,[R0, #+32]
    431                      break;
   \   00000014   0x4770             BX       LR
    432          #endif
    433          
    434          #if (MCI_OVERHEATING_WASH == ENABLED)
    435                  case MCISENSORSWM_FLOAT_AI_OVERHEATING_WASHING:
    436                      ret_val = OH_Washing_Index_F;
   \                     ??MciSensorsWm__GetFloatAnalog_2: (+1)
   \   00000016   0x....             LDR.N    R0,??DataTable9_3
   \   00000018   0xED90 0x0A0F      VLDR     S0,[R0, #+60]
    437                      break;
   \   0000001C   0x4770             BX       LR
    438          #endif
    439          
    440          
    441          #if (MCI_DRUM_LOAD_AVERAGE == ENABLED)
    442                  case MCISENSORSWM_FLOAT_AI_DRUM_LOAD_AVERAGE:
    443                      ret_val = Drum_Load_Torque;
   \                     ??MciSensorsWm__GetFloatAnalog_1: (+1)
   \   0000001E   0x....             LDR.N    R0,??DataTable9_3
   \   00000020   0xED90 0x0A11      VLDR     S0,[R0, #+68]
    444                      break;
    445          #endif
    446                  default:
    447                      //
    448                      break;
    449              }
    450          
    451              return ret_val;
   \   00000024   0x4770             BX       LR               ;; return
    452          }
    453          
    454          //---------------------------------------------------------------------------------------------------------------------
    455          /**
    456           *  @brief      Returns Tramsission Ratio
    457           *
    458           *  @return     Transmission Ratio value with default motor direction (1 or -1)
    459           *              If no parameters are read, it return 1.0 or -1.0
    460           */

   \                                 In section .text, align 2, keep-with-next
    461          float32 MciSensorsWm__GetTransmissionRatio(void)
    462          {
    463              float32 ratio = MOTOR_DIRECTION;
    464          
    465              if (ParamsReady == TRUE)
   \                     MciSensorsWm__GetTransmissionRatio: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable9_3
   \   00000002   0x7A01             LDRB     R1,[R0, #+8]
   \   00000004   0xEEB7 0x0A00      VMOV.F32 S0,#1.0
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xBF04             ITT      EQ 
    466              {
    467                  ratio *= MciSensorsWm_Params->Transmission_Ratio;
   \   0000000C   0x69C0             LDREQ    R0,[R0, #+28]
   \   0000000E   0xED90 0x0A02      VLDREQ   S0,[R0, #+8]
    468              }
    469          
    470              return(ratio);
   \   00000012   0x4770             BX       LR               ;; return
    471          }
    472          
    473          
    474          //=====================================================================================================================
    475          //-------------------------------------- Private Functions ------------------------------------------------------------
    476          //=====================================================================================================================
    477          #if (MCI_MEAN_VALUE_CALC == ENABLED)

   \                                 In section .text, align 2, keep-with-next
    478          static void MeanValueCalc(void)
    479          {
   \                     MeanValueCalc: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    480              sint16 torque;                  // torque = result of torque estimator
    481              float torque_f;                 // torque = result of torque estimator
    482              sint16 torque_mean;
    483              float torque_mean_f;
    484              sint16 mean_over_drum_rev;
    485              uint16 temp_vibration_index;
    486              
    487              
    488              if(Mci__GetDigital(MOTOR0, MCI_DI_MOTOR_RUNNING) == TRUE)
   \   00000004   0x....             LDR.N    R4,??DataTable9_3
   \   00000006   0xED2D 0x8B02      VPUSH    {D8}
   \   0000000A   0x2104             MOVS     R1,#+4
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       Mci__GetDigital
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xF040 0x80A1      BNE.W    ??MeanValueCalc_0
    489              {
    490                  torque = Mci__GetAnalog(MOTOR0, MCI_AI_LOAD_TORQUE_S16)>>TORQUE_NM256_2_PU_SHIFT; //TODO: put the shift into parameters
   \   00000018   0x210A             MOVS     R1,#+10
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      BL       Mci__GetAnalog
   \   00000020   0x0345             LSLS     R5,R0,#+13
   \   00000022   0x142D             ASRS     R5,R5,#+16
    491                  torque_f = (1.0f/65536.0f) * Mci__GetAnalog(MOTOR0, MCI_AI_LOAD_TORQUE_S16) * (MciSensorsWm_Params->Transmission_Ratio * MOTOR_DIRECTION); //Nm_Drum
   \   00000024   0x210A             MOVS     R1,#+10
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x.... 0x....      BL       Mci__GetAnalog
   \   0000002C   0xEE00 0x0A10      VMOV     S0,R0
    492          
    493                  // Accumulator update
    494                  Torque_Acc = Torque_Acc + torque;
   \   00000030   0x6A60             LDR      R0,[R4, #+36]
    495                  Torque_Acc_F = Torque_Acc_F + torque_f;
   \   00000032   0xED94 0x1A0B      VLDR     S2,[R4, #+44]
   \   00000036   0x1828             ADDS     R0,R5,R0
   \   00000038   0x6260             STR      R0,[R4, #+36]
   \   0000003A   0xEEBA 0x0AC8      VCVT.F32.S32 S0,S0,#+16
   \   0000003E   0x69E0             LDR      R0,[R4, #+28]
   \   00000040   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
    496                  Vibra_Acc = Vibra_Acc + MATHCALC__ABS(torque - Torque_Mean);
   \   00000044   0xF9B4 0x000C      LDRSH    R0,[R4, #+12]
   \   00000048   0xEE00 0x1A20      VMLA.F32 S2,S0,S1
   \   0000004C   0xED84 0x1A0B      VSTR     S2,[R4, #+44]
   \   00000050   0x1A28             SUBS     R0,R5,R0
   \   00000052   0xBF48             IT       MI 
   \   00000054   0x4240             RSBMI    R0,R0,#+0
   \   00000056   0x6AA1             LDR      R1,[R4, #+40]
   \   00000058   0x1840             ADDS     R0,R0,R1
   \   0000005A   0x62A0             STR      R0,[R4, #+40]
    497          
    498                  Turns_Counter += IQMATH__I1Q31MULI1Q15(MciSensorsWm_Params->K_Turns, MATHCALC__ABS((Mci__GetAnalog(MOTOR0, MCI_AI_ACTUAL_SPEED_S16)>>16)));
   \   0000005C   0x2102             MOVS     R1,#+2
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x.... 0x....      BL       Mci__GetAnalog
   \   00000064   0x1400             ASRS     R0,R0,#+16
   \   00000066   0xD506             BPL.N    ??MeanValueCalc_1
   \   00000068   0x2102             MOVS     R1,#+2
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x.... 0x....      BL       Mci__GetAnalog
   \   00000070   0x1400             ASRS     R0,R0,#+16
   \   00000072   0x4240             RSBS     R0,R0,#+0
   \   00000074   0xE004             B.N      ??MeanValueCalc_2
   \                     ??MeanValueCalc_1: (+1)
   \   00000076   0x2102             MOVS     R1,#+2
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x.... 0x....      BL       Mci__GetAnalog
   \   0000007E   0x1400             ASRS     R0,R0,#+16
   \                     ??MeanValueCalc_2: (+1)
   \   00000080   0x69E2             LDR      R2,[R4, #+28]
   \   00000082   0x6B21             LDR      R1,[R4, #+48]
   \   00000084   0xF9B2 0x2000      LDRSH    R2,[R2, #+0]
   \   00000088   0x4350             MULS     R0,R0,R2
   \   0000008A   0xEB01 0x0040      ADD      R0,R1,R0, LSL #+1
   \   0000008E   0x6320             STR      R0,[R4, #+48]
    499                  
    500                  Mean_Samples_Cnt++;
    501          
    502                  // check spinning region
    503          		if((Mci__GetAnalog(MOTOR0, MCI_AI_TARGET_SPEED_RPM_S16)>>16) > MciSensorsWm_Params->Spinning_Thr_Speed)
   \   00000090   0x2100             MOVS     R1,#+0
   \   00000092   0x89E0             LDRH     R0,[R4, #+14]
   \   00000094   0x1C40             ADDS     R0,R0,#+1
   \   00000096   0x81E0             STRH     R0,[R4, #+14]
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x.... 0x....      BL       Mci__GetAnalog
   \   0000009E   0x69E1             LDR      R1,[R4, #+28]
   \   000000A0   0xF9B1 0x2002      LDRSH    R2,[R1, #+2]
   \   000000A4   0xF9B1 0x1004      LDRSH    R1,[R1, #+4]
   \   000000A8   0xEBB1 0x4F20      CMP      R1,R0, ASR #+16
   \   000000AC   0xBFB8             IT       LT 
    504          		{
    505          			mean_over_drum_rev = MciSensorsWm_Params->Mean_Over_Drum_Rev << 2;
   \   000000AE   0x0092             LSLLT    R2,R2,#+2
    506          		}
    507          		else
    508          		{
    509          			mean_over_drum_rev = MciSensorsWm_Params->Mean_Over_Drum_Rev;
    510          		}
    511          
    512                  if (IQMATH__IQ2IQ(Turns_Counter, IQ31, IQ15) >= mean_over_drum_rev)
   \   000000B0   0x6B20             LDR      R0,[R4, #+48]
   \   000000B2   0x1400             ASRS     R0,R0,#+16
   \   000000B4   0xB212             SXTH     R2,R2
   \   000000B6   0x4290             CMP      R0,R2
   \   000000B8   0xDB58             BLT.N    ??MeanValueCalc_3
    513                  {
    514                      // clear turns counter
    515                      Turns_Counter = 0;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x6320             STR      R0,[R4, #+48]
    516          
    517                      //--------------------- Torque mean value calculation - begin ---------------------
    518                      torque_mean = (Torque_Acc)/Mean_Samples_Cnt;
   \   000000BE   0x89E0             LDRH     R0,[R4, #+14]
   \   000000C0   0x6A61             LDR      R1,[R4, #+36]
    519                      torque_mean_f = (Torque_Acc_F)/((float)Mean_Samples_Cnt);
   \   000000C2   0xEDD4 0x0A0B      VLDR     S1,[R4, #+44]
   \   000000C6   0xEE00 0x0A10      VMOV     S0,R0
   \   000000CA   0xFB91 0xF5F0      SDIV     R5,R1,R0
   \   000000CE   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   000000D2   0xEE80 0x8A80      VDIV.F32 S16,S1,S0
    520          
    521                      // check spinning region
    522                      if((Mci__GetAnalog(MOTOR0, MCI_AI_SPEED_REFERENCE_RPM_S16)>>16) >= MciSensorsWm_Params->Spinning_Thr_Speed)
   \   000000D6   0x2101             MOVS     R1,#+1
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x.... 0x....      BL       Mci__GetAnalog
   \   000000DE   0x69E1             LDR      R1,[R4, #+28]
   \   000000E0   0xF9B1 0x1004      LDRSH    R1,[R1, #+4]
   \   000000E4   0x1400             ASRS     R0,R0,#+16
   \   000000E6   0x4288             CMP      R0,R1
   \   000000E8   0xDB0C             BLT.N    ??MeanValueCalc_4
    523                      {
    524                          // IIR filter for spinning region
    525                          torque_mean = (sint16)(((sint32)torque_mean + (sint32) Torque_Mean)>>1);
   \   000000EA   0xF9B4 0x000C      LDRSH    R0,[R4, #+12]
    526          
    527                          torque_mean_f = (torque_mean_f + Torque_Mean_F)/(2.0f);
   \   000000EE   0xED94 0x0A08      VLDR     S0,[R4, #+32]
   \   000000F2   0xFA00 0xF085      SXTAH    R0,R0,R5
   \   000000F6   0xEE38 0x0A00      VADD.F32 S0,S16,S0
   \   000000FA   0xEEF6 0x0A00      VMOV.F32 S1,#0.5
   \   000000FE   0x1045             ASRS     R5,R0,#+1
   \   00000100   0xEE20 0x8A20      VMUL.F32 S16,S0,S1
    528                      }
    529          
    530                      // updating of torque_mean
    531                      Torque_Mean = torque_mean;
    532                      Torque_Mean_F = torque_mean_f;
    533                      //--------------------- Torque mean value calculation - end ---------------------
    534                      
    535                      //--------------------- Unbalance Index calculation - begin ---------------------
    536                      temp_vibration_index = (Vibra_Acc)/Mean_Samples_Cnt;
    537                      
    538                      // Vibration Index calculation - IIR filter
    539                      Vibration_Index = (sint16)(((sint32)temp_vibration_index + (sint32) Vibration_Index)>>1);
   \                     ??MeanValueCalc_4: (+1)
   \   00000104   0x6AA0             LDR      R0,[R4, #+40]
   \   00000106   0x89E1             LDRH     R1,[R4, #+14]
   \   00000108   0x81A5             STRH     R5,[R4, #+12]
   \   0000010A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000010E   0x8A61             LDRH     R1,[R4, #+18]
   \   00000110   0xED84 0x8A08      VSTR     S16,[R4, #+32]
   \   00000114   0xFA11 0xF080      UXTAH    R0,R1,R0
   \   00000118   0x1040             ASRS     R0,R0,#+1
   \   0000011A   0x8260             STRH     R0,[R4, #+18]
    540          
    541                      if(TRUE == Mci__GetDigital(MOTOR0, MCI_DI_REACHED_TARGET_SPEED))
   \   0000011C   0x2102             MOVS     R1,#+2
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0x.... 0x....      BL       Mci__GetDigital
   \   00000124   0x8A21             LDRH     R1,[R4, #+16]
   \   00000126   0x2801             CMP      R0,#+1
   \   00000128   0xD10A             BNE.N    ??MeanValueCalc_5
    542                      {
    543                          if(Unbalance_Cnt < 65535)
   \   0000012A   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000012E   0x4281             CMP      R1,R0
   \   00000130   0xD003             BEQ.N    ??MeanValueCalc_6
    544                          {
    545                              ++Unbalance_Cnt;
   \   00000132   0x1C49             ADDS     R1,R1,#+1
    546                          }
    547          
    548                          if(Unbalance_Cnt>=RATE_FOR_UNBALANCE_COUNTER)
   \   00000134   0xB289             UXTH     R1,R1
   \   00000136   0x2908             CMP      R1,#+8
   \   00000138   0xDB05             BLT.N    ??MeanValueCalc_7
    549                          {
    550                              Balance = Vibration_Index;
   \                     ??MeanValueCalc_6: (+1)
   \   0000013A   0x8A60             LDRH     R0,[R4, #+18]
   \   0000013C   0x8160             STRH     R0,[R4, #+10]
   \   0000013E   0xE002             B.N      ??MeanValueCalc_7
    551                          }
    552                      }
    553                      else    // [ not in steady state ]
    554                      {
    555                          Balance = 0;
   \                     ??MeanValueCalc_5: (+1)
   \   00000140   0x2000             MOVS     R0,#+0
   \   00000142   0x8160             STRH     R0,[R4, #+10]
    556                          Unbalance_Cnt = 0;
   \   00000144   0x2100             MOVS     R1,#+0
    557                      }
    558                      //--------------------- Unbalance Index calculation - end ---------------------
    559                      
    560                      // clear accumulators
    561                      Torque_Acc = 0;
   \                     ??MeanValueCalc_7: (+1)
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0x8221             STRH     R1,[R4, #+16]
   \   0000014A   0x6260             STR      R0,[R4, #+36]
    562                      Torque_Acc_F = 0.0f;
   \   0000014C   0x62E0             STR      R0,[R4, #+44]
    563                      Vibra_Acc = 0;
   \   0000014E   0x62A0             STR      R0,[R4, #+40]
    564                      Mean_Samples_Cnt = 0;
   \   00000150   0x81E0             STRH     R0,[R4, #+14]
    565                  }
    566              }
    567              else
    568              {
    569              	MeanValueCalc_Reset();
    570              }
    571             
    572          }
   \   00000152   0xECBD 0x8B02      VPOP     {D8}
   \   00000156   0xB001             ADD      SP,SP,#+4
   \   00000158   0xBD30             POP      {R4,R5,PC}
   \                     ??MeanValueCalc_0: (+1)
   \   0000015A   0x2000             MOVS     R0,#+0
   \   0000015C   0x6260             STR      R0,[R4, #+36]
   \   0000015E   0x62E0             STR      R0,[R4, #+44]
   \   00000160   0x62A0             STR      R0,[R4, #+40]
   \   00000162   0x6320             STR      R0,[R4, #+48]
   \   00000164   0x60E0             STR      R0,[R4, #+12]
   \   00000166   0x6220             STR      R0,[R4, #+32]
   \   00000168   0x8160             STRH     R0,[R4, #+10]
   \   0000016A   0x6120             STR      R0,[R4, #+16]
   \                     ??MeanValueCalc_3: (+1)
   \   0000016C   0xECBD 0x8B02      VPOP     {D8}
   \   00000170   0xB001             ADD      SP,SP,#+4
   \   00000172   0xBD30             POP      {R4,R5,PC}       ;; return
    573          
    574          
    575          static void MeanValueCalc_Reset(void)
    576          {
    577              // clear accumulators
    578              Torque_Acc = 0;
    579              Torque_Acc_F = 0.0f;
    580              Vibra_Acc = 0;
    581              Mean_Samples_Cnt = 0;
    582              Turns_Counter = 0;
    583          
    584              // clear sensors variables
    585              Torque_Mean = 0;
    586              Torque_Mean_F = 0.0f;
    587              Balance = 0;
    588              Unbalance_Cnt = 0;
    589              Vibration_Index = 0;
    590          }
    591          #endif
    592          
    593          
    594          #if (MCI_OVERHEATING_WASH == ENABLED)
    595          //---------------------------------------------------------------------------------------------------------------------
    596          /**
    597           *  @brief     Overheating Washing
    598           *  @details   Calculation of Washing overheating index in [A^2].
    599           *  @param[in]
    600           *  @param[out]
    601           *  @return
    602           */

   \                                 In section .text, align 4, keep-with-next
    603          static void OverHeating_Washing(void)
    604          {
   \                     OverHeating_Washing: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    605          	sint32 temp_a;
    606          	sint32 temp_b;
    607          	sint32 temp_c;
    608          
    609              float temp_a_f;
    610              float temp_b_f;
    611              float temp_c_f;
    612          
    613              float temp_sum;
    614          
    615          	sint64 temp64;
    616          
    617          	sint32 is_motor_2;
    618          
    619          
    620          	if(Mci__GetAnalog(MOTOR0, MCI_AI_INTERNAL_MCI_STATE) > 2) //> MCI_INITIALIZING
   \   00000004   0x2118             MOVS     R1,#+24
   \   00000006   0xED2D 0x8B04      VPUSH    {D8-D9}
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      BL       Mci__GetAnalog
   \   00000010   0x2803             CMP      R0,#+3
   \   00000012   0xF2C0 0x80B2      BLT.W    ??OverHeating_Washing_0
    621          	{
    622                  temp_a = Mci__GetAnalog(MOTOR0, MCI_AI_CURR_PHASE_A_S16)>>1;
   \   00000016   0x2114             MOVS     R1,#+20
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      BL       Mci__GetAnalog
   \   0000001E   0x4604             MOV      R4,R0
    623                  temp_b = Mci__GetAnalog(MOTOR0, MCI_AI_CURR_PHASE_B_S16)>>1;
   \   00000020   0x2115             MOVS     R1,#+21
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      BL       Mci__GetAnalog
   \   00000028   0x4605             MOV      R5,R0
    624                  temp_c = Mci__GetAnalog(MOTOR0, MCI_AI_CURR_PHASE_C_S16)>>1;
   \   0000002A   0x2116             MOVS     R1,#+22
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x.... 0x....      BL       Mci__GetAnalog
    625          
    626                  temp_a = (sint32)IQMATH__REAL2IQ(temp_a,BASE_CURRENT,0); //A pu 17.15
   \   00000032   0x1061             ASRS     R1,R4,#+1
   \   00000034   0xEE00 0x1A10      VMOV     S0,R1
   \   00000038   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000003C   0xEDDF 0x....      VLDR.W   S1,??DataTable9_1  ;; 0x4103851f
   \   00000040   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000044   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000048   0xEE10 0x1A10      VMOV     R1,S0
    627                  temp_b = (sint32)IQMATH__REAL2IQ(temp_b,BASE_CURRENT,0); //A pu 17.15
   \   0000004C   0x106A             ASRS     R2,R5,#+1
   \   0000004E   0xEE00 0x2A10      VMOV     S0,R2
   \   00000052   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000056   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   0000005A   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000005E   0xEE10 0x2A10      VMOV     R2,S0
    628                  temp_c = (sint32)IQMATH__REAL2IQ(temp_c,BASE_CURRENT,0); //A pu 17.15
   \   00000062   0x1040             ASRS     R0,R0,#+1
   \   00000064   0xEE00 0x0A10      VMOV     S0,R0
   \   00000068   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000006C   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000070   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
    629          
    630                  //square Ia^2 Ib^2 Ic^2
    631                  temp_a = (sint64)IQMATH__I2Q30MULI17Q15(temp_a,temp_a); //A^2 pu 2.30
    632                  temp_b = (sint64)IQMATH__I2Q30MULI17Q15(temp_b,temp_b); //A^2 pu 2.30
    633                  temp_c = (sint64)IQMATH__I2Q30MULI17Q15(temp_c,temp_c); //A^2 pu 2.30
    634          
    635          
    636                  temp64 = temp_a + temp_b + temp_c;
    637                  temp64 = temp64>>IQ15; //2.30 -> 17.15
   \   00000074   0x4352             MULS     R2,R2,R2
   \   00000076   0xEE10 0x0A10      VMOV     R0,S0
   \   0000007A   0xFB01 0x2101      MLA      R1,R1,R1,R2
   \   0000007E   0xFB00 0x1000      MLA      R0,R0,R0,R1
   \   00000082   0x13C0             ASRS     R0,R0,#+15
   \   00000084   0x17C1             ASRS     R1,R0,#+31
    638          
    639          
    640                  //saturation
    641                  if (temp64 > (sint64)MAX_31BIT_POSITIVE)
   \   00000086   0x2900             CMP      R1,#+0
   \   00000088   0xDB06             BLT.N    ??OverHeating_Washing_1
   \   0000008A   0xDC02             BGT.N    ??OverHeating_Washing_2
   \   0000008C   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   00000090   0xD302             BCC.N    ??OverHeating_Washing_1
    642                  {
    643                      is_motor_2  = (sint32)MAX_31BIT_POSITIVE;
   \                     ??OverHeating_Washing_2: (+1)
   \   00000092   0xF06F 0x4040      MVN      R0,#-1073741824
   \   00000096   0xE00A             B.N      ??OverHeating_Washing_3
    644                  }
    645                  else if (temp64 < -(sint64)MAX_31BIT_NEGATIVE)
   \                     ??OverHeating_Washing_1: (+1)
   \   00000098   0xF04F 0x33FF      MOV      R3,#-1
   \   0000009C   0xF04F 0x4280      MOV      R2,#+1073741824
   \   000000A0   0x4299             CMP      R1,R3
   \   000000A2   0xDC04             BGT.N    ??OverHeating_Washing_3
   \   000000A4   0xDB01             BLT.N    ??OverHeating_Washing_4
   \   000000A6   0x4290             CMP      R0,R2
   \   000000A8   0xD201             BCS.N    ??OverHeating_Washing_3
    646                  {
    647                      is_motor_2  = (sint32)MAX_31BIT_NEGATIVE;
   \                     ??OverHeating_Washing_4: (+1)
   \   000000AA   0xF04F 0x4040      MOV      R0,#-1073741824
    648                  }
    649                  else
    650                  {
    651                      is_motor_2  = (sint32)temp64;
    652                  }
    653          
    654                  //Update Accumulator
    655                  IsMotor2_Acc = IsMotor2_Acc + is_motor_2;
   \                     ??OverHeating_Washing_3: (+1)
   \   000000AE   0x....             LDR.N    R4,??DataTable9_3
   \   000000B0   0x6B61             LDR      R1,[R4, #+52]
   \   000000B2   0x1840             ADDS     R0,R0,R1
   \   000000B4   0x6360             STR      R0,[R4, #+52]
    656          
    657          
    658          
    659                  //Floating point calculation - begin
    660                  temp_a_f  = (1.0f/65536.0f) * Mci__GetAnalog(MOTOR0, MCI_AI_CURR_PHASE_A_S16);
   \   000000B6   0xED9F 0x....      VLDR.W   S16,??DataTable9_2  ;; 0x37800000
   \   000000BA   0x2114             MOVS     R1,#+20
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x.... 0x....      BL       Mci__GetAnalog
   \   000000C2   0xEE00 0x0A10      VMOV     S0,R0
   \   000000C6   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000000CA   0xEE60 0x8A08      VMUL.F32 S17,S0,S16
    661                  temp_b_f  = (1.0f/65536.0f) * Mci__GetAnalog(MOTOR0, MCI_AI_CURR_PHASE_B_S16);
   \   000000CE   0x2115             MOVS     R1,#+21
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x.... 0x....      BL       Mci__GetAnalog
   \   000000D6   0xEE00 0x0A10      VMOV     S0,R0
   \   000000DA   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000000DE   0xEE20 0x9A08      VMUL.F32 S18,S0,S16
    662                  temp_c_f  = (1.0f/65536.0f) * Mci__GetAnalog(MOTOR0, MCI_AI_CURR_PHASE_C_S16);
   \   000000E2   0x2116             MOVS     R1,#+22
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0x.... 0x....      BL       Mci__GetAnalog
   \   000000EA   0xEE00 0x0A10      VMOV     S0,R0
   \   000000EE   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
    663          
    664          
    665                  //square Ia^2 Ib^2 Ic^2
    666                  temp_a_f = temp_a_f*temp_a_f;
    667                  temp_b_f = temp_b_f*temp_b_f;
    668                  temp_c_f = temp_c_f*temp_c_f;
    669          
    670                  temp_sum = temp_a_f + temp_b_f + temp_c_f;
    671          
    672                  IsMotor2_Acc_F = IsMotor2_Acc_F + temp_sum;
   \   000000F2   0xEE68 0x0AA8      VMUL.F32 S1,S17,S17
    673                  //Floating point calculation - begin
    674          
    675          
    676                  //Update Counter
    677                  OH_Washing_Cnt++;
   \   000000F6   0x8AA0             LDRH     R0,[R4, #+20]
   \   000000F8   0xEE20 0x0A08      VMUL.F32 S0,S0,S16
   \   000000FC   0xEE49 0x0A09      VMLA.F32 S1,S18,S18
   \   00000100   0xEE40 0x0A00      VMLA.F32 S1,S0,S0
   \   00000104   0x1C40             ADDS     R0,R0,#+1
   \   00000106   0xED94 0x0A0E      VLDR     S0,[R4, #+56]
   \   0000010A   0x82A0             STRH     R0,[R4, #+20]
   \   0000010C   0xEE30 0x0A80      VADD.F32 S0,S1,S0
   \   00000110   0xED84 0x0A0E      VSTR     S0,[R4, #+56]
    678          
    679                  // Motor Stop Detection
    680                  if(Mci__GetDigital(MOTOR0, MCI_DI_MOTOR_RUNNING) == FALSE)
   \   00000114   0x2104             MOVS     R1,#+4
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0x.... 0x....      BL       Mci__GetDigital
   \   0000011C   0xB930             CBNZ.N   R0,??OverHeating_Washing_5
    681                  {
    682                      if(OH_Washing_Movement_Flag == 1)
   \   0000011E   0x8B20             LDRH     R0,[R4, #+24]
   \   00000120   0x2801             CMP      R0,#+1
   \   00000122   0xD105             BNE.N    ??OverHeating_Washing_6
    683                      {
    684                          OH_Washing_Stop_Flag = 1;
   \   00000124   0x82E0             STRH     R0,[R4, #+22]
    685                          OH_Washing_Movement_Flag = 0;
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0x8320             STRH     R0,[R4, #+24]
   \   0000012A   0xE007             B.N      ??OverHeating_Washing_7
    686                      }
    687                  }
    688                  else
    689                  {
    690                      OH_Washing_Movement_Flag = 1;
   \                     ??OverHeating_Washing_5: (+1)
   \   0000012C   0x2001             MOVS     R0,#+1
   \   0000012E   0x8320             STRH     R0,[R4, #+24]
    691                  }
    692          
    693          
    694                  if ((OH_Washing_Stop_Flag) || (OH_Washing_Cnt > OH_WASHING_MAX_PERIOD))
   \                     ??OverHeating_Washing_6: (+1)
   \   00000130   0x8AE0             LDRH     R0,[R4, #+22]
   \   00000132   0xB918             CBNZ.N   R0,??OverHeating_Washing_7
   \   00000134   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000136   0xF5B0 0x5FC8      CMP      R0,#+6400
   \   0000013A   0xDD1E             BLE.N    ??OverHeating_Washing_0
    695                  {
    696                      if(OH_Washing_Cnt > 0)
   \                     ??OverHeating_Washing_7: (+1)
   \   0000013C   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000013E   0xB1E0             CBZ.N    R0,??OverHeating_Washing_0
    697                      {
    698                          OH_Washing_Index = (sint16)((IsMotor2_Acc/(OH_Washing_Cnt*3))<<1); //multiplication of 2/3
    699                          OH_Washing_Index_F = ((IsMotor2_Acc_F/((float)OH_Washing_Cnt*3.0f))*2.0f); //multiplication of 2/3
   \   00000140   0xEE00 0x0A10      VMOV     S0,R0
   \   00000144   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000148   0xEEF0 0x0A08      VMOV.F32 S1,#3.0
   \   0000014C   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000150   0x6B61             LDR      R1,[R4, #+52]
   \   00000152   0xEDD4 0x0A0E      VLDR     S1,[R4, #+56]
   \   00000156   0xEB00 0x0240      ADD      R2,R0,R0, LSL #+1
   \   0000015A   0xEE80 0x0A80      VDIV.F32 S0,S1,S0
   \   0000015E   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   00000162   0xEEF0 0x0A00      VMOV.F32 S1,#2.0
   \   00000166   0x0049             LSLS     R1,R1,#+1
   \   00000168   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
    700                          OH_Washing_Stop_Flag = 0;
   \   0000016C   0x2000             MOVS     R0,#+0
   \   0000016E   0x8361             STRH     R1,[R4, #+26]
   \   00000170   0xED84 0x0A0F      VSTR     S0,[R4, #+60]
    701                          OH_Washing_Cnt = 0;
   \   00000174   0x6160             STR      R0,[R4, #+20]
    702                          IsMotor2_Acc = 0;
   \   00000176   0x6360             STR      R0,[R4, #+52]
    703                          IsMotor2_Acc_F = 0.0f;
   \   00000178   0x63A0             STR      R0,[R4, #+56]
    704                      }
    705                  }
    706          	}
    707          }
   \                     ??OverHeating_Washing_0: (+1)
   \   0000017A   0xECBD 0x8B04      VPOP     {D8-D9}
   \   0000017E   0xB001             ADD      SP,SP,#+4
   \   00000180   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0xC7000000         DC32     0xc7000000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x4103851F         DC32     0x4103851f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x37800000         DC32     0x37800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     Drum_Load_Torque_Acc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0xFFFF8000         DC32     0xffff8000
    708          /***************************************************************************/
    709          #endif
    710          
    711          
    712          #if (MCI_POWER_METER == ENABLED)
    713          //---------------------------------------------------------------------------------------------------------------------
    714          /**
    715           *  @brief     Power Meter
    716           *  @details   Calculation of Power and Energy line assorbed by inverter/motor
    717           *  @param[in]
    718           *  @param[out]
    719           *  @return
    720           */
    721          static void PowerMeter(void)
    722          {
    723          	sint32 temp32;
    724          	sint32 temp32_2;
    725          
    726              //----------- Electrical Power Calculation---------
    727          	temp32 = Mci__GetAnalog(MOTOR0, MCI_AI_ACTIVE_POWER_S16)>>12;
    728          
    729          	if(temp32 < 0)
    730          	{
    731          		temp32 = 0;
    732          	}
    733          
    734          
    735          	temp32 = (sint32)IQMATH__REAL2IQ(temp32,(sint16)(BASE_POWER*16),IQ15); //W pu 17.15
    736          	//-------------------------------------------------
    737          
    738              //----------- Electrical Energy Calculation--------
    739          
    740          	Energy_K_1 = Energy_K>>IQ15;
    741          	Energy_K = Energy_K + IQMATH__I2Q30MULI17Q15(MciSensorsWm_Params->KEnergy,temp32);
    742          
    743          	//delta energy
    744          	temp32_2 = (Energy_K>>IQ15) - Energy_K_1;
    745          
    746          
    747          	//power integration
    748          	Energy_BackUp = Energy_BackUp + temp32_2;  //17.15
    749          
    750          	if(Energy_BackUp < 0)
    751          	{
    752          		Energy_BackUp = 0;
    753          
    754          	}
    755          	//-------------------------------------------------
    756          
    757          
    758          	//Sensors values update
    759          	temp32_2 = IQMATH__I17Q15MULI17Q15(Energy_BackUp,MciSensorsWm_Params->EnergyConversion); //Ws
    760          
    761          	Motor_Line_Power       =  IQMATH__Q15MULQ15(temp32,MciSensorsWm_Params->PowerConversion);
    762          	Motor_Line_Energy_Low  =  (sint16)(temp32_2); //Ws
    763          	Motor_Line_Energy_High =   (sint16)(temp32_2>>IQ15); //Ws
    764          
    765          }
    766          /***************************************************************************/
    767          #endif
    768          
    769          
    770          #if (MCI_DRUM_LOAD_AVERAGE == ENABLED)
    771          static void Drum_Load_Average(void)
    772          {
    773              sint32 torque;                  // torque = result of torque estimator
    774              float temp_float_acc;
    775          
    776              if(Mci__GetDigital(MOTOR0, MCI_DI_MOTOR_RUNNING) == TRUE)
    777              {
    778                  torque = Mci__GetAnalog(MOTOR0, MCI_AI_LOAD_TORQUE_S16)>>6; //Nm * 1024
    779          
    780                  // Accumulator update
    781                  Drum_Load_Torque_Acc = Drum_Load_Torque_Acc + torque;
    782          
    783                  Drum_Load_Torque_Samples_Cnt++;
    784              }
    785              else // Motor is stopped -> Calculate the drum load average
    786              {
    787                  if(Drum_Load_Torque_Samples_Cnt > 0)
    788                  {
    789          
    790                      temp_float_acc = (float)(Drum_Load_Torque_Acc*MciSensorsWm_Params->Transmission_Ratio); // Nm_Motor_Acc_x1024 -> Nm_Drum_Acc_x1024;
    791          
    792                      Drum_Load_Torque_Samples_Cnt = Drum_Load_Torque_Samples_Cnt<<10;  // Samples_Cnt * 1024
    793          
    794                      Drum_Load_Torque =  temp_float_acc/((float)Drum_Load_Torque_Samples_Cnt);   // Drum_Load_Torque = Nm_Drum_Acc_x1024/(Samples_Cnt * 1024)
    795          
    796          
    797                      //Reset Counters
    798                      Drum_Load_Torque_Samples_Cnt = 0;
    799                      Drum_Load_Torque_Acc = 0;
    800                  }
    801              }
    802          }
    803          #endif
    804          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   MciSensorsWm__1msHandler
         0   -> MeanValueCalc
      16   MciSensorsWm__5msHandler
        16   -> Mci__GetAnalog
        16   -> Mci__GetDigital
        16   -> OverHeating_Washing
        16   -> __aeabi_l2f
       8   MciSensorsWm__GetAnalog
         8   -> Mci__GetAnalog
       0   MciSensorsWm__GetFloatAnalog
       0   MciSensorsWm__GetIndesitAnalog
       0   MciSensorsWm__GetTransmissionRatio
       0   MciSensorsWm__Initialize
       0   MciSensorsWm__IsParamsReady
      24   MeanValueCalc
        24   -> Mci__GetAnalog
        24   -> Mci__GetDigital
      32   OverHeating_Washing
        32   -> Mci__GetAnalog
        32   -> Mci__GetDigital


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
      84  Drum_Load_Torque_Acc
          ParamsReady
          routine_post_scaler
          Balance
          Torque_Mean
          Mean_Samples_Cnt
          Unbalance_Cnt
          Vibration_Index
          OH_Washing_Cnt
          OH_Washing_Stop_Flag
          OH_Washing_Movement_Flag
          OH_Washing_Index
          MciSensorsWm_Params
          Torque_Mean_F
          Torque_Acc
          Vibra_Acc
          Torque_Acc_F
          Turns_Counter
          IsMotor2_Acc
          IsMotor2_Acc_F
          OH_Washing_Index_F
          Drum_Load_Torque_Samples_Cnt
          Drum_Load_Torque
          MciSensorsWm_Params_SF
      26  MciSensorsWm__1msHandler
     134  MciSensorsWm__5msHandler
     178  MciSensorsWm__GetAnalog
      38  MciSensorsWm__GetFloatAnalog
      52  MciSensorsWm__GetIndesitAnalog
      20  MciSensorsWm__GetTransmissionRatio
      52  MciSensorsWm__Initialize
       8  MciSensorsWm__IsParamsReady
     372  MeanValueCalc
     386  OverHeating_Washing

 
    84 bytes in section .data
 1 286 bytes in section .text
 
 1 286 bytes of CODE memory
    84 bytes of DATA memory

Errors: none
Warnings: none
