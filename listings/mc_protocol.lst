###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        19/Nov/2024  13:15:32
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  Category\Common\MasterCommander\Source\mc_protocol.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        mc_protocol.obj -l ..\listings\mc_protocol.lst
#        Category\Common\MasterCommander\Source\mc_protocol.c
#    List file    =  ..\listings\mc_protocol.lst
#    Object file  =  mc_protocol.obj
#
###############################################################################

C:\Data\Python\Windy_sBpm_Floating\source\Category\Common\MasterCommander\Source\mc_protocol.c
      1          /**
      2           *  @file
      3           *
      4           *  @brief      MasterCommander protocol handler
      5           *
      6           *
      7           *  $Header: $
      8           *
      9           *  @copyright  Copyright 2016-$Date$. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     10           */
     11          //---------------------------------------------------------------------------------------------------------------------
     12          
     13          //-------------------------------------- Include Files ----------------------------------------------------------------
     14          #include "mc_protocol.h"
     15          
     16          #include "master_commander.h"
     17          #include "mc_llmem.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp MC_BPTR MC_SkipInBuffer(MC_BPTR, MC_SIZE8)
   \                     MC_SkipInBuffer: (+1)
   \   00000000   0x1808             ADDS     R0,R1,R0
   \   00000002   0x4770             BX       LR               ;; return
     18          #include "mc_private.h"
     19          
     20          #if !(MC_DISABLE)
     21          
     22          #ifndef READFIX_CALLBACK
     23              #define READFIX_CALLBACK()
     24          #endif
     25          #ifndef WRITEFIX_CALLBACK
     26              #define WRITEFIX_CALLBACK()
     27          #endif
     28          #ifndef SINGLEREQ_CALLBACK
     29              #define SINGLEREQ_CALLBACK()
     30          #endif
     31          #ifndef COPY_FROM_VAR
     32              #define COPY_FROM_VAR()
     33          #endif
     34          #ifndef COPY_TO_VAR
     35              #define COPY_TO_VAR()
     36          #endif
     37          
     38          
     39          #if MC_USE_FIXED_CMDS == 1
                     ^
Remark[Pe193]: zero used for undefined preprocessing identifier
          "MC_USE_FIXED_CMDS"
     40          
     41          input Receive;
     42          output Transmit;
     43          
     44          #endif /* MC_USE_FIXED_CMDS */
     45          
     46          /**************************************************************************//*!
     47          *
     48          * @brief    mc driver initialization
     49          *
     50          ******************************************************************************/
     51          

   \                                 In section .text, align 2, keep-with-next
     52          MC_BOOL MC_Init(void)
     53          {   
   \                     MC_Init: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
     54          #if MC_USE_TSA
     55              /* initialize TSA */
     56              MC_InitTsa();
     57          #endif
     58          
     59          #if MC_USE_SCOPE
     60              /* initialize Scope */
     61              MC_InitScope();
   \   00000004   0x.... 0x....      BL       MC_InitScope
     62          #endif
     63          
     64          #if MC_USE_RECORDER
     65              /* initialize Recorder */
     66              MC_InitRec();
   \   00000008   0x.... 0x....      BL       MC_InitRec
     67          #endif
     68          
     69          #if MC_USE_APPCMD
     70              /* initialize application commands */
     71              MC_InitAppCmds();
     72          #endif
     73          
     74          #if MC_USE_SFIO
     75              /* initialize SFIO encapsulation layer */
     76              MC_InitSfio();
     77          #endif
     78          
     79          #if MC_USE_PIPES
     80              /* initialize PIPES interface */
     81              MC_InitPipes();
     82          #endif
     83          
     84          #if MC_USE_PDBDM
     85              /* initialize Packet Driven BDM communication */
     86              MC_InitPDBdm();
     87          #endif  
     88              
     89          #if MC_USE_SERIAL
     90              /* initialize communication and start listening for commands */
     91              if (!MC_InitSerial())
   \   0000000C   0x.... 0x....      BL       MC_InitSerial
   \   00000010   0xB100             CBZ.N    R0,??MC_Init_0
     92                return MC_FALSE;
     93          #endif  
     94              return MC_TRUE;
   \   00000012   0x2001             MOVS     R0,#+1
   \                     ??MC_Init_0: (+1)
   \   00000014   0xB001             ADD      SP,SP,#+4
   \   00000016   0xBD00             POP      {PC}             ;; return
     95          }
     96          
     97          /**************************************************************************//*!
     98          *
     99          * @brief    Decodes the mc protocol and calls appropriate handlers
    100          *
    101          * @param    pMessageIO - message in/out buffer
    102          *
    103          * @return   TRUE if frame was valid and any output was generated to IO buffer
    104          *
    105          * This Function decodes given message and invokes proper command handler
    106          * which fills in the response. The response transmission is initiated
    107          * in this call as well.
    108          *
    109          ******************************************************************************/
    110          

   \                                 In section .text, align 2, keep-with-next
    111          MC_BOOL MC_ProtocolDecoder(MC_BPTR pMessageIO)
    112          {
   \                     MC_ProtocolDecoder: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
    113              MC_BPTR pResponseEnd;
    114              MC_U8 nCmd;
    115              
    116              /* no EX access by default */
    117              MC_SetExAddr(MC_FALSE);
    118              
    119              /* command code comes first in the message */
    120              /*lint -e{534} return value is not used */
    121              (void)MC_ValueFromBuffer8(&nCmd, pMessageIO);
    122          
    123              /* process command   */
    124              switch (nCmd)
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD01A             BEQ.N    ??MC_ProtocolDecoder_0
   \   0000000C   0x2805             CMP      R0,#+5
   \   0000000E   0xD038             BEQ.N    ??MC_ProtocolDecoder_1
   \   00000010   0x2806             CMP      R0,#+6
   \   00000012   0xD044             BEQ.N    ??MC_ProtocolDecoder_2
   \   00000014   0x280A             CMP      R0,#+10
   \   00000016   0xD018             BEQ.N    ??MC_ProtocolDecoder_3
   \   00000018   0x280B             CMP      R0,#+11
   \   0000001A   0xD02A             BEQ.N    ??MC_ProtocolDecoder_4
   \   0000001C   0x2823             CMP      R0,#+35
   \   0000001E   0xD050             BEQ.N    ??MC_ProtocolDecoder_5
   \   00000020   0x2824             CMP      R0,#+36
   \   00000022   0xD052             BEQ.N    ??MC_ProtocolDecoder_6
   \   00000024   0x2825             CMP      R0,#+37
   \   00000026   0xD054             BEQ.N    ??MC_ProtocolDecoder_7
   \   00000028   0x28C0             CMP      R0,#+192
   \   0000002A   0xD046             BEQ.N    ??MC_ProtocolDecoder_8
   \   0000002C   0x28C1             CMP      R0,#+193
   \   0000002E   0xD018             BEQ.N    ??MC_ProtocolDecoder_9
   \   00000030   0x28C2             CMP      R0,#+194
   \   00000032   0xD01A             BEQ.N    ??MC_ProtocolDecoder_10
   \   00000034   0x28C3             CMP      R0,#+195
   \   00000036   0xD010             BEQ.N    ??MC_ProtocolDecoder_11
   \   00000038   0x28C5             CMP      R0,#+197
   \   0000003A   0xD00A             BEQ.N    ??MC_ProtocolDecoder_12
   \   0000003C   0x28C9             CMP      R0,#+201
   \   0000003E   0xD01C             BEQ.N    ??MC_ProtocolDecoder_13
   \   00000040   0xE04B             B.N      ??MC_ProtocolDecoder_14
    125              {
    126              
    127          #if MC_USE_READVAR
    128          
    129                  /* read byte */
    130          #if MC_USE_EX_CMDS
    131                  case MC_CMD_READVAR8_EX:
    132                      MC_SetExAddr(MC_TRUE);
    133          #endif
    134          #if MC_USE_NOEX_CMDS
    135                  /*lint -fallthrough */
    136                  case MC_CMD_READVAR8:
    137          #endif          
    138                      pResponseEnd = MC_ReadVar(pMessageIO, 1U);
    139                      break;
    140                      
    141                  /* read word */
    142          #if MC_USE_EX_CMDS
    143                  case MC_CMD_READVAR16_EX:
    144                      MC_SetExAddr(MC_TRUE);
    145          #endif
    146          #if MC_USE_NOEX_CMDS
    147                  /*lint -fallthrough */
    148                  case MC_CMD_READVAR16:
    149          #endif
    150                      pResponseEnd = MC_ReadVar(pMessageIO, 2U);
    151                      break;
    152                      
    153                  /* read dword */
    154          #if MC_USE_EX_CMDS
    155                  case MC_CMD_READVAR32_EX:
    156                      MC_SetExAddr(MC_TRUE);
    157          #endif
    158          #if MC_USE_NOEX_CMDS
    159                  /*lint -fallthrough */
    160                  case MC_CMD_READVAR32:
    161          #endif
    162                      pResponseEnd = MC_ReadVar(pMessageIO, 4U);
    163                      break;
    164          #endif /* MC_USE_READVAR */
    165          
    166          #if MC_USE_READMEM
    167          
    168                  /* read a block of memory */
    169          #if MC_USE_EX_CMDS
    170                  case MC_CMD_READMEM_EX:
    171                      MC_SetExAddr(MC_TRUE);
    172          #endif
    173          #if MC_USE_NOEX_CMDS
    174                  /*lint -fallthrough */
    175                  case MC_CMD_READMEM:
    176          #endif
    177                      pResponseEnd = MC_ReadMem(pMessageIO);
   \                     ??MC_ProtocolDecoder_0: (+1)
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       MC_ReadMem
    178                      break;
   \   00000048   0xE04B             B.N      ??MC_ProtocolDecoder_15
    179                      
    180          #endif /* MC_USE_READMEM */
    181          
    182          #if MC_USE_SCOPE
    183          
    184                  /* prepare scope variables */
    185          #if MC_USE_EX_CMDS
    186                  case MC_CMD_SETUPSCOPE_EX:
    187                      MC_SetExAddr(MC_TRUE);
    188          #endif
    189          #if MC_USE_NOEX_CMDS
    190                  /*lint -fallthrough */
    191                  case MC_CMD_SETUPSCOPE:
    192          #endif
    193                      pResponseEnd = MC_SetUpScope(pMessageIO);
   \                     ??MC_ProtocolDecoder_3: (+1)
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       MC_SetUpScope
    194                      break;  
   \   00000050   0xE047             B.N      ??MC_ProtocolDecoder_15
    195                      
    196                  case MC_CMD_READSCOPE:
    197                      pResponseEnd = MC_ReadScope(pMessageIO);
   \                     ??MC_ProtocolDecoder_12: (+1)
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       MC_ReadScope
    198                      break;
   \   00000058   0xE043             B.N      ??MC_ProtocolDecoder_15
    199          #endif /* MC_USE_SCOPE */
    200          
    201          #if MC_USE_RECORDER
    202          
    203                  /* get recorder status */
    204                  case MC_CMD_GETRECSTS:
    205                      pResponseEnd = MC_GetRecStatus(pMessageIO);
   \                     ??MC_ProtocolDecoder_11: (+1)
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       MC_GetRecStatus
    206                      break;
   \   00000060   0xE03F             B.N      ??MC_ProtocolDecoder_15
    207          
    208                  /* start recorder */
    209                  case MC_CMD_STARTREC:
    210                      pResponseEnd = MC_StartRec(pMessageIO);
   \                     ??MC_ProtocolDecoder_9: (+1)
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       MC_StartRec
    211                      break;
   \   00000068   0xE03B             B.N      ??MC_ProtocolDecoder_15
    212          
    213                  /* stop recorder */
    214                  case MC_CMD_STOPREC:
    215                      pResponseEnd = MC_StopRec(pMessageIO);
   \                     ??MC_ProtocolDecoder_10: (+1)
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       MC_StopRec
    216                      break;
   \   00000070   0xE037             B.N      ??MC_ProtocolDecoder_15
    217          
    218                  /* setup recorder */
    219          #if MC_USE_EX_CMDS
    220                  case MC_CMD_SETUPREC_EX:
    221                      MC_SetExAddr(MC_TRUE);
    222          #endif
    223          #if MC_USE_NOEX_CMDS
    224                  /*lint -fallthrough */
    225                  case MC_CMD_SETUPREC:
    226          #endif
    227                      pResponseEnd = MC_SetUpRec(pMessageIO);
   \                     ??MC_ProtocolDecoder_4: (+1)
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       MC_SetUpRec
    228                      break;
   \   00000078   0xE033             B.N      ??MC_ProtocolDecoder_15
    229                      
    230                  /* get recorder buffer information (force EX instead of non-EX) */
    231          #if MC_USE_EX_CMDS
    232                  case MC_CMD_GETRECBUFF_EX:
    233                      MC_SetExAddr(MC_TRUE);
    234          #elif MC_USE_NOEX_CMDS
    235                  /*lint -fallthrough */
    236                  case MC_CMD_GETRECBUFF:
    237          #endif
    238                      pResponseEnd = MC_GetRecBuff(pMessageIO);
   \                     ??MC_ProtocolDecoder_13: (+1)
   \   0000007A   0x4620             MOV      R0,R4
   \   0000007C   0x.... 0x....      BL       MC_GetRecBuff
    239                      break; 
   \   00000080   0xE02F             B.N      ??MC_ProtocolDecoder_15
    240          #endif /* MC_USE_RECORDER */
    241           
    242          #if MC_USE_APPCMD
    243          
    244                  /* accept the application command */
    245                  case MC_CMD_SENDAPPCMD:
    246                      pResponseEnd = MC_StoreAppCmd(pMessageIO);
    247                      break;
    248          
    249                  /* get the application command status */
    250                  case MC_CMD_GETAPPCMDSTS:
    251                      pResponseEnd = MC_GetAppCmdStatus(pMessageIO);
    252                      break;
    253          
    254                  /* get the application command data */
    255                  case MC_CMD_GETAPPCMDDATA:
    256                      pResponseEnd = MC_GetAppCmdRespData(pMessageIO);
    257                      break;
    258          #endif /* MC_USE_APPCMD */
    259          
    260          #if MC_USE_WRITEMEM
    261          
    262                  /* write a block of memory */
    263          #if MC_USE_EX_CMDS
    264                  case MC_CMD_WRITEMEM_EX:
    265                      MC_SetExAddr(MC_TRUE);
    266          #endif          
    267          #if MC_USE_NOEX_CMDS
    268                  /*lint -fallthrough */
    269                  case MC_CMD_WRITEMEM:
    270          #endif
    271                      pResponseEnd = MC_WriteMem(pMessageIO);
   \                     ??MC_ProtocolDecoder_1: (+1)
   \   00000082   0x1CA1             ADDS     R1,R4,#+2
   \   00000084   0xA800             ADD      R0,SP,#+0
   \   00000086   0xF811 0x5B01      LDRB     R5,[R1], #+1
   \   0000008A   0x.... 0x....      BL       MC_AddressFromBuffer
   \   0000008E   0x4601             MOV      R1,R0
   \   00000090   0x9800             LDR      R0,[SP, #+0]
   \   00000092   0x462A             MOV      R2,R5
   \   00000094   0x.... 0x....      BL       MC_CopyFromBuffer
   \   00000098   0x4620             MOV      R0,R4
   \   0000009A   0x2100             MOVS     R1,#+0
   \   0000009C   0xE01F             B.N      ??MC_ProtocolDecoder_16
    272                      break;
    273          #endif /* MC_USE_WRITEMEM */
    274          
    275          #if MC_USE_WRITEMEMMASK
    276          
    277                  /* write block of memory with a bit mask */
    278          #if MC_USE_EX_CMDS
    279                  case MC_CMD_WRITEMEMMASK_EX:
    280                      MC_SetExAddr(MC_TRUE);
    281          #endif
    282          #if MC_USE_NOEX_CMDS
    283                  /*lint -fallthrough */
    284                  case MC_CMD_WRITEMEMMASK:
    285          #endif
    286                      pResponseEnd = MC_WriteMemMask(pMessageIO);
   \                     ??MC_ProtocolDecoder_2: (+1)
   \   0000009E   0x1CA1             ADDS     R1,R4,#+2
   \   000000A0   0xA800             ADD      R0,SP,#+0
   \   000000A2   0xF811 0x5B01      LDRB     R5,[R1], #+1
   \   000000A6   0x.... 0x....      BL       MC_AddressFromBuffer
   \   000000AA   0x4601             MOV      R1,R0
   \   000000AC   0x9800             LDR      R0,[SP, #+0]
   \   000000AE   0x462A             MOV      R2,R5
   \   000000B0   0x.... 0x....      BL       MC_CopyFromBufferWithMask
   \   000000B4   0x4620             MOV      R0,R4
   \   000000B6   0x2100             MOVS     R1,#+0
   \   000000B8   0xE011             B.N      ??MC_ProtocolDecoder_16
    287                      break;
    288          #endif /* MC_USE_WRITEMEMMASK */
    289                      
    290          #if MC_USE_WRITEVAR && MC_USE_NOEX_CMDS
    291          
    292                  /* write byte */
    293                  case MC_CMD_WRITEVAR8:
    294                      pResponseEnd = MC_WriteVar(pMessageIO, 1U);
    295                      break;
    296          
    297                  /* write word */
    298                  case MC_CMD_WRITEVAR16:
    299                      pResponseEnd = MC_WriteVar(pMessageIO, 2U);
    300                      break;
    301          
    302                  /* write dword */
    303                  case MC_CMD_WRITEVAR32:
    304                      pResponseEnd = MC_WriteVar(pMessageIO, 4U);
    305                      break;
    306          #endif /* MC_USE_WRITEVAR && MC_USE_NOEX_CMDS */
    307          
    308          #if MC_USE_WRITEVARMASK && MC_USE_NOEX_CMDS
    309          
    310                  /* write byte with mask */
    311                  case MC_CMD_WRITEVAR8MASK:
    312                      pResponseEnd = MC_WriteVarMask(pMessageIO, 1U);
    313                      break;
    314          
    315                  /* write word with mask */
    316                  case MC_CMD_WRITEVAR16MASK:
    317                      pResponseEnd = MC_WriteVarMask(pMessageIO, 2U);
    318                      break;
    319          
    320          #endif /* MC_USE_WRITEVARMASK && MC_USE_NOEX_CMDS */
    321          
    322          #if MC_USE_TSA
    323          
    324                  /* get TSA table (force EX instead of non-EX) */
    325          #if MC_USE_EX_CMDS
    326                  case MC_CMD_GETTSAINFO_EX:
    327                      MC_SetExAddr(MC_TRUE);
    328          #elif MC_USE_NOEX_CMDS
    329                  /*lint -fallthrough */
    330                  case MC_CMD_GETTSAINFO:
    331          #endif
    332                      pResponseEnd = MC_GetTsaInfo(pMessageIO);
    333                      break;
    334                      
    335          #if MC_USE_EX_CMDS
    336                  case MC_CMD_GETSTRLEN_EX:
    337                      MC_SetExAddr(MC_TRUE);
    338          #endif
    339          #if MC_USE_NOEX_CMDS
    340                  /*lint -fallthrough */
    341                  case MC_CMD_GETSTRLEN:
    342          #endif
    343                      pResponseEnd = MC_GetStringLen(pMessageIO);
    344                      break;
    345          
    346          #endif /* MC_USE_TSA */
    347          
    348          #if MC_USE_BRIEFINFO
    349                  /* retrieve a subset of board information structure */
    350                  case MC_CMD_GETINFOBRIEF:
    351          #else   
    352                  /* retrieve board information structure */
    353                  case MC_CMD_GETINFO:
    354          #endif
    355                      pResponseEnd = MC_GetBoardInfo(pMessageIO);
   \                     ??MC_ProtocolDecoder_8: (+1)
   \   000000BA   0x4620             MOV      R0,R4
   \   000000BC   0x.... 0x....      BL       MC_GetBoardInfo
    356                      break;
   \   000000C0   0xE00F             B.N      ??MC_ProtocolDecoder_15
    357          
    358          #if MC_USE_SFIO
    359                  case MC_CMD_SFIOFRAME_0:
    360                  case MC_CMD_SFIOFRAME_1:
    361                      pResponseEnd = MC_SfioFrame(pMessageIO);
    362                      break;
    363                  case MC_CMD_SFIOGETRESP_0:
    364                  case MC_CMD_SFIOGETRESP_1:
    365                      pResponseEnd = MC_SfioGetResp(pMessageIO);
    366                      break;
    367          #endif /* MC_USE_SFIO */
    368          
    369          #if MC_USE_PIPES
    370                  case MC_CMD_PIPE:
    371                      pResponseEnd = MC_PipeFrame(pMessageIO);
    372                      break;
    373          #endif /* MC_USE_PIPES */
    374          
    375                  /* Master&Commander Commands */
    376          
    377                  case MC_CMD_READLF:
    378          			pResponseEnd = MC_ReadLF(pMessageIO);
   \                     ??MC_ProtocolDecoder_5: (+1)
   \   000000C2   0x4620             MOV      R0,R4
   \   000000C4   0x.... 0x....      BL       MC_ReadLF
    379          			break;
   \   000000C8   0xE00B             B.N      ??MC_ProtocolDecoder_15
    380          
    381          		case MC_CMD_WRITELF:
    382          			pResponseEnd = MC_WriteLF(pMessageIO);
   \                     ??MC_ProtocolDecoder_6: (+1)
   \   000000CA   0x4620             MOV      R0,R4
   \   000000CC   0x.... 0x....      BL       MC_WriteLF
    383          			break;
   \   000000D0   0xE007             B.N      ??MC_ProtocolDecoder_15
    384          
    385          		case MC_CMD_WRITELF_BYTE:
    386          			pResponseEnd = MC_WriteLF_Byte(pMessageIO);
   \                     ??MC_ProtocolDecoder_7: (+1)
   \   000000D2   0x4620             MOV      R0,R4
   \   000000D4   0x.... 0x....      BL       MC_WriteLF_Byte
    387          			break;
   \   000000D8   0xE003             B.N      ??MC_ProtocolDecoder_15
    388          
    389          #if MC_USE_FIXED_CMDS
                     ^
Remark[Pe193]: zero used for undefined preprocessing identifier
          "MC_USE_FIXED_CMDS"
    390          #if 0 // not supported
    391          		case MC_CMD_READFIX:
    392          		    pResponseEnd = MC_ReadFix(pMessageIO);
    393          		    READFIX_CALLBACK();
    394                      break;
    395          
    396                  case MC_CMD_WRITEFIX:
    397                      pResponseEnd = MC_WriteFix(pMessageIO);
    398                      WRITEFIX_CALLBACK();
    399                      break;
    400          #endif
    401                  case MC_CMD_SINGLEREQ:
    402                      pResponseEnd = MC_SingleReq(pMessageIO);
    403                      break;
    404          #endif /* MC_USE_FIXED_CMDS */
    405          
    406                  /* unknown command */
    407                  default:
    408                      pResponseEnd = MC_ConstToBuffer8(pMessageIO, MC_STC_INVCMD);
   \                     ??MC_ProtocolDecoder_14: (+1)
   \   000000DA   0x4620             MOV      R0,R4
   \   000000DC   0x2181             MOVS     R1,#+129
   \                     ??MC_ProtocolDecoder_16: (+1)
   \   000000DE   0xF800 0x1B01      STRB     R1,[R0], #+1
    409                      break;          
    410              }
    411              
    412              /* anything to send back? */
    413              if(pResponseEnd != pMessageIO)
   \                     ??MC_ProtocolDecoder_15: (+1)
   \   000000E2   0x42A0             CMP      R0,R4
   \   000000E4   0xD007             BEQ.N    ??MC_ProtocolDecoder_17
    414              {
    415                  /*lint -e{946,960} subtracting pointers is appropriate here */
    416                  MC_SIZE8 nSize = (MC_SIZE8)(pResponseEnd - pMessageIO);
    417                  MC_SendResponse(pMessageIO, nSize);
   \   000000E6   0x1B01             SUBS     R1,R0,R4
   \   000000E8   0xB2C9             UXTB     R1,R1
   \   000000EA   0x4620             MOV      R0,R4
   \   000000EC   0x.... 0x....      BL       MC_SendResponse
    418                  return MC_TRUE;
   \   000000F0   0x2001             MOVS     R0,#+1
   \   000000F2   0xB001             ADD      SP,SP,#+4
   \   000000F4   0xBD30             POP      {R4,R5,PC}
    419              }
    420              else
    421              {
    422                  /* nothing sent out */
    423                  return MC_FALSE;
   \                     ??MC_ProtocolDecoder_17: (+1)
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0xB001             ADD      SP,SP,#+4
   \   000000FA   0xBD30             POP      {R4,R5,PC}       ;; return
    424              }
    425          }
    426          
    427          /**************************************************************************//*!
    428          *
    429          * @brief    Handling GETINFO or GETINFO_BRIEF
    430          *
    431          * @param    pMessageIO - original command (in) and response buffer (out) 
    432          *
    433          * @return   As all command handlers, the return value should be the buffer 
    434          *           pointer where the response output finished (except checksum)
    435          *
    436          ******************************************************************************/
    437          

   \                                 In section .text, align 2, keep-with-next
    438          MC_BPTR MC_GetBoardInfo(MC_BPTR pMessageIO)
    439          {
   \                     MC_GetBoardInfo: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB082             SUB      SP,SP,#+8
    440              MC_BPTR pResponse = pMessageIO;
    441              MC_U16 wTmp;
    442              MC_U8 *pStr;
                            ^
Warning[Pe177]: variable "pStr" was declared but never referenced
    443          
    444              pResponse = MC_ConstToBuffer8(pResponse, MC_STS_OK);
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF804 0x0B01      STRB     R0,[R4], #+1
    445              pResponse = MC_ConstToBuffer8(pResponse, (MC_U8)(MC_PROT_VER));            /* protVer */
   \   0000000C   0x2003             MOVS     R0,#+3
   \   0000000E   0xF804 0x0B01      STRB     R0,[R4], #+1
    446              pResponse = MC_ConstToBuffer8(pResponse, (MC_U8)(MC_CFG_FLAGS));           /* cfgFlags */
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF804 0x0B01      STRB     R0,[R4], #+1
    447              pResponse = MC_ConstToBuffer8(pResponse, (MC_U8)(MC_CFG_BUS_WIDTH));       /* dataBusWdt */
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xF804 0x0B01      STRB     R0,[R4], #+1
    448              pResponse = MC_ConstToBuffer8(pResponse, (MC_U8)(MC_GLOB_VERSION_MAJOR));  /* globVerMajor */
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xF804 0x0B01      STRB     R0,[R4], #+1
    449              pResponse = MC_ConstToBuffer8(pResponse, (MC_U8)(MC_GLOB_VERSION_MINOR));  /* globVerMinor */
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF804 0x0B01      STRB     R0,[R4], #+1
    450              pResponse = MC_ConstToBuffer8(pResponse, (MC_U8)(MC_COMM_BUFFER_SIZE));    /* cmdBuffSize  */
   \   0000002A   0x203A             MOVS     R0,#+58
   \   0000002C   0xF804 0x0B01      STRB     R0,[R4], #+1
    451          
    452              /* that is all for brief info */
    453          #if MC_USE_BRIEFINFO
    454              MC_UNUSED(pStr);
    455              MC_UNUSED(wTmp);
    456              
    457          #else /* MC_USE_BRIEFINFO */
    458          
    459          #if MC_USE_RECORDER
    460          
    461              /* recorder buffer size is always measured in bytes */
    462              wTmp = MC_GetRecBuffSize();
    463              wTmp *= MC_CFG_BUS_WIDTH;
    464          
    465              /* send size and timebase    */
    466              pResponse = MC_ValueToBuffer16(pResponse, wTmp);
    467              pResponse = MC_ConstToBuffer16(pResponse, (MC_U16) MC_REC_TIMEBASE);
   \   00000030   0x.... 0x....      BL       MC_GetRecBuffSize
   \   00000034   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000038   0x2202             MOVS     R2,#+2
   \   0000003A   0xA900             ADD      R1,SP,#+0
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       MC_CopyToBuffer
   \   00000042   0x217D             MOVS     R1,#+125
   \   00000044   0xF800 0x1B01      STRB     R1,[R0], #+1
   \   00000048   0x2180             MOVS     R1,#+128
   \   0000004A   0xF800 0x1B01      STRB     R1,[R0], #+1
    468          #else /* MC_USE_RECORDER */
    469          
    470              MC_UNUSED(wTmp);
    471          
    472              /* recorder info zeroed */
    473              pResponse = MC_ConstToBuffer16(pResponse, 0);
    474              pResponse = MC_ConstToBuffer16(pResponse, 0);
    475          #endif /* MC_USE_RECORDER */
    476          
    477          #if MC_LIGHT_VERSION
    478          MC_UNUSED(pStr);
    479              pResponse = MC_SkipInBuffer(pResponse, (MC_U8)MC_DESCR_SIZE);
    480          #else
    481              /* description string */
    482              pStr = (MC_U8*)  MC_IDT_STRING;
    483              for(wTmp = 0U; wTmp < (MC_U8)(MC_DESCR_SIZE); wTmp++)
    484              {
    485                  pResponse = MC_ValueToBuffer8(pResponse, *pStr);
    486          
    487                  /* terminating zero used to clear the remainder of the buffer */        
    488                  if(*pStr)
    489                  {
    490                      pStr ++;
    491                  }
    492              }
    493          #endif /* SEND_IDT_STRING */
    494              
    495          #endif /* MC_USE_BRIEFINFO */
    496          
    497              return pResponse;   
   \   0000004E   0x2119             MOVS     R1,#+25
   \   00000050   0x.... 0x....      BL       MC_SkipInBuffer
   \   00000054   0xB002             ADD      SP,SP,#+8
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
    498          }
    499          
    500          /**************************************************************************//*!
    501          *
    502          * @brief    Handling READMEM and READMEM_EX commands
    503          *
    504          * @param    pMessageIO - original command (in) and response buffer (out) 
    505          *
    506          * @return   As all command handlers, the return value should be the buffer 
    507          *           pointer where the response output finished (except checksum)
    508          *
    509          ******************************************************************************/
    510          

   \                                 In section .text, align 2, keep-with-next
    511          MC_BPTR MC_ReadMem(MC_BPTR pMessageIO)
    512          {
   \                     MC_ReadMem: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    513              MC_BPTR pResponse = pMessageIO;
    514              MC_ADDR nAddr;
    515              MC_U8 nSize;
    516          
    517              pMessageIO = MC_SkipInBuffer(pMessageIO, 2U);
    518              pMessageIO = MC_ValueFromBuffer8(&nSize, pMessageIO);
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x.... 0x....      BL       MC_SkipInBuffer
   \   0000000C   0xF810 0x1B01      LDRB     R1,[R0], #+1
   \   00000010   0xF88D 0x1000      STRB     R1,[SP, #+0]
    519              pMessageIO = MC_AddressFromBuffer(&nAddr, pMessageIO);
   \   00000014   0x4601             MOV      R1,R0
   \   00000016   0xA801             ADD      R0,SP,#+4
   \   00000018   0x.... 0x....      BL       MC_AddressFromBuffer
    520          
    521          #if MC_USE_TSA && MC_USE_TSA_SAFETY
    522              if(!MC_CheckTsaSpace(nAddr, (MC_SIZE8) nSize, MC_FALSE))
    523              {
    524                  return MC_ConstToBuffer8(pResponse, MC_STC_EACCESS);
    525              }
    526          #endif
    527          
    528              /* check the response will safely fit into comm buffer */
    529              if(nSize > (MC_U8)MC_COMM_BUFFER_SIZE)
   \   0000001C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000020   0x283B             CMP      R0,#+59
   \   00000022   0xDB05             BLT.N    ??MC_ReadMem_0
    530              {
    531                  return MC_ConstToBuffer8(pResponse, MC_STC_RSPBUFFOVF);
   \   00000024   0x2084             MOVS     R0,#+132
   \   00000026   0xF804 0x0B01      STRB     R0,[R4], #+1
    532              }
   \   0000002A   0xB002             ADD      SP,SP,#+8
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0xBD10             POP      {R4,PC}
    533              
    534              /* success  */
    535              pResponse = MC_ConstToBuffer8(pResponse, MC_STS_OK);
   \                     ??MC_ReadMem_0: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF804 0x0B01      STRB     R0,[R4], #+1
    536              
    537              return MC_CopyToBuffer(pResponse, nAddr, (MC_SIZE8) nSize);
   \   00000036   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   0000003A   0x9901             LDR      R1,[SP, #+4]
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       MC_CopyToBuffer
   \   00000042   0xB002             ADD      SP,SP,#+8
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
    538          }   
    539          
    540          /**************************************************************************//*!
    541          *
    542          * @brief    Handling READVAR and READVAR_EX commands (for all sizes 1,2,4)
    543          *
    544          * @param    pMessageIO - original command (in) and response buffer (out) 
    545          *
    546          * @return   As all command handlers, the return value should be the buffer 
    547          *           pointer where the response output finished (except checksum)
    548          *
    549          ******************************************************************************/
    550          

   \                                 In section .text, align 2, keep-with-next
    551          MC_BPTR MC_ReadVar(MC_BPTR pMessageIO, MC_SIZE8 nSize)
    552          {
   \                     MC_ReadVar: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x4604             MOV      R4,R0
    553              MC_BPTR pResponse = pMessageIO;
    554              MC_ADDR nAddr;
    555          
    556              pMessageIO = MC_SkipInBuffer(pMessageIO, 1U);
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x.... 0x....      BL       MC_SkipInBuffer
    557              pMessageIO = MC_AddressFromBuffer(&nAddr, pMessageIO);
   \   0000000E   0x4601             MOV      R1,R0
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x.... 0x....      BL       MC_AddressFromBuffer
    558          
    559          #if MC_USE_TSA && MC_USE_TSA_SAFETY
    560              if(!MC_CheckTsaSpace(nAddr, nSize, MC_FALSE))
    561              {
    562                  return MC_ConstToBuffer8(pResponse, MC_STC_EACCESS);
    563              }
    564          #endif
    565          
    566              /* success  */
    567              pResponse = MC_ConstToBuffer8(pResponse, MC_STS_OK);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF804 0x0B01      STRB     R0,[R4], #+1
    568              
    569              return MC_CopyToBuffer(pResponse, nAddr, nSize);
   \   0000001C   0x462A             MOV      R2,R5
   \   0000001E   0x9900             LDR      R1,[SP, #+0]
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       MC_CopyToBuffer
   \   00000026   0xB001             ADD      SP,SP,#+4
   \   00000028   0xBD30             POP      {R4,R5,PC}       ;; return
    570          }   
    571          
    572          /**************************************************************************//*!
    573          *
    574          * @brief    Handling WRITEMEM and WRITEMEM_EX commands
    575          *
    576          * @param    pMessageIO - original command (in) and response buffer (out) 
    577          *
    578          * @return   As all command handlers, the return value should be the buffer 
    579          *           pointer where the response output finished (except checksum)
    580          *
    581          ******************************************************************************/
    582          

   \                                 In section .text, align 2, keep-with-next
    583          MC_BPTR MC_WriteMem(MC_BPTR pMessageIO)
    584          {
   \                     MC_WriteMem: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    585              MC_BPTR pResponse = pMessageIO;
    586              MC_ADDR nAddr;
    587              MC_U8 nSize,nResponseCode;
    588          
    589              pMessageIO = MC_SkipInBuffer(pMessageIO, 2U);
    590              pMessageIO = MC_ValueFromBuffer8(&nSize, pMessageIO);
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x.... 0x....      BL       MC_SkipInBuffer
   \   0000000C   0xF810 0x1B01      LDRB     R1,[R0], #+1
   \   00000010   0xF88D 0x1000      STRB     R1,[SP, #+0]
    591              pMessageIO = MC_AddressFromBuffer(&nAddr, pMessageIO);
   \   00000014   0x4601             MOV      R1,R0
   \   00000016   0xA801             ADD      R0,SP,#+4
   \   00000018   0x.... 0x....      BL       MC_AddressFromBuffer
   \   0000001C   0x4601             MOV      R1,R0
    592          
    593          #if MC_USE_TSA && MC_USE_TSA_SAFETY
    594              if(!MC_CheckTsaSpace(nAddr, (MC_SIZE8) nSize, MC_TRUE))
    595              {
    596                  nResponseCode = MC_STC_EACCESS;
    597                  goto MC_WriteMem_exit;
    598              }
    599          #endif
    600          
    601              /*lint -e{534} ignoring function return value */
    602              MC_CopyFromBuffer(nAddr, pMessageIO, (MC_SIZE8) nSize);
   \   0000001E   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000022   0x9801             LDR      R0,[SP, #+4]
   \   00000024   0x.... 0x....      BL       MC_CopyFromBuffer
    603              nResponseCode = MC_STS_OK;
    604          
    605          #if MC_USE_TSA && MC_USE_TSA_SAFETY
    606          MC_WriteMem_exit:
    607          #endif      
    608                
    609              return MC_ConstToBuffer8(pResponse, nResponseCode);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF804 0x0B01      STRB     R0,[R4], #+1
   \   0000002E   0xB002             ADD      SP,SP,#+8
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
    610          }
    611          
    612          /**************************************************************************//*!
    613          *
    614          * @brief    Handling WRITEVAR command
    615          *
    616          * @param    pMessageIO - original command (in) and response buffer (out) 
    617          * @param    nSize - variable size
    618          *
    619          * @return   As all command handlers, the return value should be the buffer 
    620          *           pointer where the response output finished (except checksum)
    621          *
    622          ******************************************************************************/
    623          

   \                                 In section .text, align 2, keep-with-next
    624          MC_BPTR MC_WriteVar(MC_BPTR pMessageIO, MC_SIZE8 nSize)
    625          {
   \                     MC_WriteVar: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x4604             MOV      R4,R0
    626              MC_BPTR pResponse = pMessageIO;
    627              MC_ADDR nAddr;
    628              MC_U8 nResponseCode;
    629          
    630              pMessageIO = MC_SkipInBuffer(pMessageIO, 1U);
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x.... 0x....      BL       MC_SkipInBuffer
    631              pMessageIO = MC_AddressFromBuffer(&nAddr, pMessageIO);
   \   0000000E   0x4601             MOV      R1,R0
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x.... 0x....      BL       MC_AddressFromBuffer
   \   00000016   0x4601             MOV      R1,R0
    632          
    633          #if MC_USE_TSA && MC_USE_TSA_SAFETY
    634              if(!MC_CheckTsaSpace(nAddr, nSize, MC_TRUE))
    635              {
    636                  nResponseCode = MC_STC_EACCESS;
    637                  goto MC_WriteVar_exit;
    638              }
    639          #endif
    640          
    641              /*lint -e{534} ignoring function return value */
    642              MC_CopyFromBuffer(nAddr, pMessageIO, nSize);
   \   00000018   0x9800             LDR      R0,[SP, #+0]
   \   0000001A   0x462A             MOV      R2,R5
   \   0000001C   0x.... 0x....      BL       MC_CopyFromBuffer
    643              nResponseCode = MC_STS_OK;
    644          
    645          #if MC_USE_TSA && MC_USE_TSA_SAFETY
    646          MC_WriteVar_exit:
    647          #endif
    648                
    649              return MC_ConstToBuffer8(pResponse, nResponseCode);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF804 0x0B01      STRB     R0,[R4], #+1
   \   00000026   0xB001             ADD      SP,SP,#+4
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0xBD30             POP      {R4,R5,PC}       ;; return
    650          }
    651          
    652          
    653          /**************************************************************************//*!
    654          *
    655          * @brief    Handling WRITEMEMMASK and WRITEMEMMASK_EX commands
    656          *
    657          * @param    pMessageIO - original command (in) and response buffer (out) 
    658          *
    659          * @return   As all command handlers, the return value should be the buffer 
    660          *           pointer where the response output finished (except checksum)
    661          *
    662          ******************************************************************************/
    663          

   \                                 In section .text, align 2, keep-with-next
    664          MC_BPTR MC_WriteMemMask(MC_BPTR pMessageIO)
    665          {
   \                     MC_WriteMemMask: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    666              MC_BPTR pResponse = pMessageIO;
    667              MC_ADDR nAddr;
    668              MC_U8 nSize,nResponseCode;
    669          
    670              pMessageIO = MC_SkipInBuffer(pMessageIO, 2U);
    671              pMessageIO = MC_ValueFromBuffer8(&nSize, pMessageIO);
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x.... 0x....      BL       MC_SkipInBuffer
   \   0000000C   0xF810 0x1B01      LDRB     R1,[R0], #+1
   \   00000010   0xF88D 0x1000      STRB     R1,[SP, #+0]
    672              pMessageIO = MC_AddressFromBuffer(&nAddr, pMessageIO);
   \   00000014   0x4601             MOV      R1,R0
   \   00000016   0xA801             ADD      R0,SP,#+4
   \   00000018   0x.... 0x....      BL       MC_AddressFromBuffer
   \   0000001C   0x4601             MOV      R1,R0
    673          
    674          #if MC_USE_TSA && MC_USE_TSA_SAFETY
    675              if(!MC_CheckTsaSpace(nAddr, (MC_SIZE8)nSize, MC_TRUE))
    676              {
    677                  nResponseCode = MC_STC_EACCESS;
    678                  goto MC_WriteMemMask_exit;
    679              }
    680          #endif
    681          
    682          #if MC_CFG_BUS_WIDTH > 1U
    683              /* size must be divisible by bus width (mask must not begin in half of memory word) */
    684              if(nSize % MC_CFG_BUS_WIDTH)
    685              {
    686                  nResponseCode = MC_STC_INVSIZE;
    687                  goto MC_WriteMemMask_exit;
    688              }
    689          #endif
    690          
    691              /* put the data */
    692              MC_CopyFromBufferWithMask(nAddr, pMessageIO, (MC_SIZE8)nSize);
   \   0000001E   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000022   0x9801             LDR      R0,[SP, #+4]
   \   00000024   0x.... 0x....      BL       MC_CopyFromBufferWithMask
    693              nResponseCode = MC_STS_OK;
    694          
    695          #if (MC_USE_TSA && MC_USE_TSA_SAFETY) || (MC_CFG_BUS_WIDTH > 1U)
    696          MC_WriteMemMask_exit:
    697          #endif  
    698                
    699              return MC_ConstToBuffer8(pResponse, nResponseCode);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF804 0x0B01      STRB     R0,[R4], #+1
   \   0000002E   0xB002             ADD      SP,SP,#+8
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
    700          }
    701          
    702          /**************************************************************************//*!
    703          *
    704          * @brief    Handling WRITEVARMASK command
    705          *
    706          * @param    pMessageIO - original command (in) and response buffer (out) 
    707          * @param    nSize - variable size
    708          *
    709          * @return   As all command handlers, the return value should be the buffer 
    710          *           pointer where the response output finished (except checksum)
    711          *
    712          ******************************************************************************/
    713          

   \                                 In section .text, align 2, keep-with-next
    714          MC_BPTR MC_WriteVarMask(MC_BPTR pMessageIO, MC_SIZE8 nSize)
    715          {
   \                     MC_WriteVarMask: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x4604             MOV      R4,R0
    716              MC_BPTR pResponse = pMessageIO;
    717              MC_ADDR nAddr;
    718              MC_U8 nResponseCode;
    719              
    720              pMessageIO = MC_SkipInBuffer(pMessageIO, 1U);
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x.... 0x....      BL       MC_SkipInBuffer
    721              pMessageIO = MC_AddressFromBuffer(&nAddr, pMessageIO);
   \   0000000E   0x4601             MOV      R1,R0
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x.... 0x....      BL       MC_AddressFromBuffer
   \   00000016   0x4601             MOV      R1,R0
    722          
    723          #if MC_USE_TSA && MC_USE_TSA_SAFETY
    724              if(!MC_CheckTsaSpace(nAddr, nSize, MC_TRUE))
    725              {
    726                  nResponseCode = MC_STC_EACCESS;
    727                  goto MC_WriteVarMask_exit;
    728              }
    729          #endif
    730          
    731              /* put the data */
    732              MC_CopyFromBufferWithMask(nAddr, pMessageIO, nSize);
   \   00000018   0x9800             LDR      R0,[SP, #+0]
   \   0000001A   0x462A             MOV      R2,R5
   \   0000001C   0x.... 0x....      BL       MC_CopyFromBufferWithMask
    733              nResponseCode = MC_STS_OK;
    734          
    735          #if MC_USE_TSA && MC_USE_TSA_SAFETY
    736          MC_WriteVarMask_exit:
    737          #endif      
    738          
    739              return MC_ConstToBuffer8(pResponse, nResponseCode);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF804 0x0B01      STRB     R0,[R4], #+1
   \   00000026   0xB001             ADD      SP,SP,#+4
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0xBD30             POP      {R4,R5,PC}       ;; return
    740          }
    741          
    742          
    743          /**************************************************************************//*!
    744          *
    745          * @brief    Private inline implementation of "strlen" used by TSA and Pipes
    746          *
    747          ******************************************************************************/
    748          

   \                                 In section .text, align 4, keep-with-next
    749          MC_U16 MC_StrLen(MC_ADDR nAddr)
    750          {
    751              const MC_U8* pStr;
    752              MC_U16 nLen = 0U;
    753          
    754              #ifdef __HCS12X__
    755              /* convert from logical to global if needed */
    756              nAddr = MC_FixHcs12xAddr(nAddr);
    757              #endif
    758          
    759              /*lint -e{923} casting address value to pointer */
    760              pStr = (const MC_U8*) nAddr;
    761              
    762              while(*pStr++)
   \                     MC_StrLen: (+1)
   \   00000000   0x7802             LDRB     R2,[R0, #+0]
   \   00000002   0xF05F 0x0100      MOVS.W   R1,#+0
   \   00000006   0xB18A             CBZ.N    R2,??MC_StrLen_0
    763              {
    764                  nLen++;
   \                     ??MC_StrLen_1: (+1)
   \   00000008   0xF810 0x2F01      LDRB     R2,[R0, #+1]!
   \   0000000C   0x1C49             ADDS     R1,R1,#+1
   \   0000000E   0xB16A             CBZ.N    R2,??MC_StrLen_0
   \   00000010   0xF810 0x2F01      LDRB     R2,[R0, #+1]!
   \   00000014   0x1C49             ADDS     R1,R1,#+1
   \   00000016   0xB14A             CBZ.N    R2,??MC_StrLen_0
   \   00000018   0xF810 0x2F01      LDRB     R2,[R0, #+1]!
   \   0000001C   0x1C49             ADDS     R1,R1,#+1
   \   0000001E   0x2A00             CMP      R2,#+0
   \   00000020   0xD004             BEQ.N    ??MC_StrLen_0
   \   00000022   0xF810 0x2F01      LDRB     R2,[R0, #+1]!
   \   00000026   0x1C49             ADDS     R1,R1,#+1
   \   00000028   0x2A00             CMP      R2,#+0
   \   0000002A   0xD1ED             BNE.N    ??MC_StrLen_1
    765              }
    766                  
    767              return nLen;
   \                     ??MC_StrLen_0: (+1)
   \   0000002C   0xB288             UXTH     R0,R1
   \   0000002E   0x4770             BX       LR               ;; return
    768          }
    769          
    770          /**
    771          *
    772          * @brief    Handling READLF command
    773          *
    774          * @param    pMessageIO - original command (in) and response buffer (out)
    775          *
    776          * @return   As all command handlers, the return value should be the buffer
    777          *           pointer where the response output finished (except checksum)
    778          *
    779          */

   \                                 In section .text, align 2, keep-with-next
    780          MC_BPTR MC_ReadLF(MC_BPTR pMessageIO)
    781          {
   \                     MC_ReadLF: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x4604             MOV      R4,R0
    782              MC_BPTR pResponse = pMessageIO;
    783              MC_ADDR nAddr;
    784              MC_U8 nSize;
    785              MC_U8 i;
    786          
    787              /* Skips only the command byte */
    788              pMessageIO = MC_SkipInBuffer(pMessageIO, 1U);
    789          
    790              /* Retrieve the number of words to read. This is equal to the LEN */
    791              pMessageIO = MC_ValueFromBuffer8(&nSize, pMessageIO);
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x.... 0x....      BL       MC_SkipInBuffer
   \   0000000C   0x4605             MOV      R5,R0
   \   0000000E   0xF815 0x6B01      LDRB     R6,[R5], #+1
    792          
    793              /* check the response will safely fit into comm buffer */
    794          	if(nSize > (MC_U8)MC_COMM_BUFFER_SIZE)
   \   00000012   0x2E3B             CMP      R6,#+59
   \   00000014   0xDB05             BLT.N    ??MC_ReadLF_0
    795          	{
    796          		return MC_ConstToBuffer8(pResponse, MC_STC_RSPBUFFOVF);
   \   00000016   0x2084             MOVS     R0,#+132
   \   00000018   0xF804 0x0B01      STRB     R0,[R4], #+1
    797          	}
    798          
    799          	/* success  */
    800          	pResponse = MC_ConstToBuffer8(pResponse, MC_STS_OK);
    801          	/* fixed this to support 32 bit addressing */
    802          #if MC_PLATFORM_KXX
    803          	nSize >>= (sizeof(MC_ADDR) >> 1);
    804          #else
    805          	nSize >>= 1;
    806          #endif /* MC_PLATFORM_KXX */
    807          
    808              for (i = 0; i < nSize; i++)
    809              {
    810              	pMessageIO = MC_AddressFromBuffer(&nAddr, pMessageIO);
    811              	pResponse = MC_CopyToBuffer(pResponse, nAddr, (MC_SIZE8) 2);
    812              }
    813          
    814              return pResponse;
   \   0000001C   0xB001             ADD      SP,SP,#+4
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0xBDF0             POP      {R4-R7,PC}
   \                     ??MC_ReadLF_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xF804 0x0B01      STRB     R0,[R4], #+1
   \   00000028   0x08B6             LSRS     R6,R6,#+2
   \   0000002A   0x4607             MOV      R7,R0
   \   0000002C   0xD00E             BEQ.N    ??MC_ReadLF_1
   \                     ??MC_ReadLF_2: (+1)
   \   0000002E   0x4629             MOV      R1,R5
   \   00000030   0xA800             ADD      R0,SP,#+0
   \   00000032   0x.... 0x....      BL       MC_AddressFromBuffer
   \   00000036   0x4605             MOV      R5,R0
   \   00000038   0x9900             LDR      R1,[SP, #+0]
   \   0000003A   0x2202             MOVS     R2,#+2
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       MC_CopyToBuffer
   \   00000042   0x1C7F             ADDS     R7,R7,#+1
   \   00000044   0xB2FF             UXTB     R7,R7
   \   00000046   0x4604             MOV      R4,R0
   \   00000048   0x42B7             CMP      R7,R6
   \   0000004A   0xD3F0             BCC.N    ??MC_ReadLF_2
   \                     ??MC_ReadLF_1: (+1)
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0xB001             ADD      SP,SP,#+4
   \   00000050   0xBDF0             POP      {R4-R7,PC}       ;; return
    815          
    816          }
    817          
    818          
    819          
    820          /**
    821          *
    822          * @brief    Handling WRITELF command
    823          *
    824          * @param    pMessageIO - original command (in) and response buffer (out)
    825          *
    826          * @return   As all command handlers, the return value should be the buffer
    827          *           pointer where the response output finished (except checksum)
    828          *
    829          */

   \                                 In section .text, align 2, keep-with-next
    830          MC_BPTR MC_WriteLF(MC_BPTR pMessageIO)
    831          {
   \                     MC_WriteLF: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    832              MC_BPTR pResponse = pMessageIO;
    833              MC_ADDR nAddr;
    834              MC_U8 nSize, nResponseCode, i = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    835          
    836              /* Skips only the command byte */
    837          	pMessageIO = MC_SkipInBuffer(pMessageIO, 1U);
    838          
    839          	/* Retrieve the number of words to write. This is equal to the LEN / 4 */
    840          	pMessageIO = MC_ValueFromBuffer8(&nSize, pMessageIO);
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x.... 0x....      BL       MC_SkipInBuffer
   \   0000000E   0xF810 0x6B01      LDRB     R6,[R0], #+1
    841          
    842          	while (i < nSize)
   \   00000012   0xB166             CBZ.N    R6,??MC_WriteLF_0
    843          	{
    844          		/* Retrieve the address */
    845          		pMessageIO = MC_AddressFromBuffer(&nAddr, pMessageIO);
   \                     ??MC_WriteLF_1: (+1)
   \   00000014   0x4601             MOV      R1,R0
   \   00000016   0xA800             ADD      R0,SP,#+0
   \   00000018   0x.... 0x....      BL       MC_AddressFromBuffer
   \   0000001C   0x4601             MOV      R1,R0
    846          		pMessageIO = MC_CopyFromBuffer(nAddr, pMessageIO, (MC_SIZE8) 2);
   \   0000001E   0x9800             LDR      R0,[SP, #+0]
   \   00000020   0x2202             MOVS     R2,#+2
   \   00000022   0x.... 0x....      BL       MC_CopyFromBuffer
    847          #if MC_PLATFORM_KXX
    848          		i += (2 + sizeof(MC_ADDR));
   \   00000026   0x1DAD             ADDS     R5,R5,#+6
   \   00000028   0xB2E9             UXTB     R1,R5
   \   0000002A   0x42B1             CMP      R1,R6
   \   0000002C   0xD3F2             BCC.N    ??MC_WriteLF_1
    849          #else
    850          		i += 4;
    851          #endif /* MC_PLATFORM_KXX */
    852          	}
    853          
    854          
    855              nResponseCode = MC_STS_OK;
    856          
    857              return MC_ConstToBuffer8(pResponse, nResponseCode);
   \                     ??MC_WriteLF_0: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF804 0x0B01      STRB     R0,[R4], #+1
   \   00000034   0xB002             ADD      SP,SP,#+8
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
    858          }
    859          
    860          
    861          /**
    862          *
    863          * @brief    Handling WRITELF_BYTE command
    864          *
    865          * @param    pMessageIO - original command (in) and response buffer (out)
    866          *
    867          * @return   As all command handlers, the return value should be the buffer
    868          *           pointer where the response output finished (except checksum)
    869          *
    870          */

   \                                 In section .text, align 2, keep-with-next
    871          MC_BPTR MC_WriteLF_Byte(MC_BPTR pMessageIO)
    872          {
   \                     MC_WriteLF_Byte: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    873              MC_BPTR pResponse = pMessageIO;
    874              MC_ADDR nAddr;
    875              MC_U8 nSize, nResponseCode, i = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    876          
    877              /* Skips only the command byte */
    878          	pMessageIO = MC_SkipInBuffer(pMessageIO, 1U);
    879          
    880          	/* Retrieve the number of bytes to write. For each variable we have 3 bytes. */
    881          	/* 2 for ADDR, 1 for VAL */
    882          	pMessageIO = MC_ValueFromBuffer8(&nSize, pMessageIO);
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x.... 0x....      BL       MC_SkipInBuffer
   \   0000000E   0xF810 0x6B01      LDRB     R6,[R0], #+1
    883          
    884              while (i < nSize)
   \   00000012   0xB166             CBZ.N    R6,??MC_WriteLF_Byte_0
    885              {
    886              	/* Retrieve the address */
    887              	pMessageIO = MC_AddressFromBuffer(&nAddr, pMessageIO);
   \                     ??MC_WriteLF_Byte_1: (+1)
   \   00000014   0x4601             MOV      R1,R0
   \   00000016   0xA800             ADD      R0,SP,#+0
   \   00000018   0x.... 0x....      BL       MC_AddressFromBuffer
   \   0000001C   0x4601             MOV      R1,R0
    888              	pMessageIO = MC_CopyFromBuffer(nAddr, pMessageIO, (MC_SIZE8) 1);
   \   0000001E   0x9800             LDR      R0,[SP, #+0]
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x.... 0x....      BL       MC_CopyFromBuffer
    889          #if MC_PLATFORM_KXX
    890              	i += (1 + sizeof(MC_ADDR));
   \   00000026   0x1D6D             ADDS     R5,R5,#+5
   \   00000028   0xB2E9             UXTB     R1,R5
   \   0000002A   0x42B1             CMP      R1,R6
   \   0000002C   0xD3F2             BCC.N    ??MC_WriteLF_Byte_1
    891          #else
    892              	i += 3;
    893          #endif /* MC_PLATFORM_KXX */
    894              }
    895          
    896          
    897              nResponseCode = MC_STS_OK;
    898          
    899              return MC_ConstToBuffer8(pResponse, nResponseCode);
   \                     ??MC_WriteLF_Byte_0: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF804 0x0B01      STRB     R0,[R4], #+1
   \   00000034   0xB002             ADD      SP,SP,#+8
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
    900          }
    901          
    902          #if MC_USE_FIXED_CMDS
                     ^
Remark[Pe193]: zero used for undefined preprocessing identifier
          "MC_USE_FIXED_CMDS"
    903          #if 0  // not supported
    904          /**
    905          *
    906          * @brief    Handling READFIX command
    907          *
    908          * @param    pMessageIO - original command (in) and response buffer (out)
    909          *
    910          * @return   As all command handlers, the return value should be the buffer
    911          *           pointer where the response output finished (except checksum)
    912          *
    913          */
    914          MC_BPTR MC_ReadFix(MC_BPTR pMessageIO)
    915          {
    916              MC_BPTR pResponse = pMessageIO;
    917              MC_ADDR pAddr = (MC_ADDR) Transmit;
    918          
    919              /* Skips only the command byte */
    920              pMessageIO = MC_SkipInBuffer(pMessageIO, 1U);
    921          
    922              /* check the response will safely fit into comm buffer */
    923              if(INPUT_LEN > (MC_U8)MC_COMM_BUFFER_SIZE)
    924              {
    925                  return MC_ConstToBuffer8(pResponse, MC_STC_RSPBUFFOVF);
    926              }
    927          
    928              /* success  */
    929              pResponse = MC_ConstToBuffer8(pResponse, MC_STS_OK);
    930          
    931              // Copy from buffer payload to send buffer
    932              pResponse = MC_CopyToBuffer(pResponse, pAddr, OUTPUT_LEN);
    933          
    934              return pResponse;
    935          }
    936          
    937          /**
    938          *
    939          * @brief    Handling WRITEFIX command
    940          *
    941          * @param    pMessageIO - original command (in) and response buffer (out)
    942          *
    943          * @return   As all command handlers, the return value should be the buffer
    944          *           pointer where the response output finished (except checksum)
    945          *
    946          */
    947          MC_BPTR MC_WriteFix(MC_BPTR pMessageIO)
    948          {
    949              MC_BPTR pResponse = pMessageIO;
    950              MC_ADDR nAddr = (MC_ADDR) Receive;
    951              MC_U8 nResponseCode;
    952          
    953              /* Skips command byte and Len byte */
    954              pMessageIO = MC_SkipInBuffer(pMessageIO, 2U);
    955          
    956              /* Retrieve the values */
    957              pMessageIO = MC_CopyFromBuffer(nAddr, pMessageIO, INPUT_LEN);
    958          
    959              nResponseCode = MC_STS_OK;
    960          
    961              return MC_ConstToBuffer8(pResponse, nResponseCode);
    962          }
    963          #endif
    964          
    965          /**
    966          *
    967          * @brief    Handling SINGLEREQ command.
    968          *
    969          * @param    pMessageIO - original command (in) and response buffer (out)
    970          *
    971          * @return   As all command handlers, the return value should be the buffer
    972          *           pointer where the response output finished (except checksum)
    973          *
    974          */
    975          MC_BPTR MC_SingleReq(MC_BPTR pMessageIO)
    976          {
    977              MC_BPTR pResponse = pMessageIO;
    978              MC_ADDR nAddr = (MC_ADDR) Receive;
    979              MC_ADDR pAddr = (MC_ADDR) Transmit;
    980              unsigned char index = 0;
    981          
    982              /* Skips command byte and Len byte */
    983              pMessageIO = MC_SkipInBuffer(pMessageIO, 2U);
    984          
    985              /* Retrieve the index byte */
    986              pMessageIO = MC_ValueFromBuffer8(&index, pMessageIO);
    987          
    988              /* Retrieve the values */
    989              pMessageIO = MC_CopyFromBuffer(nAddr, pMessageIO, SIM_INPUT_LEN_ARRAY[index]);
    990          
    991              // Copy to the mapped variables
    992              COPY_TO_VAR(index, Receive);
    993          
    994              // Call back
    995              SINGLEREQ_CALLBACK(index);
    996          
    997              // Read operation
    998              // check the response will safely fit into comm buffer
    999              if(SIM_INPUT_LEN_ARRAY[index] > (MC_U8)MC_COMM_BUFFER_SIZE)
   1000              {
   1001                  return MC_ConstToBuffer8(pResponse, MC_STC_RSPBUFFOVF);
   1002              }
   1003          
   1004              // Success
   1005              pResponse = MC_ConstToBuffer8(pResponse, MC_STS_OK);
   1006              // Copy from variables to buffer payload
   1007              COPY_FROM_VAR(index, Transmit);
   1008          
   1009              // Copy from buffer payload to send buffer
   1010              pResponse = MC_CopyToBuffer(pResponse, pAddr, SIM_OUTPUT_LEN_ARRAY[index]);
   1011          
   1012              return pResponse;
   1013          }
   1014          
   1015          #endif /* MC_USE_FIXED_CMDS */
   1016          #else /* !MC_DISABLE */
   1017          
   1018          /**************************************************************************//*!
   1019          *
   1020          * @brief    mc driver initialization is disabled
   1021          *
   1022          ******************************************************************************/
   1023          
   1024          MC_BOOL MC_Init(void)
   1025          {   
   1026              return MC_FALSE;
   1027          }
   1028          
   1029          /*******************************************************************************
   1030          *
   1031          * @brief    API: Main "Polling" call from the application main loop
   1032          *
   1033          *******************************************************************************/
   1034          
   1035          void MC_Poll(void)
   1036          { 
   1037          }
   1038          
   1039          /* HC12 interrupt routine declaration, must be in non-paged code memory */
   1040          #if defined(MC_PLATFORM_HC12) && (!defined(__S12Z__))
   1041              #include "non_bank.sgm"
   1042          #endif
   1043          
   1044          /*******************************************************************************
   1045          *
   1046          * @brief    API: API: Main SCI / CAN Interrupt handler call
   1047          *
   1048          *******************************************************************************/
   1049          #if !defined(MC_PLATFORM_MQX)
   1050          #if defined(MC_PLATFORM_MPC55xx)
   1051          void MC_Isr(unsigned long vec)
   1052          {
   1053              MC_UNUSED(vec);
   1054          }
   1055          #else
   1056          void MC_Isr(void)
   1057          {
   1058          }
   1059          #endif
   1060          #endif
   1061          
   1062          #if defined(MC_PLATFORM_HC12) || defined(MC_PLATFORM_HC08) || defined(MC_PLATFORM_MCF51xx)
   1063          /*******************************************************************************
   1064          *
   1065          * @brief    API: API: The 2nd MC interrupt handler
   1066          *
   1067          *******************************************************************************/
   1068          
   1069          void MC_Isr2(void)
   1070          {
   1071          }
   1072          
   1073          #endif
   1074          
   1075          /* restore HC12 code segment */
   1076          #if defined(MC_PLATFORM_HC12) && (!defined(__S12Z__))
   1077              #include "default.sgm"
   1078          #endif
   1079          
   1080          #endif /* !MC_DISABLE */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   MC_GetBoardInfo
        16   -> MC_CopyToBuffer
        16   -> MC_GetRecBuffSize
        16   -> MC_SkipInBuffer
       8   MC_Init
         8   -> MC_InitRec
         8   -> MC_InitScope
         8   -> MC_InitSerial
      16   MC_ProtocolDecoder
        16   -> MC_AddressFromBuffer
        16   -> MC_CopyFromBuffer
        16   -> MC_CopyFromBufferWithMask
        16   -> MC_GetBoardInfo
        16   -> MC_GetRecBuff
        16   -> MC_GetRecStatus
        16   -> MC_ReadLF
        16   -> MC_ReadMem
        16   -> MC_ReadScope
        16   -> MC_SendResponse
        16   -> MC_SetUpRec
        16   -> MC_SetUpScope
        16   -> MC_StartRec
        16   -> MC_StopRec
        16   -> MC_WriteLF
        16   -> MC_WriteLF_Byte
      24   MC_ReadLF
        24   -> MC_AddressFromBuffer
        24   -> MC_CopyToBuffer
        24   -> MC_SkipInBuffer
      16   MC_ReadMem
        16   -> MC_AddressFromBuffer
        16   -> MC_CopyToBuffer
        16   -> MC_SkipInBuffer
      16   MC_ReadVar
        16   -> MC_AddressFromBuffer
        16   -> MC_CopyToBuffer
        16   -> MC_SkipInBuffer
       0   MC_SkipInBuffer
       0   MC_StrLen
      24   MC_WriteLF
        24   -> MC_AddressFromBuffer
        24   -> MC_CopyFromBuffer
        24   -> MC_SkipInBuffer
      24   MC_WriteLF_Byte
        24   -> MC_AddressFromBuffer
        24   -> MC_CopyFromBuffer
        24   -> MC_SkipInBuffer
      16   MC_WriteMem
        16   -> MC_AddressFromBuffer
        16   -> MC_CopyFromBuffer
        16   -> MC_SkipInBuffer
      16   MC_WriteMemMask
        16   -> MC_AddressFromBuffer
        16   -> MC_CopyFromBufferWithMask
        16   -> MC_SkipInBuffer
      16   MC_WriteVar
        16   -> MC_AddressFromBuffer
        16   -> MC_CopyFromBuffer
        16   -> MC_SkipInBuffer
      16   MC_WriteVarMask
        16   -> MC_AddressFromBuffer
        16   -> MC_CopyFromBufferWithMask
        16   -> MC_SkipInBuffer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      88  MC_GetBoardInfo
      24  MC_Init
     252  MC_ProtocolDecoder
      82  MC_ReadLF
      70  MC_ReadMem
      42  MC_ReadVar
       4  MC_SkipInBuffer
      48  MC_StrLen
      58  MC_WriteLF
      58  MC_WriteLF_Byte
      52  MC_WriteMem
      52  MC_WriteMemMask
      44  MC_WriteVar
      44  MC_WriteVarMask

 
 918 bytes in section .text
 
 918 bytes of CODE memory

Errors: none
Warnings: 1
