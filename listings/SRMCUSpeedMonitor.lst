###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        13/Mar/2025  15:31:37
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  XCategory\Common\SRMcuSpeedMonitor\SRMCUSpeedMonitor.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        SRMCUSpeedMonitor.obj -l ..\listings\SRMCUSpeedMonitor.lst
#        XCategory\Common\SRMcuSpeedMonitor\SRMCUSpeedMonitor.c
#    List file    =  ..\listings\SRMCUSpeedMonitor.lst
#    Object file  =  SRMCUSpeedMonitor.obj
#
###############################################################################

C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Common\SRMcuSpeedMonitor\SRMCUSpeedMonitor.c
      1          /**
      2           * @file        SRMCUSpeedMonitor.c
      3           * @brief       MCU Speed monitor - ACU extension in MCU to monitor and allow/deny motor to run
      4           *              Monitors the status from ACU and enables motor control accordingly. Also,
      5           *              monitors the status from MCU and publish to the WIN bus
      6           * @defgroup    CLASS_B Class_B_Group Class B Motor Control Unit Speed Monitor
      7           *
      8           * @details     Motor shall be allow to run under few sceneries (safe to run):
      9           *              1.  API20 non error: timeout is not expired or correct sequence,
     10           *                  no error is detected from API20. API20 living is the link that
     11           *                  ensures the data from door lock status installed in the ACU.
     12           *                  Upon an API20 failure, the status are not be updated anymore, therefore
     13           *                  the default reaction is to block the motor by class B means.
     14           *              2.  Motor enabled and not limited: allowed to run at any speed
     15           *              3.  Motor enabled and limited: allowed to run with speed below a threshold
     16           *              4.  Motor not enabled: motor is blocked to start
     17           *
     18           * @copyright   Copyright 2017 Whirlpool Corporation.  All rights reserved - CONFIDENTIAL.
     19           *
     20           */
     21          
     22          // --- Include Files --------------------------------------------------------------------------------------------------
     23          #include "SRSystemConfig.h"                         //!< System configuration
     24          #include "Compiler_defs.h"                          //!< Compiler definition
     25          #include "C_Extensions.h"                           //!< C extension
     26          #include "SRAPI020Safety.h"                         //!< Class B API020 (Safety relevant communication)

  PACKED typedef struct API019_APPLIANCE_DATA_STRUCT
         ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Application\Reveal_APIs\API019ProductInfo\API019ProductInfo_Defs.h",42  Remark[Pe082]: 
          storage class is not first

  PACKED typedef struct API019_BOARD_DATA_STRUCT
         ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Application\Reveal_APIs\API019ProductInfo\API019ProductInfo_Defs.h",50  Remark[Pe082]: 
          storage class is not first

  PACKED typedef struct API019_TEST_DATA_STRUCT
         ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Application\Reveal_APIs\API019ProductInfo\API019ProductInfo_Defs.h",141  Remark[Pe082]: 
          storage class is not first

  PACKED typedef struct API019_SERVICE_DATA_STRUCT
         ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Application\Reveal_APIs\API019ProductInfo\API019ProductInfo_Defs.h",150  Remark[Pe082]: 
          storage class is not first

  PACKED typedef struct API019_PROJECT_DATA_STRUCT
         ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Application\Reveal_APIs\API019ProductInfo\API019ProductInfo_Defs.h",183  Remark[Pe082]: 
          storage class is not first
     27          #include "SRMCUSpeedMonitor.h"                      //!< Class B speed monitor header
     28          #include "SRMCUSpeedMonitor_prv.h"                  //!< Class B speed monitor parameters
     29          #include "Micro.h"                                  //!< Micro definition
     30          
     31          // --- Private Declarations -------------------------------------------------------------------------------------------
     32          
     33          
     34          // -- Private Constant Declarations --
     35          
     36          // -- Private Structure Type Declarations --
     37          
     38          
     39          // --- Private Definitions --------------------------------------------------------------------------------------------
     40          
     41          //! Convert the timer set from seconds to the routine ticks.

   \                                 In section .rodata, align 1, keep-with-next
     42          const uint8 SR_SPEED_MONITOR_TX_TIMER = (uint8)((1.0f/25.0f) * 1300); //!< Set to 1.3 seconds to prevent marginal timing
   \                     SR_SPEED_MONITOR_TX_TIMER:
   \   00000000   0x34               DC8 52
     43                                                                                //!< with SRAPI020.
     44                                                                                //!< Refer to SRAPI020_SPEED_MONITOR_TX_RATE_MS
     45          
     46          #ifdef SR_REQUEST_CLASS_A_DEBOUNCER
     47          
     48              #if (SR_REQUEST_CLASS_A_DEBOUNCER >= 255)
     49                  #error Debouncer must be smaller than or equal to 254. Sanity check of uint8 size to prevent overflow.
     50              #endif
     51          
     52              //! Debouncer used when class A requests unlock door speed fault
     53              const uint8 SR_REQUEST_CLASS_A_DEBOUNCER_RELOAD = (uint8)SR_REQUEST_CLASS_A_DEBOUNCER;
     54          #endif
     55          
     56          // -- Private Variable Definitions --
     57          
     58          #ifdef SRMCU_SPEED_MONITOR_DEBUG
     59          
     60              #warning SRMCU_SPEED_MONITOR_DEBUG shall not be used in certification!!
     61              #warning SRMCU_SPEED_MONITOR_DEBUG shall not be used in certification!!
     62              #warning SRMCU_SPEED_MONITOR_DEBUG shall not be used in certification!!
     63              #warning SRMCU_SPEED_MONITOR_DEBUG shall not be used in certification!!
     64              #warning SRMCU_SPEED_MONITOR_DEBUG shall not be used in certification!!
     65          
     66              volatile signed char my_speed_limited;          //!< DEBUG variable - shall not be disabled in certification
     67              volatile signed char my_motor_enabled;          //!< DEBUG variable - shall not be disabled in certification
     68              volatile signed char my_api20_still_alive;      //!< DEBUG variable - shall not be disabled in certification
     69              volatile signed char my_high_speed_detected;    //!< DEBUG variable - shall not be disabled in certification
     70          
     71              volatile signed char my_fbk_speed_limited;      //!< DEBUG variable - shall not be disabled in certification
     72              volatile signed char my_fbk_motor_enabled;      //!< DEBUG variable - shall not be disabled in certification
     73              volatile signed char my_fbk_api20_still_alive;  //!< DEBUG variable - shall not be disabled in certification
     74              volatile signed char my_fbk_high_speed_detected;//!< DEBUG variable - shall not be disabled in certification
     75          
     76          #endif
     77          
     78          
     79          //! Flag TRUE/FALSE warning if high speed is found in the Class B motor control

   \                                 In section .bss, align 1
     80          uint8 SR_Speed_Monitor_High_Speed_Found;
   \                     SR_Speed_Monitor_High_Speed_Found:
   \   00000000                      DS8 1
     81          //! Contains the data to be sent to MCU.
     82          SRAPI020_SPEED_MONITOR_TX_BIT_TYPE SR_API020_Speed_Monitor_TX_Status;
   \                     SR_API020_Speed_Monitor_TX_Status:
   \   00000001                      DS8 1
     83          //! Timer to reflect the timer. Count in routine tick
     84          uint8 SR_Speed_Monitor_TX_Handler_Timer;
   \                     SR_Speed_Monitor_TX_Handler_Timer:
   \   00000002                      DS8 1
     85          
     86          #ifdef SR_REQUEST_CLASS_A_DEBOUNCER
     87              //! Class A request - use only to set flags. no safety purpose - 0 - no request, else fault request debouncer
     88              uint8 Request_Set_Fault_From_ClassA;
     89          #endif
     90          
     91          //! Compliment of 2 of SR_Speed_Monitor_High_Speed_Found
     92          uint8 NSR_Speed_Monitor_High_Speed_Found;
   \                     NSR_Speed_Monitor_High_Speed_Found:
   \   00000003                      DS8 1
     93          //! Compliment of 2 of NSR_API020_Speed_Monitor_TX_Status
     94          SRAPI020_SPEED_MONITOR_TX_BIT_TYPE NSR_API020_Speed_Monitor_TX_Status;
   \                     NSR_API020_Speed_Monitor_TX_Status:
   \   00000004                      DS8 1
     95          //! Compliment of 2 of NSR_Speed_Monitor_TX_Handler_Timer
     96          uint8 NSR_Speed_Monitor_TX_Handler_Timer;
   \                     NSR_Speed_Monitor_TX_Handler_Timer:
   \   00000005                      DS8 1
     97          
     98          #ifdef SR_REQUEST_CLASS_A_DEBOUNCER
     99              //! Class A request - use only to set flags. no safety purpose - 0 - no request, else fault request debouncer
    100              uint8 NRequest_Set_Fault_From_ClassA;
    101          #endif
    102          
    103          //  --- Private Function Prototypes -----------------------------------------------------------------------------------
    104          static void Monitor_RX_Status_Reaction(void);
    105          static void Monitor_TX_Status(void);
    106          
    107          //! Macros to update safety relevant data
    108          //! Update SR byte
    109          #define SR_MCU_SM_UPDATE_BYTE(var, value)  {auto uint8 temp_sm_update_u8; (var) = (value); temp_sm_update_u8 = (uint8)~(value); (N##var) = temp_sm_update_u8;}
    110          //! Update SR short
    111          #define SR_MCU_SM_UPDATE_SHORT(var, value) {auto uint16 temp_sm_update_u16; (var) = (value); temp_sm_update_u16 = (uint16)~(value); (N##var) = temp_sm_update_u16;}
    112          //!< Update SR long
    113          #define SR_MCU_SM_UPDATE_LONG(var, value)  {auto uint32 temp_sm_update_u32; (var) = (value); temp_sm_update_u32 = (uint16)~(value); (N##var) = temp_sm_update_u32;}
    114          
    115          
    116          //! Macros to check safety relevant data
    117          //! Check SR byte
    118          #define SR_MCU_SM_CHECK_BYTE(check,var)    {auto uint8 temp_u8;  temp_u8 = (uint8)(var); check += (temp_u8 !=  (uint8)(~(N##var)));}
    119          //! Check SR short
    120          #define SR_MCU_SM_CHECK_SHORT(check,var)   {auto uint16 temp_u16;  temp_u16 = (uint16)(var); check += (temp_u16 != (uint16)(~(N##var)));}
    121          //! Check SR long
    122          #define SR_MCU_SM_CHECK_LONG(check,var)    {auto uint32 temp_u32;  temp_u32 = (uint32)(var); check += (temp_u32 != (uint32)(~(N##var)));}
    123          
    124          
    125          //=====================================================================================================================
    126          //-------------------------------------------- Public Functions -------------------------------------------------------
    127          //=====================================================================================================================
    128          
    129          
    130          
    131          //---------------------------------------------------------------------------------------------------------------------
    132          /**
    133           * @brief   Initialize the module's variables.
    134           */

   \                                 In section .text, align 2, keep-with-next
    135          void SRMCUSpeedMonitor__Initialize(void)
    136          {
    137              SRMCUSPEEDMONITOR_FLOW_INITIALIZE_BEGIN();
    138          
    139              SR_MCU_SM_UPDATE_BYTE(SR_Speed_Monitor_High_Speed_Found, TRUE); //lint !e64
                     ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \                     SRMCUSpeedMonitor__Initialize: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable3
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x7001             STRB     R1,[R0, #+0]
    140              SR_MCU_SM_UPDATE_BYTE(SR_API020_Speed_Monitor_TX_Status, (SRAPI020_SPEED_MONITOR_TX_BIT_TYPE)0); //lint !e64
                     ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)

      SR_MCU_SM_UPDATE_BYTE(SR_API020_Speed_Monitor_TX_Status, (SRAPI020_SPEED_MONITOR_TX_BIT_TYPE)0); //lint !e64
      ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Common\SRMcuSpeedMonitor\SRMCUSpeedMonitor.c",140  Warning[Pe188]: 
          enumerated type mixed with another type
    141              SR_MCU_SM_UPDATE_BYTE(SR_Speed_Monitor_TX_Handler_Timer, 0); //lint !e64
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x21FE             MOVS     R1,#+254
   \   0000000A   0x70C1             STRB     R1,[R0, #+3]
   \   0000000C   0x7082             STRB     R2,[R0, #+2]
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7041             STRB     R1,[R0, #+1]
   \   00000012   0x21FF             MOVS     R1,#+255
   \   00000014   0x7101             STRB     R1,[R0, #+4]
   \   00000016   0x7141             STRB     R1,[R0, #+5]
    142          
    143          #ifdef SR_REQUEST_CLASS_A_DEBOUNCER
    144              SR_MCU_SM_UPDATE_BYTE(Request_Set_Fault_From_ClassA, 0);
    145          #endif
    146          
    147              SRMCUSPEEDMONITOR__STOP_MOTOR();
    148          
    149              SRMCUSPEEDMONITOR_FLOW_INITIALIZE_END();
    150          
    151          #ifdef SRMCU_SPEED_MONITOR_DEBUG
    152          
    153              my_speed_limited = -1;
    154              my_motor_enabled = -1;
    155              my_api20_still_alive = -1;
    156              my_high_speed_detected = -1;
    157          
    158          #endif
    159          
    160          }
   \   00000018   0x4770             BX       LR               ;; return
    161          
    162          
    163          
    164          
    165          //---------------------------------------------------------------------------------------------------------------------
    166          /**
    167           * @brief   Handle the flags, status from ACU door lock and send updated status from MCU
    168           */

   \                                 In section .text, align 2, keep-with-next
    169          void SRMCUSpeedMonitor__SlowHandler(void)
    170          {
   \                     SRMCUSpeedMonitor__SlowHandler: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    171              SRMCUSPEEDMONITOR_5MS_FLOW_HANDLER_BEGIN();
    172          
    173              Monitor_RX_Status_Reaction();
   \   00000004   0xF3EF 0x8510      MRS      R5,PRIMASK
   \   00000008   0xB672             CPSID    I
   \   0000000A   0x....             LDR.N    R4,??DataTable3
   \   0000000C   0x78E1             LDRB     R1,[R4, #+3]
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x43C9             MVNS     R1,R1
   \   00000012   0xB2C9             UXTB     R1,R1
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD004             BEQ.N    ??SRMCUSpeedMonitor__SlowHandler_0
   \   00000018   0x2265             MOVS     R2,#+101
   \   0000001A   0x2164             MOVS     R1,#+100
   \   0000001C   0x200D             MOVS     R0,#+13
   \   0000001E   0x.... 0x....      BL       SRException__Queue
   \                     ??SRMCUSpeedMonitor__SlowHandler_0: (+1)
   \   00000022   0xF385 0x8810      MSR      PRIMASK,R5
   \   00000026   0xA900             ADD      R1,SP,#+0
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      BL       SRAPI020Safety__GetRxValue
    174              Monitor_TX_Status();
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   00000034   0xB672             CPSID    I
   \   00000036   0x7963             LDRB     R3,[R4, #+5]
   \   00000038   0x78A2             LDRB     R2,[R4, #+2]
   \   0000003A   0x43DB             MVNS     R3,R3
   \   0000003C   0xB2DB             UXTB     R3,R3
   \   0000003E   0x429A             CMP      R2,R3
   \   00000040   0xBF18             IT       NE 
   \   00000042   0x2001             MOVNE    R0,#+1
   \   00000044   0x78E3             LDRB     R3,[R4, #+3]
   \   00000046   0x7822             LDRB     R2,[R4, #+0]
   \   00000048   0x43DB             MVNS     R3,R3
   \   0000004A   0xB2DB             UXTB     R3,R3
   \   0000004C   0x429A             CMP      R2,R3
   \   0000004E   0xBF18             IT       NE 
   \   00000050   0x1C40             ADDNE    R0,R0,#+1
   \   00000052   0x7923             LDRB     R3,[R4, #+4]
   \   00000054   0x7862             LDRB     R2,[R4, #+1]
   \   00000056   0x43DB             MVNS     R3,R3
   \   00000058   0xB2DB             UXTB     R3,R3
   \   0000005A   0x429A             CMP      R2,R3
   \   0000005C   0xBF18             IT       NE 
   \   0000005E   0x1C40             ADDNE    R0,R0,#+1
   \   00000060   0xBB98             CBNZ.N   R0,??SRMCUSpeedMonitor__SlowHandler_1
   \   00000062   0xF381 0x8810      MSR      PRIMASK,R1
   \   00000066   0x78A0             LDRB     R0,[R4, #+2]
   \   00000068   0xB130             CBZ.N    R0,??SRMCUSpeedMonitor__SlowHandler_2
   \   0000006A   0x1E40             SUBS     R0,R0,#+1
   \   0000006C   0x70A0             STRB     R0,[R4, #+2]
    175          
    176              SRMCUSPEEDMONITOR_5MS_FLOW_HANDLER_END();
    177          }
   \   0000006E   0xB001             ADD      SP,SP,#+4
   \   00000070   0xB2C0             UXTB     R0,R0
   \   00000072   0x43C0             MVNS     R0,R0
   \   00000074   0x7160             STRB     R0,[R4, #+5]
   \   00000076   0xBD30             POP      {R4,R5,PC}
   \                     ??SRMCUSpeedMonitor__SlowHandler_2: (+1)
   \   00000078   0x7821             LDRB     R1,[R4, #+0]
   \   0000007A   0x2900             CMP      R1,#+0
   \   0000007C   0xBF14             ITE      NE 
   \   0000007E   0xF042 0x0501      ORRNE    R5,R2,#0x1
   \   00000082   0xF002 0x05FE      ANDEQ    R5,R2,#0xFE
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x.... 0x....      BL       SRMotorSafetyMgr__GetFlag
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xBF14             ITE      NE 
   \   00000090   0xF045 0x0502      ORRNE    R5,R5,#0x2
   \   00000094   0xF005 0x05FD      ANDEQ    R5,R5,#0xFD
   \   00000098   0x2003             MOVS     R0,#+3
   \   0000009A   0x.... 0x....      BL       SRMotorSafetyMgr__GetFaultHolder
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xBF1A             ITTE     NE 
   \   000000A2   0xF005 0x00FD      ANDNE    R0,R5,#0xFD
   \   000000A6   0xF040 0x0004      ORRNE    R0,R0,#0x4
   \   000000AA   0xF005 0x00FB      ANDEQ    R0,R5,#0xFB
   \   000000AE   0x7060             STRB     R0,[R4, #+1]
   \   000000B0   0x1C61             ADDS     R1,R4,#+1
   \   000000B2   0x43C0             MVNS     R0,R0
   \   000000B4   0x7120             STRB     R0,[R4, #+4]
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x.... 0x....      BL       SRAPI020Safety__SetTxValue
   \   000000BC   0xB150             CBZ.N    R0,??SRMCUSpeedMonitor__SlowHandler_3
   \   000000BE   0x2034             MOVS     R0,#+52
   \   000000C0   0x70A0             STRB     R0,[R4, #+2]
   \   000000C2   0xB001             ADD      SP,SP,#+4
   \   000000C4   0x20CB             MOVS     R0,#+203
   \   000000C6   0x7160             STRB     R0,[R4, #+5]
   \   000000C8   0xBD30             POP      {R4,R5,PC}
   \                     ??SRMCUSpeedMonitor__SlowHandler_1: (+1)
   \   000000CA   0x2265             MOVS     R2,#+101
   \   000000CC   0x2164             MOVS     R1,#+100
   \   000000CE   0x200D             MOVS     R0,#+13
   \   000000D0   0x.... 0x....      BL       SRException__Queue
   \                     ??SRMCUSpeedMonitor__SlowHandler_3: (+1)
   \   000000D4   0xB001             ADD      SP,SP,#+4
   \   000000D6   0xBD30             POP      {R4,R5,PC}       ;; return
    178          
    179          
    180          
    181          
    182          /*
    183           * @brief       Set or reset the warning that speed is above the threshold
    184           * @param[in]   high_speed_detected [0 - FALSE/Otherwise - TRUE] speed above the threshold
    185           *
    186           */

   \                                 In section .text, align 2, keep-with-next
    187          void SRMCUSpeedMonitor__High_Speed_Detected(uint8 high_speed_detected)
    188          {
   \                     SRMCUSpeedMonitor__High_Speed_Detected: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xB081             SUB      SP,SP,#+4
    189              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    190              uint32 check_integrity_status;
    191          
    192              check_integrity_status = FALSE;
    193          
    194              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   00000004   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   00000008   0xB672             CPSID    I
    195              SR_MCU_SM_CHECK_BYTE(check_integrity_status, SR_Speed_Monitor_High_Speed_Found);
                     ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \   0000000A   0x....             LDR.N    R2,??DataTable3
   \   0000000C   0x78D4             LDRB     R4,[R2, #+3]
   \   0000000E   0x7813             LDRB     R3,[R2, #+0]
   \   00000010   0x43E4             MVNS     R4,R4
   \   00000012   0xB2E4             UXTB     R4,R4
   \   00000014   0x42A3             CMP      R3,R4
   \   00000016   0xD10F             BNE.N    ??SRMCUSpeedMonitor__High_Speed_Detected_0
    196          
    197              if(check_integrity_status == FALSE)
    198              {
    199                  MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL()
   \   00000018   0xF381 0x8810      MSR      PRIMASK,R1
    200          
    201                  if(high_speed_detected)
   \   0000001C   0xB130             CBZ.N    R0,??SRMCUSpeedMonitor__High_Speed_Detected_1
    202                  {
    203                      SR_MCU_SM_UPDATE_BYTE(SR_Speed_Monitor_High_Speed_Found, TRUE); //lint !e64
                             ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x7010             STRB     R0,[R2, #+0]
    204                  }
    205                  else
    206                  {
    207                      SR_MCU_SM_UPDATE_BYTE(SR_Speed_Monitor_High_Speed_Found, FALSE); //lint !e64
                             ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
    208                  }
    209              }
    210              else
    211              {
    212                  // Then block motor driving
    213                  SRMCUSPEEDMONITOR__STOP_MOTOR();
    214          
    215                  // Invoke Exception
    216                  SRMCUSPEEDMONITOR__CORRUPTED_VAR();
    217              }
    218          }
   \   00000022   0xB001             ADD      SP,SP,#+4
   \   00000024   0x20FE             MOVS     R0,#+254
   \   00000026   0x70D0             STRB     R0,[R2, #+3]
   \   00000028   0xBC10             POP      {R4}
   \   0000002A   0x4770             BX       LR
   \                     ??SRMCUSpeedMonitor__High_Speed_Detected_1: (+1)
   \   0000002C   0x7010             STRB     R0,[R2, #+0]
   \   0000002E   0xB001             ADD      SP,SP,#+4
   \   00000030   0x20FF             MOVS     R0,#+255
   \   00000032   0x70D0             STRB     R0,[R2, #+3]
   \   00000034   0xBC10             POP      {R4}
   \   00000036   0x4770             BX       LR
   \                     ??SRMCUSpeedMonitor__High_Speed_Detected_0: (+1)
   \   00000038   0xB001             ADD      SP,SP,#+4
   \   0000003A   0xBC10             POP      {R4}
   \   0000003C   0x2265             MOVS     R2,#+101
   \   0000003E   0x2164             MOVS     R1,#+100
   \   00000040   0x200D             MOVS     R0,#+13
   \   00000042   0x.... 0x....      B.W      SRException__Queue
    219          
    220          
    221          
    222          
    223          //---------------------------------------------------------------------------------------------------------------------
    224          /*
    225           * @brief       Set unlock door speed fault to be reported by SRAPI020.
    226           * @param[in]   None
    227           *
    228           */

   \                                 In section .text, align 2, keep-with-next
    229          void SRMCUSpeedMonitor__SetUnlockDoorFault(void)
    230          {
    231              #ifdef SR_REQUEST_CLASS_A_DEBOUNCER
    232          
    233                  MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    234                  uint32 check_integrity_status;
    235          
    236                  check_integrity_status = FALSE;
    237          
    238                  MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
    239                  SR_MCU_SM_CHECK_BYTE(check_integrity_status, Request_Set_Fault_From_ClassA);
    240                  MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL()
    241          
    242                  if(check_integrity_status)
    243                  {
    244                  	// Integrity is corrupt
    245                  	
    246                      // Then block motor driving
    247                      SRMCUSPEEDMONITOR__STOP_MOTOR();
    248          
    249                      // Invoke Exception
    250                      SRMCUSPEEDMONITOR__CORRUPTED_VAR();
    251                  }
    252                  else
    253                  {
    254                  	// Integrity is intact
    255                  	
    256                      SR_MCU_SM_UPDATE_BYTE(Request_Set_Fault_From_ClassA, SR_REQUEST_CLASS_A_DEBOUNCER_RELOAD);
    257                  }
    258          
    259              #endif
    260          }
   \                     SRMCUSpeedMonitor__SetUnlockDoorFault: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     SR_Speed_Monitor_High_Speed_Found
    261          
    262          
    263          
    264          //=====================================================================================================================
    265          //  --- Private Functions ---------------------------------------------------------------------------------------------
    266          //=====================================================================================================================
    267          
    268          
    269          //---------------------------------------------------------------------------------------------------------------------
    270          /**
    271           * @brief   Handle the status from API20 (ACU Door lock module) and MCU and take proper reaction to them.
    272           *
    273             @startuml{SRMCUSpeedMonitor_RX_Monitor.png}
    274                 (*)  --> "Get SRAPI020 is valid/alive,\nmotor enabled and speed limited status flags"
    275          
    276                 if "" then
    277                     -left-> [neither alive nor valid] "motor enabled = FALSE"
    278                     --> " " as cont1
    279                 else
    280                     --> [alive and valid] cont1
    281                 endif
    282          
    283                 if "" then
    284                     --> [motor enabled] if "" then
    285                                   --> [speed limited] if "" then
    286                                                 --> [high speed\ndetected] "Invoke Class B motor control to force to stop motor" as force_stop
    287                                             else
    288                                                 --> [high speed\nnot detected] "No action is taken" as no_action_taken
    289                                                 --> (*)
    290                                             endif
    291                               else
    292                                   --> [speed not limited] no_action_taken
    293                                   --> (*)
    294                               endif
    295                 else
    296                     --> [motor disabled] force_stop
    297                 endif
    298          
    299                 force_stop --> (*)
    300             @enduml
    301           *
    302           */
    303          #ifdef __IAR_SYSTEMS_ICC__
    304              #pragma inline = forced
    305          #endif
    306          void Monitor_RX_Status_Reaction(void)
    307          {
    308              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    309              uint32 check_integrity_status;
    310              uint8 motor_enabled;
    311              uint8 speed_limited;
    312              uint8 high_speed_detected;
    313              uint8 srapi20_alive;
    314              SRAPI020_SPEED_MONITOR_RX_BIT_TYPE speed_monitor_status_api20_rx;
    315          
    316              check_integrity_status = FALSE;
    317          
    318              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
    319              SR_MCU_SM_CHECK_BYTE(check_integrity_status, SR_Speed_Monitor_High_Speed_Found);
                     ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
    320          
    321              // Variable is corrupted
    322              if(check_integrity_status == TRUE)
    323              {
    324                  // Then block motor driving
    325                  SRMCUSPEEDMONITOR__STOP_MOTOR();
    326          
    327                  // Invoke Exception
    328                  SRMCUSPEEDMONITOR__CORRUPTED_VAR();
    329              }
    330          
    331              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
    332          
    333          
    334              // Check speed monitor package status from SRAPI020
    335              srapi20_alive = SRAPI020Safety__GetRxValue(API020_RX_SPEED_MONITOR_STATUS, &speed_monitor_status_api20_rx);
    336          
    337              //// Update status flags
    338              // from SRAPI020 Receiver
    339              motor_enabled = BIT_TEST(speed_monitor_status_api20_rx, SRAPI020_SPEED_MONITOR__RX_ENABLED);
    340              speed_limited = BIT_TEST(speed_monitor_status_api20_rx, SRAPI020_SPEED_MONITOR__RX_LIMITED);
    341              // from SRSafetyMotorMgr (Motor Control)
    342              high_speed_detected = SR_Speed_Monitor_High_Speed_Found;
    343          
    344          
    345          #ifdef SRMCU_SPEED_MONITOR_DEBUG
    346          
    347              //////////// START debug code
    348              if(my_motor_enabled >= 0)           motor_enabled = my_motor_enabled;
    349              if(my_speed_limited >= 0)           speed_limited = my_speed_limited;
    350              if(my_api20_still_alive >= 0)       srapi20_alive = my_api20_still_alive;
    351              if(my_high_speed_detected >= 0)     high_speed_detected = my_high_speed_detected;
    352          
    353              my_fbk_speed_limited       = speed_limited;
    354              my_fbk_motor_enabled       = motor_enabled;
    355              my_fbk_api20_still_alive   = srapi20_alive;
    356              my_fbk_high_speed_detected = high_speed_detected;
    357              /////////// END debug code.
    358          
    359          #endif
    360          
    361          
    362              // If communication is NOT alive and NOT valid
    363              // (SRAPI020 timeout, invalid sequence, invalid data, etc.)
    364              if( !srapi20_alive )
    365              {
    366                  // disable motor driving because communication is invalid
    367                  motor_enabled = FALSE;
    368              }
    369          
    370          
    371              //// Do logic with status flags
    372              // If motor driving enabled
    373              if(motor_enabled)
    374              {
    375                  // if the speed is requested to be limited
    376                  if(speed_limited)
    377                  {
    378                      // if the speed is detected to be above the threshold
    379                      // (threshold is set in the SRMotorSafetyMngr)
    380                      if(high_speed_detected)
    381                      {
    382                          // Then block motor driving
    383                          SRMCUSPEEDMONITOR__STOP_MOTOR();
    384                      }
    385                  }
    386              }
    387              else // else motor driving is disabled
    388              {
    389                  // Then block motor driving
    390                  SRMCUSPEEDMONITOR__STOP_MOTOR();
    391              }
    392          }
    393          
    394          
    395          
    396          
    397          //---------------------------------------------------------------------------------------------------------------------
    398          /**
    399           * @brief   Handle the flags from the SR Motor control module and update the API20, ACU SRDoor lock module
    400           *
    401           *
    402             @startuml{SRMCUSpeedMonitor_Monitor_TX_Status.png}
    403                 (*)  --> "Wait for publishing time"
    404                 "Wait for publishing time" --> [not expired] "Wait for publishing time"
    405                 --> [time expired] "Read unlock speed\nunlock speed failed and\nhigh speed flags" as read_flags
    406                 if "   try enqueue data" then
    407                     --> [enqueued] "Reload timer"
    408                     --> (*)
    409                 else
    410                     --> [not enqueued] read_flags
    411                 endif
    412             @enduml
    413           *
    414           */
    415          #ifdef __IAR_SYSTEMS_ICC__
    416              #pragma inline = forced
    417          #endif
    418          static void Monitor_TX_Status(void)
    419          {
    420              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    421              uint8 temp_u8;
    422              #ifdef SR_REQUEST_CLASS_A_DEBOUNCER
    423                  uint8 temp_u8_1;
    424              #endif
    425              SRAPI020_SPEED_MONITOR_TX_BIT_TYPE temp_status;
    426              uint32 check_integrity_status;
    427          
    428              check_integrity_status = FALSE;
    429          
    430              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
    431              SR_MCU_SM_CHECK_BYTE(check_integrity_status, SR_Speed_Monitor_TX_Handler_Timer);
                     ^
Remark[Pe1348]: declaration hides variable "temp_u8" (declared at line 421)

      SR_MCU_SM_CHECK_BYTE(check_integrity_status, SR_Speed_Monitor_TX_Handler_Timer);
      ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Common\SRMcuSpeedMonitor\SRMCUSpeedMonitor.c",431  Remark[Pa091]: 
          operator operates on value promoted to int (with possibly unexpected
          result)
    432              SR_MCU_SM_CHECK_BYTE(check_integrity_status, SR_Speed_Monitor_High_Speed_Found);
                     ^
Remark[Pe1348]: declaration hides variable "temp_u8" (declared at line 421)

      SR_MCU_SM_CHECK_BYTE(check_integrity_status, SR_Speed_Monitor_High_Speed_Found);
      ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Common\SRMcuSpeedMonitor\SRMCUSpeedMonitor.c",432  Remark[Pa091]: 
          operator operates on value promoted to int (with possibly unexpected
          result)
    433              SR_MCU_SM_CHECK_BYTE(check_integrity_status, SR_API020_Speed_Monitor_TX_Status);
                     ^
Remark[Pe1348]: declaration hides variable "temp_u8" (declared at line 421)

      SR_MCU_SM_CHECK_BYTE(check_integrity_status, SR_API020_Speed_Monitor_TX_Status);
      ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Common\SRMcuSpeedMonitor\SRMCUSpeedMonitor.c",433  Remark[Pa091]: 
          operator operates on value promoted to int (with possibly unexpected
          result)
    434          
    435              #ifdef SR_REQUEST_CLASS_A_DEBOUNCER
    436                  SR_MCU_SM_CHECK_BYTE(check_integrity_status, Request_Set_Fault_From_ClassA);
    437              #endif
    438          
    439              if(check_integrity_status == FALSE)
    440              {
    441                  MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL()
    442          
    443                  if(SR_Speed_Monitor_TX_Handler_Timer)
    444                  {
    445                      temp_u8 = SR_Speed_Monitor_TX_Handler_Timer;
    446                      temp_u8--;
    447                      SR_MCU_SM_UPDATE_BYTE(SR_Speed_Monitor_TX_Handler_Timer, temp_u8); //lint !e64
                             ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
    448                  }
    449                  else
    450                  {
    451                      temp_status = SR_API020_Speed_Monitor_TX_Status;
    452                      // Evaluate if high speed detected
    453                      if(SR_Speed_Monitor_High_Speed_Found)
    454                      {
    455                          BIT_SET(temp_status, SRAPI020_SPEED_MONITOR__TX_HIGH_SPEED_FOUND);    //lint !e64
    456                      }
    457                      else
    458                      {
    459                          BIT_CLR(temp_status, SRAPI020_SPEED_MONITOR__TX_HIGH_SPEED_FOUND);    //lint !e64
    460                      }
    461          
    462                      // Evaluate if unlock door speed detected
    463                      temp_u8 = SRMCUSPEEDMONITOR__UNLOCK_SPEED_DETECTED();
    464                      if(temp_u8)
    465                      {
    466                          BIT_SET(temp_status, SRAPI020_SPEED_MONITOR__TX_UNLOCK_SPEED_FOUND);  //lint !e64
    467                      }
    468                      else
    469                      {
    470                          BIT_CLR(temp_status, SRAPI020_SPEED_MONITOR__TX_UNLOCK_SPEED_FOUND);  //lint !e64
    471                      }
    472          
    473                      // Evaluate if the unlock door speed detection failed
    474                      temp_u8 = (SRMCUSPEEDMONITOR__UNLOCK_SPEED_FAILED() > 0);   // Return only 1 if get is not zero
    475          
    476                      #ifdef SR_REQUEST_CLASS_A_DEBOUNCER
    477          
    478                          // Debounce request from class A
    479                          temp_u8_1 = Request_Set_Fault_From_ClassA;
    480                          if(temp_u8_1)
    481                          {
    482                              temp_u8_1--;
    483                              SR_MCU_SM_UPDATE_BYTE(Request_Set_Fault_From_ClassA, temp_u8_1);
    484          
    485                              BIT_SET(temp_status, SRAPI020_SPEED_MONITOR__TX_SHIFTER_FAILED); //lint !e64
    486                          }
    487                          else
    488                          {
    489                              BIT_CLR(temp_status, SRAPI020_SPEED_MONITOR__TX_SHIFTER_FAILED); //lint !e64
    490                          }
    491          
    492                          // Do OR between fault from class B and request to fault from class A
    493                          temp_u8 += temp_u8_1;
    494                      #endif
    495          
    496                      if(temp_u8)
    497                      {
    498                          BIT_SET(temp_status, SRAPI020_SPEED_MONITOR__TX_UNLOCK_SPEED_FAILED); //lint !e64
    499                          BIT_CLR(temp_status, SRAPI020_SPEED_MONITOR__TX_UNLOCK_SPEED_FOUND);  //lint !e64
    500                      }
    501                      else
    502                      {
    503                          BIT_CLR(temp_status, SRAPI020_SPEED_MONITOR__TX_UNLOCK_SPEED_FAILED); //lint !e64
    504                      }
    505          
    506                      SR_MCU_SM_UPDATE_BYTE(SR_API020_Speed_Monitor_TX_Status, temp_status); //lint !e64
                             ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)

              SR_MCU_SM_UPDATE_BYTE(SR_API020_Speed_Monitor_TX_Status, temp_status); //lint !e64
              ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Common\SRMcuSpeedMonitor\SRMCUSpeedMonitor.c",506  Warning[Pe188]: 
          enumerated type mixed with another type
    507          
    508                      // Handle the unlock door speed and unlock door speed failed flags...
    509                      temp_u8 = SRAPI020Safety__SetTxValue(API020_TX_SPEED_MONITOR_STATUS, &SR_API020_Speed_Monitor_TX_Status);
    510                      // If the TX command was properly stacked...
    511                      if(temp_u8)
    512                      {
    513                          // Reload the TX timer
    514                          SR_MCU_SM_UPDATE_BYTE(SR_Speed_Monitor_TX_Handler_Timer, SR_SPEED_MONITOR_TX_TIMER);
                                 ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
    515                      }
    516                  }
    517              }
    518              else
    519              {
    520                  // Then block motor driving
    521                  SRMCUSPEEDMONITOR__STOP_MOTOR();
    522          
    523                  // Invoke Exception
    524                  SRMCUSPEEDMONITOR__CORRUPTED_VAR();
    525              }
    526          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   SRMCUSpeedMonitor__High_Speed_Detected
         0   -> SRException__Queue
       0   SRMCUSpeedMonitor__Initialize
       0   SRMCUSpeedMonitor__SetUnlockDoorFault
      16   SRMCUSpeedMonitor__SlowHandler
        16   -> SRAPI020Safety__GetRxValue
        16   -> SRAPI020Safety__SetTxValue
        16   -> SRException__Queue
        16   -> SRMotorSafetyMgr__GetFaultHolder
        16   -> SRMotorSafetyMgr__GetFlag


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
      70  SRMCUSpeedMonitor__High_Speed_Detected
      26  SRMCUSpeedMonitor__Initialize
       2  SRMCUSpeedMonitor__SetUnlockDoorFault
     216  SRMCUSpeedMonitor__SlowHandler
       1  SR_SPEED_MONITOR_TX_TIMER
       6  SR_Speed_Monitor_High_Speed_Found
          SR_API020_Speed_Monitor_TX_Status
          SR_Speed_Monitor_TX_Handler_Timer
          NSR_Speed_Monitor_High_Speed_Found
          NSR_API020_Speed_Monitor_TX_Status
          NSR_Speed_Monitor_TX_Handler_Timer

 
   6 bytes in section .bss
   1 byte  in section .rodata
 318 bytes in section .text
 
 318 bytes of CODE  memory
   1 byte  of CONST memory
   6 bytes of DATA  memory

Errors: none
Warnings: 2
