###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        19/Nov/2024  13:15:25
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  Category\Application\ParamEst\ParamEst.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        ParamEst.obj -l ..\listings\ParamEst.lst
#        Category\Application\ParamEst\ParamEst.c
#    List file    =  ..\listings\ParamEst.lst
#    Object file  =  ParamEst.obj
#
###############################################################################

C:\Data\Python\Windy_sBpm_Floating\source\Category\Application\ParamEst\ParamEst.c
      1          /**
      2           *  @file
      3           *
      4           *  @brief      Source file for the ParamEst (Parameter Estimation) file.
      5           *
      6           *  @details    GDM for Parameter Estimation algorithm.
      7           *              Parameter Estimation is a fundamental algorithm used to identify parameters in models of physical
      8           *              systems. The module is quite generic, and can be applied to various products and physical processes
      9           *              through use of the physical models embedded into this module. The module is based on Recursive Least
     10           *              Squares (RLS), a well-known algorithm. The module provides an API for the user interaction.
     11           *
     12           *  @software owner     Guilherme T Silva
     13           *  @technology owner   Guilherme T Silva
     14           *
     15           *  @section    Applicable_Documents
     16           *                  Ljung and Soderstrom, Theory and Practice of Recursive Identification, 1983
     17           *                  Soderstrom and Stoica, System Identification, 1989
     18           *                  Golub and Van Loan, Matrix Computations (4th Ed), 2012  <tr>
     19           *
     20          
     21              @startuml{ParamEst_state_machine.png}
     22          
     23                  title Parameter Estimation State Machine
     24          
     25                  [*] --> Idle
     26          
     27                  Idle --> Active : ev_enable
     28          
     29                  Active : enter / ActiveEnter
     30                  Active : do / ActiveDo
     31                  Active --> Idle : ev_disable
     32          
     33              @enduml
     34          
     35           *
     36           *  @copyright  Copyright 2014 Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     37           */
     38          //---------------------------------------------------------------------------------------------------------------------
     39          //---------------------------------------------------------------------------------------------------------------------
     40          
     41          
     42          //-------------------------------------- Include Files ----------------------------------------------------------------
     43          #include "C_Extensions.h"
     44          
     45          #include "ParamEst.h"
     46          #include "ParamEst_prv.h"

   \                                 In section .rodata, align 4, keep-with-next
   \   static __absolute struct <unnamed> const Param_Est_LS_Filter_Coeffs[2]
   \                     Param_Est_LS_Filter_Coeffs:
   \   00000000   0x40000000         DC32 40000000H, 3F800000H, 0BFF7B7BAH, 3F706A38H, 3A7AC48AH, 3F800000H
   \              0x3F800000   
   \              0xBFF7B7BA   
   \              0x3F706A38   
   \              0x3A7AC48A   
   \              0x3F800000   
   \   00000018   0x00000000         DC32 0H, 0BF706666H, 0H, 3CF99998H
   \              0xBF706666   
   \              0x00000000   
   \              0x3CF99998   

   \                                 In section .rodata, align 4, keep-with-next
   \   static __absolute struct <unnamed> const Param_Est_HS_Filter_Coeffs[2]
   \                     Param_Est_HS_Filter_Coeffs:
   \   00000000   0x40000000         DC32 40000000H, 3F800000H, 0BF40E7D2H, 3ED0078DH, 3E271BF4H, 3F800000H
   \              0x3F800000   
   \              0xBF40E7D2   
   \              0x3ED0078D   
   \              0x3E271BF4   
   \              0x3F800000   
   \   00000018   0x00000000         DC32 0H, 0BE94BFF0H, 0H, 3EB5A008H
   \              0xBE94BFF0   
   \              0x00000000   
   \              0x3EB5A008   

   \                                 In section .text, align 4, keep-with-next
   \   static __absolute struct <unnamed> const Param_Est_Filter_Bank[2]
   \                     Param_Est_Filter_Bank:
   \   00000000   0x........         DC32 Param_Est_LS_Filter_Coeffs
   \   00000004   0x02 0x00          DC8 2, 0, 0, 0
   \              0x00 0x00    
   \   00000008   0x........         DC32 Param_Est_HS_Filter_Coeffs
   \   0000000C   0x02 0x00          DC8 2, 0, 0, 0
   \              0x00 0x00    
     47          #ifndef MATLAB_MEX_FILE
     48          #include "SettingFile.h"

  PACKED typedef struct
         ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Common\SettingFile\SettingFile.h",39  Remark[Pe082]: 
          storage class is not first
     49          #endif
     50          
     51          #include "limits.h"
     52          #include "math.h"
     53          #include "string.h"
     54          
     55          //=====================================================================================================================
     56          //=== StateEngineCrank (v1.5) Auto-Generated Definitions for Parameter Estimation State Machine
     57          //=====================================================================================================================
     58          // !! StateEngineCrank cannot update this code if you change the header !!
     59          
     60          
     61          //! Unique names used to identify states of the Parameter Estimation state machine.
     62          typedef enum PARAMETER_ESTIMATION_STATE_ENUM
     63          {
     64              STATE_NONE   = 0,
     65              STATE_IDLE   = 1,                               //!< (initial_state)
     66              STATE_ACTIVE = 2,
     67              STATE_PARAMETER_ESTIMATION_END = 3
     68          } PARAMETER_ESTIMATION_STATE_TYPE;
     69          
     70          //! The state variable for the Parameter Estimation state machine.
     71          //! State machines with a history pseudostate may write to this variable during initialization.
     72          //! Other state machines must only write to this variable through auto-generated functions.
     73          static PARAMETER_ESTIMATION_STATE_TYPE Parameter_Estimation_State;
     74          
     75          // -- Private Function Prototypes used by the state machine for customization functions --
     76          static void ActiveDo(void);
     77          static void ActiveEnter(void);
     78          
     79          // -- Private Function Prototypes used by the state machine for standard state machine functions --
     80          static void EventDisable(void);
     81          static void EventEnable(void);
     82          static void ParameterEstimationExecute(void);
     83          static void ParameterEstimationInitialize(void);
     84          
     85          // !! StateEngineCrank cannot update this code if you change the footer !!
     86          // End of StateEngineCrank Auto-Generated Code.
     87          
     88          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     89          
     90          //! defines the regression delay count (in number of samples) for each model for population of the regressor and output
     91          typedef unsigned char DELAY_RLS_TYPE;

   \                                 In section .text, align 4, keep-with-next
     92          static const DELAY_RLS_TYPE DELAY_RLS[] =
   \                     DELAY_RLS:
   \   00000000   0x01 0x01          DC8 1, 1, 1, 1
   \              0x01 0x01    
     93          {
     94          #if MODEL_BK_EULER_B0 == ENABLED
     95              1,  // PARAM_EST_MODEL_BK_EULER_B0
     96          #endif
     97          #if MODEL_BK_EULER == ENABLED
     98              1,  // PARAM_EST_MODEL_BK_EULER
     99          #endif
    100          #if MODEL_HYB_ACCEL == ENABLED
    101              1,  // PARAM_EST_MODEL_HYB_ACCEL
    102          #endif
    103          #if MODEL_BK_EULER_B0_BB == ENABLED
    104              1   // PARAM_EST_MODEL_BK_EULER_B0_BB
    105          #endif
    106          };
    107          //CT_ASSERT ( (sizeof(DELAY_RLS) / sizeof(DELAY_RLS[0])) == PARAM_EST_NUM_OF_MODELS );
    108          
    109          #define MSEC_TO_SEC(msec)       ((msec) / 1000.0f)                           //!< Conversion from milliseconds to seconds
    110          
    111          //! The sample rate of the ParamID algorithm. The possible combinations of slot options and
    112          //! integer downsample ratios will dictate the sample rates which may be achieved.
    113          #define TS_PARAMID              MSEC_TO_SEC(INPUT_HANDLER_TIME_SLOT * INPUT_HANDLER_SLOT_PERIODS)
    114          
    115          #define RPM_TO_RAD_S(rpm)       ((rpm) * 2.0f * INPUT_PI / 60.0f)             //!< Conversion from RPM to rad/s
    116          #define DEG_TO_RAD(deg)         ((deg) / 180.0f * INPUT_PI)                  //!< Conversion from degrees to radians
    117          #define SIGN(in)                (((in) > 0) ? 1 : (((in) < 0) ? -1 : 0))    //!< Signum (sign function) macro
    118          
    119          /**
    120           * @brief   Wrap angle into specific range.
    121           * @details Calls WrapAngleRad with an upper limit parameter specified by #PARAM_EST_ANGLE_WRAP_UPPER_LIMIT
    122           * @param angle = the angle in radians to be wrapped
    123           */
    124          #define PARAM_EST_ANGLE_WRAP(angle)       (WrapAngleRad(angle,PARAM_EST_ANGLE_WRAP_UPPER_LIMIT))
    125          
    126          typedef unsigned char DOWN_SAMPLER_COUNTER_TYPE;          // 1 = 1 call of the ParamEst__Handler()
    127          //CT_ASSERT(INPUT_HANDLER_SLOT_PERIODS <= UCHAR_MAX);
    128          
    129          /**
    130           *  Variable type definition for the module motor speed.
    131           *  Resolution: 1.0 = 1.0 rpm
    132           */
    133          typedef float MOTOR_SPEED_TYPE;
    134          
    135          //! This enum stores names of all the possible entries of the phi (regressor) vector.
    136          
    137          typedef enum REGRESSOR_ELEMENTS_ENUM
    138          {
    139          #if MODEL_BK_EULER == ENABLED || MODEL_HYB_ACCEL == ENABLED
    140              REG_ELE_SPEED,
    141          #endif
    142              REG_ELE_TORQUE,
    143              REG_ELE_CONSTANT,
    144              REG_ELE_SIN_ANGLE,
    145              REG_ELE_COS_ANGLE,
    146          #if MODEL_BK_EULER_B0_BB == ENABLED
    147              REG_ELE_SIN_BB_ANGLE,
    148              REG_ELE_COS_BB_ANGLE,
    149          #endif
    150              N_THETA_MAX
    151          } REGRESSOR_ELEMENTS_TYPE;
    152          
    153          #if MODEL_BK_EULER_B0 == ENABLED

   \                                 In section .rodata, align 4, keep-with-next
    154          static const REGRESSOR_ELEMENTS_TYPE PHI_BK_EULER_B0[] =
   \                     PHI_BK_EULER_B0:
   \   00000000   0x01 0x02          DC8 1, 2, 3, 4
   \              0x03 0x04    
    155          {
    156              REG_ELE_TORQUE,
    157              REG_ELE_CONSTANT,
    158              REG_ELE_SIN_ANGLE,
    159              REG_ELE_COS_ANGLE
    160          };
    161          #endif
    162          
    163          #if MODEL_BK_EULER == ENABLED || MODEL_HYB_ACCEL == ENABLED

   \                                 In section .rodata, align 4, keep-with-next
    164          static const REGRESSOR_ELEMENTS_TYPE PHI_BK_EULER[] =
   \                     PHI_BK_EULER:
   \   00000000   0x00 0x01          DC8 0, 1, 2, 3, 4, 0, 0, 0
   \              0x02 0x03    
   \              0x04 0x00    
   \              0x00 0x00    
    165          {
    166              REG_ELE_SPEED,
    167              REG_ELE_TORQUE,
    168              REG_ELE_CONSTANT,
    169              REG_ELE_SIN_ANGLE,
    170              REG_ELE_COS_ANGLE
    171          };
    172          #endif
    173          
    174          #if MODEL_BK_EULER_B0_BB == ENABLED

   \                                 In section .rodata, align 4, keep-with-next
    175          static const REGRESSOR_ELEMENTS_TYPE PHI_BK_EULER_B0_BB[] =
   \                     PHI_BK_EULER_B0_BB:
   \   00000000   0x01 0x02          DC8 1, 2, 3, 4, 5, 6, 0, 0
   \              0x03 0x04    
   \              0x05 0x06    
   \              0x00 0x00    

   \                                 In section .bss, align 4
    176          {
    177              REG_ELE_TORQUE,
    178              REG_ELE_CONSTANT,
    179              REG_ELE_SIN_ANGLE,
    180              REG_ELE_COS_ANGLE,
    181              REG_ELE_SIN_BB_ANGLE,
    182              REG_ELE_COS_BB_ANGLE
    183          };
    184          #endif
    185          
    186          //! declaration of the variables used when calculating the regressor
    187          typedef struct
    188          {
    189          #if MODEL_BK_EULER == ENABLED || MODEL_HYB_ACCEL == ENABLED
    190              float Phi[N_THETA_MAX];
    191          #elif MODEL_BK_EULER_B0 == ENABLED || MODEL_BK_EULER_B0_BB == ENABLED
    192              float Phi[N_THETA_MAX+1];	//One more float to filter the speed on models that don't have it in their regressor
    193          #endif
    194              float Y;
    195          } REGRESSOR_FORM_TYPE;
    196          
    197          //! PE Filter Parameters GESE structure
    198          typedef PACKED struct PARAMETER_ESTIMATION_FILTER_STRUCT
    199          {
    200          	union
    201          	{
    202          		uint8 All;
    203          		struct
    204          		{
    205          			uint8 Section_Number		:3;
    206          			uint8 Unused				:5;
    207          		} Bit;
    208          	} Byte_0;
    209          
    210          	uint8 Filter_Warmup;
    211          	uint8 Unused_Byte_2;
    212          	uint8 Unused_Byte_3;
    213          
    214          	float32 First_Filter_Coeff;
    215          } PARAMETER_ESTIMATION_FILTER_TYPE;
    216          
    217          #define S_T_NUM_OF_ROWS (2 * N_THETA_MAX)                       							//!< Number of rows in S_T (S-transposed) matrix
    218          //! This array holds the square-root covariance matrix in its upper half. P is the covariance matrix, and P = S * S'.
    219          //! The top half of this array stores S' (S-transpose, or S_T).
    220          //! In its lower half it holds the matrix V', where R = V * V' is the covariance matrix added to P in the Kalman
    221          //! adaptation method. That is P = S*S' + V*V'. If the Kalman method is not chosen, the lower half is not used.
    222          static float S_T[S_T_NUM_OF_ROWS][N_THETA_MAX];
    223          static float Theta[N_THETA_MAX];                    //!< The vector of identified digital parameters
    224          static float Lambda_Sqrt_Inv;						//!< 1 / sqrt(Lambda) Stored for ease of computation
    225          
    226          static BIQUAD_STATE_TYPE Filter_Storage[N_THETA_MAX+1][PARAM_EST_FILTER_MAX_NUM_SECTIONS];	//!< One extra slot to filter the speed when models that don't have this signal in the regressor are in use
    227          
    228          static unsigned char N_Theta;               //!< Number of digital parameters to identify. Based on the chosen model.
    229          static unsigned char Phi_Idx[N_THETA_MAX];  //!< The vector of indices for ordering the phi (regressor) vector
    230          static float Speed_Previous;                //!< Previous speed (rad/s)
    231          static float Residual;                      //!< RLS Residual (y - y_hat)
    232          
    233          #if MODEL_BK_EULER_B0_BB == ENABLED
    234          static float Alpha_UB;                      //!< Drum angle in radians
    235          static float Alpha_BB;                      //!< Modified drum angle used to represent ball balancer movement (ball balancer angle), generated by multiplying
    236                                                      //!< drum angle #Alpha_UB by the BB_Lag parameter in #Setup_Parameters
    237          #endif
    238          
    239          static const PARAM_EST_SETUP_TYPE *Setup_Parameters;        //!< Internal storage of ParamID configuration parameters address
    240          
    241          static DIGITAL_FILTER_SOS_TYPE Param_Est_Filter;			//!< Internal storage for the pre-filter configuration parameters address
   \                     Param_Est_Filter:
   \   00000000                      DS8 8
   \   00000008                      DS8 28
   \   00000024                      DS8 8
   \   0000002C                      DS8 4
   \   00000030                      DS8 1
   \   00000031                      DS8 1
   \   00000032                      DS8 1
   \   00000033                      DS8 1
   \   00000034                      DS8 392
   \   000001BC                      DS8 4
   \   000001C0                      DS8 4
   \   000001C4                      DS8 4
   \   000001C8                      DS8 4
   \   000001CC                      DS8 4
   \   000001D0                      DS8 4
   \   000001D4                      DS8 192
    242          
    243          static BOOL_TYPE Sf_Parameters_Fault;						//!< Setting file error flag
    244          
    245          //! definition of module static variables
    246          static struct
    247          {
    248              DOWN_SAMPLER_COUNTER_TYPE   Handler_Down_Sample_Counter;
    249              DELAY_RLS_TYPE              Delay_Counter;
    250              BOOL_TYPE                   Reset;
    251          } ParamID;
    252          
    253          #ifdef MATLAB_MEX_FILE
    254          static float Torque_Input;
    255          static float Speed_Input;
    256          static float Sin_Drum_Pos_Input;
    257          static float Cos_Drum_Pos_Input;
    258          #endif
    259          
    260          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
    261          
    262          static void HandleFilterReset(const PARAM_EST_SETUP_TYPE *new_parameters);
    263          static BOOL_TYPE IsModuleActive(void);
    264          static BOOL_TYPE IsSetupAdaptationKalmanValid(const PARAM_EST_SETUP_TYPE *parameters);
    265          static BOOL_TYPE IsSetupAdaptationForgettingValid(const PARAM_EST_SETUP_TYPE *parameters);
    266          static void SetupModel(const PARAM_EST_SETUP_TYPE *parameters);
    267          static BOOL_TYPE VerifySetup(const PARAM_EST_SETUP_TYPE *parameters, const DIGITAL_FILTER_SOS_TYPE *filter);
    268          
    269          static float ParamIdRLS(float y, float *phi);
    270          static void ParamIdQR(float a[][N_THETA_MAX]);
    271          static void DFiltNChan(float *u, unsigned char n_chan);
    272          static float WrapAngleRad(float angle,float ulim);
    273          static void ResetFilter(void);
    274          static DIGITAL_FILTER_SOS_TYPE GetFilterConfig(unsigned char index);
    275          static void ResetTheta(void);
    276          static REGRESSOR_FORM_TYPE GetRegressorInputs(void);
    277          static void SetSettingFileError();
    278          static void ClearSettingFileError();
    279          
    280          #if MODEL_BK_EULER_B0_BB == ENABLED
    281          static float BBAngle(float drum_angle, float lag);
    282          #endif
    283          
    284          //=====================================================================================================================
    285          //-------------------------------------- Public Functions -------------------------------------------------------------
    286          //=====================================================================================================================
    287          
    288          //---------------------------------------------------------------------------------------------------------------------
    289          /**
    290           *  @brief      It Initializes the module ParamEst and its variables
    291           *
    292           */
    293          //#pragma optimize=size no_inline no_unroll

   \                                 In section .text, align 4, keep-with-next
    294          void ParamEst__Initialize(void)
    295          {
   \                     ParamEst__Initialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    296              ParamEst__CovReset(PARAM_EST_P0_DEFAULT);                                  // Initialize the covariance matrix w/ default
   \   00000002   0xED9F 0x....      VLDR.W   S0,??DataTable12  ;; 0x447a0000
   \   00000006   0x.... 0x....      BL       ParamEst__CovReset
    297              Setup_Parameters = NULL;
   \   0000000A   0x.... 0x....      LDR.W    R4,??DataTable17
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF8C4 0x01D0      STR      R0,[R4, #+464]
    298              Speed_Previous = 0.0f;
   \   00000014   0xF8C4 0x01C0      STR      R0,[R4, #+448]
    299          #if MODEL_BK_EULER_B0_BB == ENABLED
    300              Alpha_UB = 0.0f;
   \   00000018   0xF8C4 0x01C8      STR      R0,[R4, #+456]
    301              Alpha_BB = 0.0f;
   \   0000001C   0xF8C4 0x01CC      STR      R0,[R4, #+460]
    302          #endif
    303              Residual = 0;
   \   00000020   0xF8C4 0x01C4      STR      R0,[R4, #+452]
    304              ResetTheta();
   \   00000024   0x60A0             STR      R0,[R4, #+8]
   \   00000026   0x60E0             STR      R0,[R4, #+12]
   \   00000028   0x6120             STR      R0,[R4, #+16]
   \   0000002A   0x6160             STR      R0,[R4, #+20]
   \   0000002C   0x61A0             STR      R0,[R4, #+24]
   \   0000002E   0x61E0             STR      R0,[R4, #+28]
   \   00000030   0x6220             STR      R0,[R4, #+32]
    305              ResetFilter();
   \   00000032   0x2103             MOVS     R1,#+3
   \   00000034   0xF504 0x70EA      ADD      R0,R4,#+468
   \   00000038   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   0000003C   0x2103             MOVS     R1,#+3
   \   0000003E   0xF504 0x70F6      ADD      R0,R4,#+492
   \   00000042   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   00000046   0x2103             MOVS     R1,#+3
   \   00000048   0xF504 0x7001      ADD      R0,R4,#+516
   \   0000004C   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   00000050   0x2103             MOVS     R1,#+3
   \   00000052   0xF504 0x7007      ADD      R0,R4,#+540
   \   00000056   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   0000005A   0x2103             MOVS     R1,#+3
   \   0000005C   0xF504 0x700D      ADD      R0,R4,#+564
   \   00000060   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   00000064   0x2103             MOVS     R1,#+3
   \   00000066   0xF504 0x7013      ADD      R0,R4,#+588
   \   0000006A   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   0000006E   0x2103             MOVS     R1,#+3
   \   00000070   0xF504 0x7019      ADD      R0,R4,#+612
   \   00000074   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   00000078   0x2103             MOVS     R1,#+3
   \   0000007A   0xF504 0x701F      ADD      R0,R4,#+636
   \   0000007E   0x.... 0x....      BL       DigitalFilter__ResetSOS
    306              memset(&ParamID, 0, sizeof(ParamID));
   \   00000082   0x2103             MOVS     R1,#+3
   \   00000084   0xF104 0x002C      ADD      R0,R4,#+44
   \   00000088   0x.... 0x....      BL       __aeabi_memclr4
    307              ParameterEstimationInitialize();
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0xF884 0x0030      STRB     R0,[R4, #+48]
    308              ClearSettingFileError();
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xF884 0x0032      STRB     R0,[R4, #+50]
    309          }
   \   00000098   0xBD10             POP      {R4,PC}          ;; return
    310          
    311          #ifdef MATLAB_MEX_FILE
    312          /**
    313           *  @brief  Sets Parameter Estimation inputs when PE is set to
    314           *          receive data instead of polling it from other modules
    315           *  @param  torque_nm   Torque in N*m
    316           *  @param  speed_rpm   Speed in RPM
    317           *  @param  sin_drum_pos    Drum angle sine
    318           *  @param  cos_drum_pos    Drum angle cosine
    319           *
    320           */
    321          void ParamEst__SetInputs(float torque_nm, float speed_rpm, float sin_drum_pos, float cos_drum_pos)
    322          {
    323              Torque_Input = torque_nm;
    324              Speed_Input = speed_rpm;
    325              Sin_Drum_Pos_Input = sin_drum_pos;
    326              Cos_Drum_Pos_Input = cos_drum_pos;
    327          }
    328          #endif
    329          
    330          //---------------------------------------------------------------------------------------------------------------------
    331          /**
    332           * @brief   The ParamID handler.
    333           * @details INPUT_HANDLER_TIME_SLOT shall define the call rate of this function.
    334           */
    335          //#pragma optimize=size no_inline no_unroll

   \                                 In section .text, align 2, keep-with-next
    336          void ParamEst__Handler(void)
    337          {
   \                     ParamEst__Handler: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    338              ParamID.Handler_Down_Sample_Counter = (ParamID.Handler_Down_Sample_Counter > 0) ? ParamID.Handler_Down_Sample_Counter - 1 : 0;
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable17
   \   00000008   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   0000000C   0xB090             SUB      SP,SP,#+64
   \   0000000E   0xB100             CBZ.N    R0,??ParamEst__Handler_0
   \   00000010   0x1E40             SUBS     R0,R0,#+1
   \                     ??ParamEst__Handler_0: (+1)
   \   00000012   0xF884 0x002C      STRB     R0,[R4, #+44]
    339              ParameterEstimationExecute();
   \   00000016   0xF894 0x0030      LDRB     R0,[R4, #+48]
   \   0000001A   0x2802             CMP      R0,#+2
   \   0000001C   0xBF04             ITT      EQ 
   \   0000001E   0xF894 0x002C      LDRBEQ   R0,[R4, #+44]
   \   00000022   0x2800             CMPEQ    R0,#+0
   \   00000024   0xD123             BNE.N    ??ParamEst__Handler_1
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xF884 0x002C      STRB     R0,[R4, #+44]
   \   0000002C   0xA808             ADD      R0,SP,#+32
   \   0000002E   0x.... 0x....      BL       GetRegressorInputs
   \   00000032   0xA908             ADD      R1,SP,#+32
   \   00000034   0xE8B1 0x51EC      LDM      R1!,{R2,R3,R5-R8,R12,LR}
   \   00000038   0xA800             ADD      R0,SP,#+0
   \   0000003A   0x.... 0x....      ADR.W    R1,DELAY_RLS
   \   0000003E   0xE8A0 0x51EC      STM      R0!,{R2,R3,R5-R8,R12,LR}
   \   00000042   0xF8D4 0x21D0      LDR      R2,[R4, #+464]
   \   00000046   0xF894 0x002D      LDRB     R0,[R4, #+45]
   \   0000004A   0x7F12             LDRB     R2,[R2, #+28]
   \   0000004C   0x0912             LSRS     R2,R2,#+4
   \   0000004E   0x5C51             LDRB     R1,[R2, R1]
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD309             BCC.N    ??ParamEst__Handler_2
   \   00000054   0xA800             ADD      R0,SP,#+0
   \   00000056   0xED9D 0x0A07      VLDR     S0,[SP, #+28]
   \   0000005A   0x.... 0x....      BL       ParamIdRLS
   \   0000005E   0xED84 0x0A71      VSTR     S0,[R4, #+452]
    340          }
   \   00000062   0xB010             ADD      SP,SP,#+64
   \   00000064   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??ParamEst__Handler_2: (+1)
   \   00000068   0x1C40             ADDS     R0,R0,#+1
   \   0000006A   0xF884 0x002D      STRB     R0,[R4, #+45]
   \                     ??ParamEst__Handler_1: (+1)
   \   0000006E   0xB010             ADD      SP,SP,#+64
   \   00000070   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    341          
    342          //---------------------------------------------------------------------------------------------------------------------
    343          /**
    344           *  @brief  Start the ParamID module
    345           *  @param  reset   TRUE/FALSE flag to indicate whether to reset the module, or resume from the state when
    346           *                  the module was stopped. If enabled, the covariance matrix and parameter vector are reset.
    347           *                  Parameter only has affect on module behavior if the module is inactive when API command is received.
    348           */
    349          //#pragma optimize=size no_inline no_unroll

   \                                 In section .text, align 4, keep-with-next
    350          void ParamEst__Enable(BOOL_TYPE reset)
    351          {
   \                     ParamEst__Enable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    352              if ( Setup_Parameters == NULL )
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable17
   \   00000006   0xF8D4 0x11D0      LDR      R1,[R4, #+464]
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD066             BEQ.N    ??ParamEst__Enable_0
    353              {
    354                  DEBUG_SETUP_PARAMETERS_NULL();
    355              }
    356              else
    357              {
    358          		ParamID.Reset = reset;
   \   0000000E   0xF884 0x002E      STRB     R0,[R4, #+46]
    359          		EventEnable();
   \   00000012   0xF894 0x0030      LDRB     R0,[R4, #+48]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD160             BNE.N    ??ParamEst__Enable_0
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x0030      STRB     R0,[R4, #+48]
   \   00000020   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD151             BNE.N    ??ParamEst__Enable_1
   \   00000028   0xED9F 0x....      VLDR.W   S0,??DataTable12  ;; 0x447a0000
   \   0000002C   0x.... 0x....      BL       sqrtf
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF104 0x0134      ADD      R1,R4,#+52
   \                     ??ParamEst__Enable_2: (+1)
   \   00000036   0x2200             MOVS     R2,#+0
   \                     ??ParamEst__Enable_3: (+1)
   \   00000038   0x4282             CMP      R2,R0
   \   0000003A   0xBF0C             ITE      EQ 
   \   0000003C   0xEEF0 0x0A40      VMOVEQ.F32 S1,S0
   \   00000040   0xEDDF 0x....      VLDRNE.W S1,??DataTable13  ;; 0x0
   \   00000044   0x1C52             ADDS     R2,R2,#+1
   \   00000046   0xEDC1 0x0A00      VSTR     S1,[R1, #0]
   \   0000004A   0x4282             CMP      R2,R0
   \   0000004C   0xBF0C             ITE      EQ 
   \   0000004E   0xEEF0 0x0A40      VMOVEQ.F32 S1,S0
   \   00000052   0xEDDF 0x....      VLDRNE.W S1,??DataTable13  ;; 0x0
   \   00000056   0xEDC1 0x0A07      VSTR     S1,[R1, #+28]
   \   0000005A   0x1C52             ADDS     R2,R2,#+1
   \   0000005C   0x3138             ADDS     R1,R1,#+56
   \   0000005E   0x2A0E             CMP      R2,#+14
   \   00000060   0xDBEA             BLT.N    ??ParamEst__Enable_3
   \   00000062   0x1C40             ADDS     R0,R0,#+1
   \   00000064   0xF5A1 0x71C2      SUB      R1,R1,#+388
   \   00000068   0x2807             CMP      R0,#+7
   \   0000006A   0xDBE4             BLT.N    ??ParamEst__Enable_2
   \   0000006C   0x2103             MOVS     R1,#+3
   \   0000006E   0xF504 0x70EA      ADD      R0,R4,#+468
   \   00000072   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   00000076   0x2103             MOVS     R1,#+3
   \   00000078   0xF504 0x70F6      ADD      R0,R4,#+492
   \   0000007C   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   00000080   0x2103             MOVS     R1,#+3
   \   00000082   0xF504 0x7001      ADD      R0,R4,#+516
   \   00000086   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   0000008A   0x2103             MOVS     R1,#+3
   \   0000008C   0xF504 0x7007      ADD      R0,R4,#+540
   \   00000090   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   00000094   0x2103             MOVS     R1,#+3
   \   00000096   0xF504 0x700D      ADD      R0,R4,#+564
   \   0000009A   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   0000009E   0x2103             MOVS     R1,#+3
   \   000000A0   0xF504 0x7013      ADD      R0,R4,#+588
   \   000000A4   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   000000A8   0x2103             MOVS     R1,#+3
   \   000000AA   0xF504 0x7019      ADD      R0,R4,#+612
   \   000000AE   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   000000B2   0x2103             MOVS     R1,#+3
   \   000000B4   0xF504 0x701F      ADD      R0,R4,#+636
   \   000000B8   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x60A0             STR      R0,[R4, #+8]
   \   000000C0   0x60E0             STR      R0,[R4, #+12]
   \   000000C2   0x6120             STR      R0,[R4, #+16]
   \   000000C4   0x6160             STR      R0,[R4, #+20]
   \   000000C6   0x61A0             STR      R0,[R4, #+24]
   \   000000C8   0x61E0             STR      R0,[R4, #+28]
   \   000000CA   0x6220             STR      R0,[R4, #+32]
   \                     ??ParamEst__Enable_1: (+1)
   \   000000CC   0x2002             MOVS     R0,#+2
   \   000000CE   0xF884 0x002C      STRB     R0,[R4, #+44]
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0xF8C4 0x01C0      STR      R0,[R4, #+448]
   \   000000D8   0xF884 0x002D      STRB     R0,[R4, #+45]
    360              }
    361          }
   \                     ??ParamEst__Enable_0: (+1)
   \   000000DC   0xBD10             POP      {R4,PC}          ;; return
    362          
    363          //---------------------------------------------------------------------------------------------------------------------
    364          /**
    365           * @brief Stop the ParamID module
    366           */

   \                                 In section .text, align 2, keep-with-next
    367          void ParamEst__Disable(void)
    368          {
    369              EventDisable();
   \                     ParamEst__Disable: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000004   0xF890 0x1030      LDRB     R1,[R0, #+48]
   \   00000008   0x2902             CMP      R1,#+2
   \   0000000A   0xBF04             ITT      EQ 
   \   0000000C   0x2101             MOVEQ    R1,#+1
   \   0000000E   0xF880 0x1030      STRBEQ   R1,[R0, #+48]
    370          }
   \   00000012   0x4770             BX       LR               ;; return
    371          
    372          //---------------------------------------------------------------------------------------------------------------------
    373          /**
    374           * @brief Covariance Reset Function
    375           *
    376           * @details Resets the covariance matrix used by the ParamIdRLS function. This is done as an
    377           * adaptation method. It is not required for the user to call this function. It places p0 on
    378           * the diagonal and zeros elsewhere.
    379           *
    380           * @param p0 = the value to place on the main diagonal entries of the covariance matrix.
    381           *
    382           * @return The function writes to the private array S_T.
    383           */
    384          //#pragma optimize=size no_inline no_unroll

   \                                 In section .text, align 4, keep-with-next
    385          void ParamEst__CovReset(float p0)
    386          {
   \                     ParamEst__CovReset: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    387              float s0 = sqrtf(p0);
   \   00000004   0x.... 0x....      BL       sqrtf
    388              unsigned char j;
    389              unsigned char i;
    390          
    391              for ( j = 0; j < N_THETA_MAX; j++ )
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable17_2
    392              {
    393                  for ( i = 0; i < S_T_NUM_OF_ROWS; i++ )
   \                     ??ParamEst__CovReset_0: (+1)
   \   0000000E   0x2200             MOVS     R2,#+0
    394                  {
    395                      S_T[i][j] = (i == j) ? s0 : 0.0f;
   \                     ??ParamEst__CovReset_1: (+1)
   \   00000010   0x4282             CMP      R2,R0
   \   00000012   0xBF0C             ITE      EQ 
   \   00000014   0xEEF0 0x0A40      VMOVEQ.F32 S1,S0
   \   00000018   0xEDDF 0x....      VLDRNE.W S1,??DataTable13  ;; 0x0
   \   0000001C   0x1C52             ADDS     R2,R2,#+1
   \   0000001E   0xEDC1 0x0A00      VSTR     S1,[R1, #0]
   \   00000022   0x4282             CMP      R2,R0
   \   00000024   0xBF0C             ITE      EQ 
   \   00000026   0xEEF0 0x0A40      VMOVEQ.F32 S1,S0
   \   0000002A   0xEDDF 0x....      VLDRNE.W S1,??DataTable13  ;; 0x0
   \   0000002E   0xEDC1 0x0A07      VSTR     S1,[R1, #+28]
    396                  }
   \   00000032   0x1C52             ADDS     R2,R2,#+1
   \   00000034   0x3138             ADDS     R1,R1,#+56
   \   00000036   0x2A0E             CMP      R2,#+14
   \   00000038   0xDBEA             BLT.N    ??ParamEst__CovReset_1
    397              }
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \   0000003C   0xF5A1 0x71C2      SUB      R1,R1,#+388
   \   00000040   0x2807             CMP      R0,#+7
   \   00000042   0xDBE4             BLT.N    ??ParamEst__CovReset_0
    398          }
   \   00000044   0xB001             ADD      SP,SP,#+4
   \   00000046   0xBD00             POP      {PC}             ;; return
    399          
    400          //---------------------------------------------------------------------------------------------------------------------
    401          /**
    402           *  @brief  Returns the current ParamId Setup.
    403           *  @param  parameters   Pointer to the Environment definition of the PARAM_EST_SETUP_TYPE
    404           *  @return The current Setup is not NULL
    405           */

   \                                 In section .text, align 2, keep-with-next
    406          void ParamEst__GetSetup(PARAM_EST_SETUP_TYPE *parameters)
    407          {
   \                     ParamEst__GetSetup: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000004   0xF8D1 0x11D0      LDR      R1,[R1, #+464]
   \   00000008   0xB121             CBZ.N    R1,??ParamEst__GetSetup_0
    408              if ( Setup_Parameters != NULL )
    409              {
    410              	if ( parameters != NULL )
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xBF1C             ITT      NE 
    411              		memcpy(parameters, Setup_Parameters, sizeof(PARAM_EST_SETUP_TYPE));
   \   0000000E   0x221E             MOVNE    R2,#+30
   \   00000010   0x.... 0x....      BNE.W    __aeabi_memcpy
    412              }
    413          }
   \                     ??ParamEst__GetSetup_0: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    414          
    415          //---------------------------------------------------------------------------------------------------------------------
    416          /**
    417           *  @brief  Set the module's functional parameters
    418           *  @param  parameters  Environment specific setup.
    419           *  @return Is the new ParamEst setup valid?
    420           */
    421          //#pragma optimize=size no_inline no_unroll

   \                                 In section .text, align 4, keep-with-next
    422          void ParamEst__SetSetup(const PARAM_EST_SETUP_TYPE *parameters)
    423          {
   \                     ParamEst__SetSetup: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
    424          	DIGITAL_FILTER_SOS_TYPE filter;
    425          	if ( parameters == NULL )
   \   00000006   0xF000 0x812C      BEQ.W    ??ParamEst__SetSetup_1
    426          	{
    427          		DEBUG_SETUP_PARAMETERS_NULL();
    428          		return; // do not execute the remainder of the function
    429          	}
    430          	else
    431          	{
    432          		filter = GetFilterConfig(parameters->Filter_Configuration_Index);
   \   0000000A   0x7F67             LDRB     R7,[R4, #+29]
   \   0000000C   0x2600             MOVS     R6,#+0
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0x2FFF             CMP      R7,#+255
   \   00000012   0xD021             BEQ.N    ??ParamEst__SetSetup_2
   \   00000014   0xAA00             ADD      R2,SP,#+0
   \   00000016   0x4639             MOV      R1,R7
   \   00000018   0xF240 0x2003      MOVW     R0,#+515
   \   0000001C   0x.... 0x....      BL       SettingFile__BasicLoader
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD109             BNE.N    ??ParamEst__SetSetup_3
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0xF881 0x5032      STRB     R5,[R1, #+50]
   \   0000002E   0x1D05             ADDS     R5,R0,#+4
   \   00000030   0x7801             LDRB     R1,[R0, #+0]
   \   00000032   0xF001 0x0607      AND      R6,R1,#0x7
   \   00000036   0xE013             B.N      ??ParamEst__SetSetup_4
   \                     ??ParamEst__SetSetup_3: (+1)
   \   00000038   0x2F02             CMP      R7,#+2
   \   0000003A   0xDA07             BGE.N    ??ParamEst__SetSetup_5
   \   0000003C   0x.... 0x....      ADR.W    R0,Param_Est_Filter_Bank
   \   00000040   0xF850 0x5037      LDR      R5,[R0, R7, LSL #+3]
   \   00000044   0xEB00 0x00C7      ADD      R0,R0,R7, LSL #+3
   \   00000048   0x7906             LDRB     R6,[R0, #+4]
   \   0000004A   0xE009             B.N      ??ParamEst__SetSetup_4
   \                     ??ParamEst__SetSetup_5: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xF881 0x0032      STRB     R0,[R1, #+50]
   \   00000056   0xE003             B.N      ??ParamEst__SetSetup_4
   \                     ??ParamEst__SetSetup_2: (+1)
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable17
   \   0000005C   0xF881 0x5032      STRB     R5,[R1, #+50]
    433          		if ( VerifySetup(parameters,&filter) == TRUE )
   \                     ??ParamEst__SetSetup_4: (+1)
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x7F21             LDRB     R1,[R4, #+28]
   \   00000064   0x0909             LSRS     R1,R1,#+4
   \   00000066   0x2904             CMP      R1,#+4
   \   00000068   0xBFA8             IT       GE 
   \   0000006A   0x2000             MOVGE    R0,#+0
   \   0000006C   0x7F21             LDRB     R1,[R4, #+28]
   \   0000006E   0xF011 0x010F      ANDS     R1,R1,#0xF
   \   00000072   0xD046             BEQ.N    ??ParamEst__SetSetup_6
   \   00000074   0x2902             CMP      R1,#+2
   \   00000076   0xD002             BEQ.N    ??ParamEst__SetSetup_7
   \   00000078   0xD317             BCC.N    ??ParamEst__SetSetup_8
    434          		{
    435          
    436          			// if statement defines checks applicable only when the module is currently active
    437          			if ( IsModuleActive() == TRUE )
    438          			{
    439          				if ( parameters->Model_Config.Struct.Model != Setup_Parameters->Model_Config.Struct.Model )
    440          				{
    441          					DEBUG_CANNOT_CHANGE_MODEL_WHILE_MODULE_IS_ACTIVE(parameters->Model_Config.Struct.Model);
    442          					return; // do not execute the remainder of the function
    443          				}
    444          				else
    445          				{
    446          					HandleFilterReset(parameters);
    447          				}
    448          			}
    449          
    450          			SetupModel(parameters);
    451          			Lambda_Sqrt_Inv = (parameters->Model_Config.Struct.Adapt_Type == PARAM_EST_ADAPTATION_KALMAN) ? 1.0f : 1.0f / sqrtf(parameters->Forgetting);
    452          			Setup_Parameters = parameters;  // Copy the configuration address to the module
    453          			Param_Est_Filter = filter;	// Copy the filter configuration address to the module
    454          		}
    455          	}
    456          }
   \   0000007A   0xB003             ADD      SP,SP,#+12
   \   0000007C   0xBDF0             POP      {R4-R7,PC}
   \                     ??ParamEst__SetSetup_7: (+1)
   \   0000007E   0x6861             LDR      R1,[R4, #+4]
   \   00000080   0xEE00 0x1A10      VMOV     S0,R1
   \   00000084   0xEDDF 0x....      VLDR.W   S1,??DataTable14  ;; 0x3f800001
   \   00000088   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000008C   0xEEF1 0xFA10      FMSTAT   
   \   00000090   0xF280 0x80E7      BGE.W    ??ParamEst__SetSetup_1
   \   00000094   0x6861             LDR      R1,[R4, #+4]
   \   00000096   0xEE00 0x1A10      VMOV     S0,R1
   \   0000009A   0xEDDF 0x....      VLDR.W   S1,??DataTable14_1  ;; 0x3dcccccd
   \   0000009E   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   000000A2   0xEEF1 0xFA10      FMSTAT   
   \   000000A6   0xF100 0x80DC      BMI.W    ??ParamEst__SetSetup_1
   \                     ??ParamEst__SetSetup_8: (+1)
   \   000000AA   0x68A1             LDR      R1,[R4, #+8]
   \   000000AC   0xEE00 0x1A10      VMOV     S0,R1
   \   000000B0   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000000B4   0xEEF1 0xFA10      FMSTAT   
   \   000000B8   0xBF5F             ITTTT    PL 
   \   000000BA   0x68E1             LDRPL    R1,[R4, #+12]
   \   000000BC   0xEE00 0x1A10      VMOVPL   S0,R1
   \   000000C0   0xEEB5 0x0A40      VCMPPL.F32 S0,#0.0
   \   000000C4   0xEEF1 0xFA10      FMSTATPL 
   \   000000C8   0xF100 0x80CB      BMI.W    ??ParamEst__SetSetup_1
   \   000000CC   0x6921             LDR      R1,[R4, #+16]
   \   000000CE   0xEE00 0x1A10      VMOV     S0,R1
   \   000000D2   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000000D6   0xEEF1 0xFA10      FMSTAT   
   \   000000DA   0xBF5F             ITTTT    PL 
   \   000000DC   0x6961             LDRPL    R1,[R4, #+20]
   \   000000DE   0xEE00 0x1A10      VMOVPL   S0,R1
   \   000000E2   0xEEB5 0x0A40      VCMPPL.F32 S0,#0.0
   \   000000E6   0xEEF1 0xFA10      FMSTATPL 
   \   000000EA   0xF100 0x80BA      BMI.W    ??ParamEst__SetSetup_1
   \   000000EE   0x69A1             LDR      R1,[R4, #+24]
   \   000000F0   0xEE00 0x1A10      VMOV     S0,R1
   \   000000F4   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000000F8   0xEEF1 0xFA10      FMSTAT   
   \   000000FC   0xD517             BPL.N    ??ParamEst__SetSetup_9
   \   000000FE   0xB003             ADD      SP,SP,#+12
   \   00000100   0xBDF0             POP      {R4-R7,PC}
   \                     ??ParamEst__SetSetup_6: (+1)
   \   00000102   0x6861             LDR      R1,[R4, #+4]
   \   00000104   0xEE00 0x1A10      VMOV     S0,R1
   \   00000108   0xEDDF 0x....      VLDR.W   S1,??DataTable14  ;; 0x3f800001
   \   0000010C   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000110   0xEEF1 0xFA10      FMSTAT   
   \   00000114   0xF280 0x80A5      BGE.W    ??ParamEst__SetSetup_1
   \   00000118   0x6861             LDR      R1,[R4, #+4]
   \   0000011A   0xEE00 0x1A10      VMOV     S0,R1
   \   0000011E   0xEDDF 0x....      VLDR.W   S1,??DataTable14_1  ;; 0x3dcccccd
   \   00000122   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000126   0xEEF1 0xFA10      FMSTAT   
   \   0000012A   0xF100 0x809A      BMI.W    ??ParamEst__SetSetup_1
   \                     ??ParamEst__SetSetup_9: (+1)
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xF000 0x8097      BEQ.W    ??ParamEst__SetSetup_1
   \   00000134   0x.... 0x....      LDR.W    R7,??DataTable17
   \   00000138   0xF897 0x0030      LDRB     R0,[R7, #+48]
   \   0000013C   0x2801             CMP      R0,#+1
   \   0000013E   0xD03B             BEQ.N    ??ParamEst__SetSetup_10
   \   00000140   0xF8D7 0x01D0      LDR      R0,[R7, #+464]
   \   00000144   0x7F21             LDRB     R1,[R4, #+28]
   \   00000146   0x7F02             LDRB     R2,[R0, #+28]
   \   00000148   0x0909             LSRS     R1,R1,#+4
   \   0000014A   0xEBB1 0x1F12      CMP      R1,R2, LSR #+4
   \   0000014E   0xF040 0x8088      BNE.W    ??ParamEst__SetSetup_1
   \   00000152   0x7F61             LDRB     R1,[R4, #+29]
   \   00000154   0x29FF             CMP      R1,#+255
   \   00000156   0xD02F             BEQ.N    ??ParamEst__SetSetup_10
   \   00000158   0x7F40             LDRB     R0,[R0, #+29]
   \   0000015A   0x28FF             CMP      R0,#+255
   \   0000015C   0xD001             BEQ.N    ??ParamEst__SetSetup_11
   \   0000015E   0x4288             CMP      R0,R1
   \   00000160   0xD02A             BEQ.N    ??ParamEst__SetSetup_10
   \                     ??ParamEst__SetSetup_11: (+1)
   \   00000162   0x2103             MOVS     R1,#+3
   \   00000164   0xF507 0x70EA      ADD      R0,R7,#+468
   \   00000168   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   0000016C   0x2103             MOVS     R1,#+3
   \   0000016E   0xF507 0x70F6      ADD      R0,R7,#+492
   \   00000172   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   00000176   0x2103             MOVS     R1,#+3
   \   00000178   0xF507 0x7001      ADD      R0,R7,#+516
   \   0000017C   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   00000180   0x2103             MOVS     R1,#+3
   \   00000182   0xF507 0x7007      ADD      R0,R7,#+540
   \   00000186   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   0000018A   0x2103             MOVS     R1,#+3
   \   0000018C   0xF507 0x700D      ADD      R0,R7,#+564
   \   00000190   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   00000194   0x2103             MOVS     R1,#+3
   \   00000196   0xF507 0x7013      ADD      R0,R7,#+588
   \   0000019A   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   0000019E   0x2103             MOVS     R1,#+3
   \   000001A0   0xF507 0x7019      ADD      R0,R7,#+612
   \   000001A4   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   000001A8   0x2103             MOVS     R1,#+3
   \   000001AA   0xF507 0x701F      ADD      R0,R7,#+636
   \   000001AE   0x.... 0x....      BL       DigitalFilter__ResetSOS
   \   000001B2   0x2000             MOVS     R0,#+0
   \   000001B4   0xF887 0x002D      STRB     R0,[R7, #+45]
   \                     ??ParamEst__SetSetup_10: (+1)
   \   000001B8   0x7F20             LDRB     R0,[R4, #+28]
   \   000001BA   0x0900             LSRS     R0,R0,#+4
   \   000001BC   0x2803             CMP      R0,#+3
   \   000001BE   0xD839             BHI.N    ??ParamEst__SetSetup_12
   \   000001C0   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??ParamEst__SetSetup_0:
   \   000001C4   0x29 0x18          DC8      0x29,0x18,0x18,0x2
   \              0x18 0x02    
   \                     ??ParamEst__SetSetup_13: (+1)
   \   000001C8   0x2006             MOVS     R0,#+6
   \   000001CA   0xF887 0x0031      STRB     R0,[R7, #+49]
   \   000001CE   0x2000             MOVS     R0,#+0
   \   000001D0   0xF887 0x0025      STRB     R0,[R7, #+37]
   \   000001D4   0x2001             MOVS     R0,#+1
   \   000001D6   0xF887 0x0026      STRB     R0,[R7, #+38]
   \   000001DA   0x2002             MOVS     R0,#+2
   \   000001DC   0xF887 0x0027      STRB     R0,[R7, #+39]
   \   000001E0   0x2003             MOVS     R0,#+3
   \   000001E2   0xF887 0x0028      STRB     R0,[R7, #+40]
   \   000001E6   0x2004             MOVS     R0,#+4
   \   000001E8   0xF887 0x0029      STRB     R0,[R7, #+41]
   \   000001EC   0x2005             MOVS     R0,#+5
   \   000001EE   0xF887 0x002A      STRB     R0,[R7, #+42]
   \   000001F2   0xE01F             B.N      ??ParamEst__SetSetup_12
   \                     ??ParamEst__SetSetup_14: (+1)
   \   000001F4   0x2005             MOVS     R0,#+5
   \   000001F6   0xF887 0x0031      STRB     R0,[R7, #+49]
   \   000001FA   0x2000             MOVS     R0,#+0
   \   000001FC   0xF887 0x0024      STRB     R0,[R7, #+36]
   \   00000200   0x2001             MOVS     R0,#+1
   \   00000202   0xF887 0x0025      STRB     R0,[R7, #+37]
   \   00000206   0x2002             MOVS     R0,#+2
   \   00000208   0xF887 0x0026      STRB     R0,[R7, #+38]
   \   0000020C   0x2003             MOVS     R0,#+3
   \   0000020E   0xF887 0x0027      STRB     R0,[R7, #+39]
   \   00000212   0x2004             MOVS     R0,#+4
   \   00000214   0xE00C             B.N      ??ParamEst__SetSetup_15
   \                     ??ParamEst__SetSetup_16: (+1)
   \   00000216   0x2004             MOVS     R0,#+4
   \   00000218   0xF887 0x0031      STRB     R0,[R7, #+49]
   \   0000021C   0x2000             MOVS     R0,#+0
   \   0000021E   0xF887 0x0025      STRB     R0,[R7, #+37]
   \   00000222   0x2001             MOVS     R0,#+1
   \   00000224   0xF887 0x0026      STRB     R0,[R7, #+38]
   \   00000228   0x2002             MOVS     R0,#+2
   \   0000022A   0xF887 0x0027      STRB     R0,[R7, #+39]
   \   0000022E   0x2003             MOVS     R0,#+3
   \                     ??ParamEst__SetSetup_15: (+1)
   \   00000230   0xF887 0x0028      STRB     R0,[R7, #+40]
   \                     ??ParamEst__SetSetup_12: (+1)
   \   00000234   0x7F20             LDRB     R0,[R4, #+28]
   \   00000236   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000023A   0x2801             CMP      R0,#+1
   \   0000023C   0xBF08             IT       EQ 
   \   0000023E   0xEEB7 0x0A00      VMOVEQ.F32 S0,#1.0
   \   00000242   0xD008             BEQ.N    ??ParamEst__SetSetup_17
   \   00000244   0x6860             LDR      R0,[R4, #+4]
   \   00000246   0xEE00 0x0A10      VMOV     S0,R0
   \   0000024A   0x.... 0x....      BL       sqrtf
   \   0000024E   0xEEF7 0x0A00      VMOV.F32 S1,#1.0
   \   00000252   0xEE80 0x0A80      VDIV.F32 S0,S1,S0
   \                     ??ParamEst__SetSetup_17: (+1)
   \   00000256   0xED87 0x0A6F      VSTR     S0,[R7, #+444]
   \   0000025A   0xF8C7 0x41D0      STR      R4,[R7, #+464]
   \   0000025E   0x603D             STR      R5,[R7, #+0]
   \   00000260   0x713E             STRB     R6,[R7, #+4]
   \                     ??ParamEst__SetSetup_1: (+1)
   \   00000262   0xB003             ADD      SP,SP,#+12
   \   00000264   0xBDF0             POP      {R4-R7,PC}       ;; return
    457          
    458          //---------------------------------------------------------------------------------------------------------------------
    459          /**
    460           * @brief Return the state of the ParamID module
    461           *
    462           * @return The state of the ParamID module
    463           */

   \                                 In section .text, align 2, keep-with-next
    464          BOOL_TYPE ParamEst__IsRunning(void)
    465          {
    466              return ( IsModuleActive() );
   \                     ParamEst__IsRunning: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000004   0xF890 0x0030      LDRB     R0,[R0, #+48]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??ParamEst__IsRunning_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR
   \                     ??ParamEst__IsRunning_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR               ;; return
    467          }
    468          
    469          //---------------------------------------------------------------------------------------------------------------------
    470          /**
    471           * @brief Query parameter value from ParamID module
    472           *
    473           * @details Calculates the relevant continuous-time parameters from the digital parameters. This
    474           * function is where the model of the physical system is used to "make sense" of the identified parameters.
    475           *
    476           * @param parameter = name of the parameter to query
    477           *
    478           * @return The value of the requested parameter
    479           */
    480          //#pragma optimize=size no_inline no_unroll

   \                                 In section .text, align 4, keep-with-next
    481          float ParamEst__GetParameterValue(PARAM_EST_PARAMETER_TYPE parameter)
    482          {
   \                     ParamEst__GetParameterValue: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xED9F 0x8AD8      VLDR.W   S16,??ParamEst__GetParameterValue_5  ;; 0x0
   \   0000000A   0x.... 0x....      LDR.W    R4,??DataTable17
   \   0000000E   0xE000             B.N      ??ParamEst__GetParameterValue_6
    483              float result = 0.0f;
    484          #if MODEL_BK_EULER_B0_BB == ENABLED
    485              float angle_ub = 0.0f;
    486              float angle_bb = 0.0f;
    487          #endif
    488          
    489              if ( Setup_Parameters == NULL )
    490              {
    491                  DEBUG_CANNOT_GET_PARAMETER_VALUE_SETUP_IS_NULL();
    492              }
    493              else if ( parameter == PARAM_EST_RESIDUAL )
    494              {
    495                  result = Residual;
    496              }
    497              else
    498              {
    499                  switch ( Setup_Parameters->Model_Config.Struct.Model )
    500                  {
    501          #if MODEL_BK_EULER_B0 == ENABLED
    502                      // w_dot(t) = [T(t), -1, -sin(alpha), -cos(alpha)] * [1/J; c/J; mgr*cos(beta)/J; mgr*sin(beta)/J]
    503                      case PARAM_EST_MODEL_BK_EULER_B0:
    504                          if ( Theta[Phi_Idx[REG_ELE_TORQUE]] != 0.0f )
    505                          {
    506                              switch ( parameter )
    507                              {
    508                                  case PARAM_EST_INERTIA:
    509                                      result = 1.0f / Theta[Phi_Idx[REG_ELE_TORQUE]];
    510                                      break;
    511                                  case PARAM_EST_COULOMB:                                       // -fallthrough
    512                                  case PARAM_EST_FRICTION:
    513                                      result = Theta[Phi_Idx[REG_ELE_CONSTANT]] / Theta[Phi_Idx[REG_ELE_TORQUE]];
    514                                      break;
    515                                  case PARAM_EST_UBMAG:
    516                                      // This is the norm
    517                                      result = sqrtf(Theta[Phi_Idx[REG_ELE_SIN_ANGLE]] * Theta[Phi_Idx[REG_ELE_SIN_ANGLE]] +
    518                                              Theta[Phi_Idx[REG_ELE_COS_ANGLE]] * Theta[Phi_Idx[REG_ELE_COS_ANGLE]]) /
    519                                              Theta[Phi_Idx[REG_ELE_TORQUE]];
    520                                      break;
    521                                  case PARAM_EST_UBPHASE:
    522                                      result = PARAM_EST_ANGLE_WRAP(atan2f(Theta[Phi_Idx[REG_ELE_COS_ANGLE]], Theta[Phi_Idx[REG_ELE_SIN_ANGLE]]));
    523                                      break;
    524                                  default:        // Invalid parameter selection by user
    525                                      DEBUG_INVALID_PARAMETER_SELECTION(parameter);
    526                                      break;
    527                              }
    528                          }
    529                          break;
    530          #endif
    531          #if MODEL_BK_EULER == ENABLED
    532                      // w(t) = [w(t-1), T(t), -1, -sin(alpha), -cos(alpha)] * [A*J/Ts; A; A*c; A*mgr*cos(beta); A*mgr*sin(beta)]
    533                      // where A = Ts/(J+b*Ts)
    534                      case PARAM_EST_MODEL_BK_EULER:
    535                          if ( Theta[Phi_Idx[REG_ELE_TORQUE]] != 0.0f )
    536                          {
    537                              switch ( parameter )
    538                              {
    539                                  case PARAM_EST_INERTIA:
    540                                      result = Theta[Phi_Idx[REG_ELE_SPEED]] / Theta[Phi_Idx[REG_ELE_TORQUE]] * TS_PARAMID;
    541                                      break;
    542                                  case PARAM_EST_VISCOUS:
    543                                      result = (1.0f - Theta[Phi_Idx[REG_ELE_SPEED]]) / Theta[Phi_Idx[REG_ELE_TORQUE]];
    544                                      break;
    545                                  case PARAM_EST_COULOMB:
    546                                      result = Theta[Phi_Idx[REG_ELE_CONSTANT]] / Theta[Phi_Idx[REG_ELE_TORQUE]];
    547                                      break;
    548                                  case PARAM_EST_FRICTION:        // b * w + c
    549                                      result = ParamEst__GetParameterValue(PARAM_EST_VISCOUS) * Speed_Previous + ParamEst__GetParameterValue(PARAM_EST_COULOMB);
    550                                      break;
    551                                  case PARAM_EST_UBMAG:
    552                                      result = sqrtf(Theta[Phi_Idx[REG_ELE_SIN_ANGLE]] * Theta[Phi_Idx[REG_ELE_SIN_ANGLE]] +
    553                                              Theta[Phi_Idx[REG_ELE_COS_ANGLE]] * Theta[Phi_Idx[REG_ELE_COS_ANGLE]]) /
    554                                              Theta[Phi_Idx[REG_ELE_TORQUE]];
    555                                      break;
    556                                  case PARAM_EST_UBPHASE:
    557                                      result = PARAM_EST_ANGLE_WRAP(atan2f(Theta[Phi_Idx[REG_ELE_COS_ANGLE]], Theta[Phi_Idx[REG_ELE_SIN_ANGLE]]));
    558                                      break;
    559                                  default:        // Invalid parameter selection by user
    560                                      DEBUG_INVALID_PARAMETER_SELECTION(parameter);
    561                                      break;
    562                              }
    563                          }
    564                          break;
    565          #endif
    566          #if MODEL_HYB_ACCEL
    567                      // w_dot(t) = [-w(t), T(t), -1, -sin(alpha(t)), -cos(alpha(t))] * [b/J; 1/J; c/J; mgr*cos(beta)/J; mgr*sin(beta)/J]
    568                      case PARAM_EST_MODEL_HYB_ACCEL:
    569                          if ( Theta[Phi_Idx[REG_ELE_TORQUE]] != 0.0f )
    570                          {
    571                              switch ( parameter )
    572                              {
    573                                  case PARAM_EST_INERTIA:
    574                                      result = 1.0f / Theta[Phi_Idx[REG_ELE_TORQUE]];
    575                                      break;
    576                                  case PARAM_EST_VISCOUS:
    577                                      result = Theta[Phi_Idx[REG_ELE_SPEED]] / Theta[Phi_Idx[REG_ELE_TORQUE]];
    578                                      break;
    579                                  case PARAM_EST_COULOMB:
    580                                      result = Theta[Phi_Idx[REG_ELE_CONSTANT]] / Theta[Phi_Idx[REG_ELE_TORQUE]];
    581                                      break;
    582                                  case PARAM_EST_FRICTION:        // b * w + c
    583                                      result = ParamEst__GetParameterValue(PARAM_EST_VISCOUS) * Speed_Previous + ParamEst__GetParameterValue(PARAM_EST_COULOMB);
    584                                      break;
    585                                  case PARAM_EST_UBMAG:
    586                                      result = sqrtf(Theta[Phi_Idx[REG_ELE_SIN_ANGLE]] * Theta[Phi_Idx[REG_ELE_SIN_ANGLE]] +
    587                                              Theta[Phi_Idx[REG_ELE_COS_ANGLE]] * Theta[Phi_Idx[REG_ELE_COS_ANGLE]]) /
    588                                              Theta[Phi_Idx[REG_ELE_TORQUE]];
    589                                      break;
    590                                  case PARAM_EST_UBPHASE:
    591                                      result = PARAM_EST_ANGLE_WRAP(atan2f(Theta[Phi_Idx[REG_ELE_COS_ANGLE]], Theta[Phi_Idx[REG_ELE_SIN_ANGLE]]));
    592                                      break;
    593                                  default:        // Invalid parameter selection by user
    594                                      DEBUG_INVALID_PARAMETER_SELECTION(parameter);
    595                                      break;
    596                              }
    597                          }
    598                          break;
    599          #endif
    600          #if MODEL_BK_EULER_B0_BB == ENABLED
    601                      case PARAM_EST_MODEL_BK_EULER_B0_BB:
    602          
    603                          if(Theta[Phi_Idx[REG_ELE_TORQUE]] != 0.0f)
    604                          {
    605                              switch( parameter )
    606                              {
    607                                  case PARAM_EST_INERTIA:
    608                                      result = 1.0f / Theta[Phi_Idx[REG_ELE_TORQUE]];
    609                                      break;
    610                                  case PARAM_EST_COULOMB:                                       // -fallthrough
    611                                  case PARAM_EST_FRICTION:
    612                                      result = Theta[Phi_Idx[REG_ELE_CONSTANT]] / Theta[Phi_Idx[REG_ELE_TORQUE]];
    613                                      break;
    614                                  case PARAM_EST_UBMAG:
    615                                      // This is the norm
    616                                      result = sqrtf(Theta[Phi_Idx[REG_ELE_SIN_ANGLE]] * Theta[Phi_Idx[REG_ELE_SIN_ANGLE]] +
    617                                      Theta[Phi_Idx[REG_ELE_COS_ANGLE]] * Theta[Phi_Idx[REG_ELE_COS_ANGLE]]) /
    618                                      Theta[Phi_Idx[REG_ELE_TORQUE]];
    619                                      break;
    620                                  case PARAM_EST_UBPHASE:
    621                                      result = PARAM_EST_ANGLE_WRAP(atan2f(Theta[Phi_Idx[REG_ELE_COS_ANGLE]], Theta[Phi_Idx[REG_ELE_SIN_ANGLE]]));
    622                                      break;
    623                                  case PARAM_EST_BBMAG:
    624                                      result = sqrtf(Theta[Phi_Idx[REG_ELE_SIN_BB_ANGLE]] * Theta[Phi_Idx[REG_ELE_SIN_BB_ANGLE]] +
    625                                      Theta[Phi_Idx[REG_ELE_COS_BB_ANGLE]] * Theta[Phi_Idx[REG_ELE_COS_BB_ANGLE]]) /
    626                                      Theta[Phi_Idx[REG_ELE_TORQUE]];
    627                                      break;
    628                                  case PARAM_EST_BBPHASE:
    629                                      result = PARAM_EST_ANGLE_WRAP(atan2f(Theta[Phi_Idx[REG_ELE_COS_BB_ANGLE]], Theta[Phi_Idx[REG_ELE_SIN_BB_ANGLE]]));
    630                                      break;
    631                                  case PARAM_EST_BBPHASEDIFF:
    632                                      angle_ub = WrapAngleRad(ParamEst__GetParameterValue(PARAM_EST_UBPHASE) + Alpha_UB, 2*INPUT_PI); // instantaneous load unbalance position
    633                                      angle_bb = WrapAngleRad(ParamEst__GetParameterValue(PARAM_EST_BBPHASE) + Alpha_BB, 2*INPUT_PI); // instantaneous ball balancer position
    634          
    635                                      result = PARAM_EST_ANGLE_WRAP(angle_ub - angle_bb);
    636                                      break;
    637                                  case PARAM_EST_BBPHASELAG:
    638                                      // Since whether the balls are lagging or leading the unbalance is relative to the direction of rotation, it is
    639                                      // necessary to invert the sign of the phase difference when the drum is rotating in the negative direction. In other words,
    640                                      // whether the balls are "behind" or "in front of" the unbalance depends on the direction the unbalance is rotating.
    641                                      if(SIGN(INPUT_DRUM_SPEED_RAD_S()) == -1)
    642                                      {
    643                                          result = PARAM_EST_ANGLE_WRAP(-ParamEst__GetParameterValue(PARAM_EST_BBPHASEDIFF));
    644                                      }
    645                                      else
    646                                      {
    647                                          result = ParamEst__GetParameterValue(PARAM_EST_BBPHASEDIFF);
   \                     ??ParamEst__GetParameterValue_7: (+1)
   \   00000010   0x2009             MOVS     R0,#+9
    648                                      }
   \                     ??ParamEst__GetParameterValue_6: (+1)
   \   00000012   0xF8D4 0x11D0      LDR      R1,[R4, #+464]
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xF000 0x81DC      BEQ.W    ??ParamEst__GetParameterValue_8
   \   0000001C   0x2806             CMP      R0,#+6
   \   0000001E   0xD106             BNE.N    ??ParamEst__GetParameterValue_9
   \   00000020   0xED94 0x8A71      VLDR     S16,[R4, #+452]
    649          
    650                                      break;
    651                                  default:        // Invalid parameter selection by user
    652                                      DEBUG_INVALID_PARAMETER_SELECTION(parameter);
    653                                      break;
    654                              }
    655                          }
    656                          break;
    657          #endif
    658                      default:                    // Code should never get here, Invalid model selection
    659                          // an invalid Model is posted by macro DEBUG_INVALID_MODEL in ParamEst__Enable()
    660                          break;
    661                  }
    662              }
    663              return ( result );
   \   00000024   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000028   0xECBD 0x8B02      VPOP     {D8}
   \   0000002C   0xBD10             POP      {R4,PC}
   \                     ??ParamEst__GetParameterValue_9: (+1)
   \   0000002E   0x7F09             LDRB     R1,[R1, #+28]
   \   00000030   0x0909             LSRS     R1,R1,#+4
   \   00000032   0x2903             CMP      R1,#+3
   \   00000034   0xF200 0x81CE      BHI.W    ??ParamEst__GetParameterValue_8
   \   00000038   0xE8DF 0xF011      TBH      [PC, R1, LSL #+1]
   \                     ??ParamEst__GetParameterValue_0:
   \   0000003C   0x0004 0x0035      DC16     0x4,0x35,0x88,0xD9
   \              0x0088 0x00D9
   \                     ??ParamEst__GetParameterValue_10: (+1)
   \   00000044   0xF894 0x1025      LDRB     R1,[R4, #+37]
   \   00000048   0xEB04 0x0181      ADD      R1,R4,R1, LSL #+2
   \   0000004C   0xEDD1 0x8A02      VLDR     S17,[R1, #+8]
   \   00000050   0xEEF5 0x8A40      VCMP.F32 S17,#0.0
   \   00000054   0xEEF1 0xFA10      FMSTAT   
   \   00000058   0xF000 0x81BC      BEQ.W    ??ParamEst__GetParameterValue_8
   \   0000005C   0x2805             CMP      R0,#+5
   \   0000005E   0xF200 0x81B9      BHI.W    ??ParamEst__GetParameterValue_8
   \   00000062   0xE8DF 0xF010      TBH      [PC, R0, LSL #+1]
   \                     ??ParamEst__GetParameterValue_1:
   \   00000066   0x00DB 0x01B7      DC16     0xDB,0x1B7,0xDE,0xDE
   \              0x00DE 0x00DE
   \   0000006E   0x0006 0x000F      DC16     0x6,0xF
   \                     ??ParamEst__GetParameterValue_11: (+1)
   \   00000072   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \   00000076   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   0000007A   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   0000007E   0xF894 0x0027      LDRB     R0,[R4, #+39]
   \   00000082   0xE103             B.N      ??ParamEst__GetParameterValue_12
   \                     ??ParamEst__GetParameterValue_13: (+1)
   \   00000084   0xF894 0x0027      LDRB     R0,[R4, #+39]
   \   00000088   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   0000008C   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   00000090   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \   00000094   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000098   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   0000009C   0x.... 0x....      BL       atan2f
   \   000000A0   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   000000A4   0xE17B             B.N      ??ParamEst__GetParameterValue_14
   \                     ??ParamEst__GetParameterValue_15: (+1)
   \   000000A6   0xF894 0x1025      LDRB     R1,[R4, #+37]
   \   000000AA   0xEB04 0x0181      ADD      R1,R4,R1, LSL #+2
   \   000000AE   0xEDD1 0x8A02      VLDR     S17,[R1, #+8]
   \   000000B2   0xEEF5 0x8A40      VCMP.F32 S17,#0.0
   \   000000B6   0xEEF1 0xFA10      FMSTAT   
   \   000000BA   0xF000 0x818B      BEQ.W    ??ParamEst__GetParameterValue_8
   \   000000BE   0x2805             CMP      R0,#+5
   \   000000C0   0xF200 0x8188      BHI.W    ??ParamEst__GetParameterValue_8
   \   000000C4   0xE8DF 0xF010      TBH      [PC, R0, LSL #+1]
   \                     ??ParamEst__GetParameterValue_2:
   \   000000C8   0x0006 0x0017      DC16     0x6,0x17,0xAD,0x66
   \              0x00AD 0x0066
   \   000000D0   0x0028 0x0031      DC16     0x28,0x31
   \                     ??ParamEst__GetParameterValue_16: (+1)
   \   000000D4   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   000000D8   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   000000DC   0xEDDF 0x....      VLDR.W   S1,??DataTable16  ;; 0x3c23d70a
   \   000000E0   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   000000E4   0xEE80 0x0A28      VDIV.F32 S0,S0,S17
   \   000000E8   0xEE20 0x8A20      VMUL.F32 S16,S0,S1
   \   000000EC   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000000F0   0xECBD 0x8B02      VPOP     {D8}
   \   000000F4   0xBD10             POP      {R4,PC}
   \                     ??ParamEst__GetParameterValue_17: (+1)
   \   000000F6   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   000000FA   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   000000FE   0xEEB7 0x0A00      VMOV.F32 S0,#1.0
   \   00000102   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   00000106   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   0000010A   0xEE80 0x8A28      VDIV.F32 S16,S0,S17
   \   0000010E   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000112   0xECBD 0x8B02      VPOP     {D8}
   \   00000116   0xBD10             POP      {R4,PC}
   \                     ??ParamEst__GetParameterValue_18: (+1)
   \   00000118   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \   0000011C   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000120   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   00000124   0xF894 0x0027      LDRB     R0,[R4, #+39]
   \   00000128   0xE0B0             B.N      ??ParamEst__GetParameterValue_12
   \                     ??ParamEst__GetParameterValue_19: (+1)
   \   0000012A   0xF894 0x0027      LDRB     R0,[R4, #+39]
   \   0000012E   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000132   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   00000136   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \   0000013A   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   0000013E   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   00000142   0x.... 0x....      BL       atan2f
   \   00000146   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000014A   0xE128             B.N      ??ParamEst__GetParameterValue_14
   \                     ??ParamEst__GetParameterValue_20: (+1)
   \   0000014C   0xF894 0x1025      LDRB     R1,[R4, #+37]
   \   00000150   0xEB04 0x0181      ADD      R1,R4,R1, LSL #+2
   \   00000154   0xEDD1 0x8A02      VLDR     S17,[R1, #+8]
   \   00000158   0xEEF5 0x8A40      VCMP.F32 S17,#0.0
   \   0000015C   0xEEF1 0xFA10      FMSTAT   
   \   00000160   0xF000 0x8138      BEQ.W    ??ParamEst__GetParameterValue_8
   \   00000164   0x2805             CMP      R0,#+5
   \   00000166   0xF200 0x8135      BHI.W    ??ParamEst__GetParameterValue_8
   \   0000016A   0xE8DF 0xF010      TBH      [PC, R0, LSL #+1]
   \                     ??ParamEst__GetParameterValue_3:
   \   0000016E   0x0057 0x0006      DC16     0x57,0x6,0x5A,0x13
   \              0x005A 0x0013
   \   00000176   0x0026 0x002F      DC16     0x26,0x2F
   \                     ??ParamEst__GetParameterValue_21: (+1)
   \   0000017A   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   0000017E   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000182   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   00000186   0xEE80 0x8A28      VDIV.F32 S16,S0,S17
   \   0000018A   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   0000018E   0xECBD 0x8B02      VPOP     {D8}
   \   00000192   0xBD10             POP      {R4,PC}
   \                     ??ParamEst__GetParameterValue_22: (+1)
   \   00000194   0x2001             MOVS     R0,#+1
   \   00000196   0xF7FF 0xFF33      BL       ParamEst__GetParameterValue
   \   0000019A   0xEEF0 0x8A40      VMOV.F32 S17,S0
   \   0000019E   0x2002             MOVS     R0,#+2
   \   000001A0   0xF7FF 0xFF2E      BL       ParamEst__GetParameterValue
   \   000001A4   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   000001A8   0xED94 0x0A70      VLDR     S0,[R4, #+448]
   \   000001AC   0xEE08 0x8A80      VMLA.F32 S16,S17,S0
   \   000001B0   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000001B4   0xECBD 0x8B02      VPOP     {D8}
   \   000001B8   0xBD10             POP      {R4,PC}
   \                     ??ParamEst__GetParameterValue_23: (+1)
   \   000001BA   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \   000001BE   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   000001C2   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   000001C6   0xF894 0x0027      LDRB     R0,[R4, #+39]
   \   000001CA   0xE05F             B.N      ??ParamEst__GetParameterValue_12
   \                     ??ParamEst__GetParameterValue_24: (+1)
   \   000001CC   0xF894 0x0027      LDRB     R0,[R4, #+39]
   \   000001D0   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   000001D4   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   000001D8   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \   000001DC   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   000001E0   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   000001E4   0x.... 0x....      BL       atan2f
   \   000001E8   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   000001EC   0xE0D7             B.N      ??ParamEst__GetParameterValue_14
   \                     ??ParamEst__GetParameterValue_25: (+1)
   \   000001EE   0xF894 0x1025      LDRB     R1,[R4, #+37]
   \   000001F2   0xEB04 0x0181      ADD      R1,R4,R1, LSL #+2
   \   000001F6   0xEDD1 0x8A02      VLDR     S17,[R1, #+8]
   \   000001FA   0xEEF5 0x8A40      VCMP.F32 S17,#0.0
   \   000001FE   0xEEF1 0xFA10      FMSTAT   
   \   00000202   0xF000 0x80E7      BEQ.W    ??ParamEst__GetParameterValue_8
   \   00000206   0x280A             CMP      R0,#+10
   \   00000208   0xF200 0x80E4      BHI.W    ??ParamEst__GetParameterValue_8
   \   0000020C   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??ParamEst__GetParameterValue_4:
   \   00000210   0x06 0xE2          DC8      0x6,0xE2,0x9,0x9
   \              0x09 0x09    
   \   00000214   0x1C 0x25          DC8      0x1C,0x25,0xE2,0x36
   \              0xE2 0x36    
   \   00000218   0x4F 0x60          DC8      0x4F,0x60,0xAE,0x0
   \              0xAE 0x00    
   \                     ??ParamEst__GetParameterValue_26: (+1)
   \   0000021C   0xEEB7 0x0A00      VMOV.F32 S0,#1.0
   \   00000220   0xE005             B.N      ??ParamEst__GetParameterValue_27
   \                     ??ParamEst__GetParameterValue_28: (+1)
   \   00000222   0xF894 0x0026      LDRB     R0,[R4, #+38]
   \   00000226   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   0000022A   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \                     ??ParamEst__GetParameterValue_27: (+1)
   \   0000022E   0xF894 0x0025      LDRB     R0,[R4, #+37]
   \   00000232   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000236   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   0000023A   0xEE80 0x8A20      VDIV.F32 S16,S0,S1
   \   0000023E   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000242   0xECBD 0x8B02      VPOP     {D8}
   \   00000246   0xBD10             POP      {R4,PC}
   \                     ??ParamEst__GetParameterValue_29: (+1)
   \   00000248   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \   0000024C   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000250   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   00000254   0xF894 0x0027      LDRB     R0,[R4, #+39]
   \   00000258   0xE018             B.N      ??ParamEst__GetParameterValue_12
   \                     ??ParamEst__GetParameterValue_30: (+1)
   \   0000025A   0xF894 0x0027      LDRB     R0,[R4, #+39]
   \   0000025E   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000262   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   00000266   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \   0000026A   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   0000026E   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   00000272   0x.... 0x....      BL       atan2f
   \   00000276   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000027A   0xE090             B.N      ??ParamEst__GetParameterValue_14
   \                     ??ParamEst__GetParameterValue_31: (+1)
   \   0000027C   0xF894 0x002A      LDRB     R0,[R4, #+42]
   \   00000280   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000284   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   00000288   0xF894 0x0029      LDRB     R0,[R4, #+41]
   \                     ??ParamEst__GetParameterValue_12: (+1)
   \   0000028C   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000290   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   00000294   0xEE20 0x0A00      VMUL.F32 S0,S0,S0
   \   00000298   0xEE00 0x0AA0      VMLA.F32 S0,S1,S1
   \   0000029C   0x.... 0x....      BL       sqrtf
   \   000002A0   0xEE80 0x8A28      VDIV.F32 S16,S0,S17
   \   000002A4   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000002A8   0xECBD 0x8B02      VPOP     {D8}
   \   000002AC   0xBD10             POP      {R4,PC}
   \                     ??ParamEst__GetParameterValue_32: (+1)
   \   000002AE   0xF894 0x0029      LDRB     R0,[R4, #+41]
   \   000002B2   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   000002B6   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   000002BA   0xF894 0x002A      LDRB     R0,[R4, #+42]
   \   000002BE   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   000002C2   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   000002C6   0x.... 0x....      BL       atan2f
   \   000002CA   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   000002CE   0xE066             B.N      ??ParamEst__GetParameterValue_14
   \                     ??ParamEst__GetParameterValue_33: (+1)
   \   000002D0   0x2005             MOVS     R0,#+5
   \   000002D2   0xF7FF 0xFE95      BL       ParamEst__GetParameterValue
   \   000002D6   0xEDD4 0x0A72      VLDR     S1,[R4, #+456]
   \   000002DA   0xEE30 0x8A20      VADD.F32 S16,S0,S1
   \   000002DE   0xEDDF 0x....      VLDR.W   S17,??DataTable16_1  ;; 0x40c90fdb
   \   000002E2   0xEEB4 0x8A68      VCMP.F32 S16,S17
   \   000002E6   0xEEF1 0xFA10      FMSTAT   
   \   000002EA   0xDB04             BLT.N    ??ParamEst__GetParameterValue_34
   \   000002EC   0xED9F 0x....      VLDR.W   S0,??DataTable16_2  ;; 0xc0c90fdb
   \   000002F0   0xEE38 0x8A00      VADD.F32 S16,S16,S0
   \   000002F4   0xE006             B.N      ??ParamEst__GetParameterValue_35
   \                     ??ParamEst__GetParameterValue_34: (+1)
   \   000002F6   0xEEB5 0x8A40      VCMP.F32 S16,#0.0
   \   000002FA   0xEEF1 0xFA10      FMSTAT   
   \   000002FE   0xBF48             IT       MI 
   \   00000300   0xEE38 0x8A28      VADDMI.F32 S16,S16,S17
   \                     ??ParamEst__GetParameterValue_35: (+1)
   \   00000304   0x2008             MOVS     R0,#+8
   \   00000306   0xF7FF 0xFE7B      BL       ParamEst__GetParameterValue
   \   0000030A   0xEDD4 0x0A73      VLDR     S1,[R4, #+460]
   \   0000030E   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   00000312   0xEEB4 0x0A68      VCMP.F32 S0,S17
   \   00000316   0xEEF1 0xFA10      FMSTAT   
   \   0000031A   0xDB04             BLT.N    ??ParamEst__GetParameterValue_36
   \   0000031C   0xEDDF 0x....      VLDR.W   S1,??DataTable16_2  ;; 0xc0c90fdb
   \   00000320   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   00000324   0xE006             B.N      ??ParamEst__GetParameterValue_37
   \                     ??ParamEst__GetParameterValue_36: (+1)
   \   00000326   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000032A   0xEEF1 0xFA10      FMSTAT   
   \   0000032E   0xBF48             IT       MI 
   \   00000330   0xEE30 0x0A28      VADDMI.F32 S0,S0,S17
   \                     ??ParamEst__GetParameterValue_37: (+1)
   \   00000334   0xEE38 0x8A40      VSUB.F32 S16,S16,S0
   \   00000338   0xED9F 0x....      VLDR.W   S0,??DataTable16_3  ;; 0x40490fdb
   \   0000033C   0xEEB4 0x8A40      VCMP.F32 S16,S0
   \   00000340   0xEEF1 0xFA10      FMSTAT   
   \   00000344   0xBFA8             IT       GE 
   \   00000346   0xED9F 0x....      VLDRGE.W S0,??DataTable16_2  ;; 0xc0c90fdb
   \   0000034A   0xDA41             BGE.N    ??ParamEst__GetParameterValue_38
   \   0000034C   0xED9F 0x....      VLDR.W   S0,??DataTable16_4  ;; 0xc0490fdb
   \   00000350   0xEEB4 0x8A40      VCMP.F32 S16,S0
   \   00000354   0xEEF1 0xFA10      FMSTAT   
   \   00000358   0xD53C             BPL.N    ??ParamEst__GetParameterValue_8
   \   0000035A   0xEE38 0x8A28      VADD.F32 S16,S16,S17
   \   0000035E   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000362   0xECBD 0x8B02      VPOP     {D8}
   \   00000366   0xBD10             POP      {R4,PC}
   \                     ??ParamEst__GetParameterValue_5:
   \   00000368   0x00000000         DC32     0x0
   \                     ??ParamEst__GetParameterValue_39: (+1)
   \   0000036C   0x2101             MOVS     R1,#+1
   \   0000036E   0x2000             MOVS     R0,#+0
   \   00000370   0x.... 0x....      BL       BandLimiter__GetSignal
   \   00000374   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000378   0xEEF1 0xFA10      FMSTAT   
   \   0000037C   0xF73F 0xAE48      BGT.W    ??ParamEst__GetParameterValue_7
   \   00000380   0x2101             MOVS     R1,#+1
   \   00000382   0x2000             MOVS     R0,#+0
   \   00000384   0x.... 0x....      BL       BandLimiter__GetSignal
   \   00000388   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000038C   0xEEF1 0xFA10      FMSTAT   
   \   00000390   0xF57F 0xAE3E      BPL.W    ??ParamEst__GetParameterValue_7
   \   00000394   0x2009             MOVS     R0,#+9
   \   00000396   0xF7FF 0xFE33      BL       ParamEst__GetParameterValue
   \   0000039A   0xEEB1 0x8A40      VNEG.F32 S16,S0
   \                     ??ParamEst__GetParameterValue_14: (+1)
   \   0000039E   0xED9F 0x....      VLDR.W   S0,??DataTable16_3  ;; 0x40490fdb
   \   000003A2   0xEEB4 0x8A40      VCMP.F32 S16,S0
   \   000003A6   0xEEF1 0xFA10      FMSTAT   
   \   000003AA   0xDB08             BLT.N    ??ParamEst__GetParameterValue_40
   \   000003AC   0xED9F 0x....      VLDR.W   S0,??DataTable16_2  ;; 0xc0c90fdb
   \   000003B0   0xEE38 0x8A00      VADD.F32 S16,S16,S0
   \   000003B4   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000003B8   0xECBD 0x8B02      VPOP     {D8}
   \   000003BC   0xBD10             POP      {R4,PC}
   \                     ??ParamEst__GetParameterValue_40: (+1)
   \   000003BE   0xED9F 0x....      VLDR.W   S0,??DataTable16_4  ;; 0xc0490fdb
   \   000003C2   0xEEB4 0x8A40      VCMP.F32 S16,S0
   \   000003C6   0xEEF1 0xFA10      FMSTAT   
   \   000003CA   0xD503             BPL.N    ??ParamEst__GetParameterValue_8
   \   000003CC   0xED9F 0x....      VLDR.W   S0,??DataTable16_1  ;; 0x40c90fdb
   \                     ??ParamEst__GetParameterValue_38: (+1)
   \   000003D0   0xEE38 0x8A00      VADD.F32 S16,S16,S0
   \                     ??ParamEst__GetParameterValue_8: (+1)
   \   000003D4   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000003D8   0xECBD 0x8B02      VPOP     {D8}
   \   000003DC   0xBD10             POP      {R4,PC}          ;; return
    664          }
    665          
    666          //---------------------------------------------------------------------------------------------------------------------
    667          /**
    668           *	@brief	Get the setting file error flag
    669           */

   \                                 In section .text, align 2, keep-with-next
    670          BOOL_TYPE ParamEst__GetSettingFileError()
    671          {
    672          	return Sf_Parameters_Fault;
   \                     ParamEst__GetSettingFileError: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000004   0xF890 0x0032      LDRB     R0,[R0, #+50]
   \   00000008   0x4770             BX       LR               ;; return
    673          }
    674          
    675          //=====================================================================================================================
    676          //-------------------------------------- Private Functions ------------------------------------------------------------
    677          //=====================================================================================================================
    678          
    679          /**
    680           *  @brief      Compares filter1 and filter2 coefficients, returns TRUE if they are the same
    681           *  @param      filter1      filter to be compared to filter2
    682           *  @param      filter2      filter to be compared to filter1
    683           */
    684          //#pragma optimize=size no_inline no_unroll
    685          static BOOL_TYPE CompareFilters(DIGITAL_FILTER_SOS_TYPE filter1, DIGITAL_FILTER_SOS_TYPE filter2)
                                  ^
Warning[Pe177]: function "CompareFilters" was declared but never referenced
    686          {
    687          	for (int i = 0; i < filter1.Num_Sections; i++)
    688          	{
    689          		for (int j = 0; j < filter2.Num_Sections; j++)
    690          		{
    691          			for (int k = 0; k < BIQUAD_FILTER_ORDER-1; k++)
    692          			{
    693          				if ((filter1.Coeffs[i].Num[k] != filter2.Coeffs[j].Num[k]) ||
    694          						(filter1.Coeffs[i].Den[k] != filter2.Coeffs[j].Den[k]))
    695          				{
    696          					return FALSE;
    697          				}
    698          			}
    699          		}
    700          	}
    701          	return TRUE;
    702          }
    703          
    704          //---------------------------------------------------------------------------------------------------------------------
    705          /**
    706           *  @brief      Performs checks to verify if fiter needs to be reset.
    707           *  @param      new_parameters      pointer to the parameters
    708           */
    709          //#pragma optimize=size no_inline no_unroll
    710          static void HandleFilterReset(const PARAM_EST_SETUP_TYPE *new_parameters)
    711          {
    712              #define RESET_FILTER()  ResetFilter();\
    713                                      ParamID.Delay_Counter = 0
    714          
    715              if ( new_parameters->Filter_Configuration_Index != FILTER_DISABLED )
    716              {
    717                  if (( Setup_Parameters->Filter_Configuration_Index == FILTER_DISABLED ) ||                  				// the filter is switched on
    718                      ( Setup_Parameters->Filter_Configuration_Index != new_parameters->Filter_Configuration_Index))         	// the index of the filter has changed
    719                  {
    720                      RESET_FILTER();
    721                  }
    722              }
    723              // else parameters->Enable == FALSE, do nothing
    724          }
    725          
    726          //---------------------------------------------------------------------------------------------------------------------
    727          /**
    728           *  @brief  Returns if the module is inactive or active
    729           *
    730           *  @return TRUE = module is active; FALSE = module is inactive
    731           */
    732          static BOOL_TYPE IsModuleActive(void)
    733          {
    734              return (( Parameter_Estimation_State == STATE_IDLE) ? FALSE : TRUE );
    735          }
    736          
    737          //---------------------------------------------------------------------------------------------------------------------
    738          /**
    739           *  @brief      Verifies if the values are valid when the Adaptation type is PARAM_EST_ADAPTATION_KALMAN.
    740           *  @param      parameters      pointer to the parameters
    741           *
    742           *  @return     TRUE = values are valid; FALSE = values are not valid
    743           */
    744          //#pragma optimize=size no_inline no_unroll
    745          static BOOL_TYPE IsSetupAdaptationKalmanValid(const PARAM_EST_SETUP_TYPE *parameters)
    746          {
    747              BOOL_TYPE ret_val = TRUE;
    748              unsigned char i;
    749              for ( i = 0; i < PARAM_EST_LENGTH_KALMAN; i++ )
    750              {
    751                  if ( parameters->Kalman_Vector[i] < 0.0f )
    752                  {
    753                      DEBUG_INVALID_KALMAN_VALUE(i, parameters->Kalman_Vector[i]);
    754                      ret_val = FALSE;
    755                      break;
    756                  }
    757              }
    758              return ( ret_val );
    759          }
    760          
    761          //---------------------------------------------------------------------------------------------------------------------
    762          /**
    763           *  @brief      Verifies if the values are valid when the Adaptation type is PARAM_EST_ADAPTATION_FORGETTING.
    764           *  @param      parameters      pointer to the parameters
    765           *
    766           *  @return     TRUE = values are valid; FALSE = values are not valid
    767           */
    768          //#pragma optimize=size no_inline no_unroll
    769          static BOOL_TYPE IsSetupAdaptationForgettingValid(const PARAM_EST_SETUP_TYPE *parameters)
    770          {
    771              BOOL_TYPE ret_val = TRUE;
    772              if (( parameters->Forgetting > 1.0f ) ||
    773                  ( parameters->Forgetting < 0.1f ))
    774              {
    775                  DEBUG_INVALID_FORGETTING_FACTOR(parameters->Forgetting);
    776                  ret_val = FALSE;
    777              }
    778              return ( ret_val );
    779          }
    780          
    781          //---------------------------------------------------------------------------------------------------------------------
    782          /**
    783           *  @brief      Sets up the Model.
    784           *  @param      parameters      pointer to the parameters
    785           */
    786          //#pragma optimize=size no_inline no_unroll
    787          static void SetupModel(const PARAM_EST_SETUP_TYPE *parameters)
    788          {
    789              unsigned char i;
    790          
    791              switch ( parameters->Model_Config.Struct.Model )
    792              {
    793          #if MODEL_BK_EULER_B0 == ENABLED
    794                  case PARAM_EST_MODEL_BK_EULER_B0:
    795                      N_Theta = sizeof(PHI_BK_EULER_B0) / sizeof(PHI_BK_EULER_B0[0]);    // Length of regressor
    796                      // Set up the indices of data elements in regressor
    797                      for ( i = 0; i < N_Theta; i++ )
    798                      {
    799                          Phi_Idx[PHI_BK_EULER_B0[i]] = i;
    800                      }
    801                      break;
    802          #endif
    803          #if MODEL_BK_EULER == ENABLED
    804                  case PARAM_EST_MODEL_BK_EULER:
    805          #endif
    806          #if MODEL_HYB_ACCEL == ENABLED
    807                  case PARAM_EST_MODEL_HYB_ACCEL:
    808          #endif
    809          #if MODEL_BK_EULER == ENABLED || MODEL_HYB_ACCEL == ENABLED
    810                      N_Theta = sizeof(PHI_BK_EULER) / sizeof(PHI_BK_EULER[0]);
    811                      // Set up the indices of data elements in regressor
    812                      for ( i = 0; i < N_Theta; i++ )
    813                      {
    814                          Phi_Idx[PHI_BK_EULER[i]] = i;
    815                      }
    816                      break;
    817          #endif
    818          #if MODEL_BK_EULER_B0_BB == ENABLED
    819                  case PARAM_EST_MODEL_BK_EULER_B0_BB:
    820                      N_Theta = sizeof(PHI_BK_EULER_B0_BB) / sizeof(PHI_BK_EULER_B0_BB[0]);
    821                      for ( i = 0; i < N_Theta; i++ )
    822                      {
    823                          Phi_Idx[PHI_BK_EULER_B0_BB[i]] = i;
    824                      }
    825                      break;
    826          #endif
    827                  default:    // Invalid model, but code will never get here since it has already been checked
    828                      break;
    829              }
    830          }
    831          
    832          //---------------------------------------------------------------------------------------------------------------------
    833          /**
    834           * @brief Wrapper function for filtering multiple channels of data
    835           *
    836           * @details Calls FilterDF2T in a loop for multiple channels of data.
    837           *
    838           * @param u = Pointer to 1-D array that holds the data to be filtered. Each element in u corresponds
    839           * to a channel of the input signal. The result of the function is to overwrite this array's
    840           * contents with the filtered data.
    841           * The function overwrites input u to store the filtered output data.
    842           *
    843           * @param n_chan = Number of channels contained in u. This can be less than or equal to the array's
    844           * size.
    845           */
    846          //#pragma optimize=size no_inline no_unroll
    847          static void DFiltNChan(float *u, unsigned char n_chan)
    848          {
    849              unsigned char i;
    850          
    851              for(i=0; i<n_chan; i++)             // loop over channels
    852              {
    853              	u[i] = DigitalFilter__DF2TSOS(u[i], Param_Est_Filter, Filter_Storage[i]);
    854              }
    855          }
    856          
    857          //---------------------------------------------------------------------------------------------------------------------
    858          /**
    859           * @brief Ball balancer angle construction
    860           *
    861           * @details Constructs an angle in radians which moves at a frequency defined by
    862           * the basket frequency multiplied by the lag parameter. This angle is used to estimate ball
    863           * balancer position in the RLS algorithm.
    864           *
    865           * @param w_drum        Drum speed in rad/s
    866           * @param lag           Factor by which the frequency of the drum is multiplied to construct
    867           * the ball balancer angle.
    868           *
    869           * @return The ball balancer angle.
    870           */
    871          //#pragma optimize=size no_inline no_unroll
    872          #if MODEL_BK_EULER_B0_BB == ENABLED
    873          static float BBAngle(float w_drum, float lag)
    874          {
    875              return PARAM_EST_ANGLE_WRAP(Alpha_BB + w_drum * TS_PARAMID * lag);
    876          }
    877          #endif
    878          
    879          //---------------------------------------------------------------------------------------------------------------------
    880          /**
    881           * @brief Angle wrapping function
    882           *
    883           * @detail Wraps angles in radians into a range specified by the upper limit parameter. Only works for angles
    884           * within 1 period in either direction of the principal range. For example, for a range of [0,2*PI], it will
    885           * wrap 3*PI to PI, but it will not do the same for 5*PI.
    886           *
    887           * @param angle = the angle in radians to wrap inside the principal range
    888           * @param ulim = the upper limit of the principal range. The principal range is taken as [ulim - 2*PI, ulim]
    889           *
    890           * @return the angle wrapped into the principal range
    891           */
    892          //#pragma optimize=size no_inline no_unroll
    893          static float WrapAngleRad(float angle,float ulim)
    894          {
    895          
    896              if (angle >= ulim)
    897              {
    898                  angle -= 2.0f * PI;
    899              }
    900              else if (angle < (ulim - 2.0 * PI))
    901              {
    902                  angle += 2.0f * PI;
    903              }
    904          
    905              return angle;
    906          
    907          }
    908          
    909          //---------------------------------------------------------------------------------------------------------------------
    910          /**
    911           * @brief Recursive Least Squares Algorithm, ParamID's core function
    912           *
    913           * @details This algorithm computes the parameter estimates from the data. It is not model-specific
    914           * and is applicable to any system written in regressor form (y = phi' * theta). Implementation follows
    915           * Potter's square root algorithm with forgetting and/or Kalman-style adaptation using QR decomposition.
    916           * For convenience, S' (S-transpose) is updated instead of S. See Ljung and Soderstrom,
    917           * Theory and Practice of Recursive Identification, page 327-329 for details. In the comments, Matlab-
    918           * style notation is used to show the underlying matrix computations.
    919           *
    920           * @param y = output in the model of the physical system.
    921           *
    922           * @param phi = pointer to 1-D input array which represents the regressor.
    923           *
    924           * @return The function writes to the static array Theta as its output, as well as returning the residual (error).
    925           */
    926          //#pragma optimize=size no_inline no_unroll

   \                                 In section .text, align 4, keep-with-next
    927          static float ParamIdRLS(float y, float *phi)
    928          {
   \                     ParamIdRLS: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xED2D 0x8B04      VPUSH    {D8-D9}
   \   00000008   0xB08E             SUB      SP,SP,#+56
    929              float f[N_THETA_MAX];
    930              float l_t[N_THETA_MAX];
    931              float beta;
    932              float alpha;
    933              float e;
    934              float y_hat;
    935              float e_by_beta;
    936              unsigned char i;
    937              unsigned char j;
    938          
    939              // write all elements in the arrays to remove PC Lint warnings
    940              for ( REGRESSOR_ELEMENTS_TYPE regressor_element = (REGRESSOR_ELEMENTS_TYPE)0; regressor_element < N_THETA_MAX; regressor_element++ )
   \   0000000A   0xA900             ADD      R1,SP,#+0
    941              {
    942                  f[regressor_element] = 0.0f;
   \   0000000C   0x2300             MOVS     R3,#+0
    943                  l_t[regressor_element] = 0.0f;
    944              }
    945          
    946              // y_hat = phi'*Theta
    947              // This is the one-step ahead prediction of the output (prediction step).
    948              y_hat = 0;
    949              for(i=0; i<N_Theta; i++)
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable17
   \   00000012   0x604B             STR      R3,[R1, #+4]
   \   00000014   0x608B             STR      R3,[R1, #+8]
   \   00000016   0x60CB             STR      R3,[R1, #+12]
   \   00000018   0x610B             STR      R3,[R1, #+16]
   \   0000001A   0x614B             STR      R3,[R1, #+20]
   \   0000001C   0x618B             STR      R3,[R1, #+24]
   \   0000001E   0xAA07             ADD      R2,SP,#+28
   \   00000020   0xF894 0x1031      LDRB     R1,[R4, #+49]
   \   00000024   0x9307             STR      R3,[SP, #+28]
   \   00000026   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000002A   0x9300             STR      R3,[SP, #+0]
   \   0000002C   0x6053             STR      R3,[R2, #+4]
   \   0000002E   0x6093             STR      R3,[R2, #+8]
   \   00000030   0x60D3             STR      R3,[R2, #+12]
   \   00000032   0x6113             STR      R3,[R2, #+16]
   \   00000034   0x6153             STR      R3,[R2, #+20]
   \   00000036   0x6193             STR      R3,[R2, #+24]
   \   00000038   0xED9F 0x0A3E      VLDR.W   S0,??ParamIdRLS_0  ;; 0x0
   \   0000003C   0x2900             CMP      R1,#+0
   \   0000003E   0xD069             BEQ.N    ??ParamIdRLS_1
   \   00000040   0xF104 0x0308      ADD      R3,R4,#+8
   \   00000044   0x4605             MOV      R5,R0
   \   00000046   0x07CE             LSLS     R6,R1,#+31
   \   00000048   0xD507             BPL.N    ??ParamIdRLS_2
    950              {
    951                  y_hat += Theta[i] * phi[i]; // one-step ahead prediction y_hat(t|t-1)
   \   0000004A   0xEDD3 0x0A00      VLDR     S1,[R3, #0]
   \   0000004E   0xED95 0x1A00      VLDR     S2,[R5, #0]
   \   00000052   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   \   00000056   0x1D2D             ADDS     R5,R5,#+4
   \   00000058   0x1D1B             ADDS     R3,R3,#+4
   \                     ??ParamIdRLS_2: (+1)
   \   0000005A   0x084A             LSRS     R2,R1,#+1
   \   0000005C   0xD16C             BNE.N    ??ParamIdRLS_3
   \                     ??ParamIdRLS_4: (+1)
   \   0000005E   0xEE38 0x8A40      VSUB.F32 S16,S16,S0
   \   00000062   0xAA07             ADD      R2,SP,#+28
   \   00000064   0xF104 0x0534      ADD      R5,R4,#+52
   \   00000068   0x460E             MOV      R6,R1
    952              }
    953          
    954              // This is the innovation step where we compare estimated output to actual output to
    955              // form the error signal used for correction.
    956              e = y - y_hat;
    957          
    958              // f = S_T*phi
    959              for(i=0; i<N_Theta; i++) // rows
    960              {
    961                  f[i] = 0; // f is a column vector
   \                     ??ParamIdRLS_5: (+1)
   \   0000006A   0x2300             MOVS     R3,#+0
   \   0000006C   0x6013             STR      R3,[R2, #+0]
    962                  for(j=0; j<N_Theta; j++) // cols
   \   0000006E   0xF011 0x0C03      ANDS     R12,R1,#0x3
   \   00000072   0xD011             BEQ.N    ??ParamIdRLS_6
    963                  {
    964                      f[i] += S_T[i][j] * phi[j];
   \                     ??ParamIdRLS_7: (+1)
   \   00000074   0xEB05 0x0783      ADD      R7,R5,R3, LSL #+2
   \   00000078   0xED92 0x1A00      VLDR     S2,[R2, #0]
   \   0000007C   0xED97 0x0A00      VLDR     S0,[R7, #0]
   \   00000080   0xEB00 0x0783      ADD      R7,R0,R3, LSL #+2
   \   00000084   0x1C5B             ADDS     R3,R3,#+1
   \   00000086   0xEDD7 0x0A00      VLDR     S1,[R7, #0]
   \   0000008A   0xEE00 0x1A20      VMLA.F32 S2,S0,S1
   \   0000008E   0xED82 0x1A00      VSTR     S2,[R2, #0]
   \   00000092   0xF1BC 0x0C01      SUBS     R12,R12,#+1
   \   00000096   0xD1ED             BNE.N    ??ParamIdRLS_7
   \                     ??ParamIdRLS_6: (+1)
   \   00000098   0x088F             LSRS     R7,R1,#+2
   \   0000009A   0xD037             BEQ.N    ??ParamIdRLS_8
   \                     ??ParamIdRLS_9: (+1)
   \   0000009C   0xEB05 0x0C83      ADD      R12,R5,R3, LSL #+2
   \   000000A0   0xED92 0x0A00      VLDR     S0,[R2, #0]
   \   000000A4   0xEDDC 0x0A00      VLDR     S1,[R12, #0]
   \   000000A8   0xEB00 0x0C83      ADD      R12,R0,R3, LSL #+2
   \   000000AC   0x1C5B             ADDS     R3,R3,#+1
   \   000000AE   0xED9C 0x1A00      VLDR     S2,[R12, #0]
   \   000000B2   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   \   000000B6   0xEB05 0x0C83      ADD      R12,R5,R3, LSL #+2
   \   000000BA   0xED82 0x0A00      VSTR     S0,[R2, #0]
   \   000000BE   0xEDDC 0x0A00      VLDR     S1,[R12, #0]
   \   000000C2   0xEB00 0x0C83      ADD      R12,R0,R3, LSL #+2
   \   000000C6   0x1C5B             ADDS     R3,R3,#+1
   \   000000C8   0xED9C 0x1A00      VLDR     S2,[R12, #0]
   \   000000CC   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   \   000000D0   0xEB05 0x0C83      ADD      R12,R5,R3, LSL #+2
   \   000000D4   0xED82 0x0A00      VSTR     S0,[R2, #0]
   \   000000D8   0xEDDC 0x0A00      VLDR     S1,[R12, #0]
   \   000000DC   0xEB00 0x0C83      ADD      R12,R0,R3, LSL #+2
   \   000000E0   0x1C5B             ADDS     R3,R3,#+1
   \   000000E2   0xED9C 0x1A00      VLDR     S2,[R12, #0]
   \   000000E6   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   \   000000EA   0xEB05 0x0C83      ADD      R12,R5,R3, LSL #+2
   \   000000EE   0xED82 0x0A00      VSTR     S0,[R2, #0]
   \   000000F2   0xEDDC 0x0A00      VLDR     S1,[R12, #0]
   \   000000F6   0xEB00 0x0C83      ADD      R12,R0,R3, LSL #+2
    965                  }
   \   000000FA   0x1C5B             ADDS     R3,R3,#+1
   \   000000FC   0xED9C 0x1A00      VLDR     S2,[R12, #0]
   \   00000100   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   \   00000104   0xED82 0x0A00      VSTR     S0,[R2, #0]
   \   00000108   0x1E7F             SUBS     R7,R7,#+1
   \   0000010A   0xD1C7             BNE.N    ??ParamIdRLS_9
    966              }
   \                     ??ParamIdRLS_8: (+1)
   \   0000010C   0x351C             ADDS     R5,R5,#+28
   \   0000010E   0x1D12             ADDS     R2,R2,#+4
   \   00000110   0x1E76             SUBS     R6,R6,#+1
   \   00000112   0xD1AA             BNE.N    ??ParamIdRLS_5
    967          
    968              // beta = Lambda + f'*f
    969              if( (Setup_Parameters->Model_Config.Struct.Adapt_Type == PARAM_EST_ADAPTATION_FORGETTING) ||
    970                  (Setup_Parameters->Model_Config.Struct.Adapt_Type == PARAM_EST_ADAPTATION_BOTH) )
   \                     ??ParamIdRLS_1: (+1)
   \   00000114   0xF8D4 0x01D0      LDR      R0,[R4, #+464]
   \   00000118   0x7F01             LDRB     R1,[R0, #+28]
   \   0000011A   0x220F             MOVS     R2,#+15
   \   0000011C   0x4211             TST      R1,R2
   \   0000011E   0xBF1C             ITT      NE 
   \   00000120   0xF001 0x010F      ANDNE    R1,R1,#0xF
   \   00000124   0x2902             CMPNE    R1,#+2
   \   00000126   0xBF06             ITTE     EQ 
    971              {
    972                  beta = Setup_Parameters->Forgetting;
   \   00000128   0x6841             LDREQ    R1,[R0, #+4]
   \   0000012A   0xEE09 0x1A10      VMOVEQ   S18,R1
    973              }
    974              else
    975              {
    976                  beta = 1.0f;
   \   0000012E   0xEEB7 0x9A00      VMOVNE.F32 S18,#1.0
   \   00000132   0xE013             B.N      ??ParamIdRLS_10
   \                     ??ParamIdRLS_0:
   \   00000134   0x00000000         DC32     0x0
    977              }
   \                     ??ParamIdRLS_3: (+1)
   \   00000138   0xEDD3 0x0A01      VLDR     S1,[R3, #+4]
   \   0000013C   0xED95 0x1A01      VLDR     S2,[R5, #+4]
   \   00000140   0xEDD3 0x1A00      VLDR     S3,[R3, #0]
   \   00000144   0xED95 0x2A00      VLDR     S4,[R5, #0]
   \   00000148   0xEE01 0x0A82      VMLA.F32 S0,S3,S4
   \   0000014C   0x1E52             SUBS     R2,R2,#+1
   \   0000014E   0x3508             ADDS     R5,R5,#+8
   \   00000150   0x3308             ADDS     R3,R3,#+8
   \   00000152   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   \   00000156   0x2A00             CMP      R2,#+0
   \   00000158   0xD1EE             BNE.N    ??ParamIdRLS_3
   \   0000015A   0xE780             B.N      ??ParamIdRLS_4
    978          
    979              for(i=0; i<N_Theta; i++)
   \                     ??ParamIdRLS_10: (+1)
   \   0000015C   0xF894 0x0031      LDRB     R0,[R4, #+49]
   \   00000160   0xB1B0             CBZ.N    R0,??ParamIdRLS_11
   \   00000162   0xA907             ADD      R1,SP,#+28
   \   00000164   0x07C2             LSLS     R2,R0,#+31
   \   00000166   0xD504             BPL.N    ??ParamIdRLS_12
    980              {
    981                  beta += f[i] * f[i];
   \   00000168   0xED91 0x0A00      VLDR     S0,[R1, #0]
   \   0000016C   0xEE00 0x9A00      VMLA.F32 S18,S0,S0
   \   00000170   0x1D09             ADDS     R1,R1,#+4
   \                     ??ParamIdRLS_12: (+1)
   \   00000172   0x0840             LSRS     R0,R0,#+1
   \   00000174   0xF000 0x800C      BEQ.W    ??ParamIdRLS_11
   \                     ??ParamIdRLS_13: (+1)
   \   00000178   0xED91 0x0A01      VLDR     S0,[R1, #+4]
   \   0000017C   0xEDD1 0x0A00      VLDR     S1,[R1, #0]
   \   00000180   0xEE00 0x9AA0      VMLA.F32 S18,S1,S1
    982              }
   \   00000184   0x1E40             SUBS     R0,R0,#+1
   \   00000186   0x3108             ADDS     R1,R1,#+8
   \   00000188   0xEE00 0x9A00      VMLA.F32 S18,S0,S0
   \   0000018C   0x2800             CMP      R0,#+0
   \   0000018E   0xD1F3             BNE.N    ??ParamIdRLS_13
    983          
    984              e_by_beta = e / beta;
    985          
    986              if( (Setup_Parameters->Model_Config.Struct.Adapt_Type == PARAM_EST_ADAPTATION_FORGETTING) ||
    987                  (Setup_Parameters->Model_Config.Struct.Adapt_Type == PARAM_EST_ADAPTATION_BOTH) )
   \                     ??ParamIdRLS_11: (+1)
   \   00000190   0xF8D4 0x01D0      LDR      R0,[R4, #+464]
   \   00000194   0x7F01             LDRB     R1,[R0, #+28]
   \   00000196   0x220F             MOVS     R2,#+15
   \   00000198   0xEEC8 0x8A09      VDIV.F32 S17,S16,S18
   \   0000019C   0x4211             TST      R1,R2
   \   0000019E   0xBF1C             ITT      NE 
   \   000001A0   0xF001 0x010F      ANDNE    R1,R1,#0xF
   \   000001A4   0x2902             CMPNE    R1,#+2
   \   000001A6   0xBF03             ITTTE    EQ 
    988              {
    989                  alpha = 1.0f / (beta + sqrtf(beta * Setup_Parameters->Forgetting));
   \   000001A8   0x6841             LDREQ    R1,[R0, #+4]
   \   000001AA   0xEE00 0x1A10      VMOVEQ   S0,R1
   \   000001AE   0xEE29 0x0A00      VMULEQ.F32 S0,S18,S0
    990              }
    991              else
    992              {
    993                  alpha = 1.0f / (beta + sqrtf(beta));
   \   000001B2   0xEEB0 0x0A49      VMOVNE.F32 S0,S18
   \   000001B6   0x.... 0x....      BL       sqrtf
    994              }
    995          
    996              // l_t = f'*S_T
    997              for(j=0; j<N_Theta; j++) // cols
   \   000001BA   0xF894 0x1031      LDRB     R1,[R4, #+49]
   \   000001BE   0xEE39 0x0A00      VADD.F32 S0,S18,S0
   \   000001C2   0xEEF7 0x0A00      VMOV.F32 S1,#1.0
   \   000001C6   0xEE80 0x0A80      VDIV.F32 S0,S1,S0
   \   000001CA   0x2900             CMP      R1,#+0
   \   000001CC   0xF000 0x80A6      BEQ.W    ??ParamIdRLS_14
   \   000001D0   0xAB00             ADD      R3,SP,#+0
   \   000001D2   0xF104 0x0534      ADD      R5,R4,#+52
   \   000001D6   0x460E             MOV      R6,R1
    998              {
    999                  l_t[j] = 0.0f;
   1000                  for(i=0; i<N_Theta; i++) // rows
   \                     ??ParamIdRLS_15: (+1)
   \   000001D8   0x2700             MOVS     R7,#+0
   \   000001DA   0xEDDF 0x....      VLDR.W   S1,??DataTable17_1  ;; 0x0
   \   000001DE   0xF011 0x0001      ANDS     R0,R1,#0x1
   \   000001E2   0xD006             BEQ.N    ??ParamIdRLS_16
   1001                  {
   1002                      l_t[j] += f[i] * S_T[i][j];
   \   000001E4   0xED9D 0x1A07      VLDR     S2,[SP, #+28]
   \   000001E8   0xEDD5 0x1A00      VLDR     S3,[R5, #0]
   \   000001EC   0xEE41 0x0A21      VMLA.F32 S1,S2,S3
   \   000001F0   0x2701             MOVS     R7,#+1
   \                     ??ParamIdRLS_16: (+1)
   \   000001F2   0x084A             LSRS     R2,R1,#+1
   \   000001F4   0x4694             MOV      R12,R2
   \   000001F6   0xD01B             BEQ.N    ??ParamIdRLS_17
   \   000001F8   0xF10D 0x0E1C      ADD      LR,SP,#+28
   \   000001FC   0xEB0E 0x0E87      ADD      LR,LR,R7, LSL #+2
   \   00000200   0xEBC7 0x08C7      RSB      R8,R7,R7, LSL #+3
   \   00000204   0xEB05 0x0788      ADD      R7,R5,R8, LSL #+2
   \                     ??ParamIdRLS_18: (+1)
   \   00000208   0xEDD7 0x1A07      VLDR     S3,[R7, #+28]
   \   0000020C   0xED9E 0x2A00      VLDR     S4,[LR, #0]
   \   00000210   0xEDD7 0x2A00      VLDR     S5,[R7, #0]
   \   00000214   0xED9E 0x1A01      VLDR     S2,[LR, #+4]
   \   00000218   0xEE42 0x0A22      VMLA.F32 S1,S4,S5
   1003                  }
   \   0000021C   0xF1AC 0x0C01      SUB      R12,R12,#+1
   \   00000220   0x3738             ADDS     R7,R7,#+56
   \   00000222   0xEE41 0x0A21      VMLA.F32 S1,S2,S3
   \   00000226   0xF10E 0x0E08      ADD      LR,LR,#+8
   \   0000022A   0xF1BC 0x0F00      CMP      R12,#+0
   \   0000022E   0xD1EB             BNE.N    ??ParamIdRLS_18
   \                     ??ParamIdRLS_17: (+1)
   \   00000230   0xEDC3 0x0A00      VSTR     S1,[R3, #0]
   1004              }
   \   00000234   0x1D2D             ADDS     R5,R5,#+4
   \   00000236   0x1D1B             ADDS     R3,R3,#+4
   \   00000238   0x1E76             SUBS     R6,R6,#+1
   \   0000023A   0xD1CD             BNE.N    ??ParamIdRLS_15
   \   0000023C   0xF104 0x0308      ADD      R3,R4,#+8
   \   00000240   0xAD00             ADD      R5,SP,#+0
   \   00000242   0xB148             CBZ.N    R0,??ParamIdRLS_19
   1005          
   1006              // Parameter Update. This is the correction step where we modify the estimated parameters
   1007              // based on the innovation (error in prediction).
   1008              // Theta = Theta + l_t'*(e/beta)
   1009              for(i=0; i<N_Theta; i++)
   1010              {
   1011                  Theta[i] += l_t[i] * e_by_beta;
   \   00000244   0xEDD5 0x0A00      VLDR     S1,[R5, #0]
   \   00000248   0xED93 0x1A00      VLDR     S2,[R3, #0]
   \   0000024C   0xEE00 0x1AA8      VMLA.F32 S2,S1,S17
   \   00000250   0xED83 0x1A00      VSTR     S2,[R3, #0]
   \   00000254   0x1D2D             ADDS     R5,R5,#+4
   \   00000256   0x1D1B             ADDS     R3,R3,#+4
   \                     ??ParamIdRLS_19: (+1)
   \   00000258   0x0016             MOVS     R6,R2
   \   0000025A   0xD014             BEQ.N    ??ParamIdRLS_20
   \                     ??ParamIdRLS_21: (+1)
   \   0000025C   0xEDD5 0x0A00      VLDR     S1,[R5, #0]
   \   00000260   0xED93 0x1A00      VLDR     S2,[R3, #0]
   \   00000264   0xEE00 0x1AA8      VMLA.F32 S2,S1,S17
   \   00000268   0xED83 0x1A00      VSTR     S2,[R3, #0]
   \   0000026C   0xEDD5 0x0A01      VLDR     S1,[R5, #+4]
   \   00000270   0xED93 0x1A01      VLDR     S2,[R3, #+4]
   \   00000274   0xEE00 0x1AA8      VMLA.F32 S2,S1,S17
   \   00000278   0xED83 0x1A01      VSTR     S2,[R3, #+4]
   1012              }
   \   0000027C   0x1E76             SUBS     R6,R6,#+1
   \   0000027E   0x3508             ADDS     R5,R5,#+8
   \   00000280   0x3308             ADDS     R3,R3,#+8
   \   00000282   0x2E00             CMP      R6,#+0
   \   00000284   0xD1EA             BNE.N    ??ParamIdRLS_21
   \                     ??ParamIdRLS_20: (+1)
   \   00000286   0x460F             MOV      R7,R1
   \   00000288   0xAD07             ADD      R5,SP,#+28
   \   0000028A   0xF104 0x0634      ADD      R6,R4,#+52
   \   0000028E   0x2300             MOVS     R3,#+0
   \   00000290   0xA900             ADD      R1,SP,#+0
   \   00000292   0xE000             B.N      ??ParamIdRLS_22
   1013          
   1014              // Square root covariance update.
   1015          
   1016              // S_T = (S_T - alpha*f*l_t)/sqrtf(Lambda)
   1017              for(i=0; i<N_Theta; i++) // rows
   \                     ??ParamIdRLS_23: (+1)
   \   00000294   0x2300             MOVS     R3,#+0
   \                     ??ParamIdRLS_22: (+1)
   \   00000296   0xB180             CBZ.N    R0,??ParamIdRLS_24
   1018              {
   1019                  for(j=0; j<N_Theta; j++) // cols
   1020                  {
   1021                      S_T[i][j] = (S_T[i][j] - alpha * f[i] * l_t[j]) * Lambda_Sqrt_Inv;
   \   00000298   0xEDD5 0x0A00      VLDR     S1,[R5, #0]
   \   0000029C   0xED9D 0x1A00      VLDR     S2,[SP, #+0]
   \   000002A0   0xEDD6 0x1A00      VLDR     S3,[R6, #0]
   \   000002A4   0xEE60 0x0A20      VMUL.F32 S1,S0,S1
   \   000002A8   0xEE40 0x1AC1      VMLS.F32 S3,S1,S2
   \   000002AC   0xEDD4 0x0A6F      VLDR     S1,[R4, #+444]
   \   000002B0   0xEE61 0x0AA0      VMUL.F32 S1,S3,S1
   \   000002B4   0xEDC6 0x0A00      VSTR     S1,[R6, #0]
   \   000002B8   0x2301             MOVS     R3,#+1
   \                     ??ParamIdRLS_24: (+1)
   \   000002BA   0xEA5F 0x0C02      MOVS     R12,R2
   \   000002BE   0xD029             BEQ.N    ??ParamIdRLS_25
   \   000002C0   0xEB06 0x0E83      ADD      LR,R6,R3, LSL #+2
   \   000002C4   0xEB01 0x0383      ADD      R3,R1,R3, LSL #+2
   \                     ??ParamIdRLS_26: (+1)
   \   000002C8   0xED95 0x1A00      VLDR     S2,[R5, #0]
   \   000002CC   0xEDD3 0x1A00      VLDR     S3,[R3, #0]
   \   000002D0   0xED9E 0x2A00      VLDR     S4,[LR, #0]
   \   000002D4   0xEDD4 0x0A6F      VLDR     S1,[R4, #+444]
   \   000002D8   0xEE20 0x1A01      VMUL.F32 S2,S0,S2
   \   000002DC   0xEE01 0x2A61      VMLS.F32 S4,S2,S3
   \   000002E0   0xEE22 0x1A20      VMUL.F32 S2,S4,S1
   \   000002E4   0xED8E 0x1A00      VSTR     S2,[LR, #0]
   1022                  }
   \   000002E8   0xF1AC 0x0C01      SUB      R12,R12,#+1
   \   000002EC   0xED95 0x1A00      VLDR     S2,[R5, #0]
   \   000002F0   0xEDD3 0x1A01      VLDR     S3,[R3, #+4]
   \   000002F4   0xED9E 0x2A01      VLDR     S4,[LR, #+4]
   \   000002F8   0xEE20 0x1A01      VMUL.F32 S2,S0,S2
   \   000002FC   0xEE01 0x2A61      VMLS.F32 S4,S2,S3
   \   00000300   0xEE62 0x0A20      VMUL.F32 S1,S4,S1
   \   00000304   0xEDCE 0x0A01      VSTR     S1,[LR, #+4]
   \   00000308   0x3308             ADDS     R3,R3,#+8
   \   0000030A   0xF10E 0x0E08      ADD      LR,LR,#+8
   \   0000030E   0xF1BC 0x0F00      CMP      R12,#+0
   \   00000312   0xD1D9             BNE.N    ??ParamIdRLS_26
   1023              }
   \                     ??ParamIdRLS_25: (+1)
   \   00000314   0x361C             ADDS     R6,R6,#+28
   \   00000316   0x1D2D             ADDS     R5,R5,#+4
   \   00000318   0x1E7F             SUBS     R7,R7,#+1
   \   0000031A   0xD1BB             BNE.N    ??ParamIdRLS_23
   1024          
   1025              // If using Kalman approach, now do QR factorization to update S_T
   1026              if (( Setup_Parameters->Model_Config.Struct.Adapt_Type == PARAM_EST_ADAPTATION_KALMAN ) ||
   1027                  ( Setup_Parameters->Model_Config.Struct.Adapt_Type == PARAM_EST_ADAPTATION_BOTH ))
   \                     ??ParamIdRLS_14: (+1)
   \   0000031C   0xF8D4 0x01D0      LDR      R0,[R4, #+464]
   \   00000320   0x7F01             LDRB     R1,[R0, #+28]
   \   00000322   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000326   0x2901             CMP      R1,#+1
   \   00000328   0xBF18             IT       NE 
   \   0000032A   0x2902             CMPNE    R1,#+2
   \   0000032C   0xF040 0x80F9      BNE.W    ??ParamIdRLS_27
   1028              {
   1029                  // Now concatenate S' vertically with V' to incorporate additive term to covariance matrix.
   1030                  // V' is a diagonal matrix that satisfies V*V' = R_1. The covariance matrix P = S * S' is modified
   1031                  // in this approach by adding R_1 = V*V' to it. That is, P <- P + R_1 = S*S' + V*V' is performed.
   1032          
   1033                  // Reorder Kalman Vector to match phi. This is done according to each model, to link parameters'
   1034                  // adaptation rates to the corresponding elements in the regressor.
   1035                  switch(Setup_Parameters->Model_Config.Struct.Model)
   \   00000330   0x7F01             LDRB     R1,[R0, #+28]
   \   00000332   0x0909             LSRS     R1,R1,#+4
   \   00000334   0x1E49             SUBS     R1,R1,#+1
   \   00000336   0x2901             CMP      R1,#+1
   \   00000338   0xD93E             BLS.N    ??ParamIdRLS_28
   \   0000033A   0x1E89             SUBS     R1,R1,#+2
   \   0000033C   0x6881             LDR      R1,[R0, #+8]
   \   0000033E   0xF894 0x0025      LDRB     R0,[R4, #+37]
   \   00000342   0xEE00 0x1A10      VMOV     S0,R1
   \   00000346   0xF894 0x1031      LDRB     R1,[R4, #+49]
   \   0000034A   0xF000 0x8083      BEQ.W    ??ParamIdRLS_29
   1036                  {
   1037                      default:
   1038          #if MODEL_BK_EULER_B0 == ENABLED
   1039                      case PARAM_EST_MODEL_BK_EULER_B0:
   1040                          S_T[Phi_Idx[REG_ELE_TORQUE]+N_Theta] [Phi_Idx[REG_ELE_TORQUE]] = Setup_Parameters->Kalman_Vector[PARAM_EST_KALMAN_INERTIA];
   \   0000034E   0x1841             ADDS     R1,R0,R1
   \   00000350   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   00000354   0xEB04 0x0182      ADD      R1,R4,R2, LSL #+2
   \   00000358   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   0000035C   0xED80 0x0A0D      VSTR     S0,[R0, #+52]
   1041                          S_T[Phi_Idx[REG_ELE_CONSTANT]+N_Theta] [Phi_Idx[REG_ELE_CONSTANT]] = Setup_Parameters->Kalman_Vector[PARAM_EST_KALMAN_COULOMB];
   \   00000360   0xF8D4 0x01D0      LDR      R0,[R4, #+464]
   \   00000364   0x6901             LDR      R1,[R0, #+16]
   \   00000366   0xF894 0x0026      LDRB     R0,[R4, #+38]
   \   0000036A   0xEE00 0x1A10      VMOV     S0,R1
   \   0000036E   0xF894 0x1031      LDRB     R1,[R4, #+49]
   \   00000372   0x1841             ADDS     R1,R0,R1
   \   00000374   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   00000378   0xEB04 0x0182      ADD      R1,R4,R2, LSL #+2
   \   0000037C   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000380   0xED80 0x0A0D      VSTR     S0,[R0, #+52]
   1042                          S_T[Phi_Idx[REG_ELE_SIN_ANGLE]+N_Theta] [Phi_Idx[REG_ELE_SIN_ANGLE]] = Setup_Parameters->Kalman_Vector[PARAM_EST_KALMAN_UNBALANCE];
   \   00000384   0xF8D4 0x01D0      LDR      R0,[R4, #+464]
   \   00000388   0x6941             LDR      R1,[R0, #+20]
   \   0000038A   0xF894 0x0027      LDRB     R0,[R4, #+39]
   \   0000038E   0xEE00 0x1A10      VMOV     S0,R1
   \   00000392   0xF894 0x1031      LDRB     R1,[R4, #+49]
   \   00000396   0x1841             ADDS     R1,R0,R1
   \   00000398   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   0000039C   0xEB04 0x0182      ADD      R1,R4,R2, LSL #+2
   \   000003A0   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   000003A4   0xED80 0x0A0D      VSTR     S0,[R0, #+52]
   1043                          S_T[Phi_Idx[REG_ELE_COS_ANGLE]+N_Theta] [Phi_Idx[REG_ELE_COS_ANGLE]] = Setup_Parameters->Kalman_Vector[PARAM_EST_KALMAN_UNBALANCE];
   \   000003A8   0xF8D4 0x01D0      LDR      R0,[R4, #+464]
   \   000003AC   0x6941             LDR      R1,[R0, #+20]
   \   000003AE   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \   000003B2   0xEE00 0x1A10      VMOV     S0,R1
   \   000003B6   0xE0A5             B.N      ??ParamIdRLS_30
   1044                          break;
   1045          #endif
   1046          
   1047                      // For the backward Euler case, Kalman tuning doesn't allow us to strictly separate the adaptation of inertia and
   1048                      // viscous friction. They are arbitrarily assigned below. Avoid using the Kalman adaptation method for this model
   1049                      // choice if the goal is to tune inertia and friction adaptation independently.
   1050          #if MODEL_BK_EULER == ENABLED
   1051                      case PARAM_EST_MODEL_BK_EULER:
   1052          #endif
   1053          #if MODEL_HYB_ACCEL == ENABLED
   1054                      case PARAM_EST_MODEL_HYB_ACCEL:
   1055          #endif
   1056          #if MODEL_BK_EULER == ENABLED || MODEL_HYB_ACCEL == ENABLED
   1057                          S_T[Phi_Idx[REG_ELE_TORQUE]+N_Theta] [Phi_Idx[REG_ELE_TORQUE]] = Setup_Parameters->Kalman_Vector[PARAM_EST_KALMAN_INERTIA];
   \                     ??ParamIdRLS_28: (+1)
   \   000003B8   0x6881             LDR      R1,[R0, #+8]
   \   000003BA   0xF894 0x0025      LDRB     R0,[R4, #+37]
   \   000003BE   0xEE00 0x1A10      VMOV     S0,R1
   \   000003C2   0xF894 0x1031      LDRB     R1,[R4, #+49]
   \   000003C6   0x1841             ADDS     R1,R0,R1
   \   000003C8   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   000003CC   0xEB04 0x0182      ADD      R1,R4,R2, LSL #+2
   \   000003D0   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   000003D4   0xED80 0x0A0D      VSTR     S0,[R0, #+52]
   1058                          S_T[Phi_Idx[REG_ELE_SPEED]+N_Theta] [Phi_Idx[REG_ELE_SPEED]] = Setup_Parameters->Kalman_Vector[PARAM_EST_KALMAN_VISCOUS];
   \   000003D8   0xF8D4 0x01D0      LDR      R0,[R4, #+464]
   \   000003DC   0x68C1             LDR      R1,[R0, #+12]
   \   000003DE   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   000003E2   0xEE00 0x1A10      VMOV     S0,R1
   \   000003E6   0xF894 0x1031      LDRB     R1,[R4, #+49]
   \   000003EA   0x1841             ADDS     R1,R0,R1
   \   000003EC   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   000003F0   0xEB04 0x0182      ADD      R1,R4,R2, LSL #+2
   \   000003F4   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   000003F8   0xED80 0x0A0D      VSTR     S0,[R0, #+52]
   1059                          S_T[Phi_Idx[REG_ELE_CONSTANT]+N_Theta] [Phi_Idx[REG_ELE_CONSTANT]] = Setup_Parameters->Kalman_Vector[PARAM_EST_KALMAN_COULOMB];
   \   000003FC   0xF8D4 0x01D0      LDR      R0,[R4, #+464]
   \   00000400   0x6901             LDR      R1,[R0, #+16]
   \   00000402   0xF894 0x0026      LDRB     R0,[R4, #+38]
   \   00000406   0xEE00 0x1A10      VMOV     S0,R1
   \   0000040A   0xF894 0x1031      LDRB     R1,[R4, #+49]
   \   0000040E   0x1841             ADDS     R1,R0,R1
   \   00000410   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   00000414   0xEB04 0x0182      ADD      R1,R4,R2, LSL #+2
   \   00000418   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   0000041C   0xED80 0x0A0D      VSTR     S0,[R0, #+52]
   1060                          S_T[Phi_Idx[REG_ELE_SIN_ANGLE]+N_Theta] [Phi_Idx[REG_ELE_SIN_ANGLE]] = Setup_Parameters->Kalman_Vector[PARAM_EST_KALMAN_UNBALANCE];
   \   00000420   0xF8D4 0x01D0      LDR      R0,[R4, #+464]
   \   00000424   0x6941             LDR      R1,[R0, #+20]
   \   00000426   0xF894 0x0027      LDRB     R0,[R4, #+39]
   \   0000042A   0xEE00 0x1A10      VMOV     S0,R1
   \   0000042E   0xF894 0x1031      LDRB     R1,[R4, #+49]
   \   00000432   0x1841             ADDS     R1,R0,R1
   \   00000434   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   00000438   0xEB04 0x0182      ADD      R1,R4,R2, LSL #+2
   \   0000043C   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000440   0xED80 0x0A0D      VSTR     S0,[R0, #+52]
   1061                          S_T[Phi_Idx[REG_ELE_COS_ANGLE]+N_Theta] [Phi_Idx[REG_ELE_COS_ANGLE]] = Setup_Parameters->Kalman_Vector[PARAM_EST_KALMAN_UNBALANCE];
   \   00000444   0xF8D4 0x01D0      LDR      R0,[R4, #+464]
   \   00000448   0x6941             LDR      R1,[R0, #+20]
   \   0000044A   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \   0000044E   0xEE00 0x1A10      VMOV     S0,R1
   \   00000452   0xE057             B.N      ??ParamIdRLS_30
   1062                          break;
   1063          #endif
   1064          #if MODEL_BK_EULER_B0_BB == ENABLED
   1065                      case PARAM_EST_MODEL_BK_EULER_B0_BB:
   1066                          S_T[Phi_Idx[REG_ELE_TORQUE]+N_Theta] [Phi_Idx[REG_ELE_TORQUE]] = Setup_Parameters->Kalman_Vector[PARAM_EST_KALMAN_INERTIA];
   \                     ??ParamIdRLS_29: (+1)
   \   00000454   0x1841             ADDS     R1,R0,R1
   \   00000456   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   0000045A   0xEB04 0x0182      ADD      R1,R4,R2, LSL #+2
   \   0000045E   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000462   0xED80 0x0A0D      VSTR     S0,[R0, #+52]
   1067                          S_T[Phi_Idx[REG_ELE_CONSTANT]+N_Theta] [Phi_Idx[REG_ELE_CONSTANT]] = Setup_Parameters->Kalman_Vector[PARAM_EST_KALMAN_COULOMB];
   \   00000466   0xF8D4 0x01D0      LDR      R0,[R4, #+464]
   \   0000046A   0x6901             LDR      R1,[R0, #+16]
   \   0000046C   0xF894 0x0026      LDRB     R0,[R4, #+38]
   \   00000470   0xEE00 0x1A10      VMOV     S0,R1
   \   00000474   0xF894 0x1031      LDRB     R1,[R4, #+49]
   \   00000478   0x1841             ADDS     R1,R0,R1
   \   0000047A   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   0000047E   0xEB04 0x0182      ADD      R1,R4,R2, LSL #+2
   \   00000482   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000486   0xED80 0x0A0D      VSTR     S0,[R0, #+52]
   1068                          S_T[Phi_Idx[REG_ELE_SIN_ANGLE]+N_Theta] [Phi_Idx[REG_ELE_SIN_ANGLE]] = Setup_Parameters->Kalman_Vector[PARAM_EST_KALMAN_UNBALANCE];
   \   0000048A   0xF8D4 0x01D0      LDR      R0,[R4, #+464]
   \   0000048E   0x6941             LDR      R1,[R0, #+20]
   \   00000490   0xF894 0x0027      LDRB     R0,[R4, #+39]
   \   00000494   0xEE00 0x1A10      VMOV     S0,R1
   \   00000498   0xF894 0x1031      LDRB     R1,[R4, #+49]
   \   0000049C   0x1841             ADDS     R1,R0,R1
   \   0000049E   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   000004A2   0xEB04 0x0182      ADD      R1,R4,R2, LSL #+2
   \   000004A6   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   000004AA   0xED80 0x0A0D      VSTR     S0,[R0, #+52]
   1069                          S_T[Phi_Idx[REG_ELE_COS_ANGLE]+N_Theta] [Phi_Idx[REG_ELE_COS_ANGLE]] = Setup_Parameters->Kalman_Vector[PARAM_EST_KALMAN_UNBALANCE];
   \   000004AE   0xF8D4 0x01D0      LDR      R0,[R4, #+464]
   \   000004B2   0x6941             LDR      R1,[R0, #+20]
   \   000004B4   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \   000004B8   0xEE00 0x1A10      VMOV     S0,R1
   \   000004BC   0xF894 0x1031      LDRB     R1,[R4, #+49]
   \   000004C0   0x1841             ADDS     R1,R0,R1
   \   000004C2   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   000004C6   0xEB04 0x0182      ADD      R1,R4,R2, LSL #+2
   \   000004CA   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   000004CE   0xED80 0x0A0D      VSTR     S0,[R0, #+52]
   1070                          S_T[Phi_Idx[REG_ELE_SIN_BB_ANGLE]+N_Theta] [Phi_Idx[REG_ELE_SIN_BB_ANGLE]] = Setup_Parameters->Kalman_Vector[PARAM_EST_KALMAN_BALLBALANCER];
   \   000004D2   0xF8D4 0x01D0      LDR      R0,[R4, #+464]
   \   000004D6   0x6981             LDR      R1,[R0, #+24]
   \   000004D8   0xF894 0x0029      LDRB     R0,[R4, #+41]
   \   000004DC   0xEE00 0x1A10      VMOV     S0,R1
   \   000004E0   0xF894 0x1031      LDRB     R1,[R4, #+49]
   \   000004E4   0x1841             ADDS     R1,R0,R1
   \   000004E6   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   000004EA   0xEB04 0x0182      ADD      R1,R4,R2, LSL #+2
   \   000004EE   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   000004F2   0xED80 0x0A0D      VSTR     S0,[R0, #+52]
   1071                          S_T[Phi_Idx[REG_ELE_COS_BB_ANGLE]+N_Theta] [Phi_Idx[REG_ELE_COS_BB_ANGLE]] = Setup_Parameters->Kalman_Vector[PARAM_EST_KALMAN_BALLBALANCER];
   \   000004F6   0xF8D4 0x01D0      LDR      R0,[R4, #+464]
   \   000004FA   0x6981             LDR      R1,[R0, #+24]
   \   000004FC   0xF894 0x002A      LDRB     R0,[R4, #+42]
   \   00000500   0xEE00 0x1A10      VMOV     S0,R1
   \                     ??ParamIdRLS_30: (+1)
   \   00000504   0xF894 0x1031      LDRB     R1,[R4, #+49]
   \   00000508   0x1841             ADDS     R1,R0,R1
   \   0000050A   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   0000050E   0xEB04 0x0182      ADD      R1,R4,R2, LSL #+2
   \   00000512   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000516   0xED80 0x0A0D      VSTR     S0,[R0, #+52]
   1072                          break;
   1073          #endif
   1074                  }
   1075          
   1076                  ParamIdQR(S_T);
   \   0000051A   0xF104 0x0034      ADD      R0,R4,#+52
   \   0000051E   0x.... 0x....      BL       ParamIdQR
   1077              }
   1078          
   1079              return e;
   \                     ??ParamIdRLS_27: (+1)
   \   00000522   0xB00E             ADD      SP,SP,#+56
   \   00000524   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000528   0xECBD 0x8B04      VPOP     {D8-D9}
   \   0000052C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1080          
   1081          }
   1082          
   1083          //---------------------------------------------------------------------------------------------------------------------
   1084          /**
   1085           * @brief QR decomposition of the input matrix. Called by the ParamIdRLS function.
   1086           *
   1087           * @details Performs QR (orthogonal-triangular) decomposition of the input matrix A
   1088           * so that A = Q * R. Uses the Householder method. This function overwrites the input
   1089           * array A with R. Q is not needed, and is thus not stored. See Golub and Van Loan,
   1090           * Matrix Computations (4th Ed), section 5.2.2 for details. In the comments, Matlab-
   1091           * style notation is used to show the underlying matrix computations.
   1092           *
   1093           * @param   a = pointer to 2-D array to decompose. A is overwritten with the result R.
   1094           *          The function overwrites the input array with the result.
   1095           */
   1096          //#pragma optimize=size no_inline no_unroll

   \                                 In section .text, align 4, keep-with-next
   1097          static void ParamIdQR(float a[][N_THETA_MAX])
   1098          {
   \                     ParamIdQR: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   1099              float sigma;
   1100              float mu;
   1101              float beta;
   1102              float v0;
   1103              unsigned char j;
   1104              unsigned char i;
   1105              unsigned char k;
   1106              unsigned char m;
   1107          
   1108          
   1109              for ( j = 0; j < N_Theta; j++ ) // Loop across columns of A to introduce zeros
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000008   0xED2D 0x8B04      VPUSH    {D8-D9}
   \   0000000C   0xF890 0x0031      LDRB     R0,[R0, #+49]
   \   00000010   0x2400             MOVS     R4,#+0
   \   00000012   0xB082             SUB      SP,SP,#+8
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xF000 0x81CC      BEQ.W    ??ParamIdQR_0
   \   0000001A   0x9E06             LDR      R6,[SP, #+24]
   \   0000001C   0xF8DD 0x8018      LDR      R8,[SP, #+24]
   \   00000020   0x9601             STR      R6,[SP, #+4]
   \   00000022   0x2501             MOVS     R5,#+1
   \   00000024   0xEEB8 0x8A00      VMOV.F32 S16,#-2.0
   \   00000028   0xEEF7 0x8A00      VMOV.F32 S17,#1.0
   1110              {
   1111                  m = 2 * N_Theta - 1;    // This is the lowest relevant row in A.
   \                     ??ParamIdQR_1: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000030   0xF890 0x0031      LDRB     R0,[R0, #+49]
   \   00000034   0x0040             LSLS     R0,R0,#+1
   \   00000036   0x1E40             SUBS     R0,R0,#+1
   \   00000038   0xB2C7             UXTB     R7,R0
   \   0000003A   0xEBC7 0x00C7      RSB      R0,R7,R7, LSL #+3
   \   0000003E   0xEB06 0x0080      ADD      R0,R6,R0, LSL #+2
   \   00000042   0xE002             B.N      ??ParamIdQR_2
   1112          
   1113                  // Set the lower limit of subcolumn j to exclude lower zeros. m is the index of the last nonzero entry.
   1114                  while (( a[m][j] == 0 ) &&
   1115                         ( m > j ))
   1116                  {
   1117                      m--;
   \                     ??ParamIdQR_3: (+1)
   \   00000044   0x1E79             SUBS     R1,R7,#+1
   \   00000046   0xB2CF             UXTB     R7,R1
   \   00000048   0x381C             SUBS     R0,R0,#+28
   1118                  }
   \                     ??ParamIdQR_2: (+1)
   \   0000004A   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   0000004E   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000052   0xEEF1 0xFA10      FMSTAT   
   \   00000056   0xD101             BNE.N    ??ParamIdQR_4
   \   00000058   0x42BC             CMP      R4,R7
   \   0000005A   0xDBF3             BLT.N    ??ParamIdQR_3
   1119          
   1120                  // m = j + N_Theta; // This indicates the location of the last nonzero element of column A(:,j),
   1121                  // since the bottom half of A is diagonal (R_1 matrix)
   1122          
   1123          
   1124                  // The following block computes the householder vector v. The first component is stored in v0,
   1125                  // the remaining components are the subdiagonal elements of column j. In the comments that follow,
   1126                  // x denotes the subcolumn being zero'd. That is, x = A(j:m,j).
   1127          
   1128                  // sigma = x(2:m)'*x(2:m)
   1129                  // This is the norm squared of x(2:m)
   1130                  sigma = 0;
   1131                  for ( i = j + 1; i < m + 1; i++ )
   \                     ??ParamIdQR_4: (+1)
   \   0000005C   0xF104 0x0901      ADD      R9,R4,#+1
   \   00000060   0x1C78             ADDS     R0,R7,#+1
   \   00000062   0xED9F 0x....      VLDR.W   S18,??DataTable18  ;; 0x0
   \   00000066   0x464B             MOV      R3,R9
   \   00000068   0x9000             STR      R0,[SP, #+0]
   \   0000006A   0x4285             CMP      R5,R0
   \   0000006C   0xBFA8             IT       GE 
   \   0000006E   0xEEB0 0x0A68      VMOVGE.F32 S0,S17
   \   00000072   0xDA44             BGE.N    ??ParamIdQR_5
   \   00000074   0x1B00             SUBS     R0,R0,R4
   \   00000076   0x1E40             SUBS     R0,R0,#+1
   \   00000078   0xF010 0x0103      ANDS     R1,R0,#0x3
   \   0000007C   0xF000 0x800C      BEQ.W    ??ParamIdQR_6
   \                     ??ParamIdQR_7: (+1)
   \   00000080   0xEBC3 0x02C3      RSB      R2,R3,R3, LSL #+3
   \   00000084   0xEB06 0x0282      ADD      R2,R6,R2, LSL #+2
   1132                  {
   1133                      sigma += a[i][j] * a[i][j];
   \   00000088   0x1C5B             ADDS     R3,R3,#+1
   \   0000008A   0xED92 0x0A00      VLDR     S0,[R2, #0]
   \   0000008E   0xEE00 0x9A00      VMLA.F32 S18,S0,S0
   \   00000092   0xB2DB             UXTB     R3,R3
   \   00000094   0x1E49             SUBS     R1,R1,#+1
   \   00000096   0xD1F3             BNE.N    ??ParamIdQR_7
   \                     ??ParamIdQR_6: (+1)
   \   00000098   0x0880             LSRS     R0,R0,#+2
   \   0000009A   0xD029             BEQ.N    ??ParamIdQR_8
   \                     ??ParamIdQR_9: (+1)
   \   0000009C   0xEBC3 0x01C3      RSB      R1,R3,R3, LSL #+3
   \   000000A0   0xEB06 0x0181      ADD      R1,R6,R1, LSL #+2
   \   000000A4   0xED91 0x0A00      VLDR     S0,[R1, #0]
   \   000000A8   0x1C59             ADDS     R1,R3,#+1
   \   000000AA   0xB2C9             UXTB     R1,R1
   \   000000AC   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   000000B0   0xEB06 0x0282      ADD      R2,R6,R2, LSL #+2
   \   000000B4   0xEE00 0x9A00      VMLA.F32 S18,S0,S0
   \   000000B8   0x1C49             ADDS     R1,R1,#+1
   \   000000BA   0xED92 0x0A00      VLDR     S0,[R2, #0]
   \   000000BE   0xB2C9             UXTB     R1,R1
   \   000000C0   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   000000C4   0xEB06 0x0282      ADD      R2,R6,R2, LSL #+2
   \   000000C8   0xEE00 0x9A00      VMLA.F32 S18,S0,S0
   \   000000CC   0x1C49             ADDS     R1,R1,#+1
   \   000000CE   0xED92 0x0A00      VLDR     S0,[R2, #0]
   \   000000D2   0xB2C9             UXTB     R1,R1
   \   000000D4   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   000000D8   0xEB06 0x0282      ADD      R2,R6,R2, LSL #+2
   \   000000DC   0xEE00 0x9A00      VMLA.F32 S18,S0,S0
   \   000000E0   0xED92 0x0A00      VLDR     S0,[R2, #0]
   1134                  }
   \   000000E4   0x1C4B             ADDS     R3,R1,#+1
   \   000000E6   0xEE00 0x9A00      VMLA.F32 S18,S0,S0
   \   000000EA   0xB2DB             UXTB     R3,R3
   \   000000EC   0x1E40             SUBS     R0,R0,#+1
   \   000000EE   0xD1D5             BNE.N    ??ParamIdQR_9
   1135          
   1136                  v0 = 1;
   1137                  if (( sigma == 0 ) &&
   1138                      ( a[j][j] >= 0 ))
   \                     ??ParamIdQR_8: (+1)
   \   000000F0   0xEEB5 0x9A40      VCMP.F32 S18,#0.0
   \   000000F4   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   000000F8   0xEEF1 0xFA10      FMSTAT   
   \   000000FC   0xD10C             BNE.N    ??ParamIdQR_10
   \                     ??ParamIdQR_5: (+1)
   \   000000FE   0xEDD8 0x9A00      VLDR     S19,[R8, #0]
   \   00000102   0xEEF5 0x9A40      VCMP.F32 S19,#0.0
   \   00000106   0xEEF1 0xFA10      FMSTAT   
   \   0000010A   0xF280 0x8143      BGE.W    ??ParamIdQR_11
   1139                  {
   1140                      continue; // do nothing - the vector is already  zero'd
   1141                  }
   1142                  else if (( sigma == 0 ) &&
   1143                           ( a[j][j] < 0 ))  // Vector is zero'd, but x(1) is negative.
   1144                  {
   1145                      beta = -2;
   \   0000010E   0xEEF0 0x0A48      VMOV.F32 S1,S16
   1146                      mu = -a[j][j];
   \   00000112   0xEEB1 0x1A69      VNEG.F32 S2,S19
   \   00000116   0xE01C             B.N      ??ParamIdQR_12
   1147                  }
   1148                  else    // Most situations, where x is not zero'd yet.
   1149                  {
   1150                      // mu is the 2-norm of x. That is, mu = norm(x,2).
   1151                      mu = sqrtf(a[j][j]*a[j][j] + sigma);
   \                     ??ParamIdQR_10: (+1)
   \   00000118   0xEDD8 0x9A00      VLDR     S19,[R8, #0]
   \   0000011C   0xEEB0 0x0A49      VMOV.F32 S0,S18
   \   00000120   0xEE09 0x0AA9      VMLA.F32 S0,S19,S19
   \   00000124   0x.... 0x....      BL       sqrtf
   1152          
   1153                      // This computes v0, the first component in the householder vector.
   1154                      // The remaining components of v are just the 2nd-last components of x.
   1155                      if ( a[j][j] <= 0 )
   \   00000128   0xEEF5 0x9A40      VCMP.F32 S19,#0.0
   \   0000012C   0xEEB0 0x1A40      VMOV.F32 S2,S0
   \   00000130   0xEEF1 0xFA10      FMSTAT   
   \   00000134   0xBF91             ITEEE    LS 
   1156                      {
   1157                          v0 = a[j][j] - mu;
   \   00000136   0xEE39 0x0AC1      VSUBLS.F32 S0,S19,S2
   1158                      }
   1159                      else
   1160                      {
   1161                          v0 = -sigma / (a[j][j] + mu);
   \   0000013A   0xEE39 0x0A81      VADDHI.F32 S0,S19,S2
   \   0000013E   0xEE89 0x0A00      VDIVHI.F32 S0,S18,S0
   \   00000142   0xEEB1 0x0A40      VNEGHI.F32 S0,S0
   1162                      }
   1163          
   1164                      beta = 2.0f / (sigma + v0 * v0);
   \   00000146   0xEE00 0x9A00      VMLA.F32 S18,S0,S0
   \   0000014A   0xEEF0 0x0A00      VMOV.F32 S1,#2.0
   \   0000014E   0xEEC0 0x0A89      VDIV.F32 S1,S1,S18
   1165                  }
   1166          
   1167          
   1168                  // Now we apply the Householder matrix to the subcolumns of A to introduce zeros.
   1169                  // In the section that follows, the operations perform the multiplication H * A.
   1170                  // H is not stored, but is used in factored form H = I - beta*v*v'.
   1171                  // This block calculates H * A = (I - v*v') * A = A - (v * (v' * A(j:m,k)))
   1172                  // v is the vector [v0;A(j+1:m,j)].
   1173          
   1174                  a[j][j] = mu;   // This is the only nonzero element in subcolumn A(j:m,j).
   1175          
   1176                  for ( k = j + 1; k < N_Theta; k++ )     // loop over remaining subcolumns (right of column j)
   \                     ??ParamIdQR_12: (+1)
   \   00000152   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000156   0xED88 0x1A00      VSTR     S2,[R8, #0]
   \   0000015A   0xF890 0x2031      LDRB     R2,[R0, #+49]
   \   0000015E   0x4295             CMP      R5,R2
   \   00000160   0xF280 0x80E6      BGE.W    ??ParamIdQR_13
   \   00000164   0x9801             LDR      R0,[SP, #+4]
   \   00000166   0x9B06             LDR      R3,[SP, #+24]
   \   00000168   0xEB00 0x0089      ADD      R0,R0,R9, LSL #+2
   \   0000016C   0xEB03 0x0189      ADD      R1,R3,R9, LSL #+2
   \   00000170   0xEBA2 0x0209      SUB      R2,R2,R9
   1177                  {
   1178                      // Calculate the scalar quantity v' * A(j:m,k). mu is reused for storage of this quantity.
   1179                      mu = v0 * a[j][k];
   1180                      for ( i = j + 1; i < m + 1; i++ )
   \                     ??ParamIdQR_14: (+1)
   \   00000174   0xF8DD 0xC000      LDR      R12,[SP, #+0]
   \   00000178   0xEDD0 0x1A00      VLDR     S3,[R0, #0]
   \   0000017C   0xEE20 0x1A21      VMUL.F32 S2,S0,S3
   \   00000180   0x464B             MOV      R3,R9
   \   00000182   0x4565             CMP      R5,R12
   \   00000184   0xDA57             BGE.N    ??ParamIdQR_15
   \   00000186   0xF107 0x0C01      ADD      R12,R7,#+1
   \   0000018A   0xEBAC 0x0C04      SUB      R12,R12,R4
   \   0000018E   0xF1AC 0x0C01      SUB      R12,R12,#+1
   \   00000192   0xF01C 0x0E03      ANDS     LR,R12,#0x3
   \   00000196   0xD010             BEQ.N    ??ParamIdQR_16
   1181                      {
   1182                          mu += a[i][j] * a[i][k];    // The elements of v are a[i][j]
   \                     ??ParamIdQR_17: (+1)
   \   00000198   0xEBC3 0x0AC3      RSB      R10,R3,R3, LSL #+3
   \   0000019C   0xEB06 0x0B8A      ADD      R11,R6,R10, LSL #+2
   \   000001A0   0xEB01 0x0A8A      ADD      R10,R1,R10, LSL #+2
   \   000001A4   0xED9B 0x2A00      VLDR     S4,[R11, #0]
   \   000001A8   0xEDDA 0x2A00      VLDR     S5,[R10, #0]
   \   000001AC   0x1C5B             ADDS     R3,R3,#+1
   \   000001AE   0xEE02 0x1A22      VMLA.F32 S2,S4,S5
   \   000001B2   0xB2DB             UXTB     R3,R3
   \   000001B4   0xF1BE 0x0E01      SUBS     LR,LR,#+1
   \   000001B8   0xD1EE             BNE.N    ??ParamIdQR_17
   \                     ??ParamIdQR_16: (+1)
   \   000001BA   0xEA5F 0x0C9C      LSRS     R12,R12,#+2
   \   000001BE   0xD03A             BEQ.N    ??ParamIdQR_15
   \                     ??ParamIdQR_18: (+1)
   \   000001C0   0xEBC3 0x0EC3      RSB      LR,R3,R3, LSL #+3
   \   000001C4   0xEB06 0x0A8E      ADD      R10,R6,LR, LSL #+2
   \   000001C8   0xEB01 0x0E8E      ADD      LR,R1,LR, LSL #+2
   \   000001CC   0x1C5B             ADDS     R3,R3,#+1
   \   000001CE   0xEDDE 0x2A00      VLDR     S5,[LR, #0]
   \   000001D2   0xED9A 0x2A00      VLDR     S4,[R10, #0]
   \   000001D6   0xB2DB             UXTB     R3,R3
   \   000001D8   0xEBC3 0x0EC3      RSB      LR,R3,R3, LSL #+3
   \   000001DC   0xEB06 0x0A8E      ADD      R10,R6,LR, LSL #+2
   \   000001E0   0xEB01 0x0E8E      ADD      LR,R1,LR, LSL #+2
   \   000001E4   0xEE02 0x1A22      VMLA.F32 S2,S4,S5
   \   000001E8   0x1C5B             ADDS     R3,R3,#+1
   \   000001EA   0xEDDE 0x2A00      VLDR     S5,[LR, #0]
   \   000001EE   0xED9A 0x2A00      VLDR     S4,[R10, #0]
   \   000001F2   0xB2DB             UXTB     R3,R3
   \   000001F4   0xEBC3 0x0EC3      RSB      LR,R3,R3, LSL #+3
   \   000001F8   0xEB06 0x0A8E      ADD      R10,R6,LR, LSL #+2
   \   000001FC   0xEB01 0x0E8E      ADD      LR,R1,LR, LSL #+2
   \   00000200   0xEE02 0x1A22      VMLA.F32 S2,S4,S5
   \   00000204   0x1C5B             ADDS     R3,R3,#+1
   \   00000206   0xEDDE 0x2A00      VLDR     S5,[LR, #0]
   \   0000020A   0xED9A 0x2A00      VLDR     S4,[R10, #0]
   \   0000020E   0xB2DB             UXTB     R3,R3
   \   00000210   0xEBC3 0x0EC3      RSB      LR,R3,R3, LSL #+3
   \   00000214   0xEB06 0x0A8E      ADD      R10,R6,LR, LSL #+2
   \   00000218   0xEB01 0x0E8E      ADD      LR,R1,LR, LSL #+2
   \   0000021C   0xEE02 0x1A22      VMLA.F32 S2,S4,S5
   \   00000220   0xED9A 0x2A00      VLDR     S4,[R10, #0]
   \   00000224   0xEDDE 0x2A00      VLDR     S5,[LR, #0]
   1183                      }
   \   00000228   0x1C5B             ADDS     R3,R3,#+1
   \   0000022A   0xEE02 0x1A22      VMLA.F32 S2,S4,S5
   \   0000022E   0xB2DB             UXTB     R3,R3
   \   00000230   0xF1BC 0x0C01      SUBS     R12,R12,#+1
   \   00000234   0xD1C4             BNE.N    ??ParamIdQR_18
   1184          
   1185                      // Now complete the computation by taking beta * v * (v' * A(j:m,k))
   1186                      // and subtracting this vector from A(j:m,k).
   1187                      a[j][k] -= beta * mu * v0;
   \                     ??ParamIdQR_15: (+1)
   \   00000236   0xEE20 0x1A81      VMUL.F32 S2,S1,S2
   \   0000023A   0xEE41 0x1A40      VMLS.F32 S3,S2,S0
   \   0000023E   0xEDC0 0x1A00      VSTR     S3,[R0, #0]
   1188                      for ( i = j + 1; i < m + 1; i++ )
   \   00000242   0x464B             MOV      R3,R9
   \   00000244   0xF8DD 0xC000      LDR      R12,[SP, #+0]
   \   00000248   0x4565             CMP      R5,R12
   \   0000024A   0xDA6C             BGE.N    ??ParamIdQR_19
   \   0000024C   0xF107 0x0C01      ADD      R12,R7,#+1
   \   00000250   0xEBAC 0x0C04      SUB      R12,R12,R4
   \   00000254   0xF1AC 0x0C01      SUB      R12,R12,#+1
   \   00000258   0xF01C 0x0E03      ANDS     LR,R12,#0x3
   \   0000025C   0xF000 0x8015      BEQ.W    ??ParamIdQR_20
   1189                      {
   1190                          a[i][k] -= beta * mu * a[i][j]; // The elements of v are a[i][j]
   \                     ??ParamIdQR_21: (+1)
   \   00000260   0xEBC3 0x0AC3      RSB      R10,R3,R3, LSL #+3
   \   00000264   0xEB06 0x0B8A      ADD      R11,R6,R10, LSL #+2
   \   00000268   0x1C5B             ADDS     R3,R3,#+1
   \   0000026A   0xEDDB 0x1A00      VLDR     S3,[R11, #0]
   \   0000026E   0xEB01 0x0B8A      ADD      R11,R1,R10, LSL #+2
   \   00000272   0xEB01 0x0A8A      ADD      R10,R1,R10, LSL #+2
   \   00000276   0xED9B 0x2A00      VLDR     S4,[R11, #0]
   \   0000027A   0xEE01 0x2A61      VMLS.F32 S4,S2,S3
   \   0000027E   0xED8A 0x2A00      VSTR     S4,[R10, #0]
   \   00000282   0xB2DB             UXTB     R3,R3
   \   00000284   0xF1BE 0x0E01      SUBS     LR,LR,#+1
   \   00000288   0xD1EA             BNE.N    ??ParamIdQR_21
   \                     ??ParamIdQR_20: (+1)
   \   0000028A   0xEA5F 0x0C9C      LSRS     R12,R12,#+2
   \   0000028E   0xD04A             BEQ.N    ??ParamIdQR_19
   \                     ??ParamIdQR_22: (+1)
   \   00000290   0xEBC3 0x0EC3      RSB      LR,R3,R3, LSL #+3
   \   00000294   0xEB06 0x0A8E      ADD      R10,R6,LR, LSL #+2
   \   00000298   0x1C5B             ADDS     R3,R3,#+1
   \   0000029A   0xEDDA 0x1A00      VLDR     S3,[R10, #0]
   \   0000029E   0xEB01 0x0A8E      ADD      R10,R1,LR, LSL #+2
   \   000002A2   0xEB01 0x0E8E      ADD      LR,R1,LR, LSL #+2
   \   000002A6   0xED9A 0x2A00      VLDR     S4,[R10, #0]
   \   000002AA   0xEE01 0x2A61      VMLS.F32 S4,S2,S3
   \   000002AE   0xED8E 0x2A00      VSTR     S4,[LR, #0]
   \   000002B2   0xB2DB             UXTB     R3,R3
   \   000002B4   0xEBC3 0x0EC3      RSB      LR,R3,R3, LSL #+3
   \   000002B8   0xEB06 0x0A8E      ADD      R10,R6,LR, LSL #+2
   \   000002BC   0x1C5B             ADDS     R3,R3,#+1
   \   000002BE   0xEDDA 0x1A00      VLDR     S3,[R10, #0]
   \   000002C2   0xEB01 0x0A8E      ADD      R10,R1,LR, LSL #+2
   \   000002C6   0xEB01 0x0E8E      ADD      LR,R1,LR, LSL #+2
   \   000002CA   0xED9A 0x2A00      VLDR     S4,[R10, #0]
   \   000002CE   0xEE01 0x2A61      VMLS.F32 S4,S2,S3
   \   000002D2   0xED8E 0x2A00      VSTR     S4,[LR, #0]
   \   000002D6   0xB2DB             UXTB     R3,R3
   \   000002D8   0xEBC3 0x0EC3      RSB      LR,R3,R3, LSL #+3
   \   000002DC   0xEB06 0x0A8E      ADD      R10,R6,LR, LSL #+2
   \   000002E0   0x1C5B             ADDS     R3,R3,#+1
   \   000002E2   0xEDDA 0x1A00      VLDR     S3,[R10, #0]
   \   000002E6   0xEB01 0x0A8E      ADD      R10,R1,LR, LSL #+2
   \   000002EA   0xEB01 0x0E8E      ADD      LR,R1,LR, LSL #+2
   \   000002EE   0xED9A 0x2A00      VLDR     S4,[R10, #0]
   \   000002F2   0xEE01 0x2A61      VMLS.F32 S4,S2,S3
   \   000002F6   0xED8E 0x2A00      VSTR     S4,[LR, #0]
   \   000002FA   0xB2DB             UXTB     R3,R3
   \   000002FC   0xEBC3 0x0EC3      RSB      LR,R3,R3, LSL #+3
   \   00000300   0xEB06 0x0A8E      ADD      R10,R6,LR, LSL #+2
   1191                      }
   \   00000304   0x1C5B             ADDS     R3,R3,#+1
   \   00000306   0xEDDA 0x1A00      VLDR     S3,[R10, #0]
   \   0000030A   0xEB01 0x0A8E      ADD      R10,R1,LR, LSL #+2
   \   0000030E   0xEB01 0x0E8E      ADD      LR,R1,LR, LSL #+2
   \   00000312   0xED9A 0x2A00      VLDR     S4,[R10, #0]
   \   00000316   0xEE01 0x2A61      VMLS.F32 S4,S2,S3
   \   0000031A   0xED8E 0x2A00      VSTR     S4,[LR, #0]
   \   0000031E   0xB2DB             UXTB     R3,R3
   \   00000320   0xF1BC 0x0C01      SUBS     R12,R12,#+1
   \   00000324   0xD1B4             BNE.N    ??ParamIdQR_22
   1192                  }
   \                     ??ParamIdQR_19: (+1)
   \   00000326   0x1D09             ADDS     R1,R1,#+4
   \   00000328   0x1D00             ADDS     R0,R0,#+4
   \   0000032A   0x1E52             SUBS     R2,R2,#+1
   \   0000032C   0xF47F 0xAF22      BNE.W    ??ParamIdQR_14
   1193          
   1194                  // Set subdiagonal entries of column j to zero
   1195                  for ( i = j + 1; i < m + 1; i++ )
   \                     ??ParamIdQR_13: (+1)
   \   00000330   0x9800             LDR      R0,[SP, #+0]
   \   00000332   0x464B             MOV      R3,R9
   \   00000334   0x4285             CMP      R5,R0
   \   00000336   0xDA2D             BGE.N    ??ParamIdQR_11
   \   00000338   0x1C78             ADDS     R0,R7,#+1
   \   0000033A   0x1B00             SUBS     R0,R0,R4
   \   0000033C   0x1E40             SUBS     R0,R0,#+1
   \   0000033E   0xF010 0x0103      ANDS     R1,R0,#0x3
   \   00000342   0xD008             BEQ.N    ??ParamIdQR_23
   1196                  {
   1197                      a[i][j] = 0;
   \                     ??ParamIdQR_24: (+1)
   \   00000344   0xEBC3 0x02C3      RSB      R2,R3,R3, LSL #+3
   \   00000348   0x0092             LSLS     R2,R2,#+2
   \   0000034A   0x2400             MOVS     R4,#+0
   \   0000034C   0x5194             STR      R4,[R2, R6]
   \   0000034E   0x1C5B             ADDS     R3,R3,#+1
   \   00000350   0xB2DB             UXTB     R3,R3
   \   00000352   0x1E49             SUBS     R1,R1,#+1
   \   00000354   0xD1F6             BNE.N    ??ParamIdQR_24
   \                     ??ParamIdQR_23: (+1)
   \   00000356   0x0880             LSRS     R0,R0,#+2
   \   00000358   0xF000 0x801C      BEQ.W    ??ParamIdQR_11
   \                     ??ParamIdQR_25: (+1)
   \   0000035C   0xEBC3 0x01C3      RSB      R1,R3,R3, LSL #+3
   \   00000360   0x0089             LSLS     R1,R1,#+2
   \   00000362   0x2200             MOVS     R2,#+0
   \   00000364   0x518A             STR      R2,[R1, R6]
   \   00000366   0x1C59             ADDS     R1,R3,#+1
   \   00000368   0xB2C9             UXTB     R1,R1
   \   0000036A   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   0000036E   0x0092             LSLS     R2,R2,#+2
   \   00000370   0x2300             MOVS     R3,#+0
   \   00000372   0x5193             STR      R3,[R2, R6]
   \   00000374   0x1C49             ADDS     R1,R1,#+1
   \   00000376   0xB2C9             UXTB     R1,R1
   \   00000378   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   0000037C   0x0092             LSLS     R2,R2,#+2
   \   0000037E   0x1C49             ADDS     R1,R1,#+1
   \   00000380   0x5193             STR      R3,[R2, R6]
   \   00000382   0xB2C9             UXTB     R1,R1
   \   00000384   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   00000388   0x0092             LSLS     R2,R2,#+2
   \   0000038A   0x5193             STR      R3,[R2, R6]
   1198                  }
   \   0000038C   0x1C4B             ADDS     R3,R1,#+1
   \   0000038E   0xB2DB             UXTB     R3,R3
   \   00000390   0x1E40             SUBS     R0,R0,#+1
   \   00000392   0xD1E3             BNE.N    ??ParamIdQR_25
   1199              }
   \                     ??ParamIdQR_11: (+1)
   \   00000394   0x9801             LDR      R0,[SP, #+4]
   \   00000396   0x301C             ADDS     R0,R0,#+28
   \   00000398   0x9001             STR      R0,[SP, #+4]
   \   0000039A   0x464C             MOV      R4,R9
   \   0000039C   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000003A0   0xF890 0x0031      LDRB     R0,[R0, #+49]
   \   000003A4   0x1D36             ADDS     R6,R6,#+4
   \   000003A6   0x1C6D             ADDS     R5,R5,#+1
   \   000003A8   0xF108 0x0820      ADD      R8,R8,#+32
   \   000003AC   0x4284             CMP      R4,R0
   \   000003AE   0xF6FF 0xAE3D      BLT.W    ??ParamIdQR_1
   1200          }
   \                     ??ParamIdQR_0: (+1)
   \   000003B2   0xB002             ADD      SP,SP,#+8
   \   000003B4   0xECBD 0x8B04      VPOP     {D8-D9}
   \   000003B8   0xB001             ADD      SP,SP,#+4
   \   000003BA   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1201          
   1202          //---------------------------------------------------------------------------------------------------------------------
   1203          /**
   1204           * @brief Reset Filter States (storage) to zero
   1205           */
   1206          //#pragma optimize=size no_inline no_unroll
   1207          static void ResetFilter()
   1208          {
   1209          	for (int i = 0; i <= N_THETA_MAX; i++)
   1210          	{
   1211          		DigitalFilter__ResetSOS(Filter_Storage[i], PARAM_EST_FILTER_MAX_NUM_SECTIONS);
   1212          	}
   1213          }
   1214          
   1215          //---------------------------------------------------------------------------------------------------------------------
   1216          /**
   1217           * @brief Reset Theta (parameter vector) to zero
   1218           */
   1219          //#pragma optimize=size no_inline no_unroll
   1220          static void ResetTheta(void)
   1221          {
   1222              REGRESSOR_ELEMENTS_TYPE i;
   1223          
   1224              for ( i = (REGRESSOR_ELEMENTS_TYPE)0; i < N_THETA_MAX; i++ )
   1225              {
   1226                  Theta[i] = 0.0f;
   1227              }
   1228          }
   1229          
   1230          //---------------------------------------------------------------------------------------------------------------------
   1231          /**
   1232           *	@brief	Set the setting file error flag
   1233           */
   1234          static void SetSettingFileError()
   1235          {
   1236          	Sf_Parameters_Fault = TRUE;
   1237          }
   1238          
   1239          //---------------------------------------------------------------------------------------------------------------------
   1240          /**
   1241           *	@brief	Clear the setting file error flag
   1242           */
   1243          static void ClearSettingFileError()
   1244          {
   1245          	Sf_Parameters_Fault = FALSE;
   1246          }
   1247          
   1248          //---------------------------------------------------------------------------------------------------------------------
   1249          /**
   1250           * @brief Retrieve the filter configuration structure pointer from GESE
   1251           *
   1252           * @return  Pointer to the filter configuration structure.
   1253           */
   1254          static DIGITAL_FILTER_SOS_TYPE GetFilterConfig(unsigned char index)
   1255          {
   1256          	DIGITAL_FILTER_SOS_TYPE pe_filter;
   1257          
   1258          #ifndef MATLAB_MEX_FILE
   1259          	SETTINGFILE_LOADER_TYPE loaded_data;
   1260          	PARAMETER_ESTIMATION_FILTER_TYPE *PE_filter_ptr;
   1261          
   1262          	pe_filter.Num_Sections = 0;
   1263          	pe_filter.Coeffs = NULL;
   1264          
   1265          	if (index != FILTER_DISABLED)
   1266          	{
   1267          		if (SettingFile__BasicLoader(SF_PTR_MCU_PARAMETER_ESTIMATION, index, &loaded_data) == PASS)
   1268          		{
   1269          			ClearSettingFileError();
   1270          
   1271          			PE_filter_ptr = (PARAMETER_ESTIMATION_FILTER_TYPE *)loaded_data.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
   1272          
   1273          			pe_filter.Num_Sections = PE_filter_ptr->Byte_0.Bit.Section_Number;
   1274          			pe_filter.Coeffs = (DIGITAL_FILTER_BIQUAD_COEFF_TYPE *)&(PE_filter_ptr->First_Filter_Coeff);	//lint !e929 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
   1275          		}
   1276          		else
   1277          		{
   1278          #if (PARAM_EST_HARD_CODED_PARAMETERS != 0)
   1279          			if (index < NUM_FILTERS)
   1280          			{
   1281          				pe_filter = Param_Est_Filter_Bank[index];
   1282          			}
   1283          			else
   1284          #endif // ((PARAM_EST_HARD_CODED_PARAMETERS != 0)
   1285          				SetSettingFileError();
   1286          		}
   1287          	}
   1288          	else
   1289          	{
   1290          		ClearSettingFileError();
   1291          	}
   1292          #else
   1293          #if (PARAM_EST_HARD_CODED_PARAMETERS != 0)
   1294          			if (index < NUM_FILTERS)
   1295          			{
   1296          				pe_filter = Param_Est_Filter_Bank[index];
   1297          			}
   1298          #endif // ((PARAM_EST_HARD_CODED_PARAMETERS != 0)
   1299          #endif // ifndef MATLAB_MEX_FILE
   1300          
   1301          	return pe_filter;
   1302          }
   1303          
   1304          //---------------------------------------------------------------------------------------------------------------------
   1305          /**
   1306           * @brief Get the regressor inputs based on the Environment defined Model.
   1307           *
   1308           * @return  The regressor Y and Phi values.
   1309           */
   1310          //#pragma optimize=size no_inline no_unroll

   \                                 In section .text, align 4, keep-with-next
   1311          static REGRESSOR_FORM_TYPE GetRegressorInputs(void)
   1312          {
   \                     GetRegressorInputs: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xED2D 0x8B02      VPUSH    {D8}
   \   00000008   0xB088             SUB      SP,SP,#+32
   \   0000000A   0x4604             MOV      R4,R0
   1313              REGRESSOR_FORM_TYPE  regressor;
   1314              regressor.Y = 0.0f;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9007             STR      R0,[SP, #+28]
   1315              // write all elements in the arrays to remove PC Lint warnings
   1316              for ( REGRESSOR_ELEMENTS_TYPE element = (REGRESSOR_ELEMENTS_TYPE)0; element < N_THETA_MAX; element++ )
   1317              {
   1318                  regressor.Phi[element] = 0.0f;
   \   00000010   0x9000             STR      R0,[SP, #+0]
   \   00000012   0x9001             STR      R0,[SP, #+4]
   \   00000014   0x9002             STR      R0,[SP, #+8]
   \   00000016   0x9003             STR      R0,[SP, #+12]
   \   00000018   0x9004             STR      R0,[SP, #+16]
   \   0000001A   0x9005             STR      R0,[SP, #+20]
   \   0000001C   0x9006             STR      R0,[SP, #+24]
   1319              }
   1320          
   1321              // Set up the regressor and the output for the model realization chosen.
   1322              switch ( Setup_Parameters->Model_Config.Struct.Model )
   \   0000001E   0x.... 0x....      LDR.W    R5,??DataTable19
   \   00000022   0xF8D5 0x01D0      LDR      R0,[R5, #+464]
   \   00000026   0x7F00             LDRB     R0,[R0, #+28]
   \   00000028   0x0900             LSRS     R0,R0,#+4
   \   0000002A   0x2803             CMP      R0,#+3
   \   0000002C   0xF200 0x81F6      BHI.W    ??GetRegressorInputs_1
   \   00000030   0xE8DF 0xF010      TBH      [PC, R0, LSL #+1]
   \                     ??GetRegressorInputs_0:
   \   00000034   0x0004 0x0057      DC16     0x4,0x57,0xB5,0x125
   \              0x00B5 0x0125
   1323              {
   1324          #if MODEL_BK_EULER_B0 == ENABLED
   1325                  case PARAM_EST_MODEL_BK_EULER_B0:
   1326                      regressor.Phi[Phi_Idx[REG_ELE_TORQUE]] = INPUT_DRUM_TORQUE_NM();
   \                     ??GetRegressorInputs_2: (+1)
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      BL       BandLimiter__GetSignal
   \   00000044   0xF895 0x1025      LDRB     R1,[R5, #+37]
   1327                      regressor.Phi[Phi_Idx[REG_ELE_CONSTANT]] = -1.0f;                                      // constant
   \   00000048   0x.... 0x....      LDR.W    R2,??DataTable19_6  ;; 0xbf800000
   \   0000004C   0xA800             ADD      R0,SP,#+0
   \   0000004E   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000052   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   00000056   0xA800             ADD      R0,SP,#+0
   \   00000058   0xF895 0x1026      LDRB     R1,[R5, #+38]
   \   0000005C   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
   1328                      regressor.Phi[Phi_Idx[REG_ELE_SIN_ANGLE]] = -INPUT_SIN_DRUM_POS();     // sin(alpha) (Rad)
   \   00000060   0x2102             MOVS     R1,#+2
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x.... 0x....      BL       BandLimiter__GetSignal
   \   00000068   0xF895 0x1027      LDRB     R1,[R5, #+39]
   \   0000006C   0xA800             ADD      R0,SP,#+0
   \   0000006E   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000072   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   00000076   0xED80 0x0A00      VSTR     S0,[R0, #0]
   1329                      regressor.Phi[Phi_Idx[REG_ELE_COS_ANGLE]] = -INPUT_COS_DRUM_POS();     // cos(alpha) (Rad)
   \   0000007A   0x2103             MOVS     R1,#+3
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x.... 0x....      BL       BandLimiter__GetSignal
   \   00000082   0xF895 0x1028      LDRB     R1,[R5, #+40]
   \   00000086   0xA800             ADD      R0,SP,#+0
   \   00000088   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   0000008C   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   00000090   0xED80 0x0A00      VSTR     S0,[R0, #0]
   1330          
   1331                      // Append speed to phi only for filtering (not part of the actual regressor). The last element of phi is simply holding current speed.
   1332                      regressor.Phi[N_Theta] = INPUT_DRUM_SPEED_RAD_S();           // Speed (Rad/s)
   \   00000094   0x2101             MOVS     R1,#+1
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x.... 0x....      BL       BandLimiter__GetSignal
   \   0000009C   0xF895 0x0031      LDRB     R0,[R5, #+49]
   \   000000A0   0xA900             ADD      R1,SP,#+0
   \   000000A2   0xEB01 0x0180      ADD      R1,R1,R0, LSL #+2
   \   000000A6   0xED81 0x0A00      VSTR     S0,[R1, #0]
   1333          
   1334                      if ( Setup_Parameters->Filter_Configuration_Index != FILTER_DISABLED )
   \   000000AA   0xF8D5 0x11D0      LDR      R1,[R5, #+464]
   \   000000AE   0x7F49             LDRB     R1,[R1, #+29]
   \   000000B0   0x29FF             CMP      R1,#+255
   \   000000B2   0xBF1E             ITTT     NE 
   1335                      {
   1336                          DFiltNChan(regressor.Phi, N_Theta + 1);     // Filter the output and regressor (N_Theta + 1 because of appended speed)
   \   000000B4   0x1C46             ADDNE    R6,R0,#+1
   \   000000B6   0xB2F6             UXTBNE   R6,R6
   \   000000B8   0x2E00             CMPNE    R6,#+0
   \   000000BA   0xF000 0x8199      BEQ.W    ??GetRegressorInputs_3
   \   000000BE   0xAF00             ADD      R7,SP,#+0
   \   000000C0   0xF505 0x78EA      ADD      R8,R5,#+468
   \                     ??GetRegressorInputs_4: (+1)
   \   000000C4   0xE9D5 0x0100      LDRD     R0,R1,[R5, #+0]
   \   000000C8   0x4642             MOV      R2,R8
   \   000000CA   0xED97 0x0A00      VLDR     S0,[R7, #0]
   \   000000CE   0x.... 0x....      BL       DigitalFilter__DF2TSOS
   \   000000D2   0xED87 0x0A00      VSTR     S0,[R7, #0]
   \   000000D6   0x1D3F             ADDS     R7,R7,#+4
   \   000000D8   0xF108 0x0818      ADD      R8,R8,#+24
   \   000000DC   0x1E76             SUBS     R6,R6,#+1
   \   000000DE   0xD1F1             BNE.N    ??GetRegressorInputs_4
   \   000000E0   0xE186             B.N      ??GetRegressorInputs_3
   1337                      }
   1338          
   1339                      // y is acceleration (backward difference rule).
   1340                      regressor.Y = (regressor.Phi[N_Theta] - Speed_Previous) / TS_PARAMID;
   1341          
   1342                      Speed_Previous = regressor.Phi[N_Theta];
   1343                      break;
   1344          #endif
   1345          #if MODEL_BK_EULER == ENABLED
   1346                  case PARAM_EST_MODEL_BK_EULER:
   1347                      regressor.Phi[Phi_Idx[REG_ELE_SPEED]] = INPUT_DRUM_SPEED_RAD_S();              // Speed (Rad/s)
   \                     ??GetRegressorInputs_5: (+1)
   \   000000E2   0x2101             MOVS     R1,#+1
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0x.... 0x....      BL       BandLimiter__GetSignal
   \   000000EA   0xF895 0x1024      LDRB     R1,[R5, #+36]
   \   000000EE   0xA800             ADD      R0,SP,#+0
   \   000000F0   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   1348                      regressor.Phi[Phi_Idx[REG_ELE_TORQUE]] = INPUT_DRUM_TORQUE_NM();
   \   000000F4   0x2100             MOVS     R1,#+0
   \   000000F6   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0x.... 0x....      BL       BandLimiter__GetSignal
   \   00000100   0xF895 0x1025      LDRB     R1,[R5, #+37]
   1349                      regressor.Phi[Phi_Idx[REG_ELE_CONSTANT]] = -1.0f;                                      // constant
   \   00000104   0x....             LDR.N    R2,??DataTable19_6  ;; 0xbf800000
   \   00000106   0xA800             ADD      R0,SP,#+0
   \   00000108   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   0000010C   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   00000110   0xA800             ADD      R0,SP,#+0
   \   00000112   0xF895 0x1026      LDRB     R1,[R5, #+38]
   \   00000116   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
   1350                      regressor.Phi[Phi_Idx[REG_ELE_SIN_ANGLE]] = -INPUT_SIN_DRUM_POS();     // sin(alpha) (Rad)
   \   0000011A   0x2102             MOVS     R1,#+2
   \   0000011C   0x2000             MOVS     R0,#+0
   \   0000011E   0x.... 0x....      BL       BandLimiter__GetSignal
   \   00000122   0xF895 0x1027      LDRB     R1,[R5, #+39]
   \   00000126   0xA800             ADD      R0,SP,#+0
   \   00000128   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   0000012C   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   00000130   0xED80 0x0A00      VSTR     S0,[R0, #0]
   1351                      regressor.Phi[Phi_Idx[REG_ELE_COS_ANGLE]] = -INPUT_COS_DRUM_POS();     // cos(alpha) (Rad)
   \   00000134   0x2103             MOVS     R1,#+3
   \   00000136   0x2000             MOVS     R0,#+0
   \   00000138   0x.... 0x....      BL       BandLimiter__GetSignal
   \   0000013C   0xF895 0x1028      LDRB     R1,[R5, #+40]
   \   00000140   0xA800             ADD      R0,SP,#+0
   \   00000142   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000146   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   0000014A   0xED80 0x0A00      VSTR     S0,[R0, #0]
   1352          
   1353                      if ( Setup_Parameters->Filter_Configuration_Index != FILTER_DISABLED )
   \   0000014E   0xF8D5 0x01D0      LDR      R0,[R5, #+464]
   \   00000152   0x7F40             LDRB     R0,[R0, #+29]
   \   00000154   0x28FF             CMP      R0,#+255
   \   00000156   0xBF1C             ITT      NE 
   1354                      {
   1355                          DFiltNChan(regressor.Phi, N_Theta);     // Filter the regressor
   \   00000158   0xF895 0x6031      LDRBNE   R6,[R5, #+49]
   \   0000015C   0x2E00             CMPNE    R6,#+0
   \   0000015E   0xD011             BEQ.N    ??GetRegressorInputs_6
   \   00000160   0xF10D 0x0700      ADD.W    R7,SP,#+0
   \   00000164   0xF505 0x78EA      ADD      R8,R5,#+468
   \                     ??GetRegressorInputs_7: (+1)
   \   00000168   0xE9D5 0x0100      LDRD     R0,R1,[R5, #+0]
   \   0000016C   0x4642             MOV      R2,R8
   \   0000016E   0xED97 0x0A00      VLDR     S0,[R7, #0]
   \   00000172   0x.... 0x....      BL       DigitalFilter__DF2TSOS
   \   00000176   0xED87 0x0A00      VSTR     S0,[R7, #0]
   \   0000017A   0x1D3F             ADDS     R7,R7,#+4
   \   0000017C   0xF108 0x0818      ADD      R8,R8,#+24
   \   00000180   0x1E76             SUBS     R6,R6,#+1
   \   00000182   0xD1F1             BNE.N    ??GetRegressorInputs_7
   \                     ??GetRegressorInputs_6: (+1)
   \   00000184   0xF895 0x0024      LDRB     R0,[R5, #+36]
   1356                      }
   1357          
   1358                      // Y is current speed, and comes from regressor, so is already filtered
   1359                      regressor.Y = regressor.Phi[Phi_Idx[REG_ELE_SPEED]];        // Form the output (current speed)
   1360                      regressor.Phi[Phi_Idx[REG_ELE_SPEED]] = Speed_Previous;     // Actual speed element in regressor is previous speed
   \   00000188   0xF8D5 0x21C0      LDR      R2,[R5, #+448]
   \   0000018C   0xA900             ADD      R1,SP,#+0
   \   0000018E   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000192   0x9107             STR      R1,[SP, #+28]
   \   00000194   0xA900             ADD      R1,SP,#+0
   \   00000196   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   1361          
   1362                      Speed_Previous = regressor.Y;
   \   0000019A   0x9807             LDR      R0,[SP, #+28]
   \   0000019C   0xE13C             B.N      ??GetRegressorInputs_8
   1363                      break;
   1364          #endif
   1365          #if MODEL_HYB_ACCEL == ENABLED
   1366                  case PARAM_EST_MODEL_HYB_ACCEL:
   1367                      regressor.Phi[Phi_Idx[REG_ELE_SPEED]] = -INPUT_DRUM_SPEED_RAD_S();             // Speed (Rad/s)
   \                     ??GetRegressorInputs_9: (+1)
   \   0000019E   0x2101             MOVS     R1,#+1
   \   000001A0   0x2000             MOVS     R0,#+0
   \   000001A2   0x.... 0x....      BL       BandLimiter__GetSignal
   \   000001A6   0xF895 0x1024      LDRB     R1,[R5, #+36]
   \   000001AA   0xA800             ADD      R0,SP,#+0
   \   000001AC   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   000001B0   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   000001B4   0xED80 0x0A00      VSTR     S0,[R0, #0]
   1368                      regressor.Phi[Phi_Idx[REG_ELE_TORQUE]] = INPUT_DRUM_TORQUE_NM();
   \   000001B8   0x2100             MOVS     R1,#+0
   \   000001BA   0x2000             MOVS     R0,#+0
   \   000001BC   0x.... 0x....      BL       BandLimiter__GetSignal
   \   000001C0   0xF895 0x1025      LDRB     R1,[R5, #+37]
   1369                      regressor.Phi[Phi_Idx[REG_ELE_CONSTANT]] = -1.0f;                                        // constant
   \   000001C4   0x....             LDR.N    R2,??DataTable19_6  ;; 0xbf800000
   \   000001C6   0xA800             ADD      R0,SP,#+0
   \   000001C8   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   000001CC   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   000001D0   0xA800             ADD      R0,SP,#+0
   \   000001D2   0xF895 0x1026      LDRB     R1,[R5, #+38]
   \   000001D6   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
   1370                      regressor.Phi[Phi_Idx[REG_ELE_SIN_ANGLE]] = -INPUT_SIN_DRUM_POS();     // sin(alpha) (Rad)
   \   000001DA   0x2102             MOVS     R1,#+2
   \   000001DC   0x2000             MOVS     R0,#+0
   \   000001DE   0x.... 0x....      BL       BandLimiter__GetSignal
   \   000001E2   0xF895 0x1027      LDRB     R1,[R5, #+39]
   \   000001E6   0xA800             ADD      R0,SP,#+0
   \   000001E8   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   000001EC   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   000001F0   0xED80 0x0A00      VSTR     S0,[R0, #0]
   1371                      regressor.Phi[Phi_Idx[REG_ELE_COS_ANGLE]] = -INPUT_COS_DRUM_POS();     // cos(alpha) (Rad)
   \   000001F4   0x2103             MOVS     R1,#+3
   \   000001F6   0x2000             MOVS     R0,#+0
   \   000001F8   0x.... 0x....      BL       BandLimiter__GetSignal
   \   000001FC   0xF895 0x1028      LDRB     R1,[R5, #+40]
   \   00000200   0xA800             ADD      R0,SP,#+0
   \   00000202   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000206   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   0000020A   0xED80 0x0A00      VSTR     S0,[R0, #0]
   1372          
   1373                      if ( Setup_Parameters->Filter_Configuration_Index != FILTER_DISABLED )
   \   0000020E   0xF8D5 0x01D0      LDR      R0,[R5, #+464]
   \   00000212   0x7F40             LDRB     R0,[R0, #+29]
   \   00000214   0x28FF             CMP      R0,#+255
   \   00000216   0xBF1C             ITT      NE 
   1374                      {
   1375                          DFiltNChan(regressor.Phi, N_Theta);     // Filter the regressor
   \   00000218   0xF895 0x6031      LDRBNE   R6,[R5, #+49]
   \   0000021C   0x2E00             CMPNE    R6,#+0
   \   0000021E   0xD011             BEQ.N    ??GetRegressorInputs_10
   \   00000220   0xF10D 0x0700      ADD.W    R7,SP,#+0
   \   00000224   0xF505 0x78EA      ADD      R8,R5,#+468
   \                     ??GetRegressorInputs_11: (+1)
   \   00000228   0xE9D5 0x0100      LDRD     R0,R1,[R5, #+0]
   \   0000022C   0x4642             MOV      R2,R8
   \   0000022E   0xED97 0x0A00      VLDR     S0,[R7, #0]
   \   00000232   0x.... 0x....      BL       DigitalFilter__DF2TSOS
   \   00000236   0xED87 0x0A00      VSTR     S0,[R7, #0]
   \   0000023A   0x1D3F             ADDS     R7,R7,#+4
   \   0000023C   0xF108 0x0818      ADD      R8,R8,#+24
   \   00000240   0x1E76             SUBS     R6,R6,#+1
   \   00000242   0xD1F1             BNE.N    ??GetRegressorInputs_11
   \                     ??GetRegressorInputs_10: (+1)
   \   00000244   0xF895 0x0024      LDRB     R0,[R5, #+36]
   \   00000248   0xEDD5 0x0A70      VLDR     S1,[R5, #+448]
   \   0000024C   0xA900             ADD      R1,SP,#+0
   \   0000024E   0xEB01 0x0180      ADD      R1,R1,R0, LSL #+2
   \   00000252   0xED91 0x0A00      VLDR     S0,[R1, #0]
   \   00000256   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   0000025A   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   0000025E   0xEDDF 0x....      VLDR.W   S1,??DataTable19_1  ;; 0x3c23d70a
   1376                      }
   1377          
   1378                      // y is acceleration (backward difference rule), and is linear function of regressor, so is already filtered
   1379                      regressor.Y = (-regressor.Phi[Phi_Idx[REG_ELE_SPEED]] - Speed_Previous) / TS_PARAMID;
   1380          
   1381                      Speed_Previous = -regressor.Phi[Phi_Idx[REG_ELE_SPEED]];
   \   00000262   0xA900             ADD      R1,SP,#+0
   \   00000264   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000268   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   0000026C   0xED8D 0x0A07      VSTR     S0,[SP, #+28]
   \   00000270   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000274   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   00000278   0xED85 0x0A70      VSTR     S0,[R5, #+448]
   1382                      break;
   \   0000027C   0xE0CE             B.N      ??GetRegressorInputs_1
   1383          #endif
   1384          #if MODEL_BK_EULER_B0_BB == ENABLED
   1385                  case PARAM_EST_MODEL_BK_EULER_B0_BB:
   1386                      Alpha_BB = BBAngle(INPUT_DRUM_SPEED_RAD_S(),Setup_Parameters->BB_Lag);
   \                     ??GetRegressorInputs_12: (+1)
   \   0000027E   0x2101             MOVS     R1,#+1
   \   00000280   0x2000             MOVS     R0,#+0
   \   00000282   0x.... 0x....      BL       BandLimiter__GetSignal
   \   00000286   0xF8D5 0x01D0      LDR      R0,[R5, #+464]
   \   0000028A   0x6801             LDR      R1,[R0, #+0]
   \   0000028C   0xED9F 0x....      VLDR.W   S2,??DataTable19_1  ;; 0x3c23d70a
   \   00000290   0xEE20 0x1A01      VMUL.F32 S2,S0,S2
   \   00000294   0xEE00 0x1A90      VMOV     S1,R1
   \   00000298   0xED95 0x0A73      VLDR     S0,[R5, #+460]
   \   0000029C   0xEE01 0x0A20      VMLA.F32 S0,S2,S1
   \   000002A0   0xEDDF 0x....      VLDR.W   S17,??DataTable19_2  ;; 0x40490fdb
   \   000002A4   0xEEB4 0x0A68      VCMP.F32 S0,S17
   \   000002A8   0xEEF1 0xFA10      FMSTAT   
   \   000002AC   0xBFA8             IT       GE 
   \   000002AE   0xEDDF 0x....      VLDRGE.W S1,??DataTable19_3  ;; 0xc0c90fdb
   \   000002B2   0xDA08             BGE.N    ??GetRegressorInputs_13
   \   000002B4   0xEDDF 0x....      VLDR.W   S1,??DataTable19_4  ;; 0xc0490fdb
   \   000002B8   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   000002BC   0xEEF1 0xFA10      FMSTAT   
   \   000002C0   0xD503             BPL.N    ??GetRegressorInputs_14
   \   000002C2   0xEDDF 0x....      VLDR.W   S1,??DataTable19_5  ;; 0x40c90fdb
   \                     ??GetRegressorInputs_13: (+1)
   \   000002C6   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \                     ??GetRegressorInputs_14: (+1)
   \   000002CA   0xED85 0x0A73      VSTR     S0,[R5, #+460]
   1387                      Alpha_UB = PARAM_EST_ANGLE_WRAP(INPUT_DRUM_POS_RADIANS());
   \   000002CE   0x2103             MOVS     R1,#+3
   \   000002D0   0x2000             MOVS     R0,#+0
   \   000002D2   0x.... 0x....      BL       BandLimiter__GetSignal
   \   000002D6   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   000002DA   0x2102             MOVS     R1,#+2
   \   000002DC   0x2000             MOVS     R0,#+0
   \   000002DE   0x.... 0x....      BL       BandLimiter__GetSignal
   \   000002E2   0xEEF0 0x0A48      VMOV.F32 S1,S16
   \   000002E6   0x.... 0x....      BL       atan2f
   \   000002EA   0xEEB4 0x0A68      VCMP.F32 S0,S17
   \   000002EE   0xEEF1 0xFA10      FMSTAT   
   \   000002F2   0xBFA8             IT       GE 
   \   000002F4   0xEDDF 0x....      VLDRGE.W S1,??DataTable19_3  ;; 0xc0c90fdb
   \   000002F8   0xDA08             BGE.N    ??GetRegressorInputs_15
   \   000002FA   0xEDDF 0x....      VLDR.W   S1,??DataTable19_4  ;; 0xc0490fdb
   \   000002FE   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000302   0xEEF1 0xFA10      FMSTAT   
   \   00000306   0xD503             BPL.N    ??GetRegressorInputs_16
   \   00000308   0xEDDF 0x....      VLDR.W   S1,??DataTable19_5  ;; 0x40c90fdb
   \                     ??GetRegressorInputs_15: (+1)
   \   0000030C   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \                     ??GetRegressorInputs_16: (+1)
   \   00000310   0xED85 0x0A72      VSTR     S0,[R5, #+456]
   1388          
   1389                      regressor.Phi[Phi_Idx[REG_ELE_TORQUE]] = INPUT_DRUM_TORQUE_NM();         // Torque (N-m)
   \   00000314   0x2100             MOVS     R1,#+0
   \   00000316   0x2000             MOVS     R0,#+0
   \   00000318   0x.... 0x....      BL       BandLimiter__GetSignal
   \   0000031C   0xF895 0x1025      LDRB     R1,[R5, #+37]
   1390                      regressor.Phi[Phi_Idx[REG_ELE_CONSTANT]] = -1.0f;                                    // constant
   \   00000320   0x....             LDR.N    R2,??DataTable19_6  ;; 0xbf800000
   \   00000322   0xA800             ADD      R0,SP,#+0
   \   00000324   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000328   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   0000032C   0xA800             ADD      R0,SP,#+0
   \   0000032E   0xF895 0x1026      LDRB     R1,[R5, #+38]
   \   00000332   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
   1391                      regressor.Phi[Phi_Idx[REG_ELE_SIN_ANGLE]] = -INPUT_SIN_DRUM_POS();                      // sin(alpha) (Rad)
   \   00000336   0x2102             MOVS     R1,#+2
   \   00000338   0x2000             MOVS     R0,#+0
   \   0000033A   0x.... 0x....      BL       BandLimiter__GetSignal
   \   0000033E   0xF895 0x1027      LDRB     R1,[R5, #+39]
   \   00000342   0xA800             ADD      R0,SP,#+0
   \   00000344   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000348   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   0000034C   0xED80 0x0A00      VSTR     S0,[R0, #0]
   1392                      regressor.Phi[Phi_Idx[REG_ELE_COS_ANGLE]] = -INPUT_COS_DRUM_POS();                      // cos(alpha) (Rad)
   \   00000350   0x2103             MOVS     R1,#+3
   \   00000352   0x2000             MOVS     R0,#+0
   \   00000354   0x.... 0x....      BL       BandLimiter__GetSignal
   \   00000358   0xF895 0x1028      LDRB     R1,[R5, #+40]
   \   0000035C   0xA800             ADD      R0,SP,#+0
   \   0000035E   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000362   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   00000366   0xED80 0x0A00      VSTR     S0,[R0, #0]
   1393                      regressor.Phi[Phi_Idx[REG_ELE_SIN_BB_ANGLE]] = -sinf(Alpha_BB);                   // sin(alpha_bb) (Rad)
   \   0000036A   0x2000             MOVS     R0,#+0
   \   0000036C   0xED95 0x8A73      VLDR     S16,[R5, #+460]
   \   00000370   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000374   0x.... 0x....      BL       __iar_FSin
   \   00000378   0xF895 0x1029      LDRB     R1,[R5, #+41]
   \   0000037C   0xA800             ADD      R0,SP,#+0
   \   0000037E   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000382   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   00000386   0xED80 0x0A00      VSTR     S0,[R0, #0]
   1394                      regressor.Phi[Phi_Idx[REG_ELE_COS_BB_ANGLE]] = -cosf(Alpha_BB);                   // cos(alpha_bb) (Rad)
   \   0000038A   0x2001             MOVS     R0,#+1
   \   0000038C   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000390   0x.... 0x....      BL       __iar_FSin
   \   00000394   0xF895 0x102A      LDRB     R1,[R5, #+42]
   \   00000398   0xA800             ADD      R0,SP,#+0
   \   0000039A   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   0000039E   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   000003A2   0xED80 0x0A00      VSTR     S0,[R0, #0]
   1395          
   1396                      // Append speed to phi only for filtering (not part of the actual regressor). The last element of phi is simply holding current speed.
   1397                      regressor.Phi[N_Theta] = INPUT_DRUM_SPEED_RAD_S();                          // Speed (Rad/s)
   \   000003A6   0x2101             MOVS     R1,#+1
   \   000003A8   0x2000             MOVS     R0,#+0
   \   000003AA   0x.... 0x....      BL       BandLimiter__GetSignal
   \   000003AE   0xF895 0x0031      LDRB     R0,[R5, #+49]
   \   000003B2   0xA900             ADD      R1,SP,#+0
   \   000003B4   0xEB01 0x0180      ADD      R1,R1,R0, LSL #+2
   \   000003B8   0xED81 0x0A00      VSTR     S0,[R1, #0]
   1398          
   1399                      if( Setup_Parameters->Filter_Configuration_Index != FILTER_DISABLED )
   \   000003BC   0xF8D5 0x11D0      LDR      R1,[R5, #+464]
   \   000003C0   0x7F49             LDRB     R1,[R1, #+29]
   \   000003C2   0x29FF             CMP      R1,#+255
   \   000003C4   0xBF1E             ITTT     NE 
   1400                      {
   1401                          DFiltNChan(regressor.Phi, N_Theta + 1);     // Filter the output and regressor (N_Theta + 1 because of appended speed)
   \   000003C6   0x1C46             ADDNE    R6,R0,#+1
   \   000003C8   0xB2F6             UXTBNE   R6,R6
   \   000003CA   0x2E00             CMPNE    R6,#+0
   \   000003CC   0xD010             BEQ.N    ??GetRegressorInputs_3
   \   000003CE   0xAF00             ADD      R7,SP,#+0
   \   000003D0   0xF505 0x78EA      ADD      R8,R5,#+468
   \                     ??GetRegressorInputs_17: (+1)
   \   000003D4   0xE9D5 0x0100      LDRD     R0,R1,[R5, #+0]
   \   000003D8   0x4642             MOV      R2,R8
   \   000003DA   0xED97 0x0A00      VLDR     S0,[R7, #0]
   \   000003DE   0x.... 0x....      BL       DigitalFilter__DF2TSOS
   \   000003E2   0xED87 0x0A00      VSTR     S0,[R7, #0]
   \   000003E6   0x1D3F             ADDS     R7,R7,#+4
   \   000003E8   0xF108 0x0818      ADD      R8,R8,#+24
   \   000003EC   0x1E76             SUBS     R6,R6,#+1
   \   000003EE   0xD1F1             BNE.N    ??GetRegressorInputs_17
   \                     ??GetRegressorInputs_3: (+1)
   \   000003F0   0xF895 0x0031      LDRB     R0,[R5, #+49]
   \   000003F4   0xEDD5 0x0A70      VLDR     S1,[R5, #+448]
   \   000003F8   0xA900             ADD      R1,SP,#+0
   \   000003FA   0xEB01 0x0180      ADD      R1,R1,R0, LSL #+2
   \   000003FE   0xED91 0x0A00      VLDR     S0,[R1, #0]
   \   00000402   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   00000406   0xEDDF 0x....      VLDR.W   S1,??DataTable19_1  ;; 0x3c23d70a
   \   0000040A   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   1402                      }
   1403          
   1404                      // y is acceleration (backward difference rule).
   1405                      regressor.Y = (regressor.Phi[N_Theta] - Speed_Previous) / TS_PARAMID;
   1406          
   1407                      Speed_Previous = regressor.Phi[N_Theta];
   \   0000040E   0xA900             ADD      R1,SP,#+0
   \   00000410   0xED8D 0x0A07      VSTR     S0,[SP, #+28]
   \   00000414   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \                     ??GetRegressorInputs_8: (+1)
   \   00000418   0xF8C5 0x01C0      STR      R0,[R5, #+448]
   1408                      break;
   1409          #endif
   1410                  default:                // Code can never get here
   1411                      // an invalid Model is posted by macro DEBUG_INVALID_MODEL in ParamEst__Enable()
   1412                      break;
   1413              }
   1414          
   1415              return ( regressor );
   \                     ??GetRegressorInputs_1: (+1)
   \   0000041C   0xA800             ADD      R0,SP,#+0
   \   0000041E   0xE8B0 0x50EE      LDM      R0!,{R1-R3,R5-R7,R12,LR}
   \   00000422   0xE8A4 0x50EE      STM      R4!,{R1-R3,R5-R7,R12,LR}
   \   00000426   0xB008             ADD      SP,SP,#+32
   \   00000428   0x3820             SUBS     R0,R0,#+32
   \   0000042A   0xECBD 0x8B02      VPOP     {D8}
   \   0000042E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1416          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x447A0000         DC32     0x447a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x3F800001         DC32     0x3f800001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x3DCCCCCD         DC32     0x3dcccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x3C23D70A         DC32     0x3c23d70a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x40C90FDB         DC32     0x40c90fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0xC0C90FDB         DC32     0xc0c90fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x40490FDB         DC32     0x40490fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0xC0490FDB         DC32     0xc0490fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     Param_Est_Filter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x........         DC32     Param_Est_Filter+0x34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     Param_Est_Filter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x3C23D70A         DC32     0x3c23d70a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x40490FDB         DC32     0x40490fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0xC0C90FDB         DC32     0xc0c90fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   0xC0490FDB         DC32     0xc0490fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_5:
   \   00000000   0x40C90FDB         DC32     0x40c90fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_6:
   \   00000000   0xBF800000         DC32     0xbf800000
   1417          
   1418          //---------------------------------------------------------------------------------------------------------------------
   1419          /**
   1420           * @brief   Verifies the passed Setup values are valid.
   1421           *
   1422           * @return  TRUE = parameters are valid; FALSE = parameters are invalid
   1423           */
   1424          //#pragma optimize=size no_inline no_unroll
   1425          static BOOL_TYPE VerifySetup(const PARAM_EST_SETUP_TYPE *parameters, const DIGITAL_FILTER_SOS_TYPE *filter)
   1426          {
   1427              BOOL_TYPE config_valid = TRUE;
   1428          
   1429              // verify the Setup Model
   1430              if ( parameters->Model_Config.Struct.Model >= PARAM_EST_NUM_OF_MODELS )
   1431              {
   1432                 config_valid = FALSE;
   1433                 DEBUG_INVALID_MODEL(parameters->Model_Config.Struct.Model);
   1434              }
   1435              // else Model is valid
   1436          
   1437              // verify the Setup Adapt_Type and Forgetting value
   1438              switch ( parameters->Model_Config.Struct.Adapt_Type )
   1439              {
   1440                  case PARAM_EST_ADAPTATION_FORGETTING:
   1441                      if ( IsSetupAdaptationForgettingValid(parameters) == FALSE )
   1442                      {
   1443                          config_valid = FALSE;
   1444                      }
   1445                      // else setup is valid
   1446                      break;
   1447                  case PARAM_EST_ADAPTATION_KALMAN:
   1448                      if ( IsSetupAdaptationKalmanValid(parameters) == FALSE )
   1449                      {
   1450                          config_valid = FALSE;
   1451                      }
   1452                      // else setup is valid
   1453                      break;
   1454                  case PARAM_EST_ADAPTATION_BOTH:
   1455                      if (( IsSetupAdaptationForgettingValid(parameters) == FALSE ) ||
   1456                          ( IsSetupAdaptationKalmanValid(parameters) == FALSE ))
   1457                      {
   1458                          config_valid = FALSE;
   1459                      }
   1460                      // else setup is valid
   1461                      break;
   1462                  default:
   1463                      config_valid = FALSE;
   1464                      DEBUG_INVALID_ADAPTATION_TYPE(parameters->Model_Config.Struct.Adapt_Type);
   1465                      break;
   1466              }
   1467          
   1468              // verify the Setup Filter
   1469              if (( parameters->Filter_Configuration_Index != FILTER_DISABLED ) &&
   1470                  ( filter->Num_Sections > PARAM_EST_FILTER_MAX_NUM_SECTIONS ) &&
   1471          		( filter->Num_Sections == 0 ))
   1472              {
   1473                  config_valid = FALSE;
   1474                  DEBUG_INVALID_FILTER_ORDER(filter->Num_Sections);
   1475              }
   1476          
   1477              return ( config_valid );
   1478          }
   1479          
   1480          //=====================================================================================================================
   1481          //-- Private State Machine Customization Functions --------------------------------------------------------------------
   1482          //=====================================================================================================================
   1483          
   1484          //---------------------------------------------------------------------------------------------------------------------
   1485          /**
   1486           *  @brief      Tasks to perform when enabling the algorithm.
   1487           */
   1488          //#pragma optimize=size no_inline no_unroll
   1489          static void ActiveEnter(void)
   1490          {
   1491              if ( ParamID.Reset == TRUE )
   1492              {
   1493                  ParamEst__CovReset(PARAM_EST_P0_DEFAULT);
   1494                  ResetFilter();
   1495                  ResetTheta();
   1496              }
   1497              ParamID.Handler_Down_Sample_Counter = INPUT_HANDLER_SLOT_PERIODS;
   1498              Speed_Previous = 0.0f;
   1499              ParamID.Delay_Counter = 0;
   1500          }
   1501          
   1502          //---------------------------------------------------------------------------------------------------------------------
   1503          /**
   1504           *  @brief      Tasks to perform when the algorithm is active.
   1505           */
   1506          //#pragma optimize=size no_inline no_unroll
   1507          static void ActiveDo(void)
   1508          {
   1509              if ( ParamID.Handler_Down_Sample_Counter == 0 )      // This is the down sampler of the handler to reach the desired sample rate.
   1510              {
   1511                  ParamID.Handler_Down_Sample_Counter = INPUT_HANDLER_SLOT_PERIODS;
   1512                  REGRESSOR_FORM_TYPE regressor = GetRegressorInputs();
   1513                  if ( ParamID.Delay_Counter >= DELAY_RLS[Setup_Parameters->Model_Config.Struct.Model] )
   1514                  {
   1515                      Residual = ParamIdRLS(regressor.Y, regressor.Phi);      // run the regression
   1516                  }
   1517                  else
   1518                  {
   1519                      ParamID.Delay_Counter++;
   1520                  }
   1521              }
   1522              // else down sampler timer not expired
   1523          }
   1524          
   1525          //=====================================================================================================================
   1526          //=== StateEngineCrank (v1.5) Auto-Generated Functions for Parameter Estimation State Machine
   1527          //=====================================================================================================================
   1528          // !! StateEngineCrank cannot update this code if you change the header !!
   1529          
   1530          
   1531          //---------------------------------------------------------------------------------------------------------------------
   1532          /**
   1533           * Process the Ev Disable Event for the Parameter Estimation state machine.
   1534           *
   1535           *              >>> DO NOT MODIFY THIS FUNCTION <<<
   1536           *
   1537           * This function was auto-generated and must not be edited manually.
   1538           * Change the UML used to generate this function and regenerate the source code.
   1539           */
   1540          static void EventDisable(void)
   1541          {
   1542              switch (Parameter_Estimation_State)
   1543              {
   1544                  case STATE_ACTIVE:
   1545                      Parameter_Estimation_State = STATE_IDLE;
   1546                      break;
   1547          
   1548                  default:
   1549                      // Event is ignored for all other values of Parameter_Estimation_State.
   1550                      break;
   1551              }
   1552          }
   1553          
   1554          
   1555          //---------------------------------------------------------------------------------------------------------------------
   1556          /**
   1557           * Process the Ev Enable Event for the Parameter Estimation state machine.
   1558           *
   1559           *              >>> DO NOT MODIFY THIS FUNCTION <<<
   1560           *
   1561           * This function was auto-generated and must not be edited manually.
   1562           * Change the UML used to generate this function and regenerate the source code.
   1563           */
   1564          static void EventEnable(void)
   1565          {
   1566              switch (Parameter_Estimation_State)
   1567              {
   1568                  case STATE_IDLE:
   1569                      Parameter_Estimation_State = STATE_ACTIVE;
   1570                      ActiveEnter();                          // STATE_ACTIVE enter function.
   1571                      break;
   1572          
   1573                  default:
   1574                      // Event is ignored for all other values of Parameter_Estimation_State.
   1575                      break;
   1576              }
   1577          }
   1578          
   1579          
   1580          //---------------------------------------------------------------------------------------------------------------------
   1581          /**
   1582           * The main execution function for the Parameter Estimation state machine.
   1583           * This function should be called periodically while the state machine is running.
   1584           *
   1585           *              >>> DO NOT MODIFY THIS FUNCTION <<<
   1586           *
   1587           * This function was auto-generated and must not be edited manually.
   1588           * Change the UML used to generate this function and regenerate the source code.
   1589           */
   1590          static void ParameterEstimationExecute(void)
   1591          {
   1592              switch (Parameter_Estimation_State)
   1593              {
   1594                  case STATE_ACTIVE:
   1595                      ActiveDo();                             // STATE_ACTIVE do function.
   1596                      break;
   1597          
   1598                  default:
   1599                      // There is nothing to do for all other values of Parameter_Estimation_State.
   1600                      break;
   1601              }
   1602          }
   1603          
   1604          
   1605          //---------------------------------------------------------------------------------------------------------------------
   1606          /**
   1607           * The initialization function for the Parameter Estimation state machine.
   1608           * This function resets the state machine to the initial state.
   1609           *
   1610           *              >>> DO NOT MODIFY THIS FUNCTION <<<
   1611           *
   1612           * This function was auto-generated and must not be edited manually.
   1613           * Change the UML used to generate this function and regenerate the source code.
   1614           */
   1615          static void ParameterEstimationInitialize(void)
   1616          {
   1617              Parameter_Estimation_State = STATE_IDLE;
   1618          }
   1619          
   1620          
   1621          // !! StateEngineCrank cannot update this code if you change the footer !!
   1622          // End of StateEngineCrank Auto-Generated Code.

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      64   GetRegressorInputs
        64   -> BandLimiter__GetSignal
        64   -> DigitalFilter__DF2TSOS
        64   -> __iar_FSin
        64   -> atan2f
       8   ParamEst__CovReset
         8   -> sqrtf
       0   ParamEst__Disable
       8   ParamEst__Enable
         8   -> DigitalFilter__ResetSOS
         8   -> sqrtf
      16   ParamEst__GetParameterValue
        16   -> BandLimiter__GetSignal
        16   -> ParamEst__GetParameterValue
        16   -> atan2f
        16   -> sqrtf
       0   ParamEst__GetSettingFileError
       0   ParamEst__GetSetup
         0   -> __aeabi_memcpy
      88   ParamEst__Handler
        88   -> GetRegressorInputs
        88   -> ParamIdRLS
       8   ParamEst__Initialize
         8   -> DigitalFilter__ResetSOS
         8   -> ParamEst__CovReset
         8   -> __aeabi_memclr4
       0   ParamEst__IsRunning
      32   ParamEst__SetSetup
        32   -> DigitalFilter__ResetSOS
        32   -> SettingFile__BasicLoader
        32   -> sqrtf
      64   ParamIdQR
        64   -> sqrtf
      96   ParamIdRLS
        96   -> ParamIdQR
        96   -> sqrtf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable18
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable19_6
       4  DELAY_RLS
    1074  GetRegressorInputs
       8  PHI_BK_EULER
       4  PHI_BK_EULER_B0
       8  PHI_BK_EULER_B0_BB
      72  ParamEst__CovReset
      20  ParamEst__Disable
     222  ParamEst__Enable
     990  ParamEst__GetParameterValue
      10  ParamEst__GetSettingFileError
      22  ParamEst__GetSetup
     116  ParamEst__Handler
     154  ParamEst__Initialize
      20  ParamEst__IsRunning
     614  ParamEst__SetSetup
     958  ParamIdQR
    1328  ParamIdRLS
     660  Param_Est_Filter
          Theta
          Phi_Idx
          ParamID
          Parameter_Estimation_State
          N_Theta
          Sf_Parameters_Fault
          S_T
          Lambda_Sqrt_Inv
          Speed_Previous
          Residual
          Alpha_UB
          Alpha_BB
          Setup_Parameters
          Filter_Storage
      16  Param_Est_Filter_Bank
      40  Param_Est_HS_Filter_Coeffs
      40  Param_Est_LS_Filter_Coeffs

 
   660 bytes in section .bss
   100 bytes in section .rodata
 5 700 bytes in section .text
 
 5 700 bytes of CODE  memory
   100 bytes of CONST memory
   660 bytes of DATA  memory

Errors: none
Warnings: 1
