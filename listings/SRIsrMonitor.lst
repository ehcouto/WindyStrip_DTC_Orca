###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        19/Nov/2024  13:15:44
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  XCategory\Common\SRIsrMonitor\SRIsrMonitor.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        SRIsrMonitor.obj -l ..\listings\SRIsrMonitor.lst
#        XCategory\Common\SRIsrMonitor\SRIsrMonitor.c
#    List file    =  ..\listings\SRIsrMonitor.lst
#    Object file  =  SRIsrMonitor.obj
#
###############################################################################

C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Common\SRIsrMonitor\SRIsrMonitor.c
      1          /**
      2           *  @file       SRIsrMonitor.c
      3           *  @defgroup   CLASS_B
      4           *  @brief      ISR Monitor module
      5           *
      6           *  @details    Detailed description of the file contents
      7           *
      8           *  @section    Applicable_Documents
      9           *					List here all the applicable documents if needed. <tr>	
     10           *
     11           *  $Header: $
     12           *
     13           *  @copyright  Copyright 2015-$Date$. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     14           */
     15          //---------------------------------------------------------------------------------------------------------------------
     16          //---------------------------------------------------------------------------------------------------------------------
     17          
     18          
     19          //-------------------------------------- Include Files ----------------------------------------------------------------
     20          #include "SRSystemConfig.h"
     21          #include "SRPowerMgr.h"
     22          #include "SRIsrMonitor.h"
     23          #include "SRisrMonitor_prv.h"
     24          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     25          #ifndef SRISRMONITOR_MAX
     26          #define SRISRMONITOR_MAX			0
     27          #endif
     28          
     29          #ifndef SRISRMONITOR_MIN
     30          #define SRISRMONITOR_MIN			0
     31          #endif
     32          
     33          #ifndef SRISRMONITOR_MAX_ATTEMPTS
     34          #define SRISRMONITOR_MAX_ATTEMPTS	0
     35          #endif
     36          
     37          #ifndef SRISRMONITOR_STATS
     38          #define SRISRMONITOR_STATS		DISABLED
     39          #endif
     40          
     41          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     42          #if (SRISRMONITOR_MAX > 0)
     43          
     44          #if (SRISRMONITOR_MIN > SRISRMONITOR_MAX)
     45          #error "SRISRMONITOR_MIN must be lower than SRISRMONITOR_MAX!"
     46          #endif
     47          
     48              #ifndef SRISRMONITOR_LOWSPEED_MAX
     49              #define SRISRMONITOR_LOWSPEED_MAX       SRISRMONITOR_MAX
     50              #endif
     51          
     52              #ifndef SRISRMONITOR_LOWSPEED_MIN
     53              #define SRISRMONITOR_LOWSPEED_MIN       SRISRMONITOR_MIN
     54              #endif
     55          
     56          #if (SRPOWERMGR_LOWPOWER_MODE == 3) // SRPOWERMGR_LOW_SPEED_MODE
                      ^
Remark[Pe193]: zero used for undefined preprocessing identifier
          "SRPOWERMGR_LOWPOWER_MODE"
     57              #if (SRISRMONITOR_LOWSPEED_MIN > SRISRMONITOR_LOWSPEED_MAX)
     58              #error "SRISRMONITOR_LOWSPEED_MIN must be lower than SRISRMONITOR_LOWSPEED_MAX!"
     59              #endif
     60          
     61          #endif
     62          
     63          #include "SRException.h"
     64          #include "SRMicro.h"
     65          #include "SRData.h"
     66          #if (SYSTEM_ENABLE_TASKSEQUENCE == ENABLED)
     67              #include "SRTaskSequence.h"
     68          #endif
     69          
     70          #if ((SRISRMONITOR_MAX < 255) && (SRISRMONITOR_LOWSPEED_MAX < 255))
     71          typedef uint8 SRISRMONITOR_CNTR_TYPE;
     72          
     73          #define SRDATA_STAT_CNTR_MAX						0xFF
     74          #define SRDATA__ISRCHECK(var, n_var)				SRData__CheckByte((var), (n_var))
     75          #define SRDATA__ISRUPDATE(var, n_var, val)			SRData__UpdateByte((var), (n_var), (val))
     76          
     77          #elif ((SRISRMONITOR_MAX < 65535) && (SRISRMONITOR_LOWSPEED_MAX < 65535))
     78          typedef uint16 SRISRMONITOR_CNTR_TYPE;
     79          
     80          #define SRDATA_STAT_CNTR_MAX						0xFFFF
     81          #define SRDATA__ISRCHECK(var, n_var)				SRData__CheckShort((var), (n_var))
     82          #define SRDATA__ISRUPDATE(var, n_var, val)			SRData__UpdateShort((var), (n_var), (val))
     83          
     84          #else
     85          typedef uint32 SRISRMONITOR_CNTR_TYPE;
     86          
     87          #define SRDATA_STAT_CNTR_MAX						0xFFFFFFFF
     88          #define SRDATA__ISRCHECK(var, n_var)				SRData__CheckLong((var), (n_var))
     89          #define SRDATA__ISRUPDATE(var, n_var, val)			SRData__UpdateLong((var), (n_var), (val))
     90          #endif
     91          

   \                                 In section .bss, align 1
     92          static SRISRMONITOR_CNTR_TYPE Isr_Max;
   \                     Isr_Max:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 1
   \   00000003                      DS8 1
     93          static SRISRMONITOR_CNTR_TYPE Isr_Min;
     94          static SRISRMONITOR_CNTR_TYPE Isr_Enter_Cntr;
     95          static SRISRMONITOR_CNTR_TYPE Isr_Exit_Cntr;
     96          static uint8                  Isr_LowSpeed_Mode;
     97          #if (SRISRMONITOR_STATS == ENABLED)
     98          SRISRMONITOR_CNTR_TYPE Isr_Min_Cntr;
   \                     Isr_Min_Cntr:
   \   00000004                      DS8 1
     99          SRISRMONITOR_CNTR_TYPE Isr_Max_Cntr;
   \                     Isr_Max_Cntr:
   \   00000005                      DS8 1
   \   00000006                      DS8 1
    100          #endif
    101          static SRISRMONITOR_CNTR_TYPE N_Isr_Max;
    102          static SRISRMONITOR_CNTR_TYPE N_Isr_Min;
    103          static SRISRMONITOR_CNTR_TYPE N_Isr_Enter_Cntr;
    104          static SRISRMONITOR_CNTR_TYPE N_Isr_Exit_Cntr;
    105          static uint8                  N_Isr_LowSpeed_Mode;
    106          
    107          
    108          
    109          #if (SRISRMONITOR_MAX_ATTEMPTS > 0)
    110          
    111          #if (SRISRMONITOR_MAX_ATTEMPTS < 255)
    112          typedef uint8 SRISRMONITOR_ATTEMPT_TYPE;
    113          
    114          #define SRDATA_STAT_ATTEMPT_MAX						0xFF
    115          #define SRDATA__ATTEMPT_CHECK(var, n_var)			SRData__CheckByte((var), (n_var))
    116          #define SRDATA__ATTEMPT_UPDATE(var, n_var, val)		SRData__UpdateByte((var), (n_var), (val))
    117          #elif (SRISRMONITOR_MAX_ATTEMPTS < 65535)
    118          typedef uint16 SRISRMONITOR_ATTEMPT_TYPE;
    119          
    120          #define SRDATA_STAT_ATTEMPT_MAX						0xFFFF
    121          #define SRDATA__ATTEMPT_CHECK(var, n_var)			SRData__CheckShort((var), (n_var))
    122          #define SRDATA__ATTEMPT_UPDATE(var, n_var, val)		SRData__UpdateShort((var), (n_var), (val))
    123          #else
    124          typedef uint32 SRISRMONITOR_ATTEMPT_TYPE;
    125          
    126          #define SRDATA_STAT_ATTEMPT_MAX						0xFFFFFFFF
    127          #define SRDATA__ATTEMPT_CHECK(var, n_var)			SRData__CheckLong((var), (n_var))
    128          #define SRDATA__ATTEMPT_UPDATE(var, n_var, val)		SRData__UpdateLong((var), (n_var), (val))
    129          
    130          #endif
    131          
    132          static SRISRMONITOR_ATTEMPT_TYPE Isr_Attempt_Cntr;
    133          #if (SRISRMONITOR_STATS == ENABLED)
    134          SRISRMONITOR_ATTEMPT_TYPE Isr_Attempt_Min_Cntr;
   \                     Isr_Attempt_Min_Cntr:
   \   00000007                      DS8 1
    135          SRISRMONITOR_ATTEMPT_TYPE Isr_Attempt_Max_Cntr;
   \                     Isr_Attempt_Max_Cntr:
   \   00000008                      DS8 1
   \   00000009                      DS8 1
   \   0000000A                      DS8 1
   \   0000000B                      DS8 1
   \   0000000C                      DS8 1
   \   0000000D                      DS8 1
   \   0000000E                      DS8 1
   \   0000000F                      DS8 1
    136          #endif
    137          static SRISRMONITOR_ATTEMPT_TYPE N_Isr_Attempt_Cntr;
    138          
    139          #endif
    140          #endif
    141          
    142          
    143          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
    144          
    145          
    146          //=====================================================================================================================
    147          //-------------------------------------- Public Functions -------------------------------------------------------------
    148          //=====================================================================================================================
    149          
    150          //---------------------------------------------------------------------------------------------------------------------
    151          /**
    152           *  @brief      It Initializes the module SRIsrMonitor and its variables
    153           *
    154           */

   \                                 In section .text, align 2, keep-with-next
    155          void SRIsrMonitor__Initialize(void)
    156          {
   \                     SRIsrMonitor__Initialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    157          #if (SRISRMONITOR_MAX > 0)
    158          	// Reset Enter and Exit counters
    159              SRDATA__ISRUPDATE(&Isr_Enter_Cntr, &N_Isr_Enter_Cntr, 0);
   \   00000002   0x....             LDR.N    R4,??DataTable3
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xF104 0x010C      ADD      R1,R4,#+12
   \   0000000A   0x1CA0             ADDS     R0,R4,#+2
   \   0000000C   0x.... 0x....      BL       SRData__UpdateByte
    160              SRDATA__ISRUPDATE(&Isr_Exit_Cntr, &N_Isr_Exit_Cntr, 0);
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0xF104 0x010D      ADD      R1,R4,#+13
   \   00000016   0x1CE0             ADDS     R0,R4,#+3
   \   00000018   0x.... 0x....      BL       SRData__UpdateByte
    161          
    162              #if (SRISRMONITOR_MAX_ATTEMPTS > 0)
    163                  // Reset Attempts counters
    164                  SRDATA__ATTEMPT_UPDATE(&Isr_Attempt_Cntr, &N_Isr_Attempt_Cntr, 0);
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0xF104 0x010F      ADD      R1,R4,#+15
   \   00000022   0x1DA0             ADDS     R0,R4,#+6
   \   00000024   0x.... 0x....      BL       SRData__UpdateByte
    165              #endif
    166          
    167              // Start using Normal Speed mode parameters
    168              SRDATA__ISRUPDATE(&Isr_Max, &N_Isr_Max, SRISRMONITOR_MAX);
   \   00000028   0x2218             MOVS     R2,#+24
   \   0000002A   0xF104 0x010A      ADD      R1,R4,#+10
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       SRData__UpdateByte
    169              SRDATA__ISRUPDATE(&Isr_Min, &N_Isr_Min, SRISRMONITOR_MIN);
   \   00000034   0x2208             MOVS     R2,#+8
   \   00000036   0xF104 0x010B      ADD      R1,R4,#+11
   \   0000003A   0x1C60             ADDS     R0,R4,#+1
   \   0000003C   0x.... 0x....      BL       SRData__UpdateByte
    170              SRData__UpdateByte(&Isr_LowSpeed_Mode, &N_Isr_LowSpeed_Mode, (uint8) FALSE);
   \   00000040   0x2200             MOVS     R2,#+0
   \   00000042   0xF104 0x010E      ADD      R1,R4,#+14
   \   00000046   0xF104 0x0009      ADD      R0,R4,#+9
   \   0000004A   0x.... 0x....      BL       SRData__UpdateByte
    171          
    172              #if (SRISRMONITOR_STATS == ENABLED)
    173                  // Reset data statistics
    174                  Isr_Min_Cntr = SRDATA_STAT_CNTR_MAX;
   \   0000004E   0x20FF             MOVS     R0,#+255
    175                  Isr_Max_Cntr = 0;
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x7120             STRB     R0,[R4, #+4]
   \   00000054   0x7161             STRB     R1,[R4, #+5]
    176                  Isr_Attempt_Min_Cntr = SRDATA_STAT_ATTEMPT_MAX;
   \   00000056   0x71E0             STRB     R0,[R4, #+7]
    177                  Isr_Attempt_Max_Cntr = 0;
   \   00000058   0x7221             STRB     R1,[R4, #+8]
    178              #endif
    179          
    180              #if (SYSTEM_ENABLE_TASKSEQUENCE == ENABLED)
    181                  SRTaskSequence__SetSequenceStep(SRTASKSEQUENCE_INIT_PHASE, SRTASKSEQUENCE_INIT_SRISRMONITOR);
    182              #endif
    183          
    184          #endif
    185          }
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
    186          
    187          //---------------------------------------------------------------------------------------------------------------------
    188          /**
    189           *  @brief      Function to be called at beginning of every ISR function
    190           *
    191           *  @detail		This function checks IsrEnterCntr data integrity and Overrun check
    192           *  			(IsrEnterCntr higher than expected)	before update it.
    193           *  			It can be called also when nested interrupt are used.
    194           *
    195           */

   \                                 In section .text, align 2, keep-with-next
    196          void SRIsrMonitor__EnterIsr(void)
    197          {
   \                     SRIsrMonitor__EnterIsr: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    198          #if (SRISRMONITOR_MAX > 0)
    199              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    200          
    201              //------- ISR Protected Code --------------------------------------------------------------------------------------
    202              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   00000004   0xF3EF 0x8410      MRS      R4,PRIMASK
   \   00000008   0xB672             CPSID    I
    203              // Data integrity
    204              SRDATA__ISRCHECK(&Isr_Enter_Cntr, &N_Isr_Enter_Cntr);
   \   0000000A   0x....             LDR.N    R5,??DataTable3
   \   0000000C   0xF105 0x010C      ADD      R1,R5,#+12
   \   00000010   0x1CA8             ADDS     R0,R5,#+2
   \   00000012   0x.... 0x....      BL       SRData__CheckByte
    205              SRDATA__ISRCHECK(&Isr_Max, &N_Isr_Max);
   \   00000016   0xF105 0x010A      ADD      R1,R5,#+10
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x.... 0x....      BL       SRData__CheckByte
    206          	// Catch an ISR overrun
    207              if (Isr_Enter_Cntr >= Isr_Max)
   \   00000020   0x78A9             LDRB     R1,[R5, #+2]
   \   00000022   0x7828             LDRB     R0,[R5, #+0]
   \   00000024   0x4281             CMP      R1,R0
   \   00000026   0xD303             BCC.N    ??SRIsrMonitor__EnterIsr_0
    208              {
    209                  SRException__Queue(SREXCEPTION_SRISR_OVERRUN, Isr_Enter_Cntr, 0);
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x2024             MOVS     R0,#+36
   \   0000002C   0x.... 0x....      BL       SRException__Queue
    210              }
    211              // Update ISR Enter counter
    212              SRDATA__ISRUPDATE(&Isr_Enter_Cntr, &N_Isr_Enter_Cntr, Isr_Enter_Cntr+1);
   \                     ??SRIsrMonitor__EnterIsr_0: (+1)
   \   00000030   0x78A8             LDRB     R0,[R5, #+2]
   \   00000032   0x1C42             ADDS     R2,R0,#+1
   \   00000034   0xB2D2             UXTB     R2,R2
   \   00000036   0xF105 0x010C      ADD      R1,R5,#+12
   \   0000003A   0x1CA8             ADDS     R0,R5,#+2
   \   0000003C   0x.... 0x....      BL       SRData__UpdateByte
    213              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \   00000040   0xF384 0x8810      MSR      PRIMASK,R4
    214              //------- End ISR Protected Code ----------------------------------------------------------------------------------
    215          #endif
    216          }
   \   00000044   0xB001             ADD      SP,SP,#+4
   \   00000046   0xBD30             POP      {R4,R5,PC}       ;; return
    217          
    218          //---------------------------------------------------------------------------------------------------------------------
    219          /**
    220           *  @brief      Function to be called at end of every ISR function
    221           *
    222           *  @detail		This function checks IsrExitCntr data integrity before update it.
    223           *  			It can be called also when nested interrupt are used.
    224           *
    225           */

   \                                 In section .text, align 2, keep-with-next
    226          void SRIsrMonitor__ExitIsr(void)
    227          {
   \                     SRIsrMonitor__ExitIsr: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    228          #if (SRISRMONITOR_MAX > 0)
    229              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    230          
    231              //------- ISR Protected Code --------------------------------------------------------------------------------------
    232              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   00000004   0xF3EF 0x8410      MRS      R4,PRIMASK
   \   00000008   0xB672             CPSID    I
    233              // Data integrity
    234              SRDATA__ISRCHECK(&Isr_Exit_Cntr, &N_Isr_Exit_Cntr);
   \   0000000A   0x....             LDR.N    R5,??DataTable3
   \   0000000C   0xF105 0x010D      ADD      R1,R5,#+13
   \   00000010   0x1CE8             ADDS     R0,R5,#+3
   \   00000012   0x.... 0x....      BL       SRData__CheckByte
    235              // Update ISR Exit counter
    236              SRDATA__ISRUPDATE(&Isr_Exit_Cntr, &N_Isr_Exit_Cntr, Isr_Exit_Cntr+1);
   \   00000016   0x78E8             LDRB     R0,[R5, #+3]
   \   00000018   0x1C42             ADDS     R2,R0,#+1
   \   0000001A   0xB2D2             UXTB     R2,R2
   \   0000001C   0xF105 0x010D      ADD      R1,R5,#+13
   \   00000020   0x1CE8             ADDS     R0,R5,#+3
   \   00000022   0x.... 0x....      BL       SRData__UpdateByte
    237              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \   00000026   0xF384 0x8810      MSR      PRIMASK,R4
    238              //------- End ISR Protected Code ----------------------------------------------------------------------------------
    239          #endif
    240          }
   \   0000002A   0xB001             ADD      SP,SP,#+4
   \   0000002C   0xBD30             POP      {R4,R5,PC}       ;; return
    241          
    242          //---------------------------------------------------------------------------------------------------------------------
    243          /**
    244           *  @brief      IsrMonitor Hanlder to check proper ISR execution
    245           *
    246           *  @detail		This function checks all data integrity, IsrEnterCntr/IsrExitCntr match
    247           *  			and minimum number of ISRs occurred.
    248           *  			If ISR number is lower, increases number attempts up to maximum reached.
    249           *  			If everything is OK, resets all counters.
    250           *				This function must be called out of any ISR, otherwise IsrEnterCntr and IsrExitCntr will not match.
    251           *				This function disables interrupts to ensure its proper execution.
    252           *
    253           */

   \                                 In section .text, align 2, keep-with-next
    254          void SRIsrMonitor__Handler(void)
    255          {
   \                     SRIsrMonitor__Handler: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    256          #if (SRISRMONITOR_MAX > 0)
    257              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    258          
    259              //------- ISR Protected Code --------------------------------------------------------------------------------------
    260              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   00000004   0xF3EF 0x8510      MRS      R5,PRIMASK
   \   00000008   0xB672             CPSID    I
    261          	// Data integrity check
    262              SRDATA__ISRCHECK(&Isr_Enter_Cntr, &N_Isr_Enter_Cntr);
   \   0000000A   0x....             LDR.N    R4,??DataTable3
   \   0000000C   0xF104 0x010C      ADD      R1,R4,#+12
   \   00000010   0x1CA0             ADDS     R0,R4,#+2
   \   00000012   0x.... 0x....      BL       SRData__CheckByte
    263              SRDATA__ISRCHECK(&Isr_Exit_Cntr, &N_Isr_Exit_Cntr);
   \   00000016   0xF104 0x010D      ADD      R1,R4,#+13
   \   0000001A   0x1CE0             ADDS     R0,R4,#+3
   \   0000001C   0x.... 0x....      BL       SRData__CheckByte
    264              SRDATA__ISRCHECK(&Isr_Max, &N_Isr_Max);
   \   00000020   0xF104 0x010A      ADD      R1,R4,#+10
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       SRData__CheckByte
    265              SRDATA__ISRCHECK(&Isr_Min, &N_Isr_Min);
   \   0000002A   0xF104 0x010B      ADD      R1,R4,#+11
   \   0000002E   0x1C60             ADDS     R0,R4,#+1
   \   00000030   0x.... 0x....      BL       SRData__CheckByte
    266              SRData__CheckByte(&Isr_LowSpeed_Mode, &N_Isr_LowSpeed_Mode);
   \   00000034   0xF104 0x010E      ADD      R1,R4,#+14
   \   00000038   0xF104 0x0009      ADD      R0,R4,#+9
   \   0000003C   0x.... 0x....      BL       SRData__CheckByte
    267              #if (SRISRMONITOR_MAX_ATTEMPTS > 0)
    268                  SRDATA__ATTEMPT_CHECK(&Isr_Attempt_Cntr, &N_Isr_Attempt_Cntr);
   \   00000040   0xF104 0x010F      ADD      R1,R4,#+15
   \   00000044   0x1DA0             ADDS     R0,R4,#+6
   \   00000046   0x.... 0x....      BL       SRData__CheckByte
    269              #endif
    270          
    271              #if (SRPOWERMGR_LOWPOWER_MODE == 3) // SRPOWERMGR_LOW_SPEED_MODE
                          ^
Remark[Pe193]: zero used for undefined preprocessing identifier
          "SRPOWERMGR_LOWPOWER_MODE"
    272          		// If Low Speed mode has been engaged, update Max and Min values with Low speed ones
    273                  if ((Isr_LowSpeed_Mode == (uint8) FALSE) &&
    274                      (SRPowerMgr__GetMode() == SRPOWERMGR_LOW_SPEED_MODE))
    275                  {
    276                      SRData__UpdateByte(&Isr_LowSpeed_Mode, &N_Isr_LowSpeed_Mode, (uint8) TRUE);
    277                      SRDATA__ISRUPDATE(&Isr_Max, &N_Isr_Max, SRISRMONITOR_LOWSPEED_MAX);
    278                      SRDATA__ISRUPDATE(&Isr_Min, &N_Isr_Min, SRISRMONITOR_LOWSPEED_MIN);
    279                  }
    280              #endif
    281          
    282              // Catch an Enter/Exit mismatch - at this point they must be equal!
    283              if (Isr_Enter_Cntr != Isr_Exit_Cntr)
   \   0000004A   0x78E2             LDRB     R2,[R4, #+3]
   \   0000004C   0x78A1             LDRB     R1,[R4, #+2]
   \   0000004E   0x4291             CMP      R1,R2
   \   00000050   0xBF1C             ITT      NE 
    284              {
    285                  SRException__Queue(SREXCEPTION_SRISR_SEQUENCE_MISMATCH, Isr_Enter_Cntr, Isr_Exit_Cntr);
   \   00000052   0x2025             MOVNE    R0,#+37
   \   00000054   0x.... 0x....      BLNE     SRException__Queue
    286              }
    287              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \   00000058   0xF385 0x8810      MSR      PRIMASK,R5
    288              //------- End ISR Protected Code ----------------------------------------------------------------------------------
    289          
    290              // Catch interrupts less than lower threshold set
    291              if (Isr_Enter_Cntr < Isr_Min)
   \   0000005C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000005E   0x7861             LDRB     R1,[R4, #+1]
   \   00000060   0x4288             CMP      R0,R1
   \   00000062   0xD217             BCS.N    ??SRIsrMonitor__Handler_0
    292              {
    293                  //------- ISR Protected Code --------------------------------------------------------------------------------------
    294                  MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   00000064   0xF3EF 0x8510      MRS      R5,PRIMASK
   \   00000068   0xB672             CPSID    I
    295                  // Handle attempts - do exception only if higher than SRISRMONITOR_MAX_ATTEMPTS
    296                  if(Isr_Attempt_Cntr < SRISRMONITOR_MAX_ATTEMPTS)
   \   0000006A   0x79A0             LDRB     R0,[R4, #+6]
   \   0000006C   0xB948             CBNZ.N   R0,??SRIsrMonitor__Handler_1
    297                  {
    298                      SRDATA__ATTEMPT_UPDATE(&Isr_Attempt_Cntr, &N_Isr_Attempt_Cntr, Isr_Attempt_Cntr+1);
   \   0000006E   0x2201             MOVS     R2,#+1
   \   00000070   0xF104 0x010F      ADD      R1,R4,#+15
   \   00000074   0x1DA0             ADDS     R0,R4,#+6
   \   00000076   0x.... 0x....      BL       SRData__UpdateByte
    299                  }
    300                  else
    301                  {
    302                      SRException__Queue(SREXCEPTION_SRISR_TIMEOUT, Isr_Enter_Cntr, 0);
    303                  }
    304                  MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
    305                  //------- End ISR Protected Code ----------------------------------------------------------------------------------
    306              }
    307              else
    308              {
    309                  #if (SRISRMONITOR_STATS == ENABLED)
    310                      // Update statistics
    311                      if (Isr_Enter_Cntr > Isr_Max_Cntr)
    312                      {
    313                          Isr_Max_Cntr = Isr_Enter_Cntr;
    314                      }
    315          
    316                      if (Isr_Enter_Cntr < Isr_Min_Cntr)
    317                      {
    318                          Isr_Min_Cntr = Isr_Enter_Cntr;
    319                      }
    320          
    321                      #if (SRISRMONITOR_MAX_ATTEMPTS > 0)
    322                          if (Isr_Attempt_Cntr > Isr_Attempt_Max_Cntr)
    323                          {
    324                              Isr_Attempt_Max_Cntr = Isr_Attempt_Cntr;
    325                          }
    326          
    327                          if (Isr_Attempt_Cntr < Isr_Attempt_Min_Cntr)
    328                          {
    329                              Isr_Attempt_Min_Cntr = Isr_Attempt_Cntr;
    330                          }
    331                      #endif
    332                  #endif
    333          
    334                  //------- ISR Protected Code --------------------------------------------------------------------------------------
    335                  MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
    336          
    337                  // Everything is going OK - reset all counters for next check
    338                  SRDATA__ISRUPDATE(&Isr_Enter_Cntr, &N_Isr_Enter_Cntr, 0);
    339                  SRDATA__ISRUPDATE(&Isr_Exit_Cntr, &N_Isr_Exit_Cntr, 0);
    340                  #if (SRISRMONITOR_MAX_ATTEMPTS > 0)
    341                      SRDATA__ATTEMPT_UPDATE(&Isr_Attempt_Cntr, &N_Isr_Attempt_Cntr, 0);
    342                  #endif
    343                  MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \   0000007A   0xF385 0x8810      MSR      PRIMASK,R5
    344                  //------- End ISR Protected Code ----------------------------------------------------------------------------------
    345              }
    346              #if (SYSTEM_ENABLE_TASKSEQUENCE == ENABLED)
    347                 SRTaskSequence__SetSequenceStep(SRTASKSEQUENCE_MAIN_HANDLER, SRTASKSEQUENCE_MAIN_ISRMONITOR);
    348              #endif
    349          
    350             //-----------------------------------------------------------------------------------------------------------------
    351          #endif
    352          }
   \   0000007E   0xB001             ADD      SP,SP,#+4
   \   00000080   0xBD30             POP      {R4,R5,PC}
   \                     ??SRIsrMonitor__Handler_1: (+1)
   \   00000082   0x78A1             LDRB     R1,[R4, #+2]
   \   00000084   0x2200             MOVS     R2,#+0
   \   00000086   0x2026             MOVS     R0,#+38
   \   00000088   0x.... 0x....      BL       SRException__Queue
   \   0000008C   0xF385 0x8810      MSR      PRIMASK,R5
   \   00000090   0xB001             ADD      SP,SP,#+4
   \   00000092   0xBD30             POP      {R4,R5,PC}
   \                     ??SRIsrMonitor__Handler_0: (+1)
   \   00000094   0x7961             LDRB     R1,[R4, #+5]
   \   00000096   0x4281             CMP      R1,R0
   \   00000098   0xBF38             IT       CC 
   \   0000009A   0x7160             STRBCC   R0,[R4, #+5]
   \   0000009C   0x7921             LDRB     R1,[R4, #+4]
   \   0000009E   0x4288             CMP      R0,R1
   \   000000A0   0xBF38             IT       CC 
   \   000000A2   0x7120             STRBCC   R0,[R4, #+4]
   \   000000A4   0x79A0             LDRB     R0,[R4, #+6]
   \   000000A6   0x7A21             LDRB     R1,[R4, #+8]
   \   000000A8   0x4281             CMP      R1,R0
   \   000000AA   0xBF38             IT       CC 
   \   000000AC   0x7220             STRBCC   R0,[R4, #+8]
   \   000000AE   0x79E1             LDRB     R1,[R4, #+7]
   \   000000B0   0x4288             CMP      R0,R1
   \   000000B2   0xBF38             IT       CC 
   \   000000B4   0x71E0             STRBCC   R0,[R4, #+7]
   \   000000B6   0xF3EF 0x8510      MRS      R5,PRIMASK
   \   000000BA   0xB672             CPSID    I
   \   000000BC   0x2200             MOVS     R2,#+0
   \   000000BE   0xF104 0x010C      ADD      R1,R4,#+12
   \   000000C2   0x1CA0             ADDS     R0,R4,#+2
   \   000000C4   0x.... 0x....      BL       SRData__UpdateByte
   \   000000C8   0x2200             MOVS     R2,#+0
   \   000000CA   0xF104 0x010D      ADD      R1,R4,#+13
   \   000000CE   0x1CE0             ADDS     R0,R4,#+3
   \   000000D0   0x.... 0x....      BL       SRData__UpdateByte
   \   000000D4   0x2200             MOVS     R2,#+0
   \   000000D6   0xF104 0x010F      ADD      R1,R4,#+15
   \   000000DA   0x1DA0             ADDS     R0,R4,#+6
   \   000000DC   0x.... 0x....      BL       SRData__UpdateByte
   \   000000E0   0xF385 0x8810      MSR      PRIMASK,R5
   \   000000E4   0xB001             ADD      SP,SP,#+4
   \   000000E6   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     Isr_Max
    353          //=====================================================================================================================
    354          //-------------------------------------- Private Functions ------------------------------------------------------------
    355          //=====================================================================================================================
    356          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   SRIsrMonitor__EnterIsr
        16   -> SRData__CheckByte
        16   -> SRData__UpdateByte
        16   -> SRException__Queue
      16   SRIsrMonitor__ExitIsr
        16   -> SRData__CheckByte
        16   -> SRData__UpdateByte
      16   SRIsrMonitor__Handler
        16   -> SRData__CheckByte
        16   -> SRData__UpdateByte
        16   -> SRException__Queue
       8   SRIsrMonitor__Initialize
         8   -> SRData__UpdateByte


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
      16  Isr_Max
          Isr_Min
          Isr_Enter_Cntr
          Isr_Exit_Cntr
          Isr_Min_Cntr
          Isr_Max_Cntr
          Isr_Attempt_Cntr
          Isr_Attempt_Min_Cntr
          Isr_Attempt_Max_Cntr
          Isr_LowSpeed_Mode
          N_Isr_Max
          N_Isr_Min
          N_Isr_Enter_Cntr
          N_Isr_Exit_Cntr
          N_Isr_LowSpeed_Mode
          N_Isr_Attempt_Cntr
      72  SRIsrMonitor__EnterIsr
      46  SRIsrMonitor__ExitIsr
     232  SRIsrMonitor__Handler
      92  SRIsrMonitor__Initialize

 
  16 bytes in section .bss
 446 bytes in section .text
 
 446 bytes of CODE memory
  16 bytes of DATA memory

Errors: none
Warnings: none
