###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        19/Nov/2024  13:15:49
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  XCategory\Driver\Flash\Flash.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        Flash.obj -l ..\listings\Flash.lst XCategory\Driver\Flash\Flash.c
#    List file    =  ..\listings\Flash.lst
#    Object file  =  Flash.obj
#
###############################################################################

C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Driver\Flash\Flash.c
      1          /**
      2           *  @file       
      3           *
      4           *    @brief    This module implements the standard Flash API (Application Programming Interface)
      5           *              for Freescale Kinetis MKV03x Micro.
      6           *    @details  This modules provides the interface to application in order to write or format the Flash of MKV03x.
      7           *              Note -  1. Controller supports only 4-byte alligned even addressed write. If the application tries to write on odd address
      8           *                         gives error.
      9           *                      2. Controller supports only long word write (i.e 4bytes). Application can write 1, 2 or 3 byte were the next adjacent byte
     10           *                         is written with 0xff(because the controller support word writing)
     11           *                      3. Before writing data on the memory the flash memory should have erase value(0xff).
     12           *
     13           *  @section    Applicable_Documents
     14           *					List here all the applicable documents if needed. <tr>	
     15           *
     16           *  $Header: Flash.c 1.1 2015/06/10 14:51:15EDT Natak Rahul (NATAKRB) Exp  $
     17           *
     18           *  @copyright  Copyright 2013-$Date: 2015/06/10 14:51:15EDT $. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     19           */
     20          //---------------------------------------------------------------------------------------------------------------------
     21          //---------------------------------------------------------------------------------------------------------------------
     22          
     23          //-------------------------------------- Include Files ----------------------------------------------------------------
     24          #include "C_Extensions.h"
     25          #include "Flash.h"
     26          #include "uc.h"
     27          #include "Micro.h"
     28          
     29          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     30          //This symbols are exported from config.icf file
     31          extern uint32 __ICFEDIT_region_RAM_start__;
     32          extern uint32 __ICFEDIT_region_RAM_end__;
     33          
     34          #define RAM_LOW_LIMIT                   ((uint32)&__ICFEDIT_region_RAM_start__)         // This symbol comes from the linker file
                         ^
Warning[Pe047]: incompatible redefinition of macro "RAM_LOW_LIMIT" (declared
          at line 153 of "ProjectSpecific/Driver/Flash_prm.h")
     35          #define RAM_HIGH_LIMIT                  ((uint32)&__ICFEDIT_region_RAM_end__)           // This symbol comes from the linker file
                         ^
Warning[Pe047]: incompatible redefinition of macro "RAM_HIGH_LIMIT" (declared
          at line 154 of "ProjectSpecific/Driver/Flash_prm.h")
     36          #if (FLASH_PAGE_FORMAT_SIZE != 0x800)
     37              #error : "FLASH_PAGE_FORMAT_SIZE macro shall be of 0x800 for this device"
     38          #endif
     39          
     40          
     41          #define FLASH_LOW_LIMIT_VAL         (FLASH_LOW_LIMIT - 1)
     42          #define FLASH_HIGH_LIMIT_VAL        (FLASH_HIGH_LIMIT + 1)
     43          
     44          
     45          
     46          
     47          typedef enum
     48          {
     49          	FLASH_READ_ONE_BLOCK             = 0x00,
     50          	FLASH_READ_ONE_SECTION           = 0x01,
     51          	FLASH_PROGRAM_CHECK              = 0x02,			//Program up to two longwords in a flash block
     52          	FLASH_READ_RESOURCE              = 0x03,			//Program up to two longwords in a flash block
     53          	FLASH_PROGRAM_LONGWORD           = 0x06,			//Program up to two longwords in a flash block
     54          	FLASH_ERASE_BLOCK                = 0x08,			//Program up to two longwords in a flash block
     55          	FLASH_ERASE_SECTOR               = 0x09,			//Program up to two longwords in a flash block
     56          	FLASH_READ_ONCE_ALL_BLOCK        = 0x40,			//Program up to two longwords in a flash block
     57          	FLASH_READ_ONCE_BLOCK            = 0x41,			//Program up to two longwords in a flash block
     58          	FLASH_PROGRAM_ONCE               = 0x43,			//Program up to two longwords in a flash block
     59          	FLASH_ERASE_ALL_BLOCKS           = 0x44,			//Program up to two longwords in a flash block
     60          	FLASH_VERIFY_BACKDOOR_ACESS_KEY  = 0x45,
     61          }FLASH_COMMAND;
     62          

   \                                 In section .bss, align 1
     63          static FLASH_STATE_TYPE Flash_Status;
   \                     Flash_Status:
   \   00000000                      DS8 1
     64          
     65          #define FLASH_PAGE_SECTOR_SIZE                   FLASH_PAGE_FORMAT_SIZE
     66          #define FLASH_LOWBYTE_DEFAULT                    ((uint32)0x00ff)
     67          #define FLASH_HIGHBYTE_DEFAULT_1_BYTE            ((uint32)0xFFFFFF00)
     68          #define FLASH_HIGHBYTE_DEFAULT_2_BYTE            ((uint32)0xFFFF0000)
     69          #define FLASH_HIGHBYTE_DEFAULT_3_BYTE            ((uint32)0xFF000000)
     70          
     71          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
     72          static FLASH_RESPONSE_TYPE FlashProgram1LongWord(FLASH_ADDRESS_TYPE address, uint32 data);
     73          static void Flash_Launchcmd(uint8 bWaitComplete);
     74          static void Flash_SetNormalSpeedMode(void);
     75          //=====================================================================================================================
     76          //-------------------------------------- Public Functions -------------------------------------------------------------
     77          //=====================================================================================================================
     78          
     79          //---------------------------------------------------------------------------------------------------------------------
     80          /**
     81           *    @brief    This method initializes the flash module.
     82           *    @details  This method initializes flash related variables.
     83           */

   \                                 In section .text, align 2, keep-with-next
     84          void Flash__Initialize(void)
     85          {
     86              Flash_Status = FLASH_STATE_FREE;
   \                     Flash__Initialize: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable6
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x7008             STRB     R0,[R1, #+0]
     87          	SIM.FCFG1 &= ~(SIM_FCFG1_FLASHDIS_MASK);				//Flash module clock Enabled
   \   00000006   0x....             LDR.N    R0,??DataTable6_1  ;; 0x4004804c
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x0849             LSRS     R1,R1,#+1
   \   0000000C   0x0049             LSLS     R1,R1,#+1
   \   0000000E   0x6001             STR      R1,[R0, #+0]
     88          }
   \   00000010   0x4770             BX       LR               ;; return
     89          
     90          //---------------------------------------------------------------------------------------------------------------------
     91          /**
     92           *    @brief    This method Copies data from the RAM to the Flash as per the size and returns
     93           *              the response for write operation.
     94           *    @details  This method writes data from source (RAM) to destination ( Flash) as per the size
     95           *              and returns the response for the write operation.
     96           *              Note -  1. Controller supports only even addressed write. If the application tries to write on odd address
     97           *                         gives error.
     98           *                      2. Controller supports only word write. Application can write 1 byte were the next adjacent byte
     99           *                         is written with 0xff(because the controller support word writing)
    100           *                      3. The software design supports for odd size write.
    101           *                         The next adjacent byte is written with 0xff(because the controller support word writing)
    102           *                      4. Before writing data on the memory the flash memory should have erase value(0xff).
    103           *
    104           *    @param    destination : Defines the address of the flash where data to be written
    105           *    @param    source      : Defines the address of RAM from where data to be written to flash
    106           *    @param    size        : Number of bytes to be written
    107           *    @return   enum FLASH_RESPONSE_TYPE
    108           *      @retval FLASH_RESPONSE_DONE                     : If the write operation is complete.
    109           *      @retval FLASH_RESPONSE_ACCEPTED                 : If the command accepted
    110           *      @retval FLASH_RESPONSE_ERROR_BUSY               : If the flash is busy
    111           *      @retval FLASH_RESPONSE_WRITE_ERROR              : If the write operation is unsuccessful.
    112           *      @retval FLASH_RESPONSE_ERROR_OUT_OF_RANGE       : If the requested memory is out of range
    113           *      @retval FLASH_RESPONSE_INVALID_SIZE             : If the size is invalid i.e. odd size
    114           */

   \                                 In section .text, align 2, keep-with-next
    115          FLASH_RESPONSE_TYPE Flash__Write(FLASH_ADDRESS_TYPE destination,uint8 * source, FLASH_SIZE_TYPE size)
    116          {
   \                     Flash__Write: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    117          	FLASH_RESPONSE_TYPE response;
    118          	response = FLASH_RESPONSE_ERROR_OUT_OF_RANGE;
   \   00000008   0x2004             MOVS     R0,#+4
    119          
    120          	//Check for Flash address within range limits
    121          	if ((destination > FLASH_LOW_LIMIT_VAL)	&&
    122          			((destination + (FLASH_ADDRESS_TYPE) size)<= FLASH_HIGH_LIMIT_VAL))
   \   0000000A   0x....             LDR.N    R1,??DataTable6_2
   \   0000000C   0x4616             MOV      R6,R2
   \   0000000E   0x42A1             CMP      R1,R4
   \   00000010   0xD240             BCS.N    ??Flash__Write_0
   \   00000012   0x....             LDR.N    R1,??DataTable6_3
   \   00000014   0x1932             ADDS     R2,R6,R4
   \   00000016   0x4291             CMP      R1,R2
   \   00000018   0xD33C             BCC.N    ??Flash__Write_0
    123          	{
    124          		//MKE02x Flash memory is 4-byte alligned even addressed write
    125          		if ((destination & ((FLASH_ADDRESS_TYPE) 0x03))  != FALSE)
   \   0000001A   0xF014 0x0F03      TST      R4,#0x3
   \   0000001E   0xBF18             IT       NE 
    126          		{
    127          			response = FLASH_RESPONSE_INVALID_SIZE;
   \   00000020   0x2005             MOVNE    R0,#+5
   \   00000022   0xD137             BNE.N    ??Flash__Write_0
    128          		}
    129          
    130          		else
    131          		{
    132          			response = FLASH_RESPONSE_DONE;
    133          			Flash_Status = FLASH_STATE_BUSY;
   \   00000024   0x....             LDR.N    R7,??DataTable6
   \   00000026   0x.... 0x....      LDR.W    R9,??DataTable6_4  ;; 0x4005200c
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x7038             STRB     R0,[R7, #+0]
   \   0000002E   0xF24B 0x4880      MOVW     R8,#+46208
   \   00000032   0xF24A 0x6A02      MOVW     R10,#+42498
   \   00000036   0xE010             B.N      ??Flash__Write_1
    134          
    135          			//Writing long word (4bytes) data in the flash memory
    136          			while ((size >= 4) && (response == FLASH_RESPONSE_DONE))
   \                     ??Flash__Write_2: (+1)
   \   00000038   0xBB38             CBNZ.N   R0,??Flash__Write_3
    137          			{
    138          				SERVICE_WATCHDOG();
   \   0000003A   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   0000003E   0xB672             CPSID    I
   \   00000040   0xF8A9 0xA000      STRH     R10,[R9, #+0]
   \   00000044   0xF8A9 0x8000      STRH     R8,[R9, #+0]
   \   00000048   0xF380 0x8810      MSR      PRIMASK,R0
    139          				response = FlashProgram1LongWord(destination,*((uint32 *) source));
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0xF855 0x1B04      LDR      R1,[R5], #+4
   \   00000052   0x.... 0x....      BL       FlashProgram1LongWord
    140          				source += 4;
    141          				destination += 4;
   \   00000056   0x1D24             ADDS     R4,R4,#+4
    142          				size -= 4;
   \   00000058   0x1F36             SUBS     R6,R6,#+4
    143          			}
   \                     ??Flash__Write_1: (+1)
   \   0000005A   0x2E04             CMP      R6,#+4
   \   0000005C   0xD2EC             BCS.N    ??Flash__Write_2
    144          
    145          			//Writing the single byte in the flash memory at the end
    146                      if (size == 0x01)
   \   0000005E   0x2E01             CMP      R6,#+1
   \   00000060   0xD103             BNE.N    ??Flash__Write_4
    147                      {
    148                          response = FlashProgram1LongWord((destination ), (FLASH_HIGHBYTE_DEFAULT_1_BYTE | (*((uint32 *) source))));
   \   00000062   0x6828             LDR      R0,[R5, #+0]
   \   00000064   0xF060 0x01FF      ORN      R1,R0,#+255
   \   00000068   0xE00C             B.N      ??Flash__Write_5
    149                      }
    150          
    151                      //Writing the double byte in the flash memory at the end
    152                      if (size == 0x02)
   \                     ??Flash__Write_4: (+1)
   \   0000006A   0x2E02             CMP      R6,#+2
   \   0000006C   0xD105             BNE.N    ??Flash__Write_6
    153                      {
    154                      	response = FlashProgram1LongWord((destination ), (FLASH_HIGHBYTE_DEFAULT_2_BYTE | (*((uint32 *) source))));
   \   0000006E   0x6828             LDR      R0,[R5, #+0]
   \   00000070   0xF040 0x417F      ORR      R1,R0,#0xFF000000
   \   00000074   0xF441 0x017F      ORR      R1,R1,#0xFF0000
   \   00000078   0xE004             B.N      ??Flash__Write_5
    155                      }
    156          
    157                      //Writing the 3 bytes in the flash memory at the end
    158                      if (size == 0x03)
   \                     ??Flash__Write_6: (+1)
   \   0000007A   0x2E03             CMP      R6,#+3
   \   0000007C   0xD105             BNE.N    ??Flash__Write_3
    159                      {
    160                          response = FlashProgram1LongWord((destination ), (FLASH_HIGHBYTE_DEFAULT_3_BYTE | (*((uint32 *) source))));
   \   0000007E   0x6828             LDR      R0,[R5, #+0]
   \   00000080   0xF040 0x417F      ORR      R1,R0,#0xFF000000
   \                     ??Flash__Write_5: (+1)
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0x.... 0x....      BL       FlashProgram1LongWord
    161                      }
    162          
    163                      //Update Flash_Status
    164          			if (response == FLASH_RESPONSE_DONE)
   \                     ??Flash__Write_3: (+1)
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xBF0C             ITE      EQ 
    165          			{
    166          				Flash_Status = FLASH_STATE_FREE;
   \   0000008E   0x2101             MOVEQ    R1,#+1
    167          			}
    168          			else
    169          			{
    170          				Flash_Status = FLASH_STATE_ERROR;
   \   00000090   0x2102             MOVNE    R1,#+2
   \   00000092   0x7039             STRB     R1,[R7, #+0]
    171          			}
    172          
    173          		}
    174          	}
    175          	return (response);
   \                     ??Flash__Write_0: (+1)
   \   00000094   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    176          }
    177          
    178          //---------------------------------------------------------------------------------------------------------------------
    179          /**
    180           *    @brief    This method performs erase/format operation on Flash for sector of 512 bytes.
    181           *    @param    start_address :  address from where the erase to be started
    182           *    @param    end_address   :  address till erase to be performed
    183           *    @return   enum FLASH_RESPONSE_TYPE
    184           *      @retval FLASH_RESPONSE_DONE                     : If the erase operation is complete.
    185           *      @retval FLASH_RESPONSE_ACCEPTED                 : If the command accepted
    186           *      @retval FLASH_RESPONSE_ERROR_BUSY               : If the flash is busy
    187           *      @retval FLASH_RESPONSE_WRITE_ERROR              : If the erase operation is unsuccessful.
    188           *      @retval FLASH_RESPONSE_ERROR_OUT_OF_RANGE       : If the requested memory is out of range
    189           *      @retval FLASH_RESPONSE_INVALID_SIZE             : If the size is invalid i.e. odd size
    190           */

   \                                 In section .text, align 2, keep-with-next
    191          FLASH_RESPONSE_TYPE Flash__FormatPage(FLASH_ADDRESS_TYPE page_init)
    192          {
   \                     Flash__FormatPage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    193          	FLASH_RESPONSE_TYPE response;
    194          	response = FLASH_RESPONSE_ERROR_OUT_OF_RANGE;
    195          	Flash_Status = FLASH_STATE_BUSY;
   \   00000002   0x....             LDR.N    R1,??DataTable6
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x700A             STRB     R2,[R1, #+0]
   \   00000008   0x2404             MOVS     R4,#+4
    196          
    197          	#if(MICRO_HIGHSPEEDRUN_MODE == ENABLED)
    198          		Flash_SetNormalSpeedMode();
   \   0000000A   0xF3EF 0x8210      MRS      R2,PRIMASK
   \   0000000E   0xB672             CPSID    I
   \   00000010   0x....             LDR.N    R3,??DataTable6_5  ;; 0x4007e000
   \   00000012   0x781D             LDRB     R5,[R3, #+0]
   \   00000014   0xF005 0x057F      AND      R5,R5,#0x7F
   \   00000018   0x701D             STRB     R5,[R3, #+0]
   \   0000001A   0x2500             MOVS     R5,#+0
   \   0000001C   0x705D             STRB     R5,[R3, #+1]
   \   0000001E   0xF242 0x7510      MOVW     R5,#+10000
   \                     ??Flash__FormatPage_0: (+1)
   \   00000022   0x78DE             LDRB     R6,[R3, #+3]
   \   00000024   0x2E01             CMP      R6,#+1
   \   00000026   0xD001             BEQ.N    ??Flash__FormatPage_1
   \   00000028   0x1E6D             SUBS     R5,R5,#+1
   \   0000002A   0xD1FA             BNE.N    ??Flash__FormatPage_0
   \                     ??Flash__FormatPage_1: (+1)
   \   0000002C   0xF382 0x8810      MSR      PRIMASK,R2
    199          	#endif
    200          
    201          	if (page_init & 0x03)											//Check for even address alignment
   \   00000030   0xF010 0x0F03      TST      R0,#0x3
   \   00000034   0xD001             BEQ.N    ??Flash__FormatPage_2
    202          	{
    203          		return (response);
   \   00000036   0x2004             MOVS     R0,#+4
   \   00000038   0xBD70             POP      {R4-R6,PC}
    204          	}
    205          
    206          	if ((page_init > FLASH_LOW_LIMIT_VAL)&& (page_init < FLASH_HIGH_LIMIT_VAL))
   \                     ??Flash__FormatPage_2: (+1)
   \   0000003A   0x....             LDR.N    R2,??DataTable6_2
   \   0000003C   0x4282             CMP      R2,R0
   \   0000003E   0xBF3C             ITT      CC 
   \   00000040   0x....             LDRCC.N  R2,??DataTable6_3
   \   00000042   0x4290             CMPCC    R0,R2
   \   00000044   0xD235             BCS.N    ??Flash__FormatPage_3
    207          	{
    208          		response = FLASH_RESPONSE_ERROR_BUSY;
    209          
    210          		//Check Flash Memory controller is idle or busy executing a flash command (CCIF = 0)
    211          		if((FTFA.FSTAT && FTFA_FSTAT_CCIF_MASK) == TRUE)
   \   00000046   0x....             LDR.N    R2,??DataTable6_6  ;; 0x40020000
   \   00000048   0x7813             LDRB     R3,[R2, #+0]
   \   0000004A   0x2402             MOVS     R4,#+2
   \   0000004C   0xB38B             CBZ.N    R3,??Flash__FormatPage_3
    212          		{
    213          			response = FLASH_RESPONSE_DONE;
   \   0000004E   0x2400             MOVS     R4,#+0
    214          
    215          		    SERVICE_WATCHDOG();										//Refresh Watchdog
   \   00000050   0xF3EF 0x8310      MRS      R3,PRIMASK
   \   00000054   0xB672             CPSID    I
   \   00000056   0x....             LDR.N    R5,??DataTable6_4  ;; 0x4005200c
   \   00000058   0xF24A 0x6602      MOVW     R6,#+42498
   \   0000005C   0x802E             STRH     R6,[R5, #+0]
   \   0000005E   0xF24B 0x4680      MOVW     R6,#+46208
   \   00000062   0x802E             STRH     R6,[R5, #+0]
   \   00000064   0xF383 0x8810      MSR      PRIMASK,R3
    216          			
    217          			MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    218          
    219          			MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   00000068   0xF3EF 0x8510      MRS      R5,PRIMASK
   \   0000006C   0xB672             CPSID    I
    220          
    221          			//Clear error flags
    222          			FTFA.FSTAT = 0x30;										//ACCERR & FPVIOL No access and protection violation detected
   \   0000006E   0x2330             MOVS     R3,#+48
   \   00000070   0x7013             STRB     R3,[R2, #+0]
    223          			FTFA.FCCOB0 = 0x09;										//Flash Erase Command
   \   00000072   0x2309             MOVS     R3,#+9
   \   00000074   0x71D3             STRB     R3,[R2, #+7]
    224          			FTFA.FCCOB1 = page_init >> 16;							//Memory address bits [23:16]
   \   00000076   0x0C03             LSRS     R3,R0,#+16
   \   00000078   0x7193             STRB     R3,[R2, #+6]
    225          			FTFA.FCCOB2 = page_init >> 8;							//Memory address bits [15:8]
   \   0000007A   0x0A03             LSRS     R3,R0,#+8
   \   0000007C   0x7153             STRB     R3,[R2, #+5]
    226          			FTFA.FCCOB3 = page_init;								//Memory address bits [7:0]
   \   0000007E   0x7110             STRB     R0,[R2, #+4]
    227          			Flash_Launchcmd(TRUE);                  				//Launch the command
   \   00000080   0x7810             LDRB     R0,[R2, #+0]
   \   00000082   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000086   0x7010             STRB     R0,[R2, #+0]
   \                     ??Flash__FormatPage_4: (+1)
   \   00000088   0x7810             LDRB     R0,[R2, #+0]
   \   0000008A   0x0600             LSLS     R0,R0,#+24
   \   0000008C   0xD5FC             BPL.N    ??Flash__FormatPage_4
    228          
    229          			//Check error status
    230          			if(FTFA.FSTAT & FTFA_FSTAT_ACCERR_MASK)
   \   0000008E   0x7810             LDRB     R0,[R2, #+0]
   \   00000090   0x0680             LSLS     R0,R0,#+26
   \   00000092   0xBF48             IT       MI 
    231          			{
    232          				response = FLASH_RESPONSE_ERROR_OUT_OF_RANGE;		//Access error id detected
   \   00000094   0x2404             MOVMI    R4,#+4
    233          				Flash_Status = FLASH_STATE_ERROR;
    234          			}
    235          
    236          			if(FTFA.FSTAT & FTFA_FSTAT_FPVIOL_MASK)
   \   00000096   0x7810             LDRB     R0,[R2, #+0]
   \   00000098   0x06C0             LSLS     R0,R0,#+27
   \   0000009A   0xBF48             IT       MI 
    237          			{
    238          				response = FLASH_RESPONSE_WRITE_ERROR;				//Protection violation is detected
   \   0000009C   0x2403             MOVMI    R4,#+3
    239          				Flash_Status = FLASH_STATE_ERROR;
    240          			}
    241          			if(FTFA.FSTAT & FTFA_FSTAT_MGSTAT0_MASK)
   \   0000009E   0x7810             LDRB     R0,[R2, #+0]
   \   000000A0   0x07C0             LSLS     R0,R0,#+31
   \   000000A2   0xD508             BPL.N    ??Flash__FormatPage_5
    242          			{
    243          				response = FLASH_RESPONSE_ERROR_BUSY;				//Flash command execution error or flash reset sequence error
   \   000000A4   0x2402             MOVS     R4,#+2
    244          				Flash_Status = FLASH_STATE_ERROR;
    245          			}
    246          
    247          			//Update Flash_Status
    248          			if (response == FLASH_RESPONSE_DONE)
    249          			{
    250          				Flash_Status = FLASH_STATE_FREE;
    251          			}
    252          			else
    253          			{
    254          				Flash_Status = FLASH_STATE_ERROR;
   \                     ??Flash__FormatPage_6: (+1)
   \   000000A6   0x2002             MOVS     R0,#+2
   \                     ??Flash__FormatPage_7: (+1)
   \   000000A8   0x7008             STRB     R0,[R1, #+0]
    255          			}
    256          
    257          	#if(MICRO_HIGHSPEEDRUN_MODE == ENABLED)
    258          				Micro__SetNormalSpeedMode();
   \   000000AA   0x.... 0x....      BL       Micro__SetNormalSpeedMode
    259          	#endif
    260          
    261                 		MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \   000000AE   0xF385 0x8810      MSR      PRIMASK,R5
    262          
    263          		}
    264          	}
    265          
    266          	return (response);
   \                     ??Flash__FormatPage_3: (+1)
   \   000000B2   0x4620             MOV      R0,R4
   \   000000B4   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??Flash__FormatPage_5: (+1)
   \   000000B6   0x2C00             CMP      R4,#+0
   \   000000B8   0xD1F5             BNE.N    ??Flash__FormatPage_6
   \   000000BA   0x2001             MOVS     R0,#+1
   \   000000BC   0xE7F4             B.N      ??Flash__FormatPage_7
    267          }
    268          
    269          //---------------------------------------------------------------------------------------------------------------------
    270          /**
    271           *    @brief    This method performs erase/format operation on Flash.
    272           *    @param    start_address :  address from where the erase to be started
    273           *    @param    end_address   :  address till erase to be performed
    274           *    @return   enum FLASH_RESPONSE_TYPE
    275           *      @retval FLASH_RESPONSE_DONE                     : If the erase operation is complete.
    276           *      @retval FLASH_RESPONSE_ACCEPTED                 : If the command accepted
    277           *      @retval FLASH_RESPONSE_ERROR_BUSY               : If the flash is busy
    278           *      @retval FLASH_RESPONSE_WRITE_ERROR              : If the erase operation is unsuccessful.
    279           *      @retval FLASH_RESPONSE_ERROR_OUT_OF_RANGE       : If the requested memory is out of range
    280           *      @retval FLASH_RESPONSE_INVALID_SIZE             : If the size is invalid i.e. odd size
    281           */

   \                                 In section .text, align 2, keep-with-next
    282          FLASH_RESPONSE_TYPE Flash__Format(FLASH_ADDRESS_TYPE start_address, FLASH_ADDRESS_TYPE end_address)
    283           {
   \                     Flash__Format: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    284          	FLASH_RESPONSE_TYPE response;
    285          	response = FLASH_RESPONSE_ERROR_OUT_OF_RANGE;
   \   00000004   0x2004             MOVS     R0,#+4
   \   00000006   0xB081             SUB      SP,SP,#+4
    286          
    287          	uint32 No_of_pages;
    288          	uint8 i;
    289          
    290          	if (start_address & 0x03)				//Check for even address alignment
   \   00000008   0xF014 0x0F03      TST      R4,#0x3
   \   0000000C   0xD11A             BNE.N    ??Flash__Format_0
    291          	{
    292          		return (response);
    293          	}
    294          
    295          	if ((start_address > FLASH_LOW_LIMIT_VAL) && (end_address < FLASH_HIGH_LIMIT_VAL))
   \   0000000E   0x....             LDR.N    R2,??DataTable6_2
   \   00000010   0x42A2             CMP      R2,R4
   \   00000012   0xBF3C             ITT      CC 
   \   00000014   0x....             LDRCC.N  R2,??DataTable6_3
   \   00000016   0x4291             CMPCC    R1,R2
   \   00000018   0xD214             BCS.N    ??Flash__Format_0
    296          	{
    297          		response = FLASH_RESPONSE_DONE;
    298          		No_of_pages = (end_address - start_address);
    299          		No_of_pages = (No_of_pages / FLASH_PAGE_SECTOR_SIZE);
   \   0000001A   0x1B09             SUBS     R1,R1,R4
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x0ACD             LSRS     R5,R1,#+11
    300          
    301          		for (i = 0; i <= No_of_pages; i++)
   \   00000020   0x2600             MOVS     R6,#+0
   \   00000022   0x....             LDR.N    R7,??DataTable6
   \   00000024   0xE005             B.N      ??Flash__Format_1
    302          		{
    303          			if (response == FLASH_RESPONSE_DONE
    304          					&& Flash_Status == FLASH_STATE_FREE)
    305          			{
    306          				response = Flash__FormatPage(start_address);
   \                     ??Flash__Format_2: (+1)
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       Flash__FormatPage
    307          				start_address = start_address + FLASH_PAGE_FORMAT_SIZE;
   \   0000002C   0xF504 0x6400      ADD      R4,R4,#+2048
    308          			} else
   \   00000030   0x1C76             ADDS     R6,R6,#+1
   \                     ??Flash__Format_1: (+1)
   \   00000032   0xB2F6             UXTB     R6,R6
   \   00000034   0x42B5             CMP      R5,R6
   \   00000036   0xD305             BCC.N    ??Flash__Format_0
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xBF04             ITT      EQ 
   \   0000003C   0x7838             LDRBEQ   R0,[R7, #+0]
   \   0000003E   0x2801             CMPEQ    R0,#+1
   \   00000040   0xD0F1             BEQ.N    ??Flash__Format_2
    309          			{
    310          				response = FLASH_RESPONSE_WRITE_ERROR;
    311          				return (response);
   \   00000042   0x2003             MOVS     R0,#+3
    312          			}
    313          		}
    314          	}
    315          	return (response);
   \                     ??Flash__Format_0: (+1)
   \   00000044   0xB001             ADD      SP,SP,#+4
   \   00000046   0xBDF0             POP      {R4-R7,PC}       ;; return
    316          
    317          }
    318          
    319          //---------------------------------------------------------------------------------------------------------------------
    320          /**
    321           *    @brief    This method performs erase operation as flash range mentioned in the configuration file
    322           *    @details  Erases a memory from  FLASH_LOW_LIMIT_VAL to FLASH_HIGH_LIMIT_VAL
    323           *
    324           *    @return   enum FLASH_RESPONSE_TYPE
    325           *      @retval FLASH_RESPONSE_DONE                     : If the erase operation is complete.
    326           *      @retval FLASH_RESPONSE_ACCEPTED                 : If the command accepted
    327           *      @retval FLASH_RESPONSE_ERROR_BUSY               : If the flash is busy
    328           *      @retval FLASH_RESPONSE_WRITE_ERROR              : If the erase operation is unsuccessful.
    329           *      @retval FLASH_RESPONSE_ERROR_OUT_OF_RANGE       : If the requested memory is out of range
    330           *      @retval FLASH_RESPONSE_INVALID_SIZE             : If the size is invalid i.e. odd size
    331           */
    332          

   \                                 In section .text, align 2, keep-with-next
    333          FLASH_RESPONSE_TYPE Flash__FormatChip(void)
    334          {
    335              return(Flash__Format(FLASH_LOW_LIMIT, FLASH_HIGH_LIMIT));
   \                     Flash__FormatChip: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable6_7
   \   00000002   0x....             LDR.N    R0,??DataTable6_8
   \   00000004   0x....             B.N      Flash__Format
    336          }
    337          //---------------------------------------------------------------------------------------------------------------------
    338          /**
    339           *    @brief    This method provides status of  flash whether busy/free/error
    340           *    @return   enum FLASH_STATE_TYPE
    341           *      @retval FLASH_STATE_FREE    :  Flash is free for read write
    342           */

   \                                 In section .text, align 2, keep-with-next
    343          FLASH_STATE_TYPE Flash__GetStatus(void)
    344          {
    345              return (FLASH_STATE_FREE);
   \                     Flash__GetStatus: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
    346          }
    347          
    348          //---------------------------------------------------------------------------------------------------------------------
    349          /**
    350           *    @brief    This method reads data from source (Flash) and copies to destination (RAM) as per the size
    351          *               and returns the response for the read operation
    352          *     @param    destination : Defines the address of the RAM where data to be copied
    353          *     @param    source      : Defines the address of Data Flash from where data to be read
    354          *     @param    size        : Number of bytes to be read
    355          *     @return   enum FLASH_RESPONSE_TYPE
    356          *       @retval FLASH_RESPONSE_DONE(0)                 : Read operation is performed successfully
    357          *       @retval FLASH_RESPONSE_ERROR_OUT_OF_RANGE(4)   : If the requested memory is out of range
    358           */

   \                                 In section .text, align 4, keep-with-next
    359          FLASH_RESPONSE_TYPE Flash__Read(uint8 * destination, FLASH_ADDRESS_TYPE source, FLASH_SIZE_TYPE size)
    360           {
   \                     Flash__Read: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    361          	FLASH_RESPONSE_TYPE response = FLASH_RESPONSE_ERROR_OUT_OF_RANGE;
    362          	FLASH_SIZE_TYPE count;
    363          
    364          	#if (FLASH_AS_DATAFLASH_RELATIVE_ADDRESS == ENABLED)
    365          		source += FLASH_USED_AS_DATAFLASH_LOW_LIMIT;
   \   00000002   0xF501 0x4420      ADD      R4,R1,#+40960
    366          	#endif
    367          
    368          	if (Flash_Status != FLASH_STATE_BUSY)
   \   00000006   0x....             LDR.N    R1,??DataTable6
   \   00000008   0x780D             LDRB     R5,[R1, #+0]
   \   0000000A   0x2304             MOVS     R3,#+4
   \   0000000C   0xB10D             CBZ.N    R5,??Flash__Read_0
    369          	{
    370          		Flash_Status = FLASH_STATE_BUSY;
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0x700D             STRB     R5,[R1, #+0]
    371          	}
    372          
    373          	if (((uint32) destination >= (FLASH_ADDRESS_TYPE) RAM_LOW_LIMIT) &&
    374          			(((uint32) destination + (uint32) size - (uint32) 1)<= (FLASH_ADDRESS_TYPE) RAM_HIGH_LIMIT))
   \                     ??Flash__Read_0: (+1)
   \   00000012   0x....             LDR.N    R6,??DataTable6_9
   \   00000014   0x42B0             CMP      R0,R6
   \   00000016   0xBF21             ITTTT    CS 
   \   00000018   0x....             LDRCS.N  R6,??DataTable6_10
   \   0000001A   0x1815             ADDCS    R5,R2,R0
   \   0000001C   0x1E6D             SUBCS    R5,R5,#+1
   \   0000001E   0x42AE             CMPCS    R6,R5
   \   00000020   0xD321             BCC.N    ??Flash__Read_1
    375          	{
    376          		for (count = 0; count < size; count++)
   \   00000022   0xB1EA             CBZ.N    R2,??Flash__Read_2
   \   00000024   0xF012 0x0303      ANDS     R3,R2,#0x3
   \   00000028   0xD005             BEQ.N    ??Flash__Read_3
    377          		{
    378          			destination[count] = ((uint8 *) source)[count];
   \                     ??Flash__Read_4: (+1)
   \   0000002A   0x1E5B             SUBS     R3,R3,#+1
   \   0000002C   0xF814 0x5B01      LDRB     R5,[R4], #+1
   \   00000030   0xF800 0x5B01      STRB     R5,[R0], #+1
   \   00000034   0xD1F9             BNE.N    ??Flash__Read_4
   \                     ??Flash__Read_3: (+1)
   \   00000036   0x0892             LSRS     R2,R2,#+2
   \   00000038   0xF000 0x8012      BEQ.W    ??Flash__Read_2
   \                     ??Flash__Read_5: (+1)
   \   0000003C   0xF814 0x3B01      LDRB     R3,[R4], #+1
   \   00000040   0xF800 0x3B01      STRB     R3,[R0], #+1
    379          		}
   \   00000044   0x1E52             SUBS     R2,R2,#+1
   \   00000046   0xF814 0x3B01      LDRB     R3,[R4], #+1
   \   0000004A   0xF800 0x3B01      STRB     R3,[R0], #+1
   \   0000004E   0xF814 0x3B01      LDRB     R3,[R4], #+1
   \   00000052   0xF800 0x3B01      STRB     R3,[R0], #+1
   \   00000056   0xF814 0x3B01      LDRB     R3,[R4], #+1
   \   0000005A   0xF800 0x3B01      STRB     R3,[R0], #+1
   \   0000005E   0xD1ED             BNE.N    ??Flash__Read_5
    380          		response = FLASH_RESPONSE_DONE;
    381          		Flash_Status = FLASH_STATE_FREE;                    //Flash_Status Free
   \                     ??Flash__Read_2: (+1)
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x2300             MOVS     R3,#+0
   \   00000064   0x7008             STRB     R0,[R1, #+0]
    382          
    383          	}
    384          	return (response);
   \                     ??Flash__Read_1: (+1)
   \   00000066   0x4618             MOV      R0,R3
   \   00000068   0xBC70             POP      {R4-R6}
   \   0000006A   0x4770             BX       LR               ;; return
    385          }
    386          
    387          //=====================================================================================================================
    388          //-------------------------------------- Private Functions ------------------------------------------------------------
    389          //=====================================================================================================================
    390          //---------------------------------------------------------------------------------------------------------------------
    391          /**
    392           *    @brief    This method writes 1 long word data at the specific flash address and
    393           *              returns the status of flash operation.
    394           *    @param    address    : Defines address of flash.
    395           *    @param    data       : Defines data to be written at flash.
    396           *    @return   enum FLASH_RESPONSE_TYPE
    397           *      @retval FLASH_RESPONSE_DONE                     : If the write operation is complete.
    398           *      @retval FLASH_RESPONSE_ACCEPTED                 : If the command accepted
    399           *      @retval FLASH_RESPONSE_ERROR_BUSY               : If the flash is busy
    400           *      @retval FLASH_RESPONSE_WRITE_ERROR              : If the write operation is unsuccessful.
    401           *      @retval FLASH_RESPONSE_ERROR_OUT_OF_RANGE       : If the requested memory is out of range
    402           *      @retval FLASH_RESPONSE_INVALID_SIZE             : If the size is invalid i.e. odd size
    403           */

   \                                 In section .text, align 2, keep-with-next
    404          static FLASH_RESPONSE_TYPE FlashProgram1LongWord(FLASH_ADDRESS_TYPE address, uint32 data)
    405           {
   \                     FlashProgram1LongWord: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    406          	FLASH_RESPONSE_TYPE status;
    407          	status = FLASH_RESPONSE_ERROR_BUSY;
    408          
    409          	MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    410          
    411          	MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   00000002   0xF3EF 0x8410      MRS      R4,PRIMASK
   \   00000006   0xB672             CPSID    I
    412          
    413          	#if(MICRO_HIGHSPEEDRUN_MODE == ENABLED)
    414          		Flash_SetNormalSpeedMode();
   \   00000008   0xF3EF 0x8210      MRS      R2,PRIMASK
   \   0000000C   0xB672             CPSID    I
   \   0000000E   0x....             LDR.N    R3,??DataTable6_5  ;; 0x4007e000
   \   00000010   0x781D             LDRB     R5,[R3, #+0]
   \   00000012   0xF005 0x057F      AND      R5,R5,#0x7F
   \   00000016   0x701D             STRB     R5,[R3, #+0]
   \   00000018   0x2500             MOVS     R5,#+0
   \   0000001A   0x705D             STRB     R5,[R3, #+1]
   \   0000001C   0xF242 0x7510      MOVW     R5,#+10000
   \                     ??FlashProgram1LongWord_0: (+1)
   \   00000020   0x78DE             LDRB     R6,[R3, #+3]
   \   00000022   0x2E01             CMP      R6,#+1
   \   00000024   0xD001             BEQ.N    ??FlashProgram1LongWord_1
   \   00000026   0x1E6D             SUBS     R5,R5,#+1
   \   00000028   0xD1FA             BNE.N    ??FlashProgram1LongWord_0
   \                     ??FlashProgram1LongWord_1: (+1)
   \   0000002A   0xF382 0x8810      MSR      PRIMASK,R2
    415          	#endif
    416          
    417          	//Clear error flags
    418          	FTFA.FSTAT = 0x30;								//ACCERR & FPVIOL No access and protection violation detected
   \   0000002E   0x....             LDR.N    R2,??DataTable6_6  ;; 0x40020000
   \   00000030   0x2330             MOVS     R3,#+48
   \   00000032   0x7013             STRB     R3,[R2, #+0]
    419          	FTFA.FCCOB0 = FLASH_PROGRAM_LONGWORD;			//Program flash command
   \   00000034   0x2306             MOVS     R3,#+6
   \   00000036   0x71D3             STRB     R3,[R2, #+7]
    420          	FTFA.FCCOB1 = address >> 16;					//Memory address bits [23:16]
   \   00000038   0x0C03             LSRS     R3,R0,#+16
   \   0000003A   0x7193             STRB     R3,[R2, #+6]
    421          	FTFA.FCCOB2 = address >> 8;						//Memory address bits [15:8]
   \   0000003C   0x0A03             LSRS     R3,R0,#+8
   \   0000003E   0x7153             STRB     R3,[R2, #+5]
    422          	FTFA.FCCOB3 = address;							//Memory address bits [7:0]
   \   00000040   0x7110             STRB     R0,[R2, #+4]
    423          
    424          	FTFA.FCCOB4 = data >> 24;					     //Big Endian 0A0B0C0D       Memory
   \   00000042   0x0E08             LSRS     R0,R1,#+24
   \   00000044   0x72D0             STRB     R0,[R2, #+11]
    425          	FTFA.FCCOB5 = data >> 16;                        //               | | | |------  a|0A|
   \   00000046   0x0C08             LSRS     R0,R1,#+16
   \   00000048   0x7290             STRB     R0,[R2, #+10]
    426          	FTFA.FCCOB6 = data >> 8;						 //               | | |------- a+1|0B|
   \   0000004A   0x0A08             LSRS     R0,R1,#+8
   \   0000004C   0x7250             STRB     R0,[R2, #+9]
    427          	FTFA.FCCOB7 = data;						         //               | |--------- a+2|0C|
   \   0000004E   0x7211             STRB     R1,[R2, #+8]
    428                                                               //               |----------- a+3|0D|
    429          
    430          	Flash_Launchcmd(TRUE);                  		//Launch the command
   \   00000050   0x7810             LDRB     R0,[R2, #+0]
   \   00000052   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000056   0x7010             STRB     R0,[R2, #+0]
   \                     ??FlashProgram1LongWord_2: (+1)
   \   00000058   0x7810             LDRB     R0,[R2, #+0]
   \   0000005A   0x0600             LSLS     R0,R0,#+24
   \   0000005C   0xD5FC             BPL.N    ??FlashProgram1LongWord_2
    431          
    432          	status = FLASH_RESPONSE_DONE;
   \   0000005E   0x2500             MOVS     R5,#+0
    433          
    434          	//Check error status
    435          	if(FTFA.FSTAT & FTFA_FSTAT_ACCERR_MASK)
   \   00000060   0x7810             LDRB     R0,[R2, #+0]
   \   00000062   0x0680             LSLS     R0,R0,#+26
   \   00000064   0xBF48             IT       MI 
    436          	{
    437          		status = FLASH_RESPONSE_ERROR_OUT_OF_RANGE;		//Access error id detected
   \   00000066   0x2504             MOVMI    R5,#+4
    438          	}
    439          
    440          	if(FTFA.FSTAT & FTFA_FSTAT_FPVIOL_MASK)
   \   00000068   0x7810             LDRB     R0,[R2, #+0]
   \   0000006A   0x06C0             LSLS     R0,R0,#+27
   \   0000006C   0xBF48             IT       MI 
    441          	{
    442          		status = FLASH_RESPONSE_WRITE_ERROR;			//Protection violation is detected
   \   0000006E   0x2503             MOVMI    R5,#+3
    443          	}
    444          
    445          	if(FTFA.FSTAT & FTFA_FSTAT_MGSTAT0_MASK)
   \   00000070   0x7810             LDRB     R0,[R2, #+0]
   \   00000072   0x07C0             LSLS     R0,R0,#+31
   \   00000074   0xBF48             IT       MI 
    446          	{
    447          		status = FLASH_RESPONSE_ERROR_BUSY;				//Flash command execution error or flash reset sequence error
   \   00000076   0x2502             MOVMI    R5,#+2
    448          	}
    449          
    450          	#if(MICRO_HIGHSPEEDRUN_MODE == ENABLED)
    451          			Micro__SetNormalSpeedMode();
   \   00000078   0x.... 0x....      BL       Micro__SetNormalSpeedMode
    452          	#endif
    453          
    454              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \   0000007C   0xF384 0x8810      MSR      PRIMASK,R4
    455          
    456          	return (status);									//Return Flash Program Status
   \   00000080   0x4628             MOV      R0,R5
   \   00000082   0xBD70             POP      {R4-R6,PC}       ;; return
    457          
    458          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     Flash_Status

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x4004804C         DC32     0x4004804c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     __SetingFile_Start+0xFFFFFFFF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     __SetingFile_End+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x4005200C         DC32     0x4005200c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x4007E000         DC32     0x4007e000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     __SetingFile_End

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x........         DC32     __SetingFile_Start

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x........         DC32     __ICFEDIT_region_RAM_start__

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x........         DC32     __ICFEDIT_region_RAM_end__
    459          
    460          //---------------------------------------------------------------------------------------------------------------------
    461          /**
    462           *    @brief    This function wait's till the flash command is executed.
    463           *    @details
    464           *    @param    bWaitComplete     : true if need wait till command completed before return.
    465           */
    466          static void Flash_Launchcmd(uint8 bWaitComplete)
    467           {
    468          	FTFA.FSTAT |= (FTFA_FSTAT_CCIF_MASK);
    469          
    470          	if (bWaitComplete)
    471          	{
    472          		// Wait till command is completed
    473          		while (!(FTFA.FSTAT & FTFA_FSTAT_CCIF_MASK));
    474          	}
    475          
    476          }
    477          //---------------------------------------------------------------------------------------------------------------------
    478          /**
    479           *    @brief    This function will step down the speed of Micro.
    480           *    @details  This method provides a way to switch from High to normal mode of operation.
    481           *
    482           */
    483          #if(MICRO_HIGHSPEEDRUN_MODE == ENABLED)
    484          static void Flash_SetNormalSpeedMode(void)
    485          {
    486          
    487              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    488              uint32 i;
    489          
    490              //Save and Disable the Interrupts
    491              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
    492          
    493          	/* The PMPROT register may have already been written by init code
    494          	 If so then this next write is not done.
    495          	 PMPROT is write once after RESET
    496          	 this write-once bit allows the MCU to enter Normal Speed Run Mode (HSRUN)*/
    497          	SMC.PMPROT.BIT.AHSRUN = 0;
    498          
    499          	/* Set the RUNM bits to 0b011 for HSRUN mode */
    500          	SMC.PMCTRL = SMC_PMCTRL_RUNM(0);
    501          
    502          	/* Wait for HSRUN regulator mode to be confirmed */
    503          	for (i = 0; i < 10000; i++)
    504          	{ /* check that the value of SMC_PMSTAT is not 0x10 once it is 0x10, we can stop checking */
    505          		if (SMC.PMSTAT != 0x01)
    506          		{
    507          			// 0x01 Current mode is normal run
    508          			// 0x80 Current mode is high speed run
    509          		}
    510          		else
    511          		break;
    512              }
    513          
    514              //Restore Interrupts
    515              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
    516          }
    517          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   FlashProgram1LongWord
        16   -> Micro__SetNormalSpeedMode
      24   Flash__Format
        24   -> Flash__FormatPage
       0   Flash__FormatChip
         0   -> Flash__Format
      16   Flash__FormatPage
        16   -> Micro__SetNormalSpeedMode
       0   Flash__GetStatus
       0   Flash__Initialize
      12   Flash__Read
      32   Flash__Write
        32   -> FlashProgram1LongWord


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
     132  FlashProgram1LongWord
       1  Flash_Status
      72  Flash__Format
       6  Flash__FormatChip
     190  Flash__FormatPage
       4  Flash__GetStatus
      18  Flash__Initialize
     108  Flash__Read
     152  Flash__Write

 
   1 byte  in section .bss
 726 bytes in section .text
 
 726 bytes of CODE memory
   1 byte  of DATA memory

Errors: none
Warnings: 2
