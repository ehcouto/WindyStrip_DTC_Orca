###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        13/Mar/2025  15:31:26
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  XCategory\Application\Mode\Mode.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        Mode.obj -l ..\listings\Mode.lst XCategory\Application\Mode\Mode.c
#    List file    =  ..\listings\Mode.lst
#    Object file  =  Mode.obj
#
###############################################################################

C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Application\Mode\Mode.c
      1          /**
      2           *  @file       
      3           *
      4           *  @brief      This module controls the overall mode (state) of the appliance
      5           *
      6           *  @details
      7          
      8              @startuml {SubMode_state_machine.jpg}
      9                  title SubMode State Machine
     10          
     11                  State Initialize
     12                  State SubModeNormalSupervisor
     13                  State SubModeError
     14                  State SubModeNormalExtControlEntering
     15                  State SubModeNormalExtControlEngaged
     16          
     17          
     18                  [*] --> Initialize
     19          
     20                  Initialize : do /\t HandleRequestedSubMode()
     21                  Initialize --> SubModeNormalSupervisor : evReqSubModeSupervisor \n [IsReqSubModeInitialize()]
     22                  Initialize --> SubModeError : evReqSubModeError \n [IsReqSubModeError()]
     23          
     24                  SubModeNormalSupervisor : enter /\t SetReqSubModeNone() \n\t\t PublishMode()
     25                  SubModeNormalSupervisor : do /\t HandleRequestedSubMode()
     26                  SubModeNormalSupervisor --> SubModeError                    : evReqSubModeError
     27                  SubModeNormalSupervisor --> SubModeNormalExtControlEntering : evReqSubModeExtControlEntering \n [EnableSystemTimer()]
     28                  SubModeNormalSupervisor --> SubModeNormalSupervisor         : evReqSubModeSupervisor
     29          
     30                  SubModeNormalExtControlEntering : do /\t VerifyTimerIsRunning() \n\t HandleRequestedSubMode()
     31                  SubModeNormalExtControlEntering --> SubModeNormalExtControlEngaged  : evReqSubModeExtControlEngaged
     32                  SubModeNormalExtControlEntering --> SubModeNormalSupervisor         : evReqSubModeSupervisor \n/ ReleaseSystemTimer()
     33                  SubModeNormalExtControlEntering --> SubModeNormalSupervisor         : evTimerExpired \n/ ReleaseSystemTimer()
     34          
     35                  SubModeNormalExtControlEngaged : enter /\t SetTimer() \n\t\t PublishMode()
     36                  SubModeNormalExtControlEngaged : do /\t VerifyTimerIsRunning() \n\t HandleRequestedSubMode()
     37                  SubModeNormalExtControlEngaged : exit /\t ReleaseSystemTimer()
     38                  SubModeNormalExtControlEngaged --> SubModeNormalSupervisor  : evReqSubModeSupervisor
     39                  SubModeNormalExtControlEngaged --> SubModeNormalSupervisor  : evTimerExpired
     40          
     41              @enduml
     42          
     43           *
     44           *  @copyright  Copyright 2015-$Date: 2015/08/06 16:33:50EDT $. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     45           */
     46          //---------------------------------------------------------------------------------------------------------------------
     47          //---------------------------------------------------------------------------------------------------------------------
     48          
     49          //-------------------------------------- Include Files ----------------------------------------------------------------
     50          #include "SystemConfig.h"
     51          
     52          #include "API011AppCtrl.h"
     53          #include "Log.h"
     54          #include "Mode.h"
     55          #include "SRMicro.h"
     56          #include "SystemTimers.h"

  PACKED typedef struct
         ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Common\SystemTimers\SystemTimers.h",45  Remark[Pe082]: 
          storage class is not first

  PACKED typedef struct
         ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Common\SystemTimers\SystemTimers.h",56  Remark[Pe082]: 
          storage class is not first
     57          
     58          //=====================================================================================================================
     59          //=== StateEngineCrank (v2.8) Auto-Generated Definitions for Sub Mode State Machine
     60          //=====================================================================================================================
     61          // !! StateEngineCrank cannot update this code if you change the header !!
     62          
     63          
     64          //! Unique names used to identify states of the Sub Mode state machine.
     65          typedef enum SUB_MODE_STATE_ENUM
     66          {
     67              STATE_SUB_MODE_NONE                        = 0,
     68          
     69              STATE_SUB_MODE_INITIALIZE                  = 1, //!< (initial_state)
     70              STATE_SUB_MODE_NORMAL_SUPERVISOR           = 2,
     71              STATE_SUB_MODE_ERROR                       = 3,
     72              STATE_SUB_MODE_NORMAL_EXT_CONTROL_ENTERING = 4,
     73              STATE_SUB_MODE_NORMAL_EXT_CONTROL_ENGAGED  = 5,
     74          
     75              STATE_SUB_MODE_END                         = 6
     76          } SUB_MODE_STATE_TYPE;
     77          
     78          //! The state variable for the Sub Mode state machine.
     79          //! State machines with a history pseudostate may write to this variable during initialization.
     80          //! Other state machines must only write to this variable through auto-generated functions.

   \                                 In section .bss, align 2
     81          static SUB_MODE_STATE_TYPE Sub_Mode_State;
   \                     Sub_Mode_State:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 1
   \   00000003                      DS8 1
   \   00000004                      DS8 1
   \   00000005                      DS8 1
   \   00000006                      DS8 2
     82          
     83          //! The transition variable for the Sub Mode state machine.
     84          //! Flag used by the state machine to track when a transition occurs in the middle of a state's
     85          //! Entry() or Do() action that contains more than one function.
     86          static BOOL_TYPE Sub_Mode_Transitioned;
     87          
     88          // -- Private Function Prototypes used by the state machine for customization functions --
     89          static BOOL_TYPE EnableSystemTimer(void);
     90          static void HandleRequestedSubMode(void);
     91          static BOOL_TYPE IsReqSubModeError(void);
     92          static BOOL_TYPE IsReqSubModeInitialize(void);
     93          static void PublishMode(void);
     94          static void ReleaseSystemTimer(void);
     95          static void SetReqSubModeNone(void);
     96          static void SetTimer(void);
     97          static void VerifyTimerIsRunning(void);
     98          
     99          // -- Private Function Prototypes used by the state machine for standard state machine functions --
    100          static void EventReqSubModeError(void);
    101          static void EventReqSubModeExtControlEngaged(void);
    102          static void EventReqSubModeExtControlEntering(void);
    103          static void EventReqSubModeSupervisor(void);
    104          static void EventTimerExpired(void);
    105          static void SubModeExecute(void);
    106          static void SubModeInitialize(void);
    107          
    108          // !! StateEngineCrank cannot update this code if you change the footer !!
    109          // End of StateEngineCrank Auto-Generated Code.
    110          
    111          
    112          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
    113          
    114          //! list of module Log messages
    115          typedef enum
    116          {
    117               INVALID_SYSTEM_TIMER                   //!< data: timer handle
    118          } MODULE_MODE_LOG_MESSAGE_ID_TYPE;
    119          #define MODULE_NAME MODULE_MODE
    120          
    121          
    122          //! SubMode that is used only in the core.  Not defined in SUBMODE_TYPE because it is not needed in the API.
    123          #define SUBMODE_NONE    ((SUBMODE_TYPE)(SUBMODE_NORMAL_EXT_CONTROL_ENGAGED + 1))
    124          
    125          //! time out for keeping the SUBMODE_NORMAL_EXT_CONTROL_ENTERING active
    126          #define SUB_MODE_EXT_ENTERING_TIMEOUT   (5000)
    127          
    128          //! time out for keeping the SUBMODE_NORMAL_EXT_CONTROL_ENGAGED active
    129          #define SUB_MODE_EXT_ENGAGED_TIMEOUT    (30000)
    130          
    131          static MODE_TYPE Mode;
    132          static MODE_TYPE Remote_Mode;
    133          static uint8 N_Mode;
    134          static SUBMODE_TYPE Requested_Sub_Mode;
    135          static uint16 Timer_PC_Control_Handle;

   \                                 In section .bss, align 1
    136          static SUBMODE_TYPE Remote_SubMode;
   \                     Remote_SubMode:
   \   00000000                      DS8 1
    137          
    138          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
    139          
    140          //=====================================================================================================================
    141          //-------------------------------------- Public Functions -------------------------------------------------------------
    142          //=====================================================================================================================
    143          
    144          //---------------------------------------------------------------------------------------------------------------------
    145          /**
    146           *  @brief      It Initializes the module Mode and its variables
    147           *
    148           */

   \                                 In section .text, align 2, keep-with-next
    149          void Mode__Initialize(void)
    150          {
   \                     Mode__Initialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    151              Remote_Mode = MODE_NORMAL;
   \   00000002   0x....             LDR.N    R4,??DataTable15
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x70E0             STRB     R0,[R4, #+3]
    152          
    153              if ((Mode > MODE_LOWPOWER) ||
    154                  (N_Mode != ((uint8)(~Mode))) ||
                                             ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
    155                  (SRMicro__GetResetMode() == MICRO_RESET_MODE_COLD) ||
    156                  (Sub_Mode_State == STATE_SUB_MODE_NONE))
   \   00000008   0x78A0             LDRB     R0,[R4, #+2]
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xDA0B             BGE.N    ??Mode__Initialize_0
   \   0000000E   0x7921             LDRB     R1,[R4, #+4]
   \   00000010   0x43C0             MVNS     R0,R0
   \   00000012   0xB2C0             UXTB     R0,R0
   \   00000014   0x4281             CMP      R1,R0
   \   00000016   0xD106             BNE.N    ??Mode__Initialize_0
   \   00000018   0x.... 0x....      BL       Micro__GetResetMode
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xBF1C             ITT      NE 
   \   00000020   0x7820             LDRBNE   R0,[R4, #+0]
   \   00000022   0x2800             CMPNE    R0,#+0
   \   00000024   0xD108             BNE.N    ??Mode__Initialize_1
    157              {
    158                  Mode = MODE_NORMAL;
   \                     ??Mode__Initialize_0: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x70A0             STRB     R0,[R4, #+2]
    159                  N_Mode = (uint8)(~MODE_NORMAL);
                                          ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \   0000002A   0x20FF             MOVS     R0,#+255
   \   0000002C   0x7120             STRB     R0,[R4, #+4]
    160                  Requested_Sub_Mode = SUBMODE_NORMAL_INITIALIZE;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x7160             STRB     R0,[R4, #+5]
    161                  SubModeInitialize();
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x7020             STRB     R0,[R4, #+0]
   \   00000036   0x7060             STRB     R0,[R4, #+1]
    162              }
    163          
    164              Timer_PC_Control_Handle = SYSTEMTIMERS_FAIL;
   \                     ??Mode__Initialize_1: (+1)
   \   00000038   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000003C   0x80E0             STRH     R0,[R4, #+6]
    165          }
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    166          
    167          //---------------------------------------------------------------------------------------------------------------------
    168          /**
    169           * @brief   Sets the mode of the machine and causes a warm reset (except for MODE_SETTINGFILE_NOT_CONSISTENT)
    170           * @param   mode: See MODE_TYPE
    171           */

   \                                 In section .text, align 2, keep-with-next
    172          void Mode__SetMode(MODE_TYPE mode)
    173          {
    174              if (Mode != mode)
   \                     Mode__SetMode: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable15
   \   00000002   0x788A             LDRB     R2,[R1, #+2]
   \   00000004   0x4282             CMP      R2,R0
   \   00000006   0xD007             BEQ.N    ??Mode__SetMode_0
    175              {
    176                  Mode = mode;
    177                  N_Mode = (uint8)(~mode);
                                          ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \   00000008   0x43C2             MVNS     R2,R0
   \   0000000A   0x7088             STRB     R0,[R1, #+2]
   \   0000000C   0x710A             STRB     R2,[R1, #+4]
    178          
    179                  if (mode != MODE_SETTINGFILE_NOT_CONSISTENT)
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xBF1C             ITT      NE 
    180                  {
    181                      SRMicro__ForceReset(MICRO_RESET_MODE_WARM);
   \   00000012   0x2001             MOVNE    R0,#+1
   \   00000014   0x.... 0x....      BNE.W    Micro__ForceReset
    182                  }
    183              }
    184          }
   \                     ??Mode__SetMode_0: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    185          
    186          //---------------------------------------------------------------------------------------------------------------------
    187          /**
    188           *
    189           * @param mode
    190           * @param sub_mode
    191           */

   \                                 In section .text, align 2, keep-with-next
    192          void Mode__SetModeExtended(MODE_TYPE mode, SUBMODE_TYPE sub_mode)
    193          {
    194              if (Mode != mode)
   \                     Mode__SetModeExtended: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable15
   \   00000002   0x7893             LDRB     R3,[R2, #+2]
   \   00000004   0x4283             CMP      R3,R0
   \   00000006   0xD008             BEQ.N    ??Mode__SetModeExtended_0
    195              {
    196                  Mode = mode;
    197                  N_Mode = (uint8)(~mode);
                                          ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \   00000008   0x43C3             MVNS     R3,R0
   \   0000000A   0x7090             STRB     R0,[R2, #+2]
   \   0000000C   0x7113             STRB     R3,[R2, #+4]
    198                  Requested_Sub_Mode = sub_mode;
   \   0000000E   0x7151             STRB     R1,[R2, #+5]
    199                  if (mode != MODE_SETTINGFILE_NOT_CONSISTENT)
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xD003             BEQ.N    ??Mode__SetModeExtended_1
    200                  {
    201                      SRMicro__ForceReset(MICRO_RESET_MODE_WARM);
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x.... 0x....      B.W      Micro__ForceReset
    202                  }
    203              }
    204              else
    205              {
    206                  Requested_Sub_Mode = sub_mode;
   \                     ??Mode__SetModeExtended_0: (+1)
   \   0000001A   0x7151             STRB     R1,[R2, #+5]
    207              }
    208          }
   \                     ??Mode__SetModeExtended_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
    209          
    210          //---------------------------------------------------------------------------------------------------------------------
    211          /**
    212           * @brief   Get the current mode of the machine.
    213           * @return  See MODE_TYPE.
    214           */

   \                                 In section .text, align 2, keep-with-next
    215          MODE_TYPE Mode__GetMode(void)
    216          {
    217              return (Mode);
   \                     Mode__GetMode: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15
   \   00000002   0x7880             LDRB     R0,[R0, #+2]
   \   00000004   0x4770             BX       LR               ;; return
    218          }
    219          
    220          //---------------------------------------------------------------------------------------------------------------------
    221          /**
    222           * @brief   Get the current sub-mode of the machine.
    223           * @return  See SUBMODE_TYPE.
    224           */

   \                                 In section .text, align 2, keep-with-next
    225          SUBMODE_TYPE Mode__GetSubMode(void)
    226          {
    227              static const SUBMODE_TYPE SUBMODE_STATE_MAP[] =
    228              {
    229                  SUBMODE_NORMAL_SUPERVISOR,              // STATE_SUB_MODE_NONE
    230                  SUBMODE_NORMAL_SUPERVISOR,              // STATE_SUB_MODE_INITIALIZE
    231                  SUBMODE_NORMAL_SUPERVISOR,              // STATE_SUB_MODE_NORMAL_SUPERVISOR
    232                  SUBMODE_NORMAL_ERROR,                   // STATE_SUB_MODE_ERROR
    233                  SUBMODE_NORMAL_EXT_CONTROL_ENTERING,    // STATE_SUB_MODE_NORMAL_EXT_CONTROL_ENTERING
    234                  SUBMODE_NORMAL_EXT_CONTROL_ENGAGED      // STATE_SUB_MODE_NORMAL_EXT_CONTROL_ENGAGED
    235              };
    236              CT_ASSERT((sizeof(SUBMODE_STATE_MAP) / sizeof(SUBMODE_TYPE)) == STATE_SUB_MODE_END);
    237              return (SUBMODE_STATE_MAP[Sub_Mode_State]);
   \                     Mode__GetSubMode: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable15
   \   00000002   0x.... 0x....      ADR.W    R0,??SUBMODE_STATE_MAP
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x5C08             LDRB     R0,[R1, R0]
   \   0000000A   0x4770             BX       LR               ;; return
    238          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??SUBMODE_STATE_MAP:
   \   00000000   0x01 0x01          DC8 1, 1, 1, 2, 3, 4, 0, 0
   \              0x01 0x02    
   \              0x03 0x04    
   \              0x00 0x00    
    239          
    240          //---------------------------------------------------------------------------------------------------------------------
    241          /**
    242           * @brief   Background tasks for the module.
    243           */

   \                                 In section .text, align 2, keep-with-next
    244          void Mode__Handler(void)
    245          {
   \                     Mode__Handler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    246              switch (Mode)
   \   00000002   0x....             LDR.N    R4,??DataTable15
   \   00000004   0x78A0             LDRB     R0,[R4, #+2]
   \   00000006   0xB118             CBZ.N    R0,??Mode__Handler_0
   \   00000008   0x1E40             SUBS     R0,R0,#+1
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD924             BLS.N    ??Mode__Handler_1
   \   0000000E   0xE027             B.N      ??Mode__Handler_2
    247              {
    248                  case MODE_NORMAL:
    249                      SubModeExecute();
   \                     ??Mode__Handler_0: (+1)
   \   00000010   0x7060             STRB     R0,[R4, #+1]
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0x1E40             SUBS     R0,R0,#+1
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD91B             BLS.N    ??Mode__Handler_3
   \   0000001A   0x1EC0             SUBS     R0,R0,#+3
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD824             BHI.N    ??Mode__Handler_4
   \   00000020   0x88E0             LDRH     R0,[R4, #+6]
   \   00000022   0x.... 0x....      BL       SystemTimers__GetState
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD011             BEQ.N    ??Mode__Handler_5
   \   0000002A   0x7820             LDRB     R0,[R4, #+0]
   \   0000002C   0x1F00             SUBS     R0,R0,#+4
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD80D             BHI.N    ??Mode__Handler_5
   \   00000032   0x88E0             LDRH     R0,[R4, #+6]
   \   00000034   0x.... 0x....      BL       SystemTimers__ReleaseHandle
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0x7020             STRB     R0,[R4, #+0]
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x7060             STRB     R0,[R4, #+1]
   \   00000040   0x2005             MOVS     R0,#+5
   \   00000042   0x7160             STRB     R0,[R4, #+5]
   \   00000044   0x.... 0x....      BL       API011AppCtrl__PubMode
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0x7060             STRB     R0,[R4, #+1]
    250                      break;
    251                  case MODE_PROGRAMMING:
    252                  case MODE_SETTINGFILE_NOT_CONSISTENT:
    253                  case MODE_LOWPOWER:
    254                      #if (SYSTEM_ACU_HANDLING == DISABLED) && (SYSTEM_HMI_HANDLING == DISABLED)
    255                          // Modes not handled on a pure expansion board
    256                          SubModeInitialize();
    257                      #endif
    258                      break;
   \   0000004C   0xBD10             POP      {R4,PC}
   \                     ??Mode__Handler_5: (+1)
   \   0000004E   0x7860             LDRB     R0,[R4, #+1]
   \   00000050   0xB958             CBNZ.N   R0,??Mode__Handler_4
   \                     ??Mode__Handler_3: (+1)
   \   00000052   0xE8BD 0x4010      POP      {R4,LR}
   \   00000056   0x....             B.N      HandleRequestedSubMode
   \                     ??Mode__Handler_1: (+1)
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x7020             STRB     R0,[R4, #+0]
   \   0000005C   0x7060             STRB     R0,[R4, #+1]
   \   0000005E   0xBD10             POP      {R4,PC}
    259                  default:
    260                      SRMicro__ForceReset(MICRO_RESET_MODE_COLD);
   \                     ??Mode__Handler_2: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xE8BD 0x4010      POP      {R4,LR}
   \   00000066   0x.... 0x....      B.W      Micro__ForceReset
    261                      break;
    262              }
    263          }
   \                     ??Mode__Handler_4: (+1)
   \   0000006A   0xBD10             POP      {R4,PC}          ;; return
    264          
    265          //---------------------------------------------------------------------------------------------------------------------
    266          /**
    267           *
    268           * @param heartbeat_code
    269           */

   \                                 In section .text, align 2, keep-with-next
    270          void Mode__SpecialHeartBeat(MODE_SPECIAL_HEARTBEAT_TYPE heartbeat_code)
                                                                         ^
Remark[Pe826]: parameter "heartbeat_code" was never referenced
    271          {
    272              if (Mode__IsPCControlEngaged() == TRUE)
   \                     Mode__SpecialHeartBeat: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15
   \   00000002   0x7881             LDRB     R1,[R0, #+2]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xBF01             ITTTT    EQ 
   \   00000008   0x.... 0x....      ADREQ.W  R1,??SUBMODE_STATE_MAP
   \   0000000C   0x7802             LDRBEQ   R2,[R0, #+0]
   \   0000000E   0x5C51             LDRBEQ   R1,[R2, R1]
   \   00000010   0x2904             CMPEQ    R1,#+4
   \   00000012   0xD104             BNE.N    ??Mode__SpecialHeartBeat_0
    273              {
    274                  SetTimer();
   \   00000014   0x88C0             LDRH     R0,[R0, #+6]
   \   00000016   0xF247 0x5130      MOVW     R1,#+30000
   \   0000001A   0x.... 0x....      B.W      SystemTimers__SetMs
    275              }
    276          }
   \                     ??Mode__SpecialHeartBeat_0: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    277          
    278          //---------------------------------------------------------------------------------------------------------------------
    279          /**
    280           *  @brief  Determines if the Mode and Sub-Mode have the values that indicate the product is engaged in PC control
    281           *  @return True if PC Control is engaged, else FALSE
    282           */

   \                                 In section .text, align 2, keep-with-next
    283          BOOL_TYPE Mode__IsPCControlEngaged(void)
    284          {
    285              return (((Mode == MODE_NORMAL) && (Mode__GetSubMode() == SUBMODE_NORMAL_EXT_CONTROL_ENGAGED)) ? TRUE : FALSE);
   \                     Mode__IsPCControlEngaged: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15
   \   00000002   0x7881             LDRB     R1,[R0, #+2]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xBF01             ITTTT    EQ 
   \   00000008   0x.... 0x....      ADREQ.W  R1,??SUBMODE_STATE_MAP
   \   0000000C   0x7800             LDRBEQ   R0,[R0, #+0]
   \   0000000E   0x5C40             LDRBEQ   R0,[R0, R1]
   \   00000010   0x2804             CMPEQ    R0,#+4
   \   00000012   0xD101             BNE.N    ??Mode__IsPCControlEngaged_0
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x4770             BX       LR
   \                     ??Mode__IsPCControlEngaged_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
    286          }
    287          
    288          //---------------------------------------------------------------------------------------------------------------------
    289          /**
    290           * @brief This method exposes if the board is in programming allowed mode
    291           * @return BOOL_TYPE
    292           *    @retval TRUE - Programming allowed .
    293           *    @retval FALSE - Programming not allowed .
    294           */

   \                                 In section .text, align 2, keep-with-next
    295          BOOL_TYPE Mode__IsProgrammingEngaged(void)
   \                     Mode__IsProgrammingEngaged: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15
   \   00000002   0x7880             LDRB     R0,[R0, #+2]
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xBF18             IT       NE 
   \   00000008   0x2802             CMPNE    R0,#+2
   \   0000000A   0xD101             BNE.N    ??Mode__IsProgrammingEngaged_0
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x4770             BX       LR
   \                     ??Mode__IsProgrammingEngaged_0: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
    296          {
    297              return (((Mode == MODE_PROGRAMMING) || (Mode == MODE_SETTINGFILE_NOT_CONSISTENT)) ? TRUE : FALSE);
    298          }
    299          
    300          //---------------------------------------------------------------------------------------------------------------------
    301          /**
    302           *  @brief  Saves the remote mode
    303           *  @param  mode: the remote mode to save
    304           */

   \                                 In section .text, align 2, keep-with-next
    305          void Mode__SaveRemoteMode(MODE_TYPE mode)
    306          {
    307              Remote_Mode = mode;
   \                     Mode__SaveRemoteMode: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable15
   \   00000002   0x70C8             STRB     R0,[R1, #+3]
    308          }
   \   00000004   0x4770             BX       LR               ;; return
    309          
    310          //---------------------------------------------------------------------------------------------------------------------
    311          /**
    312           *  @brief  Get the current remote mode
    313           *  @return Returns the current remote mode
    314           */

   \                                 In section .text, align 2, keep-with-next
    315          MODE_TYPE Mode__GetRemoteMode(void)
    316          {
    317              return (Remote_Mode);
   \                     Mode__GetRemoteMode: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15
   \   00000002   0x78C0             LDRB     R0,[R0, #+3]
   \   00000004   0x4770             BX       LR               ;; return
    318          }
    319          
    320          //---------------------------------------------------------------------------------------------------------------------
    321          /**
    322           *  @brief  Saves the remote Sub Mode
    323           *  @param  submode: the Sub Mode to save
    324           */

   \                                 In section .text, align 2, keep-with-next
    325          void Mode__SaveRemoteSubMode(SUBMODE_TYPE submode)
    326          {
    327              Remote_SubMode = submode;
   \                     Mode__SaveRemoteSubMode: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable15_1
   \   00000002   0x7008             STRB     R0,[R1, #+0]
    328          }
   \   00000004   0x4770             BX       LR               ;; return
    329          
    330          //---------------------------------------------------------------------------------------------------------------------
    331          /**
    332           *  @brief  Get the current remote Sub Mode
    333           *  @return Returns the current remote Sub Mode
    334           */

   \                                 In section .text, align 2, keep-with-next
    335          SUBMODE_TYPE Mode__GetRemoteSubMode(void)
    336          {
    337              return (Remote_SubMode);
   \                     Mode__GetRemoteSubMode: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15_1
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    338          }
    339          
    340          //=====================================================================================================================
    341          //-------------------------------------- Private Functions ------------------------------------------------------------
    342          //=====================================================================================================================
    343          
    344          //=====================================================================================================================
    345          //  --- Private State Machine Customization Functions -----------------------------------------------------------------
    346          //=====================================================================================================================
    347          
    348          
    349          //---------------------------------------------------------------------------------------------------------------------
    350          /**
    351           *  Handles enabling the system timer.
    352           *
    353           *  @return TRUE    = conditions for entering sub mode have been met
    354           *  @return FALSE   = cannot enter requested sub mode
    355           */
    356          static BOOL_TYPE EnableSystemTimer(void)
    357          {
    358              BOOL_TYPE ret_val = FALSE;
    359              Timer_PC_Control_Handle = SystemTimers__GetHandle(SYSTEMTIMERS_TYPE_DOWN_COUNTER);
    360              if (Timer_PC_Control_Handle != SYSTEMTIMERS_FAIL)
    361              {
    362                  SystemTimers__SetMs(Timer_PC_Control_Handle, SUB_MODE_EXT_ENTERING_TIMEOUT);
    363                  ret_val = TRUE;
    364              }
    365              else
    366              {
    367                  LOG_ADD_EXCEPTION(INVALID_SYSTEM_TIMER, Timer_PC_Control_Handle);
    368              }
    369              return (ret_val);
    370          }
    371          
    372          
    373          //---------------------------------------------------------------------------------------------------------------------
    374          /**
    375           *  Handles the static variable Requested_Sub_Mode.
    376           */

   \                                 In section .text, align 4, keep-with-next
    377          static void HandleRequestedSubMode(void)
    378          {
   \                     HandleRequestedSubMode: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    379              switch ( Requested_Sub_Mode )
   \   00000002   0x....             LDR.N    R4,??DataTable15
   \   00000004   0x7960             LDRB     R0,[R4, #+5]
   \   00000006   0x2804             CMP      R0,#+4
   \   00000008   0xD837             BHI.N    ??HandleRequestedSubMode_1
   \   0000000A   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??HandleRequestedSubMode_0:
   \   0000000E   0x33 0x33          DC8      0x33,0x33,0x3,0xC
   \              0x03 0x0C    
   \   00000012   0x20 0x00          DC8      0x20,0x0
    380              {
    381                  case SUBMODE_NORMAL_SUPERVISOR:
    382                      EventReqSubModeSupervisor();
    383                      break;
    384                  case SUBMODE_NORMAL_ERROR:
    385                      EventReqSubModeError();
   \                     ??HandleRequestedSubMode_2: (+1)
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD82E             BHI.N    ??HandleRequestedSubMode_1
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0x7020             STRB     R0,[R4, #+0]
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x7060             STRB     R0,[R4, #+1]
   \   00000024   0xBD10             POP      {R4,PC}
    386                      break;
    387                  case SUBMODE_NORMAL_EXT_CONTROL_ENTERING:
    388                      EventReqSubModeExtControlEntering();
   \                     ??HandleRequestedSubMode_3: (+1)
   \   00000026   0x7820             LDRB     R0,[R4, #+0]
   \   00000028   0x2802             CMP      R0,#+2
   \   0000002A   0xD126             BNE.N    ??HandleRequestedSubMode_1
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x.... 0x....      BL       SystemTimers__GetHandle
   \   00000032   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000036   0x80E0             STRH     R0,[R4, #+6]
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD01E             BEQ.N    ??HandleRequestedSubMode_1
   \   0000003C   0xF241 0x3188      MOVW     R1,#+5000
   \   00000040   0x.... 0x....      BL       SystemTimers__SetMs
   \   00000044   0x2004             MOVS     R0,#+4
   \   00000046   0x7020             STRB     R0,[R4, #+0]
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0x7060             STRB     R0,[R4, #+1]
   \   0000004C   0xBD10             POP      {R4,PC}
    389                      break;
    390                  case SUBMODE_NORMAL_EXT_CONTROL_ENGAGED:
    391                      EventReqSubModeExtControlEngaged();
   \                     ??HandleRequestedSubMode_4: (+1)
   \   0000004E   0x7820             LDRB     R0,[R4, #+0]
   \   00000050   0x2804             CMP      R0,#+4
   \   00000052   0xD112             BNE.N    ??HandleRequestedSubMode_1
   \   00000054   0x2005             MOVS     R0,#+5
   \   00000056   0x7020             STRB     R0,[R4, #+0]
   \   00000058   0xF247 0x5130      MOVW     R1,#+30000
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x7060             STRB     R0,[R4, #+1]
   \   00000060   0x88E0             LDRH     R0,[R4, #+6]
   \   00000062   0x.... 0x....      BL       SystemTimers__SetMs
   \   00000066   0x7860             LDRB     R0,[R4, #+1]
   \   00000068   0xB908             CBNZ.N   R0,??HandleRequestedSubMode_5
   \   0000006A   0x.... 0x....      BL       API011AppCtrl__PubMode
   \                     ??HandleRequestedSubMode_5: (+1)
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0x7060             STRB     R0,[R4, #+1]
   \   00000072   0xBD10             POP      {R4,PC}
    392                      break;
    393                  case SUBMODE_NORMAL_INITIALIZE:
    394                      EventReqSubModeSupervisor();
   \                     ??HandleRequestedSubMode_6: (+1)
   \   00000074   0xE8BD 0x4010      POP      {R4,LR}
   \   00000078   0x....             B.N      EventReqSubModeSupervisor
    395                      break;
    396                  default:
    397                      // do nothing
    398                      break;
    399              }
    400          }
   \                     ??HandleRequestedSubMode_1: (+1)
   \   0000007A   0xBD10             POP      {R4,PC}          ;; return
    401          
    402          
    403          //---------------------------------------------------------------------------------------------------------------------
    404          /**
    405           *  Publishes the current Mode to Reveal.
    406           */
    407          static void PublishMode(void)
    408          {
    409              API011AppCtrl__PubMode();   // Main ACU/HMI publishes mode change
    410          }
    411          
    412          
    413          //---------------------------------------------------------------------------------------------------------------------
    414          /**
    415           *  Releases the system timer.
    416           */
    417          static void ReleaseSystemTimer(void)
    418          {
    419              SystemTimers__ReleaseHandle(Timer_PC_Control_Handle);
    420          }
    421          
    422          
    423          //---------------------------------------------------------------------------------------------------------------------
    424          /**
    425           *
    426           */
    427          static void SetReqSubModeNone(void)
    428          {
    429              Requested_Sub_Mode = SUBMODE_NONE;
    430          }
    431          
    432          
    433          //---------------------------------------------------------------------------------------------------------------------
    434          /**
    435           *  Sets the system timer to keep external control sub mode enabled.
    436           */
    437          static void SetTimer(void)
    438          {
    439              SystemTimers__SetMs(Timer_PC_Control_Handle, SUB_MODE_EXT_ENGAGED_TIMEOUT);
    440          }
    441          
    442          //---------------------------------------------------------------------------------------------------------------------
    443          /**
    444           *  Verifies the system timer is still running.
    445           */
    446          static void VerifyTimerIsRunning(void)
    447          {
    448              if (SystemTimers__GetState(Timer_PC_Control_Handle) != SYSTEMTIMERS_STATE_RUNNING)
    449              {
    450                  EventTimerExpired();
    451              }
    452          }
    453          
    454          
    455          //---------------------------------------------------------------------------------------------------------------------
    456          /**
    457           * @brief   Determines if the requested sub mode is ERROR or not
    458           * @return  TRUE if the requested sub mode is ERROR, else FALSE
    459           */
    460          static BOOL_TYPE IsReqSubModeError(void)
    461          {
    462              return ((BOOL_TYPE)(Requested_Sub_Mode == SUBMODE_NORMAL_ERROR));
    463          }
    464          
    465          
    466          //---------------------------------------------------------------------------------------------------------------------
    467          /**
    468           * @brief   Determines if the requested sub mode is INITIALIZE or not
    469           * @return  TRUE if the requested sub mode is INITIALIZE, else FALSE
    470           */
    471          static BOOL_TYPE IsReqSubModeInitialize(void)
    472          {
    473              return ((BOOL_TYPE)(Requested_Sub_Mode == SUBMODE_NORMAL_INITIALIZE));
    474          }
    475          
    476          
    477          //=====================================================================================================================
    478          //=== StateEngineCrank (v2.8) Auto-Generated Functions for Sub Mode State Machine
    479          //=====================================================================================================================
    480          // !! StateEngineCrank cannot update this code if you change the header !!
    481          
    482          
    483          //---------------------------------------------------------------------------------------------------------------------
    484          /**
    485           * Process the Req Sub Mode Error Event for the Sub Mode state machine.
    486           *
    487           *              >>> DO NOT MODIFY THIS FUNCTION <<<
    488           *
    489           * This function was auto-generated and must not be edited manually.
    490           * Change the UML used to generate this function and regenerate the source code.
    491           */
    492          static void EventReqSubModeError(void)
    493          {
    494              switch (Sub_Mode_State)
    495              {
    496                  case STATE_SUB_MODE_INITIALIZE:
    497                      if (IsReqSubModeError() == TRUE)
    498                      {
    499                          Sub_Mode_State = STATE_SUB_MODE_ERROR;
    500                          Sub_Mode_Transitioned = TRUE;
    501                      }
    502                      break;
    503          
    504                  case STATE_SUB_MODE_NORMAL_SUPERVISOR:
    505                      Sub_Mode_State = STATE_SUB_MODE_ERROR;
    506                      Sub_Mode_Transitioned = TRUE;
    507                      break;
    508          
    509                  default:
    510                      // Event is ignored for all other values of Sub_Mode_State.
    511                      break;
    512              }
    513          }
    514          
    515          
    516          //---------------------------------------------------------------------------------------------------------------------
    517          /**
    518           * Process the Req Sub Mode Ext Control Engaged Event for the Sub Mode state machine.
    519           *
    520           *              >>> DO NOT MODIFY THIS FUNCTION <<<
    521           *
    522           * This function was auto-generated and must not be edited manually.
    523           * Change the UML used to generate this function and regenerate the source code.
    524           */
    525          static void EventReqSubModeExtControlEngaged(void)
    526          {
    527              switch (Sub_Mode_State)
    528              {
    529                  case STATE_SUB_MODE_NORMAL_EXT_CONTROL_ENTERING:
    530                      Sub_Mode_State = STATE_SUB_MODE_NORMAL_EXT_CONTROL_ENGAGED;
    531                      Sub_Mode_Transitioned = FALSE;
    532                      SetTimer();                             // Entry Function.
    533                      if (Sub_Mode_Transitioned == FALSE)
    534                      {
    535                          PublishMode();                      // Entry Function.
    536                      }
    537                      Sub_Mode_Transitioned = TRUE;
    538                      break;
    539          
    540                  default:
    541                      // Event is ignored for all other values of Sub_Mode_State.
    542                      break;
    543              }
    544          }
    545          
    546          
    547          //---------------------------------------------------------------------------------------------------------------------
    548          /**
    549           * Process the Req Sub Mode Ext Control Entering Event for the Sub Mode state machine.
    550           *
    551           *              >>> DO NOT MODIFY THIS FUNCTION <<<
    552           *
    553           * This function was auto-generated and must not be edited manually.
    554           * Change the UML used to generate this function and regenerate the source code.
    555           */
    556          static void EventReqSubModeExtControlEntering(void)
    557          {
    558              switch (Sub_Mode_State)
    559              {
    560                  case STATE_SUB_MODE_NORMAL_SUPERVISOR:
    561                      if (EnableSystemTimer() == TRUE)
    562                      {
    563                          Sub_Mode_State = STATE_SUB_MODE_NORMAL_EXT_CONTROL_ENTERING;
    564                          Sub_Mode_Transitioned = TRUE;
    565                      }
    566                      break;
    567          
    568                  default:
    569                      // Event is ignored for all other values of Sub_Mode_State.
    570                      break;
    571              }
    572          }
    573          
    574          
    575          //---------------------------------------------------------------------------------------------------------------------
    576          /**
    577           * Process the Req Sub Mode Supervisor Event for the Sub Mode state machine.
    578           *
    579           *              >>> DO NOT MODIFY THIS FUNCTION <<<
    580           *
    581           * This function was auto-generated and must not be edited manually.
    582           * Change the UML used to generate this function and regenerate the source code.
    583           */

   \                                 In section .text, align 4, keep-with-next
    584          static void EventReqSubModeSupervisor(void)
    585          {
   \                     EventReqSubModeSupervisor: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    586              switch (Sub_Mode_State)
   \   00000002   0x....             LDR.N    R4,??DataTable15
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x1E40             SUBS     R0,R0,#+1
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD814             BHI.N    ??EventReqSubModeSupervisor_1
   \   0000000C   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??EventReqSubModeSupervisor_0:
   \   00000010   0x03 0x0B          DC8      0x3,0xB,0x13,0x6
   \              0x13 0x06    
   \   00000014   0x06 0x00          DC8      0x6,0x0
    587              {
    588                  case STATE_SUB_MODE_INITIALIZE:
    589                      if (IsReqSubModeInitialize() == TRUE)
   \                     ??EventReqSubModeSupervisor_2: (+1)
   \   00000016   0x7960             LDRB     R0,[R4, #+5]
   \   00000018   0xB968             CBNZ.N   R0,??EventReqSubModeSupervisor_1
    590                      {
    591                          Sub_Mode_State = STATE_SUB_MODE_NORMAL_SUPERVISOR;
   \   0000001A   0xE002             B.N      ??EventReqSubModeSupervisor_3
    592                          Sub_Mode_Transitioned = FALSE;
    593                          SetReqSubModeNone();                // Entry Function.
    594                          if (Sub_Mode_Transitioned == FALSE)
    595                          {
    596                              PublishMode();                  // Entry Function.
    597                          }
    598                          Sub_Mode_Transitioned = TRUE;
    599                      }
    600                      break;
    601          
    602                  case STATE_SUB_MODE_NORMAL_SUPERVISOR:
    603                      Sub_Mode_State = STATE_SUB_MODE_NORMAL_SUPERVISOR;
    604                      Sub_Mode_Transitioned = FALSE;
    605                      SetReqSubModeNone();                    // Entry Function.
    606                      if (Sub_Mode_Transitioned == FALSE)
    607                      {
    608                          PublishMode();                      // Entry Function.
    609                      }
    610                      Sub_Mode_Transitioned = TRUE;
    611                      break;
    612          
    613                  case STATE_SUB_MODE_NORMAL_EXT_CONTROL_ENTERING:
    614                      ReleaseSystemTimer();                   // Transition action function.
    615                      Sub_Mode_State = STATE_SUB_MODE_NORMAL_SUPERVISOR;
    616                      Sub_Mode_Transitioned = FALSE;
    617                      SetReqSubModeNone();                    // Entry Function.
    618                      if (Sub_Mode_Transitioned == FALSE)
    619                      {
    620                          PublishMode();                      // Entry Function.
    621                      }
    622                      Sub_Mode_Transitioned = TRUE;
    623                      break;
    624          
    625                  case STATE_SUB_MODE_NORMAL_EXT_CONTROL_ENGAGED:
    626                      ReleaseSystemTimer();                   // Exit function.
   \                     ??EventReqSubModeSupervisor_4: (+1)
   \   0000001C   0x88E0             LDRH     R0,[R4, #+6]
   \   0000001E   0x.... 0x....      BL       SystemTimers__ReleaseHandle
    627                      Sub_Mode_State = STATE_SUB_MODE_NORMAL_SUPERVISOR;
   \                     ??EventReqSubModeSupervisor_3: (+1)
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0x7020             STRB     R0,[R4, #+0]
    628                      Sub_Mode_Transitioned = FALSE;
   \                     ??EventReqSubModeSupervisor_5: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x7060             STRB     R0,[R4, #+1]
    629                      SetReqSubModeNone();                    // Entry Function.
   \   0000002A   0x2005             MOVS     R0,#+5
   \   0000002C   0x7160             STRB     R0,[R4, #+5]
    630                      if (Sub_Mode_Transitioned == FALSE)
    631                      {
    632                          PublishMode();                      // Entry Function.
   \   0000002E   0x.... 0x....      BL       API011AppCtrl__PubMode
    633                      }
    634                      Sub_Mode_Transitioned = TRUE;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x7060             STRB     R0,[R4, #+1]
    635                      break;
    636          
    637                  default:
    638                      // Event is ignored for all other values of Sub_Mode_State.
    639                      break;
    640              }
    641          }
   \                     ??EventReqSubModeSupervisor_1: (+1)
   \   00000036   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     Sub_Mode_State

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     Remote_SubMode
    642          
    643          
    644          //---------------------------------------------------------------------------------------------------------------------
    645          /**
    646           * Process the Timer Expired Event for the Sub Mode state machine.
    647           *
    648           *              >>> DO NOT MODIFY THIS FUNCTION <<<
    649           *
    650           * This function was auto-generated and must not be edited manually.
    651           * Change the UML used to generate this function and regenerate the source code.
    652           */
    653          static void EventTimerExpired(void)
    654          {
    655              switch (Sub_Mode_State)
    656              {
    657                  case STATE_SUB_MODE_NORMAL_EXT_CONTROL_ENTERING:
    658                      ReleaseSystemTimer();                   // Transition action function.
    659                      Sub_Mode_State = STATE_SUB_MODE_NORMAL_SUPERVISOR;
    660                      Sub_Mode_Transitioned = FALSE;
    661                      SetReqSubModeNone();                    // Entry Function.
    662                      if (Sub_Mode_Transitioned == FALSE)
    663                      {
    664                          PublishMode();                      // Entry Function.
    665                      }
    666                      Sub_Mode_Transitioned = TRUE;
    667                      break;
    668          
    669                  case STATE_SUB_MODE_NORMAL_EXT_CONTROL_ENGAGED:
    670                      ReleaseSystemTimer();                   // Exit function.
    671                      Sub_Mode_State = STATE_SUB_MODE_NORMAL_SUPERVISOR;
    672                      Sub_Mode_Transitioned = FALSE;
    673                      SetReqSubModeNone();                    // Entry Function.
    674                      if (Sub_Mode_Transitioned == FALSE)
    675                      {
    676                          PublishMode();                      // Entry Function.
    677                      }
    678                      Sub_Mode_Transitioned = TRUE;
    679                      break;
    680          
    681                  default:
    682                      // Event is ignored for all other values of Sub_Mode_State.
    683                      break;
    684              }
    685          }
    686          
    687          
    688          //---------------------------------------------------------------------------------------------------------------------
    689          /**
    690           * The main execution function for the Sub Mode state machine.
    691           * This function should be called periodically while the state machine is running.
    692           *
    693           *              >>> DO NOT MODIFY THIS FUNCTION <<<
    694           *
    695           * This function was auto-generated and must not be edited manually.
    696           * Change the UML used to generate this function and regenerate the source code.
    697           */
    698          static void SubModeExecute(void)
    699          {
    700              Sub_Mode_Transitioned = FALSE;
    701              switch(Sub_Mode_State)
    702              {
    703                  case STATE_SUB_MODE_INITIALIZE:
    704                  case STATE_SUB_MODE_NORMAL_SUPERVISOR:
    705                      HandleRequestedSubMode();               // Do function.
    706                      break;
    707          
    708                  case STATE_SUB_MODE_NORMAL_EXT_CONTROL_ENTERING:
    709                  case STATE_SUB_MODE_NORMAL_EXT_CONTROL_ENGAGED:
    710                      VerifyTimerIsRunning();                 // Do function.
    711                      if (Sub_Mode_Transitioned == FALSE)
    712                      {
    713                          HandleRequestedSubMode();           // Do function.
    714                      }
    715                      break;
    716          
    717                  default:
    718                      // There is nothing to do for all other values of Sub_Mode_State.
    719                      break;
    720              }
    721          }
    722          
    723          
    724          //---------------------------------------------------------------------------------------------------------------------
    725          /**
    726           * The initialization function for the Sub Mode state machine.
    727           * This function resets the state machine to the initial state.
    728           *
    729           *              >>> DO NOT MODIFY THIS FUNCTION <<<
    730           *
    731           * This function was auto-generated and must not be edited manually.
    732           * Change the UML used to generate this function and regenerate the source code.
    733           */
    734          static void SubModeInitialize(void)
    735          {
    736              Sub_Mode_State = STATE_SUB_MODE_INITIALIZE;
    737              Sub_Mode_Transitioned = TRUE;
    738          }
    739          
    740          
    741          // !! StateEngineCrank cannot update this code if you change the footer !!
    742          // End of StateEngineCrank Auto-Generated Code.

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   EventReqSubModeSupervisor
         8   -> API011AppCtrl__PubMode
         8   -> SystemTimers__ReleaseHandle
       8   HandleRequestedSubMode
         8   -> API011AppCtrl__PubMode
         0   -> EventReqSubModeSupervisor
         8   -> SystemTimers__GetHandle
         8   -> SystemTimers__SetMs
       0   Mode__GetMode
       0   Mode__GetRemoteMode
       0   Mode__GetRemoteSubMode
       0   Mode__GetSubMode
       8   Mode__Handler
         8   -> API011AppCtrl__PubMode
         0   -> HandleRequestedSubMode
         0   -> Micro__ForceReset
         8   -> SystemTimers__GetState
         8   -> SystemTimers__ReleaseHandle
       8   Mode__Initialize
         8   -> Micro__GetResetMode
       0   Mode__IsPCControlEngaged
       0   Mode__IsProgrammingEngaged
       0   Mode__SaveRemoteMode
       0   Mode__SaveRemoteSubMode
       0   Mode__SetMode
         0   -> Micro__ForceReset
       0   Mode__SetModeExtended
         0   -> Micro__ForceReset
       0   Mode__SpecialHeartBeat
         0   -> SystemTimers__SetMs


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
      56  EventReqSubModeSupervisor
     124  HandleRequestedSubMode
       6  Mode__GetMode
       6  Mode__GetRemoteMode
       6  Mode__GetRemoteSubMode
      12  Mode__GetSubMode
     108  Mode__Handler
      64  Mode__Initialize
      28  Mode__IsPCControlEngaged
      20  Mode__IsProgrammingEngaged
       6  Mode__SaveRemoteMode
       6  Mode__SaveRemoteSubMode
      26  Mode__SetMode
      30  Mode__SetModeExtended
      32  Mode__SpecialHeartBeat
       1  Remote_SubMode
       8  SUBMODE_STATE_MAP
       8  Sub_Mode_State
          Sub_Mode_Transitioned
          Mode
          Remote_Mode
          N_Mode
          Requested_Sub_Mode
          Timer_PC_Control_Handle

 
   9 bytes in section .bss
 546 bytes in section .text
 
 546 bytes of CODE memory
   9 bytes of DATA memory

Errors: none
Warnings: none
