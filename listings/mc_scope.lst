###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        13/Mar/2025  15:31:20
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  Category\Common\MasterCommander\Source\mc_scope.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        mc_scope.obj -l ..\listings\mc_scope.lst
#        Category\Common\MasterCommander\Source\mc_scope.c
#    List file    =  ..\listings\mc_scope.lst
#    Object file  =  mc_scope.obj
#
###############################################################################

C:\Data\Repository\WindyStrip_DTC_Orca\source\Category\Common\MasterCommander\Source\mc_scope.c
      1          /**
      2           *  @file
      3           *
      4           *  @brief      MC Oscilloscope implementation.
      5           *
      6           *
      7           *  $Header: $
      8           *
      9           *  @copyright  Copyright 2016-$Date$. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     10           */
     11          //---------------------------------------------------------------------------------------------------------------------
     12          
     13          //-------------------------------------- Include Files ----------------------------------------------------------------
     14          #include "master_commander.h"
     15          #include "mc_llmem.h"
     16          #include "mc_private.h"
     17          #include "mc_protocol.h"
     18          
     19          #if (MC_USE_SCOPE) && (!(MC_DISABLE))
     20          
     21          /***********************************
     22          *  local variables 
     23          ***********************************/
     24          

   \                                 In section .bss, align 4
     25          static MC_U8  pcm_nScopeVarCount;        /* number of active scope variables */
   \                     pcm_nScopeVarCount:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \   00000004                      DS8 32
   \   00000024                      DS8 8
     26          static MC_ADDR  pcm_pScopeVarAddr[MC_MAX_SCOPE_VARS]; /* addresses of scope variables */
     27          static MC_SIZE8 pcm_pScopeVarSize[MC_MAX_SCOPE_VARS]; /* sizes of scope variables */
     28          
     29          /**************************************************************************//*!
     30          *
     31          * @brief    Scope Initialization
     32          *
     33          ******************************************************************************/
     34          

   \                                 In section .text, align 2, keep-with-next
     35          void MC_InitScope(void)
     36          {   
     37          }
   \                     MC_InitScope: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     38          
     39          /**************************************************************************//*!
     40          *
     41          * @brief    Handling SETUPSCOPE and SETUPSCOPE_EX command
     42          *
     43          * @param    pMessageIO - original command (in) and response buffer (out) 
     44          *
     45          * @return   As all command handlers, the return value should be the buffer 
     46          *           pointer where the response output finished (except checksum)
     47          *
     48          ******************************************************************************/
     49          

   \                                 In section .text, align 2, keep-with-next
     50          MC_BPTR MC_SetUpScope(MC_BPTR pMessageIO)
     51          {
   \                     MC_SetUpScope: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4680             MOV      R8,R0
     52              MC_BPTR pResponse = pMessageIO;
     53              MC_U8 i, sz, nVarCnt;
     54          
     55              /* uninitialize scope */
     56              pcm_nScopeVarCount = 0U;
   \   00000006   0x....             LDR.N    R4,??DataTable1
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x7020             STRB     R0,[R4, #+0]
     57          
     58              /* seek the setup data */
     59              pMessageIO = MC_SkipInBuffer(pMessageIO, 2U);
     60              
     61              /* scope variable count  */
     62              pMessageIO = MC_ValueFromBuffer8(&nVarCnt, pMessageIO);
   \   0000000C   0xF108 0x0002      ADD      R0,R8,#+2
   \   00000010   0xF810 0x6B01      LDRB     R6,[R0], #+1
     63          
     64              /* scope variable information must fit into our buffers */
     65              if(!nVarCnt || nVarCnt > (MC_U8)MC_MAX_SCOPE_VARS)
   \   00000014   0xB10E             CBZ.N    R6,??MC_SetUpScope_0
   \   00000016   0x2E09             CMP      R6,#+9
   \   00000018   0xDB05             BLT.N    ??MC_SetUpScope_1
     66              {
     67                  return MC_ConstToBuffer8(pResponse, MC_STC_INVBUFF);
   \                     ??MC_SetUpScope_0: (+1)
   \   0000001A   0x2085             MOVS     R0,#+133
   \   0000001C   0xF808 0x0B01      STRB     R0,[R8], #+1
     68              }
     69              
     70              /* get all addresses and sizes */
     71              for(i=0U; i<nVarCnt; i++)
     72              {
     73                  /* variable size */
     74                  pMessageIO = MC_ValueFromBuffer8(&sz, pMessageIO);
     75                  pcm_pScopeVarSize[i] = sz;
     76                  
     77                  /* variable address */
     78                  pMessageIO = MC_AddressFromBuffer(&pcm_pScopeVarAddr[i], pMessageIO);
     79          
     80                  /* valid numeric variable sizes only */
     81                  if(sz == 0U || sz > 8U)
     82                  {
     83                      return MC_ConstToBuffer8(pResponse, MC_STC_INVSIZE);
     84                  }
     85                  
     86          #if MC_CFG_BUS_WIDTH > 1U
     87                  /* even sizes only */
     88                  if(sz & 0x1)
     89                  {
     90                      return MC_ConstToBuffer8(pResponse, MC_STC_INVSIZE);
     91                  }
     92          #endif
     93                  
     94          #if MC_USE_TSA && MC_USE_TSA_SAFETY
     95                  if(!MC_CheckTsaSpace(pcm_pScopeVarAddr[i], (MC_SIZE8) sz, 0U))
     96                  {
     97                      return MC_ConstToBuffer8(pResponse, MC_STC_EACCESS);
     98                  }
     99          #endif
    100                  
    101              }
    102          
    103              /* activate scope */
    104              pcm_nScopeVarCount = nVarCnt;
    105          
    106              /* return just a status */
    107              return MC_ConstToBuffer8(pResponse, MC_STS_OK);
   \   00000020   0x4640             MOV      R0,R8
   \   00000022   0xE8BD 0x87F0      POP      {R4-R10,PC}
   \                     ??MC_SetUpScope_1: (+1)
   \   00000026   0x2500             MOVS     R5,#+0
   \   00000028   0xF104 0x0924      ADD      R9,R4,#+36
   \   0000002C   0xF104 0x0A04      ADD      R10,R4,#+4
   \   00000030   0xE003             B.N      ??MC_SetUpScope_2
   \                     ??MC_SetUpScope_3: (+1)
   \   00000032   0x1C69             ADDS     R1,R5,#+1
   \   00000034   0xB2CD             UXTB     R5,R1
   \   00000036   0xF10A 0x0A04      ADD      R10,R10,#+4
   \                     ??MC_SetUpScope_2: (+1)
   \   0000003A   0x42B5             CMP      R5,R6
   \   0000003C   0xDA10             BGE.N    ??MC_SetUpScope_4
   \   0000003E   0xF810 0x7B01      LDRB     R7,[R0], #+1
   \   00000042   0xF809 0x7B01      STRB     R7,[R9], #+1
   \   00000046   0x4601             MOV      R1,R0
   \   00000048   0x4650             MOV      R0,R10
   \   0000004A   0x.... 0x....      BL       MC_AddressFromBuffer
   \   0000004E   0xB10F             CBZ.N    R7,??MC_SetUpScope_5
   \   00000050   0x2F09             CMP      R7,#+9
   \   00000052   0xD3EE             BCC.N    ??MC_SetUpScope_3
   \                     ??MC_SetUpScope_5: (+1)
   \   00000054   0x2086             MOVS     R0,#+134
   \   00000056   0xF808 0x0B01      STRB     R0,[R8], #+1
   \   0000005A   0x4640             MOV      R0,R8
   \   0000005C   0xE8BD 0x87F0      POP      {R4-R10,PC}
   \                     ??MC_SetUpScope_4: (+1)
   \   00000060   0x7026             STRB     R6,[R4, #+0]
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xF808 0x0B01      STRB     R0,[R8], #+1
   \   00000068   0x4640             MOV      R0,R8
   \   0000006A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    108          }
    109          
    110          /**************************************************************************//*!
    111          *
    112          * @brief    Handling READSCOPE command
    113          *
    114          * @param    pMessageIO - original command (in) and response buffer (out) 
    115          *
    116          * @return   As all command handlers, the return value should be the buffer 
    117          *           pointer where the response output finished (except checksum)
    118          *
    119          ******************************************************************************/
    120          

   \                                 In section .text, align 4, keep-with-next
    121          MC_BPTR MC_ReadScope(MC_BPTR pMessageIO)
    122          {
   \                     MC_ReadScope: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    123              MC_U8 i;
    124              
    125              if(!pcm_nScopeVarCount)
   \   00000002   0x....             LDR.N    R4,??DataTable1
   \   00000004   0x7821             LDRB     R1,[R4, #+0]
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0xB921             CBNZ.N   R1,??MC_ReadScope_0
    126              {
    127                  return MC_ConstToBuffer8(pMessageIO, MC_STC_NOTINIT);
   \   0000000A   0x2188             MOVS     R1,#+136
   \   0000000C   0xF800 0x1B01      STRB     R1,[R0], #+1
    128              }
    129              
    130              /* success */
    131              pMessageIO = MC_ConstToBuffer8(pMessageIO, MC_STS_OK);
    132              
    133              for (i=0U; i<pcm_nScopeVarCount; i++)
    134              {
    135                  pMessageIO = MC_CopyToBuffer(pMessageIO, pcm_pScopeVarAddr[i], pcm_pScopeVarSize[i]);
    136              } 
    137                  
    138              /* return end position */
    139              return pMessageIO;  
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0xBDF0             POP      {R4-R7,PC}
   \                     ??MC_ReadScope_0: (+1)
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xF800 0x2B01      STRB     R2,[R0], #+1
   \   0000001A   0x2500             MOVS     R5,#+0
   \   0000001C   0xF104 0x0624      ADD      R6,R4,#+36
   \   00000020   0x1D27             ADDS     R7,R4,#+4
   \   00000022   0xB151             CBZ.N    R1,??MC_ReadScope_1
   \                     ??MC_ReadScope_2: (+1)
   \   00000024   0xF816 0x2B01      LDRB     R2,[R6], #+1
   \   00000028   0xF857 0x1B04      LDR      R1,[R7], #+4
   \   0000002C   0x.... 0x....      BL       MC_CopyToBuffer
   \   00000030   0x7821             LDRB     R1,[R4, #+0]
   \   00000032   0x1C6D             ADDS     R5,R5,#+1
   \   00000034   0xB2ED             UXTB     R5,R5
   \   00000036   0x428D             CMP      R5,R1
   \   00000038   0xDBF4             BLT.N    ??MC_ReadScope_2
   \                     ??MC_ReadScope_1: (+1)
   \   0000003A   0xB001             ADD      SP,SP,#+4
   \   0000003C   0xBDF0             POP      {R4-R7,PC}       ;; return
    140          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     pcm_nScopeVarCount
    141          
    142          #else  /* (MC_USE_SCOPE) && !(MC_DISABLE) */
    143          
    144          /*lint -efile(766, mc_protocol.h) include file is not used in this case */
    145          
    146          #endif /* (MC_USE_SCOPE) && !(MC_DISABLE) */
    147          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   MC_InitScope
      24   MC_ReadScope
        24   -> MC_CopyToBuffer
      32   MC_SetUpScope
        32   -> MC_AddressFromBuffer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       2  MC_InitScope
      62  MC_ReadScope
     110  MC_SetUpScope
      44  pcm_nScopeVarCount
          pcm_pScopeVarAddr
          pcm_pScopeVarSize

 
  44 bytes in section .bss
 178 bytes in section .text
 
 178 bytes of CODE memory
  44 bytes of DATA memory

Errors: none
Warnings: none
