###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        13/Mar/2025  15:31:39
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  XCategory\Common\SystemTimers\SystemTimers.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        SystemTimers.obj -l ..\listings\SystemTimers.lst
#        XCategory\Common\SystemTimers\SystemTimers.c
#    List file    =  ..\listings\SystemTimers.lst
#    Object file  =  SystemTimers.obj
#
###############################################################################

C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Common\SystemTimers\SystemTimers.c
      1          /**
      2           *  @file       
      3           *
      4           *  @brief      SystemTimers implements a Up and Down counter timers based on 1ms System Tick.
      5           *
      6           *  @details    This module manages timers by taking snapshots of time when a timer is started, then comparing the
      7           *              snapshot time to a free running timer to know when a timer has expired.
      8           *              The number of timers is configurable and defined in SystemTimers_prv.h. The module allocates memory to
      9           *              handle that many concurrent timers. The purpose of the "handle" is used to identify one of those timers.
     10           *              All the management of the timer is done in this module. Application modules only need to store the
     11           *              "handle" to reference their timer. This module also allows for allocation and de-allocation of timer.
     12           *              The SystemTimers__GetHandle() function is the allocation of a timer and it provides the unique
     13           *              "handle", which identifies the timer. The SystemTimers__ReleaseHandle() function is the de-allocation
     14           *              of the timer, which will free up a timer to be used by another module.
     15           *              Added NVTimers which allow Non Volatile Timers in the system
     16           *
     17           *  @copyright  Copyright 2015-2017. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     18           */
     19          //---------------------------------------------------------------------------------------------------------------------
     20          //---------------------------------------------------------------------------------------------------------------------
     21          
     22          //-------------------------------------- Include Files ----------------------------------------------------------------
     23          
     24          #include "SystemConfig.h"
     25          #include "SystemTimers.h"

  PACKED typedef struct
         ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Common\SystemTimers\SystemTimers.h",45  Remark[Pe082]: 
          storage class is not first

  PACKED typedef struct
         ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\XCategory\Common\SystemTimers\SystemTimers.h",56  Remark[Pe082]: 
          storage class is not first
     26          #include "SystemTimers_prv.h"
     27          
     28          #include "Log.h"
     29          #include <string.h>
     30          #include "Micro.h"
     31          
     32          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     33          
     34          //! list of module Log messages
     35          typedef enum
     36          {
     37              INVALID_HANDLE = 1
     38          } MODULE_SYSTEMTIMERS_LOG_MESSAGE_ID_TYPE;
     39          #define MODULE_NAME MODULE_SYSTEMTIMERS
     40          
     41          
     42          //! Definition of data related to an instance of a timer
     43          PACKED typedef struct
                        ^
Remark[Pe082]: storage class is not first
     44          {
     45              uint32 compare;
     46              uint8  handle;
     47              SYSTEMTIMERS_STATE_TYPE  state;
     48              SYSTEMTIMERS_TYPE_TYPE  type;
     49              BOOL_TYPE  event;
     50          }SYSTEMTIMERS_TYPE;
     51          
     52          //! Check to ensure there is a limit on the maximum number of timers that can be allocated for the module
     53          CT_ASSERT(SYSTEMTIMER_NUM_INSTANCES < 200);
     54          

   \                                 In section .bss, align 4
     55          static SYSTEMTIMERS_TYPE All_Timers[SYSTEMTIMER_NUM_INSTANCES];
   \                     All_Timers:
   \   00000000                      DS8 80
   \   00000050                      DS8 1
   \   00000051                      DS8 3
   \   00000054                      DS8 4
     56          static uint8 Handle_Reference;
     57          static uint32 Handle_Counter;
     58          
     59          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
     60          static void EvalTimer(SYSTEMTIMER_NV_TIMER_TYPE * nv_timer);
     61          //====================================================================================================================
     62          //-------------------------------------- Public Functions -------------------------------------------------------------
     63          //=====================================================================================================================
     64          
     65          //---------------------------------------------------------------------------------------------------------------------
     66          /**
     67           * @brief  It Initializes the module Timers and its variables
     68           * @details The Initialization must be reset type aware
     69           */

   \                                 In section .text, align 2, keep-with-next
     70          void SystemTimers__Initialize(void)
     71          {
   \                     SystemTimers__Initialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     72              uint8 index;
     73              Handle_Reference = 1;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable21
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF884 0x0050      STRB     R0,[R4, #+80]
     74          
     75              // Initialize only if Cold Reset and the data is not restored from NVData
     76              if (Micro__GetResetMode() == MICRO_RESET_MODE_COLD)
   \   0000000C   0x.... 0x....      BL       Micro__GetResetMode
   \   00000010   0xB900             CBNZ.N   R0,??SystemTimers__Initialize_0
     77              {
     78              	Handle_Counter = 0;
   \   00000012   0x6560             STR      R0,[R4, #+84]
     79              }
     80          
     81          
     82              for (index =0; index < SYSTEMTIMER_NUM_INSTANCES; index++)
   \                     ??SystemTimers__Initialize_0: (+1)
   \   00000014   0x2005             MOVS     R0,#+5
     83              {
     84                  All_Timers[index].handle = 0;
   \                     ??SystemTimers__Initialize_1: (+1)
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x7121             STRB     R1,[R4, #+4]
     85                  All_Timers[index].compare = 0;
   \   0000001A   0x6021             STR      R1,[R4, #+0]
     86                  All_Timers[index].state = SYSTEMTIMERS_STATE_INVALID;
   \   0000001C   0x2104             MOVS     R1,#+4
   \   0000001E   0x7161             STRB     R1,[R4, #+5]
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x7321             STRB     R1,[R4, #+12]
   \   00000024   0x60A1             STR      R1,[R4, #+8]
   \   00000026   0x2104             MOVS     R1,#+4
   \   00000028   0x7361             STRB     R1,[R4, #+13]
     87              }
   \   0000002A   0x3410             ADDS     R4,R4,#+16
   \   0000002C   0x1E40             SUBS     R0,R0,#+1
   \   0000002E   0xD1F2             BNE.N    ??SystemTimers__Initialize_1
     88          }
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
     89          
     90          //---------------------------------------------------------------------------------------------------------------------
     91          /**
     92           * @brief   Updates the free running counter and determines if any of the counters has expired.
     93           *          This function must be called every 1m out of the interruptions.
     94           */

   \                                 In section .text, align 4, keep-with-next
     95          void SystemTimers__Handler1ms(void)
     96          {
     97              uint8 index;
     98              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
     99          
    100              Handle_Reference++;
   \                     SystemTimers__Handler1ms: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000004   0xF890 0x1050      LDRB     R1,[R0, #+80]
   \   00000008   0x1C49             ADDS     R1,R1,#+1
    101              if (Handle_Reference == 0)
   \   0000000A   0xB2C9             UXTB     R1,R1
   \   0000000C   0xB901             CBNZ.N   R1,??SystemTimers__Handler1ms_0
    102              {
    103                  Handle_Reference++;
   \   0000000E   0x2101             MOVS     R1,#+1
   \                     ??SystemTimers__Handler1ms_0: (+1)
   \   00000010   0xF880 0x1050      STRB     R1,[R0, #+80]
    104              }
    105          
    106              Handle_Counter++;   // Intentionally not handling overflow
    107          
    108              for (index =0; index < SYSTEMTIMER_NUM_INSTANCES; index++)
   \   00000014   0x220A             MOVS     R2,#+10
   \   00000016   0x6D41             LDR      R1,[R0, #+84]
   \   00000018   0x1C49             ADDS     R1,R1,#+1
   \   0000001A   0x6541             STR      R1,[R0, #+84]
   \   0000001C   0xF110 0x0105      ADDS.W   R1,R0,#+5
    109              {
    110                  if (All_Timers[index].state == SYSTEMTIMERS_STATE_RUNNING)
   \                     ??SystemTimers__Handler1ms_1: (+1)
   \   00000020   0xF991 0x3000      LDRSB    R3,[R1, #+0]
   \   00000024   0x2B01             CMP      R3,#+1
   \   00000026   0xBF02             ITTT     EQ 
    111                  {
    112                  	if (Handle_Counter == All_Timers[index].compare)
   \   00000028   0x6D43             LDREQ    R3,[R0, #+84]
   \   0000002A   0xF851 0xCC05      LDREQ    R12,[R1, #-5]
   \   0000002E   0x4563             CMPEQ    R3,R12
   \   00000030   0xD10C             BNE.N    ??SystemTimers__Handler1ms_2
    113          			{
    114          				MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   00000032   0xF3EF 0x8310      MRS      R3,PRIMASK
   \   00000036   0xB672             CPSID    I
    115          				All_Timers[index].event = TRUE;
   \   00000038   0xF04F 0x0C01      MOV      R12,#+1
   \   0000003C   0xF881 0xC002      STRB     R12,[R1, #+2]
    116          				All_Timers[index].state = SYSTEMTIMERS_STATE_DONE;
   \   00000040   0xF04F 0x0C02      MOV      R12,#+2
   \   00000044   0xF881 0xC000      STRB     R12,[R1, #+0]
    117          				MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \   00000048   0xF383 0x8810      MSR      PRIMASK,R3
    118          			}
    119                  }
    120              }
   \                     ??SystemTimers__Handler1ms_2: (+1)
   \   0000004C   0x3108             ADDS     R1,R1,#+8
   \   0000004E   0x1E52             SUBS     R2,R2,#+1
   \   00000050   0xD1E6             BNE.N    ??SystemTimers__Handler1ms_1
    121          }
   \   00000052   0x4770             BX       LR               ;; return
    122          
    123          //---------------------------------------------------------------------------------------------------------------------
    124          /**
    125           * @brief   Returns the current value of the free running counter
    126           */

   \                                 In section .text, align 2, keep-with-next
    127          uint32 SystemTimers__GetFreeRunningCounter(void)
    128          {
    129              return (Handle_Counter);
   \                     SystemTimers__GetFreeRunningCounter: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000004   0x6D40             LDR      R0,[R0, #+84]
   \   00000006   0x4770             BX       LR               ;; return
    130          }
    131          
    132          //---------------------------------------------------------------------------------------------------------------------
    133          /**
    134           * @brief   Request a Timer Handle
    135           * @return  Timer handle, if TIMERS_FAIL(0xFFFF) means not possible to allocate it.
    136           */

   \                                 In section .text, align 4, keep-with-next
    137          uint16 SystemTimers__GetHandle(SYSTEMTIMERS_TYPE_TYPE type)
    138          {
   \                     SystemTimers__GetHandle: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    139              uint8 index;
    140              uint8 first_free;
    141              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    142          
    143              first_free = 255;
   \   00000002   0x21FF             MOVS     R1,#+255
    144              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   00000004   0xF3EF 0x8210      MRS      R2,PRIMASK
   \   00000008   0xB672             CPSID    I
    145              for (index =0; index < SYSTEMTIMER_NUM_INSTANCES; index++)
   \   0000000A   0x.... 0x....      LDR.W    R4,??DataTable21
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0xF114 0x0504      ADDS.W   R5,R4,#+4
    146              {
    147                  if ((first_free == 255) &&
    148                      (All_Timers[index].handle == 0))
   \                     ??SystemTimers__GetHandle_0: (+1)
   \   00000014   0xF815 0x6B08      LDRB     R6,[R5], #+8
   \   00000018   0xB94E             CBNZ.N   R6,??SystemTimers__GetHandle_1
    149                  {
    150                      first_free = index;
   \                     ??SystemTimers__GetHandle_2: (+1)
   \   0000001A   0xB2D9             UXTB     R1,R3
    151                      All_Timers[first_free].state = SYSTEMTIMERS_STATE_STOPPED;
   \   0000001C   0xEB04 0x03C1      ADD      R3,R4,R1, LSL #+3
   \   00000020   0x2500             MOVS     R5,#+0
   \   00000022   0x715D             STRB     R5,[R3, #+5]
    152                      All_Timers[first_free].type = type;
   \   00000024   0x7198             STRB     R0,[R3, #+6]
    153                      All_Timers[first_free].handle = Handle_Reference;
   \   00000026   0xF894 0x0050      LDRB     R0,[R4, #+80]
   \   0000002A   0x7118             STRB     R0,[R3, #+4]
    154                      break;
   \   0000002C   0xE008             B.N      ??SystemTimers__GetHandle_3
    155                  }
   \                     ??SystemTimers__GetHandle_1: (+1)
   \   0000002E   0xF815 0x6B08      LDRB     R6,[R5], #+8
   \   00000032   0x1C5B             ADDS     R3,R3,#+1
   \   00000034   0x2E00             CMP      R6,#+0
   \   00000036   0xD0F0             BEQ.N    ??SystemTimers__GetHandle_2
    156              }
   \   00000038   0x1C5B             ADDS     R3,R3,#+1
   \   0000003A   0xB2DB             UXTB     R3,R3
   \   0000003C   0x2B0A             CMP      R3,#+10
   \   0000003E   0xDBE9             BLT.N    ??SystemTimers__GetHandle_0
    157              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \                     ??SystemTimers__GetHandle_3: (+1)
   \   00000040   0xF382 0x8810      MSR      PRIMASK,R2
    158          
    159          
    160              if (first_free < SYSTEMTIMER_NUM_INSTANCES)
   \   00000044   0x290A             CMP      R1,#+10
   \   00000046   0xDA08             BGE.N    ??SystemTimers__GetHandle_4
    161              {
    162                  return ((((uint16)All_Timers[first_free].handle) << 8) + ((uint16 )first_free));
   \   00000048   0xEB04 0x00C1      ADD      R0,R4,R1, LSL #+3
   \   0000004C   0x7900             LDRB     R0,[R0, #+4]
   \   0000004E   0xBC70             POP      {R4-R6}
   \   00000050   0x0200             LSLS     R0,R0,#+8
   \   00000052   0xFA50 0xF081      UXTAB    R0,R0,R1
   \   00000056   0xB280             UXTH     R0,R0
   \   00000058   0x4770             BX       LR
    163              }
    164              else
    165              {
    166                  LOG_ADD_EXCEPTION(INVALID_HANDLE, 0);
    167                  CANNOT_ALLOCATE_SYSTEM_TIMER_HANDLE();
    168                  return (SYSTEMTIMERS_FAIL);
   \                     ??SystemTimers__GetHandle_4: (+1)
   \   0000005A   0xBC70             POP      {R4-R6}
   \   0000005C   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000060   0x4770             BX       LR               ;; return
    169              }
    170          }
    171          
    172          //---------------------------------------------------------------------------------------------------------------------
    173          /**
    174           * @brief   Releases a timer handle
    175           * @param   handle: unique identifier for a timer
    176           * @return  PASS if the timer handle was valid, else FAIL
    177           */

   \                                 In section .text, align 2, keep-with-next
    178          PASS_FAIL_TYPE SystemTimers__ReleaseHandle(uint16 handle)
    179          {
    180              PASS_FAIL_TYPE retval;
    181              uint8 index;
    182              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    183          
    184              retval = FAIL;
   \                     SystemTimers__ReleaseHandle: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    185          
    186              index = handle & 0x00FF;
   \   00000002   0xB2C2             UXTB     R2,R0
    187              if (index < SYSTEMTIMER_NUM_INSTANCES)
   \   00000004   0x2A0A             CMP      R2,#+10
   \   00000006   0xDA10             BGE.N    ??SystemTimers__ReleaseHandle_0
    188              {
    189                  if (All_Timers[index].handle == ((uint8)(handle >> 8) ))
   \   00000008   0x.... 0x....      LDR.W    R3,??DataTable21
   \   0000000C   0xEB03 0x02C2      ADD      R2,R3,R2, LSL #+3
   \   00000010   0x7913             LDRB     R3,[R2, #+4]
   \   00000012   0xEBB3 0x2F10      CMP      R3,R0, LSR #+8
   \   00000016   0xD108             BNE.N    ??SystemTimers__ReleaseHandle_0
    190                  {
    191                      MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   00000018   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   0000001C   0xB672             CPSID    I
    192                      All_Timers[index].handle = 0;
   \   0000001E   0x7111             STRB     R1,[R2, #+4]
    193                      All_Timers[index].state =  SYSTEMTIMERS_STATE_INVALID;
   \   00000020   0x2104             MOVS     R1,#+4
   \   00000022   0x7151             STRB     R1,[R2, #+5]
    194          
    195                      retval = PASS;
   \   00000024   0x2101             MOVS     R1,#+1
    196                      MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \   00000026   0xF380 0x8810      MSR      PRIMASK,R0
    197                  }
    198              }
    199              return (retval);
   \                     ??SystemTimers__ReleaseHandle_0: (+1)
   \   0000002A   0x4608             MOV      R0,R1
   \   0000002C   0x4770             BX       LR               ;; return
    200          }
    201          
    202          //---------------------------------------------------------------------------------------------------------------------
    203          /**
    204           * @brief   This method sets a timer in milliseconds
    205           * @param   handle: unique identifier for a timer
    206           * @param   reference_ms: number of milliseconds for the timer
    207           * @return  PASS if the timer handle was valid, else FAIL
    208           */

   \                                 In section .text, align 2, keep-with-next
    209          PASS_FAIL_TYPE SystemTimers__SetMs(uint16 handle, uint32 reference_ms)
    210          {
   \                     SystemTimers__SetMs: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x460A             MOV      R2,R1
    211              PASS_FAIL_TYPE retval;
    212              uint8 index;
    213              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    214          
    215              retval = FAIL;
   \   00000004   0x2100             MOVS     R1,#+0
    216          
    217              index = handle & 0x00FF;
   \   00000006   0xB2C4             UXTB     R4,R0
    218              if (index < SYSTEMTIMER_NUM_INSTANCES)
   \   00000008   0x2C0A             CMP      R4,#+10
   \   0000000A   0xDA1E             BGE.N    ??SystemTimers__SetMs_0
    219              {
    220                  if (All_Timers[index].handle == ((uint8)(handle >> 8) ))
   \   0000000C   0x.... 0x....      LDR.W    R5,??DataTable21
   \   00000010   0xEB05 0x03C4      ADD      R3,R5,R4, LSL #+3
   \   00000014   0x791E             LDRB     R6,[R3, #+4]
   \   00000016   0xEBB6 0x2F10      CMP      R6,R0, LSR #+8
   \   0000001A   0xD116             BNE.N    ??SystemTimers__SetMs_0
    221                  {
    222                      MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   0000001C   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000020   0xB672             CPSID    I
    223                      retval = PASS;
   \   00000022   0x2101             MOVS     R1,#+1
    224          
    225                      //As Handle_Counter is pre counted so this check is required otherwise it will cause overloop
    226                      if (reference_ms != 0)
   \   00000024   0xB162             CBZ.N    R2,??SystemTimers__SetMs_1
    227                      {
    228                          if (All_Timers[index].type == SYSTEMTIMERS_TYPE_DOWN_COUNTER)
   \   00000026   0xF993 0x7006      LDRSB    R7,[R3, #+6]
   \   0000002A   0x6D6E             LDR      R6,[R5, #+84]
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xBF0C             ITE      EQ 
    229                          {
    230                              All_Timers[index].compare = Handle_Counter + reference_ms;
   \   00000030   0x1992             ADDEQ    R2,R2,R6
    231                          }
    232                          else
    233                          {
    234                              All_Timers[index].compare = Handle_Counter - reference_ms;
   \   00000032   0x1AB2             SUBNE    R2,R6,R2
   \   00000034   0xF845 0x2034      STR      R2,[R5, R4, LSL #+3]
    235                          }
    236          
    237                          All_Timers[index].state = SYSTEMTIMERS_STATE_RUNNING;
   \   00000038   0x7159             STRB     R1,[R3, #+5]
    238                          All_Timers[index].event = FALSE;
   \   0000003A   0x2200             MOVS     R2,#+0
   \   0000003C   0x71DA             STRB     R2,[R3, #+7]
   \   0000003E   0xE002             B.N      ??SystemTimers__SetMs_2
    239                      }
    240                      else
    241                      {
    242                          All_Timers[index].state = SYSTEMTIMERS_STATE_DONE;
   \                     ??SystemTimers__SetMs_1: (+1)
   \   00000040   0x2202             MOVS     R2,#+2
   \   00000042   0x715A             STRB     R2,[R3, #+5]
    243                          All_Timers[index].event = TRUE;
   \   00000044   0x71D9             STRB     R1,[R3, #+7]
    244                      }
    245          
    246                      MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \                     ??SystemTimers__SetMs_2: (+1)
   \   00000046   0xF380 0x8810      MSR      PRIMASK,R0
    247                  }
    248              }
    249              return (retval);
   \                     ??SystemTimers__SetMs_0: (+1)
   \   0000004A   0x4608             MOV      R0,R1
   \   0000004C   0xBCF0             POP      {R4-R7}
   \   0000004E   0x4770             BX       LR               ;; return
    250          }
    251          
    252          //---------------------------------------------------------------------------------------------------------------------
    253          /**
    254           * @brief   This method sets a timer in hours, minutes and seconds
    255           * @param   handle: unique identifier for a timer
    256           * @param   time: amount of time for the timer (see SYSTEMTIMER_HMS_TYPE)
    257           * @return  PASS if the timer handle was valid, else FAIL
    258           */

   \                                 In section .text, align 2, keep-with-next
    259          PASS_FAIL_TYPE SystemTimers__SetHMS(uint16 handle, SYSTEMTIMER_HMS_TYPE * time)
    260          {
   \                     SystemTimers__SetHMS: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    261              uint32 value;
    262          
    263              value = ((((uint32)time->hours * 60) + (uint32)time->minutes) * 60) + (uint32)time->seconds;
    264          	value *= 1000;
    265          	value += (uint32)time->milliseconds;
    266          
    267              return (SystemTimers__SetMs(handle,value));
   \   00000002   0x788A             LDRB     R2,[R1, #+2]
   \   00000004   0xEBC2 0x1302      RSB      R3,R2,R2, LSL #+4
   \   00000008   0x009A             LSLS     R2,R3,#+2
   \   0000000A   0x78CB             LDRB     R3,[R1, #+3]
   \   0000000C   0x18D2             ADDS     R2,R2,R3
   \   0000000E   0xEBC2 0x1302      RSB      R3,R2,R2, LSL #+4
   \   00000012   0x009A             LSLS     R2,R3,#+2
   \   00000014   0x790B             LDRB     R3,[R1, #+4]
   \   00000016   0x8809             LDRH     R1,[R1, #+0]
   \   00000018   0x18D2             ADDS     R2,R2,R3
   \   0000001A   0xF44F 0x737A      MOV      R3,#+1000
   \   0000001E   0xFB03 0x1302      MLA      R3,R3,R2,R1
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0xB2C4             UXTB     R4,R0
   \   00000026   0x2C0A             CMP      R4,#+10
   \   00000028   0xDA1E             BGE.N    ??SystemTimers__SetHMS_0
   \   0000002A   0x.... 0x....      LDR.W    R5,??DataTable21
   \   0000002E   0xEB05 0x02C4      ADD      R2,R5,R4, LSL #+3
   \   00000032   0x7916             LDRB     R6,[R2, #+4]
   \   00000034   0xEBB6 0x2F10      CMP      R6,R0, LSR #+8
   \   00000038   0xD116             BNE.N    ??SystemTimers__SetHMS_0
   \   0000003A   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   0000003E   0xB672             CPSID    I
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0xB163             CBZ.N    R3,??SystemTimers__SetHMS_1
   \   00000044   0xF992 0x7006      LDRSB    R7,[R2, #+6]
   \   00000048   0x6D6E             LDR      R6,[R5, #+84]
   \   0000004A   0x2F00             CMP      R7,#+0
   \   0000004C   0xBF0C             ITE      EQ 
   \   0000004E   0x199B             ADDEQ    R3,R3,R6
   \   00000050   0x1AF3             SUBNE    R3,R6,R3
   \   00000052   0xF845 0x3034      STR      R3,[R5, R4, LSL #+3]
   \   00000056   0x7151             STRB     R1,[R2, #+5]
   \   00000058   0x2300             MOVS     R3,#+0
   \   0000005A   0x71D3             STRB     R3,[R2, #+7]
   \   0000005C   0xE002             B.N      ??SystemTimers__SetHMS_2
   \                     ??SystemTimers__SetHMS_1: (+1)
   \   0000005E   0x2302             MOVS     R3,#+2
   \   00000060   0x7153             STRB     R3,[R2, #+5]
   \   00000062   0x71D1             STRB     R1,[R2, #+7]
   \                     ??SystemTimers__SetHMS_2: (+1)
   \   00000064   0xF380 0x8810      MSR      PRIMASK,R0
   \                     ??SystemTimers__SetHMS_0: (+1)
   \   00000068   0x4608             MOV      R0,R1
   \   0000006A   0xBCF0             POP      {R4-R7}
   \   0000006C   0x4770             BX       LR               ;; return
    268          }
    269          
    270          //---------------------------------------------------------------------------------------------------------------------
    271          /**
    272           * @brief   This method resets a timer
    273           * @param   handle: unique identifier for a timer
    274           * @return  PASS if the timer handle was valid, else FAIL
    275           */

   \                                 In section .text, align 2, keep-with-next
    276          PASS_FAIL_TYPE SystemTimers__Reset(uint16 handle)
    277          {
    278              PASS_FAIL_TYPE retval;
    279              uint8 index;
    280              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    281          
    282              retval = FAIL;
   \                     SystemTimers__Reset: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    283          
    284              index = handle & 0x00FF;
   \   00000002   0xB2C2             UXTB     R2,R0
    285              if (index < SYSTEMTIMER_NUM_INSTANCES)
   \   00000004   0x2A0A             CMP      R2,#+10
   \   00000006   0xDA0F             BGE.N    ??SystemTimers__Reset_0
    286              {
    287                 if (All_Timers[index].handle == ((uint8)(handle >> 8) ))
   \   00000008   0x.... 0x....      LDR.W    R3,??DataTable21
   \   0000000C   0xEB03 0x02C2      ADD      R2,R3,R2, LSL #+3
   \   00000010   0x7913             LDRB     R3,[R2, #+4]
   \   00000012   0xEBB3 0x2F10      CMP      R3,R0, LSR #+8
   \   00000016   0xD107             BNE.N    ??SystemTimers__Reset_0
    288                 {
    289                     MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   00000018   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   0000001C   0xB672             CPSID    I
    290                     All_Timers[index].state = SYSTEMTIMERS_STATE_STOPPED;
   \   0000001E   0x7151             STRB     R1,[R2, #+5]
    291                     All_Timers[index].event = FALSE;
   \   00000020   0x71D1             STRB     R1,[R2, #+7]
    292                     retval = PASS;
   \   00000022   0x2101             MOVS     R1,#+1
    293                     MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \   00000024   0xF380 0x8810      MSR      PRIMASK,R0
    294                 }
    295              }
    296              return (retval);
   \                     ??SystemTimers__Reset_0: (+1)
   \   00000028   0x4608             MOV      R0,R1
   \   0000002A   0x4770             BX       LR               ;; return
    297          }
    298          
    299          //---------------------------------------------------------------------------------------------------------------------
    300          /**
    301           * @brief   This method pauses a Timer if it is RUNNING State.
    302           * @details It stores the remaining time in the second_compare data field.
    303           * @param   handle: unique identifier for a timer
    304           * @return  PASS if the timer handle was valid and in the RUNNING state, else FAIL
    305           */

   \                                 In section .text, align 2, keep-with-next
    306          PASS_FAIL_TYPE SystemTimers__Pause(uint16 handle)
    307          {
   \                     SystemTimers__Pause: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x4601             MOV      R1,R0
    308              PASS_FAIL_TYPE retval;
    309              uint8 index;
    310              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    311              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   00000004   0xF3EF 0x8210      MRS      R2,PRIMASK
   \   00000008   0xB672             CPSID    I
    312          
    313              retval = FAIL;
   \   0000000A   0x2000             MOVS     R0,#+0
    314              index = handle & 0x00FF;
   \   0000000C   0xB2CC             UXTB     R4,R1
    315          
    316              if (index < SYSTEMTIMER_NUM_INSTANCES)
   \   0000000E   0x2C0A             CMP      R4,#+10
   \   00000010   0xDA19             BGE.N    ??SystemTimers__Pause_0
    317              {
    318                  if (All_Timers[index].handle == ((uint8)(handle >> 8) ))
   \   00000012   0x.... 0x....      LDR.W    R5,??DataTable21
   \   00000016   0xEB05 0x03C4      ADD      R3,R5,R4, LSL #+3
   \   0000001A   0x791E             LDRB     R6,[R3, #+4]
   \   0000001C   0xEBB6 0x2F11      CMP      R6,R1, LSR #+8
   \   00000020   0xBF04             ITT      EQ 
    319                  {
    320                      if (All_Timers[index].state ==  SYSTEMTIMERS_STATE_RUNNING)
   \   00000022   0xF993 0x1005      LDRSBEQ  R1,[R3, #+5]
   \   00000026   0x2901             CMPEQ    R1,#+1
   \   00000028   0xD10D             BNE.N    ??SystemTimers__Pause_0
    321                      {
    322                      	if (All_Timers[index].type == SYSTEMTIMERS_TYPE_DOWN_COUNTER)
   \   0000002A   0xF993 0x1006      LDRSB    R1,[R3, #+6]
   \   0000002E   0x6D68             LDR      R0,[R5, #+84]
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xF855 0x1034      LDR      R1,[R5, R4, LSL #+3]
   \   00000036   0xBF0C             ITE      EQ 
    323                      	{
    324                      		All_Timers[index].compare = All_Timers[index].compare - Handle_Counter;
   \   00000038   0x1A08             SUBEQ    R0,R1,R0
    325                      	}
    326                      	else
    327                      	{
    328                      		All_Timers[index].compare = Handle_Counter - All_Timers[index].compare;
   \   0000003A   0x1A40             SUBNE    R0,R0,R1
   \   0000003C   0xF845 0x0034      STR      R0,[R5, R4, LSL #+3]
    329                      	}
    330                          All_Timers[index].state = SYSTEMTIMERS_STATE_PAUSED;
   \   00000040   0x2003             MOVS     R0,#+3
   \   00000042   0x7158             STRB     R0,[R3, #+5]
    331                          retval = PASS;
   \   00000044   0x2001             MOVS     R0,#+1
    332                      }
    333                  }
    334              }
    335          
    336              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \                     ??SystemTimers__Pause_0: (+1)
   \   00000046   0xF382 0x8810      MSR      PRIMASK,R2
    337              return (retval);
   \   0000004A   0xBC70             POP      {R4-R6}
   \   0000004C   0x4770             BX       LR               ;; return
    338          }
    339          
    340          //---------------------------------------------------------------------------------------------------------------------
    341          /**
    342           * @brief   This method resumes a Timer is it is in PAUSE state.
    343           * @details It resumes the timer using the value stored in the second_compare data field.
    344           * @param   handle: unique identifier for a timer
    345           * @return  PASS if the timer handle was valid and in the PAUSED state, else FAIL
    346           */

   \                                 In section .text, align 2, keep-with-next
    347          PASS_FAIL_TYPE SystemTimers__Resume(uint16 handle)
    348          {
   \                     SystemTimers__Resume: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    349              PASS_FAIL_TYPE retval;
    350              uint8 index;
    351          
    352              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    353              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   00000002   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   00000006   0xB672             CPSID    I
    354          
    355              retval = FAIL;
    356              index = handle & 0x00FF;
   \   00000008   0xB2C3             UXTB     R3,R0
    357              if (index < SYSTEMTIMER_NUM_INSTANCES)
   \   0000000A   0x2B0A             CMP      R3,#+10
   \   0000000C   0xDA18             BGE.N    ??SystemTimers__Resume_0
    358              {
    359                  if (All_Timers[index].handle == ((uint8)(handle >> 8) ))
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable21
   \   00000012   0xEB04 0x02C3      ADD      R2,R4,R3, LSL #+3
   \   00000016   0x7915             LDRB     R5,[R2, #+4]
   \   00000018   0xEBB5 0x2F10      CMP      R5,R0, LSR #+8
   \   0000001C   0xBF04             ITT      EQ 
    360                  {
    361                      if (All_Timers[index].state ==  SYSTEMTIMERS_STATE_PAUSED)
   \   0000001E   0xF992 0x0005      LDRSBEQ  R0,[R2, #+5]
   \   00000022   0x2803             CMPEQ    R0,#+3
   \   00000024   0xD10C             BNE.N    ??SystemTimers__Resume_0
    362                      {
    363                          //All_Timers[index].stored_counter
    364                      	if (All_Timers[index].type == SYSTEMTIMERS_TYPE_DOWN_COUNTER)
   \   00000026   0xF992 0x5006      LDRSB    R5,[R2, #+6]
   \   0000002A   0x6D60             LDR      R0,[R4, #+84]
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xF854 0x5033      LDR      R5,[R4, R3, LSL #+3]
   \   00000032   0xBF0C             ITE      EQ 
    365          				{
    366          					All_Timers[index].compare = Handle_Counter + All_Timers[index].compare;
   \   00000034   0x1940             ADDEQ    R0,R0,R5
    367          				}
    368          				else
    369          				{
    370          					All_Timers[index].compare = Handle_Counter - All_Timers[index].compare;
   \   00000036   0x1B40             SUBNE    R0,R0,R5
   \   00000038   0xF844 0x0033      STR      R0,[R4, R3, LSL #+3]
    371          				}
    372          
    373                      	All_Timers[index].state = SYSTEMTIMERS_STATE_RUNNING;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x7150             STRB     R0,[R2, #+5]
    374                      }
    375                  }
    376              }
    377          
    378              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \                     ??SystemTimers__Resume_0: (+1)
   \   00000040   0xF381 0x8810      MSR      PRIMASK,R1
    379              return (retval);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBC30             POP      {R4,R5}
   \   00000048   0x4770             BX       LR               ;; return
    380          }
    381          
    382          //---------------------------------------------------------------------------------------------------------------------
    383          /**
    384           * @brief   Request the current value of a counter in milliseconds
    385           * @param   handle: unique identifier for a timer
    386           * @return  Remaining time in milliseconds
    387           */

   \                                 In section .text, align 2, keep-with-next
    388          uint32 SystemTimers__GetMs(uint16 handle)
    389          {
   \                     SystemTimers__GetMs: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    390              uint8 index;
    391              uint32 retval;
    392              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    393          
    394              retval = 0;
   \   00000002   0x2100             MOVS     R1,#+0
    395          
    396              index = handle & 0x00FF;
   \   00000004   0xB2C2             UXTB     R2,R0
    397              if (index < SYSTEMTIMER_NUM_INSTANCES)
   \   00000006   0x2A0A             CMP      R2,#+10
   \   00000008   0xDA29             BGE.N    ??SystemTimers__GetMs_0
    398              {
    399                  if (All_Timers[index].handle == ((uint8)(handle >> 8) ))
   \   0000000A   0x.... 0x....      LDR.W    R3,??DataTable21
   \   0000000E   0xEB03 0x04C2      ADD      R4,R3,R2, LSL #+3
   \   00000012   0x7925             LDRB     R5,[R4, #+4]
   \   00000014   0xEBB5 0x2F10      CMP      R5,R0, LSR #+8
   \   00000018   0xD121             BNE.N    ??SystemTimers__GetMs_0
    400                  {
    401                      MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   0000001A   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   0000001E   0xB672             CPSID    I
    402          
    403                      switch (All_Timers[index].state)
   \   00000020   0xF994 0x5005      LDRSB    R5,[R4, #+5]
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??SystemTimers__GetMs_1
   \   00000028   0xD317             BCC.N    ??SystemTimers__GetMs_2
   \   0000002A   0x2D03             CMP      R5,#+3
   \   0000002C   0xD00B             BEQ.N    ??SystemTimers__GetMs_3
   \   0000002E   0xD30D             BCC.N    ??SystemTimers__GetMs_4
   \   00000030   0xE013             B.N      ??SystemTimers__GetMs_2
    404                      {
    405                          case SYSTEMTIMERS_STATE_RUNNING:
    406                          	if (All_Timers[index].type == SYSTEMTIMERS_TYPE_DOWN_COUNTER)
   \                     ??SystemTimers__GetMs_1: (+1)
   \   00000032   0xF994 0x4006      LDRSB    R4,[R4, #+6]
   \   00000036   0x6D59             LDR      R1,[R3, #+84]
   \   00000038   0xF853 0x2032      LDR      R2,[R3, R2, LSL #+3]
   \   0000003C   0x2C00             CMP      R4,#+0
   \   0000003E   0xBF14             ITE      NE 
    407                          	{
    408                          		retval = (All_Timers[index].compare - Handle_Counter);
    409                          	}
    410                          	else
    411                          	{
    412                          		//All_Timers[index].compare = Handle_Counter - reference_ms;
    413                          		retval = Handle_Counter - All_Timers[index].compare;
   \   00000040   0x1A89             SUBNE    R1,R1,R2
    414                          	}
   \   00000042   0x1A51             SUBEQ    R1,R2,R1
   \   00000044   0xE009             B.N      ??SystemTimers__GetMs_2
    415                              break;
    416                          case SYSTEMTIMERS_STATE_PAUSED:
    417                              retval = All_Timers[index].compare;
   \                     ??SystemTimers__GetMs_3: (+1)
   \   00000046   0xF853 0x1032      LDR      R1,[R3, R2, LSL #+3]
    418                              break;
   \   0000004A   0xE006             B.N      ??SystemTimers__GetMs_2
    419                          case SYSTEMTIMERS_STATE_DONE:
    420                          	if (All_Timers[index].type == SYSTEMTIMERS_TYPE_DOWN_COUNTER)
   \                     ??SystemTimers__GetMs_4: (+1)
   \   0000004C   0xF994 0x4006      LDRSB    R4,[R4, #+6]
   \   00000050   0xB11C             CBZ.N    R4,??SystemTimers__GetMs_2
    421          					{
    422                          		retval = 0;
    423          					}
    424          					else
    425          					{
    426          						retval = (All_Timers[index].compare + Handle_Counter);
   \   00000052   0xF853 0x1032      LDR      R1,[R3, R2, LSL #+3]
   \   00000056   0x6D5A             LDR      R2,[R3, #+84]
   \   00000058   0x1851             ADDS     R1,R2,R1
    427          					}
    428                              break;
    429                          default:
    430                              //SYSTEMTIMERS_STATE_STOPPED
    431                              break;
    432                      }
    433          
    434                      MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \                     ??SystemTimers__GetMs_2: (+1)
   \   0000005A   0xF380 0x8810      MSR      PRIMASK,R0
    435                  }
    436              }
    437          
    438              return (retval);
   \                     ??SystemTimers__GetMs_0: (+1)
   \   0000005E   0xBC30             POP      {R4,R5}
   \   00000060   0x4608             MOV      R0,R1
   \   00000062   0x4770             BX       LR               ;; return
    439          }
    440          
    441          //---------------------------------------------------------------------------------------------------------------------
    442          /**
    443           * @brief   This method request the current value of a timer in HMS
    444           * @param   handle: unique identifier for a timer
    445           * @param   time: see SYSTEMTIMER_HMS_TYPE
    446           * @return  PASS if the timer handle was valid, else FAIL
    447           */

   \                                 In section .text, align 2, keep-with-next
    448          PASS_FAIL_TYPE SystemTimers__GetHMS(uint16 handle, SYSTEMTIMER_HMS_TYPE * time)
    449          {
   \                     SystemTimers__GetHMS: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    450              uint32 value;
    451              value = SystemTimers__GetMs(handle);
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0xB2C3             UXTB     R3,R0
   \   00000006   0x2B0A             CMP      R3,#+10
   \   00000008   0xDA27             BGE.N    ??SystemTimers__GetHMS_0
   \   0000000A   0x....             LDR.N    R4,??DataTable21
   \   0000000C   0xEB04 0x05C3      ADD      R5,R4,R3, LSL #+3
   \   00000010   0x792E             LDRB     R6,[R5, #+4]
   \   00000012   0xEBB6 0x2F10      CMP      R6,R0, LSR #+8
   \   00000016   0xD120             BNE.N    ??SystemTimers__GetHMS_0
   \   00000018   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   0000001C   0xB672             CPSID    I
   \   0000001E   0xF995 0x6005      LDRSB    R6,[R5, #+5]
   \   00000022   0x2E01             CMP      R6,#+1
   \   00000024   0xD00E             BEQ.N    ??SystemTimers__GetHMS_1
   \   00000026   0xD316             BCC.N    ??SystemTimers__GetHMS_2
   \   00000028   0x2E03             CMP      R6,#+3
   \   0000002A   0xD008             BEQ.N    ??SystemTimers__GetHMS_3
   \   0000002C   0xD213             BCS.N    ??SystemTimers__GetHMS_2
   \   0000002E   0xF995 0x5006      LDRSB    R5,[R5, #+6]
   \   00000032   0xB185             CBZ.N    R5,??SystemTimers__GetHMS_2
   \   00000034   0xF854 0x2033      LDR      R2,[R4, R3, LSL #+3]
   \   00000038   0x6D63             LDR      R3,[R4, #+84]
   \   0000003A   0x189A             ADDS     R2,R3,R2
   \   0000003C   0xE00B             B.N      ??SystemTimers__GetHMS_2
   \                     ??SystemTimers__GetHMS_3: (+1)
   \   0000003E   0xF854 0x2033      LDR      R2,[R4, R3, LSL #+3]
   \   00000042   0xE008             B.N      ??SystemTimers__GetHMS_2
   \                     ??SystemTimers__GetHMS_1: (+1)
   \   00000044   0xF995 0x5006      LDRSB    R5,[R5, #+6]
   \   00000048   0x6D62             LDR      R2,[R4, #+84]
   \   0000004A   0xF854 0x3033      LDR      R3,[R4, R3, LSL #+3]
   \   0000004E   0x2D00             CMP      R5,#+0
   \   00000050   0xBF0C             ITE      EQ 
   \   00000052   0x1A9A             SUBEQ    R2,R3,R2
   \   00000054   0x1AD2             SUBNE    R2,R2,R3
   \                     ??SystemTimers__GetHMS_2: (+1)
   \   00000056   0xF380 0x8810      MSR      PRIMASK,R0
    452          
    453              time->milliseconds = (uint16)(value % 1000);
   \                     ??SystemTimers__GetHMS_0: (+1)
   \   0000005A   0xF44F 0x707A      MOV      R0,#+1000
   \   0000005E   0xFBB2 0xF0F0      UDIV     R0,R2,R0
   \   00000062   0xF44F 0x737A      MOV      R3,#+1000
   \   00000066   0xFB03 0x2210      MLS      R2,R3,R0,R2
   \   0000006A   0x800A             STRH     R2,[R1, #+0]
    454              value /= 1000;
    455              time->seconds = (uint8)(value % 60);
   \   0000006C   0x223C             MOVS     R2,#+60
   \   0000006E   0xFBB0 0xF2F2      UDIV     R2,R0,R2
   \   00000072   0xEBC2 0x1302      RSB      R3,R2,R2, LSL #+4
   \   00000076   0xEBA0 0x0083      SUB      R0,R0,R3, LSL #+2
   \   0000007A   0x7108             STRB     R0,[R1, #+4]
    456              value /= 60;
    457              time->minutes = (uint8)(value % 60);
   \   0000007C   0x203C             MOVS     R0,#+60
   \   0000007E   0xFBB2 0xF0F0      UDIV     R0,R2,R0
   \   00000082   0xEBC0 0x1300      RSB      R3,R0,R0, LSL #+4
   \   00000086   0xEBA2 0x0283      SUB      R2,R2,R3, LSL #+2
   \   0000008A   0x70CA             STRB     R2,[R1, #+3]
    458              value /= 60;
    459              time->hours = (uint8)value;
   \   0000008C   0x7088             STRB     R0,[R1, #+2]
    460          
    461              return (PASS);
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xBC70             POP      {R4-R6}
   \   00000092   0x4770             BX       LR               ;; return
    462          }
    463          
    464          //---------------------------------------------------------------------------------------------------------------------
    465          /**
    466           * @brief   This method gets the current state of a timer
    467           * @param   handle: unique identifier for a timer
    468           * @return  SYSTEMTIMERS_STATE_INVALID if the timer is invalid, else the current state of the timer (See SYSTEMTIMERS_STATE_TYPE)
    469           */

   \                                 In section .text, align 2, keep-with-next
    470          SYSTEMTIMERS_STATE_TYPE SystemTimers__GetState(uint16 handle)
    471          {
    472              SYSTEMTIMERS_STATE_TYPE retval;
    473              uint8 index;
    474          
    475              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    476              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \                     SystemTimers__GetState: (+1)
   \   00000000   0xF3EF 0x8210      MRS      R2,PRIMASK
   \   00000004   0xB672             CPSID    I
    477          
    478              retval = SYSTEMTIMERS_STATE_INVALID;
   \   00000006   0x2104             MOVS     R1,#+4
    479              index = handle & 0x00FF;
   \   00000008   0xB2C3             UXTB     R3,R0
    480          
    481              if (index < SYSTEMTIMER_NUM_INSTANCES)
   \   0000000A   0x2B0A             CMP      R3,#+10
   \   0000000C   0xDA0A             BGE.N    ??SystemTimers__GetState_0
    482              {
    483                  if (All_Timers[index].handle == ((uint8)(handle >> 8) ))
   \   0000000E   0x.... 0x....      LDR.W    R12,??DataTable21
   \   00000012   0xEB0C 0x03C3      ADD      R3,R12,R3, LSL #+3
   \   00000016   0xF893 0xC004      LDRB     R12,[R3, #+4]
   \   0000001A   0xEBBC 0x2F10      CMP      R12,R0, LSR #+8
   \   0000001E   0xBF08             IT       EQ 
    484                  {
    485                      retval = All_Timers[index].state;
   \   00000020   0xF993 0x1005      LDRSBEQ  R1,[R3, #+5]
    486                  }
    487              }
    488              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \                     ??SystemTimers__GetState_0: (+1)
   \   00000024   0xF382 0x8810      MSR      PRIMASK,R2
    489          
    490              return (retval);
   \   00000028   0x4608             MOV      R0,R1
   \   0000002A   0x4770             BX       LR               ;; return
    491          }
    492          
    493          //---------------------------------------------------------------------------------------------------------------------
    494          /**
    495           * @brief   This method gets the status of the timer, expired or not.
    496           * @param   handle: unique identifier for a timer
    497           * @return  TRUE if the timer has expired, else FALSE.
    498           */

   \                                 In section .text, align 2, keep-with-next
    499          BOOL_TYPE SystemTimers__GetEvent(uint16 handle)
    500          {
    501              BOOL_TYPE retval;
    502              uint8 index;
    503          
    504              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    505          
    506              retval = FALSE;
   \                     SystemTimers__GetEvent: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    507              index = handle & 0x00FF;
   \   00000002   0xB2C2             UXTB     R2,R0
    508          
    509              if (index < SYSTEMTIMER_NUM_INSTANCES)
   \   00000004   0x2A0A             CMP      R2,#+10
   \   00000006   0xDA0E             BGE.N    ??SystemTimers__GetEvent_0
    510              {
    511                  if (All_Timers[index].handle == ((uint8)(handle >> 8) ))
   \   00000008   0x....             LDR.N    R3,??DataTable21
   \   0000000A   0xEB03 0x02C2      ADD      R2,R3,R2, LSL #+3
   \   0000000E   0x7913             LDRB     R3,[R2, #+4]
   \   00000010   0xEBB3 0x2F10      CMP      R3,R0, LSR #+8
   \   00000014   0xD107             BNE.N    ??SystemTimers__GetEvent_0
    512                  {
    513                      MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   00000016   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   0000001A   0xB672             CPSID    I
    514                      retval = All_Timers[index].event;
   \   0000001C   0x79D1             LDRB     R1,[R2, #+7]
    515                      All_Timers[index].event = FALSE;
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x71D3             STRB     R3,[R2, #+7]
    516                      MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \   00000022   0xF380 0x8810      MSR      PRIMASK,R0
    517                  }
    518              }
    519              return (retval);
   \                     ??SystemTimers__GetEvent_0: (+1)
   \   00000026   0x4608             MOV      R0,R1
   \   00000028   0x4770             BX       LR               ;; return
    520          }
    521          
    522          
    523          //---------------------------------------------------------------------------------------------------------------------
    524          /**
    525           * @brief This method initializes a NVTimer Struct.
    526           * @param nv_timer
    527           */

   \                                 In section .text, align 2, keep-with-next
    528          void SystemTimers__NVResetTimer(SYSTEMTIMER_NV_TIMER_TYPE * nv_timer)
    529          {
    530          	nv_timer->state = SYSTEMTIMERS_STATE_STOPPED;
   \                     SystemTimers__NVResetTimer: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7401             STRB     R1,[R0, #+16]
    531          	nv_timer->n_state = SYSTEMTIMERS_STATE_N_STOPPED;
   \   00000004   0xF04F 0x31FF      MOV      R1,#-1
   \   00000008   0x7441             STRB     R1,[R0, #+17]
    532          
    533          	nv_timer->type = SYSTEMTIMERS_TYPE_UP_COUNTER;
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x7481             STRB     R1,[R0, #+18]
    534          	nv_timer->n_type = SYSTEMTIMERS_TYPE_N_UP_COUNTER;
   \   0000000E   0xF06F 0x0101      MVN      R1,#+1
   \   00000012   0x74C1             STRB     R1,[R0, #+19]
    535          
    536          	nv_timer->last_handle_counter = Handle_Counter;
   \   00000014   0x....             LDR.N    R1,??DataTable21
   \   00000016   0x6D49             LDR      R1,[R1, #+84]
   \   00000018   0x60C1             STR      R1,[R0, #+12]
    537          }
   \   0000001A   0x4770             BX       LR               ;; return
    538          
    539          //---------------------------------------------------------------------------------------------------------------------
    540          /**
    541           * @brief This method  Adjust the structure of a NVTimer based on the stored value.
    542           * @param nv_timer
    543           */

   \                                 In section .text, align 2, keep-with-next
    544          void SystemTimers__NVRestore(SYSTEMTIMER_NV_TIMER_TYPE * nv_timer)
    545          {
   \                     SystemTimers__NVRestore: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable21
   \   00000002   0x68C2             LDR      R2,[R0, #+12]
   \   00000004   0x6D49             LDR      R1,[R1, #+84]
   \   00000006   0xF8D0 0xC000      LDR      R12,[R0, #+0]
   \   0000000A   0x428A             CMP      R2,R1
   \   0000000C   0xD314             BCC.N    ??SystemTimers__NVRestore_0
    546          	uint32 diff_timer;
    547          
    548          	if (nv_timer->last_handle_counter >= Handle_Counter)
    549          	{
    550          		// for instance:
    551          		// Last time the last_handle_counter was 3000 and all values related to that..
    552          		// Now the Handle_Counter is 2000
    553          		// diff_timer  will be 1000
    554          		// and the timers was ahead of the current timer
    555          		// All values should be decremented by the difference
    556          		diff_timer = nv_timer->last_handle_counter - Handle_Counter;
   \   0000000E   0x1A53             SUBS     R3,R2,R1
    557          		nv_timer->reference -= diff_timer;
   \   00000010   0xEBAC 0x0C03      SUB      R12,R12,R3
   \   00000014   0xF8C0 0xC000      STR      R12,[R0, #+0]
    558          		nv_timer->pause_value -= diff_timer;
    559          		nv_timer->compare -= diff_timer;
    560          		nv_timer->last_handle_counter -= diff_timer;
   \   00000018   0x1AD2             SUBS     R2,R2,R3
   \   0000001A   0xF8D0 0xC004      LDR      R12,[R0, #+4]
   \   0000001E   0xEBAC 0x0C03      SUB      R12,R12,R3
   \   00000022   0xF8C0 0xC004      STR      R12,[R0, #+4]
   \   00000026   0xF8D0 0xC008      LDR      R12,[R0, #+8]
   \   0000002A   0xEBAC 0x0C03      SUB      R12,R12,R3
   \   0000002E   0xF8C0 0xC008      STR      R12,[R0, #+8]
   \   00000032   0x60C2             STR      R2,[R0, #+12]
    561          	}
    562          	else
    563          	{
    564          		// for instance:
    565          		// Last time the last_handle_counter was 3000 and all values related to that..
    566          		// Now the Handle_Counter is 4000
    567          		// diff_timer  will be 1000
    568          		// and the timers was behind of the current timer
    569          		// All values should be incremented by the difference
    570          		diff_timer = Handle_Counter - nv_timer->last_handle_counter;
    571          		nv_timer->reference += diff_timer;
    572          		nv_timer->pause_value += diff_timer;
    573          		nv_timer->compare += diff_timer;
    574          		nv_timer->last_handle_counter += diff_timer;
    575          	}
    576          	nv_timer->last_handle_counter = Handle_Counter;
   \   00000034   0x60C1             STR      R1,[R0, #+12]
    577          }
   \   00000036   0x4770             BX       LR
   \                     ??SystemTimers__NVRestore_0: (+1)
   \   00000038   0x1A8B             SUBS     R3,R1,R2
   \   0000003A   0x449C             ADD      R12,R3,R12
   \   0000003C   0xF8C0 0xC000      STR      R12,[R0, #+0]
   \   00000040   0x189A             ADDS     R2,R3,R2
   \   00000042   0xF8D0 0xC004      LDR      R12,[R0, #+4]
   \   00000046   0x449C             ADD      R12,R3,R12
   \   00000048   0xF8C0 0xC004      STR      R12,[R0, #+4]
   \   0000004C   0xF8D0 0xC008      LDR      R12,[R0, #+8]
   \   00000050   0x449C             ADD      R12,R3,R12
   \   00000052   0xF8C0 0xC008      STR      R12,[R0, #+8]
   \   00000056   0x60C2             STR      R2,[R0, #+12]
   \   00000058   0x60C1             STR      R1,[R0, #+12]
   \   0000005A   0x4770             BX       LR               ;; return
    578          
    579          
    580          
    581          //---------------------------------------------------------------------------------------------------------------------
    582          /**
    583           * @brief This method set a NVTimer using milliseconds
    584           * @param nv_timer
    585           * @param ms_duration
    586           * @return
    587           */

   \                                 In section .text, align 2, keep-with-next
    588          PASS_FAIL_TYPE SystemTimers__NVSetTimerMS(SYSTEMTIMER_NV_TIMER_TYPE * nv_timer, uint32 ms_duration,SYSTEMTIMERS_TYPE_TYPE type)
    589          {
   \                     SystemTimers__NVSetTimerMS: (+1)
   \   00000000   0x....             LDR.N    R3,??DataTable21
   \   00000002   0x6D5B             LDR      R3,[R3, #+84]
   \   00000004   0x6003             STR      R3,[R0, #+0]
    590          	nv_timer->reference = Handle_Counter;
    591          	nv_timer->compare = Handle_Counter + ms_duration;
   \   00000006   0x18C9             ADDS     R1,R1,R3
   \   00000008   0x6081             STR      R1,[R0, #+8]
    592          	nv_timer->type = type;
   \   0000000A   0x7482             STRB     R2,[R0, #+18]
    593          	nv_timer->n_type = (SYSTEMTIMERS_TYPE_TYPE)(~type);
                 	                                            ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \   0000000C   0x43D1             MVNS     R1,R2
   \   0000000E   0x74C1             STRB     R1,[R0, #+19]
    594          	nv_timer->state = SYSTEMTIMERS_STATE_RUNNING;
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x7401             STRB     R1,[R0, #+16]
    595          	nv_timer->n_state = SYSTEMTIMERS_STATE_N_RUNNING;
   \   00000014   0xF06F 0x0101      MVN      R1,#+1
   \   00000018   0x7441             STRB     R1,[R0, #+17]
    596          	nv_timer->last_handle_counter = Handle_Counter;
   \   0000001A   0x60C3             STR      R3,[R0, #+12]
    597          	return (PASS);
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x4770             BX       LR               ;; return
    598          }
    599          
    600          //---------------------------------------------------------------------------------------------------------------------
    601          /**
    602           * @brief This method Sets a NVtimer using HMS data
    603           * @param nv_timer
    604           * @param time
    605           * @return
    606           */

   \                                 In section .text, align 2, keep-with-next
    607          PASS_FAIL_TYPE SystemTimers__NVSetTimerHMS(SYSTEMTIMER_NV_TIMER_TYPE * nv_timer, SYSTEMTIMER_HMS_TYPE * time,SYSTEMTIMERS_TYPE_TYPE type)
    608          {
    609          	uint32 value;
    610          	value = ((((uint32)time->hours * 60) + (uint32)time->minutes) * 60) + (uint32)time->seconds;
   \                     SystemTimers__NVSetTimerHMS: (+1)
   \   00000000   0x788B             LDRB     R3,[R1, #+2]
   \   00000002   0xEBC3 0x1C03      RSB      R12,R3,R3, LSL #+4
   \   00000006   0xEA4F 0x038C      LSL      R3,R12,#+2
   \   0000000A   0xF891 0xC003      LDRB     R12,[R1, #+3]
   \   0000000E   0x7909             LDRB     R1,[R1, #+4]
   \   00000010   0x4463             ADD      R3,R3,R12
   \   00000012   0xEBC3 0x1C03      RSB      R12,R3,R3, LSL #+4
   \   00000016   0x....             LDR.N    R3,??DataTable21
   \   00000018   0x6D5B             LDR      R3,[R3, #+84]
   \   0000001A   0x6003             STR      R3,[R0, #+0]
   \   0000001C   0xEB01 0x018C      ADD      R1,R1,R12, LSL #+2
    611          	value *= 1000;
    612          	nv_timer->reference = Handle_Counter;
    613          	nv_timer->compare = Handle_Counter + value;
   \   00000020   0xF44F 0x7C7A      MOV      R12,#+1000
   \   00000024   0xFB0C 0x3101      MLA      R1,R12,R1,R3
   \   00000028   0x6081             STR      R1,[R0, #+8]
    614          	nv_timer->type = type;
   \   0000002A   0x7482             STRB     R2,[R0, #+18]
    615          	nv_timer->n_type = (SYSTEMTIMERS_TYPE_TYPE)(~type);
                 	                                            ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \   0000002C   0x43D1             MVNS     R1,R2
   \   0000002E   0x74C1             STRB     R1,[R0, #+19]
    616          	nv_timer->state = SYSTEMTIMERS_STATE_RUNNING;
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0x7401             STRB     R1,[R0, #+16]
    617          	nv_timer->n_state = SYSTEMTIMERS_STATE_N_RUNNING;
   \   00000034   0xF06F 0x0101      MVN      R1,#+1
   \   00000038   0x7441             STRB     R1,[R0, #+17]
    618          	nv_timer->last_handle_counter = Handle_Counter;
   \   0000003A   0x60C3             STR      R3,[R0, #+12]
    619          
    620          	return (PASS);
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x4770             BX       LR               ;; return
    621          }
    622          
    623          //---------------------------------------------------------------------------------------------------------------------
    624          /**
    625           * @brief This method checks the state of a NVTimer
    626           * @param nv_timer
    627           * @return
    628           */

   \                                 In section .text, align 2, keep-with-next
    629          SYSTEMTIMERS_STATE_TYPE SystemTimers__NVCheckTimer(SYSTEMTIMER_NV_TIMER_TYPE * nv_timer)
    630          {
   \                     SystemTimers__NVCheckTimer: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable21
   \   00000002   0x6D49             LDR      R1,[R1, #+84]
   \   00000004   0x60C1             STR      R1,[R0, #+12]
    631          	EvalTimer (nv_timer);
   \   00000006   0xF990 0x2010      LDRSB    R2,[R0, #+16]
   \   0000000A   0x2A01             CMP      R2,#+1
   \   0000000C   0xD110             BNE.N    ??SystemTimers__NVCheckTimer_0
   \   0000000E   0x6802             LDR      R2,[R0, #+0]
   \   00000010   0x4291             CMP      R1,R2
   \   00000012   0xBF38             IT       CC 
   \   00000014   0x1E49             SUBCC    R1,R1,#+1
   \   00000016   0x6883             LDR      R3,[R0, #+8]
   \   00000018   0x1A89             SUBS     R1,R1,R2
   \   0000001A   0x4293             CMP      R3,R2
   \   0000001C   0xBF38             IT       CC 
   \   0000001E   0x1E5B             SUBCC    R3,R3,#+1
   \   00000020   0x1A9A             SUBS     R2,R3,R2
   \   00000022   0x4291             CMP      R1,R2
   \   00000024   0xD30B             BCC.N    ??SystemTimers__NVCheckTimer_1
   \   00000026   0x2102             MOVS     R1,#+2
   \   00000028   0x7401             STRB     R1,[R0, #+16]
   \   0000002A   0xF06F 0x0102      MVN      R1,#+2
   \   0000002E   0xE005             B.N      ??SystemTimers__NVCheckTimer_2
   \                     ??SystemTimers__NVCheckTimer_0: (+1)
   \   00000030   0x2A05             CMP      R2,#+5
   \   00000032   0xDB04             BLT.N    ??SystemTimers__NVCheckTimer_1
   \   00000034   0x2104             MOVS     R1,#+4
   \   00000036   0x7401             STRB     R1,[R0, #+16]
   \   00000038   0xF06F 0x0104      MVN      R1,#+4
   \                     ??SystemTimers__NVCheckTimer_2: (+1)
   \   0000003C   0x7441             STRB     R1,[R0, #+17]
    632          	return (nv_timer->state);
   \                     ??SystemTimers__NVCheckTimer_1: (+1)
   \   0000003E   0xF990 0x0010      LDRSB    R0,[R0, #+16]
   \   00000042   0x4770             BX       LR               ;; return
    633          }
    634          
    635          //---------------------------------------------------------------------------------------------------------------------
    636          /**
    637           * @brief This method Pause a NVTimer
    638           * @param nv_timer
    639           * @return
    640           */

   \                                 In section .text, align 2, keep-with-next
    641          PASS_FAIL_TYPE SystemTimers__NVPauseTimer(SYSTEMTIMER_NV_TIMER_TYPE * nv_timer)
    642          {
    643          	if (nv_timer->state == SYSTEMTIMERS_STATE_RUNNING)
   \                     SystemTimers__NVPauseTimer: (+1)
   \   00000000   0xF990 0x1010      LDRSB    R1,[R0, #+16]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD10A             BNE.N    ??SystemTimers__NVPauseTimer_0
   \   00000008   0x....             LDR.N    R1,??DataTable21
   \   0000000A   0x6D49             LDR      R1,[R1, #+84]
   \   0000000C   0x6041             STR      R1,[R0, #+4]
    644          	{
    645          		nv_timer->pause_value = Handle_Counter;
    646          		nv_timer->state = SYSTEMTIMERS_STATE_PAUSED;
   \   0000000E   0x2203             MOVS     R2,#+3
   \   00000010   0x7402             STRB     R2,[R0, #+16]
    647          		nv_timer->n_state = SYSTEMTIMERS_STATE_N_PAUSED;
   \   00000012   0xF06F 0x0203      MVN      R2,#+3
   \   00000016   0x7442             STRB     R2,[R0, #+17]
    648          		nv_timer->last_handle_counter = Handle_Counter;
   \   00000018   0x60C1             STR      R1,[R0, #+12]
    649          		return (PASS);
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x4770             BX       LR
    650          	}
    651          	else
    652          	{
    653          		return (FAIL);
   \                     ??SystemTimers__NVPauseTimer_0: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x4770             BX       LR               ;; return
    654          	}
    655          }
    656          
    657          //---------------------------------------------------------------------------------------------------------------------
    658          /**
    659           * @brief This Method Resumes a NVTimer
    660           * @param nv_timer
    661           * @return
    662           */

   \                                 In section .text, align 2, keep-with-next
    663          PASS_FAIL_TYPE SystemTimers__NVResumeTimer(SYSTEMTIMER_NV_TIMER_TYPE * nv_timer)
    664          {
    665          	if (nv_timer->state == SYSTEMTIMERS_STATE_PAUSED)
   \                     SystemTimers__NVResumeTimer: (+1)
   \   00000000   0xF990 0x1010      LDRSB    R1,[R0, #+16]
   \   00000004   0x2903             CMP      R1,#+3
   \   00000006   0xD112             BNE.N    ??SystemTimers__NVResumeTimer_0
   \   00000008   0x....             LDR.N    R1,??DataTable21
   \   0000000A   0x6842             LDR      R2,[R0, #+4]
   \   0000000C   0x6D49             LDR      R1,[R1, #+84]
    666          	{
    667          		// reference ---  pause ----- compare
    668          		// ---------------------------------------- handle
    669          		uint32 delta = Handle_Counter - nv_timer->pause_value;
    670          		nv_timer->reference += delta;
   \   0000000E   0x6803             LDR      R3,[R0, #+0]
   \   00000010   0x1A8A             SUBS     R2,R1,R2
   \   00000012   0x18D3             ADDS     R3,R2,R3
   \   00000014   0x6003             STR      R3,[R0, #+0]
    671          		nv_timer->compare += delta;
   \   00000016   0x6883             LDR      R3,[R0, #+8]
   \   00000018   0x18D2             ADDS     R2,R2,R3
   \   0000001A   0x6082             STR      R2,[R0, #+8]
    672          		nv_timer->pause_value = nv_timer->compare;
   \   0000001C   0x6042             STR      R2,[R0, #+4]
    673          		nv_timer->state = SYSTEMTIMERS_STATE_RUNNING;
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x7402             STRB     R2,[R0, #+16]
    674          		nv_timer->n_state = SYSTEMTIMERS_STATE_N_RUNNING;
   \   00000022   0xF06F 0x0201      MVN      R2,#+1
   \   00000026   0x7442             STRB     R2,[R0, #+17]
    675          		nv_timer->last_handle_counter = Handle_Counter;
   \   00000028   0x60C1             STR      R1,[R0, #+12]
    676          		return (PASS);
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x4770             BX       LR
    677          	}
    678          	else
    679          	{
    680          		return (FAIL);
   \                     ??SystemTimers__NVResumeTimer_0: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x4770             BX       LR               ;; return
    681          	}
    682          }
    683          
    684          //---------------------------------------------------------------------------------------------------------------------
    685          /**
    686           * @brief This method exposes a NV timer in milliseconds
    687           * @param nv_timer
    688           * @return
    689           */

   \                                 In section .text, align 2, keep-with-next
    690          uint32 SystemTimers__NVGetTimerMs(SYSTEMTIMER_NV_TIMER_TYPE * nv_timer)
    691          {
   \                     SystemTimers__NVGetTimerMs: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    692          	uint32 retval;
    693          	retval = 0;
   \   00000002   0x....             LDR.N    R2,??DataTable21
   \   00000004   0x6D52             LDR      R2,[R2, #+84]
   \   00000006   0x60C2             STR      R2,[R0, #+12]
   \   00000008   0x2100             MOVS     R1,#+0
    694          	EvalTimer (nv_timer);
   \   0000000A   0xF990 0x3010      LDRSB    R3,[R0, #+16]
   \   0000000E   0x2B01             CMP      R3,#+1
   \   00000010   0xD11D             BNE.N    ??SystemTimers__NVGetTimerMs_0
   \   00000012   0x6804             LDR      R4,[R0, #+0]
   \   00000014   0x42A2             CMP      R2,R4
   \   00000016   0xBF2E             ITEE     CS 
   \   00000018   0x1B15             SUBCS    R5,R2,R4
   \   0000001A   0x1E55             SUBCC    R5,R2,#+1
   \   0000001C   0x1B2D             SUBCC    R5,R5,R4
   \   0000001E   0x6886             LDR      R6,[R0, #+8]
   \   00000020   0x42A6             CMP      R6,R4
   \   00000022   0xBF38             IT       CC 
   \   00000024   0x1E76             SUBCC    R6,R6,#+1
   \   00000026   0x1B34             SUBS     R4,R6,R4
   \   00000028   0x42A5             CMP      R5,R4
   \   0000002A   0xD31A             BCC.N    ??SystemTimers__NVGetTimerMs_1
   \   0000002C   0x2202             MOVS     R2,#+2
   \   0000002E   0x7402             STRB     R2,[R0, #+16]
   \   00000030   0xF06F 0x0202      MVN      R2,#+2
   \   00000034   0x7442             STRB     R2,[R0, #+17]
    695          	switch (nv_timer->state)
    696          	{
    697          		case SYSTEMTIMERS_STATE_RUNNING:
    698          			// reference  ----- Handle_Counter -----  nv_timer->compare
    699          			if (nv_timer->type == SYSTEMTIMERS_TYPE_DOWN_COUNTER)
    700          			{
    701          				if (nv_timer->compare >= Handle_Counter)
    702          				{
    703          					retval = nv_timer->compare - Handle_Counter;
    704          				}
    705          				else
    706          				{
    707          					retval = nv_timer->compare + (0xFFFFFFFF - Handle_Counter);
    708          				}
    709          			}
    710          			else
    711          			{
    712          				if (Handle_Counter >= nv_timer->reference)
    713          				{
    714          					retval = Handle_Counter - nv_timer->reference;
    715          				}
    716          				else
    717          				{
    718          					// in this case the reference is bigger than the the counter which demosntrante overflow of the cunter or underflow of the reference
    719          
    720          					retval = Handle_Counter + (0xFFFFFFFF - nv_timer->reference);
    721          				}
    722          			}
    723          			break;
    724          		case SYSTEMTIMERS_STATE_DONE:
    725          			if (nv_timer->type == SYSTEMTIMERS_TYPE_DOWN_COUNTER)
   \                     ??SystemTimers__NVGetTimerMs_2: (+1)
   \   00000036   0xF990 0x2012      LDRSB    R2,[R0, #+18]
   \   0000003A   0x2A00             CMP      R2,#+0
   \   0000003C   0xD043             BEQ.N    ??SystemTimers__NVGetTimerMs_3
    726          			{
    727          				retval = 0;
    728          			}
    729          			else
    730          			{
    731          				if (nv_timer->compare >= nv_timer->reference)
   \   0000003E   0x6886             LDR      R6,[R0, #+8]
   \   00000040   0x6804             LDR      R4,[R0, #+0]
   \   00000042   0x42A6             CMP      R6,R4
   \   00000044   0xD329             BCC.N    ??SystemTimers__NVGetTimerMs_4
    732          				{
    733          					retval = nv_timer->compare - nv_timer->reference;
   \   00000046   0x1B31             SUBS     R1,R6,R4
    734          				}
    735          				else
    736          				{
    737          					retval = nv_timer->compare + ( 0xFFFFFFFF - nv_timer->reference);
    738          
    739          				}
    740          			}
    741          			break;
    742          		case SYSTEMTIMERS_STATE_PAUSED:
    743          			// reference  ----- pause -----  nv_timer->compare
    744          			if (nv_timer->type == SYSTEMTIMERS_TYPE_DOWN_COUNTER)
    745          			{
    746          				if (nv_timer->compare >= nv_timer->pause_value)
    747          				{
    748          					retval = nv_timer->compare - nv_timer->pause_value;
    749          				}
    750          				else
    751          				{
    752          					retval = nv_timer->compare +(0xFFFFFFFF - nv_timer->pause_value);
    753          				}
    754          			}
    755          			else
    756          			{
    757          				if (nv_timer->pause_value > nv_timer->reference)
    758          				{
    759          					retval = nv_timer->pause_value - nv_timer->reference;
    760          				}
    761          				else
    762          				{
    763          					retval = nv_timer->pause_value + (0xFFFFFFFF - nv_timer->reference);
    764          				}
    765          			}
    766          			break;
    767          		default:
    768          //		case SYSTEMTIMERS_STATE_STOPPED:   // default , STOPPED and INVALID shall return 0
    769          //		case SYSTEMTIMERS_STATE_INVALID:
    770          			break;
    771          	}
    772          	return (retval);
   \   00000048   0xBC70             POP      {R4-R6}
   \   0000004A   0x4608             MOV      R0,R1
   \   0000004C   0x4770             BX       LR
   \                     ??SystemTimers__NVGetTimerMs_0: (+1)
   \   0000004E   0x2B05             CMP      R3,#+5
   \   00000050   0xDB07             BLT.N    ??SystemTimers__NVGetTimerMs_1
   \   00000052   0x2204             MOVS     R2,#+4
   \   00000054   0x7402             STRB     R2,[R0, #+16]
   \   00000056   0xF06F 0x0204      MVN      R2,#+4
   \   0000005A   0x7442             STRB     R2,[R0, #+17]
   \   0000005C   0x4608             MOV      R0,R1
   \   0000005E   0xBC70             POP      {R4-R6}
   \   00000060   0x4770             BX       LR
   \                     ??SystemTimers__NVGetTimerMs_1: (+1)
   \   00000062   0x2B01             CMP      R3,#+1
   \   00000064   0xD006             BEQ.N    ??SystemTimers__NVGetTimerMs_5
   \   00000066   0xD32E             BCC.N    ??SystemTimers__NVGetTimerMs_3
   \   00000068   0x2B03             CMP      R3,#+3
   \   0000006A   0xD018             BEQ.N    ??SystemTimers__NVGetTimerMs_6
   \   0000006C   0xD3E3             BCC.N    ??SystemTimers__NVGetTimerMs_2
   \   0000006E   0xBC70             POP      {R4-R6}
   \   00000070   0x4608             MOV      R0,R1
   \   00000072   0x4770             BX       LR
   \                     ??SystemTimers__NVGetTimerMs_5: (+1)
   \   00000074   0xF990 0x1012      LDRSB    R1,[R0, #+18]
   \   00000078   0xB941             CBNZ.N   R1,??SystemTimers__NVGetTimerMs_7
   \   0000007A   0x6886             LDR      R6,[R0, #+8]
   \   0000007C   0x4296             CMP      R6,R2
   \   0000007E   0xBF3A             ITTE     CC 
   \   00000080   0x1E70             SUBCC    R0,R6,#+1
   \   00000082   0x1A81             SUBCC    R1,R0,R2
   \   00000084   0x1AB1             SUBCS    R1,R6,R2
   \   00000086   0xBC70             POP      {R4-R6}
   \   00000088   0x4608             MOV      R0,R1
   \   0000008A   0x4770             BX       LR
   \                     ??SystemTimers__NVGetTimerMs_7: (+1)
   \   0000008C   0x6804             LDR      R4,[R0, #+0]
   \   0000008E   0x42A2             CMP      R2,R4
   \   00000090   0xBF28             IT       CS 
   \   00000092   0x1B11             SUBCS    R1,R2,R4
   \   00000094   0xD217             BCS.N    ??SystemTimers__NVGetTimerMs_3
   \   00000096   0x1E50             SUBS     R0,R2,#+1
   \   00000098   0xE014             B.N      ??SystemTimers__NVGetTimerMs_8
   \                     ??SystemTimers__NVGetTimerMs_4: (+1)
   \   0000009A   0x1E70             SUBS     R0,R6,#+1
   \   0000009C   0xE012             B.N      ??SystemTimers__NVGetTimerMs_8
   \                     ??SystemTimers__NVGetTimerMs_6: (+1)
   \   0000009E   0x6841             LDR      R1,[R0, #+4]
   \   000000A0   0xF990 0x2012      LDRSB    R2,[R0, #+18]
   \   000000A4   0xB942             CBNZ.N   R2,??SystemTimers__NVGetTimerMs_9
   \   000000A6   0x6886             LDR      R6,[R0, #+8]
   \   000000A8   0x428E             CMP      R6,R1
   \   000000AA   0xBF3A             ITTE     CC 
   \   000000AC   0x1E70             SUBCC    R0,R6,#+1
   \   000000AE   0x1A41             SUBCC    R1,R0,R1
   \   000000B0   0x1A71             SUBCS    R1,R6,R1
   \   000000B2   0xBC70             POP      {R4-R6}
   \   000000B4   0x4608             MOV      R0,R1
   \   000000B6   0x4770             BX       LR
   \                     ??SystemTimers__NVGetTimerMs_9: (+1)
   \   000000B8   0x6804             LDR      R4,[R0, #+0]
   \   000000BA   0x428C             CMP      R4,R1
   \   000000BC   0xBF38             IT       CC 
   \   000000BE   0x1B09             SUBCC    R1,R1,R4
   \   000000C0   0xD301             BCC.N    ??SystemTimers__NVGetTimerMs_3
   \   000000C2   0x1E48             SUBS     R0,R1,#+1
   \                     ??SystemTimers__NVGetTimerMs_8: (+1)
   \   000000C4   0x1B01             SUBS     R1,R0,R4
   \                     ??SystemTimers__NVGetTimerMs_3: (+1)
   \   000000C6   0xBC70             POP      {R4-R6}
   \   000000C8   0x4608             MOV      R0,R1
   \   000000CA   0x4770             BX       LR               ;; return
    773          }
    774          
    775          //---------------------------------------------------------------------------------------------------------------------
    776          /**
    777           * @brief This method exposes a timer in HMS format
    778           * @param nv_timer
    779           * @param time
    780           * @return
    781           */

   \                                 In section .text, align 2, keep-with-next
    782          PASS_FAIL_TYPE SystemTimers__NVGetTimerHMS(SYSTEMTIMER_NV_TIMER_TYPE * nv_timer, SYSTEMTIMER_HMS_TYPE * time)
    783          {
   \                     SystemTimers__NVGetTimerHMS: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    784          	uint32 value;
    785          	value = SystemTimers__NVGetTimerMs(nv_timer);
   \   00000004   0x.... 0x....      BL       SystemTimers__NVGetTimerMs
    786          	time->milliseconds = (uint16)(value % 1000);
   \   00000008   0xF44F 0x717A      MOV      R1,#+1000
   \   0000000C   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   00000010   0xF44F 0x727A      MOV      R2,#+1000
   \   00000014   0xFB02 0x0011      MLS      R0,R2,R1,R0
   \   00000018   0x8020             STRH     R0,[R4, #+0]
    787          	value /= 1000;
    788          	time->seconds = (uint8)(value % 60);
   \   0000001A   0x203C             MOVS     R0,#+60
   \   0000001C   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \   00000020   0xEBC0 0x1200      RSB      R2,R0,R0, LSL #+4
   \   00000024   0xEBA1 0x0182      SUB      R1,R1,R2, LSL #+2
   \   00000028   0x7121             STRB     R1,[R4, #+4]
    789          	value /= 60;
    790          	time->minutes = (uint8)(value % 60);
   \   0000002A   0x213C             MOVS     R1,#+60
   \   0000002C   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   00000030   0xEBC1 0x1201      RSB      R2,R1,R1, LSL #+4
   \   00000034   0xEBA0 0x0082      SUB      R0,R0,R2, LSL #+2
   \   00000038   0x70E0             STRB     R0,[R4, #+3]
    791          	value /= 60;
    792          	time->hours = (uint8)value;
   \   0000003A   0x70A1             STRB     R1,[R4, #+2]
    793          
    794          	return (PASS);
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    795          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     All_Timers
    796          
    797          //=====================================================================================================================
    798          //-------------------------------------- Private Functions ------------------------------------------------------------
    799          //=====================================================================================================================
    800          
    801          //---------------------------------------------------------------------------------------------------------------------
    802          /**
    803           * @brief Local method to evaluate a NVTimer
    804           * @param nv_timer
    805           */
    806          static void EvalTimer(SYSTEMTIMER_NV_TIMER_TYPE * nv_timer)
    807          {
    808          	nv_timer->last_handle_counter = Handle_Counter;
    809          	if (nv_timer->state == SYSTEMTIMERS_STATE_RUNNING)
    810          	{
    811          		//  |--reference  --------  compare ---|
    812          		//  |----------------------------------|
    813          
    814          		uint32 current;
    815          		uint32 compare;
    816          
    817          		if (Handle_Counter >= nv_timer->reference)
    818          		{
    819          			current = Handle_Counter - nv_timer->reference;
    820          		}
    821          		else
    822          		{
    823          			current = Handle_Counter +(0xFFFFFFFF - nv_timer->reference);
    824          		}
    825          
    826          		if (nv_timer->compare >= nv_timer->reference)
    827          		{
    828          			compare = nv_timer->compare - nv_timer->reference;
    829          		}
    830          		else
    831          		{
    832          			compare = nv_timer->compare + (0xFFFFFFFF - nv_timer->reference);
    833          		}
    834          
    835          		if (compare <= current)
    836          		{
    837          			nv_timer->state = SYSTEMTIMERS_STATE_DONE;
    838          			nv_timer->n_state = SYSTEMTIMERS_STATE_N_DONE;
    839          		}
    840          
    841          	}
    842          	else if (nv_timer->state > SYSTEMTIMERS_STATE_INVALID)
    843          	{
    844          		nv_timer->state = SYSTEMTIMERS_STATE_INVALID;
    845          		nv_timer->n_state = SYSTEMTIMERS_STATE_N_INVALID;
    846          	}
    847          }
    848          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   SystemTimers__GetEvent
       0   SystemTimers__GetFreeRunningCounter
      12   SystemTimers__GetHMS
      12   SystemTimers__GetHandle
       8   SystemTimers__GetMs
       0   SystemTimers__GetState
       0   SystemTimers__Handler1ms
       8   SystemTimers__Initialize
         8   -> Micro__GetResetMode
       0   SystemTimers__NVCheckTimer
       8   SystemTimers__NVGetTimerHMS
         8   -> SystemTimers__NVGetTimerMs
      12   SystemTimers__NVGetTimerMs
       0   SystemTimers__NVPauseTimer
       0   SystemTimers__NVResetTimer
       0   SystemTimers__NVRestore
       0   SystemTimers__NVResumeTimer
       0   SystemTimers__NVSetTimerHMS
       0   SystemTimers__NVSetTimerMS
      12   SystemTimers__Pause
       0   SystemTimers__ReleaseHandle
       0   SystemTimers__Reset
       8   SystemTimers__Resume
      16   SystemTimers__SetHMS
      16   SystemTimers__SetMs


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable21
      88  All_Timers
          Handle_Reference
          Handle_Counter
      42  SystemTimers__GetEvent
       8  SystemTimers__GetFreeRunningCounter
     148  SystemTimers__GetHMS
      98  SystemTimers__GetHandle
     100  SystemTimers__GetMs
      44  SystemTimers__GetState
      84  SystemTimers__Handler1ms
      50  SystemTimers__Initialize
      68  SystemTimers__NVCheckTimer
      64  SystemTimers__NVGetTimerHMS
     204  SystemTimers__NVGetTimerMs
      34  SystemTimers__NVPauseTimer
      28  SystemTimers__NVResetTimer
      92  SystemTimers__NVRestore
      50  SystemTimers__NVResumeTimer
      64  SystemTimers__NVSetTimerHMS
      32  SystemTimers__NVSetTimerMS
      78  SystemTimers__Pause
      46  SystemTimers__ReleaseHandle
      44  SystemTimers__Reset
      74  SystemTimers__Resume
     110  SystemTimers__SetHMS
      80  SystemTimers__SetMs

 
    88 bytes in section .bss
 1 646 bytes in section .text
 
 1 646 bytes of CODE memory
    88 bytes of DATA memory

Errors: none
Warnings: none
