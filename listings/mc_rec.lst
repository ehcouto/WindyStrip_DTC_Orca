###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        19/Nov/2024  13:15:32
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  Category\Common\MasterCommander\Source\mc_rec.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        mc_rec.obj -l ..\listings\mc_rec.lst
#        Category\Common\MasterCommander\Source\mc_rec.c
#    List file    =  ..\listings\mc_rec.lst
#    Object file  =  mc_rec.obj
#
###############################################################################

C:\Data\Python\Windy_sBpm_Floating\source\Category\Common\MasterCommander\Source\mc_rec.c
      1          /**
      2           *  @file
      3           *
      4           *  @brief      MC Recorder implementation.
      5           *
      6           *
      7           *  $Header: $
      8           *
      9           *  @copyright  Copyright 2016-$Date$. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     10           */
     11          //---------------------------------------------------------------------------------------------------------------------
     12          
     13          //-------------------------------------- Include Files ----------------------------------------------------------------
     14          #include "master_commander.h"
     15          #include "mc_llmem.h"
     16          #include "mc_private.h"
     17          #include "mc_protocol.h"
     18          
     19          #if (MC_USE_RECORDER) && (!(MC_DISABLE))
     20          
     21          #include "../Source/mc_rec.h"
     22          
     23          #if MC_USE_FASTREC
     24          #include "mc_fastrec.h"
     25          #endif
     26          
     27          /********************************************************
     28          *  global variables (shared with FastRecorder if used)
     29          ********************************************************/
     30          
     31          /* configuration variables */

   \                                 In section .bss, align 4
     32          MC_U16  pcm_wRecTotalSmps;        /* number of samples to measure */
     33          
     34          #if MC_REC_STATIC_POSTTRIG == 0
     35          MC_U16  pcm_wRecPostTrigger;      /* number of post-trigger samples to keep */
     36          #endif
     37          
     38          #if (MC_USE_FASTREC) == 0
     39          MC_U8   pcm_nRecTriggerMode;      /* trigger mode (0 = disabled, 1 = _/, 2 = \_) */
   \                     pcm_nRecTriggerMode:
   \   00000000                      DS8 1
     40          #endif
     41          
     42          #if (MC_REC_STATIC_DIVISOR) == 0
     43          MC_U16  pcm_wRecTimeDiv;          /* divisor of recorder "clock" */
     44          #endif
     45          
     46          MC_U8    pcm_nRecVarCount;        /* number of active recorder variables */
   \                     pcm_nRecVarCount:
   \   00000001                      DS8 1
   \   00000002                      DS8 1
   \   00000003                      DS8 1
   \                     pcm_wRecTotalSmps:
   \   00000004                      DS8 2
   \                     pcm_wRecPostTrigger:
   \   00000006                      DS8 2
   \                     pcm_wRecTimeDiv:
   \   00000008                      DS8 2
     47          MC_ADDR  pcm_pRecVarAddr[MC_MAX_SCOPE_VARS]; /* addresses of recorded variables */
     48          MC_SIZE8 pcm_pRecVarSize[MC_MAX_SCOPE_VARS]; /* sizes of recorded variables */
     49          
     50          /* runtime variables  */
     51          #if (MC_REC_STATIC_DIVISOR) != 1
     52          MC_U16  pcm_wRecTimeDivCtr;       /* recorder "clock" divisor counter */
   \                     pcm_wRecTimeDivCtr:
   \   0000000A                      DS8 2
     53          #endif
     54          
     55          MC_U16  pcm_wStoprecCountDown;    /* post-trigger countdown counter */
   \                     pcm_wStoprecCountDown:
   \   0000000C                      DS8 2
     56          
     57          /* recorder flags */
     58          MC_REC_FLAGS pcm_wRecFlags;
     59          
     60          /***********************************
     61          *  local variables 
     62          ***********************************/
     63          
     64          #if (MC_USE_FASTREC) == 0
     65          MC_U16   pcm_wRecBuffStartIx;     /* first sample index */
   \                     pcm_wRecBuffStartIx:
   \   0000000E                      DS8 2
   \                     pcm_pRecVarAddr:
   \   00000010                      DS8 32
   \                     pcm_pRecVarSize:
   \   00000030                      DS8 8
   \                     pcm_wRecFlags:
   \   00000038                      DS8 4
     66          
     67          /* Recorder buffer pointers */
     68          MC_ADDR pcm_dwRecWritePtr;        /* write pointer in recorder buffer */
   \                     pcm_dwRecWritePtr:
   \   0000003C                      DS8 4
     69          MC_ADDR pcm_dwRecEndBuffPtr;      /* pointer to end of active recorder buffer */
   \                     pcm_dwRecEndBuffPtr:
   \   00000040                      DS8 4
   \   00000044                      DS8 4
   \   00000048                      DS8 4
   \   0000004C                      DS8 4
   \   00000050                      DS8 4
   \   00000054                      DS8 1024
     70          
     71          /* configuration variables */
     72          static MC_ADDR pcm_nTrgVarAddr;          /* trigger variable address */
     73          static MC_U8   pcm_nTrgVarSize;          /* trigger variable threshold size */
     74          static MC_U8   pcm_bTrgVarSigned;        /* trigger compare mode (0 = unsigned, 1 = signed) */
     75          
     76          /*lint -e{960} using union */
     77          static union 
     78          {
     79          #if MC_CFG_BUS_WIDTH == 1
     80              MC_U8  u8;
     81              MC_S8  s8;
     82          #endif
     83              MC_U16 u16;
     84              MC_S16 s16;
     85              MC_U32 u32;
     86              MC_S32 s32;
     87          #if MC_REC_FLOAT_TRIG
     88              MC_FLOAT fp;
     89          #endif
     90          } pcm_uTrgThreshold;                        /* trigger threshold level (1,2 or 4 bytes) */
     91          #endif /* (MC_USE_FASTREC) == 0 */
     92          
     93          static MC_ADDR  pcm_nRecBuffAddr;        /* recorder buffer address */
     94          #if MC_REC_OWNBUFF
     95          static MC_SIZE  pcm_wRecBuffSize;        /* recorder buffer size */
     96          #endif
     97          /* compare functions prototype */
     98          typedef MC_BOOL (*MC_PCOMPAREFUNC)(void);
     99          
    100          /*/ pointer to active compare function */
    101          static MC_PCOMPAREFUNC pcm_pCompareFunc;
    102          
    103          #if !MC_REC_OWNBUFF && (MC_USE_FASTREC) == 0
    104          /* put buffer into far memory ? */
    105          #if MC_REC_FARBUFF
    106          #pragma section fardata begin
    107          #endif /* MC_REC_FARBUFF */
    108          /* statically allocated recorder buffer (MC_REC_OWNBUFF is FALSE) */
    109          static MC_U8 pcm_pOwnRecBuffer[MC_REC_BUFF_SIZE];
    110          /* end of far memory section */
    111          #if MC_REC_FARBUFF
    112          #pragma section fardata end
    113          #endif /* MC_REC_FARBUFF */
    114          #endif /* MC_REC_OWNBUFF */
    115          
    116          /***********************************
    117          *  local functions
    118          ***********************************/
    119          
    120          static MC_BOOL MC_Compare8S(void);
    121          static MC_BOOL MC_Compare8U(void);
    122          static MC_BOOL MC_Compare16S(void);
    123          static MC_BOOL MC_Compare16U(void);
    124          static MC_BOOL MC_Compare32S(void);
    125          static MC_BOOL MC_Compare32U(void);
    126          #if MC_REC_FLOAT_TRIG
    127          static MC_BOOL MC_Comparefloat(void);
    128          #endif
    129          static void MC_Recorder2(void);
    130          
    131          /**************************************************************************//*!
    132          *
    133          * @brief    Recorder Initialization
    134          *
    135          ******************************************************************************/
    136          

   \                                 In section .text, align 2, keep-with-next
    137          void MC_InitRec(void)
    138          {   
    139              /* initialize Recorder flags*/
    140              pcm_wRecFlags.all = 0U;
   \                     MC_InitRec: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0xF880 0x1038      STRB     R1,[R0, #+56]
    141          
    142              /* setup buffer pointer and size so IsInRecBuffer works even  
    143                 before the recorder is first initialized and used */
    144              
    145          #if MC_REC_OWNBUFF
    146              /* user wants to use his own buffer */
    147              pcm_nRecBuffAddr = 0U;
    148              pcm_wRecBuffSize = 0U;
    149          #elif MC_USE_FASTREC
    150              /* Initialize Fast Recorder Buffer  */
    151              MC_InitFastRec();
    152          #else
    153              /* size in native sizeof units (=bytes on most platforms) */
    154              MC_ARR2ADDR(pcm_nRecBuffAddr, pcm_pOwnRecBuffer);
   \   0000000A   0xF100 0x0154      ADD      R1,R0,#+84
   \   0000000E   0x64C1             STR      R1,[R0, #+76]
    155              
    156              /*lint -esym(528, pcm_pOwnRecBuffer) this symbol is used outside of lint sight */
    157          #endif
    158          
    159          }
   \   00000010   0x4770             BX       LR               ;; return
    160          
    161          /**************************************************************************//*!
    162          *
    163          * @brief    Abort and de-initialize recorder
    164          *
    165          ******************************************************************************/
    166          
    167          #if defined(MC_PLATFORM_HC08) || defined(MC_PLATFORM_HC12)
    168          #pragma INLINE
    169          #elif defined(__ARMCC_VERSION)
    170          __inline
    171          #else
    172          static inline
    173          #endif
    174          void MC_AbortRec(void)
    175          {
    176              /* clear flags */
    177              pcm_wRecFlags.all = 0U;
    178          }
    179          
    180          /**************************************************************************//*!
    181          *
    182          * @brief    API: Replacing the recorder buffer with the user's one
    183          *
    184          * @param    pBuffer - user buffer pointer
    185          * @param    wBuffSize - buffer size
    186          *
    187          * @note Use the MC_SetUpBuff32 to pass the forced 32bit address in SDM
    188          *
    189          ******************************************************************************/
    190          

   \                                 In section .text, align 2, keep-with-next
    191          void MC_SetUpRecBuff(MC_ADDR pBuffer, MC_SIZE nBuffSize)
                                              ^
Remark[Pe826]: parameter "pBuffer" was never referenced

  void MC_SetUpRecBuff(MC_ADDR pBuffer, MC_SIZE nBuffSize)
                                                ^
"C:\Data\Python\Windy_sBpm_Floating\source\Category\Common\MasterCommander\Source\mc_rec.c",191  Remark[Pe826]: 
          parameter "nBuffSize" was never referenced
    192          {    
    193          #if MC_REC_OWNBUFF
    194              pcm_nRecBuffAddr = pBuffer;
    195              pcm_wRecBuffSize = nBuffSize;
    196          #else
    197              MC_UNUSED(pBuffer);
    198              MC_UNUSED(nBuffSize);
    199          #endif
    200          }
   \                     MC_SetUpRecBuff: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    201          
    202          /**************************************************************************//*!
    203          *
    204          * @brief    Handling SETUPREC and SETUPREC_EX commands
    205          *
    206          * @param    pMessageIO - original command (in) and response buffer (out) 
    207          *
    208          * @return   As all command handlers, the return value should be the buffer 
    209          *           pointer where the response output finished (except checksum)
    210          *
    211          ******************************************************************************/
    212          

   \                                 In section .text, align 4, keep-with-next
    213          MC_BPTR MC_SetUpRec(MC_BPTR pMessageIO)
    214          {
   \                     MC_SetUpRec: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4682             MOV      R10,R0
    215              MC_BPTR pResponse = pMessageIO;
    216              MC_SIZE8 nRecVarsetSize;
    217              MC_SIZE blen;
    218              MC_U8 i, sz;
    219              MC_U8 nResponseCode;
    220              
    221              /* de-initialize first   */
    222              MC_AbortRec();
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable16
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF884 0x0038      STRB     R0,[R4, #+56]
    223          
    224          #if MC_REC_OWNBUFF
    225              /* user wants to use his own buffer, check if it is valid */
    226              if(!pcm_nRecBuffAddr || !pcm_wRecBuffSize)
    227              {
    228                  return MC_ConstToBuffer8(pResponse, MC_STC_INVBUFF);
    229              }
    230          #elif (MC_USE_FASTREC) == 0
    231              /* size in native sizeof units (=bytes on most platforms) */
    232              MC_ARR2ADDR(pcm_nRecBuffAddr, pcm_pOwnRecBuffer);
    233          #endif
    234          
    235              /* seek the setup data */
    236          #if (MC_USE_FASTREC) == 0
    237              pMessageIO = MC_SkipInBuffer(pMessageIO, 2U);
    238              pMessageIO = MC_ValueFromBuffer8(&pcm_nRecTriggerMode, pMessageIO);
   \   00000010   0xF10A 0x0102      ADD      R1,R10,#+2
   \   00000014   0xF104 0x0054      ADD      R0,R4,#+84
   \   00000018   0x64E0             STR      R0,[R4, #+76]
    239          #else /* (MC_USE_FASTREC) == 0 */
    240              pMessageIO = MC_SkipInBuffer(pMessageIO, 3U);
    241          #endif /* (MC_USE_FASTREC) == 0 */
    242          
    243              pMessageIO = MC_ValueFromBuffer16(&pcm_wRecTotalSmps, pMessageIO);
   \   0000001A   0x2202             MOVS     R2,#+2
   \   0000001C   0xF811 0x0B01      LDRB     R0,[R1], #+1
   \   00000020   0x7020             STRB     R0,[R4, #+0]
   \   00000022   0x1D20             ADDS     R0,R4,#+4
   \   00000024   0x.... 0x....      BL       MC_CopyFromBuffer
    244          
    245          #if (MC_REC_STATIC_POSTTRIG) == 0
    246              pMessageIO = MC_ValueFromBuffer16(&pcm_wRecPostTrigger, pMessageIO);
   \   00000028   0x4601             MOV      R1,R0
   \   0000002A   0x2202             MOVS     R2,#+2
   \   0000002C   0x1DA0             ADDS     R0,R4,#+6
   \   0000002E   0x.... 0x....      BL       MC_CopyFromBuffer
    247          #else /* (MC_REC_STATIC_POSTTRIG) == 0 */
    248              pMessageIO = MC_SkipInBuffer(pMessageIO, 2U);
    249          #endif /* (MC_REC_STATIC_POSTTRIG) == 0 */
    250          
    251          #if (MC_REC_STATIC_DIVISOR) == 0
    252              pMessageIO = MC_ValueFromBuffer16(&pcm_wRecTimeDiv, pMessageIO);
   \   00000032   0x4601             MOV      R1,R0
   \   00000034   0x2202             MOVS     R2,#+2
   \   00000036   0xF104 0x0008      ADD      R0,R4,#+8
   \   0000003A   0x.... 0x....      BL       MC_CopyFromBuffer
    253          #else /* (MC_REC_STATIC_DIVISOR) == 0 */
    254              pMessageIO = MC_SkipInBuffer(pMessageIO, 2U);
    255          #endif /* (MC_REC_STATIC_DIVISOR) == 0 */
    256          
    257          #if (MC_USE_FASTREC) == 0
    258              /* address & size of trigger variable */
    259              pMessageIO = MC_AddressFromBuffer(&pcm_nTrgVarAddr, pMessageIO);
    260              pMessageIO = MC_ValueFromBuffer8(&pcm_nTrgVarSize, pMessageIO);
   \   0000003E   0x4601             MOV      R1,R0
   \   00000040   0xF104 0x0044      ADD      R0,R4,#+68
   \   00000044   0x.... 0x....      BL       MC_AddressFromBuffer
   \   00000048   0xF810 0x1B01      LDRB     R1,[R0], #+1
   \   0000004C   0x70A1             STRB     R1,[R4, #+2]
    261          
    262              /* trigger compare mode  */
    263              pMessageIO = MC_ValueFromBuffer8(&pcm_bTrgVarSigned, pMessageIO);
    264          
    265              /* threshold value  */
    266              pMessageIO = MC_ValueFromBuffer32(&pcm_uTrgThreshold.u32, pMessageIO);
    267          #else /* (MC_USE_FASTREC) == 0 */
    268              pMessageIO = MC_SkipInBuffer(pMessageIO, 8U);
    269          #endif /* (MC_USE_FASTREC) == 0 */
    270              
    271              /* recorder variable count */
    272              pMessageIO = MC_ValueFromBuffer8(&pcm_nRecVarCount, pMessageIO);
   \   0000004E   0x2204             MOVS     R2,#+4
   \   00000050   0xF810 0x1B01      LDRB     R1,[R0], #+1
   \   00000054   0x70E1             STRB     R1,[R4, #+3]
   \   00000056   0x4601             MOV      R1,R0
   \   00000058   0xF104 0x0048      ADD      R0,R4,#+72
   \   0000005C   0x.... 0x....      BL       MC_CopyFromBuffer
   \   00000060   0xF810 0x1B01      LDRB     R1,[R0], #+1
   \   00000064   0x7061             STRB     R1,[R4, #+1]
    273          
    274              /* rec variable information must fit into our buffers */
    275              if(!pcm_nRecVarCount || pcm_nRecVarCount > (MC_U8)MC_MAX_REC_VARS)
   \   00000066   0x2900             CMP      R1,#+0
   \   00000068   0xD057             BEQ.N    ??MC_SetUpRec_0
   \   0000006A   0x2909             CMP      R1,#+9
   \   0000006C   0xDA55             BGE.N    ??MC_SetUpRec_0
    276              {
    277          #if MC_REC_COMMON_ERR_CODES
    278                  goto MC_SetUpRec_exit_error;
    279          #else
    280                  nResponseCode = MC_STC_INVBUFF;
    281                  goto MC_SetUpRec_exit;
    282          #endif
    283              }
    284          
    285              /* calculate sum of sizes of all variables */
    286              nRecVarsetSize = 0U;
   \   0000006E   0x2600             MOVS     R6,#+0
    287          
    288              /* get all addresses and sizes */
    289              for(i=0U; i<pcm_nRecVarCount; i++)
   \   00000070   0x2700             MOVS     R7,#+0
   \   00000072   0xF104 0x0830      ADD      R8,R4,#+48
   \   00000076   0xF104 0x0910      ADD      R9,R4,#+16
   \   0000007A   0xE011             B.N      ??MC_SetUpRec_1
    290              {
    291                  /* variable size */
    292                  pMessageIO = MC_ValueFromBuffer8(&sz, pMessageIO);
   \                     ??MC_SetUpRec_2: (+1)
   \   0000007C   0xF810 0x5B01      LDRB     R5,[R0], #+1
    293                  
    294                  pcm_pRecVarSize[i] = sz;
    295                  nRecVarsetSize += sz;
   \   00000080   0x19AE             ADDS     R6,R5,R6
    296                  
    297                  /* variable address */
    298                  pMessageIO = MC_AddressFromBuffer(&pcm_pRecVarAddr[i], pMessageIO);
   \   00000082   0x4601             MOV      R1,R0
   \   00000084   0xF808 0x5B01      STRB     R5,[R8], #+1
   \   00000088   0xB2F6             UXTB     R6,R6
   \   0000008A   0x4648             MOV      R0,R9
   \   0000008C   0x.... 0x....      BL       MC_AddressFromBuffer
    299          
    300                  /* valid numeric variable sizes only */
    301                  if(sz == 0U || sz > 8U)
   \   00000090   0x2D00             CMP      R5,#+0
   \   00000092   0xD042             BEQ.N    ??MC_SetUpRec_0
   \   00000094   0x2D09             CMP      R5,#+9
   \   00000096   0xD240             BCS.N    ??MC_SetUpRec_0
    302                  {
    303          #if MC_REC_COMMON_ERR_CODES
    304                      goto MC_SetUpRec_exit_error;
    305          #else
    306                      nResponseCode = MC_STC_INVSIZE;
    307                      goto MC_SetUpRec_exit;
    308          #endif
    309                  }
    310          
    311          #if MC_CFG_BUS_WIDTH > 1U
    312                  /* even sizes only */
    313                  if(sz & 0x1)
    314                  {
    315          #if MC_REC_COMMON_ERR_CODES
    316                      goto MC_SetUpRec_exit_error;
    317          #else
    318                      nResponseCode = MC_STC_INVSIZE;
    319                      goto MC_SetUpRec_exit;
    320          #endif
    321                  }
    322          #endif /* MC_CFG_BUS_WIDTH > 1U */
    323                  
    324          #if MC_USE_TSA && MC_USE_TSA_SAFETY
    325                  if(!MC_CheckTsaSpace(pcm_pRecVarAddr[i], (MC_SIZE8)sz, 0U))
    326                  {
    327          #if MC_REC_COMMON_ERR_CODES
    328                      goto MC_SetUpRec_exit_error;
    329          #else
    330                      nResponseCode = MC_STC_EACCESS;
    331                      goto MC_SetUpRec_exit;
    332          #endif
    333                  }
    334          #endif /* MC_USE_TSA && MC_USE_TSA_SAFETY */
    335              }
   \   00000098   0x1C7F             ADDS     R7,R7,#+1
   \   0000009A   0xB2FF             UXTB     R7,R7
   \   0000009C   0xF109 0x0904      ADD      R9,R9,#+4
   \                     ??MC_SetUpRec_1: (+1)
   \   000000A0   0x7861             LDRB     R1,[R4, #+1]
   \   000000A2   0x428F             CMP      R7,R1
   \   000000A4   0xDBEA             BLT.N    ??MC_SetUpRec_2
    336          
    337              /* fast recorder handles trigger by itself */
    338          #if (MC_USE_FASTREC) == 0
    339              /* any trigger? */
    340              pcm_pCompareFunc = NULL;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x6520             STR      R0,[R4, #+80]
    341              if(pcm_nRecTriggerMode)
   \   000000AA   0x7820             LDRB     R0,[R4, #+0]
   \   000000AC   0xB310             CBZ.N    R0,??MC_SetUpRec_3
    342              {
    343                  /* access to trigger variable? */
    344          #if MC_USE_TSA && MC_USE_TSA_SAFETY
    345                  if(!MC_CheckTsaSpace(pcm_nTrgVarAddr, (MC_SIZE8)pcm_nTrgVarSize, 0U))
    346                  {
    347          #if MC_REC_COMMON_ERR_CODES
    348                      goto MC_SetUpRec_exit_error;
    349          #else
    350                      nResponseCode = MC_STC_EACCESS;
    351                      goto MC_SetUpRec_exit;
    352          #endif
    353                  }
    354          #endif /* MC_USE_TSA && MC_USE_TSA_SAFETY */
    355                  /* get compare function */
    356          
    357          #if MC_REC_FLOAT_TRIG
    358                  if(pcm_bTrgVarSigned&MC_REC_FLOAT_TRIG_MASK)
   \   000000AE   0x78E0             LDRB     R0,[R4, #+3]
   \   000000B0   0x0781             LSLS     R1,R0,#+30
   \   000000B2   0xBF48             IT       MI 
    359                  {
    360                      pcm_pCompareFunc = MC_Comparefloat;
   \   000000B4   0x.... 0x....      ADRMI.W  R0,MC_Comparefloat
   \   000000B8   0xD41B             BMI.N    ??MC_SetUpRec_4
    361                  }
    362                  else
    363          #else
    364                  if(pcm_bTrgVarSigned&MC_REC_FLOAT_TRIG_MASK)
    365                  {
    366          #if MC_REC_COMMON_ERR_CODES
    367                      goto MC_SetUpRec_exit_error;
    368          #else
    369                      nResponseCode = MC_STC_FLOATDISABLED;
    370                      goto MC_SetUpRec_exit;
    371          #endif
    372                  }
    373          #endif
    374                  {
    375                  switch(pcm_nTrgVarSize)
   \   000000BA   0x78A1             LDRB     R1,[R4, #+2]
   \   000000BC   0x2901             CMP      R1,#+1
   \   000000BE   0xD004             BEQ.N    ??MC_SetUpRec_5
   \   000000C0   0x2902             CMP      R1,#+2
   \   000000C2   0xD009             BEQ.N    ??MC_SetUpRec_6
   \   000000C4   0x2904             CMP      R1,#+4
   \   000000C6   0xD00E             BEQ.N    ??MC_SetUpRec_7
   \   000000C8   0xE027             B.N      ??MC_SetUpRec_0
    376                  {
    377          #if MC_CFG_BUS_WIDTH == 1U
    378                  case 1: pcm_pCompareFunc = pcm_bTrgVarSigned ? MC_Compare8S : MC_Compare8U; break;
   \                     ??MC_SetUpRec_5: (+1)
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xBF0C             ITE      EQ 
   \   000000CE   0x.... 0x....      ADREQ.W  R0,MC_Compare8U
   \   000000D2   0x.... 0x....      ADRNE.W  R0,MC_Compare8S
   \   000000D6   0xE00C             B.N      ??MC_SetUpRec_4
    379          #endif
    380                  case 2: pcm_pCompareFunc = pcm_bTrgVarSigned ? MC_Compare16S : MC_Compare16U; break;
   \                     ??MC_SetUpRec_6: (+1)
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xBF0C             ITE      EQ 
   \   000000DC   0x.... 0x....      ADREQ.W  R0,MC_Compare16U
   \   000000E0   0x.... 0x....      ADRNE.W  R0,MC_Compare16S
   \   000000E4   0xE005             B.N      ??MC_SetUpRec_4
    381                  case 4: pcm_pCompareFunc = pcm_bTrgVarSigned ? MC_Compare32S : MC_Compare32U; break;
   \                     ??MC_SetUpRec_7: (+1)
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xBF14             ITE      NE 
   \   000000EA   0x.... 0x....      ADRNE.W  R0,MC_Compare32S
   \   000000EE   0x.... 0x....      ADREQ.W  R0,MC_Compare32U
   \                     ??MC_SetUpRec_4: (+1)
   \   000000F2   0x6520             STR      R0,[R4, #+80]
    382                  
    383                  /* invalid trigger variable size  */
    384                  default:
    385          #if MC_REC_COMMON_ERR_CODES
    386                      goto MC_SetUpRec_exit_error;
    387          #else
    388                      nResponseCode = MC_STC_INVSIZE;
    389                      goto MC_SetUpRec_exit;
    390          #endif
    391                      }
    392                  }
    393              }
    394          #endif /* (MC_USE_FASTREC) == 0 */
    395              
    396              /* total recorder buffer length in native sizeof units (=bytes on most platforms) */
    397              blen = (MC_SIZE) (pcm_wRecTotalSmps * nRecVarsetSize / MC_CFG_BUS_WIDTH);
   \                     ??MC_SetUpRec_3: (+1)
   \   000000F4   0x88A0             LDRH     R0,[R4, #+4]
   \   000000F6   0x4370             MULS     R0,R0,R6
   \   000000F8   0xB280             UXTH     R0,R0
    398          
    399              /* recorder memory available? */
    400              if(blen > MC_GetRecBuffSize())
   \   000000FA   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000000FE   0xDC0C             BGT.N    ??MC_SetUpRec_0
    401              {
    402          #if MC_REC_COMMON_ERR_CODES
    403                  goto MC_SetUpRec_exit_error;
    404          #else
    405                  nResponseCode = MC_STC_INVSIZE;
    406                  goto MC_SetUpRec_exit;
    407          #endif
    408              }
    409          
    410          #if (MC_USE_FASTREC) == 0
    411              /* remember the effective end of circular buffer */
    412              pcm_dwRecEndBuffPtr = pcm_nRecBuffAddr + blen;
   \   00000100   0x6CE1             LDR      R1,[R4, #+76]
   \   00000102   0x1840             ADDS     R0,R0,R1
   \   00000104   0x6420             STR      R0,[R4, #+64]
    413          #endif /* (MC_USE_FASTREC) == 0 */
    414          
    415          #if MC_USE_FASTREC
    416              if(!MC_SetUpFastRec())
    417              {
    418          #if MC_REC_COMMON_ERR_CODES
    419                  goto MC_SetUpRec_exit_error;
    420          #else /* MC_REC_COMMON_ERR_CODES */
    421                  nResponseCode = MC_STC_FASTRECERR;
    422                  goto MC_SetUpRec_exit;
    423          #endif /* MC_REC_COMMON_ERR_CODES */
    424              }
    425          #endif /* MC_USE_FASTREC */
    426          
    427              /* everything is okay    */
    428              pcm_wRecFlags.flg.bIsConfigured = 1U;
   \   00000106   0x6BA0             LDR      R0,[R4, #+56]
   \   00000108   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000010C   0x63A0             STR      R0,[R4, #+56]
    429              nResponseCode = MC_STS_OK;
   \   0000010E   0x2000             MOVS     R0,#+0
    430          #if MC_REC_COMMON_ERR_CODES
    431              goto MC_SetUpRec_exit;
    432          MC_SetUpRec_exit_error:
    433              nResponseCode = MC_STC_INVSIZE;
    434          #endif
    435          MC_SetUpRec_exit:
    436              return MC_ConstToBuffer8(pResponse, nResponseCode);
   \   00000110   0xF80A 0x0B01      STRB     R0,[R10], #+1
   \   00000114   0x4650             MOV      R0,R10
   \   00000116   0xE8BD 0x87F0      POP      {R4-R10,PC}
   \                     ??MC_SetUpRec_0: (+1)
   \   0000011A   0x2086             MOVS     R0,#+134
   \   0000011C   0xF80A 0x0B01      STRB     R0,[R10], #+1
   \   00000120   0x4650             MOV      R0,R10
   \   00000122   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    437          }
    438          
    439          /**************************************************************************//*!
    440          *
    441          * @brief    API: Pull the trigger of the recorder
    442          *
    443          * This function starts the post-trigger stop countdown
    444          *
    445          ******************************************************************************/
    446          

   \                                 In section .text, align 2, keep-with-next
    447          void MC_TriggerRec(void)
    448          {
    449              if(!pcm_wRecFlags.flg.bIsStopping)
   \                     MC_TriggerRec: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16
   \   00000002   0x6B81             LDR      R1,[R0, #+56]
   \   00000004   0xF3C1 0x0180      UBFX     R1,R1,#+2,#+1
   \   00000008   0xB929             CBNZ.N   R1,??MC_TriggerRec_0
    450              {
    451                  pcm_wRecFlags.flg.bIsStopping = 1U;
   \   0000000A   0x6B81             LDR      R1,[R0, #+56]
   \   0000000C   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000010   0x6381             STR      R1,[R0, #+56]
    452          #if (MC_REC_STATIC_POSTTRIG) == 0
    453                  pcm_wStoprecCountDown = pcm_wRecPostTrigger;
   \   00000012   0x88C1             LDRH     R1,[R0, #+6]
   \   00000014   0x8181             STRH     R1,[R0, #+12]
    454          #else
    455                  pcm_wStoprecCountDown = MC_REC_STATIC_POSTTRIG;
    456          #endif
    457              }
    458          }
   \                     ??MC_TriggerRec_0: (+1)
   \   00000016   0x4770             BX       LR               ;; return
    459          
    460          /**************************************************************************//*!
    461          *
    462          * @brief    Handling STARTREC command
    463          *
    464          * @param    pMessageIO - original command (in) and response buffer (out) 
    465          *
    466          * @return   As all command handlers, the return value should be the length
    467          *           of the response filled into the buffer (including status byte)
    468          *
    469          * This function starts recording (initializes internal recording variables 
    470          * and flags)
    471          *
    472          ******************************************************************************/
    473          

   \                                 In section .text, align 2, keep-with-next
    474          MC_BPTR MC_StartRec(MC_BPTR pMessageIO)
    475          {
    476               MC_U8 nResponseCode;
    477              /* must be configured */
    478              if(!pcm_wRecFlags.flg.bIsConfigured)
   \                     MC_StartRec: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable16
   \   00000002   0x6B8A             LDR      R2,[R1, #+56]
   \   00000004   0x07D2             LSLS     R2,R2,#+31
   \   00000006   0xD51C             BPL.N    ??MC_StartRec_0
    479              {
    480          #if MC_REC_COMMON_ERR_CODES
    481                  goto MC_StartRec_exit_error;
    482          #else
    483                  nResponseCode = MC_STC_NOTINIT;
    484                  goto MC_StartRec_exit;
    485          #endif
    486              }
    487                  
    488              /* already running ? */
    489              if(pcm_wRecFlags.flg.bIsRunning)
   \   00000008   0x6B8A             LDR      R2,[R1, #+56]
   \   0000000A   0xF3C2 0x0240      UBFX     R2,R2,#+1,#+1
   \   0000000E   0xB9C2             CBNZ.N   R2,??MC_StartRec_0
    490              {
    491          #if MC_REC_COMMON_ERR_CODES
    492                  goto MC_StartRec_exit_error;
    493          #else
    494                  nResponseCode = MC_STS_RECRUN;
    495                  goto MC_StartRec_exit;
    496          #endif
    497              }
    498          
    499          #if (MC_USE_FASTREC) == 0
    500              /* initialize write pointer */
    501              pcm_dwRecWritePtr = pcm_nRecBuffAddr;
   \   00000010   0x6CCA             LDR      R2,[R1, #+76]
   \   00000012   0x63CA             STR      R2,[R1, #+60]
    502          
    503              /* current (first) sample index */
    504              pcm_wRecBuffStartIx = 0U;
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x81CA             STRH     R2,[R1, #+14]
    505          #endif /* (MC_USE_FASTREC) == 0 */
    506          
    507              /* initialize time divisor */
    508          #if (MC_REC_STATIC_DIVISOR) != 1
    509              pcm_wRecTimeDivCtr = 0U;
   \   00000018   0x814A             STRH     R2,[R1, #+10]
    510          #endif
    511          
    512              /* initiate virgin cycle */
    513              pcm_wRecFlags.flg.bIsStopping = 0U;          /* no trigger active */
   \   0000001A   0x6B8A             LDR      R2,[R1, #+56]
   \   0000001C   0xF022 0x0204      BIC      R2,R2,#0x4
   \   00000020   0x638A             STR      R2,[R1, #+56]
    514              pcm_wRecFlags.flg.bTrgCrossActive = 0U;      /* waiting for threshold crossing */
   \   00000022   0x6B8A             LDR      R2,[R1, #+56]
   \   00000024   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000028   0x638A             STR      R2,[R1, #+56]
    515              pcm_wRecFlags.flg.bInvirginCycle = 1U;       /* initial cycle */
   \   0000002A   0x6B8A             LDR      R2,[R1, #+56]
   \   0000002C   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000030   0x638A             STR      R2,[R1, #+56]
    516              /* run now */
    517          
    518              /* start fast recorder */
    519          #if MC_USE_FASTREC
    520              MC_StartFastRec();
    521          #endif /* (MSTR_USE_FASTREC */
    522          
    523              /* run now */
    524              pcm_wRecFlags.flg.bIsRunning = 1U;           /* is running now! */
   \   00000032   0x6B8A             LDR      R2,[R1, #+56]
   \   00000034   0xF042 0x0202      ORR      R2,R2,#0x2
   \   00000038   0x638A             STR      R2,[R1, #+56]
    525          
    526              nResponseCode = MC_STS_OK;
   \   0000003A   0x2100             MOVS     R1,#+0
    527          #if MC_REC_COMMON_ERR_CODES
    528              goto MC_StartRec_exit;
    529          MC_StartRec_exit_error:
    530              nResponseCode = MC_STC_NOTINIT;
    531          #endif
    532          
    533          MC_StartRec_exit:
    534              return MC_ConstToBuffer8(pMessageIO, nResponseCode);
   \   0000003C   0xF800 0x1B01      STRB     R1,[R0], #+1
   \   00000040   0x4770             BX       LR
   \                     ??MC_StartRec_0: (+1)
   \   00000042   0x2188             MOVS     R1,#+136
   \   00000044   0xF800 0x1B01      STRB     R1,[R0], #+1
   \   00000048   0x4770             BX       LR               ;; return
    535          }
    536          
    537          /**************************************************************************//*!
    538          *
    539          * @brief    Handling STOPREC command
    540          *
    541          * @param    pMessageIO - original command (in) and response buffer (out) 
    542          *
    543          * @return   As all command handlers, the return value should be the length
    544          *           of the response filled into the buffer (including status byte)
    545          *
    546          * This function stops recording (same as manual trigger)
    547          *
    548          ******************************************************************************/
    549          

   \                                 In section .text, align 2, keep-with-next
    550          MC_BPTR MC_StopRec(MC_BPTR pMessageIO)
    551          {
    552              MC_U8 nResponseCode;
    553              /* must be configured */
    554              if(!pcm_wRecFlags.flg.bIsConfigured)
   \                     MC_StopRec: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable16
   \   00000002   0x6B8A             LDR      R2,[R1, #+56]
   \   00000004   0x07D2             LSLS     R2,R2,#+31
   \   00000006   0xBF58             IT       PL 
    555              {
    556                  nResponseCode = MC_STC_NOTINIT;
   \   00000008   0x2188             MOVPL    R1,#+136
    557                  goto MC_StopRec_exit;
   \   0000000A   0xD512             BPL.N    ??MC_StopRec_0
    558              }
    559                  
    560              /* already stopped ? */
    561              if(!pcm_wRecFlags.flg.bIsRunning)
   \   0000000C   0x6B8A             LDR      R2,[R1, #+56]
   \   0000000E   0xF3C2 0x0240      UBFX     R2,R2,#+1,#+1
   \   00000012   0xB91A             CBNZ.N   R2,??MC_StopRec_1
    562              {
    563                  nResponseCode = MC_STS_RECDONE;
   \   00000014   0x2102             MOVS     R1,#+2
    564                  goto MC_StopRec_exit;
    565              }
    566              
    567              /* simulate trigger */
    568              MC_TriggerRec();
    569              nResponseCode = MC_STS_OK;
    570              
    571          MC_StopRec_exit:
    572              return MC_ConstToBuffer8(pMessageIO, nResponseCode);
   \   00000016   0xF800 0x1B01      STRB     R1,[R0], #+1
   \   0000001A   0x4770             BX       LR
   \                     ??MC_StopRec_1: (+1)
   \   0000001C   0x6B8A             LDR      R2,[R1, #+56]
   \   0000001E   0xF3C2 0x0280      UBFX     R2,R2,#+2,#+1
   \   00000022   0xB92A             CBNZ.N   R2,??MC_StopRec_2
   \   00000024   0x6B8A             LDR      R2,[R1, #+56]
   \   00000026   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000002A   0x638A             STR      R2,[R1, #+56]
   \   0000002C   0x88CA             LDRH     R2,[R1, #+6]
   \   0000002E   0x818A             STRH     R2,[R1, #+12]
   \                     ??MC_StopRec_2: (+1)
   \   00000030   0x2100             MOVS     R1,#+0
   \                     ??MC_StopRec_0: (+1)
   \   00000032   0xF800 0x1B01      STRB     R1,[R0], #+1
   \   00000036   0x4770             BX       LR               ;; return
    573          }
    574          
    575          /**************************************************************************//*!
    576          *
    577          * @brief    Handling GETRECSTS command
    578          *
    579          * @param    pMessageIO - original command (in) and response buffer (out) 
    580          *
    581          * @return   As all command handlers, the return value should be the buffer 
    582          *           pointer where the response output finished (except checksum)
    583          *
    584          * This function returns current recorder status
    585          *
    586          ******************************************************************************/
    587          

   \                                 In section .text, align 2, keep-with-next
    588          MC_BPTR MC_GetRecStatus(MC_BPTR pMessageIO)
    589          {
    590              MC_U16 nResponseCode = (MC_U16) (pcm_wRecFlags.flg.bIsRunning ?
    591                  MC_STS_RECRUN : MC_STS_RECDONE);
   \                     MC_GetRecStatus: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable16
   \   00000002   0x6B8A             LDR      R2,[R1, #+56]
   \   00000004   0xF3C2 0x0240      UBFX     R2,R2,#+1,#+1
   \   00000008   0xB902             CBNZ.N   R2,??MC_GetRecStatus_0
   \   0000000A   0x2202             MOVS     R2,#+2
    592              
    593              /* must be configured */
    594              if(!pcm_wRecFlags.flg.bIsConfigured)
   \                     ??MC_GetRecStatus_0: (+1)
   \   0000000C   0x6B89             LDR      R1,[R1, #+56]
   \   0000000E   0x07C9             LSLS     R1,R1,#+31
   \   00000010   0xBF58             IT       PL 
    595              {
    596                  nResponseCode = MC_STC_NOTINIT;
   \   00000012   0x2288             MOVPL    R2,#+136
    597              }
    598                  
    599              /* get run/stop status */
    600              return MC_ConstToBuffer8(pMessageIO, (MC_U8) nResponseCode);
   \   00000014   0xF800 0x2B01      STRB     R2,[R0], #+1
   \   00000018   0x4770             BX       LR               ;; return
    601          }
    602          
    603          /* now follows the recorder only routines, skip that if FastRecorder is used */
    604          #if (MC_USE_FASTREC) == 0
    605          
    606          /**************************************************************************//*!
    607          *
    608          * @brief    Get recorder memory size 
    609          *
    610          * @return   Recorder memory size in native sizeof units (=bytes on most platforms)
    611          *
    612          ******************************************************************************/
    613          

   \                                 In section .text, align 2, keep-with-next
    614          MC_SIZE MC_GetRecBuffSize()
    615          {
    616          #if MC_REC_OWNBUFF
    617              return pcm_wRecBuffSize;
    618          #else
    619              return (MC_SIZE) MC_REC_BUFF_SIZE;
   \                     MC_GetRecBuffSize: (+1)
   \   00000000   0xF44F 0x6080      MOV      R0,#+1024
   \   00000004   0x4770             BX       LR               ;; return
    620          #endif
    621          }
    622          
    623          /**************************************************************************//*!
    624          *
    625          * @brief    Check wether given memory region is inside the recorder buffer
    626          *
    627          * @param    dwAddr - address of the memory to be checked
    628          * @param    wSize  - size of the memory to be checked
    629          *
    630          * @return   This function returns non-zero if user space is in recorder buffer
    631          *
    632          * This function is called as a part of TSA-checking process when the PC host
    633          * is requesting memory contents
    634          *
    635          ******************************************************************************/
    636          

   \                                 In section .text, align 2, keep-with-next
    637          MC_BOOL MC_IsInRecBuffer(MC_ADDR dwAddr, MC_SIZE8 nSize)
    638          {
    639              MC_BOOL bRet = 0U;
   \                     MC_IsInRecBuffer: (+1)
   \   00000000   0x....             LDR.N    R3,??DataTable16
   \   00000002   0x6CDB             LDR      R3,[R3, #+76]
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x4298             CMP      R0,R3
   \   00000008   0xBF21             ITTTT    CS 
    640              
    641              if(dwAddr >= pcm_nRecBuffAddr)
    642              {
    643                  bRet = (MC_BOOL)((dwAddr + nSize) <= (pcm_nRecBuffAddr + MC_GetRecBuffSize()) ? MC_TRUE : MC_FALSE);
   \   0000000A   0xF503 0x6380      ADDCS    R3,R3,#+1024
   \   0000000E   0xFA50 0xF081      UXTABCS  R0,R0,R1
   \   00000012   0x4283             CMPCS    R3,R0
   \   00000014   0x2201             MOVCS    R2,#+1
    644              }
    645              
    646              return bRet;
   \   00000016   0x4610             MOV      R0,R2
   \   00000018   0x4770             BX       LR               ;; return
    647          }
    648          
    649          
    650          /**************************************************************************//*!
    651          *
    652          * @brief    Handling GETRECBUFF and GETRECBUFF_EX command
    653          *
    654          * @param    pMessageIO - original command (in) and response buffer (out) 
    655          *
    656          * @return   As all command handlers, the return value should be the buffer 
    657          *           pointer where the response output finished (except checksum)
    658          *
    659          * This function returns recorder buffer information
    660          *
    661          ******************************************************************************/
    662          

   \                                 In section .text, align 2, keep-with-next
    663          MC_BPTR MC_GetRecBuff(MC_BPTR pMessageIO)
    664          {
   \                     MC_GetRecBuff: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    665              volatile MC_BPTR pResponse;
    666              /* must be configured */
    667              if(!pcm_wRecFlags.flg.bIsConfigured)
   \   00000002   0x....             LDR.N    R4,??DataTable16
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x6BA1             LDR      R1,[R4, #+56]
   \   00000008   0x07C9             LSLS     R1,R1,#+31
   \   0000000A   0xBF58             IT       PL 
    668              {
    669                  return MC_ConstToBuffer8(pMessageIO, MC_STC_NOTINIT);
   \   0000000C   0x2188             MOVPL    R1,#+136
   \   0000000E   0xD504             BPL.N    ??MC_GetRecBuff_0
    670              }
    671              
    672              /* must be stopped */
    673              if(pcm_wRecFlags.flg.bIsRunning)
   \   00000010   0x6BA1             LDR      R1,[R4, #+56]
   \   00000012   0xF3C1 0x0140      UBFX     R1,R1,#+1,#+1
   \   00000016   0xB121             CBZ.N    R1,??MC_GetRecBuff_1
    674              {
    675                  return MC_ConstToBuffer8(pMessageIO, MC_STC_SERVBUSY);
   \   00000018   0x2187             MOVS     R1,#+135
   \                     ??MC_GetRecBuff_0: (+1)
   \   0000001A   0xF800 0x1B01      STRB     R1,[R0], #+1
    676              }
   \   0000001E   0xB002             ADD      SP,SP,#+8
   \   00000020   0xBD10             POP      {R4,PC}
    677              
    678              /* fill the return info */
    679              pResponse = MC_ConstToBuffer8(pMessageIO, MC_STS_OK);
   \                     ??MC_GetRecBuff_1: (+1)
   \   00000022   0xF800 0x1B01      STRB     R1,[R0], #+1
   \   00000026   0x9000             STR      R0,[SP, #+0]
    680              pResponse = MC_AddressToBuffer(pResponse, pcm_nRecBuffAddr);
   \   00000028   0x6CE1             LDR      R1,[R4, #+76]
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
   \   0000002C   0x.... 0x....      BL       MC_AddressToBuffer
   \   00000030   0x9000             STR      R0,[SP, #+0]
    681              return MC_ValueToBuffer16(pResponse, pcm_wRecBuffStartIx);
   \   00000032   0x2202             MOVS     R2,#+2
   \   00000034   0x9800             LDR      R0,[SP, #+0]
   \   00000036   0x89E1             LDRH     R1,[R4, #+14]
   \   00000038   0xF8AD 0x1004      STRH     R1,[SP, #+4]
   \   0000003C   0xA901             ADD      R1,SP,#+4
   \   0000003E   0x.... 0x....      BL       MC_CopyToBuffer
   \   00000042   0xB002             ADD      SP,SP,#+8
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
    682          }
    683          
    684          /**************************************************************************//*!
    685          *
    686          * @brief    Compare macro used in trigger detection
    687          *
    688          * @param    v - original command 
    689          * @param    t - response buffer
    690          *
    691          * @return   zero when value is lower than threshold.
    692          * @return   non-zero when value is greater than or equal as threshold
    693          *
    694          ******************************************************************************/
    695          
    696          #define CMP(v,t) ((MC_BOOL)(((v) < (t)) ? 0 : 1))
    697          
    698          #if MC_CFG_BUS_WIDTH == 1U
    699          

   \                                 In section .text, align 4, keep-with-next
    700          static MC_BOOL MC_Compare8S()
    701          {
    702              return CMP(MC_GetS8(pcm_nTrgVarAddr), pcm_uTrgThreshold.s8);
   \                     MC_Compare8S: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16
   \   00000002   0x6C41             LDR      R1,[R0, #+68]
   \   00000004   0xF990 0x0048      LDRSB    R0,[R0, #+72]
   \   00000008   0xF991 0x1000      LDRSB    R1,[R1, #+0]
   \   0000000C   0x4281             CMP      R1,R0
   \   0000000E   0xDA01             BGE.N    ??MC_Compare8S_0
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR
   \                     ??MC_Compare8S_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x4770             BX       LR               ;; return
    703          }
    704          

   \                                 In section .text, align 4, keep-with-next
    705          static MC_BOOL MC_Compare8U()
    706          {
    707              return CMP(MC_GetU8(pcm_nTrgVarAddr), pcm_uTrgThreshold.u8);
   \                     MC_Compare8U: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16
   \   00000002   0x6C41             LDR      R1,[R0, #+68]
   \   00000004   0xF890 0x2048      LDRB     R2,[R0, #+72]
   \   00000008   0x7809             LDRB     R1,[R1, #+0]
   \   0000000A   0x4291             CMP      R1,R2
   \   0000000C   0x4180             SBCS     R0,R0,R0
   \   0000000E   0x43C0             MVNS     R0,R0
   \   00000010   0x0FC0             LSRS     R0,R0,#+31
   \   00000012   0x4770             BX       LR               ;; return
    708          }
    709          
    710          #endif
    711          

   \                                 In section .text, align 4, keep-with-next
    712          static MC_BOOL MC_Compare16S()
    713          {
    714              return CMP(MC_GetS16(pcm_nTrgVarAddr), pcm_uTrgThreshold.s16);
   \                     MC_Compare16S: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16
   \   00000002   0x6C41             LDR      R1,[R0, #+68]
   \   00000004   0xF9B0 0x0048      LDRSH    R0,[R0, #+72]
   \   00000008   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   0000000C   0x4281             CMP      R1,R0
   \   0000000E   0xDA01             BGE.N    ??MC_Compare16S_0
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR
   \                     ??MC_Compare16S_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x4770             BX       LR               ;; return
    715          }
    716          

   \                                 In section .text, align 4, keep-with-next
    717          static MC_BOOL MC_Compare16U()
    718          {
    719              return CMP(MC_GetU16(pcm_nTrgVarAddr), pcm_uTrgThreshold.u16);
   \                     MC_Compare16U: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16
   \   00000002   0x6C41             LDR      R1,[R0, #+68]
   \   00000004   0xF8B0 0x2048      LDRH     R2,[R0, #+72]
   \   00000008   0x8809             LDRH     R1,[R1, #+0]
   \   0000000A   0x4291             CMP      R1,R2
   \   0000000C   0x4180             SBCS     R0,R0,R0
   \   0000000E   0x43C0             MVNS     R0,R0
   \   00000010   0x0FC0             LSRS     R0,R0,#+31
   \   00000012   0x4770             BX       LR               ;; return
    720          }
    721          

   \                                 In section .text, align 4, keep-with-next
    722          static MC_BOOL MC_Compare32S()
    723          {
    724              return CMP(MC_GetS32(pcm_nTrgVarAddr), pcm_uTrgThreshold.s32);
   \                     MC_Compare32S: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16
   \   00000002   0x6C41             LDR      R1,[R0, #+68]
   \   00000004   0x6C80             LDR      R0,[R0, #+72]
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x4281             CMP      R1,R0
   \   0000000A   0xDA01             BGE.N    ??MC_Compare32S_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR
   \                     ??MC_Compare32S_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR               ;; return
    725          }
    726          

   \                                 In section .text, align 4, keep-with-next
    727          static MC_BOOL MC_Compare32U()
    728          {
    729              return CMP(MC_GetU32(pcm_nTrgVarAddr), pcm_uTrgThreshold.u32);
   \                     MC_Compare32U: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16
   \   00000002   0x6C41             LDR      R1,[R0, #+68]
   \   00000004   0x6C80             LDR      R0,[R0, #+72]
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x4281             CMP      R1,R0
   \   0000000A   0x4180             SBCS     R0,R0,R0
   \   0000000C   0x43C0             MVNS     R0,R0
   \   0000000E   0x0FC0             LSRS     R0,R0,#+31
   \   00000010   0x4770             BX       LR               ;; return
    730          }
    731          
    732          #if MC_REC_FLOAT_TRIG

   \                                 In section .text, align 4, keep-with-next
    733          static MC_BOOL MC_Comparefloat()
    734          {
    735              return CMP(MC_GetFloat(pcm_nTrgVarAddr), pcm_uTrgThreshold.fp);
   \                     MC_Comparefloat: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16
   \   00000002   0x6C41             LDR      R1,[R0, #+68]
   \   00000004   0xEDD0 0x0A12      VLDR     S1,[R0, #+72]
   \   00000008   0xED91 0x0A00      VLDR     S0,[R1, #0]
   \   0000000C   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000010   0xEEF1 0xFA10      FMSTAT   
   \   00000014   0xD501             BPL.N    ??MC_Comparefloat_0
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR
   \                     ??MC_Comparefloat_0: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x4770             BX       LR               ;; return
    736          }
    737          #endif
    738          
    739          /**************************************************************************//*!
    740          *
    741          * @brief    API: Recorder worker routine - can be called from application's timer ISR
    742          *
    743          *
    744          * This returns quickly if recorder is not running, otherwise it calls quite lengthy 
    745          * recorder routine which does all the recorder work (sampling, triggering)
    746          *
    747          ******************************************************************************/
    748          
    749          #if defined(MC_PLATFORM_56F8xxx) || defined(MC_PLATFORM_56F8xx)
    750          #pragma interrupt called
    751          #endif
    752          

   \                                 In section .text, align 2, keep-with-next
    753          void MC_Recorder(void)
    754          {
    755              /* recorder not active */
    756              if(!pcm_wRecFlags.flg.bIsRunning)
   \                     MC_Recorder: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   \   00000004   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xBF18             IT       NE 
    757              {
    758                  return ;
    759              }
    760              
    761              /* do the hard work      */
    762              MC_Recorder2();
   \   0000000C   0x.... 0x....      BNE.W    MC_Recorder2
    763          }
   \   00000010   0x4770             BX       LR               ;; return
    764          
    765          /**************************************************************************//*!
    766          *
    767          * @brief    Recorder function called when recorder is active
    768          *
    769          ******************************************************************************/
    770          
    771          #if defined(MC_PLATFORM_56F8xxx) || defined(MC_PLATFORM_56F8xx)
    772          #pragma interrupt called
    773          #endif
    774          

   \                                 In section .text, align 4, keep-with-next
    775          static void MC_Recorder2(void)
    776          {
   \                     MC_Recorder2: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    777              MC_SIZE8 sz;
    778              MC_BOOL cmp;
    779              MC_U8 i;
    780          
    781          #if (MC_REC_STATIC_DIVISOR) != 1
    782              /* skip this call ? */
    783              if(pcm_wRecTimeDivCtr)
   \   00000004   0x....             LDR.N    R4,??DataTable16
   \   00000006   0x8960             LDRH     R0,[R4, #+10]
   \   00000008   0xB118             CBZ.N    R0,??MC_Recorder2_0
    784              {
    785                  /* maybe next time... */
    786                  pcm_wRecTimeDivCtr--;
   \   0000000A   0x1E40             SUBS     R0,R0,#+1
   \   0000000C   0x8160             STRH     R0,[R4, #+10]
    787                  return;
    788              }
    789              
    790              /* re-initialize divider */
    791          #if (MC_REC_STATIC_DIVISOR) == 0
    792              pcm_wRecTimeDivCtr = pcm_wRecTimeDiv;
    793          #else 
    794              pcm_wRecTimeDivCtr = MC_REC_STATIC_DIVISOR;
    795          #endif /* (MC_REC_STATIC_DIVISOR) == 0 */
    796          #endif /* (MC_REC_STATIC_DIVISOR) != 1 */
    797          
    798              /* take snapshot of variable values */
    799              for (i=0U; i<pcm_nRecVarCount; i++)
    800              {
    801                  sz = pcm_pRecVarSize[i];
    802                  MC_CopyMemory(pcm_dwRecWritePtr, pcm_pRecVarAddr[i], sz);
    803                  sz /= MC_CFG_BUS_WIDTH;
    804                  pcm_dwRecWritePtr += sz;
    805              }
    806              
    807              /* another sample taken (startIx "points" after sample just taken) */
    808              /* i.e. it points to the oldest sample */
    809              pcm_wRecBuffStartIx++;
    810              
    811              /* wrap around (circular buffer) ? */
    812              if(pcm_dwRecWritePtr >= pcm_dwRecEndBuffPtr)
    813              {   
    814                  pcm_dwRecWritePtr = pcm_nRecBuffAddr;
    815                  pcm_wRecFlags.flg.bInvirginCycle = 0U;
    816                  pcm_wRecBuffStartIx = 0U;
    817              }
    818          
    819              /* no trigger testing in virgin cycle */
    820              if(pcm_wRecFlags.flg.bInvirginCycle)
    821              {
    822                  return;
    823              }
    824              
    825              /* test trigger condition if still running */
    826              if(!pcm_wRecFlags.flg.bIsStopping && pcm_pCompareFunc != NULL)
    827              {
    828                  /* compare trigger threshold */
    829                  cmp = pcm_pCompareFunc();
    830                  
    831                  /* negated logic (falling-edge) ? */
    832                  if(pcm_nRecTriggerMode == 2U)
    833                  {
    834                      cmp = (MC_BOOL) !cmp;
    835                  }
    836                  
    837                  /* above threshold ? */
    838                  if(cmp)
    839                  {
    840                      /* were we at least once below threshold ? */
    841                      if(pcm_wRecFlags.flg.bTrgCrossActive)
    842                      {
    843                          /* EDGE TRIGGER ! */
    844                          MC_TriggerRec();
    845                      }
    846                  }
    847                  else
    848                  {
    849                      /* we got bellow threshold, now wait for being above threshold */
    850                      pcm_wRecFlags.flg.bTrgCrossActive = 1U;
    851                  }
    852              }
    853              
    854              /* in stopping mode ? (note that this bit might have been set just above!) */
    855              if(pcm_wRecFlags.flg.bIsStopping)
    856              {
    857                  /* count down post-trigger samples expired ? */
    858                  if(!pcm_wStoprecCountDown)
    859                  {
    860                      /* STOP RECORDER */
    861                      pcm_wRecFlags.flg.bIsRunning = 0U;
    862                      return;
    863                  }
    864                  
    865                  /* perhaps next time */
    866                  pcm_wStoprecCountDown--;
    867              }
    868          }
   \   0000000E   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??MC_Recorder2_0: (+1)
   \   00000012   0x2700             MOVS     R7,#+0
   \   00000014   0x8920             LDRH     R0,[R4, #+8]
   \   00000016   0x8160             STRH     R0,[R4, #+10]
   \   00000018   0xF104 0x0530      ADD      R5,R4,#+48
   \   0000001C   0x7860             LDRB     R0,[R4, #+1]
   \   0000001E   0xF104 0x0610      ADD      R6,R4,#+16
   \   00000022   0xB180             CBZ.N    R0,??MC_Recorder2_1
   \                     ??MC_Recorder2_2: (+1)
   \   00000024   0xF815 0x8B01      LDRB     R8,[R5], #+1
   \   00000028   0xF856 0x1B04      LDR      R1,[R6], #+4
   \   0000002C   0x6BE0             LDR      R0,[R4, #+60]
   \   0000002E   0x4642             MOV      R2,R8
   \   00000030   0x.... 0x....      BL       MC_CopyMemory
   \   00000034   0x6BE0             LDR      R0,[R4, #+60]
   \   00000036   0xFA50 0xF088      UXTAB    R0,R0,R8
   \   0000003A   0x63E0             STR      R0,[R4, #+60]
   \   0000003C   0x1C7F             ADDS     R7,R7,#+1
   \   0000003E   0x7860             LDRB     R0,[R4, #+1]
   \   00000040   0xB2FF             UXTB     R7,R7
   \   00000042   0x4287             CMP      R7,R0
   \   00000044   0xDBEE             BLT.N    ??MC_Recorder2_2
   \                     ??MC_Recorder2_1: (+1)
   \   00000046   0x89E0             LDRH     R0,[R4, #+14]
   \   00000048   0x6C21             LDR      R1,[R4, #+64]
   \   0000004A   0x1C40             ADDS     R0,R0,#+1
   \   0000004C   0x81E0             STRH     R0,[R4, #+14]
   \   0000004E   0x6BE0             LDR      R0,[R4, #+60]
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD307             BCC.N    ??MC_Recorder2_3
   \   00000054   0x6CE0             LDR      R0,[R4, #+76]
   \   00000056   0x63E0             STR      R0,[R4, #+60]
   \   00000058   0x6BA0             LDR      R0,[R4, #+56]
   \   0000005A   0xF020 0x0008      BIC      R0,R0,#0x8
   \   0000005E   0x63A0             STR      R0,[R4, #+56]
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x81E0             STRH     R0,[R4, #+14]
   \                     ??MC_Recorder2_3: (+1)
   \   00000064   0x6BA0             LDR      R0,[R4, #+56]
   \   00000066   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   0000006A   0xBB80             CBNZ.N   R0,??MC_Recorder2_4
   \   0000006C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000006E   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   00000072   0xB958             CBNZ.N   R0,??MC_Recorder2_5
   \   00000074   0x6D20             LDR      R0,[R4, #+80]
   \   00000076   0x0001             MOVS     R1,R0
   \   00000078   0xD008             BEQ.N    ??MC_Recorder2_5
   \   0000007A   0x4780             BLX      R0
   \   0000007C   0x7821             LDRB     R1,[R4, #+0]
   \   0000007E   0x2902             CMP      R1,#+2
   \   00000080   0xD110             BNE.N    ??MC_Recorder2_6
   \   00000082   0xB188             CBZ.N    R0,??MC_Recorder2_7
   \                     ??MC_Recorder2_8: (+1)
   \   00000084   0x6BA0             LDR      R0,[R4, #+56]
   \   00000086   0xF040 0x0010      ORR      R0,R0,#0x10
   \   0000008A   0x63A0             STR      R0,[R4, #+56]
   \                     ??MC_Recorder2_5: (+1)
   \   0000008C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000008E   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   00000092   0xB1E0             CBZ.N    R0,??MC_Recorder2_4
   \   00000094   0x89A0             LDRH     R0,[R4, #+12]
   \   00000096   0xB9C0             CBNZ.N   R0,??MC_Recorder2_9
   \   00000098   0x6BA0             LDR      R0,[R4, #+56]
   \   0000009A   0xF020 0x0002      BIC      R0,R0,#0x2
   \   0000009E   0x63A0             STR      R0,[R4, #+56]
   \   000000A0   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??MC_Recorder2_6: (+1)
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD0ED             BEQ.N    ??MC_Recorder2_8
   \                     ??MC_Recorder2_7: (+1)
   \   000000A8   0x6BA0             LDR      R0,[R4, #+56]
   \   000000AA   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD0EC             BEQ.N    ??MC_Recorder2_5
   \   000000B2   0x6BA0             LDR      R0,[R4, #+56]
   \   000000B4   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD1E7             BNE.N    ??MC_Recorder2_5
   \   000000BC   0x6BA0             LDR      R0,[R4, #+56]
   \   000000BE   0xF040 0x0004      ORR      R0,R0,#0x4
   \   000000C2   0x63A0             STR      R0,[R4, #+56]
   \   000000C4   0x88E0             LDRH     R0,[R4, #+6]
   \   000000C6   0x81A0             STRH     R0,[R4, #+12]
   \   000000C8   0xE7E0             B.N      ??MC_Recorder2_5
   \                     ??MC_Recorder2_9: (+1)
   \   000000CA   0x1E40             SUBS     R0,R0,#+1
   \   000000CC   0x81A0             STRH     R0,[R4, #+12]
   \                     ??MC_Recorder2_4: (+1)
   \   000000CE   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     pcm_nRecTriggerMode
    869          
    870          #endif /* (MC_USE_FASTREC) == 0 */
    871          
    872          #else /* MC_USE_RECORDER && (!MC_DISABLE) */
    873          
    874          /* use void recorder API functions */
    875          void MC_Recorder(void)
    876          { 
    877          }
    878          
    879          void MC_TriggerRec(void)
    880          { 
    881          }
    882          
    883          void MC_SetUpRecBuff(MC_ADDR pBuffer, MC_SIZE wBuffSize)
    884          { 
    885              MC_UNUSED(pBuffer);
    886              MC_UNUSED(wBuffSize);
    887          }
    888          
    889          /*lint -efile(766, mc_protocol.h) include file is not used in this case */
    890          
    891          #endif /* MC_USE_RECORDER && (!MC_DISABLE) */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   MC_Compare16S
       0   MC_Compare16U
       0   MC_Compare32S
       0   MC_Compare32U
       0   MC_Compare8S
       0   MC_Compare8U
       0   MC_Comparefloat
      16   MC_GetRecBuff
        16   -> MC_AddressToBuffer
        16   -> MC_CopyToBuffer
       0   MC_GetRecBuffSize
       0   MC_GetRecStatus
       0   MC_InitRec
       0   MC_IsInRecBuffer
       0   MC_Recorder
         0   -> MC_Recorder2
      24   MC_Recorder2
        24   -- Indirect call
        24   -> MC_CopyMemory
      32   MC_SetUpRec
        32   -> MC_AddressFromBuffer
        32   -> MC_CopyFromBuffer
       0   MC_SetUpRecBuff
       0   MC_StartRec
       0   MC_StopRec
       0   MC_TriggerRec


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
      24  MC_Compare16S
      20  MC_Compare16U
      20  MC_Compare32S
      18  MC_Compare32U
      24  MC_Compare8S
      20  MC_Compare8U
      30  MC_Comparefloat
      70  MC_GetRecBuff
       6  MC_GetRecBuffSize
      26  MC_GetRecStatus
      18  MC_InitRec
      26  MC_IsInRecBuffer
      18  MC_Recorder
     210  MC_Recorder2
     294  MC_SetUpRec
       2  MC_SetUpRecBuff
      74  MC_StartRec
      56  MC_StopRec
      24  MC_TriggerRec
    1108  pcm_nRecTriggerMode
          pcm_nRecVarCount
          pcm_nTrgVarSize
          pcm_bTrgVarSigned
          pcm_wRecTotalSmps
          pcm_wRecPostTrigger
          pcm_wRecTimeDiv
          pcm_wRecTimeDivCtr
          pcm_wStoprecCountDown
          pcm_wRecBuffStartIx
          pcm_pRecVarAddr
          pcm_pRecVarSize
          pcm_wRecFlags
          pcm_dwRecWritePtr
          pcm_dwRecEndBuffPtr
          pcm_nTrgVarAddr
          pcm_uTrgThreshold
          pcm_nRecBuffAddr
          pcm_pCompareFunc
          pcm_pOwnRecBuffer

 
 1 108 bytes in section .bss
   984 bytes in section .text
 
   984 bytes of CODE memory
 1 108 bytes of DATA memory

Errors: none
Warnings: none
