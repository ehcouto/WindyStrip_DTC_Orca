###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        19/Nov/2024  13:15:28
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        Category\Application\ProtocolMainExternal\ProtocolMainExternal.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        ProtocolMainExternal.obj -l ..\listings\ProtocolMainExternal.lst
#        Category\Application\ProtocolMainExternal\ProtocolMainExternal.c
#    List file    =  ..\listings\ProtocolMainExternal.lst
#    Object file  =  ProtocolMainExternal.obj
#
###############################################################################

C:\Data\Python\Windy_sBpm_Floating\source\Category\Application\ProtocolMainExternal\ProtocolMainExternal.c
      1          /**
      2           *  @file       ProtocolMainExternal.c
      3           *
      4           *  @brief      The File containing UMain-DSP communication routines
      5           *
      6           *  @details    New Info Buffer,CRC calculated on buffer
      7           *
      8           *
      9           *  @copyright  Copyright 2016. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     10           */
     11          //---------------------------------------------------------------------------------------------------------------------
     12          //---------------------------------------------------------------------------------------------------------------------
     13          
     14          
     15          //-------------------------------------- Include Files ----------------------------------------------------------------
     16          #include "ProtocolMainExternal.h"
     17          #include "ProtocolMainExternal_prv.h"
     18          #include "CommandManager.h"
     19          //#include "SensorsAlgorithms.h"
     20          #include "ProtocolInfo.h"
     21          #include "C_Extensions.h"
     22          #include "FaultManager.h"
     23          #include "Micro.h"
     24          #include "Params.h"

  PACKED typedef struct
         ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Common\SettingFile\SettingFile.h",39  Remark[Pe082]: 
          storage class is not first
     25          #include "SRException.h"
     26          #include "Uart.h"
     27          #include <string.h>
     28          #include "Crc16.h"
     29          #include "mci_prm.h"
     30          
     31          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     32          
     33          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     34          
     35          #if (APPLIANCE_TYPE == APPLIANCE_TYPE_WASHER)
     36          #include "SRMotorSafetyInfoParamsMgr.h"
     37          #include "MciSetWm.h"
     38          #include "MciSensorsWm.h"
     39          //#include "MotorSr_prm.h"
     40          #elif (APPLIANCE_TYPE == APPLIANCE_TYPE_DISHWASHER)
     41          #include "Gpio.h"
     42          #include "MotorSr_Drain_prm.h"
     43          #include "MotorSr_Wash_prm.h"
     44          #include "SrMotorSafetyMgr.h"
     45          #include "Mci.h"
     46          
     47          #define RELAY_PUMPS_CONFIG()  Gpio__PinConfig(SWITCH_PUMPS_RELAY_PORT, SWITCH_PUMPS_RELAY_PIN, OUTPUT_PUSHPULL)
     48          #define RELAY_PUMPS_OPEN()    Gpio__PinWrite(SWITCH_PUMPS_RELAY_PORT, SWITCH_PUMPS_RELAY_PIN, FALSE)
     49          #define RELAY_PUMPS_CLOSE()   Gpio__PinWrite(SWITCH_PUMPS_RELAY_PORT, SWITCH_PUMPS_RELAY_PIN, TRUE)
     50          #endif
     51          
     52          
     53          enum
     54          {
     55              TOKEN_PACKET_SEND_STX = 0,
     56              TOKEN_PACKET_SEND_EXTENDED,
     57              TOKEN_PACKET_SEND_HDR,
     58              TOKEN_PACKET_SEND_TYPE,
     59              TOKEN_PACKET_SEND_LENGTH,
     60              TOKEN_PACKET_SEND_DATA0,
     61              TOKEN_PACKET_SEND_CRCHI,
     62              TOKEN_PACKET_SEND_CRCLO,
     63              TOKEN_PACKET_SEND_SIZE
     64          };
     65          
     66          enum
     67          {
     68              TOKEN_PACKET_RECEIVE_ACK = 0,
     69              TOKEN_PACKET_RECEIVE_STX,
     70              TOKEN_PACKET_RECEIVE_EXTENDED,
     71              TOKEN_PACKET_RECEIVE_HDR,
     72              TOKEN_PACKET_RECEIVE_TYPE,
     73              TOKEN_PACKET_RECEIVE_LENGTH,
     74              TOKEN_PACKET_RECEIVE_MINIMUM_SIZE,
     75              TOKEN_PACKET_RECEIVE_SEQUENCE_ID=TOKEN_PACKET_RECEIVE_MINIMUM_SIZE,
     76          
     77              // L1 load
     78              TOKEN_PACKET_RECEIVE_PILOT_TYPE_L1,         // multiple loads
     79              TOKEN_PACKET_RECEIVE_DISPL_SF_PARAMS_L1,    // multiple loads
     80              TOKEN_PACKET_RECEIVE_SPEEDHI_L1,            // multiple loads
     81              TOKEN_PACKET_RECEIVE_SPEEDLO_L1,            // multiple loads
     82              TOKEN_PACKET_RECEIVE_TIMEHI_L1,             // multiple loads
     83              TOKEN_PACKET_RECEIVE_TIMELO_L1,             // multiple loads
     84              TOKEN_PACKET_RECEIVE_FLAGSHI_L1,            // multiple loads
     85              TOKEN_PACKET_RECEIVE_FLAGSLO_L1,            // multiple loads
     86          
     87              // L2 load
     88              TOKEN_PACKET_RECEIVE_PILOT_TYPE_L2,         // multiple loads
     89              TOKEN_PACKET_RECEIVE_DISPL_SF_PARAMS_L2,    // multiple loads
     90              TOKEN_PACKET_RECEIVE_SPEEDHI_L2,            // multiple loads
     91              TOKEN_PACKET_RECEIVE_SPEEDLO_L2,            // multiple loads
     92              TOKEN_PACKET_RECEIVE_TIMEHI_L2,             // multiple loads
     93              TOKEN_PACKET_RECEIVE_TIMELO_L2,             // multiple loads
     94              TOKEN_PACKET_RECEIVE_FLAGSHI_L2,            // multiple loads
     95              TOKEN_PACKET_RECEIVE_FLAGSLO_L2,            // multiple loads
     96          
     97              TOKEN_PACKET_RECEIVE_DATATYPERAM,
     98              TOKEN_PACKET_RECEIVE_RAMREADSTARTHI,
     99              TOKEN_PACKET_RECEIVE_RAMREADSTARTLO,
    100              TOKEN_PACKET_RECEIVE_RAMREADENDHI,
    101              TOKEN_PACKET_RECEIVE_RAMREADENDLO,
    102              TOKEN_PACKET_RECEIVE_RAMWRITEADDRESSHI,
    103              TOKEN_PACKET_RECEIVE_RAMWRITEADDRESSLO,
    104              TOKEN_PACKET_RECEIVE_RAMWRITEDATAHI,
    105              TOKEN_PACKET_RECEIVE_RAMWRITEDATALO,
    106              TOKEN_PACKET_RECEIVE_EXTRAREQUESTHI,
    107              TOKEN_PACKET_RECEIVE_EXTRAREQUESTLO,
    108              TOKEN_PACKET_RECEIVE_CRCHI,
    109              TOKEN_PACKET_RECEIVE_CRCLO,
    110              TOKEN_PACKET_RECEIVE_SIZE
    111          };
    112          
    113          enum
    114          {
    115              INFO_PACKET_SEND_STX = 0,
    116              INFO_PACKET_SEND_EXTENDED,
    117              INFO_PACKET_SEND_HDR,
    118              INFO_PACKET_SEND_TYPE,
    119              INFO_PACKET_SEND_LENGTH,
    120              INFO_PACKET_SEND_SEQUENCE_ID,
    121              INFO_PACKET_SEND_LENDATARAM,
    122              INFO_PACKET_SEND_DATATYPERAM,
    123              INFO_PACKET_SEND_CRCHI,
    124              INFO_PACKET_SEND_CRCLO,
    125              INFO_PACKET_SEND_FIXED_SIZE
    126          };
    127          
    128          enum
    129          {
    130              READSETTING_STX = 0,
    131              READSETTING_EXTENDED,
    132              READSETTING_HDR,
    133              READSETTING_TYPE,
    134              READSETTING_LENGTH,
    135              READSETTING_POINTER,
    136              READSETTING_DISPL,
    137              READSETTING_CRCHI,
    138              READSETTING_CRCLO,
    139              READSETTING_SIZE
    140          };
    141          
    142          enum
    143          {
    144              EXT_READSETTING_STX = 0,
    145              EXT_READSETTING_EXTENDED,
    146              EXT_READSETTING_HDR,
    147              EXT_READSETTING_TYPE,
    148              EXT_READSETTING_LENGTH,
    149              EXT_READSETTING_POINTER,
    150              EXT_READSETTING_DISPL,
    151              EXT_READSETTING_OFFSET_LO,
    152              EXT_READSETTING_OFFSET_HI,
    153              EXT_READSETTING_NUMBYTES,
    154              EXT_READSETTING_CRCHI,
    155              EXT_READSETTING_CRCLO,
    156              EXT_READSETTING_SIZE
    157          };
    158          
    159          enum
    160          {
    161              READFLASH_RECEIVE_ACK = 0,
    162              READFLASH_RECEIVE_STX,
    163              READFLASH_RECEIVE_EXTENDED,
    164              READFLASH_RECEIVE_HDR,
    165              READFLASH_RECEIVE_TYPE,
    166              READFLASH_RECEIVE_LENGTH,
    167              READFLASH_RECEIVE_D0,
    168              READFLASH_RECEIVE_D1,
    169              READFLASH_RECEIVE_D2,
    170              READFLASH_RECEIVE_D3,
    171              READFLASH_RECEIVE_D4,
    172              READFLASH_RECEIVE_D5,
    173              READFLASH_RECEIVE_D6,
    174              READFLASH_RECEIVE_D7,
    175              READFLASH_RECEIVE_D8,
    176              READFLASH_RECEIVE_CRCHI,
    177              READFLASH_RECEIVE_CRCLO,
    178              READFLASH_RECEIVE_SIZE
    179          };
    180          
    181          //! INFO_PACKET_RECEIVE_DEFINITION
    182          enum
    183          {
    184              INFO_PACKET_SEND_ACK = 0,
    185              INFO_PACKET_RECEIVE_SIZE
    186          };
    187          
    188          typedef enum
    189          {
    190              TOKEN                 = 0,
    191              INFO                  = 1,
    192              SETTINGFILELOADED     = 2,
    193              // put here loading tables of parameters
    194              DISPLDATA             = 3,
    195              SAFETYDATA            = 4,
    196              TRIPHASEDATA_1        = 5,    // PME_WASHER specific
    197              TRIPHASEDATA_2        = 6,    // PME_WASHER specific
    198              TRIPHASEDATA          = 7,    // PME_DISHWASHER specific
    199              MODULEDATA            = 8,    // PME_DISHWASHER specific
    200              MLIMITDATA            = 9,    // PME_WASHER specific
    201          	MCISAFETYDATA      	  = 10,   // WINDY specific
    202          
    203          	SBPM_FLOAT_DTC_CONTROL_1= 11,    // WINDY sBpm Floating specific
    204          	SBPM_FLOAT_DTC_CONTROL_2= 12,    // WINDY sBpm Floating specific
    205          	SBPM_FLOAT_MOTOR_LUT    = 13,    // WINDY sBpm Floating specific
    206          	SBPM_FLOAT_SPEED_CTRL   = 14,    // WINDY sBpm Floating specific
    207          	SBPM_FLOAT_MTPA_LUT     = 15,    // WINDY sBpm Floating specific
    208          	SBPM_FLOAT_MTPV_LUT     = 16,    // WINDY sBpm Floating specific
    209          	SBPM_FLOAT_OTE          = 17,    // WINDY sBpm Floating specific
    210          	SBPM_FLOAT_SR_MOTOR     = 18,    // WINDY sBpm Floating specific
    211          	SBPM_FLOAT_MCA_SET_WM   = 19,    // WINDY sBpm Floating specific
    212          	SBPM_FLOAT_MCA_SENSOR_WM  = 20,  // WINDY sBpm Floating specific
    213          
    214              INVALID               = 256
    215          } COMM_STATE_MACHINE_E_TYPE;
    216          
    217          typedef enum
    218          {
    219              MASTER_COMMUNICATION_STANDBY                    = 0,
    220              MASTER_COMMUNICATION_RECEIVING_IN_PROCESS       = 1,
    221              MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS    = 2,
    222              MASTER_COMMUNICATION_NEW_PACKET_READY           = 3,
    223              MASTER_COMMUNICATION_NEW_COMMAND_READY          = 4,
    224              MASTER_COMMUNICATION_DUMMY                      = 256
    225          } MASTER_COMMUNICATION_RETURNS_E_TYPE;
    226          
    227          typedef enum
    228          {
    229              WAIT_FOR_ACK        = 0,
    230              WAIT_FOR_STX        = 1,
    231              WAIT_FOR_EXTENDED   = 2,
    232              WAIT_FOR_HDR        = 3,
    233              WAIT_FOR_TYPE       = 4,
    234              WAIT_FOR_LENGTH     = 5,
    235              WAIT_FOR_DATA       = 6,
    236              WAIT_FOR_DUMMY      = 256
    237          } RECEIVE_STATE_MACHINE_E_TYPE;
    238          
    239          typedef enum
    240          {
    241              PARSER_STATE_RECEIVING  = 0,
    242              PARSER_STATE_ERROR      = 1,
    243              PARSER_STATE_COMPLETED  = 2,
    244              PARSER_STATE_DUMMY      = 256
    245          } PARSER_RETURNS_E_TYPE;
    246          
    247          // multiple loads
    248          typedef enum
    249          {
    250          	EVALUATION_LOAD = 0,			//!< 0, evaluation state after a reset
    251          	DRIVING_L1		= 1,			//!< 1, drive load L1
    252          	DRIVING_L2		= 2,			//!< 2, drive load L2
    253          	DRIVING_DUMMY	= 256
    254          } DECODE_LOAD_STATE_MACHINE_ENUM_TYPE;
    255          
    256          // Set your limit for RAM Read or put Min and Max to zero to disable RAM read
    257          // If request is out of limit ram read will not be served
    258          #if (uP_MODEL == uP_MODEL_RX)
    259              #define MIN_READABLE_ADDRESS    0x00000001
    260          #define MAX_READABLE_ADDRESS        0x00003FFF
    261              #define READABLE_ADDRESS_OFFSET (MIN_READABLE_ADDRESS & 0xFFFF0000U)
    262          #elif (uP_MODEL == uP_MODEL_MK3)
    263              #define MIN_READABLE_ADDRESS    0x1FFFE000//0x1FFF8000
    264              #define MAX_READABLE_ADDRESS    0x20001FFF // should be 0x20001FFF
    265              #define READABLE_ADDRESS_OFFSET (MIN_READABLE_ADDRESS & 0xFFFF0000U)
    266          #endif
    267          
    268          // Timings
    269          #define COM_REQUEST_INTERVAL		2000  //250 ms * /1000 * Pwm Frequency
    270          #define DELAY_TIMER_FREQ_KHZ        8
    271          #define TOKEN_DELAY_TIME_MS         250
    272          #define TOKEN_DELAY_TIME            TOKEN_DELAY_TIME_MS*DELAY_TIMER_FREQ_KHZ
    273          #define RECEIVE_BYTE_TIMEOUT_MS     100
    274          #define RECEIVE_BYTE_TIMEOUT        RECEIVE_BYTE_TIMEOUT_MS*DELAY_TIMER_FREQ_KHZ
    275          #define BYTE_SEND_DELAY_MS          1
    276          #define BYTE_SEND_DELAY             BYTE_SEND_DELAY_MS*DELAY_TIMER_FREQ_KHZ
    277          
    278          // delay before trasmission in case of receive error
    279          #define ERROR_DELAY_TIME_MS         100
    280          #define ERROR_DELAY_TIME            ERROR_DELAY_TIME_MS*DELAY_TIMER_FREQ_KHZ
    281          
    282          #define MAXIMUM_READABLE_RAM_LOCATIONS_INFO_WORDS   16
    283          #define MAX_DELAY_BETWEEN_RAM_ADDRESS   (MAXIMUM_READABLE_RAM_LOCATIONS_INFO_WORDS<<1) // Multiplication by 2 for the byte addressing
    284          
    285          #define MINIMAL_INFO_WORDS          (SIZE_OF_INFO_BUFFER/2)
    286          #define MINIMAL_COMMON_WORDS        (SIZE_OF_COMMON_BUFFER/2)
    287          
    288          #if (APPLIANCE_TYPE == APPLIANCE_TYPE_WASHER)
    289              #define INFO_PACKET_SEND_SIZE   INFO_PACKET_SEND_FIXED_SIZE + 2*MAXIMUM_READABLE_RAM_LOCATIONS_INFO_WORDS + 2 + 2*MINIMAL_INFO_WORDS + 2 + 2*MINIMAL_COMMON_WORDS
    290              #define MAX_COUNTER_AFTER_RAM   INFO_PACKET_SEND_SIZE-INFO_PACKET_SEND_SEQUENCE_ID-2-MINIMAL_INFO_WORDS*2-2-MINIMAL_COMMON_WORDS*2-2-1
    291          #else
    292              #define INFO_PACKET_SEND_SIZE   INFO_PACKET_SEND_FIXED_SIZE + 2*MAXIMUM_READABLE_RAM_LOCATIONS_INFO_WORDS + 2*(2 + 2*MINIMAL_INFO_WORDS) + 2 + 2*MINIMAL_COMMON_WORDS
    293              #define MAX_COUNTER_AFTER_RAM   INFO_PACKET_SEND_SIZE-INFO_PACKET_SEND_SEQUENCE_ID-2*(2*MINIMAL_INFO_WORDS+2)-2-MINIMAL_COMMON_WORDS*2-2-1
    294          #endif
    295          
    296          #define NACK_BYTE                   0x55
    297          #define ACK_BYTE                    0x5A
    298          #define STX_BYTE                    0xA5
    299          #define EXTENDED_BYTE               0xEE
    300          #define HDR_BYTE                    0x01
    301          #define TOKEN_TYPE_BYTE             0x6A
    302          #define INFO_TYPE_BYTE              0x6B
    303          #define DATA_TYPE_RAM               0x00
    304          #define DATA_TYPE_COMMON            0xFF
    305          #define TOKEN_CRCHI_BYTE            0x8C
    306          #define TOKEN_CRCLO_BYTE            0x5E
    307          
    308          #define READ_SETTINGFILE_DATA_TYPE_BYTE 0x4A
    309          
    310          #define CRC_POLINOMIAL_VALUE        0x1021
    311          #define CRC_INIT_VALUE              0xFFFF
    312          
    313          #define TRIPHASE_MOTOR_CONTROL_AREA_POINTER 0x01
    314          
    315          #define MAIN_POINTER                0x001
    316          #define MAIN_DISPL                  0x000
    317          
    318          #define IO_POINTER                  0x021
    319          
    320          #ifndef MOTOR_SBPM_FLOAT
    321          #define MINIMUM_APPLICATION_PARAMS_NUM  Params__SizeOfSFApp()
    322          #define MINIMUM_SAFETY_PARAMS_NUM       Params__SizeOfSFSafe()
    323          #define MINIMUM_MODULES_PARAMS_NUM      Params__SizeOfSFModule()
    324          #define MINIMUM_MLIMIT_PARAMS_NUM       Params__SizeOfSFMLimit()
    325          
    326          
    327          #define MINIMUM_APPLICATION_1_PARAMS_NUM    (Params__SizeOfSFApp()/2/2)*2 /* mast be even */
    328          #define MINIMUM_APPLICATION_2_PARAMS_NUM    (MINIMUM_APPLICATION_PARAMS_NUM-MINIMUM_APPLICATION_1_PARAMS_NUM)
    329          #endif
    330          
    331          
    332          #define MASTER_COMMUNICATION_MAX_RESEND_PACKET  10
    333          
    334          #define LEN_INFO                    SIZE_OF_INFO_BUFFER+1
    335          #define LEN_COMMON                  SIZE_OF_COMMON_BUFFER+1
    336          
    337          #if (APPLIANCE_TYPE == APPLIANCE_TYPE_DISHWASHER)
    338              #define DEFAULT_LOAD 		        PILOT_TYPE_WASH		// the wash pump is activated when relay is in rest position
    339          #else
    340              #define DEFAULT_LOAD                0
    341          #endif
    342          

   \                                 In section .bss, align 4
    343          static uint16 Com_Request_Interval;
    344          static COMM_STATE_MACHINE_E_TYPE Master_Comm_Flags;
    345          static uint16 Send_Buffer[INFO_PACKET_SEND_SIZE];
    346          static uint16 Receive_Buffer[TOKEN_PACKET_RECEIVE_SIZE];
   \                     Receive_Buffer:
   \   00000000                      DS8 72
   \   00000048                      DS8 160
   \   000000E8                      DS8 8
   \   000000F0                      DS8 8
   \   000000F8                      DS8 1
   \   000000F9                      DS8 1
   \   000000FA                      DS8 1
   \   000000FB                      DS8 1
   \   000000FC                      DS8 1
   \   000000FD                      DS8 1
   \   000000FE                      DS8 1
   \   000000FF                      DS8 1
   \   00000100                      DS8 1
   \   00000101                      DS8 1
   \   00000102                      DS8 2
   \   00000104                      DS8 2
   \   00000106                      DS8 2
   \   00000108                      DS8 2
   \   0000010A                      DS8 2
   \   0000010C                      DS8 2
   \   0000010E                      DS8 2
   \   00000110                      DS8 2
   \   00000112                      DS8 2
   \   00000114                      DS8 2
   \   00000116                      DS8 2
   \   00000118                      DS8 2
   \   0000011A                      DS8 2
   \   0000011C                      DS8 2
   \   0000011E                      DS8 2
   \   00000120                      DS8 2
   \   00000122                      DS8 2
   \   00000124                      DS8 2
   \   00000126                      DS8 2
   \   00000128                      DS8 2
   \   0000012A                      DS8 2
   \   0000012C                      DS8 2
   \   0000012E                      DS8 2
   \   00000130                      DS8 2
   \   00000132                      DS8 2
   \   00000134                      DS8 2
   \   00000136                      DS8 2
   \   00000138                      DS8 4
   \   0000013C                      DS8 4
   \   00000140                      DS8 4
   \   00000144                      DS8 8
    347          static uint16 SafetyParamsBuffer[MINIMUM_MCISAFETY_PARAMS_NUM/2];
    348          
    349          static uint16 Bytes_To_Transmit;
    350          static uint16 Bytes_To_Receive;
    351          static uint16 Bytes_Transmitted;
    352          static uint16 Bytes_Received;
    353          static RECEIVE_STATE_MACHINE_E_TYPE Receive_State_Machine;
    354          static uint16 Token_Time_Mark;
    355          static uint16 Receive_Time_Mark;
    356          static uint16 Send_Time_Mark;
    357          static uint16 Attempts;
    358          static uint16 Min_Setting_Bytes_Num;
    359          
    360          static uint16* Ram_Read_Start_Address_Ptr;
    361          // lint -esym(552,Ram_Read_End_Address_Ptr)
    362          static uint16* Ram_Read_End_Address_Ptr;
    363          
    364          // lint -esym(552,Seq_ID)
    365          static uint16 Seq_ID;
    366          static uint16 Params_Displ;
    367          static uint16 Params_Displ_2;
    368          
    369          
    370          static uint8 Prm_Displ_DTC_Ctrl;
    371          static uint8 Prm_Displ_Motor_Lut;
    372          static uint8 Prm_Displ_Speed_Ctrl;
    373          static uint8 Prm_Displ_MTPA;
    374          static uint8 Prm_Displ_MTPV;
    375          static uint8 Prm_Displ_OTE;
    376          static uint8 Prm_Displ_SR;
    377          static uint8 Prm_Displ_Set_Wm;
    378          static uint8 Prm_Displ_Sensor_Wm;
    379          
    380          static uint16 Com_Safety_Flags;
    381          
    382          static uint16 Min_Params_Num;
    383          static uint16 Calculated_Crc;
    384          static uint16 MainCrc;
    385          static uint16 Calculated_Info_Crc;
    386          
    387          //! Safety Protocol Variables
    388          static uint16 Set_File_All_Crc;
    389          
    390          static uint8* Set_File_Table;
    391          static uint16 Table_Size;

   \                                 In section .bss, align 2
   \   00000000                      DS8 2
    392          static uint16 Buff_Safety_Displ;

   \                                 In section .bss, align 2
   \   00000000                      DS8 2
    393          static uint16 Crc_Application_1;
    394          

   \                                 In section .bss, align 2
   \   00000000                      DS8 2
    395          static uint16 Setting_File_Loading_Interrupted;
    396          
    397          static uint16 Com_Timer_Cnt;
    398          static uint16 Motor_Displ;
    399          static DECODE_LOAD_STATE_MACHINE_ENUM_TYPE Decode_Load_State_Machine;
    400          static uint16 Error_Delay;
    401          static uint16 Module_Type;
    402          static uint16 Modules_Displ;

   \                                 In section .bss, align 2
   \   00000000                      DS8 2
    403          static uint16 Displ_Sf_Params_L1;

   \                                 In section .bss, align 2
   \   00000000                      DS8 2
    404          static uint16 Displ_Sf_Params_L2;
    405          static uint16 Dyn_Packet;
    406          
    407          static COMMAND_DATA_TYPE Command_Data;
    408          static COMMAND_DATA_TYPE Command_Data_L1;
    409          static COMMAND_DATA_TYPE Command_Data_L2;
    410          
    411          static uint16 Fault;
    412          static uint16 COM_Global_Attempts;
    413          
    414          #if (COMMAND_MODE==FREEMASTER)
    415          //! Decode Master command handlin flag from FreeMaster 
    416          static uint16 Master_Cmd_Force;
    417          #endif
    418          
    419          #if (COMMAND_MODE==SIL)
    420          //! Decode Master command handlin flag from FreeMaster 
    421          #include "Sil.h"
    422          extern SIL_TYPE Sil;
    423          #endif
    424          
    425          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
    426          static void ProtocolInitialization(COMM_STATE_MACHINE_E_TYPE comm_type);
    427          static inline uint16 IsTxReady(void);
    428          static uint16 MakeReadSettingFileDataBlock(uint16* buffer, uint16 pointer, uint16 displacement, uint16 offset, uint8 num_bytes);
    429          static uint16 MakeInfoPacket(uint16* buffer);
    430          static MASTER_COMMUNICATION_RETURNS_E_TYPE Rs232MasterCommunication(void);
    431          static MASTER_COMMUNICATION_RETURNS_E_TYPE CheckResendPacket(uint16 resend_on_error);
    432          static PARSER_RETURNS_E_TYPE RxParser(uint8 new_byte);
    433          static PARSER_RETURNS_E_TYPE DisplProcessing(void);
    434          static void DecodeLoadType(void);
    435          static void InitPumps(void);
    436          #if (uP_MODEL == uP_MODEL_MK3)
    437          static inline uint32 TranslateAddress(uint32 address);
    438          #endif /* uP_MODEL_MK3 */
    439          static uint16 CalcCrc1(uint16 crc, uint8 data);
    440          static uint16 CalcCrc(uint16 *buf, uint16 len);
    441          
    442          //=====================================================================================================================
    443          //-------------------------------------- Public Functions -------------------------------------------------------------
    444          //=====================================================================================================================
    445          
    446          //---------------------------------------------------------------------------------------------------------------------
    447          /**
    448           *  @brief      It Initializes the module ProtocolMainExternal and its variables
    449           *
    450           */

   \                                 In section .text, align 2, keep-with-next
    451          void ProtocolMainExternal__Initialize(void)
    452          {
   \                     ProtocolMainExternal__Initialize: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    453              ProtocolInfo__Initialize();
   \   00000004   0x.... 0x....      BL       ProtocolInfo__Initialize
    454          #if (COM_MAIN_EXTERNAL == ENABLED)
    455              Uart__Initialize(PROTOCOLMAINEXTERNAL_COMPORT, PROTOCOLMAINEXTERNAL_BAUDRATE, UART_STOP_BIT_1, UART_PARITY_NONE);
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x2103             MOVS     R1,#+3
   \   0000000E   0x4610             MOV      R0,R2
   \   00000010   0x.... 0x....      BL       Uart__Initialize
    456              if (FaultManager__GetResetState() == TRUE)
   \   00000014   0x.... 0x....      BL       FaultManager__GetResetState
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD107             BNE.N    ??ProtocolMainExternal__Initialize_0
    457              {
    458                  // Reset the peripheral in case of external reset request
    459                  Uart__Disable(PROTOCOLMAINEXTERNAL_COMPORT, UART_OPTION_ALL);
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      BL       Uart__Disable
    460                  Uart__Enable(PROTOCOLMAINEXTERNAL_COMPORT, UART_OPTION_ALL);
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x4608             MOV      R0,R1
   \   00000028   0x.... 0x....      BL       Uart__Enable
    461              }
    462          
    463          
    464          //    SRMotorSafetyInfoParamsMgr__SetLoaded(FALSE);
    465              //Params__SetLoaded(FALSE);
    466              Params__SetReady(FALSE);
   \                     ??ProtocolMainExternal__Initialize_0: (+1)
   \   0000002C   0x....             LDR.N    R4,??DataTable4
    467             // Params__SetUpdated(FALSE);
    468          
    469          #endif //#if (COMM_MODE==MAIN_uC)
    470          
    471          #if ((APPLIANCE_TYPE == APPLIANCE_TYPE_DISHWASHER) || (defined(INTERNAL_PARAMS)))
    472          
    473          	ProtocolInitialization(TOKEN);  // initialization of Communication Protocol
   \   0000002E   0x....             LDR.N    R5,??DataTable4_1
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x7020             STRB     R0,[R4, #+0]
   \   00000034   0xF8B5 0x012A      LDRH     R0,[R5, #+298]
   \   00000038   0xF8A5 0x0110      STRH     R0,[R5, #+272]
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xF8A5 0x0106      STRH     R0,[R5, #+262]
   \   00000042   0xF8A5 0x0108      STRH     R0,[R5, #+264]
   \   00000046   0xF8A5 0x0130      STRH     R0,[R5, #+304]
   \   0000004A   0xF8A5 0x0116      STRH     R0,[R5, #+278]
   \   0000004E   0xF8A5 0x0104      STRH     R0,[R5, #+260]
   \   00000052   0xF8C5 0x0138      STR      R0,[R5, #+312]
   \   00000056   0xF8C5 0x013C      STR      R0,[R5, #+316]
   \   0000005A   0xF8A5 0x011C      STRH     R0,[R5, #+284]
    474          
    475          #if (APPLIANCE_TYPE == APPLIANCE_TYPE_DISHWASHER)
    476          	RELAY_PUMPS_CONFIG();
    477          #else
    478          	// We don't need a reset for the internal parameters to work
    479          	Params__Initialize();
   \   0000005E   0x.... 0x....      BL       Params__Initialize
    480          	Params__SetReady(TRUE);
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0x7020             STRB     R0,[R4, #+0]
    481          
    482          	//Motor Sr parameters initialization
    483          	//memcpy(SafetyParamsBuffer, &MotorSrParams, MINIMUM_MCISAFETY_PARAMS_NUM);
    484          	//safety parameters Crc calculation to pass the check class B check in safety data (the excel file doesn't calculate it)
    485          	//SafetyParamsBuffer[1] = Crc16__RangeProcess((uint8 *)(&SafetyParamsBuffer[2]),0xFFFF,(MINIMUM_MCISAFETY_PARAMS_NUM-4));
    486              //SafetyParamsBuffer[1] = CalcCrc(&SafetyParamsBuffer[2], MINIMUM_MCISAFETY_PARAMS_NUM-4);
    487          
    488          	//SRMotorSafetyInfoParamsMgr__SetParams(&SafetyParamsBuffer[1]);
    489          #endif
    490          
    491          #else
    492          	ProtocolInitialization(DISPLDATA); // initialization of Communication Protocol
    493          #endif
    494          	// initialization of ComRequestInterval
    495          	Com_Request_Interval = TOKEN_DELAY_TIME;  // corresponding to 250ms (expressed in 8KHz cycles)
    496          
    497              Fault = 0;
    498              Motor_Displ = 0;
    499              Decode_Load_State_Machine = EVALUATION_LOAD;
    500          
    501              COM_Global_Attempts = 0;
    502          
    503              Setting_File_Loading_Interrupted = FALSE;
    504          }
   \   00000066   0xB001             ADD      SP,SP,#+4
   \   00000068   0xF44F 0x60FA      MOV      R0,#+2000
   \   0000006C   0xF8A5 0x0102      STRH     R0,[R5, #+258]
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xF8A5 0x0134      STRH     R0,[R5, #+308]
   \   00000076   0xF8A5 0x012C      STRH     R0,[R5, #+300]
   \   0000007A   0xF8A5 0x012E      STRH     R0,[R5, #+302]
   \   0000007E   0xF8A5 0x0136      STRH     R0,[R5, #+310]
   \   00000082   0xBD30             POP      {R4,R5,PC}       ;; return
    505          
    506          
    507          //---------------------------------------------------------------------------------------------------------------------
    508          /**
    509           *  @brief      ProtocolMainExternal 250us handler
    510           *
    511           */

   \                                 In section .text, align 2, keep-with-next
    512          void ProtocolMainExternal__250usHandler(void)
    513          {
    514              // Increment by 2 to simulate DELAY_TIMER_FREQ_KHZ = 8kHz frequency
    515              Com_Timer_Cnt += 2;
   \                     ProtocolMainExternal__250usHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4_1
   \   00000002   0xF8B0 0x112A      LDRH     R1,[R0, #+298]
   \   00000006   0x1C89             ADDS     R1,R1,#+2
   \   00000008   0xF8A0 0x112A      STRH     R1,[R0, #+298]
    516          
    517              // wait delay before transmitting in case of error
    518              if (Error_Delay > 1)
   \   0000000C   0xF8B0 0x1130      LDRH     R1,[R0, #+304]
   \   00000010   0x2902             CMP      R1,#+2
   \   00000012   0xBFAC             ITE      GE 
    519              {
    520                  // Decrement by 2 to simulate DELAY_TIMER_FREQ_KHZ = 8kHz frequency
    521                  Error_Delay -= 2;
   \   00000014   0x1E89             SUBGE    R1,R1,#+2
    522              }
    523              else
    524              {
    525                  Error_Delay = 0;
   \   00000016   0x2100             MOVLT    R1,#+0
   \   00000018   0xF8A0 0x1130      STRH     R1,[R0, #+304]
    526              }
    527          }
   \   0000001C   0x4770             BX       LR               ;; return
    528          
    529          
    530          //---------------------------------------------------------------------------------------------------------------------
    531          /**
    532           *  @brief      ProtocolMainExternal 1ms handler
    533           *
    534           */

   \                                 In section .text, align 2, keep-with-next
    535          void ProtocolMainExternal__1msHandler(void)
    536          {
   \                     ProtocolMainExternal__1msHandler: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    537          	MASTER_COMMUNICATION_RETURNS_E_TYPE main_communication_return;
                 	                                    ^
Warning[Pe550]: variable "main_communication_return" was set but never used
    538          
    539          #if (COM_MAIN_EXTERNAL == ENABLED)
    540          	if (FaultManager__GetResetState() == TRUE)
   \   00000004   0x.... 0x....      BL       FaultManager__GetResetState
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD003             BEQ.N    ??ProtocolMainExternal__1msHandler_0
    541          	{
    542          	    // Do not communicate in case of external reset request
    543          	    main_communication_return = MASTER_COMMUNICATION_STANDBY;
    544          	}
    545          	else
    546          	{
    547          	    main_communication_return = Rs232MasterCommunication();
   \   0000000C   0xB001             ADD      SP,SP,#+4
   \   0000000E   0xF85D 0xEB04      POP      {LR}
   \   00000012   0x....             B.N      Rs232MasterCommunication
    548          	}
    549          #else
    550          	ProtocolInfo__GetInfo();
    551          #endif
    552          
    553          #if (COMMAND_MODE==MAIN_uC)
    554          
    555              // Main Communication Manager
    556              if (main_communication_return==MASTER_COMMUNICATION_NEW_COMMAND_READY)  // new command ready ?
    557              {
    558          #elif (COMMAND_MODE==FREEMASTER)
    559              if(Master_Cmd_Force)
    560              {
    561                  Master_Cmd_Force = 0;
    562          
    563          #elif (COMMAND_MODE==MCI_BD)
    564              if(0)
    565              {
    566          #elif (COMMAND_MODE==SIL)
    567              if(Sil.Cmd.Force == 1)
    568              {
    569                  Sil.Cmd.Force = 0;
    570          		Command_Data_L1.Speed = Sil.Cmd.Speed;
    571          		Command_Data_L1.Ramp_Time = Sil.Cmd.Time;
    572          		Command_Data_L1.Cmd_Flags = Sil.Cmd.Flags;
    573          #elif (COMMAND_MODE==COMMAND_MANAGER_BD)
    574          	{
    575          #else
    576          #endif
    577                  #if (APPLIANCE_TYPE == APPLIANCE_TYPE_DISHWASHER)
    578          		// Decode Load Type
    579          		DecodeLoadType();
    580          
    581          		#if (COMMAND_MODE==FREEMASTER)
    582          			switch (Decode_Load_State_Machine)
    583          			{
    584          				case DRIVING_L1:
    585          					Command_Data.Data_Type = PILOT_TYPE_DRAIN;
    586          					break;
    587          
    588          				case DRIVING_L2:
    589          					Command_Data.Data_Type = PILOT_TYPE_WASH;
    590          					break;
    591          
    592          				default:
    593          					break;
    594          			}
    595          		#endif
    596          
    597          		#ifdef INTERNAL_PARAMS
    598          	    InitPumps();
    599          		#endif
    600          
    601          	    CommandManager__DecodeMasterCommand(Command_Data.Speed, Command_Data.Ramp_Time);
    602          		#else
    603          		CommandManager__DecodeMasterCommand(Command_Data_L1.Speed, Command_Data_L1.Ramp_Time, Command_Data_L1.Cmd_Flags);
    604          
    605          
    606          //        //Meaning request
    607          //        if(BIT_TEST(Command_Data_L1.Cmd_Flags,MEANING_REQUEST) != 0)
    608          //        {
    609          //            SensorsAlgorithms__MeaningRequest(TRUE);
    610          //        }
    611          //        else
    612          //        {
    613          //            SensorsAlgorithms__MeaningRequest(FALSE);
    614          //        }
    615          //
    616          //        //Limit normative request
    617          //        if(BIT_TEST(Command_Data_L1.Cmd_Flags,VDC_NORM_REQUEST) != 0)
    618          //        {
    619          //            SensorsAlgorithms__LimitNormRequest(TRUE);
    620          //        }
    621          //        else
    622          //        {
    623          //            SensorsAlgorithms__LimitNormRequest(FALSE);
    624          //        }
    625          		#endif //#if (APPLIANCE_TYPE == APPLIANCE_TYPE_DISHWASHER)
    626          
    627          
    628              }
    629          }
   \                     ??ProtocolMainExternal__1msHandler_0: (+1)
   \   00000014   0xB001             ADD      SP,SP,#+4
   \   00000016   0xBD00             POP      {PC}             ;; return
    630          
    631          
    632          /**
    633           *  @brief      Get the last ProtocolMainExternal Fault
    634           *
    635           *  @return     Value of last fault detected by the module
    636           *
    637           */

   \                                 In section .text, align 2, keep-with-next
    638          uint16 ProtocolMainExternal__GetFault(void)
    639          {
    640              return Fault;
   \                     ProtocolMainExternal__GetFault: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4_1
   \   00000002   0xF8B0 0x0134      LDRH     R0,[R0, #+308]
   \   00000006   0x4770             BX       LR               ;; return
    641          }
    642          
    643          
    644          
    645          /**
    646           *  @brief      Get the last ProtocolMainExternal Fault
    647           *
    648           *  @return     Value of last fault detected by the module
    649           *
    650           */

   \                                 In section .text, align 2, keep-with-next
    651          COMMAND_DATA_TYPE* ProtocolMainExternal__GetCommandData(LOAD_ENUM_TYPE load)
    652          {
    653          
    654              COMMAND_DATA_TYPE* read_command;
    655          
    656              switch(load)
   \                     ProtocolMainExternal__GetCommandData: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD004             BEQ.N    ??ProtocolMainExternal__GetCommandData_0
   \   00000004   0x2802             CMP      R0,#+2
   \   00000006   0xD005             BEQ.N    ??ProtocolMainExternal__GetCommandData_1
    657          	{
    658          		case LOAD_0:
    659          			read_command = &Command_Data;
    660          			break;
    661          
    662          		case LOAD_1:
    663          			read_command = &Command_Data_L1;
    664          			break;
    665          
    666          		case LOAD_2:
    667          			read_command = &Command_Data_L2;
    668          			break;
    669          
    670          		default:
    671          		    // Default value if no valid load provided
    672          		    read_command = &Command_Data;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable5
    673          			break;
    674          	};
    675          
    676              return(read_command);
   \   0000000C   0x4770             BX       LR
   \                     ??ProtocolMainExternal__GetCommandData_0: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000012   0x4770             BX       LR
   \                     ??ProtocolMainExternal__GetCommandData_1: (+1)
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   00000018   0x4770             BX       LR
    677          }
    678          
    679          #if (APPLIANCE_TYPE == APPLIANCE_TYPE_DISHWASHER)
    680          //---------------------------------------------------------------------------------------------------------------------
    681          /**
    682           *  @brief      Returns pointer to commond feedback struct
    683           *
    684           *  @param      comm_type - initial state
    685           */
    686          //void ProtocolMainExternal__SetIPMType(IPM_TYPE ipm_type)
    687          //{
    688          //   Module_Type = ipm_type;
    689          //}
    690          #endif
    691             
    692          //=====================================================================================================================
    693          //-------------------------------------- Private Functions ------------------------------------------------------------
    694          //=====================================================================================================================
    695          //---------------------------------------------------------------------------------------------------------------------
    696          /**
    697           *  @brief      Protocol initialisation
    698           *
    699           *  @param      comm_type - initial state
    700           */
    701          void ProtocolInitialization(COMM_STATE_MACHINE_E_TYPE comm_type)
    702          {
    703              Token_Time_Mark = Com_Timer_Cnt;
    704              Bytes_To_Transmit = 0;
    705              Bytes_To_Receive = 0;
    706              Error_Delay = 0;
    707              Attempts = 0;
    708              Master_Comm_Flags = comm_type;
    709              Ram_Read_Start_Address_Ptr = NULL;
    710              Ram_Read_End_Address_Ptr = NULL;
    711              Com_Safety_Flags = 0;
    712          }
    713          
    714          
    715          //---------------------------------------------------------------------------------------------------------------------
    716          /**
    717           *  @brief      If Return a save time mark using Send_Time_Mark=Com_Timer_Cnt
    718           *
    719           *  @return     Return 1 or 0 depending on SCI Resisters. If ready to send another char return 1, else return 0
    720           */
    721          inline uint16 IsTxReady(void)
    722          {
    723              uint16 ret_val;
    724              ret_val = 0;
    725          
    726              if(TRUE == Uart__GetStatus(PROTOCOLMAINEXTERNAL_COMPORT, UART_STATUS_TX_EMPTY))
    727              {
    728                  if((uint16)(Com_Timer_Cnt - Send_Time_Mark) >= BYTE_SEND_DELAY)
    729                  {
    730                      ret_val = 1;
    731                  }
    732              }
    733              else
    734              {
    735                  Send_Time_Mark = Com_Timer_Cnt;
    736              }
    737          
    738              return ret_val;
    739          }
    740          
    741          
    742          //---------------------------------------------------------------------------------------------------------------------
    743          /**
    744           *  @brief      Makes read setting file data block
    745           *
    746           *  @param      buffer - Transmission buffer
    747           *  @return     size of block
    748           */
    749          uint16 MakeReadSettingFileDataBlock(uint16* buffer, uint16 pointer, uint16 displacement, uint16 offset, uint8 num_bytes)
    750          {
    751              uint16 crc;
    752              uint16 read_setting_size;
    753          
    754              *(buffer+READSETTING_STX)       = STX_BYTE;
    755              *(buffer+READSETTING_EXTENDED)  = EXTENDED_BYTE;
    756              *(buffer+READSETTING_HDR)       = HDR_BYTE;
    757              *(buffer+READSETTING_TYPE)      = READ_SETTINGFILE_DATA_TYPE_BYTE;
    758          
    759              if(num_bytes == 0)
    760              {
    761                  *(buffer+READSETTING_LENGTH)    = READSETTING_CRCHI-READSETTING_LENGTH-1;
    762                  *(buffer+READSETTING_POINTER)   = pointer;              // FIXED POINTER
    763                  *(buffer+READSETTING_DISPL)     = displacement;         // FIXED DISPLACEMENT
    764          
    765                  crc=CalcCrc(buffer,READSETTING_CRCHI);
    766                  *(buffer+READSETTING_CRCHI)     = ((crc >> 8) & 0x00FF);
    767                  *(buffer+READSETTING_CRCLO)     = ((crc) & 0x00FF);
    768          
    769                  read_setting_size = READSETTING_SIZE;
    770              }
    771              else
    772              {
    773                  *(buffer+EXT_READSETTING_LENGTH)    = EXT_READSETTING_CRCHI-EXT_READSETTING_LENGTH-1;
    774                  *(buffer+EXT_READSETTING_POINTER)   = pointer;          // FIXED POINTER
    775                  *(buffer+EXT_READSETTING_DISPL)     = displacement;     // FIXED DISPLACEMENT
    776          
    777                  *(buffer+EXT_READSETTING_OFFSET_LO) = (offset) & 0x00FF;
    778                  *(buffer+EXT_READSETTING_OFFSET_HI) = offset>>8;
    779                  *(buffer+EXT_READSETTING_NUMBYTES)  = num_bytes;
    780          
    781                  crc=CalcCrc(buffer,EXT_READSETTING_CRCHI);
    782                  *(buffer+EXT_READSETTING_CRCHI)     = ((crc >> 8) & 0x00FF);
    783                  *(buffer+EXT_READSETTING_CRCLO)     = ((crc) & 0x00FF);
    784          
    785                  read_setting_size = EXT_READSETTING_SIZE;
    786              }
    787          
    788              return (read_setting_size);
    789          }
    790          
    791          
    792          //---------------------------------------------------------------------------------------------------------------------
    793          /**
    794           *  @brief      Makes token packet
    795           *
    796           *  @param      buffer - Transmission buffer
    797           *  @return     size of block
    798           */
    799          inline uint16 MakeTokenPacket(uint16* buffer)
    800          {
    801              *(buffer+TOKEN_PACKET_SEND_STX)     = STX_BYTE;
    802              *(buffer+TOKEN_PACKET_SEND_EXTENDED)= EXTENDED_BYTE;
    803              *(buffer+TOKEN_PACKET_SEND_HDR)     = HDR_BYTE;
    804              *(buffer+TOKEN_PACKET_SEND_TYPE)    = TOKEN_TYPE_BYTE;
    805              *(buffer+TOKEN_PACKET_SEND_LENGTH)  = TOKEN_PACKET_SEND_CRCHI-TOKEN_PACKET_SEND_LENGTH-1;
    806              *(buffer+TOKEN_PACKET_SEND_DATA0)   = TOKEN_TYPE_BYTE;
    807              *(buffer+TOKEN_PACKET_SEND_CRCHI)   = TOKEN_CRCHI_BYTE; // attention: must be change accordingly to CRC calculation
    808              *(buffer+TOKEN_PACKET_SEND_CRCLO)   = TOKEN_CRCLO_BYTE; // attention: must be change accordingly to CRC calculation
    809          
    810              return (TOKEN_PACKET_SEND_SIZE);
    811          }
    812          
    813          
    814          //---------------------------------------------------------------------------------------------------------------------
    815          /**
    816           *  @brief      Makes info packet
    817           *
    818           *
    819           *  @param      buffer - Transmission buffer
    820           *  @return     size of block
    821           */

   \                                 In section .text, align 2, keep-with-next
    822          uint16 MakeInfoPacket(uint16* buffer)
    823          {
   \                     MakeInfoPacket: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
    824              uint16 counter;
    825              uint16 i;
    826              uint16 *buff_ptr;
    827              uint16 *ram_read_start_address_ptr_temp;
    828          	sint16 k1;
    829              uint16 packet_len;
    830              PROTOCOL_INFO_TYPE* protocol_info;
    831          
    832              protocol_info = ProtocolInfo__GetInfo();
   \   00000006   0x.... 0x....      BL       ProtocolInfo__GetInfo
   \   0000000A   0x4605             MOV      R5,R0
    833              packet_len = 1+2+MINIMAL_INFO_WORDS*2; // initialize at minimum size
    834          
    835              counter = 1;
    836          
    837              //------------------------------------------------------
    838          
    839              buff_ptr = (buffer+INFO_PACKET_SEND_SEQUENCE_ID);
    840          
    841              *(buffer+INFO_PACKET_SEND_STX)      = STX_BYTE;
   \   0000000C   0x20A5             MOVS     R0,#+165
   \   0000000E   0x8020             STRH     R0,[R4, #+0]
   \   00000010   0x2601             MOVS     R6,#+1
    842              *(buffer+INFO_PACKET_SEND_EXTENDED) = EXTENDED_BYTE;
   \   00000012   0x20EE             MOVS     R0,#+238
   \   00000014   0x8060             STRH     R0,[R4, #+2]
    843              *(buffer+INFO_PACKET_SEND_HDR)      = HDR_BYTE;
   \   00000016   0x80A6             STRH     R6,[R4, #+4]
    844              *(buffer+INFO_PACKET_SEND_TYPE)     = INFO_TYPE_BYTE;
   \   00000018   0x206B             MOVS     R0,#+107
   \   0000001A   0x80E0             STRH     R0,[R4, #+6]
   \   0000001C   0x2713             MOVS     R7,#+19
    845              *(buff_ptr)                         = Seq_ID;
   \   0000001E   0x.... 0x....      LDR.W    R8,??DataTable4_1
   \   00000022   0xF8B8 0x011A      LDRH     R0,[R8, #+282]
   \   00000026   0xF104 0x090A      ADD      R9,R4,#+10
   \   0000002A   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    846          
    847             	if (Ram_Read_Start_Address_Ptr != NULL)
   \   0000002E   0xF8D8 0xA138      LDR      R10,[R8, #+312]
   \   00000032   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000036   0xD02E             BEQ.N    ??MakeInfoPacket_0
    848              {   // Ram/ Ident Table reading request
    849                  packet_len += 2+(Ram_Read_End_Address_Ptr-Ram_Read_Start_Address_Ptr+1)*2; // add read ram
   \   00000038   0xF8D8 0x013C      LDR      R0,[R8, #+316]
   \   0000003C   0xEBA0 0x010A      SUB      R1,R0,R10
   \   00000040   0x1049             ASRS     R1,R1,#+1
   \   00000042   0x0049             LSLS     R1,R1,#+1
   \   00000044   0xF101 0x0717      ADD      R7,R1,#+23
    850          
    851                  *(buffer+INFO_PACKET_SEND_LENDATARAM)=(uint16)(1+(Ram_Read_End_Address_Ptr-Ram_Read_Start_Address_Ptr+1)*2);
   \   00000048   0xEBA0 0x010A      SUB      R1,R0,R10
   \   0000004C   0xF64F 0x72FE      MOVW     R2,#+65534
   \   00000050   0x4011             ANDS     R1,R2,R1
   \   00000052   0x1CC9             ADDS     R1,R1,#+3
   \   00000054   0x81A1             STRH     R1,[R4, #+12]
    852                  *(buffer+INFO_PACKET_SEND_DATATYPERAM)=DATA_TYPE_RAM;
    853                  counter = 3;
   \   00000056   0x2603             MOVS     R6,#+3
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0xB2BF             UXTH     R7,R7
   \   0000005C   0x81E1             STRH     R1,[R4, #+14]
    854          
    855                  ram_read_start_address_ptr_temp = Ram_Read_Start_Address_Ptr;
    856          
    857                  while (ram_read_start_address_ptr_temp <= Ram_Read_End_Address_Ptr)
   \   0000005E   0x4550             CMP      R0,R10
   \   00000060   0xD319             BCC.N    ??MakeInfoPacket_0
   \   00000062   0xE002             B.N      ??MakeInfoPacket_1
    858                  {
    859                      if(counter > MAX_COUNTER_AFTER_RAM)
   \                     ??MakeInfoPacket_2: (+1)
   \   00000064   0xB2B6             UXTH     R6,R6
   \   00000066   0x2E23             CMP      R6,#+35
   \   00000068   0xDA0C             BGE.N    ??MakeInfoPacket_3
    860                      {
    861                          SRException__Queue(EXCEPTION_SEND_PACKET_FAIL, 0, 0);
    862                      }
    863                      else
    864                      {
    865                          *(buff_ptr+counter)= (*(ram_read_start_address_ptr_temp) >> 8);
   \                     ??MakeInfoPacket_1: (+1)
   \   0000006A   0xF8BA 0x0000      LDRH     R0,[R10, #+0]
   \   0000006E   0x0A00             LSRS     R0,R0,#+8
   \   00000070   0xF829 0x0016      STRH     R0,[R9, R6, LSL #+1]
    866                          counter++;
   \   00000074   0x1C70             ADDS     R0,R6,#+1
    867                          *(buff_ptr+counter)= (*(ram_read_start_address_ptr_temp++) & 0x00FF);
   \   00000076   0xF81A 0x1B02      LDRB     R1,[R10], #+2
   \   0000007A   0xB280             UXTH     R0,R0
   \   0000007C   0xF829 0x1010      STRH     R1,[R9, R0, LSL #+1]
    868                          counter++;
   \   00000080   0x1C46             ADDS     R6,R0,#+1
   \   00000082   0xE004             B.N      ??MakeInfoPacket_4
    869                      }
   \                     ??MakeInfoPacket_3: (+1)
   \   00000084   0x2200             MOVS     R2,#+0
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x2022             MOVS     R0,#+34
   \   0000008A   0x.... 0x....      BL       SRException__Queue
   \                     ??MakeInfoPacket_4: (+1)
   \   0000008E   0xF8D8 0x013C      LDR      R0,[R8, #+316]
   \   00000092   0x4550             CMP      R0,R10
   \   00000094   0xD2E6             BCS.N    ??MakeInfoPacket_2
    870                  }
    871              }
    872          
    873              if(Decode_Load_State_Machine != DRIVING_L2)
   \                     ??MakeInfoPacket_0: (+1)
   \   00000096   0xF9B8 0x012E      LDRSH    R0,[R8, #+302]
   \   0000009A   0x2802             CMP      R0,#+2
   \   0000009C   0xBF14             ITE      NE 
    874              {// we are driving the load in the first place --> we have to write the first part of InfoBuffer
    875               // we are in "Evaluation" phase --> we have to write the first part of InfoBuffer
    876                  k1 = 0;
   \   0000009E   0x2000             MOVNE    R0,#+0
    877              }
    878              else
    879              {
    880                  k1 = MINIMAL_INFO_WORDS*2 + 2;
   \   000000A0   0x2024             MOVEQ    R0,#+36
    881              }
    882          
    883              // Put len info & datatype
    884              *(buff_ptr+counter) = LEN_INFO;
   \   000000A2   0x2111             MOVS     R1,#+17
   \   000000A4   0xB2B6             UXTH     R6,R6
   \   000000A6   0xF829 0x1016      STRH     R1,[R9, R6, LSL #+1]
    885              counter++;
   \   000000AA   0x1C71             ADDS     R1,R6,#+1
    886              *(buff_ptr+counter) = Command_Data_L1.Data_Type;
   \   000000AC   0xF8B8 0x20EE      LDRH     R2,[R8, #+238]
   \   000000B0   0xB289             UXTH     R1,R1
   \   000000B2   0xF829 0x2011      STRH     R2,[R9, R1, LSL #+1]
    887              counter++;
   \   000000B6   0x1C49             ADDS     R1,R1,#+1
    888          
    889              Buff_Safety_Displ = INFO_PACKET_SEND_SEQUENCE_ID+counter;
    890          
    891             	// Put minimal info related to driven load
    892              for (i=0;i<MINIMAL_INFO_WORDS;i++)
    893              {
    894                  *(buff_ptr+k1+counter)= (((uint16*)protocol_info)[i]) >> 8;
   \   000000B8   0x882B             LDRH     R3,[R5, #+0]
   \   000000BA   0xEB00 0x0209      ADD      R2,R0,R9
   \   000000BE   0xB289             UXTH     R1,R1
   \   000000C0   0x0A1B             LSRS     R3,R3,#+8
   \   000000C2   0xF822 0x3011      STRH     R3,[R2, R1, LSL #+1]
    895                  counter++;
   \   000000C6   0x1C49             ADDS     R1,R1,#+1
    896                  *(buff_ptr+k1+counter)= (((uint16*)protocol_info)[i]) & 0x00FF;
   \   000000C8   0x782B             LDRB     R3,[R5, #+0]
   \   000000CA   0xB289             UXTH     R1,R1
   \   000000CC   0xF822 0x3011      STRH     R3,[R2, R1, LSL #+1]
    897                  counter++;
   \   000000D0   0x1C49             ADDS     R1,R1,#+1
   \   000000D2   0x886B             LDRH     R3,[R5, #+2]
   \   000000D4   0xB289             UXTH     R1,R1
   \   000000D6   0x0A1B             LSRS     R3,R3,#+8
   \   000000D8   0xF822 0x3011      STRH     R3,[R2, R1, LSL #+1]
   \   000000DC   0x1C49             ADDS     R1,R1,#+1
   \   000000DE   0x78AB             LDRB     R3,[R5, #+2]
   \   000000E0   0xB289             UXTH     R1,R1
   \   000000E2   0xF822 0x3011      STRH     R3,[R2, R1, LSL #+1]
   \   000000E6   0x1C49             ADDS     R1,R1,#+1
   \   000000E8   0x88AB             LDRH     R3,[R5, #+4]
   \   000000EA   0xB289             UXTH     R1,R1
   \   000000EC   0x0A1B             LSRS     R3,R3,#+8
   \   000000EE   0xF822 0x3011      STRH     R3,[R2, R1, LSL #+1]
   \   000000F2   0x1C49             ADDS     R1,R1,#+1
   \   000000F4   0x792B             LDRB     R3,[R5, #+4]
   \   000000F6   0xB289             UXTH     R1,R1
   \   000000F8   0xF822 0x3011      STRH     R3,[R2, R1, LSL #+1]
   \   000000FC   0x1C49             ADDS     R1,R1,#+1
   \   000000FE   0x88EB             LDRH     R3,[R5, #+6]
   \   00000100   0xB289             UXTH     R1,R1
   \   00000102   0x0A1B             LSRS     R3,R3,#+8
   \   00000104   0xF822 0x3011      STRH     R3,[R2, R1, LSL #+1]
   \   00000108   0x1C49             ADDS     R1,R1,#+1
   \   0000010A   0x79AB             LDRB     R3,[R5, #+6]
   \   0000010C   0xB289             UXTH     R1,R1
   \   0000010E   0xF822 0x3011      STRH     R3,[R2, R1, LSL #+1]
   \   00000112   0x1C49             ADDS     R1,R1,#+1
   \   00000114   0x892B             LDRH     R3,[R5, #+8]
   \   00000116   0xB289             UXTH     R1,R1
   \   00000118   0x0A1B             LSRS     R3,R3,#+8
   \   0000011A   0xF822 0x3011      STRH     R3,[R2, R1, LSL #+1]
   \   0000011E   0x1C49             ADDS     R1,R1,#+1
   \   00000120   0x7A2B             LDRB     R3,[R5, #+8]
   \   00000122   0xB289             UXTH     R1,R1
   \   00000124   0xF822 0x3011      STRH     R3,[R2, R1, LSL #+1]
   \   00000128   0x1C49             ADDS     R1,R1,#+1
   \   0000012A   0x896B             LDRH     R3,[R5, #+10]
   \   0000012C   0xB289             UXTH     R1,R1
   \   0000012E   0x0A1B             LSRS     R3,R3,#+8
   \   00000130   0xF822 0x3011      STRH     R3,[R2, R1, LSL #+1]
   \   00000134   0x1C49             ADDS     R1,R1,#+1
   \   00000136   0x7AAB             LDRB     R3,[R5, #+10]
   \   00000138   0xB289             UXTH     R1,R1
   \   0000013A   0xF822 0x3011      STRH     R3,[R2, R1, LSL #+1]
   \   0000013E   0x1C49             ADDS     R1,R1,#+1
   \   00000140   0x89AB             LDRH     R3,[R5, #+12]
   \   00000142   0xB289             UXTH     R1,R1
   \   00000144   0x0A1B             LSRS     R3,R3,#+8
   \   00000146   0xF822 0x3011      STRH     R3,[R2, R1, LSL #+1]
   \   0000014A   0x1C49             ADDS     R1,R1,#+1
   \   0000014C   0x7B2B             LDRB     R3,[R5, #+12]
   \   0000014E   0xB289             UXTH     R1,R1
   \   00000150   0xF822 0x3011      STRH     R3,[R2, R1, LSL #+1]
   \   00000154   0x1C49             ADDS     R1,R1,#+1
   \   00000156   0x89EB             LDRH     R3,[R5, #+14]
   \   00000158   0xB289             UXTH     R1,R1
   \   0000015A   0x0A1B             LSRS     R3,R3,#+8
   \   0000015C   0xF822 0x3011      STRH     R3,[R2, R1, LSL #+1]
   \   00000160   0x1C49             ADDS     R1,R1,#+1
   \   00000162   0x7BAB             LDRB     R3,[R5, #+14]
   \   00000164   0xB289             UXTH     R1,R1
   \   00000166   0xF822 0x3011      STRH     R3,[R2, R1, LSL #+1]
   \   0000016A   0x1C49             ADDS     R1,R1,#+1
    898              }
    899          
    900          	if (Dyn_Packet == 1) // --> two loads
   \   0000016C   0xF8B8 0x2132      LDRH     R2,[R8, #+306]
   \   00000170   0x2A01             CMP      R2,#+1
   \   00000172   0xD14F             BNE.N    ??MakeInfoPacket_5
    901          	{
    902          		packet_len += 2+MINIMAL_INFO_WORDS*2; // add second load
    903          
    904          		*(buff_ptr+counter) = LEN_INFO;			// LENinfoL2 = 1(=DataTypeL2) + MINIMAL_INFO_WORDS (related to load L2)
   \   00000174   0x2211             MOVS     R2,#+17
   \   00000176   0xB289             UXTH     R1,R1
   \   00000178   0xF829 0x2011      STRH     R2,[R9, R1, LSL #+1]
    905          		counter++;
   \   0000017C   0x1C49             ADDS     R1,R1,#+1
    906          		*(buff_ptr+counter) = Command_Data_L2.Data_Type;	// DataTypeL2 coming from main_uC
   \   0000017E   0xF8B8 0x20F6      LDRH     R2,[R8, #+246]
   \   00000182   0xB289             UXTH     R1,R1
   \   00000184   0xF829 0x2011      STRH     R2,[R9, R1, LSL #+1]
    907          		counter++;
   \   00000188   0x1C49             ADDS     R1,R1,#+1
    908          
    909          		// Put zeros info related to not-driven load
    910          		for (i=0;i<MINIMAL_INFO_WORDS;i++)
   \   0000018A   0xEBA9 0x0000      SUB      R0,R9,R0
    911          		{
    912          			*(buff_ptr-k1+counter)= 0;
   \   0000018E   0x2200             MOVS     R2,#+0
   \   00000190   0xB289             UXTH     R1,R1
   \   00000192   0xF820 0x2011      STRH     R2,[R0, R1, LSL #+1]
    913          			counter++;
   \   00000196   0x1C49             ADDS     R1,R1,#+1
    914          			*(buff_ptr-k1+counter)= 0;
   \   00000198   0xB289             UXTH     R1,R1
   \   0000019A   0xF820 0x2011      STRH     R2,[R0, R1, LSL #+1]
    915          			counter++;
   \   0000019E   0x1C49             ADDS     R1,R1,#+1
   \   000001A0   0xB289             UXTH     R1,R1
   \   000001A2   0xF820 0x2011      STRH     R2,[R0, R1, LSL #+1]
   \   000001A6   0x1C49             ADDS     R1,R1,#+1
   \   000001A8   0xB289             UXTH     R1,R1
   \   000001AA   0xF820 0x2011      STRH     R2,[R0, R1, LSL #+1]
   \   000001AE   0x1C49             ADDS     R1,R1,#+1
   \   000001B0   0xB289             UXTH     R1,R1
   \   000001B2   0xF820 0x2011      STRH     R2,[R0, R1, LSL #+1]
   \   000001B6   0x1C49             ADDS     R1,R1,#+1
   \   000001B8   0xB289             UXTH     R1,R1
   \   000001BA   0xF820 0x2011      STRH     R2,[R0, R1, LSL #+1]
   \   000001BE   0x1C49             ADDS     R1,R1,#+1
   \   000001C0   0xB289             UXTH     R1,R1
   \   000001C2   0xF820 0x2011      STRH     R2,[R0, R1, LSL #+1]
   \   000001C6   0x1C49             ADDS     R1,R1,#+1
   \   000001C8   0xB289             UXTH     R1,R1
   \   000001CA   0xF820 0x2011      STRH     R2,[R0, R1, LSL #+1]
   \   000001CE   0x1C49             ADDS     R1,R1,#+1
   \   000001D0   0xB289             UXTH     R1,R1
   \   000001D2   0xF820 0x2011      STRH     R2,[R0, R1, LSL #+1]
   \   000001D6   0x1C49             ADDS     R1,R1,#+1
   \   000001D8   0xB289             UXTH     R1,R1
   \   000001DA   0xF820 0x2011      STRH     R2,[R0, R1, LSL #+1]
   \   000001DE   0x1C49             ADDS     R1,R1,#+1
   \   000001E0   0xB289             UXTH     R1,R1
   \   000001E2   0xF820 0x2011      STRH     R2,[R0, R1, LSL #+1]
   \   000001E6   0x1C49             ADDS     R1,R1,#+1
   \   000001E8   0xB289             UXTH     R1,R1
   \   000001EA   0xF820 0x2011      STRH     R2,[R0, R1, LSL #+1]
   \   000001EE   0x1C49             ADDS     R1,R1,#+1
   \   000001F0   0xB289             UXTH     R1,R1
   \   000001F2   0xF820 0x2011      STRH     R2,[R0, R1, LSL #+1]
   \   000001F6   0x1C49             ADDS     R1,R1,#+1
   \   000001F8   0xB289             UXTH     R1,R1
   \   000001FA   0xF820 0x2011      STRH     R2,[R0, R1, LSL #+1]
   \   000001FE   0x1C49             ADDS     R1,R1,#+1
   \   00000200   0xB289             UXTH     R1,R1
   \   00000202   0xF820 0x2011      STRH     R2,[R0, R1, LSL #+1]
   \   00000206   0x1C49             ADDS     R1,R1,#+1
   \   00000208   0xB289             UXTH     R1,R1
   \   0000020A   0xF820 0x2011      STRH     R2,[R0, R1, LSL #+1]
   \   0000020E   0x3712             ADDS     R7,R7,#+18
   \   00000210   0xB2BF             UXTH     R7,R7
   \   00000212   0x1C49             ADDS     R1,R1,#+1
    916          		}
    917          	}
    918          
    919              packet_len += 2+MINIMAL_COMMON_WORDS*2; // add common buffer
    920              // Put common info & datatype
    921              *(buff_ptr+counter) = LEN_COMMON;
   \                     ??MakeInfoPacket_5: (+1)
   \   00000214   0x2213             MOVS     R2,#+19
   \   00000216   0xB289             UXTH     R1,R1
   \   00000218   0xF829 0x2011      STRH     R2,[R9, R1, LSL #+1]
    922              counter++;
   \   0000021C   0x1C49             ADDS     R1,R1,#+1
    923              *(buff_ptr+counter) = DATA_TYPE_COMMON;
   \   0000021E   0x22FF             MOVS     R2,#+255
   \   00000220   0xB289             UXTH     R1,R1
   \   00000222   0xF829 0x2011      STRH     R2,[R9, R1, LSL #+1]
   \   00000226   0xF107 0x0014      ADD      R0,R7,#+20
    924              counter++;
   \   0000022A   0x1C4B             ADDS     R3,R1,#+1
   \   0000022C   0xB280             UXTH     R0,R0
    925          
    926              // Put minimal info
    927              for (i=0;i<MINIMAL_COMMON_WORDS;i++)
   \   0000022E   0xF105 0x0110      ADD      R1,R5,#+16
   \   00000232   0x2203             MOVS     R2,#+3
    928              {
    929                  *(buff_ptr+counter)= (((uint16*)protocol_info)[i + MINIMAL_INFO_WORDS]) >> 8;
   \                     ??MakeInfoPacket_6: (+1)
   \   00000234   0x880D             LDRH     R5,[R1, #+0]
   \   00000236   0x0A2D             LSRS     R5,R5,#+8
   \   00000238   0xB29B             UXTH     R3,R3
   \   0000023A   0xF829 0x5013      STRH     R5,[R9, R3, LSL #+1]
    930                  counter++;
   \   0000023E   0x1C5B             ADDS     R3,R3,#+1
    931                  *(buff_ptr+counter)= (((uint16*)protocol_info)[i + MINIMAL_INFO_WORDS]) & 0x00FF;
   \   00000240   0xF811 0x5B02      LDRB     R5,[R1], #+2
   \   00000244   0xB29B             UXTH     R3,R3
   \   00000246   0xF829 0x5013      STRH     R5,[R9, R3, LSL #+1]
    932                  counter++;
   \   0000024A   0x1C5B             ADDS     R3,R3,#+1
   \   0000024C   0x880D             LDRH     R5,[R1, #+0]
   \   0000024E   0x0A2D             LSRS     R5,R5,#+8
   \   00000250   0xB29B             UXTH     R3,R3
   \   00000252   0xF829 0x5013      STRH     R5,[R9, R3, LSL #+1]
   \   00000256   0x1C5B             ADDS     R3,R3,#+1
   \   00000258   0xF811 0x5B02      LDRB     R5,[R1], #+2
   \   0000025C   0xB29B             UXTH     R3,R3
   \   0000025E   0xF829 0x5013      STRH     R5,[R9, R3, LSL #+1]
   \   00000262   0x1C5B             ADDS     R3,R3,#+1
   \   00000264   0x880D             LDRH     R5,[R1, #+0]
   \   00000266   0x0A2D             LSRS     R5,R5,#+8
   \   00000268   0xB29B             UXTH     R3,R3
   \   0000026A   0xF829 0x5013      STRH     R5,[R9, R3, LSL #+1]
   \   0000026E   0x1C5B             ADDS     R3,R3,#+1
   \   00000270   0xF811 0x5B02      LDRB     R5,[R1], #+2
   \   00000274   0xB29B             UXTH     R3,R3
   \   00000276   0xF829 0x5013      STRH     R5,[R9, R3, LSL #+1]
   \   0000027A   0x1C5B             ADDS     R3,R3,#+1
    933              }
   \   0000027C   0x1E52             SUBS     R2,R2,#+1
   \   0000027E   0xD1D9             BNE.N    ??MakeInfoPacket_6
    934          
    935              // Write Packet Len
    936              *(buffer+INFO_PACKET_SEND_LENGTH) = packet_len;
   \   00000280   0x8120             STRH     R0,[R4, #+8]
    937          
    938              counter = counter+2; // CRC Size
    939          
    940              return ((INFO_PACKET_SEND_SEQUENCE_ID+counter));
   \   00000282   0x1DD8             ADDS     R0,R3,#+7
   \   00000284   0xB280             UXTH     R0,R0
   \   00000286   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    941          }
    942          
    943          
    944          
    945          
    946          
    947          //---------------------------------------------------------------------------------------------------------------------
    948          /**
    949           *  @brief      Master communication
    950           *
    951           *  @ref        MOD_SMI_3
    952           *
    953           *  @return     Communication state
    954           */

   \                                 In section .text, align 4, keep-with-next
    955          MASTER_COMMUNICATION_RETURNS_E_TYPE Rs232MasterCommunication()
    956          {
   \                     Rs232MasterCommunication: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    957              MASTER_COMMUNICATION_RETURNS_E_TYPE comm_state;
    958              uint8 rx_byte;
    959          
    960              comm_state = MASTER_COMMUNICATION_STANDBY;
    961          
    962              if (Bytes_To_Transmit)
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable6
   \   00000006   0xF8B4 0x0106      LDRH     R0,[R4, #+262]
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0xB081             SUB      SP,SP,#+4
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xF000 0x80A1      BEQ.W    ??Rs232MasterCommunication_2
    963              {
    964                  comm_state = MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS;
   \   00000014   0x2502             MOVS     R5,#+2
    965          
    966                  // Transmission in process
    967                  if (IsTxReady())
   \   00000016   0x2102             MOVS     R1,#+2
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      BL       Uart__GetStatus
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xF8B4 0x012A      LDRH     R0,[R4, #+298]
   \   00000024   0xBF18             IT       NE 
   \   00000026   0xF8A4 0x0114      STRHNE   R0,[R4, #+276]
   \   0000002A   0xF040 0x85B4      BNE.W    ??Rs232MasterCommunication_3
   \   0000002E   0xF8B4 0x1114      LDRH     R1,[R4, #+276]
   \   00000032   0x1A40             SUBS     R0,R0,R1
   \   00000034   0xB280             UXTH     R0,R0
   \   00000036   0x2808             CMP      R0,#+8
   \   00000038   0xF2C0 0x85AD      BLT.W    ??Rs232MasterCommunication_3
    968                  {
    969                      if(Master_Comm_Flags == INFO)
   \   0000003C   0xF9B4 0x0104      LDRSH    R0,[R4, #+260]
   \   00000040   0xF8B4 0x110A      LDRH     R1,[R4, #+266]
   \   00000044   0x2801             CMP      R0,#+1
   \   00000046   0xD14A             BNE.N    ??Rs232MasterCommunication_4
    970                      {
    971                          if(Bytes_Transmitted == 0)
   \   00000048   0xB919             CBNZ.N   R1,??Rs232MasterCommunication_5
    972                          {
    973                              Calculated_Info_Crc = CRC_INIT_VALUE;
   \   0000004A   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000004E   0xF8A4 0x0124      STRH     R0,[R4, #+292]
   \                     ??Rs232MasterCommunication_5: (+1)
   \   00000052   0xEB04 0x0241      ADD      R2,R4,R1, LSL #+1
   \   00000056   0xF8B4 0x0106      LDRH     R0,[R4, #+262]
   \   0000005A   0xF8B4 0x3124      LDRH     R3,[R4, #+292]
   \   0000005E   0x2802             CMP      R0,#+2
   \   00000060   0xD106             BNE.N    ??Rs232MasterCommunication_6
    974                          }
    975          
    976                          // Crc Info Packet
    977                          if(Bytes_To_Transmit == 2)
    978                          {
    979                              Send_Buffer[Bytes_Transmitted] = Calculated_Info_Crc >> 8;
   \   00000062   0x0A18             LSRS     R0,R3,#+8
   \   00000064   0xF8A2 0x0048      STRH     R0,[R2, #+72]
    980                              Send_Buffer[Bytes_Transmitted+1] = (Calculated_Info_Crc & 0x00FF);
   \   00000068   0xB2D8             UXTB     R0,R3
   \   0000006A   0xF8A2 0x004A      STRH     R0,[R2, #+74]
   \   0000006E   0xE036             B.N      ??Rs232MasterCommunication_4
    981                          }
    982                          else
    983                          {
    984                              Calculated_Info_Crc = CalcCrc1(Calculated_Info_Crc, (uint8)Send_Buffer[Bytes_Transmitted]);
   \                     ??Rs232MasterCommunication_6: (+1)
   \   00000070   0xF241 0x0021      MOVW     R0,#+4129
   \   00000074   0xF892 0x2048      LDRB     R2,[R2, #+72]
   \   00000078   0xEA83 0x2202      EOR      R2,R3,R2, LSL #+8
   \   0000007C   0x0052             LSLS     R2,R2,#+1
   \   0000007E   0xF5B2 0x3F80      CMP      R2,#+65536
   \   00000082   0xBF28             IT       CS 
   \   00000084   0x4042             EORCS    R2,R0,R2
   \   00000086   0x0412             LSLS     R2,R2,#+16
   \   00000088   0x0BD2             LSRS     R2,R2,#+15
   \   0000008A   0xF5B2 0x3F80      CMP      R2,#+65536
   \   0000008E   0xBF28             IT       CS 
   \   00000090   0x4042             EORCS    R2,R0,R2
   \   00000092   0x0412             LSLS     R2,R2,#+16
   \   00000094   0x0BD2             LSRS     R2,R2,#+15
   \   00000096   0xF5B2 0x3F80      CMP      R2,#+65536
   \   0000009A   0xBF28             IT       CS 
   \   0000009C   0x4042             EORCS    R2,R0,R2
   \   0000009E   0x0412             LSLS     R2,R2,#+16
   \   000000A0   0x0BD2             LSRS     R2,R2,#+15
   \   000000A2   0xF5B2 0x3F80      CMP      R2,#+65536
   \   000000A6   0xBF28             IT       CS 
   \   000000A8   0x4042             EORCS    R2,R0,R2
   \   000000AA   0x0412             LSLS     R2,R2,#+16
   \   000000AC   0x0BD2             LSRS     R2,R2,#+15
   \   000000AE   0xF5B2 0x3F80      CMP      R2,#+65536
   \   000000B2   0xBF28             IT       CS 
   \   000000B4   0x4042             EORCS    R2,R0,R2
   \   000000B6   0x0412             LSLS     R2,R2,#+16
   \   000000B8   0x0BD2             LSRS     R2,R2,#+15
   \   000000BA   0xF5B2 0x3F80      CMP      R2,#+65536
   \   000000BE   0xBF28             IT       CS 
   \   000000C0   0x4042             EORCS    R2,R0,R2
   \   000000C2   0x0412             LSLS     R2,R2,#+16
   \   000000C4   0x0BD2             LSRS     R2,R2,#+15
   \   000000C6   0xF5B2 0x3F80      CMP      R2,#+65536
   \   000000CA   0xBF28             IT       CS 
   \   000000CC   0x4042             EORCS    R2,R0,R2
   \   000000CE   0x0412             LSLS     R2,R2,#+16
   \   000000D0   0x0BD2             LSRS     R2,R2,#+15
   \   000000D2   0xF5B2 0x3F80      CMP      R2,#+65536
   \   000000D6   0xBF28             IT       CS 
   \   000000D8   0x4042             EORCS    R2,R0,R2
    985                          }
    986                      }
   \   000000DA   0xF8A4 0x2124      STRH     R2,[R4, #+292]
    987                      Uart__WriteByte(PROTOCOLMAINEXTERNAL_COMPORT, ((uint8)Send_Buffer[Bytes_Transmitted++]));
   \                     ??Rs232MasterCommunication_4: (+1)
   \   000000DE   0x1C48             ADDS     R0,R1,#+1
   \   000000E0   0xF8A4 0x010A      STRH     R0,[R4, #+266]
   \   000000E4   0xEB04 0x0041      ADD      R0,R4,R1, LSL #+1
   \   000000E8   0xF8B0 0x1048      LDRH     R1,[R0, #+72]
   \   000000EC   0xB2C9             UXTB     R1,R1
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x.... 0x....      BL       Uart__WriteByte
   \   000000F4   0xF8B4 0x0106      LDRH     R0,[R4, #+262]
   \   000000F8   0x1E40             SUBS     R0,R0,#+1
   \   000000FA   0xF8A4 0x0106      STRH     R0,[R4, #+262]
   \   000000FE   0xB280             UXTH     R0,R0
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xF040 0x8548      BNE.W    ??Rs232MasterCommunication_3
    988          
    989                      if (!(--Bytes_To_Transmit))
    990                      {
    991                          // Transmission finished
    992                          Bytes_Transmitted=0;
   \   00000106   0xF8A4 0x010A      STRH     R0,[R4, #+266]
    993                          Bytes_Received=0;
   \   0000010A   0xF8A4 0x010C      STRH     R0,[R4, #+268]
    994                          Receive_State_Machine=WAIT_FOR_ACK;
   \   0000010E   0xF8A4 0x010E      STRH     R0,[R4, #+270]
    995                          Receive_Time_Mark=Com_Timer_Cnt;
    996                          // Clear SCI Input data register
    997                          if (Uart__GetStatus(PROTOCOLMAINEXTERNAL_COMPORT, UART_STATUS_RX_AVAILABLE) > 0)
   \   00000112   0x2104             MOVS     R1,#+4
   \   00000114   0xF8B4 0x012A      LDRH     R0,[R4, #+298]
   \   00000118   0xF8A4 0x0112      STRH     R0,[R4, #+274]
   \   0000011C   0x2000             MOVS     R0,#+0
   \   0000011E   0x.... 0x....      BL       Uart__GetStatus
   \   00000122   0xB110             CBZ.N    R0,??Rs232MasterCommunication_7
    998                          {
    999                              Uart__ReadByte(PROTOCOLMAINEXTERNAL_COMPORT);
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0x.... 0x....      BL       Uart__ReadByte
   1000                          }
   1001          
   1002                          //------------------------------------------------------------------------------
   1003          
   1004                          if (Master_Comm_Flags == TOKEN)
   \                     ??Rs232MasterCommunication_7: (+1)
   \   0000012A   0xF9B4 0x0104      LDRSH    R0,[R4, #+260]
   \   0000012E   0xB950             CBNZ.N   R0,??Rs232MasterCommunication_8
   1005                          {
   1006                              if (Com_Safety_Flags == 0x000F)
   \   00000130   0xF8B4 0x011C      LDRH     R0,[R4, #+284]
   \   00000134   0x280F             CMP      R0,#+15
   \   00000136   0xD102             BNE.N    ??Rs232MasterCommunication_9
   \   00000138   0x2007             MOVS     R0,#+7
   \                     ??Rs232MasterCommunication_10: (+1)
   \   0000013A   0xF8A4 0x011C      STRH     R0,[R4, #+284]
   1007                              { // if Transmitted TOKEN after ACK
   1008                                  Com_Safety_Flags = 0x0007;
   1009                              }
   1010          
   1011                          }
   1012                          if (Master_Comm_Flags == INFO)
   1013                          {
   1014                              if (Com_Safety_Flags == 0x0003)
   1015                              { // if Transmitted INFO after ACK
   1016                                  Com_Safety_Flags = 0x0001;
   1017                              }
   1018                          }
   1019          
   1020                          comm_state = MASTER_COMMUNICATION_RECEIVING_IN_PROCESS;
   1021                      }
   1022                  }
   1023              }
   1024              else if (Bytes_To_Receive)
   1025              {
   1026                  // Reception in process
   1027                  if ((uint16)(Com_Timer_Cnt - Receive_Time_Mark)>RECEIVE_BYTE_TIMEOUT)
   1028                  {// Byte Timeout Fail
   1029                      comm_state = (CheckResendPacket(2));
   1030                  }
   1031                  else if (Uart__GetStatus(PROTOCOLMAINEXTERNAL_COMPORT, UART_STATUS_RX_AVAILABLE) > 0)
   1032                  {
   1033                      rx_byte = Uart__ReadByte(PROTOCOLMAINEXTERNAL_COMPORT);
   1034                      Receive_Time_Mark=Com_Timer_Cnt;
   1035          
   1036                      switch (Master_Comm_Flags)
   1037                      {
   1038          
   1039          #ifndef MOTOR_SBPM_FLOAT
   1040          
   1041                          case SAFETYDATA:
   1042                              Set_File_Table = (uint16 *)Params__GetSFSafe();
   1043                              Table_Size = Params__SizeOfSFSafe();
   1044                              Min_Params_Num = MINIMUM_SAFETY_PARAMS_NUM;
   1045                              break;
   1046          
   1047                          case TRIPHASEDATA_1:
   1048                              Set_File_Table = (uint16 *)Params__GetSFApp();
   1049                              Table_Size = MINIMUM_APPLICATION_1_PARAMS_NUM;
   1050                              Min_Params_Num = MINIMUM_APPLICATION_1_PARAMS_NUM;
   1051                              break;
   1052          
   1053                          case TRIPHASEDATA_2:
   1054                              Set_File_Table = (uint16 *)Params__GetSFApp()+(MINIMUM_APPLICATION_1_PARAMS_NUM/2);
   1055                              Table_Size = MINIMUM_APPLICATION_2_PARAMS_NUM;
   1056                              Min_Params_Num = MINIMUM_APPLICATION_2_PARAMS_NUM;
   1057                              break;
   1058          
   1059                          case TRIPHASEDATA:
   1060                              Set_File_Table = (uint16 *)Params__GetSFApp();
   1061                              Table_Size = MINIMUM_APPLICATION_PARAMS_NUM;
   1062                              Min_Params_Num = MINIMUM_APPLICATION_PARAMS_NUM;
   1063                              break;
   1064          
   1065                          case MODULEDATA:
   1066                              Set_File_Table = (uint16 *)Params__GetSFModule();
   1067                              Table_Size = MINIMUM_MODULES_PARAMS_NUM;
   1068                              Min_Params_Num = MINIMUM_MODULES_PARAMS_NUM;
   1069                              break;
   1070          
   1071                          case MLIMITDATA:
   1072                              Set_File_Table = (uint16 *)Params__GetSFMLimit();
   1073                              Table_Size = MINIMUM_MLIMIT_PARAMS_NUM;
   1074                              Min_Params_Num = MINIMUM_MLIMIT_PARAMS_NUM;
   1075                              break;
   1076          
   1077                          case MCISAFETYDATA:
   1078          					 Set_File_Table = (uint16 *)(&SafetyParamsBuffer[0]);
   1079          					 Table_Size = MINIMUM_MCISAFETY_PARAMS_NUM;
   1080          					 Min_Params_Num = MINIMUM_MCISAFETY_PARAMS_NUM;
   1081          					 break;
   1082          #else
   1083          
   1084                          case SBPM_FLOAT_DTC_CONTROL_1:
   1085                              Set_File_Table = Mci_ClassA_Dtc;
   1086                              Table_Size = 0xFF;
   1087                              Min_Params_Num = 0xFF;
   1088                              break;
   1089          
   1090                          case SBPM_FLOAT_DTC_CONTROL_2:
   1091                              Set_File_Table = Mci_ClassA_Dtc + 0xFF;
   1092                              Table_Size = sizeof(Mci_ClassA_Dtc)-0xFF;
   1093                              Min_Params_Num = sizeof(Mci_ClassA_Dtc)-0xFF;
   1094                              break;
   1095          
   1096                          case SBPM_FLOAT_MOTOR_LUT:
   1097                              Set_File_Table = Mci_ClassA_Motor_Lut;
   1098                              Table_Size = sizeof(Mci_ClassA_Motor_Lut);
   1099                              Min_Params_Num = sizeof(Mci_ClassA_Motor_Lut);
   1100                              break;
   1101          
   1102                          case SBPM_FLOAT_SPEED_CTRL:
   1103                              Set_File_Table = Mci_ClassA_Speed_Ctrl;
   1104                              Table_Size = sizeof(Mci_ClassA_Speed_Ctrl);
   1105                              Min_Params_Num = sizeof(Mci_ClassA_Speed_Ctrl);
   1106                              break;
   1107          
   1108                          case SBPM_FLOAT_MTPA_LUT:
   1109                              Set_File_Table = Mci_ClassA_Mtpa;
   1110                              Table_Size = sizeof(Mci_ClassA_Mtpa);
   1111                              Min_Params_Num = sizeof(Mci_ClassA_Mtpa);
   1112                              break;
   1113          
   1114                          case SBPM_FLOAT_MTPV_LUT:
   1115                              Set_File_Table = Mci_ClassA_Mtpv;
   1116                              Table_Size = sizeof(Mci_ClassA_Mtpv);
   1117                              Min_Params_Num =  sizeof(Mci_ClassA_Mtpv);
   1118                              break;
   1119          
   1120                          case SBPM_FLOAT_OTE:
   1121                              Set_File_Table = Mci_ClassA_Ote;
   1122                              Table_Size = sizeof(Mci_ClassA_Ote);
   1123                              Min_Params_Num =  sizeof(Mci_ClassA_Ote);
   1124                              break;
   1125          
   1126                           case SBPM_FLOAT_SR_MOTOR:
   1127                              Set_File_Table = Mci_ClassB_Prm;
   1128                              Table_Size = sizeof(Mci_ClassB_Prm);
   1129                              Min_Params_Num = sizeof(Mci_ClassB_Prm);
   1130                              break;
   1131          
   1132                           case SBPM_FLOAT_MCA_SET_WM:
   1133                              Set_File_Table = Mca_Set_Wm;
   1134                              Table_Size = sizeof(Mca_Set_Wm);
   1135                              Min_Params_Num = sizeof(Mca_Set_Wm);
   1136                              break;
   1137          
   1138                           case SBPM_FLOAT_MCA_SENSOR_WM:
   1139                              Set_File_Table = Mca_Sensor_Wm;
   1140                              Table_Size = sizeof(Mca_Sensor_Wm);
   1141                              Min_Params_Num = sizeof(Mca_Sensor_Wm);
   1142                              break;
   1143          #endif
   1144          
   1145          
   1146          
   1147                          default:
   1148                              break;
   1149                      }
   1150          
   1151                      switch (RxParser(rx_byte))
   1152                      {
   1153                          case PARSER_STATE_RECEIVING:
   1154                              comm_state = MASTER_COMMUNICATION_RECEIVING_IN_PROCESS;
   1155                              break;
   1156          
   1157                          case PARSER_STATE_ERROR:
   1158                              comm_state = CheckResendPacket(1);
   1159                              break;
   1160          
   1161                          case PARSER_STATE_COMPLETED:
   1162                              // Reception Completed
   1163                              CheckResendPacket(0);
   1164                              if (Com_Safety_Flags == 0)
   1165                              {
   1166                                  // reset Safety Flags
   1167                                  Com_Safety_Flags = 0x000F;
   1168                              }
   1169          
   1170                              if(Master_Comm_Flags==INFO)
   1171                              {
   1172                                  comm_state = MASTER_COMMUNICATION_NEW_COMMAND_READY;
   1173                              }
   1174                              else
   1175                              {
   1176                                  comm_state = MASTER_COMMUNICATION_NEW_PACKET_READY;
   1177                              }
   1178                              break;
   1179          
   1180                          default:
   1181                              break;
   1182                      }
   1183                  }
   1184                  else
   1185                  {
   1186                      comm_state = MASTER_COMMUNICATION_RECEIVING_IN_PROCESS;
   \                     ??Rs232MasterCommunication_9: (+1)
   \   0000013E   0x2501             MOVS     R5,#+1
   1187                  }
   1188              }
   1189              else if (Error_Delay == 0)  // wait delay before transmitting in case of error
   1190              {
   1191                  switch (Master_Comm_Flags)
   1192                  {
   1193                      case DISPLDATA:
   1194                          Bytes_To_Transmit=MakeReadSettingFileDataBlock(Send_Buffer, MAIN_POINTER, Motor_Displ, 0x0, 0x0);
   1195                          Bytes_To_Receive=TOKEN_PACKET_RECEIVE_MINIMUM_SIZE+2;
   1196                          comm_state = MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS;
   1197                          break;
   1198          
   1199          #ifndef MOTOR_SBPM_FLOAT
   1200                      case SAFETYDATA:
   1201                          Bytes_To_Transmit=MakeReadSettingFileDataBlock(Send_Buffer, IO_POINTER, (Params_Displ&0x00FF), 0x0, 0x0);
   1202                          Bytes_To_Receive=TOKEN_PACKET_RECEIVE_MINIMUM_SIZE+2;
   1203                          comm_state = MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS;
   1204                          break;
   1205          
   1206                      case TRIPHASEDATA_1:
   1207                          Bytes_To_Transmit=MakeReadSettingFileDataBlock(Send_Buffer, IO_POINTER, Params_Displ>>8, 0x0, MINIMUM_APPLICATION_1_PARAMS_NUM);
   1208                          Bytes_To_Receive=TOKEN_PACKET_RECEIVE_MINIMUM_SIZE+2;
   1209                          comm_state = MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS;
   1210                          break;
   1211          
   1212                      case TRIPHASEDATA_2:
   1213                          Bytes_To_Transmit=MakeReadSettingFileDataBlock(Send_Buffer, IO_POINTER, Params_Displ>>8, MINIMUM_APPLICATION_1_PARAMS_NUM, MINIMUM_APPLICATION_2_PARAMS_NUM);
   1214                          Bytes_To_Receive=TOKEN_PACKET_RECEIVE_MINIMUM_SIZE+2;
   1215                          comm_state = MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS;
   1216                          break;
   1217          
   1218          
   1219                      case TRIPHASEDATA:
   1220                          Bytes_To_Transmit=MakeReadSettingFileDataBlock(Send_Buffer, IO_POINTER, Params_Displ>>8, 0x0, 0x0);
   1221                          Bytes_To_Receive=TOKEN_PACKET_RECEIVE_MINIMUM_SIZE+2;
   1222                          comm_state = MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS;
   1223                          break;
   1224          
   1225                      case MODULEDATA:
   1226                          Bytes_To_Transmit=MakeReadSettingFileDataBlock(Send_Buffer, IO_POINTER, (Modules_Displ&0x00FF), 0x0, 0x0);
   1227                          Bytes_To_Receive=TOKEN_PACKET_RECEIVE_MINIMUM_SIZE+2;
   1228                          comm_state = MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS;
   1229                          break;
   1230          
   1231                      case MLIMITDATA:
   1232          				Bytes_To_Transmit=MakeReadSettingFileDataBlock(Send_Buffer, IO_POINTER, Params_Displ_2>>8, 0x0, 0x0);
   1233          				Bytes_To_Receive=TOKEN_PACKET_RECEIVE_MINIMUM_SIZE+2;
   1234          				comm_state = MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS;
   1235          				break;
   1236          
   1237                      case MCISAFETYDATA:
   1238          				Bytes_To_Transmit=MakeReadSettingFileDataBlock(Send_Buffer, IO_POINTER, (Params_Displ_2&0x00FF), 0x0, 0x0);
   1239          				Bytes_To_Receive=TOKEN_PACKET_RECEIVE_MINIMUM_SIZE+2;
   1240          				comm_state = MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS;
   1241          				break;
   1242          
   1243          
   1244          #else //sBPM Floating
   1245          
   1246                      case SBPM_FLOAT_DTC_CONTROL_1:
   1247                          Bytes_To_Transmit=MakeReadSettingFileDataBlock(Send_Buffer, IO_POINTER, (uint16)Prm_Displ_DTC_Ctrl, 0x0, 0xFF);
   1248                          Bytes_To_Receive=TOKEN_PACKET_RECEIVE_MINIMUM_SIZE+2;
   1249                          comm_state = MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS;
   1250                          break;
   1251          
   1252                      case SBPM_FLOAT_DTC_CONTROL_2:
   1253                          Bytes_To_Transmit=MakeReadSettingFileDataBlock(Send_Buffer, IO_POINTER, (uint16)Prm_Displ_DTC_Ctrl, 0xFF, sizeof(Mci_ClassA_Dtc)-0xFF);
   1254                          Bytes_To_Receive=TOKEN_PACKET_RECEIVE_MINIMUM_SIZE+2;
   1255                          comm_state = MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS;
   1256                          break;
   1257          
   1258                      case SBPM_FLOAT_MOTOR_LUT:
   1259                          Bytes_To_Transmit=MakeReadSettingFileDataBlock(Send_Buffer, IO_POINTER, (uint16)Prm_Displ_Motor_Lut, 0x0, 0x0);
   1260                          Bytes_To_Receive=TOKEN_PACKET_RECEIVE_MINIMUM_SIZE+2;
   1261                          comm_state = MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS;
   1262                          break;
   1263          
   1264                      case SBPM_FLOAT_SPEED_CTRL:
   1265                          Bytes_To_Transmit=MakeReadSettingFileDataBlock(Send_Buffer, IO_POINTER, (uint16)Prm_Displ_Speed_Ctrl, 0x0, 0x0);
   1266                          Bytes_To_Receive=TOKEN_PACKET_RECEIVE_MINIMUM_SIZE+2;
   1267                          comm_state = MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS;
   1268                          break;
   1269          
   1270          
   1271                      case SBPM_FLOAT_MTPA_LUT:
   1272                          Bytes_To_Transmit=MakeReadSettingFileDataBlock(Send_Buffer, IO_POINTER, (uint16)Prm_Displ_MTPA, 0x0, 0x0);
   1273                          Bytes_To_Receive=TOKEN_PACKET_RECEIVE_MINIMUM_SIZE+2;
   1274                          comm_state = MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS;
   1275                          break;
   1276          
   1277                      case SBPM_FLOAT_MTPV_LUT:
   1278                          Bytes_To_Transmit=MakeReadSettingFileDataBlock(Send_Buffer, IO_POINTER, (uint16)Prm_Displ_MTPV, 0x0, 0x0);
   1279                          Bytes_To_Receive=TOKEN_PACKET_RECEIVE_MINIMUM_SIZE+2;
   1280                          comm_state = MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS;
   1281                          break;
   1282          
   1283                      case SBPM_FLOAT_OTE:
   1284                          Bytes_To_Transmit=MakeReadSettingFileDataBlock(Send_Buffer, IO_POINTER, (uint16)Prm_Displ_OTE, 0x0, 0x0);
   1285                          Bytes_To_Receive=TOKEN_PACKET_RECEIVE_MINIMUM_SIZE+2;
   1286                          comm_state = MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS;
   1287                          break;
   1288          
   1289                      case SBPM_FLOAT_SR_MOTOR:
   1290                          Bytes_To_Transmit=MakeReadSettingFileDataBlock(Send_Buffer, IO_POINTER, (uint16)Prm_Displ_SR, 0x0, 0x0);
   1291                          Bytes_To_Receive=TOKEN_PACKET_RECEIVE_MINIMUM_SIZE+2;
   1292                          comm_state = MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS;
   1293                          break;
   1294          
   1295                      case SBPM_FLOAT_MCA_SET_WM:
   1296                          Bytes_To_Transmit=MakeReadSettingFileDataBlock(Send_Buffer, IO_POINTER, (uint16)Prm_Displ_Set_Wm, 0x0, 0x0);
   1297                          Bytes_To_Receive=TOKEN_PACKET_RECEIVE_MINIMUM_SIZE+2;
   1298                          comm_state = MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS;
   1299                          break;
   1300          
   1301                      case SBPM_FLOAT_MCA_SENSOR_WM:
   1302                          Bytes_To_Transmit=MakeReadSettingFileDataBlock(Send_Buffer, IO_POINTER, (uint16)Prm_Displ_Sensor_Wm, 0x0, 0x0);
   1303                          Bytes_To_Receive=TOKEN_PACKET_RECEIVE_MINIMUM_SIZE+2;
   1304                          comm_state = MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS;
   1305                          break;
   1306          
   1307          #endif
   1308          
   1309                      case SETTINGFILELOADED:
   1310                          //SYSTEM_RESET();
   1311          
   1312          
   1313          				#if (APPLIANCE_TYPE == APPLIANCE_TYPE_DISHWASHER)
   1314                      	InitPumps();
   1315          				#else
   1316          
   1317          //				// setting File Parameters reading finished
   1318          				#ifndef INTERNAL_PARAMS
   1319                      	// send the ID   -- Class A: copying from Flash to RAM
   1320          				MciSetWm__Initialize();
   1321          				MciSensorsWm__Initialize();
   1322          				CommandManager__Initialize();
   1323          				Params__Initialize();
   1324          				#endif
   1325          
   1326          				//SRMotorSafetyInfoParamsMgr__SetParams(&SafetyParamsBuffer[1]);
   1327          
   1328          				Params__SetReady(TRUE);
   1329          				ProtocolInitialization(TOKEN);  // initialization of Communication Protocol lint !e641
   1330          			    Com_Timer_Cnt+=Com_Request_Interval;    // to immediately start communication
   1331          				#endif
   1332          
   1333          
   1334          
   1335          
   1336                          break; // lint !e527
   1337          
   1338                      case TOKEN:
   1339                          if ((uint16)(Com_Timer_Cnt - Token_Time_Mark)>Com_Request_Interval)
   1340                          {
   1341                              // Prepare token request packet
   1342                              Bytes_To_Transmit=MakeTokenPacket(Send_Buffer);
   1343                              Bytes_To_Receive=TOKEN_PACKET_RECEIVE_MINIMUM_SIZE+2;        // +2 because the minimum size should also consider 16 BIT CRC
   1344                              Token_Time_Mark=Com_Timer_Cnt;
   1345                              comm_state = MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS;
   1346                          }
   1347                          else
   1348                          {
   1349                              comm_state = MASTER_COMMUNICATION_STANDBY;
   1350                          }
   1351                          break;
   1352          
   1353                      case INFO:
   1354                          Bytes_To_Transmit=MakeInfoPacket(Send_Buffer);
   1355                          Bytes_To_Receive=INFO_PACKET_RECEIVE_SIZE;
   1356                          comm_state = MASTER_COMMUNICATION_TRANSMITTING_IN_PROCESS;
   1357                          break;
   1358          
   1359                      default:
   1360                          comm_state = MASTER_COMMUNICATION_STANDBY;
   1361                          break;
   1362                  }
   1363              }
   1364              else
   1365              {   // wait delay before transmitting in case of error
   1366                  comm_state = MASTER_COMMUNICATION_STANDBY;
   1367              }
   1368          
   1369              return comm_state;
   \   00000140   0x4628             MOV      R0,R5
   \   00000142   0xB001             ADD      SP,SP,#+4
   \   00000144   0xBD30             POP      {R4,R5,PC}
   \                     ??Rs232MasterCommunication_8: (+1)
   \   00000146   0x2801             CMP      R0,#+1
   \   00000148   0xBF04             ITT      EQ 
   \   0000014A   0xF8B4 0x011C      LDRHEQ   R0,[R4, #+284]
   \   0000014E   0x2803             CMPEQ    R0,#+3
   \   00000150   0xD1F5             BNE.N    ??Rs232MasterCommunication_9
   \   00000152   0x2001             MOVS     R0,#+1
   \   00000154   0xE7F1             B.N      ??Rs232MasterCommunication_10
   \                     ??Rs232MasterCommunication_2: (+1)
   \   00000156   0xF8B4 0x0108      LDRH     R0,[R4, #+264]
   \   0000015A   0x2800             CMP      R0,#+0
   \   0000015C   0xF000 0x8085      BEQ.W    ??Rs232MasterCommunication_11
   \   00000160   0xF8B4 0x012A      LDRH     R0,[R4, #+298]
   \   00000164   0xF8B4 0x1112      LDRH     R1,[R4, #+274]
   \   00000168   0x1A40             SUBS     R0,R0,R1
   \   0000016A   0xB280             UXTH     R0,R0
   \   0000016C   0xF5B0 0x7F48      CMP      R0,#+800
   \   00000170   0xBFC8             IT       GT 
   \   00000172   0x2002             MOVGT    R0,#+2
   \   00000174   0xDC61             BGT.N    ??Rs232MasterCommunication_12
   \   00000176   0x2104             MOVS     R1,#+4
   \   00000178   0x2000             MOVS     R0,#+0
   \   0000017A   0x.... 0x....      BL       Uart__GetStatus
   \   0000017E   0x2800             CMP      R0,#+0
   \   00000180   0xD0DD             BEQ.N    ??Rs232MasterCommunication_9
   \   00000182   0x2000             MOVS     R0,#+0
   \   00000184   0x.... 0x....      BL       Uart__ReadByte
   \   00000188   0xF8B4 0x112A      LDRH     R1,[R4, #+298]
   \   0000018C   0xF8A4 0x1112      STRH     R1,[R4, #+274]
   \   00000190   0xF9B4 0x1104      LDRSH    R1,[R4, #+260]
   \   00000194   0x390B             SUBS     R1,R1,#+11
   \   00000196   0x2909             CMP      R1,#+9
   \   00000198   0xD845             BHI.N    ??Rs232MasterCommunication_13
   \   0000019A   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??Rs232MasterCommunication_0:
   \   0000019E   0x05 0x0B          DC8      0x5,0xB,0x11,0x17
   \              0x11 0x17    
   \   000001A2   0x1D 0x23          DC8      0x1D,0x23,0x29,0x2F
   \              0x29 0x2F    
   \   000001A6   0x35 0x3B          DC8      0x35,0x3B
   \                     ??Rs232MasterCommunication_14: (+1)
   \   000001A8   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   000001AC   0xF8C4 0x1140      STR      R1,[R4, #+320]
   \   000001B0   0x21FF             MOVS     R1,#+255
   \   000001B2   0xE034             B.N      ??Rs232MasterCommunication_15
   \                     ??Rs232MasterCommunication_16: (+1)
   \   000001B4   0x.... 0x....      LDR.W    R1,??DataTable6_2
   \   000001B8   0xF8C4 0x1140      STR      R1,[R4, #+320]
   \   000001BC   0x21B5             MOVS     R1,#+181
   \   000001BE   0xE02E             B.N      ??Rs232MasterCommunication_15
   \                     ??Rs232MasterCommunication_17: (+1)
   \   000001C0   0x.... 0x....      LDR.W    R1,??DataTable6_3
   \   000001C4   0xF8C4 0x1140      STR      R1,[R4, #+320]
   \   000001C8   0x21C8             MOVS     R1,#+200
   \   000001CA   0xE028             B.N      ??Rs232MasterCommunication_15
   \                     ??Rs232MasterCommunication_18: (+1)
   \   000001CC   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \   000001D0   0xF8C4 0x1140      STR      R1,[R4, #+320]
   \   000001D4   0x2168             MOVS     R1,#+104
   \   000001D6   0xE022             B.N      ??Rs232MasterCommunication_15
   \                     ??Rs232MasterCommunication_19: (+1)
   \   000001D8   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \   000001DC   0xF8C4 0x1140      STR      R1,[R4, #+320]
   \   000001E0   0x2188             MOVS     R1,#+136
   \   000001E2   0xE01C             B.N      ??Rs232MasterCommunication_15
   \                     ??Rs232MasterCommunication_20: (+1)
   \   000001E4   0x.... 0x....      LDR.W    R1,??DataTable6_6
   \   000001E8   0xF8C4 0x1140      STR      R1,[R4, #+320]
   \   000001EC   0x2188             MOVS     R1,#+136
   \   000001EE   0xE016             B.N      ??Rs232MasterCommunication_15
   \                     ??Rs232MasterCommunication_21: (+1)
   \   000001F0   0x.... 0x....      LDR.W    R1,??DataTable6_7
   \   000001F4   0xF8C4 0x1140      STR      R1,[R4, #+320]
   \   000001F8   0x21CC             MOVS     R1,#+204
   \   000001FA   0xE010             B.N      ??Rs232MasterCommunication_15
   \                     ??Rs232MasterCommunication_22: (+1)
   \   000001FC   0x.... 0x....      LDR.W    R1,??DataTable6_8
   \   00000200   0xF8C4 0x1140      STR      R1,[R4, #+320]
   \   00000204   0x2134             MOVS     R1,#+52
   \   00000206   0xE00A             B.N      ??Rs232MasterCommunication_15
   \                     ??Rs232MasterCommunication_23: (+1)
   \   00000208   0x.... 0x....      LDR.W    R1,??DataTable6_9
   \   0000020C   0xF8C4 0x1140      STR      R1,[R4, #+320]
   \   00000210   0x218C             MOVS     R1,#+140
   \   00000212   0xE004             B.N      ??Rs232MasterCommunication_15
   \                     ??Rs232MasterCommunication_24: (+1)
   \   00000214   0x.... 0x....      LDR.W    R1,??DataTable7
   \   00000218   0xF8C4 0x1140      STR      R1,[R4, #+320]
   \   0000021C   0x210C             MOVS     R1,#+12
   \                     ??Rs232MasterCommunication_15: (+1)
   \   0000021E   0xF8A4 0x1128      STRH     R1,[R4, #+296]
   \   00000222   0xF8A4 0x111E      STRH     R1,[R4, #+286]
   \                     ??Rs232MasterCommunication_13: (+1)
   \   00000226   0x.... 0x....      BL       RxParser
   \   0000022A   0x2800             CMP      R0,#+0
   \   0000022C   0xF43F 0xAF87      BEQ.W    ??Rs232MasterCommunication_9
   \   00000230   0x2802             CMP      R0,#+2
   \   00000232   0xD008             BEQ.N    ??Rs232MasterCommunication_25
   \   00000234   0xF080 0x84AF      BCS.W    ??Rs232MasterCommunication_3
   \   00000238   0x2001             MOVS     R0,#+1
   \                     ??Rs232MasterCommunication_12: (+1)
   \   0000023A   0x.... 0x....      BL       CheckResendPacket
   \   0000023E   0x4605             MOV      R5,R0
   \   00000240   0x4628             MOV      R0,R5
   \   00000242   0xB001             ADD      SP,SP,#+4
   \   00000244   0xBD30             POP      {R4,R5,PC}
   \                     ??Rs232MasterCommunication_25: (+1)
   \   00000246   0x2000             MOVS     R0,#+0
   \   00000248   0x.... 0x....      BL       CheckResendPacket
   \   0000024C   0xF8B4 0x011C      LDRH     R0,[R4, #+284]
   \   00000250   0xB910             CBNZ.N   R0,??Rs232MasterCommunication_26
   \   00000252   0x200F             MOVS     R0,#+15
   \   00000254   0xF8A4 0x011C      STRH     R0,[R4, #+284]
   \                     ??Rs232MasterCommunication_26: (+1)
   \   00000258   0xF9B4 0x0104      LDRSH    R0,[R4, #+260]
   \   0000025C   0x2801             CMP      R0,#+1
   \   0000025E   0xBF14             ITE      NE 
   \   00000260   0x2503             MOVNE    R5,#+3
   \   00000262   0x2504             MOVEQ    R5,#+4
   \   00000264   0x4628             MOV      R0,R5
   \   00000266   0xB001             ADD      SP,SP,#+4
   \   00000268   0xBD30             POP      {R4,R5,PC}
   \                     ??Rs232MasterCommunication_11: (+1)
   \   0000026A   0xF8B4 0x0130      LDRH     R0,[R4, #+304]
   \   0000026E   0x2800             CMP      R0,#+0
   \   00000270   0xF040 0x8491      BNE.W    ??Rs232MasterCommunication_3
   \   00000274   0xF9B4 0x1104      LDRSH    R1,[R4, #+260]
   \   00000278   0xF241 0x0021      MOVW     R0,#+4129
   \   0000027C   0x2914             CMP      R1,#+20
   \   0000027E   0xF200 0x848A      BHI.W    ??Rs232MasterCommunication_3
   \   00000282   0xE8DF 0xF011      TBH      [PC, R1, LSL #+1]
   \                     ??Rs232MasterCommunication_1:
   \   00000286   0x0454 0x047E      DC16     0x454,0x47E,0x43A,0x15
   \              0x043A 0x0015
   \   0000028E   0x0488 0x0488      DC16     0x488,0x488,0x488,0x488
   \              0x0488 0x0488
   \   00000296   0x0488 0x0488      DC16     0x488,0x488,0x488,0x75
   \              0x0488 0x0075
   \   0000029E   0x00DB 0x0142      DC16     0xDB,0x142,0x1A1,0x200
   \              0x01A1 0x0200
   \   000002A6   0x025F 0x02BE      DC16     0x25F,0x2BE,0x31D,0x37C
   \              0x031D 0x037C
   \   000002AE   0x03DB             DC16     0x3DB
   \                     ??Rs232MasterCommunication_27: (+1)
   \   000002B0   0x21A5             MOVS     R1,#+165
   \   000002B2   0xF8A4 0x1048      STRH     R1,[R4, #+72]
   \   000002B6   0xF64F 0x73FF      MOVW     R3,#+65535
   \   000002BA   0x21EE             MOVS     R1,#+238
   \   000002BC   0xF8A4 0x104A      STRH     R1,[R4, #+74]
   \   000002C0   0x2207             MOVS     R2,#+7
   \   000002C2   0x2101             MOVS     R1,#+1
   \   000002C4   0xF8A4 0x104C      STRH     R1,[R4, #+76]
   \   000002C8   0x214A             MOVS     R1,#+74
   \   000002CA   0xF8A4 0x104E      STRH     R1,[R4, #+78]
   \   000002CE   0x2102             MOVS     R1,#+2
   \   000002D0   0xF8A4 0x1050      STRH     R1,[R4, #+80]
   \   000002D4   0x2101             MOVS     R1,#+1
   \   000002D6   0xF8A4 0x1052      STRH     R1,[R4, #+82]
   \   000002DA   0xF8B4 0x112C      LDRH     R1,[R4, #+300]
   \   000002DE   0xF8A4 0x1054      STRH     R1,[R4, #+84]
   \   000002E2   0xF104 0x0148      ADD      R1,R4,#+72
   \                     ??Rs232MasterCommunication_28: (+1)
   \   000002E6   0x780D             LDRB     R5,[R1, #+0]
   \   000002E8   0xB29B             UXTH     R3,R3
   \   000002EA   0xEA83 0x2305      EOR      R3,R3,R5, LSL #+8
   \   000002EE   0x1E52             SUBS     R2,R2,#+1
   \   000002F0   0x005B             LSLS     R3,R3,#+1
   \   000002F2   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000002F6   0xBF28             IT       CS 
   \   000002F8   0x4043             EORCS    R3,R0,R3
   \   000002FA   0x041B             LSLS     R3,R3,#+16
   \   000002FC   0x0BDB             LSRS     R3,R3,#+15
   \   000002FE   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000302   0xBF28             IT       CS 
   \   00000304   0x4043             EORCS    R3,R0,R3
   \   00000306   0x041B             LSLS     R3,R3,#+16
   \   00000308   0x0BDB             LSRS     R3,R3,#+15
   \   0000030A   0xF5B3 0x3F80      CMP      R3,#+65536
   \   0000030E   0xBF28             IT       CS 
   \   00000310   0x4043             EORCS    R3,R0,R3
   \   00000312   0x041B             LSLS     R3,R3,#+16
   \   00000314   0x0BDB             LSRS     R3,R3,#+15
   \   00000316   0xF5B3 0x3F80      CMP      R3,#+65536
   \   0000031A   0xBF28             IT       CS 
   \   0000031C   0x4043             EORCS    R3,R0,R3
   \   0000031E   0x041B             LSLS     R3,R3,#+16
   \   00000320   0x0BDB             LSRS     R3,R3,#+15
   \   00000322   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000326   0xBF28             IT       CS 
   \   00000328   0x4043             EORCS    R3,R0,R3
   \   0000032A   0x041B             LSLS     R3,R3,#+16
   \   0000032C   0x0BDB             LSRS     R3,R3,#+15
   \   0000032E   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000332   0xBF28             IT       CS 
   \   00000334   0x4043             EORCS    R3,R0,R3
   \   00000336   0x041B             LSLS     R3,R3,#+16
   \   00000338   0x0BDB             LSRS     R3,R3,#+15
   \   0000033A   0xF5B3 0x3F80      CMP      R3,#+65536
   \   0000033E   0xBF28             IT       CS 
   \   00000340   0x4043             EORCS    R3,R0,R3
   \   00000342   0x041B             LSLS     R3,R3,#+16
   \   00000344   0x0BDB             LSRS     R3,R3,#+15
   \   00000346   0xF5B3 0x3F80      CMP      R3,#+65536
   \   0000034A   0xBF28             IT       CS 
   \   0000034C   0x4043             EORCS    R3,R0,R3
   \   0000034E   0x1C89             ADDS     R1,R1,#+2
   \   00000350   0x2A00             CMP      R2,#+0
   \   00000352   0xD1C8             BNE.N    ??Rs232MasterCommunication_28
   \   00000354   0xB29B             UXTH     R3,R3
   \   00000356   0x0418             LSLS     R0,R3,#+16
   \   00000358   0x0E00             LSRS     R0,R0,#+24
   \   0000035A   0xF8A4 0x0056      STRH     R0,[R4, #+86]
   \   0000035E   0xB2D8             UXTB     R0,R3
   \   00000360   0xF8A4 0x0058      STRH     R0,[R4, #+88]
   \   00000364   0x2009             MOVS     R0,#+9
   \   00000366   0xF8A4 0x0106      STRH     R0,[R4, #+262]
   \   0000036A   0x2008             MOVS     R0,#+8
   \   0000036C   0xF000 0xBC10      B.W      ??Rs232MasterCommunication_29
   \                     ??Rs232MasterCommunication_30: (+1)
   \   00000370   0x21A5             MOVS     R1,#+165
   \   00000372   0xF8A4 0x1048      STRH     R1,[R4, #+72]
   \   00000376   0xF8A4 0x5056      STRH     R5,[R4, #+86]
   \   0000037A   0x21EE             MOVS     R1,#+238
   \   0000037C   0xF8A4 0x104A      STRH     R1,[R4, #+74]
   \   00000380   0xF8A4 0x5058      STRH     R5,[R4, #+88]
   \   00000384   0x2101             MOVS     R1,#+1
   \   00000386   0xF8A4 0x104C      STRH     R1,[R4, #+76]
   \   0000038A   0xF64F 0x73FF      MOVW     R3,#+65535
   \   0000038E   0x214A             MOVS     R1,#+74
   \   00000390   0xF8A4 0x104E      STRH     R1,[R4, #+78]
   \   00000394   0x220A             MOVS     R2,#+10
   \   00000396   0x2105             MOVS     R1,#+5
   \   00000398   0xF8A4 0x1050      STRH     R1,[R4, #+80]
   \   0000039C   0x2121             MOVS     R1,#+33
   \   0000039E   0xF8A4 0x1052      STRH     R1,[R4, #+82]
   \   000003A2   0xF894 0x10F8      LDRB     R1,[R4, #+248]
   \   000003A6   0xF8A4 0x1054      STRH     R1,[R4, #+84]
   \   000003AA   0x21FF             MOVS     R1,#+255
   \   000003AC   0xF8A4 0x105A      STRH     R1,[R4, #+90]
   \   000003B0   0xF104 0x0148      ADD      R1,R4,#+72
   \                     ??Rs232MasterCommunication_31: (+1)
   \   000003B4   0x780D             LDRB     R5,[R1, #+0]
   \   000003B6   0xB29B             UXTH     R3,R3
   \   000003B8   0xEA83 0x2305      EOR      R3,R3,R5, LSL #+8
   \   000003BC   0x1E52             SUBS     R2,R2,#+1
   \   000003BE   0x005B             LSLS     R3,R3,#+1
   \   000003C0   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000003C4   0xBF28             IT       CS 
   \   000003C6   0x4043             EORCS    R3,R0,R3
   \   000003C8   0x041B             LSLS     R3,R3,#+16
   \   000003CA   0x0BDB             LSRS     R3,R3,#+15
   \   000003CC   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000003D0   0xBF28             IT       CS 
   \   000003D2   0x4043             EORCS    R3,R0,R3
   \   000003D4   0x041B             LSLS     R3,R3,#+16
   \   000003D6   0x0BDB             LSRS     R3,R3,#+15
   \   000003D8   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000003DC   0xBF28             IT       CS 
   \   000003DE   0x4043             EORCS    R3,R0,R3
   \   000003E0   0x041B             LSLS     R3,R3,#+16
   \   000003E2   0x0BDB             LSRS     R3,R3,#+15
   \   000003E4   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000003E8   0xBF28             IT       CS 
   \   000003EA   0x4043             EORCS    R3,R0,R3
   \   000003EC   0x041B             LSLS     R3,R3,#+16
   \   000003EE   0x0BDB             LSRS     R3,R3,#+15
   \   000003F0   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000003F4   0xBF28             IT       CS 
   \   000003F6   0x4043             EORCS    R3,R0,R3
   \   000003F8   0x041B             LSLS     R3,R3,#+16
   \   000003FA   0x0BDB             LSRS     R3,R3,#+15
   \   000003FC   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000400   0xBF28             IT       CS 
   \   00000402   0x4043             EORCS    R3,R0,R3
   \   00000404   0x041B             LSLS     R3,R3,#+16
   \   00000406   0x0BDB             LSRS     R3,R3,#+15
   \   00000408   0xF5B3 0x3F80      CMP      R3,#+65536
   \   0000040C   0xBF28             IT       CS 
   \   0000040E   0x4043             EORCS    R3,R0,R3
   \   00000410   0x041B             LSLS     R3,R3,#+16
   \   00000412   0x0BDB             LSRS     R3,R3,#+15
   \   00000414   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000418   0xBF28             IT       CS 
   \   0000041A   0x4043             EORCS    R3,R0,R3
   \   0000041C   0x1C89             ADDS     R1,R1,#+2
   \   0000041E   0x2A00             CMP      R2,#+0
   \   00000420   0xD1C8             BNE.N    ??Rs232MasterCommunication_31
   \   00000422   0xB29B             UXTH     R3,R3
   \   00000424   0x0418             LSLS     R0,R3,#+16
   \   00000426   0x0E00             LSRS     R0,R0,#+24
   \   00000428   0xF8A4 0x005C      STRH     R0,[R4, #+92]
   \   0000042C   0xB2D8             UXTB     R0,R3
   \   0000042E   0xF8A4 0x005E      STRH     R0,[R4, #+94]
   \   00000432   0x200C             MOVS     R0,#+12
   \   00000434   0xF8A4 0x0106      STRH     R0,[R4, #+262]
   \   00000438   0x2008             MOVS     R0,#+8
   \   0000043A   0xE3A9             B.N      ??Rs232MasterCommunication_29
   \                     ??Rs232MasterCommunication_32: (+1)
   \   0000043C   0x21A5             MOVS     R1,#+165
   \   0000043E   0xF8A4 0x1048      STRH     R1,[R4, #+72]
   \   00000442   0xF8A4 0x5058      STRH     R5,[R4, #+88]
   \   00000446   0x21EE             MOVS     R1,#+238
   \   00000448   0xF8A4 0x104A      STRH     R1,[R4, #+74]
   \   0000044C   0xF64F 0x73FF      MOVW     R3,#+65535
   \   00000450   0x2101             MOVS     R1,#+1
   \   00000452   0xF8A4 0x104C      STRH     R1,[R4, #+76]
   \   00000456   0x220A             MOVS     R2,#+10
   \   00000458   0x214A             MOVS     R1,#+74
   \   0000045A   0xF8A4 0x104E      STRH     R1,[R4, #+78]
   \   0000045E   0x2105             MOVS     R1,#+5
   \   00000460   0xF8A4 0x1050      STRH     R1,[R4, #+80]
   \   00000464   0x2121             MOVS     R1,#+33
   \   00000466   0xF8A4 0x1052      STRH     R1,[R4, #+82]
   \   0000046A   0xF894 0x10F8      LDRB     R1,[R4, #+248]
   \   0000046E   0xF8A4 0x1054      STRH     R1,[R4, #+84]
   \   00000472   0x21FF             MOVS     R1,#+255
   \   00000474   0xF8A4 0x1056      STRH     R1,[R4, #+86]
   \   00000478   0x21B5             MOVS     R1,#+181
   \   0000047A   0xF8A4 0x105A      STRH     R1,[R4, #+90]
   \   0000047E   0xF104 0x0148      ADD      R1,R4,#+72
   \                     ??Rs232MasterCommunication_33: (+1)
   \   00000482   0x780D             LDRB     R5,[R1, #+0]
   \   00000484   0xB29B             UXTH     R3,R3
   \   00000486   0xEA83 0x2305      EOR      R3,R3,R5, LSL #+8
   \   0000048A   0x1E52             SUBS     R2,R2,#+1
   \   0000048C   0x005B             LSLS     R3,R3,#+1
   \   0000048E   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000492   0xBF28             IT       CS 
   \   00000494   0x4043             EORCS    R3,R0,R3
   \   00000496   0x041B             LSLS     R3,R3,#+16
   \   00000498   0x0BDB             LSRS     R3,R3,#+15
   \   0000049A   0xF5B3 0x3F80      CMP      R3,#+65536
   \   0000049E   0xBF28             IT       CS 
   \   000004A0   0x4043             EORCS    R3,R0,R3
   \   000004A2   0x041B             LSLS     R3,R3,#+16
   \   000004A4   0x0BDB             LSRS     R3,R3,#+15
   \   000004A6   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000004AA   0xBF28             IT       CS 
   \   000004AC   0x4043             EORCS    R3,R0,R3
   \   000004AE   0x041B             LSLS     R3,R3,#+16
   \   000004B0   0x0BDB             LSRS     R3,R3,#+15
   \   000004B2   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000004B6   0xBF28             IT       CS 
   \   000004B8   0x4043             EORCS    R3,R0,R3
   \   000004BA   0x041B             LSLS     R3,R3,#+16
   \   000004BC   0x0BDB             LSRS     R3,R3,#+15
   \   000004BE   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000004C2   0xBF28             IT       CS 
   \   000004C4   0x4043             EORCS    R3,R0,R3
   \   000004C6   0x041B             LSLS     R3,R3,#+16
   \   000004C8   0x0BDB             LSRS     R3,R3,#+15
   \   000004CA   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000004CE   0xBF28             IT       CS 
   \   000004D0   0x4043             EORCS    R3,R0,R3
   \   000004D2   0x041B             LSLS     R3,R3,#+16
   \   000004D4   0x0BDB             LSRS     R3,R3,#+15
   \   000004D6   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000004DA   0xBF28             IT       CS 
   \   000004DC   0x4043             EORCS    R3,R0,R3
   \   000004DE   0x041B             LSLS     R3,R3,#+16
   \   000004E0   0x0BDB             LSRS     R3,R3,#+15
   \   000004E2   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000004E6   0xBF28             IT       CS 
   \   000004E8   0x4043             EORCS    R3,R0,R3
   \   000004EA   0x1C89             ADDS     R1,R1,#+2
   \   000004EC   0x2A00             CMP      R2,#+0
   \   000004EE   0xD1C8             BNE.N    ??Rs232MasterCommunication_33
   \   000004F0   0xB29B             UXTH     R3,R3
   \   000004F2   0x0418             LSLS     R0,R3,#+16
   \   000004F4   0x0E00             LSRS     R0,R0,#+24
   \   000004F6   0xF8A4 0x005C      STRH     R0,[R4, #+92]
   \   000004FA   0xB2D8             UXTB     R0,R3
   \   000004FC   0xF8A4 0x005E      STRH     R0,[R4, #+94]
   \   00000500   0x200C             MOVS     R0,#+12
   \   00000502   0xF8A4 0x0106      STRH     R0,[R4, #+262]
   \   00000506   0x2008             MOVS     R0,#+8
   \   00000508   0xE342             B.N      ??Rs232MasterCommunication_29
   \                     ??Rs232MasterCommunication_34: (+1)
   \   0000050A   0x21A5             MOVS     R1,#+165
   \   0000050C   0xF8A4 0x1048      STRH     R1,[R4, #+72]
   \   00000510   0xF64F 0x73FF      MOVW     R3,#+65535
   \   00000514   0x21EE             MOVS     R1,#+238
   \   00000516   0xF8A4 0x104A      STRH     R1,[R4, #+74]
   \   0000051A   0x2207             MOVS     R2,#+7
   \   0000051C   0x2101             MOVS     R1,#+1
   \   0000051E   0xF8A4 0x104C      STRH     R1,[R4, #+76]
   \   00000522   0x214A             MOVS     R1,#+74
   \   00000524   0xF8A4 0x104E      STRH     R1,[R4, #+78]
   \   00000528   0x2102             MOVS     R1,#+2
   \   0000052A   0xF8A4 0x1050      STRH     R1,[R4, #+80]
   \   0000052E   0x2121             MOVS     R1,#+33
   \   00000530   0xF8A4 0x1052      STRH     R1,[R4, #+82]
   \   00000534   0xF894 0x10F9      LDRB     R1,[R4, #+249]
   \   00000538   0xF8A4 0x1054      STRH     R1,[R4, #+84]
   \   0000053C   0xF104 0x0148      ADD      R1,R4,#+72
   \                     ??Rs232MasterCommunication_35: (+1)
   \   00000540   0x780D             LDRB     R5,[R1, #+0]
   \   00000542   0xB29B             UXTH     R3,R3
   \   00000544   0xEA83 0x2305      EOR      R3,R3,R5, LSL #+8
   \   00000548   0x1E52             SUBS     R2,R2,#+1
   \   0000054A   0x005B             LSLS     R3,R3,#+1
   \   0000054C   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000550   0xBF28             IT       CS 
   \   00000552   0x4043             EORCS    R3,R0,R3
   \   00000554   0x041B             LSLS     R3,R3,#+16
   \   00000556   0x0BDB             LSRS     R3,R3,#+15
   \   00000558   0xF5B3 0x3F80      CMP      R3,#+65536
   \   0000055C   0xBF28             IT       CS 
   \   0000055E   0x4043             EORCS    R3,R0,R3
   \   00000560   0x041B             LSLS     R3,R3,#+16
   \   00000562   0x0BDB             LSRS     R3,R3,#+15
   \   00000564   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000568   0xBF28             IT       CS 
   \   0000056A   0x4043             EORCS    R3,R0,R3
   \   0000056C   0x041B             LSLS     R3,R3,#+16
   \   0000056E   0x0BDB             LSRS     R3,R3,#+15
   \   00000570   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000574   0xBF28             IT       CS 
   \   00000576   0x4043             EORCS    R3,R0,R3
   \   00000578   0x041B             LSLS     R3,R3,#+16
   \   0000057A   0x0BDB             LSRS     R3,R3,#+15
   \   0000057C   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000580   0xBF28             IT       CS 
   \   00000582   0x4043             EORCS    R3,R0,R3
   \   00000584   0x041B             LSLS     R3,R3,#+16
   \   00000586   0x0BDB             LSRS     R3,R3,#+15
   \   00000588   0xF5B3 0x3F80      CMP      R3,#+65536
   \   0000058C   0xBF28             IT       CS 
   \   0000058E   0x4043             EORCS    R3,R0,R3
   \   00000590   0x041B             LSLS     R3,R3,#+16
   \   00000592   0x0BDB             LSRS     R3,R3,#+15
   \   00000594   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000598   0xBF28             IT       CS 
   \   0000059A   0x4043             EORCS    R3,R0,R3
   \   0000059C   0x041B             LSLS     R3,R3,#+16
   \   0000059E   0x0BDB             LSRS     R3,R3,#+15
   \   000005A0   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000005A4   0xBF28             IT       CS 
   \   000005A6   0x4043             EORCS    R3,R0,R3
   \   000005A8   0x1C89             ADDS     R1,R1,#+2
   \   000005AA   0x2A00             CMP      R2,#+0
   \   000005AC   0xD1C8             BNE.N    ??Rs232MasterCommunication_35
   \   000005AE   0xB29B             UXTH     R3,R3
   \   000005B0   0x0418             LSLS     R0,R3,#+16
   \   000005B2   0x0E00             LSRS     R0,R0,#+24
   \   000005B4   0xF8A4 0x0056      STRH     R0,[R4, #+86]
   \   000005B8   0xB2D8             UXTB     R0,R3
   \   000005BA   0xF8A4 0x0058      STRH     R0,[R4, #+88]
   \   000005BE   0x2009             MOVS     R0,#+9
   \   000005C0   0xF8A4 0x0106      STRH     R0,[R4, #+262]
   \   000005C4   0x2008             MOVS     R0,#+8
   \   000005C6   0xE2E3             B.N      ??Rs232MasterCommunication_29
   \                     ??Rs232MasterCommunication_36: (+1)
   \   000005C8   0x21A5             MOVS     R1,#+165
   \   000005CA   0xF8A4 0x1048      STRH     R1,[R4, #+72]
   \   000005CE   0xF64F 0x73FF      MOVW     R3,#+65535
   \   000005D2   0x21EE             MOVS     R1,#+238
   \   000005D4   0xF8A4 0x104A      STRH     R1,[R4, #+74]
   \   000005D8   0x2207             MOVS     R2,#+7
   \   000005DA   0x2101             MOVS     R1,#+1
   \   000005DC   0xF8A4 0x104C      STRH     R1,[R4, #+76]
   \   000005E0   0x214A             MOVS     R1,#+74
   \   000005E2   0xF8A4 0x104E      STRH     R1,[R4, #+78]
   \   000005E6   0x2102             MOVS     R1,#+2
   \   000005E8   0xF8A4 0x1050      STRH     R1,[R4, #+80]
   \   000005EC   0x2121             MOVS     R1,#+33
   \   000005EE   0xF8A4 0x1052      STRH     R1,[R4, #+82]
   \   000005F2   0xF894 0x10FA      LDRB     R1,[R4, #+250]
   \   000005F6   0xF8A4 0x1054      STRH     R1,[R4, #+84]
   \   000005FA   0xF104 0x0148      ADD      R1,R4,#+72
   \                     ??Rs232MasterCommunication_37: (+1)
   \   000005FE   0x780D             LDRB     R5,[R1, #+0]
   \   00000600   0xB29B             UXTH     R3,R3
   \   00000602   0xEA83 0x2305      EOR      R3,R3,R5, LSL #+8
   \   00000606   0x1E52             SUBS     R2,R2,#+1
   \   00000608   0x005B             LSLS     R3,R3,#+1
   \   0000060A   0xF5B3 0x3F80      CMP      R3,#+65536
   \   0000060E   0xBF28             IT       CS 
   \   00000610   0x4043             EORCS    R3,R0,R3
   \   00000612   0x041B             LSLS     R3,R3,#+16
   \   00000614   0x0BDB             LSRS     R3,R3,#+15
   \   00000616   0xF5B3 0x3F80      CMP      R3,#+65536
   \   0000061A   0xBF28             IT       CS 
   \   0000061C   0x4043             EORCS    R3,R0,R3
   \   0000061E   0x041B             LSLS     R3,R3,#+16
   \   00000620   0x0BDB             LSRS     R3,R3,#+15
   \   00000622   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000626   0xBF28             IT       CS 
   \   00000628   0x4043             EORCS    R3,R0,R3
   \   0000062A   0x041B             LSLS     R3,R3,#+16
   \   0000062C   0x0BDB             LSRS     R3,R3,#+15
   \   0000062E   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000632   0xBF28             IT       CS 
   \   00000634   0x4043             EORCS    R3,R0,R3
   \   00000636   0x041B             LSLS     R3,R3,#+16
   \   00000638   0x0BDB             LSRS     R3,R3,#+15
   \   0000063A   0xF5B3 0x3F80      CMP      R3,#+65536
   \   0000063E   0xBF28             IT       CS 
   \   00000640   0x4043             EORCS    R3,R0,R3
   \   00000642   0x041B             LSLS     R3,R3,#+16
   \   00000644   0x0BDB             LSRS     R3,R3,#+15
   \   00000646   0xF5B3 0x3F80      CMP      R3,#+65536
   \   0000064A   0xBF28             IT       CS 
   \   0000064C   0x4043             EORCS    R3,R0,R3
   \   0000064E   0x041B             LSLS     R3,R3,#+16
   \   00000650   0x0BDB             LSRS     R3,R3,#+15
   \   00000652   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000656   0xBF28             IT       CS 
   \   00000658   0x4043             EORCS    R3,R0,R3
   \   0000065A   0x041B             LSLS     R3,R3,#+16
   \   0000065C   0x0BDB             LSRS     R3,R3,#+15
   \   0000065E   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000662   0xBF28             IT       CS 
   \   00000664   0x4043             EORCS    R3,R0,R3
   \   00000666   0x1C89             ADDS     R1,R1,#+2
   \   00000668   0x2A00             CMP      R2,#+0
   \   0000066A   0xD1C8             BNE.N    ??Rs232MasterCommunication_37
   \   0000066C   0xB29B             UXTH     R3,R3
   \   0000066E   0x0418             LSLS     R0,R3,#+16
   \   00000670   0x0E00             LSRS     R0,R0,#+24
   \   00000672   0xF8A4 0x0056      STRH     R0,[R4, #+86]
   \   00000676   0xB2D8             UXTB     R0,R3
   \   00000678   0xF8A4 0x0058      STRH     R0,[R4, #+88]
   \   0000067C   0x2009             MOVS     R0,#+9
   \   0000067E   0xF8A4 0x0106      STRH     R0,[R4, #+262]
   \   00000682   0x2008             MOVS     R0,#+8
   \   00000684   0xE284             B.N      ??Rs232MasterCommunication_29
   \                     ??Rs232MasterCommunication_38: (+1)
   \   00000686   0x21A5             MOVS     R1,#+165
   \   00000688   0xF8A4 0x1048      STRH     R1,[R4, #+72]
   \   0000068C   0xF64F 0x73FF      MOVW     R3,#+65535
   \   00000690   0x21EE             MOVS     R1,#+238
   \   00000692   0xF8A4 0x104A      STRH     R1,[R4, #+74]
   \   00000696   0x2207             MOVS     R2,#+7
   \   00000698   0x2101             MOVS     R1,#+1
   \   0000069A   0xF8A4 0x104C      STRH     R1,[R4, #+76]
   \   0000069E   0x214A             MOVS     R1,#+74
   \   000006A0   0xF8A4 0x104E      STRH     R1,[R4, #+78]
   \   000006A4   0x2102             MOVS     R1,#+2
   \   000006A6   0xF8A4 0x1050      STRH     R1,[R4, #+80]
   \   000006AA   0x2121             MOVS     R1,#+33
   \   000006AC   0xF8A4 0x1052      STRH     R1,[R4, #+82]
   \   000006B0   0xF894 0x10FB      LDRB     R1,[R4, #+251]
   \   000006B4   0xF8A4 0x1054      STRH     R1,[R4, #+84]
   \   000006B8   0xF104 0x0148      ADD      R1,R4,#+72
   \                     ??Rs232MasterCommunication_39: (+1)
   \   000006BC   0x780D             LDRB     R5,[R1, #+0]
   \   000006BE   0xB29B             UXTH     R3,R3
   \   000006C0   0xEA83 0x2305      EOR      R3,R3,R5, LSL #+8
   \   000006C4   0x1E52             SUBS     R2,R2,#+1
   \   000006C6   0x005B             LSLS     R3,R3,#+1
   \   000006C8   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000006CC   0xBF28             IT       CS 
   \   000006CE   0x4043             EORCS    R3,R0,R3
   \   000006D0   0x041B             LSLS     R3,R3,#+16
   \   000006D2   0x0BDB             LSRS     R3,R3,#+15
   \   000006D4   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000006D8   0xBF28             IT       CS 
   \   000006DA   0x4043             EORCS    R3,R0,R3
   \   000006DC   0x041B             LSLS     R3,R3,#+16
   \   000006DE   0x0BDB             LSRS     R3,R3,#+15
   \   000006E0   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000006E4   0xBF28             IT       CS 
   \   000006E6   0x4043             EORCS    R3,R0,R3
   \   000006E8   0x041B             LSLS     R3,R3,#+16
   \   000006EA   0x0BDB             LSRS     R3,R3,#+15
   \   000006EC   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000006F0   0xBF28             IT       CS 
   \   000006F2   0x4043             EORCS    R3,R0,R3
   \   000006F4   0x041B             LSLS     R3,R3,#+16
   \   000006F6   0x0BDB             LSRS     R3,R3,#+15
   \   000006F8   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000006FC   0xBF28             IT       CS 
   \   000006FE   0x4043             EORCS    R3,R0,R3
   \   00000700   0x041B             LSLS     R3,R3,#+16
   \   00000702   0x0BDB             LSRS     R3,R3,#+15
   \   00000704   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000708   0xBF28             IT       CS 
   \   0000070A   0x4043             EORCS    R3,R0,R3
   \   0000070C   0x041B             LSLS     R3,R3,#+16
   \   0000070E   0x0BDB             LSRS     R3,R3,#+15
   \   00000710   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000714   0xBF28             IT       CS 
   \   00000716   0x4043             EORCS    R3,R0,R3
   \   00000718   0x041B             LSLS     R3,R3,#+16
   \   0000071A   0x0BDB             LSRS     R3,R3,#+15
   \   0000071C   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000720   0xBF28             IT       CS 
   \   00000722   0x4043             EORCS    R3,R0,R3
   \   00000724   0x1C89             ADDS     R1,R1,#+2
   \   00000726   0x2A00             CMP      R2,#+0
   \   00000728   0xD1C8             BNE.N    ??Rs232MasterCommunication_39
   \   0000072A   0xB29B             UXTH     R3,R3
   \   0000072C   0x0418             LSLS     R0,R3,#+16
   \   0000072E   0x0E00             LSRS     R0,R0,#+24
   \   00000730   0xF8A4 0x0056      STRH     R0,[R4, #+86]
   \   00000734   0xB2D8             UXTB     R0,R3
   \   00000736   0xF8A4 0x0058      STRH     R0,[R4, #+88]
   \   0000073A   0x2009             MOVS     R0,#+9
   \   0000073C   0xF8A4 0x0106      STRH     R0,[R4, #+262]
   \   00000740   0x2008             MOVS     R0,#+8
   \   00000742   0xE225             B.N      ??Rs232MasterCommunication_29
   \                     ??Rs232MasterCommunication_40: (+1)
   \   00000744   0x21A5             MOVS     R1,#+165
   \   00000746   0xF8A4 0x1048      STRH     R1,[R4, #+72]
   \   0000074A   0xF64F 0x73FF      MOVW     R3,#+65535
   \   0000074E   0x21EE             MOVS     R1,#+238
   \   00000750   0xF8A4 0x104A      STRH     R1,[R4, #+74]
   \   00000754   0x2207             MOVS     R2,#+7
   \   00000756   0x2101             MOVS     R1,#+1
   \   00000758   0xF8A4 0x104C      STRH     R1,[R4, #+76]
   \   0000075C   0x214A             MOVS     R1,#+74
   \   0000075E   0xF8A4 0x104E      STRH     R1,[R4, #+78]
   \   00000762   0x2102             MOVS     R1,#+2
   \   00000764   0xF8A4 0x1050      STRH     R1,[R4, #+80]
   \   00000768   0x2121             MOVS     R1,#+33
   \   0000076A   0xF8A4 0x1052      STRH     R1,[R4, #+82]
   \   0000076E   0xF894 0x10FC      LDRB     R1,[R4, #+252]
   \   00000772   0xF8A4 0x1054      STRH     R1,[R4, #+84]
   \   00000776   0xF104 0x0148      ADD      R1,R4,#+72
   \                     ??Rs232MasterCommunication_41: (+1)
   \   0000077A   0x780D             LDRB     R5,[R1, #+0]
   \   0000077C   0xB29B             UXTH     R3,R3
   \   0000077E   0xEA83 0x2305      EOR      R3,R3,R5, LSL #+8
   \   00000782   0x1E52             SUBS     R2,R2,#+1
   \   00000784   0x005B             LSLS     R3,R3,#+1
   \   00000786   0xF5B3 0x3F80      CMP      R3,#+65536
   \   0000078A   0xBF28             IT       CS 
   \   0000078C   0x4043             EORCS    R3,R0,R3
   \   0000078E   0x041B             LSLS     R3,R3,#+16
   \   00000790   0x0BDB             LSRS     R3,R3,#+15
   \   00000792   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000796   0xBF28             IT       CS 
   \   00000798   0x4043             EORCS    R3,R0,R3
   \   0000079A   0x041B             LSLS     R3,R3,#+16
   \   0000079C   0x0BDB             LSRS     R3,R3,#+15
   \   0000079E   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000007A2   0xBF28             IT       CS 
   \   000007A4   0x4043             EORCS    R3,R0,R3
   \   000007A6   0x041B             LSLS     R3,R3,#+16
   \   000007A8   0x0BDB             LSRS     R3,R3,#+15
   \   000007AA   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000007AE   0xBF28             IT       CS 
   \   000007B0   0x4043             EORCS    R3,R0,R3
   \   000007B2   0x041B             LSLS     R3,R3,#+16
   \   000007B4   0x0BDB             LSRS     R3,R3,#+15
   \   000007B6   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000007BA   0xBF28             IT       CS 
   \   000007BC   0x4043             EORCS    R3,R0,R3
   \   000007BE   0x041B             LSLS     R3,R3,#+16
   \   000007C0   0x0BDB             LSRS     R3,R3,#+15
   \   000007C2   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000007C6   0xBF28             IT       CS 
   \   000007C8   0x4043             EORCS    R3,R0,R3
   \   000007CA   0x041B             LSLS     R3,R3,#+16
   \   000007CC   0x0BDB             LSRS     R3,R3,#+15
   \   000007CE   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000007D2   0xBF28             IT       CS 
   \   000007D4   0x4043             EORCS    R3,R0,R3
   \   000007D6   0x041B             LSLS     R3,R3,#+16
   \   000007D8   0x0BDB             LSRS     R3,R3,#+15
   \   000007DA   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000007DE   0xBF28             IT       CS 
   \   000007E0   0x4043             EORCS    R3,R0,R3
   \   000007E2   0x1C89             ADDS     R1,R1,#+2
   \   000007E4   0x2A00             CMP      R2,#+0
   \   000007E6   0xD1C8             BNE.N    ??Rs232MasterCommunication_41
   \   000007E8   0xB29B             UXTH     R3,R3
   \   000007EA   0x0418             LSLS     R0,R3,#+16
   \   000007EC   0x0E00             LSRS     R0,R0,#+24
   \   000007EE   0xF8A4 0x0056      STRH     R0,[R4, #+86]
   \   000007F2   0xB2D8             UXTB     R0,R3
   \   000007F4   0xF8A4 0x0058      STRH     R0,[R4, #+88]
   \   000007F8   0x2009             MOVS     R0,#+9
   \   000007FA   0xF8A4 0x0106      STRH     R0,[R4, #+262]
   \   000007FE   0x2008             MOVS     R0,#+8
   \   00000800   0xE1C6             B.N      ??Rs232MasterCommunication_29
   \                     ??Rs232MasterCommunication_42: (+1)
   \   00000802   0x21A5             MOVS     R1,#+165
   \   00000804   0xF8A4 0x1048      STRH     R1,[R4, #+72]
   \   00000808   0xF64F 0x73FF      MOVW     R3,#+65535
   \   0000080C   0x21EE             MOVS     R1,#+238
   \   0000080E   0xF8A4 0x104A      STRH     R1,[R4, #+74]
   \   00000812   0x2207             MOVS     R2,#+7
   \   00000814   0x2101             MOVS     R1,#+1
   \   00000816   0xF8A4 0x104C      STRH     R1,[R4, #+76]
   \   0000081A   0x214A             MOVS     R1,#+74
   \   0000081C   0xF8A4 0x104E      STRH     R1,[R4, #+78]
   \   00000820   0x2102             MOVS     R1,#+2
   \   00000822   0xF8A4 0x1050      STRH     R1,[R4, #+80]
   \   00000826   0x2121             MOVS     R1,#+33
   \   00000828   0xF8A4 0x1052      STRH     R1,[R4, #+82]
   \   0000082C   0xF894 0x10FD      LDRB     R1,[R4, #+253]
   \   00000830   0xF8A4 0x1054      STRH     R1,[R4, #+84]
   \   00000834   0xF104 0x0148      ADD      R1,R4,#+72
   \                     ??Rs232MasterCommunication_43: (+1)
   \   00000838   0x780D             LDRB     R5,[R1, #+0]
   \   0000083A   0xB29B             UXTH     R3,R3
   \   0000083C   0xEA83 0x2305      EOR      R3,R3,R5, LSL #+8
   \   00000840   0x1E52             SUBS     R2,R2,#+1
   \   00000842   0x005B             LSLS     R3,R3,#+1
   \   00000844   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000848   0xBF28             IT       CS 
   \   0000084A   0x4043             EORCS    R3,R0,R3
   \   0000084C   0x041B             LSLS     R3,R3,#+16
   \   0000084E   0x0BDB             LSRS     R3,R3,#+15
   \   00000850   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000854   0xBF28             IT       CS 
   \   00000856   0x4043             EORCS    R3,R0,R3
   \   00000858   0x041B             LSLS     R3,R3,#+16
   \   0000085A   0x0BDB             LSRS     R3,R3,#+15
   \   0000085C   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000860   0xBF28             IT       CS 
   \   00000862   0x4043             EORCS    R3,R0,R3
   \   00000864   0x041B             LSLS     R3,R3,#+16
   \   00000866   0x0BDB             LSRS     R3,R3,#+15
   \   00000868   0xF5B3 0x3F80      CMP      R3,#+65536
   \   0000086C   0xBF28             IT       CS 
   \   0000086E   0x4043             EORCS    R3,R0,R3
   \   00000870   0x041B             LSLS     R3,R3,#+16
   \   00000872   0x0BDB             LSRS     R3,R3,#+15
   \   00000874   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000878   0xBF28             IT       CS 
   \   0000087A   0x4043             EORCS    R3,R0,R3
   \   0000087C   0x041B             LSLS     R3,R3,#+16
   \   0000087E   0x0BDB             LSRS     R3,R3,#+15
   \   00000880   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000884   0xBF28             IT       CS 
   \   00000886   0x4043             EORCS    R3,R0,R3
   \   00000888   0x041B             LSLS     R3,R3,#+16
   \   0000088A   0x0BDB             LSRS     R3,R3,#+15
   \   0000088C   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000890   0xBF28             IT       CS 
   \   00000892   0x4043             EORCS    R3,R0,R3
   \   00000894   0x041B             LSLS     R3,R3,#+16
   \   00000896   0x0BDB             LSRS     R3,R3,#+15
   \   00000898   0xF5B3 0x3F80      CMP      R3,#+65536
   \   0000089C   0xBF28             IT       CS 
   \   0000089E   0x4043             EORCS    R3,R0,R3
   \   000008A0   0x1C89             ADDS     R1,R1,#+2
   \   000008A2   0x2A00             CMP      R2,#+0
   \   000008A4   0xD1C8             BNE.N    ??Rs232MasterCommunication_43
   \   000008A6   0xB29B             UXTH     R3,R3
   \   000008A8   0x0418             LSLS     R0,R3,#+16
   \   000008AA   0x0E00             LSRS     R0,R0,#+24
   \   000008AC   0xF8A4 0x0056      STRH     R0,[R4, #+86]
   \   000008B0   0xB2D8             UXTB     R0,R3
   \   000008B2   0xF8A4 0x0058      STRH     R0,[R4, #+88]
   \   000008B6   0x2009             MOVS     R0,#+9
   \   000008B8   0xF8A4 0x0106      STRH     R0,[R4, #+262]
   \   000008BC   0x2008             MOVS     R0,#+8
   \   000008BE   0xE167             B.N      ??Rs232MasterCommunication_29
   \                     ??Rs232MasterCommunication_44: (+1)
   \   000008C0   0x21A5             MOVS     R1,#+165
   \   000008C2   0xF8A4 0x1048      STRH     R1,[R4, #+72]
   \   000008C6   0xF64F 0x73FF      MOVW     R3,#+65535
   \   000008CA   0x21EE             MOVS     R1,#+238
   \   000008CC   0xF8A4 0x104A      STRH     R1,[R4, #+74]
   \   000008D0   0x2207             MOVS     R2,#+7
   \   000008D2   0x2101             MOVS     R1,#+1
   \   000008D4   0xF8A4 0x104C      STRH     R1,[R4, #+76]
   \   000008D8   0x214A             MOVS     R1,#+74
   \   000008DA   0xF8A4 0x104E      STRH     R1,[R4, #+78]
   \   000008DE   0x2102             MOVS     R1,#+2
   \   000008E0   0xF8A4 0x1050      STRH     R1,[R4, #+80]
   \   000008E4   0x2121             MOVS     R1,#+33
   \   000008E6   0xF8A4 0x1052      STRH     R1,[R4, #+82]
   \   000008EA   0xF894 0x10FE      LDRB     R1,[R4, #+254]
   \   000008EE   0xF8A4 0x1054      STRH     R1,[R4, #+84]
   \   000008F2   0xF104 0x0148      ADD      R1,R4,#+72
   \                     ??Rs232MasterCommunication_45: (+1)
   \   000008F6   0x780D             LDRB     R5,[R1, #+0]
   \   000008F8   0xB29B             UXTH     R3,R3
   \   000008FA   0xEA83 0x2305      EOR      R3,R3,R5, LSL #+8
   \   000008FE   0x1E52             SUBS     R2,R2,#+1
   \   00000900   0x005B             LSLS     R3,R3,#+1
   \   00000902   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000906   0xBF28             IT       CS 
   \   00000908   0x4043             EORCS    R3,R0,R3
   \   0000090A   0x041B             LSLS     R3,R3,#+16
   \   0000090C   0x0BDB             LSRS     R3,R3,#+15
   \   0000090E   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000912   0xBF28             IT       CS 
   \   00000914   0x4043             EORCS    R3,R0,R3
   \   00000916   0x041B             LSLS     R3,R3,#+16
   \   00000918   0x0BDB             LSRS     R3,R3,#+15
   \   0000091A   0xF5B3 0x3F80      CMP      R3,#+65536
   \   0000091E   0xBF28             IT       CS 
   \   00000920   0x4043             EORCS    R3,R0,R3
   \   00000922   0x041B             LSLS     R3,R3,#+16
   \   00000924   0x0BDB             LSRS     R3,R3,#+15
   \   00000926   0xF5B3 0x3F80      CMP      R3,#+65536
   \   0000092A   0xBF28             IT       CS 
   \   0000092C   0x4043             EORCS    R3,R0,R3
   \   0000092E   0x041B             LSLS     R3,R3,#+16
   \   00000930   0x0BDB             LSRS     R3,R3,#+15
   \   00000932   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000936   0xBF28             IT       CS 
   \   00000938   0x4043             EORCS    R3,R0,R3
   \   0000093A   0x041B             LSLS     R3,R3,#+16
   \   0000093C   0x0BDB             LSRS     R3,R3,#+15
   \   0000093E   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000942   0xBF28             IT       CS 
   \   00000944   0x4043             EORCS    R3,R0,R3
   \   00000946   0x041B             LSLS     R3,R3,#+16
   \   00000948   0x0BDB             LSRS     R3,R3,#+15
   \   0000094A   0xF5B3 0x3F80      CMP      R3,#+65536
   \   0000094E   0xBF28             IT       CS 
   \   00000950   0x4043             EORCS    R3,R0,R3
   \   00000952   0x041B             LSLS     R3,R3,#+16
   \   00000954   0x0BDB             LSRS     R3,R3,#+15
   \   00000956   0xF5B3 0x3F80      CMP      R3,#+65536
   \   0000095A   0xBF28             IT       CS 
   \   0000095C   0x4043             EORCS    R3,R0,R3
   \   0000095E   0x1C89             ADDS     R1,R1,#+2
   \   00000960   0x2A00             CMP      R2,#+0
   \   00000962   0xD1C8             BNE.N    ??Rs232MasterCommunication_45
   \   00000964   0xB29B             UXTH     R3,R3
   \   00000966   0x0418             LSLS     R0,R3,#+16
   \   00000968   0x0E00             LSRS     R0,R0,#+24
   \   0000096A   0xF8A4 0x0056      STRH     R0,[R4, #+86]
   \   0000096E   0xB2D8             UXTB     R0,R3
   \   00000970   0xF8A4 0x0058      STRH     R0,[R4, #+88]
   \   00000974   0x2009             MOVS     R0,#+9
   \   00000976   0xF8A4 0x0106      STRH     R0,[R4, #+262]
   \   0000097A   0x2008             MOVS     R0,#+8
   \   0000097C   0xE108             B.N      ??Rs232MasterCommunication_29
   \                     ??Rs232MasterCommunication_46: (+1)
   \   0000097E   0x21A5             MOVS     R1,#+165
   \   00000980   0xF8A4 0x1048      STRH     R1,[R4, #+72]
   \   00000984   0xF64F 0x73FF      MOVW     R3,#+65535
   \   00000988   0x21EE             MOVS     R1,#+238
   \   0000098A   0xF8A4 0x104A      STRH     R1,[R4, #+74]
   \   0000098E   0x2207             MOVS     R2,#+7
   \   00000990   0x2101             MOVS     R1,#+1
   \   00000992   0xF8A4 0x104C      STRH     R1,[R4, #+76]
   \   00000996   0x214A             MOVS     R1,#+74
   \   00000998   0xF8A4 0x104E      STRH     R1,[R4, #+78]
   \   0000099C   0x2102             MOVS     R1,#+2
   \   0000099E   0xF8A4 0x1050      STRH     R1,[R4, #+80]
   \   000009A2   0x2121             MOVS     R1,#+33
   \   000009A4   0xF8A4 0x1052      STRH     R1,[R4, #+82]
   \   000009A8   0xF894 0x10FF      LDRB     R1,[R4, #+255]
   \   000009AC   0xF8A4 0x1054      STRH     R1,[R4, #+84]
   \   000009B0   0xF104 0x0148      ADD      R1,R4,#+72
   \                     ??Rs232MasterCommunication_47: (+1)
   \   000009B4   0x780D             LDRB     R5,[R1, #+0]
   \   000009B6   0xB29B             UXTH     R3,R3
   \   000009B8   0xEA83 0x2305      EOR      R3,R3,R5, LSL #+8
   \   000009BC   0x1E52             SUBS     R2,R2,#+1
   \   000009BE   0x005B             LSLS     R3,R3,#+1
   \   000009C0   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000009C4   0xBF28             IT       CS 
   \   000009C6   0x4043             EORCS    R3,R0,R3
   \   000009C8   0x041B             LSLS     R3,R3,#+16
   \   000009CA   0x0BDB             LSRS     R3,R3,#+15
   \   000009CC   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000009D0   0xBF28             IT       CS 
   \   000009D2   0x4043             EORCS    R3,R0,R3
   \   000009D4   0x041B             LSLS     R3,R3,#+16
   \   000009D6   0x0BDB             LSRS     R3,R3,#+15
   \   000009D8   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000009DC   0xBF28             IT       CS 
   \   000009DE   0x4043             EORCS    R3,R0,R3
   \   000009E0   0x041B             LSLS     R3,R3,#+16
   \   000009E2   0x0BDB             LSRS     R3,R3,#+15
   \   000009E4   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000009E8   0xBF28             IT       CS 
   \   000009EA   0x4043             EORCS    R3,R0,R3
   \   000009EC   0x041B             LSLS     R3,R3,#+16
   \   000009EE   0x0BDB             LSRS     R3,R3,#+15
   \   000009F0   0xF5B3 0x3F80      CMP      R3,#+65536
   \   000009F4   0xBF28             IT       CS 
   \   000009F6   0x4043             EORCS    R3,R0,R3
   \   000009F8   0x041B             LSLS     R3,R3,#+16
   \   000009FA   0x0BDB             LSRS     R3,R3,#+15
   \   000009FC   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000A00   0xBF28             IT       CS 
   \   00000A02   0x4043             EORCS    R3,R0,R3
   \   00000A04   0x041B             LSLS     R3,R3,#+16
   \   00000A06   0x0BDB             LSRS     R3,R3,#+15
   \   00000A08   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000A0C   0xBF28             IT       CS 
   \   00000A0E   0x4043             EORCS    R3,R0,R3
   \   00000A10   0x041B             LSLS     R3,R3,#+16
   \   00000A12   0x0BDB             LSRS     R3,R3,#+15
   \   00000A14   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000A18   0xBF28             IT       CS 
   \   00000A1A   0x4043             EORCS    R3,R0,R3
   \   00000A1C   0x1C89             ADDS     R1,R1,#+2
   \   00000A1E   0x2A00             CMP      R2,#+0
   \   00000A20   0xD1C8             BNE.N    ??Rs232MasterCommunication_47
   \   00000A22   0xB29B             UXTH     R3,R3
   \   00000A24   0x0418             LSLS     R0,R3,#+16
   \   00000A26   0x0E00             LSRS     R0,R0,#+24
   \   00000A28   0xF8A4 0x0056      STRH     R0,[R4, #+86]
   \   00000A2C   0xB2D8             UXTB     R0,R3
   \   00000A2E   0xF8A4 0x0058      STRH     R0,[R4, #+88]
   \   00000A32   0x2009             MOVS     R0,#+9
   \   00000A34   0xF8A4 0x0106      STRH     R0,[R4, #+262]
   \   00000A38   0x2008             MOVS     R0,#+8
   \   00000A3A   0xE0A9             B.N      ??Rs232MasterCommunication_29
   \                     ??Rs232MasterCommunication_48: (+1)
   \   00000A3C   0x21A5             MOVS     R1,#+165
   \   00000A3E   0xF8A4 0x1048      STRH     R1,[R4, #+72]
   \   00000A42   0xF64F 0x73FF      MOVW     R3,#+65535
   \   00000A46   0x21EE             MOVS     R1,#+238
   \   00000A48   0xF8A4 0x104A      STRH     R1,[R4, #+74]
   \   00000A4C   0x2207             MOVS     R2,#+7
   \   00000A4E   0x2101             MOVS     R1,#+1
   \   00000A50   0xF8A4 0x104C      STRH     R1,[R4, #+76]
   \   00000A54   0x214A             MOVS     R1,#+74
   \   00000A56   0xF8A4 0x104E      STRH     R1,[R4, #+78]
   \   00000A5A   0x2102             MOVS     R1,#+2
   \   00000A5C   0xF8A4 0x1050      STRH     R1,[R4, #+80]
   \   00000A60   0x2121             MOVS     R1,#+33
   \   00000A62   0xF8A4 0x1052      STRH     R1,[R4, #+82]
   \   00000A66   0xF894 0x1100      LDRB     R1,[R4, #+256]
   \   00000A6A   0xF8A4 0x1054      STRH     R1,[R4, #+84]
   \   00000A6E   0xF104 0x0148      ADD      R1,R4,#+72
   \                     ??Rs232MasterCommunication_49: (+1)
   \   00000A72   0x780D             LDRB     R5,[R1, #+0]
   \   00000A74   0xB29B             UXTH     R3,R3
   \   00000A76   0xEA83 0x2305      EOR      R3,R3,R5, LSL #+8
   \   00000A7A   0x1E52             SUBS     R2,R2,#+1
   \   00000A7C   0x005B             LSLS     R3,R3,#+1
   \   00000A7E   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000A82   0xBF28             IT       CS 
   \   00000A84   0x4043             EORCS    R3,R0,R3
   \   00000A86   0x041B             LSLS     R3,R3,#+16
   \   00000A88   0x0BDB             LSRS     R3,R3,#+15
   \   00000A8A   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000A8E   0xBF28             IT       CS 
   \   00000A90   0x4043             EORCS    R3,R0,R3
   \   00000A92   0x041B             LSLS     R3,R3,#+16
   \   00000A94   0x0BDB             LSRS     R3,R3,#+15
   \   00000A96   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000A9A   0xBF28             IT       CS 
   \   00000A9C   0x4043             EORCS    R3,R0,R3
   \   00000A9E   0x041B             LSLS     R3,R3,#+16
   \   00000AA0   0x0BDB             LSRS     R3,R3,#+15
   \   00000AA2   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000AA6   0xBF28             IT       CS 
   \   00000AA8   0x4043             EORCS    R3,R0,R3
   \   00000AAA   0x041B             LSLS     R3,R3,#+16
   \   00000AAC   0x0BDB             LSRS     R3,R3,#+15
   \   00000AAE   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000AB2   0xBF28             IT       CS 
   \   00000AB4   0x4043             EORCS    R3,R0,R3
   \   00000AB6   0x041B             LSLS     R3,R3,#+16
   \   00000AB8   0x0BDB             LSRS     R3,R3,#+15
   \   00000ABA   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000ABE   0xBF28             IT       CS 
   \   00000AC0   0x4043             EORCS    R3,R0,R3
   \   00000AC2   0x041B             LSLS     R3,R3,#+16
   \   00000AC4   0x0BDB             LSRS     R3,R3,#+15
   \   00000AC6   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000ACA   0xBF28             IT       CS 
   \   00000ACC   0x4043             EORCS    R3,R0,R3
   \   00000ACE   0x041B             LSLS     R3,R3,#+16
   \   00000AD0   0x0BDB             LSRS     R3,R3,#+15
   \   00000AD2   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000AD6   0xBF28             IT       CS 
   \   00000AD8   0x4043             EORCS    R3,R0,R3
   \   00000ADA   0x1C89             ADDS     R1,R1,#+2
   \   00000ADC   0x2A00             CMP      R2,#+0
   \   00000ADE   0xD1C8             BNE.N    ??Rs232MasterCommunication_49
   \   00000AE0   0xB29B             UXTH     R3,R3
   \   00000AE2   0x0418             LSLS     R0,R3,#+16
   \   00000AE4   0x0E00             LSRS     R0,R0,#+24
   \   00000AE6   0xF8A4 0x0056      STRH     R0,[R4, #+86]
   \   00000AEA   0xB2D8             UXTB     R0,R3
   \   00000AEC   0xF8A4 0x0058      STRH     R0,[R4, #+88]
   \   00000AF0   0x2009             MOVS     R0,#+9
   \   00000AF2   0xF8A4 0x0106      STRH     R0,[R4, #+262]
   \   00000AF6   0x2008             MOVS     R0,#+8
   \   00000AF8   0xE04A             B.N      ??Rs232MasterCommunication_29
   \                     ??Rs232MasterCommunication_50: (+1)
   \   00000AFA   0x.... 0x....      LDR.W    R1,??DataTable7_1
   \   00000AFE   0xF8A4 0x5116      STRH     R5,[R4, #+278]
   \   00000B02   0x2001             MOVS     R0,#+1
   \   00000B04   0x7008             STRB     R0,[R1, #+0]
   \   00000B06   0xF8A4 0x5104      STRH     R5,[R4, #+260]
   \   00000B0A   0xF8C4 0x5138      STR      R5,[R4, #+312]
   \   00000B0E   0xF8C4 0x513C      STR      R5,[R4, #+316]
   \   00000B12   0xF8A4 0x511C      STRH     R5,[R4, #+284]
   \   00000B16   0xB001             ADD      SP,SP,#+4
   \   00000B18   0xF8B4 0x012A      LDRH     R0,[R4, #+298]
   \   00000B1C   0xF8B4 0x1102      LDRH     R1,[R4, #+258]
   \   00000B20   0xF8A4 0x0110      STRH     R0,[R4, #+272]
   \   00000B24   0x1808             ADDS     R0,R1,R0
   \   00000B26   0xF8A4 0x012A      STRH     R0,[R4, #+298]
   \   00000B2A   0x4628             MOV      R0,R5
   \   00000B2C   0xBD30             POP      {R4,R5,PC}
   \                     ??Rs232MasterCommunication_51: (+1)
   \   00000B2E   0xF8B4 0x012A      LDRH     R0,[R4, #+298]
   \   00000B32   0xF8B4 0x2110      LDRH     R2,[R4, #+272]
   \   00000B36   0xF8B4 0x1102      LDRH     R1,[R4, #+258]
   \   00000B3A   0x1A82             SUBS     R2,R0,R2
   \   00000B3C   0xB292             UXTH     R2,R2
   \   00000B3E   0x4291             CMP      R1,R2
   \   00000B40   0xD229             BCS.N    ??Rs232MasterCommunication_3
   \   00000B42   0x21A5             MOVS     R1,#+165
   \   00000B44   0xF8A4 0x1048      STRH     R1,[R4, #+72]
   \   00000B48   0xF8A4 0x0110      STRH     R0,[R4, #+272]
   \   00000B4C   0x21EE             MOVS     R1,#+238
   \   00000B4E   0xF8A4 0x104A      STRH     R1,[R4, #+74]
   \   00000B52   0x2101             MOVS     R1,#+1
   \   00000B54   0xF8A4 0x104C      STRH     R1,[R4, #+76]
   \   00000B58   0x216A             MOVS     R1,#+106
   \   00000B5A   0xF8A4 0x104E      STRH     R1,[R4, #+78]
   \   00000B5E   0x2101             MOVS     R1,#+1
   \   00000B60   0xF8A4 0x1050      STRH     R1,[R4, #+80]
   \   00000B64   0x216A             MOVS     R1,#+106
   \   00000B66   0xF8A4 0x1052      STRH     R1,[R4, #+82]
   \   00000B6A   0x218C             MOVS     R1,#+140
   \   00000B6C   0xF8A4 0x1054      STRH     R1,[R4, #+84]
   \   00000B70   0x215E             MOVS     R1,#+94
   \   00000B72   0xF8A4 0x1056      STRH     R1,[R4, #+86]
   \   00000B76   0x2108             MOVS     R1,#+8
   \   00000B78   0xF8A4 0x1106      STRH     R1,[R4, #+262]
   \   00000B7C   0xF8A4 0x1108      STRH     R1,[R4, #+264]
   \   00000B80   0xE008             B.N      ??Rs232MasterCommunication_52
   \                     ??Rs232MasterCommunication_53: (+1)
   \   00000B82   0xF104 0x0048      ADD      R0,R4,#+72
   \   00000B86   0x.... 0x....      BL       MakeInfoPacket
   \   00000B8A   0xF8A4 0x0106      STRH     R0,[R4, #+262]
   \   00000B8E   0x2001             MOVS     R0,#+1
   \                     ??Rs232MasterCommunication_29: (+1)
   \   00000B90   0xF8A4 0x0108      STRH     R0,[R4, #+264]
   \                     ??Rs232MasterCommunication_52: (+1)
   \   00000B94   0x2502             MOVS     R5,#+2
   \                     ??Rs232MasterCommunication_3: (+1)
   \   00000B96   0x4628             MOV      R0,R5
   \   00000B98   0xB001             ADD      SP,SP,#+4
   \   00000B9A   0xBD30             POP      {R4,R5,PC}       ;; return
   1370          }
   1371          
   1372          
   1373          //---------------------------------------------------------------------------------------------------------------------
   1374          /**
   1375           *  @brief      Check Resend Packet
   1376           *
   1377           *  @ref        MOD_SMI_1
   1378           *  @ref        MOD_SMI_3
   1379           *
   1380           *  @param      resend_on_error - Receiving error state (0 -> OK, !=0 -> KO)
   1381           *  @return     Transmission state
   1382           *              - MASTER_COMMUNICATION_NEW_PACKET_READY: a new packet can be transmitted
   1383           *              - MASTER_COMMUNICATION_STANDBY: transmission is waiting
   1384           */

   \                                 In section .text, align 4, keep-with-next
   1385          MASTER_COMMUNICATION_RETURNS_E_TYPE CheckResendPacket(uint16 resend_on_error)
   1386          {
   \                     CheckResendPacket: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   1387              MASTER_COMMUNICATION_RETURNS_E_TYPE comm_state;
   1388          
   1389              uint32  ram_write_address;
   1390              uint16  ram_write_data;
   1391              uint32  ram_read_start;
   1392              uint32  ram_read_end;
   1393              uint16  extra_request_lo;
   1394              uint16  extra_request_hi;
   1395              sint16  buf_ptr_shift;
   1396              uint16  temp_ptr;
   1397              uint16  i;
   1398          
   1399              Bytes_To_Transmit=0;
   \   00000002   0x....             LDR.N    R4,??DataTable6
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0xF8A4 0x1106      STRH     R1,[R4, #+262]
   1400              Bytes_To_Receive =0;
   \   0000000C   0xF8A4 0x1108      STRH     R1,[R4, #+264]
   1401          
   1402              if(resend_on_error == 0)
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xF040 0x8129      BNE.W    ??CheckResendPacket_1
   1403              {
   1404                  Attempts=0;
   \   00000016   0xF8A4 0x0116      STRH     R0,[R4, #+278]
   1405          
   1406                  switch (Send_Buffer[TOKEN_PACKET_SEND_TYPE])
   \   0000001A   0xF8B4 0x004E      LDRH     R0,[R4, #+78]
   \   0000001E   0x284A             CMP      R0,#+74
   \   00000020   0xD006             BEQ.N    ??CheckResendPacket_2
   \   00000022   0x286A             CMP      R0,#+106
   \   00000024   0xD075             BEQ.N    ??CheckResendPacket_3
   \   00000026   0x286B             CMP      R0,#+107
   \   00000028   0xD067             BEQ.N    ??CheckResendPacket_4
   1407                  {
   1408                      case READ_SETTINGFILE_DATA_TYPE_BYTE:
   1409          
   1410                          if (Master_Comm_Flags > DISPLDATA)
   1411                          {
   1412          
   1413          #ifndef MOTOR_SBPM_FLOAT
   1414          
   1415                              if (Master_Comm_Flags == TRIPHASEDATA_2)
   1416                              {
   1417                                  Set_File_Table = (uint16 *)Params__GetSFApp();
   1418                              }
   1419          
   1420                              if ((Set_File_All_Crc == *(Set_File_Table))||(Master_Comm_Flags == TRIPHASEDATA_1))  // checksum on buffer
   1421          #else
   1422                              if(1) //Setting File Crc check is skipped
   1423          #endif
   1424                              {
   1425                                  //---------------------------------------------------------------------------------------
   1426          
   1427                                  if(Receive_Buffer[READFLASH_RECEIVE_LENGTH] < Min_Params_Num)
   1428                                  {// the number of parameters is less then the minimum expected  --> fault!
   1429                                      Fault = (FAULT_ENUM_TYPE)((uint16)INVALID_SETFILE_LENGTH + Master_Comm_Flags - DISPLDATA);
   1430                                      Master_Comm_Flags=TOKEN;
   1431          
   1432                                      break;
   1433                                  }
   1434          
   1435                                  switch (Master_Comm_Flags)
   1436                                  {
   1437          
   1438          #ifndef MOTOR_SBPM_FLOAT
   1439          
   1440                                      case SAFETYDATA:
   1441                                          #if (APPLIANCE_TYPE == APPLIANCE_TYPE_DISHWASHER)
   1442                                              Master_Comm_Flags = TRIPHASEDATA;
   1443                                          #else
   1444                                              Master_Comm_Flags = TRIPHASEDATA_1;
   1445                                          #endif //#if (APPLIANCE_TYPE == APPLIANCE_TYPE_DISHWASHER)
   1446                                          break;
   1447          
   1448                                      case TRIPHASEDATA:
   1449                                          Master_Comm_Flags = MODULEDATA;
   1450                                          break;
   1451          
   1452                                      case TRIPHASEDATA_1:
   1453                                          Master_Comm_Flags = TRIPHASEDATA_2;
   1454                                          Crc_Application_1 = Set_File_All_Crc;
   1455                                          break;
   1456          
   1457                                      case TRIPHASEDATA_2:
   1458          								#ifdef MOTOR_BPM_TYPE
   1459                                      	Master_Comm_Flags = MCISAFETYDATA;
   1460          								#else
   1461                                      	Master_Comm_Flags = MLIMITDATA;
   1462          								#endif
   1463                                          break;
   1464          
   1465                                      case MODULEDATA:
   1466          								Master_Comm_Flags = SETTINGFILELOADED;
   1467          								break;
   1468          
   1469                                      case MLIMITDATA:
   1470                                          Master_Comm_Flags = MCISAFETYDATA;
   1471                                          break;
   1472          
   1473                                      case MCISAFETYDATA:
   1474                                          Master_Comm_Flags = SETTINGFILELOADED;
   1475                                          break;
   1476          #else
   1477                                      case SBPM_FLOAT_DTC_CONTROL_1:
   1478                                          Master_Comm_Flags = SBPM_FLOAT_DTC_CONTROL_2;
   1479                                          break;
   1480          
   1481                                      case SBPM_FLOAT_DTC_CONTROL_2:
   1482                                          Master_Comm_Flags = SBPM_FLOAT_MOTOR_LUT;
   1483                                          break;
   1484          
   1485                                      case SBPM_FLOAT_MOTOR_LUT:
   1486                                          Master_Comm_Flags = SBPM_FLOAT_SPEED_CTRL;
   1487                                          break;
   1488          
   1489                                      case SBPM_FLOAT_SPEED_CTRL:
   1490                                          Master_Comm_Flags = TOKEN;
   1491                                          //Setting file loading is interrupted by a TOKEN-COMMAND-INFO-ACK sequence in order to reset the ACU timeout (2 s).
   1492                                          Setting_File_Loading_Interrupted = TRUE; 
   1493                                          break;
   1494          
   1495                                      case SBPM_FLOAT_MTPA_LUT:
   1496                                          Master_Comm_Flags = SBPM_FLOAT_MTPV_LUT;
   1497                                          break;
   1498          
   1499                                      case SBPM_FLOAT_MTPV_LUT:
   1500                                          Master_Comm_Flags = SBPM_FLOAT_OTE;
   1501                                          break;
   1502          
   1503                                      case SBPM_FLOAT_OTE:
   1504                                          Master_Comm_Flags = SBPM_FLOAT_SR_MOTOR;
   1505                                          break;
   1506          
   1507                                      case SBPM_FLOAT_SR_MOTOR:
   1508                                          Master_Comm_Flags = SBPM_FLOAT_MCA_SET_WM;
   1509                                          break;
   1510          
   1511                                      case SBPM_FLOAT_MCA_SET_WM:
   1512                                          Master_Comm_Flags = SBPM_FLOAT_MCA_SENSOR_WM;
   1513                                          break;
   1514          
   1515                                      case SBPM_FLOAT_MCA_SENSOR_WM:
   1516                                          Master_Comm_Flags = SETTINGFILELOADED;
   1517                                          break;
   1518          #endif
   1519                                      default:
   1520                                          break;
   1521                                  }
   1522                              }
   1523                              else
   1524                              {
   1525                                  Fault = (FAULT_ENUM_TYPE)((uint16)INVALID_SETFILE_CRC + Master_Comm_Flags - DISPLDATA);
   1526                                  Master_Comm_Flags = TOKEN;
   1527                              }
   1528                          }
   1529                          else
   1530                          {	   // we receive Displacement data
   1531          #ifndef MOTOR_SBPM_FLOAT
   1532                              Master_Comm_Flags = SAFETYDATA;
   1533          #else
   1534                              Master_Comm_Flags = SBPM_FLOAT_DTC_CONTROL_1;
   1535          #endif
   1536                          }
   1537          
   1538                          break;
   1539          
   1540                      case INFO_TYPE_BYTE:
   1541          
   1542                          //---------------------------------------------------------------------------------------
   1543          
   1544                          #ifndef INTERNAL_PARAMS
   1545                              // multiple loads: check the load and send the right packet - begin
   1546                              if((HIBYTE(FaultManager__GetFaultToPublish()) == 0x09) || (FaultManager__GetFaultToPublish()== MODULETYPE_NET_FAULT) ||(Params__IsReady() == TRUE))
   1547                              {// we have already loaded the setting file or we are choosing the correct load
   1548                                  Master_Comm_Flags = TOKEN;            // send the TOKEN packet
   1549                              }
   1550                              else
   1551                              {// we have to load the setting file (<--> sFlags.TriphaseParamsReadFlag == 1)
   1552          
   1553                                  if(Setting_File_Loading_Interrupted == TRUE)
   1554                                  {
   1555                                      Setting_File_Loading_Interrupted = FALSE;
   1556                                      Master_Comm_Flags = SBPM_FLOAT_MTPA_LUT;    // send the TRIPHASEDATA packet
   1557                                  }
   1558                                  else
   1559                                  {
   1560                                      Master_Comm_Flags = DISPLDATA;              // send the TRIPHASEDATA packet
   1561                                  }
   1562                              }
   1563                              // multiple loads: check the load and send the right packet - end
   1564                          #else
   1565                              // Info sending finished..., wait for next token
   1566                              Master_Comm_Flags = TOKEN;
   1567                          #endif
   1568                          if (Com_Safety_Flags == 0x0001)
   1569                          {     // Received ACK after INFO
   1570                              Com_Safety_Flags = 0;
   1571                          }
   1572                          else
   1573                          {    // sequence is not correct: reset only the flags, but not reset the counter
   1574                              Com_Safety_Flags = 0x000F;
   1575                          }
   1576                          break;
   1577          
   1578                      case TOKEN_TYPE_BYTE:
   1579          
   1580                          // Check if resend token for the second time & Read Data
   1581                          Seq_ID                          = (Receive_Buffer[TOKEN_PACKET_RECEIVE_SEQUENCE_ID]);
   1582          
   1583          #if (COMMAND_MODE==MAIN_uC)
   1584                          Command_Data_L1.Speed          =  (sint16)((Receive_Buffer[TOKEN_PACKET_RECEIVE_SPEEDHI_L1] << 8) + (Receive_Buffer[TOKEN_PACKET_RECEIVE_SPEEDLO_L1]));
   1585                          Command_Data_L1.Ramp_Time      = (Receive_Buffer[TOKEN_PACKET_RECEIVE_TIMEHI_L1]  << 8) + (Receive_Buffer[TOKEN_PACKET_RECEIVE_TIMELO_L1]);
   1586                          Command_Data_L1.Cmd_Flags      = (Receive_Buffer[TOKEN_PACKET_RECEIVE_FLAGSHI_L1] << 8) + (Receive_Buffer[TOKEN_PACKET_RECEIVE_FLAGSLO_L1]);
   1587          #endif
   1588                          Command_Data_L1.Data_Type      = (Receive_Buffer[TOKEN_PACKET_RECEIVE_PILOT_TYPE_L1]);
   1589                          Displ_Sf_Params_L1              = (Receive_Buffer[TOKEN_PACKET_RECEIVE_DISPL_SF_PARAMS_L1]);
   1590          
   1591                          Ram_Read_Start_Address_Ptr = NULL;
   1592                          Ram_Read_End_Address_Ptr   = NULL;
   1593          
   1594                          // DYNAMIC LOAD COMMAND PACKET
   1595                          Dyn_Packet = 0;//  --> one load
   1596                          if ((Receive_Buffer[TOKEN_PACKET_RECEIVE_LENGTH]>TOKEN_PACKET_RECEIVE_PILOT_TYPE_L2-TOKEN_PACKET_RECEIVE_SEQUENCE_ID) &&
   1597                              (Receive_Buffer[TOKEN_PACKET_RECEIVE_PILOT_TYPE_L2] != DATA_TYPE_RAM))
   1598                          {
   1599          #if (COMMAND_MODE==MAIN_uC)
   1600                          	// save Speed, Time and Flags of Load2
   1601                              Command_Data_L2.Speed      = (sint16)((Receive_Buffer[TOKEN_PACKET_RECEIVE_SPEEDHI_L2] << 8) + Receive_Buffer[TOKEN_PACKET_RECEIVE_SPEEDLO_L2]);
   1602                              Command_Data_L2.Ramp_Time  = ((Receive_Buffer[TOKEN_PACKET_RECEIVE_TIMEHI_L2]  << 8) + Receive_Buffer[TOKEN_PACKET_RECEIVE_TIMELO_L2]);
   1603                              Command_Data_L2.Cmd_Flags  = ((Receive_Buffer[TOKEN_PACKET_RECEIVE_FLAGSHI_L2] << 8) + Receive_Buffer[TOKEN_PACKET_RECEIVE_FLAGSLO_L2]);
   1604          #endif
   1605                              // save PilotType and Displacement of Load2
   1606                              Command_Data_L2.Data_Type  = Receive_Buffer[TOKEN_PACKET_RECEIVE_PILOT_TYPE_L2];
   1607                              Displ_Sf_Params_L2          = Receive_Buffer[TOKEN_PACKET_RECEIVE_DISPL_SF_PARAMS_L2];
   1608                              buf_ptr_shift = 0;
   1609                              Dyn_Packet = 1;  // --> Two loads
   1610                          }
   1611                          else
   1612                          {
   1613                              buf_ptr_shift = (uint16)(TOKEN_PACKET_RECEIVE_PILOT_TYPE_L2 - TOKEN_PACKET_RECEIVE_DATATYPERAM);
                                                     ^
Warning[Pe068]: integer conversion resulted in a change of sign

      uint16  i;
              ^
"C:\Data\Python\Windy_sBpm_Floating\source\Category\Application\ProtocolMainExternal\ProtocolMainExternal.c",1397  Warning[Pe177]: 
          variable "i" was declared but never referenced

  static uint16 SafetyParamsBuffer[MINIMUM_MCISAFETY_PARAMS_NUM/2];
                ^
"C:\Data\Python\Windy_sBpm_Floating\source\Category\Application\ProtocolMainExternal\ProtocolMainExternal.c",347  Warning[Pe177]: 
          variable "SafetyParamsBuffer" was declared but never referenced

  static uint16 Params_Displ;
                ^
"C:\Data\Python\Windy_sBpm_Floating\source\Category\Application\ProtocolMainExternal\ProtocolMainExternal.c",366  Warning[Pe177]: 
          variable "Params_Displ" was declared but never referenced

  static uint16 Params_Displ_2;
                ^
"C:\Data\Python\Windy_sBpm_Floating\source\Category\Application\ProtocolMainExternal\ProtocolMainExternal.c",367  Warning[Pe177]: 
          variable "Params_Displ_2" was declared but never referenced

  static uint16 Buff_Safety_Displ;
                ^
"C:\Data\Python\Windy_sBpm_Floating\source\Category\Application\ProtocolMainExternal\ProtocolMainExternal.c",392  Warning[Pe550]: 
          variable "Buff_Safety_Displ" was set but never used

  static uint16 Setting_File_Loading_Interrupted;
                ^
"C:\Data\Python\Windy_sBpm_Floating\source\Category\Application\ProtocolMainExternal\ProtocolMainExternal.c",395  Warning[Pe550]: 
          variable "Setting_File_Loading_Interrupted" was set but never used

  static uint16 Module_Type;
                ^
"C:\Data\Python\Windy_sBpm_Floating\source\Category\Application\ProtocolMainExternal\ProtocolMainExternal.c",401  Warning[Pe177]: 
          variable "Module_Type" was declared but never referenced

  static uint16 Modules_Displ;
                ^
"C:\Data\Python\Windy_sBpm_Floating\source\Category\Application\ProtocolMainExternal\ProtocolMainExternal.c",402  Warning[Pe177]: 
          variable "Modules_Displ" was declared but never referenced

  static uint16 Displ_Sf_Params_L1;
                ^
"C:\Data\Python\Windy_sBpm_Floating\source\Category\Application\ProtocolMainExternal\ProtocolMainExternal.c",403  Warning[Pe550]: 
          variable "Displ_Sf_Params_L1" was set but never used

  static uint16 Displ_Sf_Params_L2;
                ^
"C:\Data\Python\Windy_sBpm_Floating\source\Category\Application\ProtocolMainExternal\ProtocolMainExternal.c",404  Warning[Pe550]: 
          variable "Displ_Sf_Params_L2" was set but never used

  static PARSER_RETURNS_E_TYPE DisplProcessing(void);
                               ^
"C:\Data\Python\Windy_sBpm_Floating\source\Category\Application\ProtocolMainExternal\ProtocolMainExternal.c",433  Warning[Pe177]: 
          function "DisplProcessing" was declared but never referenced

  static void DecodeLoadType(void);
              ^
"C:\Data\Python\Windy_sBpm_Floating\source\Category\Application\ProtocolMainExternal\ProtocolMainExternal.c",434  Warning[Pe177]: 
          function "DecodeLoadType" was declared but never referenced

  static void InitPumps(void);
              ^
"C:\Data\Python\Windy_sBpm_Floating\source\Category\Application\ProtocolMainExternal\ProtocolMainExternal.c",435  Warning[Pe177]: 
          function "InitPumps" was declared but never referenced
   1614                          }
   1615          
   1616                          if (Receive_Buffer[TOKEN_PACKET_RECEIVE_LENGTH]>TOKEN_PACKET_RECEIVE_EXTRAREQUESTHI-TOKEN_PACKET_RECEIVE_SEQUENCE_ID+buf_ptr_shift)
   1617                          {// an ExtraRequest has been requested
   1618                              temp_ptr = TOKEN_PACKET_RECEIVE_EXTRAREQUESTHI+buf_ptr_shift;
   1619                              extra_request_hi=Receive_Buffer[temp_ptr++];
   1620                              extra_request_lo=Receive_Buffer[temp_ptr]>>1;
   1621          
   1622                              if (extra_request_hi==1)
   1623                              {
   1624                                  if ((extra_request_lo == 0)||(extra_request_lo > MAXIMUM_READABLE_RAM_LOCATIONS_INFO_WORDS * 2))
   1625                                  {
   1626                                      extra_request_lo = MAXIMUM_READABLE_RAM_LOCATIONS_INFO_WORDS;
   1627                                  }
   1628          
   1629                                  //Ram_Read_Start_Address_Ptr = (uint16*)&(IdentTable);
   1630                                  Ram_Read_Start_Address_Ptr = (uint16*)ProtocolInfo__GetIdent();
   1631                                  Ram_Read_End_Address_Ptr   = Ram_Read_Start_Address_Ptr + (extra_request_lo - 1);
   1632          
   1633                              }
   1634                          }
   1635                          else if (Receive_Buffer[TOKEN_PACKET_RECEIVE_LENGTH]>TOKEN_PACKET_RECEIVE_DATATYPERAM-TOKEN_PACKET_RECEIVE_SEQUENCE_ID+buf_ptr_shift)
   1636                          {// a RAM Read has been requested
   1637          
   1638                              temp_ptr = TOKEN_PACKET_RECEIVE_RAMREADSTARTHI+buf_ptr_shift;
   1639                              ram_read_start = Receive_Buffer[temp_ptr++]<<8;
   1640                              ram_read_start += Receive_Buffer[temp_ptr++];
   1641          
   1642                              // temp_ptr point to TOKEN_PACKET_RECEIVE_RAMREADENDHI
   1643                              ram_read_end  = Receive_Buffer[temp_ptr++]<<8;
   1644                              ram_read_end += Receive_Buffer[temp_ptr];
   1645          
   1646          #if (uP_MODEL == uP_MODEL_MK3)
   1647                              // Workaround for the KV30 memory map
   1648                              // SRAM is in the range 0x1FFF_E000-0x2000_1FFF but we have only
   1649                              // 16 bit for the address specification in the protocol
   1650                              ram_read_start = TranslateAddress(ram_read_start<<1);
   1651                              ram_read_end = TranslateAddress(ram_read_end<<1);
   1652          #endif /* uP_MODEL_MK3 */
   1653          
   1654                              if((ram_read_start>=MIN_READABLE_ADDRESS) && (ram_read_end<=MAX_READABLE_ADDRESS) && ((ram_read_end-ram_read_start) < MAX_DELAY_BETWEEN_RAM_ADDRESS))
   1655                              {
   1656                                  Ram_Read_Start_Address_Ptr = (uint16 *) ram_read_start;
   1657                                  Ram_Read_End_Address_Ptr   = (uint16 *) ram_read_end;
   1658                              }
   1659          
   1660          
   1661                              if (Receive_Buffer[TOKEN_PACKET_RECEIVE_LENGTH]>TOKEN_PACKET_RECEIVE_RAMWRITEADDRESSHI-TOKEN_PACKET_RECEIVE_SEQUENCE_ID+buf_ptr_shift)
   1662                              {// a RAM Write has been requested
   1663                                  temp_ptr = TOKEN_PACKET_RECEIVE_RAMWRITEADDRESSHI+buf_ptr_shift;
   1664                                  ram_write_address = Receive_Buffer[temp_ptr++]<<8;
   1665                                  ram_write_address += Receive_Buffer[temp_ptr++];
   1666          #if (uP_MODEL == uP_MODEL_MK3)
   1667                                  ram_write_address = TranslateAddress(ram_write_address<<1);
   1668          #endif /* uP_MODEL_MK3 */
   1669                                  // temp_ptr point to TOKEN_PACKET_RECEIVE_RAMWRITEDATAHI
   1670                                  ram_write_data = Receive_Buffer[temp_ptr++]<<8;
   1671                                  ram_write_data += Receive_Buffer[temp_ptr];
   1672          
   1673                                  // execute WRITE RAM Request
   1674                                  if ((ram_write_address<=MAX_READABLE_ADDRESS) && (ram_write_address>=MIN_READABLE_ADDRESS))
   1675                                  {
   1676                                      *(uint16*) ram_write_address = ram_write_data;
   1677                                  }
   1678                              }
   1679                          }
   1680          
   1681                          // Token OK....
   1682                          Master_Comm_Flags=INFO;
   1683          
   1684                          //---------------------------------------------------------------------------------------
   1685          
   1686                          if (Com_Safety_Flags == 0x0007)
   1687                          { /* Received COMMAND after TOKEN */
   1688                              Com_Safety_Flags = 0x0003;
   1689                          }
   1690                          break;
   1691          
   1692                      default:
   1693                          break;
   1694                  }
   1695          
   1696                  comm_state = MASTER_COMMUNICATION_NEW_PACKET_READY;
   \   0000002A   0x2003             MOVS     R0,#+3
   1697              }
   1698              else
   1699              {
   1700                  Attempts++;
   1701                  COM_Global_Attempts++;
   1702          
   1703                  // Resend the same packet due to communication error
   1704          
   1705                 // ---------------------------------------------------------------------------------------
   1706          
   1707                  if (Attempts>MASTER_COMMUNICATION_MAX_RESEND_PACKET)
   1708                  {
   1709                      if(Send_Buffer[TOKEN_PACKET_SEND_TYPE] == READ_SETTINGFILE_DATA_TYPE_BYTE)
   1710                      {
   1711                          Fault = (FAULT_ENUM_TYPE)((uint16)SETFILE_NOT_LOADED +  Master_Comm_Flags - DISPLDATA);
   1712                      }
   1713          
   1714                      Master_Comm_Flags=TOKEN;
   1715                  }
   1716          
   1717                  if (resend_on_error == 1)
   1718                  {
   1719                      Error_Delay  = ERROR_DELAY_TIME;      // no error delay in case of receive timeout (ResendOnError ==2)
   1720                  }
   1721                  comm_state = MASTER_COMMUNICATION_STANDBY;
   1722              }
   1723          
   1724              return comm_state;
   \   0000002C   0xB001             ADD      SP,SP,#+4
   \   0000002E   0xBD30             POP      {R4,R5,PC}
   \                     ??CheckResendPacket_2: (+1)
   \   00000030   0xF9B4 0x0104      LDRSH    R0,[R4, #+260]
   \   00000034   0x2804             CMP      R0,#+4
   \   00000036   0xDB5A             BLT.N    ??CheckResendPacket_5
   \   00000038   0x8961             LDRH     R1,[R4, #+10]
   \   0000003A   0xF8B4 0x211E      LDRH     R2,[R4, #+286]
   \   0000003E   0x4291             CMP      R1,R2
   \   00000040   0xD209             BCS.N    ??CheckResendPacket_6
   \   00000042   0xF600 0x108D      ADDW     R0,R0,#+2445
   \   00000046   0xF8A4 0x0134      STRH     R0,[R4, #+308]
   \   0000004A   0xB001             ADD      SP,SP,#+4
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xF8A4 0x0104      STRH     R0,[R4, #+260]
   \   00000052   0x2003             MOVS     R0,#+3
   \   00000054   0xBD30             POP      {R4,R5,PC}
   \                     ??CheckResendPacket_6: (+1)
   \   00000056   0x380B             SUBS     R0,R0,#+11
   \   00000058   0x2809             CMP      R0,#+9
   \   0000005A   0xF200 0x8102      BHI.W    ??CheckResendPacket_7
   \   0000005E   0xE8DF 0xF010      TBH      [PC, R0, LSL #+1]
   \                     ??CheckResendPacket_0:
   \   00000062   0x000A 0x0010      DC16     0xA,0x10,0x16,0x1C
   \              0x0016 0x001C
   \   0000006A   0x0022 0x0028      DC16     0x22,0x28,0x2E,0x34
   \              0x002E 0x0034
   \   00000072   0x003A 0x0040      DC16     0x3A,0x40
   \                     ??CheckResendPacket_8: (+1)
   \   00000076   0x200C             MOVS     R0,#+12
   \   00000078   0xF8A4 0x0104      STRH     R0,[R4, #+260]
   \   0000007C   0xB001             ADD      SP,SP,#+4
   \   0000007E   0x2003             MOVS     R0,#+3
   \   00000080   0xBD30             POP      {R4,R5,PC}
   \                     ??CheckResendPacket_9: (+1)
   \   00000082   0x200D             MOVS     R0,#+13
   \   00000084   0xF8A4 0x0104      STRH     R0,[R4, #+260]
   \   00000088   0xB001             ADD      SP,SP,#+4
   \   0000008A   0x2003             MOVS     R0,#+3
   \   0000008C   0xBD30             POP      {R4,R5,PC}
   \                     ??CheckResendPacket_10: (+1)
   \   0000008E   0x200E             MOVS     R0,#+14
   \   00000090   0xF8A4 0x0104      STRH     R0,[R4, #+260]
   \   00000094   0xB001             ADD      SP,SP,#+4
   \   00000096   0x2003             MOVS     R0,#+3
   \   00000098   0xBD30             POP      {R4,R5,PC}
   \                     ??CheckResendPacket_11: (+1)
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xF8A4 0x0104      STRH     R0,[R4, #+260]
   \   000000A0   0xB001             ADD      SP,SP,#+4
   \   000000A2   0x2003             MOVS     R0,#+3
   \   000000A4   0xBD30             POP      {R4,R5,PC}
   \                     ??CheckResendPacket_12: (+1)
   \   000000A6   0x2010             MOVS     R0,#+16
   \   000000A8   0xF8A4 0x0104      STRH     R0,[R4, #+260]
   \   000000AC   0xB001             ADD      SP,SP,#+4
   \   000000AE   0x2003             MOVS     R0,#+3
   \   000000B0   0xBD30             POP      {R4,R5,PC}
   \                     ??CheckResendPacket_13: (+1)
   \   000000B2   0x2011             MOVS     R0,#+17
   \   000000B4   0xF8A4 0x0104      STRH     R0,[R4, #+260]
   \   000000B8   0xB001             ADD      SP,SP,#+4
   \   000000BA   0x2003             MOVS     R0,#+3
   \   000000BC   0xBD30             POP      {R4,R5,PC}
   \                     ??CheckResendPacket_14: (+1)
   \   000000BE   0x2012             MOVS     R0,#+18
   \   000000C0   0xF8A4 0x0104      STRH     R0,[R4, #+260]
   \   000000C4   0xB001             ADD      SP,SP,#+4
   \   000000C6   0x2003             MOVS     R0,#+3
   \   000000C8   0xBD30             POP      {R4,R5,PC}
   \                     ??CheckResendPacket_15: (+1)
   \   000000CA   0x2013             MOVS     R0,#+19
   \   000000CC   0xF8A4 0x0104      STRH     R0,[R4, #+260]
   \   000000D0   0xB001             ADD      SP,SP,#+4
   \   000000D2   0x2003             MOVS     R0,#+3
   \   000000D4   0xBD30             POP      {R4,R5,PC}
   \                     ??CheckResendPacket_16: (+1)
   \   000000D6   0x2014             MOVS     R0,#+20
   \   000000D8   0xF8A4 0x0104      STRH     R0,[R4, #+260]
   \   000000DC   0xB001             ADD      SP,SP,#+4
   \   000000DE   0x2003             MOVS     R0,#+3
   \   000000E0   0xBD30             POP      {R4,R5,PC}
   \                     ??CheckResendPacket_17: (+1)
   \   000000E2   0x2002             MOVS     R0,#+2
   \   000000E4   0xF8A4 0x0104      STRH     R0,[R4, #+260]
   \   000000E8   0xB001             ADD      SP,SP,#+4
   \   000000EA   0x2003             MOVS     R0,#+3
   \   000000EC   0xBD30             POP      {R4,R5,PC}
   \                     ??CheckResendPacket_5: (+1)
   \   000000EE   0x200B             MOVS     R0,#+11
   \   000000F0   0xF8A4 0x0104      STRH     R0,[R4, #+260]
   \   000000F4   0xB001             ADD      SP,SP,#+4
   \   000000F6   0x2003             MOVS     R0,#+3
   \   000000F8   0xBD30             POP      {R4,R5,PC}
   \                     ??CheckResendPacket_4: (+1)
   \   000000FA   0xF8B4 0x011C      LDRH     R0,[R4, #+284]
   \   000000FE   0xF8A4 0x1104      STRH     R1,[R4, #+260]
   \   00000102   0x2801             CMP      R0,#+1
   \   00000104   0xBF08             IT       EQ 
   \   00000106   0xF8A4 0x111C      STRHEQ   R1,[R4, #+284]
   \   0000010A   0xF000 0x80AA      BEQ.W    ??CheckResendPacket_7
   \   0000010E   0x200F             MOVS     R0,#+15
   \   00000110   0xE0A5             B.N      ??CheckResendPacket_18
   \                     ??CheckResendPacket_3: (+1)
   \   00000112   0x89A0             LDRH     R0,[R4, #+12]
   \   00000114   0xF8A4 0x011A      STRH     R0,[R4, #+282]
   \   00000118   0x2200             MOVS     R2,#+0
   \   0000011A   0x89E0             LDRH     R0,[R4, #+14]
   \   0000011C   0xF8A4 0x00EE      STRH     R0,[R4, #+238]
   \   00000120   0xF8C4 0x1138      STR      R1,[R4, #+312]
   \   00000124   0xF8C4 0x113C      STR      R1,[R4, #+316]
   \   00000128   0x8960             LDRH     R0,[R4, #+10]
   \   0000012A   0x280A             CMP      R0,#+10
   \   0000012C   0xDB06             BLT.N    ??CheckResendPacket_19
   \   0000012E   0x8BE1             LDRH     R1,[R4, #+30]
   \   00000130   0xB121             CBZ.N    R1,??CheckResendPacket_19
   \   00000132   0xF8A4 0x10F6      STRH     R1,[R4, #+246]
   \   00000136   0x2201             MOVS     R2,#+1
   \   00000138   0x2100             MOVS     R1,#+0
   \   0000013A   0xE001             B.N      ??CheckResendPacket_20
   \                     ??CheckResendPacket_19: (+1)
   \   0000013C   0xF06F 0x0107      MVN      R1,#+7
   \                     ??CheckResendPacket_20: (+1)
   \   00000140   0xF8A4 0x2132      STRH     R2,[R4, #+306]
   \   00000144   0xF101 0x021A      ADD      R2,R1,#+26
   \   00000148   0x4282             CMP      R2,R0
   \   0000014A   0xDA19             BGE.N    ??CheckResendPacket_21
   \   0000014C   0xF101 0x0220      ADD      R2,R1,#+32
   \   00000150   0x1C50             ADDS     R0,R2,#+1
   \   00000152   0xB280             UXTH     R0,R0
   \   00000154   0xF834 0x0010      LDRH     R0,[R4, R0, LSL #+1]
   \   00000158   0x0845             LSRS     R5,R0,#+1
   \   0000015A   0xB292             UXTH     R2,R2
   \   0000015C   0xF834 0x0012      LDRH     R0,[R4, R2, LSL #+1]
   \   00000160   0x2801             CMP      R0,#+1
   \   00000162   0xD174             BNE.N    ??CheckResendPacket_22
   \   00000164   0xB10D             CBZ.N    R5,??CheckResendPacket_23
   \   00000166   0x2D21             CMP      R5,#+33
   \   00000168   0xDB00             BLT.N    ??CheckResendPacket_24
   \                     ??CheckResendPacket_23: (+1)
   \   0000016A   0x2510             MOVS     R5,#+16
   \                     ??CheckResendPacket_24: (+1)
   \   0000016C   0x.... 0x....      BL       ProtocolInfo__GetIdent
   \   00000170   0xF8C4 0x0138      STR      R0,[R4, #+312]
   \   00000174   0xEB00 0x0045      ADD      R0,R0,R5, LSL #+1
   \   00000178   0x1E80             SUBS     R0,R0,#+2
   \   0000017A   0xF8C4 0x013C      STR      R0,[R4, #+316]
   \   0000017E   0xE066             B.N      ??CheckResendPacket_22
   \                     ??CheckResendPacket_21: (+1)
   \   00000180   0xF101 0x0211      ADD      R2,R1,#+17
   \   00000184   0x4282             CMP      R2,R0
   \   00000186   0xDA62             BGE.N    ??CheckResendPacket_22
   \   00000188   0xF101 0x0218      ADD      R2,R1,#+24
   \   0000018C   0xB292             UXTH     R2,R2
   \   0000018E   0xF834 0x3012      LDRH     R3,[R4, R2, LSL #+1]
   \   00000192   0x1C52             ADDS     R2,R2,#+1
   \   00000194   0xB292             UXTH     R2,R2
   \   00000196   0xF834 0x5012      LDRH     R5,[R4, R2, LSL #+1]
   \   0000019A   0x021B             LSLS     R3,R3,#+8
   \   0000019C   0xFA13 0xF385      UXTAH    R3,R3,R5
   \   000001A0   0x1C52             ADDS     R2,R2,#+1
   \   000001A2   0x005B             LSLS     R3,R3,#+1
   \   000001A4   0xF5B3 0x4F60      CMP      R3,#+57344
   \   000001A8   0xBF39             ITTEE    CC 
   \   000001AA   0xF5B3 0x5F00      CMPCC    R3,#+8192
   \   000001AE   0xF103 0x5300      ADDCC    R3,R3,#+536870912
   \   000001B2   0x....             LDRCS.N  R5,??DataTable7_2  ;; 0x1fff0000
   \   000001B4   0x18EB             ADDCS    R3,R5,R3
   \   000001B6   0xB292             UXTH     R2,R2
   \   000001B8   0xF834 0x5012      LDRH     R5,[R4, R2, LSL #+1]
   \   000001BC   0x1C52             ADDS     R2,R2,#+1
   \   000001BE   0xB292             UXTH     R2,R2
   \   000001C0   0xF834 0x2012      LDRH     R2,[R4, R2, LSL #+1]
   \   000001C4   0x022D             LSLS     R5,R5,#+8
   \   000001C6   0xFA15 0xF282      UXTAH    R2,R5,R2
   \   000001CA   0x0052             LSLS     R2,R2,#+1
   \   000001CC   0xF5B2 0x4F60      CMP      R2,#+57344
   \   000001D0   0xBF39             ITTEE    CC 
   \   000001D2   0xF5B2 0x5F00      CMPCC    R2,#+8192
   \   000001D6   0xF102 0x5200      ADDCC    R2,R2,#+536870912
   \   000001DA   0x....             LDRCS.N  R5,??DataTable7_2  ;; 0x1fff0000
   \   000001DC   0x18AA             ADDCS    R2,R5,R2
   \   000001DE   0x....             LDR.N    R5,??DataTable7_3  ;; 0x1fffe000
   \   000001E0   0x42AB             CMP      R3,R5
   \   000001E2   0xD308             BCC.N    ??CheckResendPacket_25
   \   000001E4   0xF1B2 0x2F20      CMP      R2,#+536879104
   \   000001E8   0xBF3F             ITTTT    CC 
   \   000001EA   0x1AD5             SUBCC    R5,R2,R3
   \   000001EC   0x2D20             CMPCC    R5,#+32
   \   000001EE   0xF8C4 0x3138      STRCC    R3,[R4, #+312]
   \   000001F2   0xF8C4 0x213C      STRCC    R2,[R4, #+316]
   \                     ??CheckResendPacket_25: (+1)
   \   000001F6   0xF101 0x0216      ADD      R2,R1,#+22
   \   000001FA   0x4282             CMP      R2,R0
   \   000001FC   0xDA27             BGE.N    ??CheckResendPacket_22
   \   000001FE   0xF101 0x001C      ADD      R0,R1,#+28
   \   00000202   0xB280             UXTH     R0,R0
   \   00000204   0xF834 0x1010      LDRH     R1,[R4, R0, LSL #+1]
   \   00000208   0x1C40             ADDS     R0,R0,#+1
   \   0000020A   0xB280             UXTH     R0,R0
   \   0000020C   0xF834 0x2010      LDRH     R2,[R4, R0, LSL #+1]
   \   00000210   0x0209             LSLS     R1,R1,#+8
   \   00000212   0xFA11 0xF182      UXTAH    R1,R1,R2
   \   00000216   0x1C42             ADDS     R2,R0,#+1
   \   00000218   0x0048             LSLS     R0,R1,#+1
   \   0000021A   0xF5B0 0x4F60      CMP      R0,#+57344
   \   0000021E   0xBF39             ITTEE    CC 
   \   00000220   0xF5B0 0x5F00      CMPCC    R0,#+8192
   \   00000224   0xF100 0x5000      ADDCC    R0,R0,#+536870912
   \   00000228   0x....             LDRCS.N  R1,??DataTable7_2  ;; 0x1fff0000
   \   0000022A   0x1808             ADDCS    R0,R1,R0
   \   0000022C   0xF100 0x4160      ADD      R1,R0,#-536870912
   \   00000230   0xF501 0x5100      ADD      R1,R1,#+8192
   \   00000234   0xF5B1 0x4F80      CMP      R1,#+16384
   \   00000238   0xD209             BCS.N    ??CheckResendPacket_22
   \   0000023A   0xB292             UXTH     R2,R2
   \   0000023C   0xF834 0x1012      LDRH     R1,[R4, R2, LSL #+1]
   \   00000240   0x1C52             ADDS     R2,R2,#+1
   \   00000242   0xB292             UXTH     R2,R2
   \   00000244   0xF834 0x2012      LDRH     R2,[R4, R2, LSL #+1]
   \   00000248   0xEB02 0x2101      ADD      R1,R2,R1, LSL #+8
   \   0000024C   0x8001             STRH     R1,[R0, #+0]
   \                     ??CheckResendPacket_22: (+1)
   \   0000024E   0x2001             MOVS     R0,#+1
   \   00000250   0xF8A4 0x0104      STRH     R0,[R4, #+260]
   \   00000254   0xF8B4 0x011C      LDRH     R0,[R4, #+284]
   \   00000258   0x2807             CMP      R0,#+7
   \   0000025A   0xD102             BNE.N    ??CheckResendPacket_7
   \   0000025C   0x2003             MOVS     R0,#+3
   \                     ??CheckResendPacket_18: (+1)
   \   0000025E   0xF8A4 0x011C      STRH     R0,[R4, #+284]
   \                     ??CheckResendPacket_7: (+1)
   \   00000262   0x2003             MOVS     R0,#+3
   \   00000264   0xB001             ADD      SP,SP,#+4
   \   00000266   0xBD30             POP      {R4,R5,PC}
   \                     ??CheckResendPacket_1: (+1)
   \   00000268   0xF8B4 0x1116      LDRH     R1,[R4, #+278]
   \   0000026C   0xF8B4 0x2136      LDRH     R2,[R4, #+310]
   \   00000270   0x1C49             ADDS     R1,R1,#+1
   \   00000272   0xF8A4 0x1116      STRH     R1,[R4, #+278]
   \   00000276   0x1C52             ADDS     R2,R2,#+1
   \   00000278   0xB289             UXTH     R1,R1
   \   0000027A   0xF8A4 0x2136      STRH     R2,[R4, #+310]
   \   0000027E   0x290B             CMP      R1,#+11
   \   00000280   0xDB0C             BLT.N    ??CheckResendPacket_26
   \   00000282   0xF8B4 0x104E      LDRH     R1,[R4, #+78]
   \   00000286   0x294A             CMP      R1,#+74
   \   00000288   0xD105             BNE.N    ??CheckResendPacket_27
   \   0000028A   0xF9B4 0x1104      LDRSH    R1,[R4, #+260]
   \   0000028E   0xF601 0x119D      ADDW     R1,R1,#+2461
   \   00000292   0xF8A4 0x1134      STRH     R1,[R4, #+308]
   \                     ??CheckResendPacket_27: (+1)
   \   00000296   0x2100             MOVS     R1,#+0
   \   00000298   0xF8A4 0x1104      STRH     R1,[R4, #+260]
   \                     ??CheckResendPacket_26: (+1)
   \   0000029C   0x2801             CMP      R0,#+1
   \   0000029E   0xBF04             ITT      EQ 
   \   000002A0   0xF44F 0x7048      MOVEQ    R0,#+800
   \   000002A4   0xF8A4 0x0130      STRHEQ   R0,[R4, #+304]
   \   000002A8   0x2000             MOVS     R0,#+0
   \   000002AA   0xB001             ADD      SP,SP,#+4
   \   000002AC   0xBD30             POP      {R4,R5,PC}       ;; return
   1725          }
   1726          
   1727          
   1728          //---------------------------------------------------------------------------------------------------------------------
   1729          /**
   1730           *  @brief      Check Resend Packet
   1731           *
   1732           *  @ref        MOD_SMI_2
   1733           *
   1734           *  @param      new_byte Received byte
   1735           *  @return     Parser state
   1736           *              - PARSER_STATE_RECEIVING: receiving in progress
   1737           *              - PARSER_STATE_ERROR: parsing error
   1738           *              - PARSER_STATE_COMPLETED: Packet receiving and parsing complete
   1739           */

   \                                 In section .text, align 4, keep-with-next
   1740          PARSER_RETURNS_E_TYPE RxParser(uint8 new_byte)
   1741          {
   \                     RxParser: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1742              PARSER_RETURNS_E_TYPE rx_parser_state;
   1743              rx_parser_state = PARSER_STATE_RECEIVING;
   1744          
   1745              switch (Receive_State_Machine)
   \   00000002   0x....             LDR.N    R2,??DataTable7_4
   \   00000004   0xF9B2 0x310E      LDRSH    R3,[R2, #+270]
   \   00000008   0x4601             MOV      R1,R0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x2B05             CMP      R3,#+5
   \   0000000E   0xD84B             BHI.N    ??RxParser_1
   \   00000010   0xE8DF 0xF003      TBB      [PC, R3]
   \                     ??RxParser_0:
   \   00000014   0x03 0x14          DC8      0x3,0x14,0x1A,0x20
   \              0x1A 0x20    
   \   00000018   0x26 0x33          DC8      0x26,0x33
   1746              {
   1747                  case WAIT_FOR_ACK:
   1748                      if (new_byte==ACK_BYTE)
   \                     ??RxParser_2: (+1)
   \   0000001A   0x295A             CMP      R1,#+90
   \   0000001C   0xD129             BNE.N    ??RxParser_3
   1749                      {
   1750                          // initialize CRC value
   1751                          Calculated_Crc = CRC_INIT_VALUE;
   1752          
   1753                          if (Master_Comm_Flags != TRIPHASEDATA_2)
   \   0000001E   0xF9B2 0x4104      LDRSH    R4,[R2, #+260]
   \   00000022   0xF64F 0x73FF      MOVW     R3,#+65535
   \   00000026   0xF8A2 0x3120      STRH     R3,[R2, #+288]
   \   0000002A   0x2C06             CMP      R4,#+6
   \   0000002C   0xBF08             IT       EQ 
   1754                          {
   1755                              Set_File_All_Crc = CRC_INIT_VALUE;
   1756                          }
   1757                          else
   1758                          {
   1759                              Set_File_All_Crc = Crc_Application_1;
   \   0000002E   0x2300             MOVEQ    R3,#+0
   \   00000030   0xF8A2 0x3126      STRH     R3,[R2, #+294]
   1760                          }
   1761                          Receive_State_Machine=WAIT_FOR_STX;
   \   00000034   0x2301             MOVS     R3,#+1
   \   00000036   0xF8A2 0x310E      STRH     R3,[R2, #+270]
   \   0000003A   0xE035             B.N      ??RxParser_1
   1762                      }
   1763                      else
   1764                      {
   1765                          rx_parser_state = PARSER_STATE_ERROR;
   1766                      }
   1767                      break;
   1768          
   1769                  case WAIT_FOR_STX:
   1770                      if (new_byte==STX_BYTE)
   \                     ??RxParser_4: (+1)
   \   0000003C   0x29A5             CMP      R1,#+165
   \   0000003E   0xD118             BNE.N    ??RxParser_3
   1771                      {
   1772                          Receive_State_Machine=WAIT_FOR_EXTENDED;
   \   00000040   0x2302             MOVS     R3,#+2
   \   00000042   0xF8A2 0x310E      STRH     R3,[R2, #+270]
   \   00000046   0xE02F             B.N      ??RxParser_1
   1773                      }
   1774                      else
   1775                      {
   1776                          rx_parser_state = PARSER_STATE_ERROR;
   1777                      }
   1778                      break;
   1779          
   1780                  case WAIT_FOR_EXTENDED:
   1781                      if (new_byte==EXTENDED_BYTE)
   \                     ??RxParser_5: (+1)
   \   00000048   0x29EE             CMP      R1,#+238
   \   0000004A   0xD112             BNE.N    ??RxParser_3
   1782                      {
   1783                          Receive_State_Machine=WAIT_FOR_HDR;
   \   0000004C   0x2303             MOVS     R3,#+3
   \   0000004E   0xF8A2 0x310E      STRH     R3,[R2, #+270]
   \   00000052   0xE029             B.N      ??RxParser_1
   1784                      }
   1785                      else
   1786                      {
   1787                          rx_parser_state = PARSER_STATE_ERROR;
   1788                      }
   1789                      break;
   1790          
   1791                  case WAIT_FOR_HDR:
   1792                      if (new_byte==HDR_BYTE)
   \                     ??RxParser_6: (+1)
   \   00000054   0x2901             CMP      R1,#+1
   \   00000056   0xD10C             BNE.N    ??RxParser_3
   1793                      {
   1794                          Receive_State_Machine=WAIT_FOR_TYPE;
   \   00000058   0x2304             MOVS     R3,#+4
   \   0000005A   0xF8A2 0x310E      STRH     R3,[R2, #+270]
   \   0000005E   0xE023             B.N      ??RxParser_1
   1795                      }
   1796                      else
   1797                      {
   1798                          rx_parser_state = PARSER_STATE_ERROR;
   1799                      }
   1800                      break;
   1801          
   1802                  case WAIT_FOR_TYPE:
   1803                      if (new_byte==(uint8)Send_Buffer[TOKEN_PACKET_SEND_TYPE])
   \                     ??RxParser_7: (+1)
   \   00000060   0xF8B2 0x304E      LDRH     R3,[R2, #+78]
   \   00000064   0xB2DB             UXTB     R3,R3
   \   00000066   0x4299             CMP      R1,R3
   \   00000068   0xD103             BNE.N    ??RxParser_3
   1804                      {
   1805                          Receive_State_Machine=WAIT_FOR_LENGTH;
   \   0000006A   0x2305             MOVS     R3,#+5
   \   0000006C   0xF8A2 0x310E      STRH     R3,[R2, #+270]
   \   00000070   0xE01A             B.N      ??RxParser_1
   1806                      }
   1807                      else
   1808                      {
   1809                          rx_parser_state = PARSER_STATE_ERROR;
   \                     ??RxParser_3: (+1)
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0xF8B2 0x3122      LDRH     R3,[R2, #+290]
   \   00000078   0xE0DA             B.N      ??RxParser_8
   1810                      }
   1811                      break;
   1812          
   1813                  case WAIT_FOR_LENGTH:
   1814                      Bytes_To_Receive+=new_byte;
   \                     ??RxParser_9: (+1)
   \   0000007A   0xF8B2 0x3108      LDRH     R3,[R2, #+264]
   1815                      Receive_State_Machine=WAIT_FOR_DATA;
   1816          
   1817                      if (Master_Comm_Flags>DISPLDATA)
   \   0000007E   0xF9B2 0x5104      LDRSH    R5,[R2, #+260]
   \   00000082   0x18CB             ADDS     R3,R1,R3
   \   00000084   0xF8A2 0x3108      STRH     R3,[R2, #+264]
   \   00000088   0x2306             MOVS     R3,#+6
   \   0000008A   0xF8A2 0x310E      STRH     R3,[R2, #+270]
   \   0000008E   0x2D04             CMP      R5,#+4
   \   00000090   0xF8B2 0x3122      LDRH     R3,[R2, #+290]
   \   00000094   0xDB0A             BLT.N    ??RxParser_10
   1818                      {
   1819                          if(Table_Size<new_byte)
   \   00000096   0xF8B2 0x5128      LDRH     R5,[R2, #+296]
   \   0000009A   0x428D             CMP      R5,R1
   \   0000009C   0xBF2C             ITE      CS 
   1820                          {
   1821                              Min_Setting_Bytes_Num = Table_Size;
   1822                          }
   1823                          else
   1824                          {
   1825                              Min_Setting_Bytes_Num = new_byte;
   \   0000009E   0xF8A2 0x1118      STRHCS   R1,[R2, #+280]
   1826                          }
   \   000000A2   0xF8A2 0x5118      STRHCC   R5,[R2, #+280]
   \   000000A6   0xE001             B.N      ??RxParser_10
   1827                      }
   1828                      break;
   1829          
   1830                  default:
   1831                      break;
   1832              }
   1833          
   1834              if(rx_parser_state != PARSER_STATE_ERROR)
   \                     ??RxParser_1: (+1)
   \   000000A8   0xF8B2 0x3122      LDRH     R3,[R2, #+290]
   1835              {
   1836                  if ((Bytes_To_Receive - Bytes_Received) > 2)
   \                     ??RxParser_10: (+1)
   \   000000AC   0xF8B2 0x410C      LDRH     R4,[R2, #+268]
   \   000000B0   0xF8B2 0x6108      LDRH     R6,[R2, #+264]
   \   000000B4   0x4625             MOV      R5,R4
   \   000000B6   0x1B77             SUBS     R7,R6,R5
   \   000000B8   0x2F03             CMP      R7,#+3
   \   000000BA   0xF2C0 0x808A      BLT.W    ??RxParser_11
   1837                  {
   1838                      // # Byte Received, @ Byte Not Received, x Byte Processed
   1839                      // Packet [###########x@@]
   1840          
   1841                      //---------------------------------------------------------------------------------------
   1842          
   1843                      if(Receive_State_Machine > WAIT_FOR_STX)
   \   000000BE   0xF9B2 0x710E      LDRSH    R7,[R2, #+270]
   \   000000C2   0xF241 0x0621      MOVW     R6,#+4129
   \   000000C6   0x2F02             CMP      R7,#+2
   \   000000C8   0xDB34             BLT.N    ??RxParser_12
   1844                      {
   1845                          Calculated_Crc = CalcCrc1(Calculated_Crc, new_byte);
   \   000000CA   0xF8B2 0x7120      LDRH     R7,[R2, #+288]
   \   000000CE   0xEA87 0x2701      EOR      R7,R7,R1, LSL #+8
   \   000000D2   0x007F             LSLS     R7,R7,#+1
   \   000000D4   0xF5B7 0x3F80      CMP      R7,#+65536
   \   000000D8   0xBF28             IT       CS 
   \   000000DA   0x4077             EORCS    R7,R6,R7
   \   000000DC   0x043F             LSLS     R7,R7,#+16
   \   000000DE   0x0BFF             LSRS     R7,R7,#+15
   \   000000E0   0xF5B7 0x3F80      CMP      R7,#+65536
   \   000000E4   0xBF28             IT       CS 
   \   000000E6   0x4077             EORCS    R7,R6,R7
   \   000000E8   0x043F             LSLS     R7,R7,#+16
   \   000000EA   0x0BFF             LSRS     R7,R7,#+15
   \   000000EC   0xF5B7 0x3F80      CMP      R7,#+65536
   \   000000F0   0xBF28             IT       CS 
   \   000000F2   0x4077             EORCS    R7,R6,R7
   \   000000F4   0x043F             LSLS     R7,R7,#+16
   \   000000F6   0x0BFF             LSRS     R7,R7,#+15
   \   000000F8   0xF5B7 0x3F80      CMP      R7,#+65536
   \   000000FC   0xBF28             IT       CS 
   \   000000FE   0x4077             EORCS    R7,R6,R7
   \   00000100   0x043F             LSLS     R7,R7,#+16
   \   00000102   0x0BFF             LSRS     R7,R7,#+15
   \   00000104   0xF5B7 0x3F80      CMP      R7,#+65536
   \   00000108   0xBF28             IT       CS 
   \   0000010A   0x4077             EORCS    R7,R6,R7
   \   0000010C   0x043F             LSLS     R7,R7,#+16
   \   0000010E   0x0BFF             LSRS     R7,R7,#+15
   \   00000110   0xF5B7 0x3F80      CMP      R7,#+65536
   \   00000114   0xBF28             IT       CS 
   \   00000116   0x4077             EORCS    R7,R6,R7
   \   00000118   0x043F             LSLS     R7,R7,#+16
   \   0000011A   0x0BFF             LSRS     R7,R7,#+15
   \   0000011C   0xF5B7 0x3F80      CMP      R7,#+65536
   \   00000120   0xBF28             IT       CS 
   \   00000122   0x4077             EORCS    R7,R6,R7
   \   00000124   0x043F             LSLS     R7,R7,#+16
   \   00000126   0x0BFF             LSRS     R7,R7,#+15
   \   00000128   0xF5B7 0x3F80      CMP      R7,#+65536
   \   0000012C   0xBF28             IT       CS 
   \   0000012E   0x4077             EORCS    R7,R6,R7
   1846                      }
   \   00000130   0xF8A2 0x7120      STRH     R7,[R2, #+288]
   \                     ??RxParser_12: (+1)
   \   00000134   0xF9B2 0x7104      LDRSH    R7,[R2, #+260]
   \   00000138   0x2F04             CMP      R7,#+4
   \   0000013A   0xBFA8             IT       GE 
   \   0000013C   0x2D06             CMPGE    R5,#+6
   \   0000013E   0xDB43             BLT.N    ??RxParser_13
   1847                      //---------------------------------------------------------------------------------------
   1848          
   1849                      if (Master_Comm_Flags>DISPLDATA && (Bytes_Received > READFLASH_RECEIVE_LENGTH))
   1850                      {
   1851                          if (Bytes_Received <= (READFLASH_RECEIVE_LENGTH + Min_Setting_Bytes_Num))
   \   00000140   0xF8B2 0x4118      LDRH     R4,[R2, #+280]
   \   00000144   0x1D64             ADDS     R4,R4,#+5
   \   00000146   0x42AC             CMP      R4,R5
   \   00000148   0xDB04             BLT.N    ??RxParser_14
   1852                          {
   1853          
   1854          #ifndef MOTOR_SBPM_FLOAT
   1855          
   1856                              if (Bytes_Received & 1)
   1857                              {
   1858                                  // READING high BYTE
   1859                                  *((uint8 *)Set_File_Table + ((Bytes_Received) - READFLASH_RECEIVE_LENGTH-2)) = (uint8)new_byte;
   1860                              }
   1861                              else
   1862                              {
   1863                                  // READING low BYTE
   1864                                  *((uint8 *)Set_File_Table + ((Bytes_Received) - READFLASH_RECEIVE_LENGTH)) = (uint8)new_byte;
   1865                              }
   1866          #else
   1867          
   1868                              *(Set_File_Table + (Bytes_Received - READFLASH_RECEIVE_LENGTH -1)) = new_byte;
   \   0000014A   0xF8D2 0x4140      LDR      R4,[R2, #+320]
   \   0000014E   0x192C             ADDS     R4,R5,R4
   \   00000150   0xF804 0x1C06      STRB     R1,[R4, #-6]
   1869          
   1870          #endif
   1871                          }
   1872          
   1873                          //---------------------------------------------------------------------------------------
   1874          
   1875                          if (Master_Comm_Flags != TRIPHASEDATA_2)
   \                     ??RxParser_14: (+1)
   \   00000154   0x2F06             CMP      R7,#+6
   \   00000156   0xD001             BEQ.N    ??RxParser_15
   1876                          {
   1877                              if(Bytes_Received > READFLASH_RECEIVE_D1)    // Params__Get()->Params_Crc is not included
   \   00000158   0x2D08             CMP      R5,#+8
   \   0000015A   0xDB69             BLT.N    ??RxParser_8
   1878                              {   // we are receiving the setting file data
   1879                                  // (CRC on Buffer)
   1880                                  Set_File_All_Crc = CalcCrc1(Set_File_All_Crc, new_byte);
   1881                              }
   1882                          }
   1883                          else
   1884                          {
   1885                              // we are receiving the setting file data
   1886                              // (CRC on Buffer)
   1887                              Set_File_All_Crc = CalcCrc1(Set_File_All_Crc, new_byte);
   \                     ??RxParser_15: (+1)
   \   0000015C   0xF8B2 0x4126      LDRH     R4,[R2, #+294]
   \   00000160   0xEA84 0x2101      EOR      R1,R4,R1, LSL #+8
   \   00000164   0x0049             LSLS     R1,R1,#+1
   \   00000166   0xF5B1 0x3F80      CMP      R1,#+65536
   \   0000016A   0xBF28             IT       CS 
   \   0000016C   0x4071             EORCS    R1,R6,R1
   \   0000016E   0x0409             LSLS     R1,R1,#+16
   \   00000170   0x0BC9             LSRS     R1,R1,#+15
   \   00000172   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000176   0xBF28             IT       CS 
   \   00000178   0x4071             EORCS    R1,R6,R1
   \   0000017A   0x0409             LSLS     R1,R1,#+16
   \   0000017C   0x0BC9             LSRS     R1,R1,#+15
   \   0000017E   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000182   0xBF28             IT       CS 
   \   00000184   0x4071             EORCS    R1,R6,R1
   \   00000186   0x0409             LSLS     R1,R1,#+16
   \   00000188   0x0BC9             LSRS     R1,R1,#+15
   \   0000018A   0xF5B1 0x3F80      CMP      R1,#+65536
   \   0000018E   0xBF28             IT       CS 
   \   00000190   0x4071             EORCS    R1,R6,R1
   \   00000192   0x0409             LSLS     R1,R1,#+16
   \   00000194   0x0BC9             LSRS     R1,R1,#+15
   \   00000196   0xF5B1 0x3F80      CMP      R1,#+65536
   \   0000019A   0xBF28             IT       CS 
   \   0000019C   0x4071             EORCS    R1,R6,R1
   \   0000019E   0x0409             LSLS     R1,R1,#+16
   \   000001A0   0x0BC9             LSRS     R1,R1,#+15
   \   000001A2   0xF5B1 0x3F80      CMP      R1,#+65536
   \   000001A6   0xBF28             IT       CS 
   \   000001A8   0x4071             EORCS    R1,R6,R1
   \   000001AA   0x0409             LSLS     R1,R1,#+16
   \   000001AC   0x0BC9             LSRS     R1,R1,#+15
   \   000001AE   0xF5B1 0x3F80      CMP      R1,#+65536
   \   000001B2   0xBF28             IT       CS 
   \   000001B4   0x4071             EORCS    R1,R6,R1
   \   000001B6   0x0409             LSLS     R1,R1,#+16
   \   000001B8   0x0BC9             LSRS     R1,R1,#+15
   \   000001BA   0xF5B1 0x3F80      CMP      R1,#+65536
   \   000001BE   0xBF28             IT       CS 
   \   000001C0   0x4071             EORCS    R1,R6,R1
   1888                          }
   1889                          //---------------------------------------------------------------------------------------
   1890                      }
   \   000001C2   0xF8A2 0x1126      STRH     R1,[R2, #+294]
   \   000001C6   0xE033             B.N      ??RxParser_8
   1891                      else
   1892                      {
   1893                          if (Bytes_Received >= sizeof(Receive_Buffer))
   \                     ??RxParser_13: (+1)
   \   000001C8   0x2C48             CMP      R4,#+72
   \   000001CA   0xD230             BCS.N    ??RxParser_16
   1894                          {
   1895                              rx_parser_state = PARSER_STATE_ERROR;
   1896                          }
   1897                          else
   1898                          {
   1899                              Receive_Buffer[Bytes_Received]=(uint16)new_byte;
   \   000001CC   0xF822 0x1015      STRH     R1,[R2, R5, LSL #+1]
   \   000001D0   0xE02E             B.N      ??RxParser_8
   1900                          }
   1901                      }
   1902                  }
   1903                  else if((Bytes_To_Receive - Bytes_Received) == 2)
   \                     ??RxParser_11: (+1)
   \   000001D2   0x2F02             CMP      R7,#+2
   \   000001D4   0xBF0E             ITEE     EQ 
   1904                  {
   1905                      // # Byte Received, @ Byte Not Received, x Byte Processed
   1906                      // Packet [############x@]
   1907          
   1908                      MainCrc= ((uint16)new_byte << 8);
   \   000001D6   0x020B             LSLEQ    R3,R1,#+8
   1909                  }
   1910                  else // Ricezione Completata
   1911                  {
   1912                      // # Byte Received, @ Byte Not Received, x Byte Processed
   1913                      // Packet [#############x]
   1914          
   1915                      rx_parser_state = PARSER_STATE_COMPLETED;
   \   000001D8   0x2002             MOVNE    R0,#+2
   1916          
   1917                      if (Bytes_To_Receive!=INFO_PACKET_RECEIVE_SIZE)
   \   000001DA   0x2E01             CMPNE    R6,#+1
   \   000001DC   0xD028             BEQ.N    ??RxParser_8
   1918                      {
   1919                          MainCrc = MainCrc|((uint16)new_byte);
   \   000001DE   0x430B             ORRS     R3,R1,R3
   1920          
   1921                          if (Calculated_Crc!=MainCrc)
   \   000001E0   0xF8B2 0x1120      LDRH     R1,[R2, #+288]
   \   000001E4   0x4299             CMP      R1,R3
   \   000001E6   0xD122             BNE.N    ??RxParser_16
   1922                          {
   1923                              // checksum fail
   1924                              rx_parser_state = PARSER_STATE_ERROR;
   1925                          }
   1926                          else if (Master_Comm_Flags == DISPLDATA)
   \   000001E8   0xF9B2 0x1104      LDRSH    R1,[R2, #+260]
   \   000001EC   0x2903             CMP      R1,#+3
   \   000001EE   0xD11F             BNE.N    ??RxParser_8
   1927                          {
   1928                              #if (APPLIANCE_TYPE == APPLIANCE_TYPE_DISHWASHER)
   1929                                  rx_parser_state = DisplProcessing();
   1930                              #else
   1931          #ifdef MOTOR_CIM_TYPE
   1932                                  if (Receive_Buffer[READFLASH_RECEIVE_LENGTH] >= 4)
   1933                                  {
   1934                                      Params_Displ  = ((Receive_Buffer[READFLASH_RECEIVE_D0] << 8) | (Receive_Buffer[READFLASH_RECEIVE_D1]));
   1935                                      Params_Displ_2 = ((Receive_Buffer[READFLASH_RECEIVE_D2] << 8) | (Receive_Buffer[READFLASH_RECEIVE_D3]));
   1936                                  }
   1937                                  else
   1938                                  {   /* invalid len */
   1939                                      rx_parser_state = PARSER_STATE_ERROR;
   1940                                  }
   1941          #else // ARK3 mode
   1942          
   1943                                 	// check on packet len: must be 4
   1944                                 	if (Receive_Buffer[READFLASH_RECEIVE_LENGTH] >= 4)
   \   000001F0   0x8951             LDRH     R1,[R2, #+10]
   \   000001F2   0x2904             CMP      R1,#+4
   \   000001F4   0xDB1B             BLT.N    ??RxParser_16
   1945                                 	{
   1946          #ifdef MOTOR_SBPM_FLOAT
   1947                                    	Prm_Displ_DTC_Ctrl   = Receive_Buffer[READFLASH_RECEIVE_D0];
   \   000001F6   0x8991             LDRH     R1,[R2, #+12]
   \   000001F8   0xF882 0x10F8      STRB     R1,[R2, #+248]
   1948                                     	Prm_Displ_Motor_Lut  = Receive_Buffer[READFLASH_RECEIVE_D1];
   \   000001FC   0x89D1             LDRH     R1,[R2, #+14]
   \   000001FE   0xF882 0x10F9      STRB     R1,[R2, #+249]
   1949                                     	Prm_Displ_Speed_Ctrl = Receive_Buffer[READFLASH_RECEIVE_D2];
   \   00000202   0x8A11             LDRH     R1,[R2, #+16]
   \   00000204   0xF882 0x10FA      STRB     R1,[R2, #+250]
   1950                                     	Prm_Displ_MTPA       = Receive_Buffer[READFLASH_RECEIVE_D3];
   \   00000208   0x8A51             LDRH     R1,[R2, #+18]
   \   0000020A   0xF882 0x10FB      STRB     R1,[R2, #+251]
   1951                                     	Prm_Displ_MTPV       = Receive_Buffer[READFLASH_RECEIVE_D4];
   \   0000020E   0x8A91             LDRH     R1,[R2, #+20]
   \   00000210   0xF882 0x10FC      STRB     R1,[R2, #+252]
   1952                                     	Prm_Displ_OTE        = Receive_Buffer[READFLASH_RECEIVE_D5];
   \   00000214   0x8AD1             LDRH     R1,[R2, #+22]
   \   00000216   0xF882 0x10FD      STRB     R1,[R2, #+253]
   1953                                     	Prm_Displ_SR         = Receive_Buffer[READFLASH_RECEIVE_D6];
   \   0000021A   0x8B11             LDRH     R1,[R2, #+24]
   \   0000021C   0xF882 0x10FE      STRB     R1,[R2, #+254]
   1954                                     	Prm_Displ_Set_Wm     = Receive_Buffer[READFLASH_RECEIVE_D7];
   \   00000220   0x8B51             LDRH     R1,[R2, #+26]
   \   00000222   0xF882 0x10FF      STRB     R1,[R2, #+255]
   1955                                     	Prm_Displ_Sensor_Wm  = Receive_Buffer[READFLASH_RECEIVE_D8];
   \   00000226   0x8B91             LDRH     R1,[R2, #+28]
   \   00000228   0xF882 0x1100      STRB     R1,[R2, #+256]
   \   0000022C   0xE000             B.N      ??RxParser_8
   1956          #else
   1957          							Params_Displ_2  = ((Receive_Buffer[READFLASH_RECEIVE_D0] << 8) | (Receive_Buffer[READFLASH_RECEIVE_D1]));
   1958                                      Params_Displ    = ((Receive_Buffer[READFLASH_RECEIVE_D2] << 8) | (Receive_Buffer[READFLASH_RECEIVE_D3]));
   1959          #endif
   1960                                 	}
   1961                                 	else
   1962                                 	{    // invalid len
   1963                                     	rx_parser_state = PARSER_STATE_ERROR;
   \                     ??RxParser_16: (+1)
   \   0000022E   0x2001             MOVS     R0,#+1
   \                     ??RxParser_8: (+1)
   \   00000230   0xF8A2 0x3122      STRH     R3,[R2, #+290]
   1964                                 	}
   1965          #endif // ARK2
   1966                              #endif  //#if (APPLIANCE_TYPE == APPLIANCE_TYPE_DISHWASHER)
   1967                          }
   1968                      }
   1969                  }
   1970              }
   1971          
   1972              Bytes_Received++;
   \   00000234   0xF8B2 0x110C      LDRH     R1,[R2, #+268]
   \   00000238   0x1C49             ADDS     R1,R1,#+1
   \   0000023A   0xF8A2 0x110C      STRH     R1,[R2, #+268]
   1973          
   1974              return rx_parser_state;
   \   0000023E   0xBCF0             POP      {R4-R7}
   \   00000240   0x4770             BX       LR               ;; return
   1975          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     Parms_Ready

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     Receive_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     Receive_Buffer+0x144

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     Receive_Buffer+0xE8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     Receive_Buffer+0xF0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     Receive_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     Mci_ClassA_Dtc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     Mci_ClassA_Dtc+0xFF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     Mci_ClassA_Motor_Lut

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     Mci_ClassA_Speed_Ctrl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     Mci_ClassA_Mtpa

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     Mci_ClassA_Mtpv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     Mci_ClassA_Ote

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x........         DC32     Mci_ClassB_Prm

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x........         DC32     Mca_Set_Wm

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     Mca_Sensor_Wm

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     Parms_Ready

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x1FFF0000         DC32     0x1fff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x1FFFE000         DC32     0x1fffe000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x........         DC32     Receive_Buffer
   1976          
   1977          #if (APPLIANCE_TYPE == APPLIANCE_TYPE_DISHWASHER)
   1978          //---------------------------------------------------------------------------------------------------------------------
   1979          /**
   1980           *  @brief      Displacement processing
   1981           *
   1982           *  @return     Displacement state
   1983           */
   1984          PARSER_RETURNS_E_TYPE DisplProcessing(void)
   1985          {
   1986              PARSER_RETURNS_E_TYPE rx_displ_state;
   1987              uint16 displ_len_expected;
   1988              rx_displ_state = PARSER_STATE_RECEIVING;
   1989          
   1990              displ_len_expected = 4 + ((Module_Type>>1)<<1);
   1991          
   1992              if (Receive_Buffer[READFLASH_RECEIVE_LENGTH] >= displ_len_expected)
   1993              {
   1994                  Params_Displ = ((Receive_Buffer[READFLASH_RECEIVE_D0] << 8) | (Receive_Buffer[READFLASH_RECEIVE_D1]));
   1995                  Modules_Displ = Receive_Buffer[READFLASH_RECEIVE_D2+Module_Type];
   1996          
   1997                  if(Modules_Displ != 0x00FF)
   1998                  {
   1999                      rx_displ_state = PARSER_STATE_COMPLETED;
   2000                  }
   2001                  else
   2002                  {
   2003                      rx_displ_state = PARSER_STATE_ERROR;
   2004                  }
   2005              }
   2006              else
   2007              {
   2008                  rx_displ_state = PARSER_STATE_ERROR;
   2009              }
   2010          
   2011              return rx_displ_state;
   2012          }
   2013          
   2014          
   2015          //---------------------------------------------------------------------------------------------------------------------
   2016          /**
   2017           *  @brief      Decode Load Type
   2018           *
   2019           *  @remarks    This function to undestand what is the motor to drive
   2020           *              hp: the application must avoid that [(PrevSpeedL1 != 0) && (PrevSpeedL2 != 0)] at same time
   2021           *
   2022           *  @ref        MOD_SMI_2
   2023           *
   2024           */
   2025          void DecodeLoadType(void)
   2026          {
   2027              switch (Decode_Load_State_Machine)
   2028              {
   2029                  default:
   2030                  case EVALUATION_LOAD:    // 0
   2031                      // Evaluation State after a reset: what load to drive?
   2032                      if (Command_Data_L1.Speed != 0)
   2033                      {// we have received a speed command not null for L1 load
   2034                          Decode_Load_State_Machine = DRIVING_L1;
   2035                          Motor_Displ = Displ_Sf_Params_L1;    // load the correct setting file
   2036                          Command_Data.Data_Type = Command_Data_L1.Data_Type;        // added for Tools <--> save the PilotType for Tools
   2037                      }
   2038                      else if(Command_Data_L2.Speed != 0)
   2039                      {// we have received a speed command not null for L2 load
   2040                          Decode_Load_State_Machine = DRIVING_L2;
   2041                          Motor_Displ = Displ_Sf_Params_L2;    // load the correct setting file
   2042                          Command_Data.Data_Type = Command_Data_L2.Data_Type;        // added for Tools <--> save the PilotType for Tools
   2043                      }
   2044                      else
   2045                      {// (PrevSpeedL1 == 0) && (PrevSpeedL2 == 0)
   2046                          // both speed commands are null
   2047                          // choose the default load according to the motor activated when the relay is in rest position
   2048                          // to avoid relay noise after each reset (every 32sec in case of null commands)
   2049                          if ((Command_Data_L1.Data_Type == DEFAULT_LOAD) || (Command_Data_L2.Data_Type == 0)) // L1 must be driven in case of single load (Command_Data_L2.Data_Type == 0)
   2050                          {
   2051                              Decode_Load_State_Machine = DRIVING_L1;
   2052                              Motor_Displ = Displ_Sf_Params_L1;    // load the correct setting file
   2053                              Command_Data.Data_Type = Command_Data_L1.Data_Type;        // added for Tools <--> save the PilotType for Tools
   2054                          }
   2055                          else
   2056                          {
   2057                              Decode_Load_State_Machine = DRIVING_L2;
   2058                              Motor_Displ = Displ_Sf_Params_L2;    // load the correct setting file
   2059                              Command_Data.Data_Type = Command_Data_L2.Data_Type;        // added for Tools <--> save the PilotType for Tools
   2060                          }
   2061                      }
   2062          
   2063                      Command_Data.Ramp_Time = 0;
   2064                      Command_Data.Speed = 0;
   2065                      break;
   2066          
   2067                  case DRIVING_L1:        // 1
   2068                      Motor_Displ = Displ_Sf_Params_L1;
   2069                      Command_Data.Data_Type = Command_Data_L1.Data_Type;
   2070                      // we are driving L1 load: what next?
   2071                      if(Command_Data_L2.Speed != 0)
   2072                      {// we have received a speed command not null for L2 load
   2073          
   2074                          Command_Data.Ramp_Time = 0;
   2075                          Command_Data.Speed = 0;
   2076          
   2077                          if((Params__IsUpdateAllowed() == TRUE) || (Params__IsReady() == FALSE))
   2078                          {
   2079                              Decode_Load_State_Machine = DRIVING_L2;                 // switch load
   2080                              Params__SetReady(FALSE);
   2081                              Motor_Displ = Displ_Sf_Params_L2;                       // load the correct setting file
   2082                              Command_Data.Data_Type = Command_Data_L2.Data_Type;   // added for Tools <--> save the PilotType for Tools
   2083                          }
   2084                      }
   2085                      else
   2086                      {// [ (PrevSpeedL1 != 0) || ((PrevSpeedL1 == 0) && (PrevSpeedL2 == 0)) ] --> drive load L1
   2087          
   2088                          // set the commands for L1 load
   2089                          Command_Data.Ramp_Time = Command_Data_L1.Ramp_Time;
   2090                          Command_Data.Speed = Command_Data_L1.Speed;
   2091                          Command_Data.Cmd_Flags = Command_Data_L1.Cmd_Flags;
   2092                      }
   2093                      break;
   2094          
   2095                  case DRIVING_L2:        // 2
   2096                      Motor_Displ = Displ_Sf_Params_L2; 
   2097                      Command_Data.Data_Type = Command_Data_L2.Data_Type;
   2098                      // we are driving L2 load: what next?
   2099                      if(Command_Data_L1.Speed != 0)
   2100                      {// we have received a speed command not null for L1 load
   2101          
   2102                          Command_Data.Ramp_Time = 0;
   2103                          Command_Data.Speed = 0;
   2104          
   2105                          if((Params__IsUpdateAllowed() == TRUE) || (Params__IsReady() == FALSE))
   2106                          {
   2107                              Decode_Load_State_Machine = DRIVING_L1;                 // switch load
   2108                              Params__SetReady(FALSE);
   2109                              Motor_Displ = Displ_Sf_Params_L1;                       // load the correct setting file
   2110                              Command_Data.Data_Type = Command_Data_L1.Data_Type;   // added for Tools <--> save the PilotType for Tool
   2111                          }
   2112                      }
   2113                      else
   2114                      {// [ (PrevSpeedL2 != 0) || ((PrevSpeedL1 == 0) && (PrevSpeedL2 == 0)) ] --> drive load L2
   2115          
   2116                          // set the commands for L2 load
   2117                          Command_Data.Ramp_Time = Command_Data_L2.Ramp_Time;
   2118                          Command_Data.Speed = Command_Data_L2.Speed;
   2119                          Command_Data.Cmd_Flags = Command_Data_L1.Cmd_Flags;
   2120                      }
   2121                      break;
   2122              }
   2123          }
   2124          
   2125          
   2126          //---------------------------------------------------------------------------------------------------------------------
   2127          /**
   2128           *  @brief      It Initializes the module DishWasher Pumps according the decode load
   2129           *
   2130           */
   2131          void InitPumps(void)
   2132          {
   2133          
   2134          	if((Params__IsReady() == FALSE)&&(Decode_Load_State_Machine!=EVALUATION_LOAD))
   2135          	{
   2136          
   2137          		SensorsAlgorithms__Initialize();
   2138          		CommandManager__Initialize();
   2139          		Mci__SetDigital(MOTOR0, MCI_DO_CLEAR_ALL_FAILURE, TRUE);
   2140          		FaultManager__Initialize();
   2141          		ProtocolInfo__Initialize();
   2142          
   2143          		switch (Decode_Load_State_Machine)
   2144          		{
   2145          			case DRIVING_L1:
   2146          
   2147          				//Motor Sr parameters initialization
   2148          				memcpy(SafetyParamsBuffer, &MotorSrDrainParams, MINIMUM_MCISAFETY_PARAMS_NUM);
   2149          				//safety parameters Crc calculation to pass the check class B check in safety data (the excel file doesn't calculate it)
   2150          				SafetyParamsBuffer[1] = Crc16__RangeProcess((uint8 *)(&SafetyParamsBuffer[2]),0xFFFF,(MINIMUM_MCISAFETY_PARAMS_NUM-4));
   2151          				//SafetyParamsBuffer[1] = CalcCrc(&SafetyParamsBuffer[2], MINIMUM_MCISAFETY_PARAMS_NUM-4);
   2152          
   2153          				SRMotorSafetyMgr__SetParams(&SafetyParamsBuffer[1]);
   2154          				Params__InitializeDrain();
   2155          				RELAY_PUMPS_OPEN();
   2156          				break;
   2157          
   2158          			case DRIVING_L2:
   2159          
   2160          				//Motor Sr parameters initialization
   2161          				memcpy(SafetyParamsBuffer, &MotorSrWashParams, MINIMUM_MCISAFETY_PARAMS_NUM);
   2162          				//safety parameters Crc calculation to pass the check class B check in safety data (the excel file doesn't calculate it)
   2163          				SafetyParamsBuffer[1] = Crc16__RangeProcess((uint8 *)(&SafetyParamsBuffer[2]),0xFFFF,(MINIMUM_MCISAFETY_PARAMS_NUM-4));
   2164          				//SafetyParamsBuffer[1] = CalcCrc(&SafetyParamsBuffer[2], MINIMUM_MCISAFETY_PARAMS_NUM-4);
   2165          
   2166          				SRMotorSafetyMgr__SetParams(&SafetyParamsBuffer[1]);
   2167          				Params__InitializeWash();
   2168          				RELAY_PUMPS_CLOSE();
   2169          				break;
   2170          
   2171          			default:
   2172          				break;
   2173          		}
   2174          
   2175          
   2176          		// We don't need a reset for the internal parameters to work
   2177          		ProtocolInitialization(TOKEN);  // initialization of Communication Protocol
   2178          		Params__SetReady(TRUE);
   2179          	}
   2180          }
   2181          #endif
   2182          
   2183          
   2184          #if (uP_MODEL == uP_MODEL_MK3)
   2185          /**
   2186           *  @brief      Address translation for KV30
   2187           *              Workaround for the KV30 memory map
   2188           *              SRAM is in the range 0x1FFF_E000-0x2000_1FFF but we have only
   2189           *              16 bit for the address specification in the protocol
   2190           *
   2191           *  @param      address Value to check and convert if needed
   2192           *  @return     The converted address value
   2193           */
   2194          static inline uint32 TranslateAddress(uint32 address)
   2195          {
   2196              if (address >= 0xE000)
   2197              {
   2198                  address += (0x1FFF0000);
   2199              }
   2200              else if (address < 0x2000)
   2201              {
   2202                  address += (0x20000000);
   2203              }
   2204              else
   2205              {
   2206                  // invalid address
   2207                  // make sure the MIN_READABLE_ADDRESS and MAX_READABLE_ADDRESS
   2208                  // are configured accordingly
   2209                  address += (0x1FFF0000);
   2210              }
   2211          
   2212              return address;
   2213          }
   2214          #endif /* uP_MODEL_MK3 */
   2215          
   2216          
   2217          //---------------------------------------------------------------------------------------------------------------------
   2218          /**
   2219           *  @brief      CRC calculation on the reception buffer
   2220           *
   2221           *  @ref        MOD_R1_6_1
   2222           *
   2223           *  @param      crc CRC on the previous step
   2224           *  @param      byte Received byte to process
   2225           *  @return     Current step CRC value
   2226           */
   2227          uint16 CalcCrc1(uint16 crc, uint8 data)
   2228          {
   2229              uint32 crc32;
   2230              uint16 i;
   2231          
   2232              crc32 = crc ^ ((data << 8) & 0xFF00); // data byte is coupled into high byte
   2233              for (i = 0; i < 8; i++)
   2234              {
   2235                  crc32 = crc32 << 1;
   2236                  if (crc32 > 0xFFFF) // Test if bit 16 is set after shifting
   2237                  {
   2238                      crc32 = crc32 ^ CRC_POLINOMIAL_VALUE;
   2239                  }
   2240                  crc32 = crc32 & 0xFFFF; // clear bit 16 (if set)
   2241              }
   2242          
   2243              return (uint16)crc32;
   2244          }
   2245          
   2246          
   2247          //---------------------------------------------------------------------------------------------------------------------
   2248          /**
   2249           *  @brief      CRC calculation on the transmission buffer
   2250           *
   2251           *  @ref        MOD_R1_6_1
   2252           *
   2253           *  @param      *buf Transmission buffer
   2254           *  @param      len Buffer length
   2255           *  @return     CRC value
   2256           */
   2257          uint16 CalcCrc(uint16 *buf, uint16 len)
   2258          {
   2259              uint16 crc = CRC_INIT_VALUE;
   2260          
   2261              while (len--)
   2262              {
   2263                  crc = CalcCrc1(crc, (uint8)*buf++);
   2264              }
   2265              return (uint16)(crc & 0x0000FFFF);
   2266          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   CheckResendPacket
        16   -> ProtocolInfo__GetIdent
      32   MakeInfoPacket
        32   -> ProtocolInfo__GetInfo
        32   -> SRException__Queue
       8   ProtocolMainExternal__1msHandler
         8   -> FaultManager__GetResetState
         0   -> Rs232MasterCommunication
       0   ProtocolMainExternal__250usHandler
       0   ProtocolMainExternal__GetCommandData
       0   ProtocolMainExternal__GetFault
      16   ProtocolMainExternal__Initialize
        16   -> FaultManager__GetResetState
        16   -> Params__Initialize
        16   -> ProtocolInfo__Initialize
        16   -> Uart__Disable
        16   -> Uart__Enable
        16   -> Uart__Initialize
      16   Rs232MasterCommunication
        16   -> CheckResendPacket
        16   -> MakeInfoPacket
        16   -> RxParser
        16   -> Uart__GetStatus
        16   -> Uart__ReadByte
        16   -> Uart__WriteByte
      16   RxParser


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       2  Buff_Safety_Displ
     686  CheckResendPacket
       2  Crc_Application_1
       2  Displ_Sf_Params_L1
       2  Displ_Sf_Params_L2
     650  MakeInfoPacket
      24  ProtocolMainExternal__1msHandler
      30  ProtocolMainExternal__250usHandler
      26  ProtocolMainExternal__GetCommandData
       8  ProtocolMainExternal__GetFault
     132  ProtocolMainExternal__Initialize
     332  Receive_Buffer
          Send_Buffer
          Command_Data_L1
          Command_Data_L2
          Prm_Displ_DTC_Ctrl
          Prm_Displ_Motor_Lut
          Prm_Displ_Speed_Ctrl
          Prm_Displ_MTPA
          Prm_Displ_MTPV
          Prm_Displ_OTE
          Prm_Displ_SR
          Prm_Displ_Set_Wm
          Prm_Displ_Sensor_Wm
          Com_Request_Interval
          Master_Comm_Flags
          Bytes_To_Transmit
          Bytes_To_Receive
          Bytes_Transmitted
          Bytes_Received
          Receive_State_Machine
          Token_Time_Mark
          Receive_Time_Mark
          Send_Time_Mark
          Attempts
          Min_Setting_Bytes_Num
          Seq_ID
          Com_Safety_Flags
          Min_Params_Num
          Calculated_Crc
          MainCrc
          Calculated_Info_Crc
          Set_File_All_Crc
          Table_Size
          Com_Timer_Cnt
          Motor_Displ
          Decode_Load_State_Machine
          Error_Delay
          Dyn_Packet
          Fault
          COM_Global_Attempts
          Ram_Read_Start_Address_Ptr
          Ram_Read_End_Address_Ptr
          Set_File_Table
          Command_Data
    2972  Rs232MasterCommunication
     578  RxParser
       2  Setting_File_Loading_Interrupted

 
   342 bytes in section .bss
 5 186 bytes in section .text
 
 5 186 bytes of CODE memory
   342 bytes of DATA memory

Errors: none
Warnings: 15
