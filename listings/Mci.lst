###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        19/Nov/2024  13:15:58
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  XCategory\Hbl\Mci\Mci.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs
#        XCategory\Hbl\Mci\Mci.c XCategory\Hbl\Mci\Mcl\Mcl.c
#        XCategory\Hbl\Mci\Mcl\Braking\Braking.c
#        XCategory\Hbl\Mci\Mcl\MacroBlocks\MclDqCtrl.c
#        XCategory\Hbl\Mci\Mcl\MacroBlocks\MclDqRef.c
#        XCategory\Hbl\Mci\Mcl\MacroBlocks\MclInputProc.c
#        XCategory\Hbl\Mci\Mcl\MacroBlocks\MclObserver.c
#        XCategory\Hbl\Mci\Mcl\MacroBlocks\MclPwm.c
#        XCategory\Hbl\Mci\Mcl\MacroBlocks\MclSpeedCtrl.c
#        XCategory\Hbl\Mci\Mcl\MclFvt\MclFvt.c
#        XCategory\Hbl\Mci\Mcl\MicroBlocks\ClrkPark\ClrkPark.c
#        XCategory\Hbl\Mci\Mcl\MicroBlocks\Filters\Filters.c
#        XCategory\Hbl\Mci\Mcl\MicroBlocks\Math\MathCalc.c
#        XCategory\Hbl\Mci\Mcl\MicroBlocks\Pi\Pi.c
#        XCategory\Hbl\Mci\Mcl\MicroBlocks\PwmModulation\PwmModulation.c
#        XCategory\Hbl\Mci\Mcl\ResistanceEstimation\ResistanceEstimation.c
#        XCategory\Hbl\Mci\SpeedRefGen\SpeedRefGen.c
#        XCategory\Hbl\Mci\InverterTemp\InverterTemp.c
#        XCategory\Hbl\Mci\SurgeRelay\SurgeRelay.c
#        XCategory\Driver\SRMCAtod\SRMCAtod.c
#        XCategory\Driver\SRMCPwm\SRMCPwm.c
#        XCategory\Hbl\SRMotorSafetyMgr\SRMotorSafetyMgr.c -o Mci.obj --mfc -l
#        ..\listings\Mci.lst
#    List file    =  ..\listings\Mci.lst
#    Object file  =  Mci.obj
#
###############################################################################

C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\Mci.c
      1          /**
      2           *  @file       Mci.c
      3           *  @brief      Motor control interface
      4           *
      5           *  @details    Define the implementation of an API to control the motor, get its feedbacks, methods to set parameters.
      6           *              This is also a generic state machine enough to handle different motor control control techniques.
      7           *
      8              @startuml
      9          
     10              package "MCI2.0"  {
     11                  InverterTemp :
     12                  SpeedRefGen :
     13                  SurgeRelay :
     14                  Mathcalc :
     15                  C_Extensions :
     16          
     17                  package "Mcl" {
     18                  package "MacroBlocks" {
     19                          MclDqCtrl :
     20                          MclDqRef :
     21                          MclObserver :
     22                          MclPwm :
     23                          MclSpeedCtrl :
     24                      }
     25                  Mcl :
     26                  Mcl ..> MacroBlocks
     27                  }
     28              }
     29          
     30              InverterTemp -[hidden]- Mcl
     31              SpeedRefGen -[hidden]- Mcl
     32              SurgeRelay -[hidden]- Mcl
     33              Mathcalc -[hidden]- Mcl
     34              C_Extensions -[hidden]- Mcl
     35              @enduml
     36           *
     37           *
     38           *---------------------------------------------------------------------------------------------------------------------
     39           *------------------- Copyright 2017.  Whirlpool Corporation.  All rights reserved - CONFIDENTIAL ---------------------
     40           *---------------------------------------------------------------------------------------------------------------------
     41           */
     42          //-------------------------------------- Include Files ----------------------------------------------------------------
     43          #include "Mci.h"
     44          #include "MotorSafetyMgr.h"
     45          #include "Mcl.h"
     46          #include "SpeedRefGen.h"
     47          
     48          // Include Gpio only if OC polling is enabled.
     49          #if (defined MCI_HW_OC_DEBOUNCE_TIME) && (defined MCI_HW_OC_PORT) && (defined MCI_HW_OC_PIN) && (defined MCI_HW_OC_LEVEL)
     50          	#include "Gpio.h"
     51          #endif
     52          
     53          #if MCI_FVT_TESTS == ENABLED
     54              #include "MclFvt.h"
     55          #endif
     56          
     57          
     58          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     59          
     60          //!< Post scaler to check error
     61          #define MCI_CHECKERR_POSTSCALER     (uint8)(0.3f/0.005f)
     62          
     63          //!< Threshold to declare initialization/power up error
     64          #define MCI_INIT_ERROR_THRES        (uint16)(250.0f / 0.3f)
     65          
     66          //!< Threshold to declare class B start up error - 10 seconds by ticks of 0.3f (refer to MCI_CHECKERR_POSTSCALER)
     67          #define MCI_CLASS_B_STARTUP_THRES   (uint16)(10.0f / 0.3f)
     68          
     69          #ifndef MIN_SINT32
     70              #define MIN_SINT32  -2147483648L
     71          #endif
     72          
     73          #ifndef MAX_UINT16
     74              #define MAX_UINT16  65535L
     75          #endif
     76          
     77          
     78          #ifndef MAX_UINT32
     79              #define MAX_UINT32  4294967295UL
     80          #endif
     81          
     82          
     83          
     84          //! Define the main states of this controller
     85          typedef enum
     86          {
     87              MCI_NOT_DEFINED = 0,                            //!< 0  - reserved 0 index - shall not be used
     88              MCI_FVT_MODE,                                   //!< 1  - Function Verification Test (FVT) Mode.
     89              MCI_INITIALIZING,                               //!< 2  - initializing state
     90              MCI_IDLE,                                       //!< 3  - idling
     91              MCI_CLASS_B_STARTING,                           //!< 4  - hardware starting, checking and power up
     92              MCI_CLASS_B_STOPPING,                           //!< 5  - stopping Class B, executes before idling
     93              MCI_FAILED,                                     //!< 6  - something has failed
     94              MCI_STARTING,                                   //!< 7  - starting the motor, executes before running
     95              MCI_RUNNING,                                    //!< 8  - running
     96              MCI_STOPPING,                                   //!< 9  - stopping the motor, executes before Class B stopping
     97              MCI_DEBUGGING,                                  //!< 10 - debugging, shall not be used for production
     98              MCI_MANUAL_CONTROL,                             //!< 11 - manual control of inverter bridge, used for AC or DC, voltage or current control
     99          } MCI_CONTROL_STATE_TYPE;
    100          
    101          
    102          
    103          
    104          //! Define the behavior and algorithm flow control
    105          typedef enum
    106          {
    107              MCI_FORCE_LOWERS_ON,                            //!<  0 - Enabled all lowers IGBTs
    108              MCI_ALL_DEVICES_OFF,                            //!<  1 - Disable all 6 IGBTs
    109              MCI_REQUESTED_STOP,                             //!<  2 - Requested to stop
    110              MCI_REQUESTED_START,                            //!<  3 - Requested to start
    111          
    112              MCI_REQUESTED_MANUAL_DC_VOLTAGE,                //!<  4 - Requested to manually control the output DC voltage
    113              MCI_REQUESTED_MANUAL_AC_VOLTAGE,                //!<  5 - Requested to manually control the output AC voltage
    114              MCI_REQUESTED_MANUAL_DC_CURRENT,                //!<  6 - Requested to manually control the output DC current
    115              MCI_REQUESTED_MANUAL_AC_CURRENT,                //!<  7 - Requested to manually control the output AC current
    116          
    117              MCI_REQUESTED_FVT_MODE,                         //!<  8 - Requested to execute functional verification test (FVT)
    118          } MCI_FLOWCONTROL_TYPE;
    119          
    120          
    121          //! Define the flags used to request manual injection
    122          #define MCI_REQ_MANUAL_INJECTION_FLOW_FLAGS     ((MCI_FLOWCONTROL_TYPE)1<<MCI_REQUESTED_MANUAL_DC_VOLTAGE) +   \
    123                                                          ((MCI_FLOWCONTROL_TYPE)1<<MCI_REQUESTED_MANUAL_AC_VOLTAGE) +   \
    124                                                          ((MCI_FLOWCONTROL_TYPE)1<<MCI_REQUESTED_MANUAL_DC_CURRENT) +   \
    125                                                          ((MCI_FLOWCONTROL_TYPE)1<<MCI_REQUESTED_MANUAL_AC_CURRENT)
    126          
    127          
    128          MCI_CONTROL_STATE_TYPE Mci_Control_State;           //!< Define the states used in this controller
    129          
    130          uint32 Mci_Error;                                   //!< [MCI_ERROR_TYPE] define all flags used in the mci management, use uint32
    131                                                              //!<                  rather MCI_ERROR_TYPE to prevent lint warnings.
    132          uint32 Mci_Error_Holder;                            //!< [MCI_ERROR_TYPE] copy of the Mci_Error, use uint32 rather MCI_ERROR_TYPE
    133                                                              //!<                  to prevent lint warnings.
    134          uint32 Mci_Flow_Control;                            //!< [MCI_FLOWCONTROL_TYPE] define some actions to control the algorithm flow
    135          uint32 Mci_Status_Control;                          //!< [MCI_DI_TYPE] define some actions to control the algorithm state control
    136          uint16 Mci_GP_Timer;                                //!< [seconds / MCI_CHECKERR_POSTSCALER] General Purpose timer.
    137                                                              //!< Timer to start up after POR. This timer also helps to filter out
    138                                                              //!< the tachometer signal and to perform the timeout during start up
    139          
    140          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
    141          
    142          //! Converts a value into TRUE or FALSE; 0 is FALSE, TRUE otherwise.
    143          #ifndef GET_TRUE_FALSE
    144              #define GET_TRUE_FALSE(value)           (BOOL_TYPE)(((value) == 0) ? (FALSE) : (TRUE))
    145          #endif
    146          
    147          //! MCI_SET_ERROR sets the flags data and its holder
    148          #define MCI_SET_ERROR(mci_flags)                BIT_SET(Mci_Error_Holder, (mci_flags));                 \
    149                                                          BIT_SET(Mci_Error_Holder, MCI_ERROR_ANY_ERROR_FOUND);   \
    150                                                          BIT_SET(Mci_Error, (mci_flags))
    151          
    152          //! MCI_CLR_ERROR resets only the flags data and does not touch the holder
    153          #define MCI_CLR_ERROR(mci_flags)                BIT_CLR(Mci_Error, (mci_flags))
    154          
    155          //! MCI_FLOWCONTROL_TYPE controls the algorithm flow
    156          #define MCI_SET_FLOW_CTL(mci_flowcontrol)       BIT_SET(Mci_Flow_Control, (mci_flowcontrol))
    157          #define MCI_CLR_FLOW_CTL(mci_flowcontrol)       BIT_CLR(Mci_Flow_Control, (mci_flowcontrol))
    158          
    159          //! MCI_DI_TYPE controls the DI state of motor control
    160          #define MCI_SET_STATUS_CTL(mci_statuscontrol)   BIT_SET(Mci_Status_Control, (mci_statuscontrol))
    161          #define MCI_CLR_STATUS_CTL(mci_statuscontrol)   BIT_CLR(Mci_Status_Control, (mci_statuscontrol))
    162          
    163          
    164          #include "Mci_prv.h"                                //! This include is made here in order to make some #define above visible in the prv file
    165          
    166          //! Definition of some methods. They might be not defined in the Mci_prv.h file, however the macro is called here. So, define the macro as empty.
    167          #ifndef MCI_STARTING_ENTRY
    168              #define MCI_STARTING_ENTRY()
    169          #endif
    170          
    171          #ifndef MCI_STARTING_EXIT
    172              #define MCI_STARTING_EXIT()
    173          #endif
    174          
    175          #ifndef MCI_RUNNING_ENTRY
    176              #define MCI_RUNNING_ENTRY()
    177          #endif
    178          
    179          #ifndef MCI_RUNNING_EXIT
    180              #define MCI_RUNNING_EXIT()
    181          #endif
    182          
    183          #ifndef MCI_STOPPING_ENTRY
    184              #define MCI_STOPPING_ENTRY()
    185          #endif
    186          
    187          #ifndef MCI_STOPPING_EXIT
    188              #define MCI_STOPPING_EXIT()
    189          #endif
    190          
    191          #ifndef MCI_IDLE_PWM
    192              #define MCI_IDLE_PWM()
    193          #endif
    194          
    195          #ifndef MCI_IDLE_LEAVE
    196              #define MCI_IDLE_LEAVE()    TRUE
    197          #endif
    198          
    199          #ifndef MCI_IDLE_EXIT
    200              #define MCI_IDLE_EXIT()
    201          #endif
    202          
    203          #ifndef MCI_MANUAL_INJECTION_EXIT
    204              #define MCI_MANUAL_INJECTION_EXIT()
    205          #endif
    206          
    207          #ifndef MCI_FAILED_PWM
    208              #define MCI_FAILED_PWM()
    209          #endif
    210          
    211          #ifndef MCI_FAILED_EXIT
    212              #define MCI_FAILED_EXIT()
    213          #endif
    214          
    215          #ifndef MCL_SET_STOPPING_COAST_DOWN
    216              #define MCL_SET_STOPPING_COAST_DOWN()
    217          #endif
    218          
    219          #ifndef MCL_SET_STOPPING_LOWERS_ON
    220              #define MCL_SET_STOPPING_LOWERS_ON()
    221          #endif
    222          
    223          #ifndef MCL_SET_STOPPING_REQUEST
    224              #define MCL_SET_STOPPING_REQUEST()
    225          #endif
    226          
    227          #ifndef MCI_STARTING_PWM_STEP2
    228              #define MCI_STARTING_PWM_STEP2()
    229          #endif
    230          
    231          #ifndef MCI_FVT_ENTRY
    232              #define MCI_FVT_ENTRY()
    233          #endif
    234          
    235          #ifndef MCI_FVT_EXIT
    236              #define MCI_FVT_EXIT()
    237          #endif
    238          
    239          
    240          
    241          //! If the post scaler is required.
    242          #if (defined MCI_IDLE_2ND_PWM)             || \
    243              (defined MCI_STARTING_2ND_PWM)         || \
    244              (defined MCI_RUNNING_2ND_PWM)          || \
    245              (defined MCI_STOPPING_2ND_PWM)         || \
    246              (defined MCI_MANUAL_INJECTION_2ND_PWM) || \
    247              (defined MCI_FAILED_2ND_PWM)
    248          
    249              //! Define to use it.
    250              #define USE_HALF_PWM_FREQUENCY
    251          
    252          #endif
    253          
    254          
    255          /////////////////////// Callbacks; if they are not defined, they are declared as empty! - START
    256          // These callbacks are usually defined in the Mci_prm.h file.
    257          #ifndef MCI_INITIALIZE_CALLBACK
    258              #define MCI_INITIALIZE_CALLBACK()
    259          #endif
    260          
    261          #ifndef MCI_PWM_CALLBACK
    262              #define MCI_PWM_CALLBACK()
    263          #endif
    264          
    265          #ifndef MCI_END_PWM_CALLBACK
    266              #define MCI_END_PWM_CALLBACK()
    267          #endif
    268          
    269          #ifndef MCI_HALLS_CALLBACK
    270              #define MCI_HALLS_CALLBACK()
    271          #endif
    272          
    273          #ifndef MCI_250US_CALLBACK
    274              #define MCI_250US_CALLBACK()
    275          #endif
    276          
    277          #ifndef MCI_1MS_CALLBACK
    278              #define MCI_1MS_CALLBACK()
    279          #endif
    280          
    281          #ifndef MCI_5MS_CALLBACK
    282              #define MCI_5MS_CALLBACK()
    283          #endif
    284          
    285          #ifndef MCI_25MS_CALLBACK
    286              #define MCI_25MS_CALLBACK()
    287          #endif
    288          
    289          
    290          // Definition to connect surge relay module to the Mci.
    291          #ifdef SURGE_RELAY_USED
    292          
    293              #include "SurgeRelay.h"
    294          
    295              #define SURGE_RELAY_INITIALIZE()        SurgeRelay__Initialize()
    296              #define SURGE_RELAY_25MS_HANDLER()      SurgeRelay__25msHandler()
    297              #define SURGE_RELAY_READY()             SurgeRelay__IsBusReady()
    298          
    299          #else
    300          
    301              // Otherwise, declare the surge relay as empty module.
    302              #define SURGE_RELAY_INITIALIZE()
    303              #define SURGE_RELAY_25MS_HANDLER()
    304              #define SURGE_RELAY_READY()             TRUE
    305          
    306          #endif // SURGE_RELAY_USED
    307          
    308          
    309          // Definition to connect the inverter temperature module to the Mci.
    310          #if defined MCI_MEASURE_INVERTER_TEMP
    311          
    312              #include "InverterTemp.h"
    313          
    314              #define INVERTER_TEMP_INITIALIZE()              InverterTemp__Initialize()
    315              #define INVERTER_TEMP_25MS_HANDLER()            InverterTemp__Handler()
    316              #define INVERTER_TEMP_READ_TEMP()
    317          
    318              #define INVERTER_TEMP_GET_TEMP_S16()            InverterTemp__GetInverterTemp_s16()
    319              #define INVERTER_TEMP_GET_TEMP_RAW_DATA()       InverterTemp__GetInverterRawTemp()
    320          
    321          
    322              #ifndef INVERTER_TEMP_SETTINGFILE_SUPPORT
    323              #define INVERTER_TEMP_SETTINGFILE_SUPPORT DISABLED
    324              #endif
    325          
    326          #else
    327          
    328              // Otherwise, declare the inverter as empty module.
    329              #define INVERTER_TEMP_INITIALIZE()
    330              #define INVERTER_TEMP_25MS_HANDLER()
    331              #define INVERTER_TEMP_READ_TEMP()
    332              #define INVERTER_TEMP_SETTINGFILE_SUPPORT DISABLED
    333          #endif // MCI_MEASURE_INVERTER_TEMP
    334          
    335          #if (POWERMODULE_MANAGER_USED == ENABLED)
                      ^
Remark[Pe193]: zero used for undefined preprocessing identifier
          "POWERMODULE_MANAGER_USED"
    336              #include "PowerModuleManager.h"
    337          
    338              #define POWERMODULEMANAGER__INITIALIZE()        PowerModuleManager__Initialize()
    339              #define POWERMODULEMANAGER__25MS_HANDLER()      PowerModuleManager__25msHandler()
    340          #else
    341              #define POWERMODULE_MANAGER_USED    DISABLED
    342              #define POWERMODULEMANAGER__INITIALIZE()
    343              #define POWERMODULEMANAGER__25MS_HANDLER()
    344          #endif // POWERMODULE_MANAGER_USED
    345          
    346          #ifdef ENABLE_API220_CALLBACKS
    347          
    348              #include "APIMotorControl.h"
    349          
    350              #define API220_PUBLISHDIGITAL_CALLBACK(motor, write_data, value, ret_val)   APIMotorControl__PublishSetDigital((motor), (write_data), (value), (ret_val))
    351              #define API220_PUBLISHANALOG_CALLBACK(motor, write_data, value, ret_val)    APIMotorControl__PublishSetAnalog((motor), (write_data), (value), (ret_val))
    352              #define API220_RUN_CALLBACK(motor, speed_rpm, ramp_rpm_per_s, response)     APIMotorControl__PublishRun((motor), (speed_rpm), (ramp_rpm_per_s), (response))
    353          	#define API220_MANUAL_INJECTION_CALLBACK(motor, 			\
    354          											method, 			\
    355          											level_x32, 			\
    356          											level_rate_x32, 	\
    357          											param_x32, 			\
    358          											param_rate_x32, 	\
    359          											response)							// todo Luigi needs to implement the API220 call back of manual injection
    360              #define API220_STOP_CALLBACK(motor, ramp_rpm_per_s, response)               APIMotorControl__PublishStop((motor), (ramp_rpm_per_s), (response))
    361          
    362          #else
    363          
    364              #define API220_PUBLISHDIGITAL_CALLBACK(motor, write_data, value, ret_val)
    365              #define API220_PUBLISHANALOG_CALLBACK(motor, write_data, value, ret_val)
    366              #define API220_RUN_CALLBACK(motor, speed_rpm, ramp_rpm_per_s, response)
    367          	#define API220_MANUAL_INJECTION_CALLBACK(motor, 			\
    368          											method, 			\
    369          											level_x32, 			\
    370          											level_rate_x32, 	\
    371          											param_x32, 			\
    372          											param_rate_x32, 	\
    373          											response)
    374          	#define API220_STOP_CALLBACK(motor, ramp_rpm_per_s, response)
    375          
    376          #endif
    377          
    378          
    379          #ifndef API220_DEBUG_MODE
    380              #define API220_DEBUG_MODE   DISABLED
    381          #endif
    382          
    383          
    384          #define MCI_PARAMS_LOADED_CHECKS (2 + INVERTER_TEMP_SETTINGFILE_SUPPORT + POWERMODULE_MANAGER_USED)
    385          
    386          /////////////////////// Callbacks; if they are not defined, they are declared as empty! - END
    387          
    388          
    389          //////////////////////////////////////////////////////////////////////////////////////
    390          // Floating point \ Fixed Point MCL management  -- usually defined in mci_prv.h     //
    391          //                      if not defined, consider Fixed point notation               //
    392          //////////////////////////////////////////////////////////////////////////////////////
    393          #ifndef MCL_SPEED_REF_GEN
    394              #define MCL_SPEED_REF_GEN()  (sint32)(SpeedRefGen__Generator() / BASE_SPEED_RADS * (float32)(1U<<IQ15))
    395          #endif
    396          
    397          #ifndef MCL_CURRENT
    398              #define MCL_CURRENT(arg)  (arg)
    399          #endif
    400          
    401          #ifndef MCL_VOLTAGE
    402              #define MCL_VOLTAGE(arg)  (arg)
    403          #endif
    404          
    405          #ifndef MCL_DUTY
    406              #define MCL_DUTY(arg) (arg)
    407          #endif
    408          
    409          #ifndef MCL_NOTATION_TYPE
    410              #define MCL_NOTATION_TYPE  sint32
    411          #endif
    412          
    413          #ifndef MCL__ABS
    414              #include "McMathCalc_macros.h"
    415              #define MCL__ABS(value)  MATHCALC__ABS(value)
    416          #endif
    417          
    418          //////////////////////////////////////////////////////////////////////////////////////
    419          
    420          
    421          
    422          
    423          static void Initialize_Current_DCBus_Voltage(void);
    424          static void Read_Current_DCBus_Voltage(sint32 ia_adc, sint32 ib_adc, sint32 ic_adc, sint32 dcbus_adc);
    425          static void Drive_The_Motor(void);
    426          static void Check_Errors_Pwm_Handler(void);
    427          static void Check_Errors_5ms_Handler(void);
    428          static void Update_Status(void);
    429          
    430          
    431          //=====================================================================================================================
    432          //-------------------------------------- Public Functions -------------------------------------------------------------
    433          //=====================================================================================================================
    434          
    435          
    436          
    437          //---------------------------------------------------------------------------------------------------------------------
    438          /**
    439           *  @brief      It Initializes the module Mci and its variables.
    440           *
    441           */

   \                                 In section .text, align 2, keep-with-next
    442          void Mci__Initialize(void)
    443          {
   \                     Mci__Initialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    444              MCI_INITIALIZE_CALLBACK();
   \   00000002   0x.... 0x....      BL       BoardDebugging__Initialize
    445          
    446              SURGE_RELAY_INITIALIZE();
   \   00000006   0x2206             MOVS     R2,#+6
   \   00000008   0x2118             MOVS     R1,#+24
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0x.... 0x....      BL       Gpio__PinConfig
   \   00000010   0x.... 0x....      LDR.W    R4,??DataTable11_1
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x036C      STRB     R0,[R4, #+876]
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF8A4 0x0398      STRH     R0,[R4, #+920]
   \   00000022   0x2118             MOVS     R1,#+24
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xF884 0x036D      STRB     R0,[R4, #+877]
   \   0000002A   0x2004             MOVS     R0,#+4
   \   0000002C   0x.... 0x....      BL       Gpio__PinWrite
    447              INVERTER_TEMP_INITIALIZE();
    448              POWERMODULEMANAGER__INITIALIZE();
    449          
    450              Initialize_Current_DCBus_Voltage();
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF8C4 0x0148      STR      R0,[R4, #+328]
   \   00000036   0xF8C4 0x014C      STR      R0,[R4, #+332]
   \   0000003A   0xF8C4 0x0150      STR      R0,[R4, #+336]
   \   0000003E   0xF8C4 0x0144      STR      R0,[R4, #+324]
    451              Mcl__Initialize();
   \   00000042   0x.... 0x....      BL       Mcl__Initialize
    452              SpeedRefGen__Initialize();
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF8C4 0x04D8      STR      R0,[R4, #+1240]
   \   0000004C   0xF8C4 0x04DC      STR      R0,[R4, #+1244]
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable11_2  ;; 0x3a80adfd
   \   00000054   0xF8C4 0x04D0      STR      R0,[R4, #+1232]
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF884 0x036B      STRB     R0,[R4, #+875]
    453          
    454              // Initialize the errors that initializing procedures handles;
    455              // Other error are declared may be either not used, or not defined, or not specified
    456              // or it will require the motor be started to be checked.
    457              Mci_Error = MCI_POWER_UP_ERROR_TO_TEST;
   \   0000005E   0xF241 0x008C      MOVW     R0,#+4236
   \   00000062   0xF8C4 0x03E0      STR      R0,[R4, #+992]
    458          
    459              // No error shall be reported while starting up the inverter
    460              Mci_Error_Holder = 0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xF8C4 0x03E4      STR      R0,[R4, #+996]
    461              Mci_Flow_Control = 0;
   \   0000006C   0xF8C4 0x03E8      STR      R0,[R4, #+1000]
    462              Mci_Status_Control = 0;
   \   00000070   0xF8C4 0x03EC      STR      R0,[R4, #+1004]
    463              Mci_GP_Timer = 0;
   \   00000074   0xF8A4 0x037A      STRH     R0,[R4, #+890]
    464          
    465              Mci_Control_State = MCI_INITIALIZING;
   \   00000078   0x2002             MOVS     R0,#+2
   \   0000007A   0xF884 0x0354      STRB     R0,[R4, #+852]
    466          
    467          
    468          }
   \   0000007E   0xBD10             POP      {R4,PC}          ;; return
    469          
    470          
    471          
    472          
    473          //---------------------------------------------------------------------------------------------------------------------
    474          /**
    475           *  @brief      Handle Mci events every Pwm interrupt.
    476           *
    477              @startuml{MCI_Class_A_State_Machine.png}
    478          
    479                  title Motor Control Interface - Main state machine
    480          
    481                  [*] --> MCI_INITIALIZING
    482          
    483                  MCI_INITIALIZING : Waits until data are reliable \nfrom either Class A and Class B
    484                  MCI_INITIALIZING --> MCI_FAILED : [Initialization timer expired]
    485                  MCI_INITIALIZING --> MCI_IDLE   : [No error found] AND\n[Class B in IDLE]
    486          
    487          
    488                  MCI_IDLE : Motor is idling.
    489                  MCI_IDLE : Entry / MCI_IDLE_ENTRY()
    490                  MCI_IDLE : Do / MCI_IDLE_PWM() - MCI_IDLE_2ND_PWM()
    491                  MCI_IDLE : Exit / MCI_IDLE_EXIT()
    492                  MCI_IDLE --> MCI_CLASS_B_STARTING   : [User requested to run] OR\n[User requested to manual control]
    493                  MCI_IDLE --> MCI_FAILED : [Any error found in either Class A or Class B]
    494          
    495          
    496                  MCI_CLASS_B_STARTING : Waiting for Class B to be ready,\ne.g. perform plausibility check.
    497                  MCI_CLASS_B_STARTING --> MCI_CLASS_B_STOPPING   : [User requested to stop]
    498                  MCI_CLASS_B_STARTING --> MCI_MANUAL_CONTROL     : [User requested to manual control] AND\n[Class A granted access to PWM]
    499                  MCI_CLASS_B_STARTING --> MCI_STARTING           : [User requested to run] AND\n[Class A granted access to PWM]
    500                  MCI_CLASS_B_STARTING --> MCI_FAILED             : [Any error found in either Class A or Class B]
    501          
    502          
    503                  MCI_CLASS_B_STOPPING : Waiting for Class B to be finish its checks,\ne.g. perform plausibility check.
    504                  MCI_CLASS_B_STOPPING --> MCI_IDLE               : [Class B is IDLE]
    505                  MCI_CLASS_B_STOPPING --> MCI_FAILED             : [Any error found in either Class A or Class B]
    506          
    507          
    508                  MCI_FAILED : Fault found in either inverter or motor
    509                  MCI_FAILED : Check and recover from failure
    510                  MCI_FAILED --> MCI_IDLE   : [Class B in IDLE] AND\n[All errors are cleared]
    511          
    512          
    513                  MCI_STARTING : Motor is performing activities before running control technique
    514                  MCI_STARTING : Entry / MCI_STARTING_ENTRY()
    515                  MCI_STARTING : Do / MCI_STARTING_PWM() - MCI_STARTING_2ND_PWM()
    516                  MCI_STARTING : Exit / MCI_STARTING_EXIT()
    517                  MCI_STARTING --> MCI_CLASS_B_STOPPING   : [User requested to stop]
    518                  MCI_STARTING --> MCI_RUNNING            : [MCI_STARTING_GUARD_EXIT() == TRUE]
    519                  MCI_STARTING --> MCI_FAILED             : [Any error found in either Class A or Class B]
    520          
    521          
    522                  MCI_RUNNING : Motor is controlled by FOC/DTC, e.g. automatic control.
    523                  MCI_RUNNING : Entry / MCI_RUNNING_ENTRY()
    524                  MCI_RUNNING : Do / MCI_RUNNING_PWM() - MCI_RUNNING_2ND_PWM()
    525                  MCI_RUNNING : Exit / MCI_RUNNING_EXIT()
    526                  MCI_RUNNING --> MCI_STOPPING            : [MCI_RUNNING_GUARD_EXIT() == TRUE]
    527                  MCI_RUNNING --> MCI_FAILED              : [Any error found in either Class A or Class B]
    528          
    529          
    530                  MCI_MANUAL_CONTROL : Motor is under manual control.
    531                  MCI_MANUAL_CONTROL : Entry / MCI_MANUAL_INJECTION_ENTRY()
    532                  MCI_MANUAL_CONTROL : Do / MCI_MANUAL_INJECTION_PWM() - MCI_MANUAL_INJECTION_2ND_PWM()
    533                  MCI_MANUAL_CONTROL : Exit / MCI_MANUAL_INJECTION_EXIT()
    534                  MCI_MANUAL_CONTROL --> MCI_CLASS_B_STOPPING     : [User requested to stop]
    535                  MCI_MANUAL_CONTROL --> MCI_FAILED               : [Any error found in either Class A or Class B]
    536          
    537          
    538                  MCI_STOPPING : Motor is controlled by class A and it is stopping.
    539                  MCI_STOPPING : Entry / MCI_STOPPING_ENTRY()
    540                  MCI_STOPPING : Do / MCI_STOPPING_PWM() - MCI_STOPPING_2ND_PWM()
    541                  MCI_STOPPING : Exit / MCI_STOPPING_EXIT()
    542                  MCI_STOPPING --> MCI_CLASS_B_STOPPING   : [MCI_STOPPING_GUARD_EXIT() == TRUE]
    543                  MCI_STOPPING --> MCI_FAILED             : [Any error found in either Class A or Class B]
    544          
    545              @enduml
    546           */

   \                                 In section .text, align 4, keep-with-next
    547          void Mci__PwmHandler(sint32 ia_adc, sint32 ib_adc, sint32 ic_adc, sint32 dcbus_adc)
    548          {
   \                     Mci__PwmHandler: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    549          #ifdef USE_HALF_PWM_FREQUENCY
    550          
    551              static unsigned char pwm_post_scaler = 0;
    552          
    553              pwm_post_scaler++;
    554          
    555          #endif
    556          
    557              // Read and scales offseted values from class B
    558              Read_Current_DCBus_Voltage(ia_adc, ib_adc, ic_adc, dcbus_adc);
   \   00000002   0x4240             RSBS     R0,R0,#+0
   \   00000004   0x0100             LSLS     R0,R0,#+4
   \   00000006   0xEE00 0x0A90      VMOV     S1,R0
   \   0000000A   0xED9F 0x0A37      VLDR.W   S0,??Mci__PwmHandler_0  ;; 0x4103851f
   \   0000000E   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000012   0x.... 0x....      LDR.W    R4,??DataTable11_1
   \   00000016   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   0000001A   0xED9F 0x1A34      VLDR.W   S2,??Mci__PwmHandler_0+0x4  ;; 0x38000000
   \   0000001E   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   00000022   0x4248             RSBS     R0,R1,#+0
   \   00000024   0xEDC4 0x0A52      VSTR     S1,[R4, #+328]
   \   00000028   0x0100             LSLS     R0,R0,#+4
   \   0000002A   0xEE00 0x0A90      VMOV     S1,R0
   \   0000002E   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000032   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000036   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   0000003A   0x4250             RSBS     R0,R2,#+0
   \   0000003C   0xEDC4 0x0A53      VSTR     S1,[R4, #+332]
   \   00000040   0x0100             LSLS     R0,R0,#+4
   \   00000042   0xEE00 0x0A90      VMOV     S1,R0
   \   00000046   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   0000004A   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   0000004E   0xEDDF 0x0A27      VLDR.W   S1,??Mci__PwmHandler_0+0x4  ;; 0x38000000
   \   00000052   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000056   0xED84 0x0A54      VSTR     S0,[R4, #+336]
   \   0000005A   0x00D8             LSLS     R0,R3,#+3
   \   0000005C   0xEE00 0x0A10      VMOV     S0,R0
   \   00000060   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000064   0xEDDF 0x0A22      VLDR.W   S1,??Mci__PwmHandler_0+0x8  ;; 0x43ddb333
   \   00000068   0xF894 0x5355      LDRB     R5,[R4, #+853]
    559          
    560              // Callback running at pwm rate
    561              MCI_PWM_CALLBACK();
    562          
    563              // Check errors at pwm rate
    564              Check_Errors_Pwm_Handler();
   \   0000006C   0xF8D4 0x13E0      LDR      R1,[R4, #+992]
   \   00000070   0xF894 0x0354      LDRB     R0,[R4, #+852]
   \   00000074   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000078   0xEDDF 0x0A1C      VLDR.W   S1,??Mci__PwmHandler_0+0x4  ;; 0x38000000
   \   0000007C   0x1C6D             ADDS     R5,R5,#+1
   \   0000007E   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000082   0xB081             SUB      SP,SP,#+4
   \   00000084   0xF884 0x5355      STRB     R5,[R4, #+853]
   \   00000088   0xED84 0x0A51      VSTR     S0,[R4, #+324]
   \   0000008C   0x2807             CMP      R0,#+7
   \   0000008E   0xDB33             BLT.N    ??Mci__PwmHandler_1
   \   00000090   0xF8D4 0x2148      LDR      R2,[R4, #+328]
   \   00000094   0xF022 0x4200      BIC      R2,R2,#0x80000000
   \   00000098   0xEE00 0x2A10      VMOV     S0,R2
   \   0000009C   0xF8D4 0x214C      LDR      R2,[R4, #+332]
   \   000000A0   0xF022 0x4200      BIC      R2,R2,#0x80000000
   \   000000A4   0xEE00 0x2A90      VMOV     S1,R2
   \   000000A8   0xF8D4 0x2150      LDR      R2,[R4, #+336]
   \   000000AC   0xEDDF 0x1A11      VLDR.W   S3,??Mci__PwmHandler_0+0xC  ;; 0x4101999a
   \   000000B0   0xF022 0x4200      BIC      R2,R2,#0x80000000
   \   000000B4   0xEEB4 0x0A61      VCMP.F32 S0,S3
   \   000000B8   0xEE01 0x2A10      VMOV     S2,R2
   \   000000BC   0xEEF1 0xFA10      FMSTAT   
   \   000000C0   0xBFBF             ITTTT    LT 
   \   000000C2   0xEEF4 0x0A61      VCMPLT.F32 S1,S3
   \   000000C6   0xEEF1 0xFA10      FMSTATLT 
   \   000000CA   0xEEB4 0x1A61      VCMPLT.F32 S2,S3
   \   000000CE   0xEEF1 0xFA10      FMSTATLT 
   \   000000D2   0xDB11             BLT.N    ??Mci__PwmHandler_1
   \   000000D4   0xF8D4 0x23E4      LDR      R2,[R4, #+996]
   \   000000D8   0xF240 0x4301      MOVW     R3,#+1025
   \   000000DC   0x431A             ORRS     R2,R3,R2
   \   000000DE   0xF8C4 0x23E4      STR      R2,[R4, #+996]
   \   000000E2   0xF441 0x6180      ORR      R1,R1,#0x400
   \   000000E6   0xE009             B.N      ??Mci__PwmHandler_2
   \                     ??Mci__PwmHandler_0:
   \   000000E8   0x4103851F         DC32     0x4103851f
   \   000000EC   0x38000000         DC32     0x38000000
   \   000000F0   0x43DDB333         DC32     0x43ddb333
   \   000000F4   0x4101999A         DC32     0x4101999a
   \                     ??Mci__PwmHandler_1: (+1)
   \   000000F8   0xF421 0x6180      BIC      R1,R1,#0x400
   \                     ??Mci__PwmHandler_2: (+1)
   \   000000FC   0xF8C4 0x13E0      STR      R1,[R4, #+992]
    565          
    566              ////////////////////////////////////////////////
    567              ////////////////////////////////////////////////
    568              ////////////////////////////////////////////////
    569              ////////////////////////////////////////////////
    570              // If any error is found...
    571              if(Mci_Error)
   \   00000100   0x2900             CMP      R1,#+0
   \   00000102   0xD048             BEQ.N    ??Mci__PwmHandler_3
    572              {
    573                  // then set the state machine to error
    574                  // if it is not under initialization.
    575                  if((Mci_Control_State > MCI_INITIALIZING)|| \
    576                     ((Mci_Control_State == MCI_INITIALIZING)&&(BIT_TEST(Mci_Error, MCI_ERROR_INITIALIZATION_FAILED))))
   \   00000104   0x2803             CMP      R0,#+3
   \   00000106   0xDA06             BGE.N    ??Mci__PwmHandler_4
   \   00000108   0x2802             CMP      R0,#+2
   \   0000010A   0xF040 0x8295      BNE.W    ??Mci__PwmHandler_5
   \   0000010E   0xF3C1 0x0040      UBFX     R0,R1,#+1,#+1
   \   00000112   0x2800             CMP      R0,#+0
   \   00000114   0xD03A             BEQ.N    ??Mci__PwmHandler_6
    577                  {
    578                      Mci_Control_State = MCI_FAILED;
   \                     ??Mci__PwmHandler_4: (+1)
   \   00000116   0x2006             MOVS     R0,#+6
   \   00000118   0xF884 0x0354      STRB     R0,[R4, #+852]
    579          
    580                      MCI_DEFAULT_ERROR_REACTION();
   \   0000011C   0xF8D4 0x03E8      LDR      R0,[R4, #+1000]
   \   00000120   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000124   0xF8C4 0x03E8      STR      R0,[R4, #+1000]
    581                  }
    582              }
    583          
    584          
    585              ////////////////////////////////////////////////
    586              ////////////////////////////////////////////////
    587              ////////////////////////////////////////////////
    588              ////////////////////////////////////////////////
    589              if(Mci_Control_State == MCI_RUNNING)
    590              {
    591          
    592          #if (defined MCI_RUNNING_2ND_PWM)
    593          
    594                  if(pwm_post_scaler & 0x01)
    595                  {
    596                      MCI_RUNNING_PWM();
    597          
    598                      if(MCI_RUNNING_GUARD_EXIT() == TRUE)
    599                      {
    600                          MCI_RUNNING_EXIT();
    601                          MCI_STOPPING_ENTRY();
    602                          Mci_Control_State = MCI_STOPPING;
    603                      }
    604                  }
    605                  else
    606                  {
    607                      Mcl_IO.Speed_Rot_Ref = MCL_SPEED_REF_GEN();
    608          
    609                      MCI_RUNNING_2ND_PWM();
    610                  }
    611          
    612          #else
    613          
    614                  Mcl_IO.Speed_Rot_Ref = MCL_SPEED_REF_GEN();
    615          
    616                  MCI_RUNNING_PWM();
    617          
    618                  if(MCI_RUNNING_GUARD_EXIT() == TRUE)
    619                  {
    620                      MCI_RUNNING_EXIT();
    621                      MCI_STOPPING_ENTRY();
    622                      Mci_Control_State = MCI_STOPPING;
    623                  }
    624          
    625          #endif
    626          
    627                  Drive_The_Motor();
    628              }
    629          
    630          
    631          
    632              ////////////////////////////////////////////////
    633              ////////////////////////////////////////////////
    634              ////////////////////////////////////////////////
    635              ////////////////////////////////////////////////
    636              else if(Mci_Control_State == MCI_STARTING)
    637              {
    638          
    639          #if (defined MCI_STARTING_2ND_PWM)
    640          
    641                  if(pwm_post_scaler & 0x01)
    642                  {
    643                      MCI_STARTING_PWM();
    644                  }
    645                  else
    646                  {
    647                      MCI_STARTING_2ND_PWM();
    648                  }
    649          
    650          #else
    651          
    652                  MCI_STARTING_PWM();
    653          
    654          #endif
    655          
    656                  Drive_The_Motor();
    657          
    658                  if(BIT_TEST(Mci_Flow_Control, MCI_REQUESTED_STOP))
    659                  {
    660                      MCI_STARTING_EXIT();
    661                      Mci_Control_State = MCI_CLASS_B_STOPPING;
    662                  }
    663                  else if(MCI_STARTING_GUARD_EXIT() == TRUE)
    664                  {
    665                      MCI_STARTING_EXIT();
    666                      MCI_RUNNING_ENTRY();
    667                      Mci_Control_State = MCI_RUNNING;
    668                  }
    669          
    670                  // temporary fix - required to optimize "robust start"
    671                  // issue found: drive to update pwm is required due to slot overflow
    672                  if(MCI_STARTING_GUARD_EXIT() == FALSE)
    673                  {
    674                      MCI_STARTING_PWM_STEP2();
    675                  }
    676              }
    677          
    678          
    679          
    680              ////////////////////////////////////////////////
    681              ////////////////////////////////////////////////
    682              ////////////////////////////////////////////////
    683              ////////////////////////////////////////////////
    684              else if(Mci_Control_State == MCI_CLASS_B_STARTING)
    685              {
    686                  MotorSafetyMgr__Prepare2StartMotor();
    687          
    688                  if(BIT_TEST(Mci_Flow_Control, MCI_REQUESTED_STOP))
    689                  {
    690                      Mci_Control_State = MCI_CLASS_B_STOPPING;
    691                  }
    692                  else if(MotorSafetyMgr__DoesClassAHaveAccessToPwm() == TRUE)
    693                  {
    694                      if(Mci_Flow_Control & MCI_REQ_MANUAL_INJECTION_FLOW_FLAGS)
    695                      {
    696                          MCI_MANUAL_INJECTION_ENTRY();
    697                          Mci_Control_State = MCI_MANUAL_CONTROL;
    698                      }
    699                      else if(BIT_TEST(Mci_Flow_Control, MCI_REQUESTED_START))
    700                      {
    701                          SpeedRefGen__Reset();
    702                          MCI_STARTING_ENTRY();
    703                          Mci_Control_State = MCI_STARTING;
    704                      }
    705          #if defined MCI_FVT_PMW
    706                      else if(BIT_TEST(Mci_Flow_Control, MCI_REQUESTED_FVT_MODE))
    707                      {
    708                          MCI_FVT_ENTRY();
    709                          Mci_Control_State = MCI_FVT_MODE;
    710                      }
    711          #endif
    712          
    713                      MCI_CLR_FLOW_CTL(MCI_REQUESTED_START);
    714                  }
    715              }
    716          
    717          
    718          
    719              ////////////////////////////////////////////////
    720              ////////////////////////////////////////////////
    721              ////////////////////////////////////////////////
    722              ////////////////////////////////////////////////
    723              else if(Mci_Control_State == MCI_STOPPING)
    724              {
    725          
    726          #if defined MCI_STOPPING_2ND_PWM
    727          
    728                  if(pwm_post_scaler & 0x01)
    729                  {
    730                      MCI_STOPPING_PWM();
    731          
    732                      if(MCI_STOPPING_GUARD_EXIT())
    733                      {
    734                          MCI_STOPPING_EXIT();
    735                          Mci_Control_State = MCI_CLASS_B_STOPPING;
    736                      }
    737                  }
    738                  else
    739                  {
    740                       MCI_STOPPING_2ND_PWM();
    741                  }
    742          
    743          #else
    744          
    745                  MCI_STOPPING_PWM();
    746          
    747                  if(MCI_STOPPING_GUARD_EXIT())
    748                  {
    749                      MCI_STOPPING_EXIT();
    750                      Mci_Control_State = MCI_CLASS_B_STOPPING;
    751                  }
    752          
    753          #endif
    754          
    755                  Drive_The_Motor();
    756          
    757              }
    758          
    759          
    760          
    761          
    762              ////////////////////////////////////////////////
    763              ////////////////////////////////////////////////
    764              ////////////////////////////////////////////////
    765              ////////////////////////////////////////////////
    766              else if(Mci_Control_State == MCI_CLASS_B_STOPPING)
    767              {
    768                  MotorSafetyMgr__Prepare2StopMotor();
    769          
    770                  if(MotorSafetyMgr__IsInIdle() == TRUE)
    771                  {
    772                      SpeedRefGen__Initialize();
    773          
    774                      MCI_IDLE_ENTRY();
    775          
    776                      Mci_Control_State = MCI_IDLE;
    777                  }
    778              }
    779          
    780          
    781          
    782          
    783              ////////////////////////////////////////////////
    784              ////////////////////////////////////////////////
    785              ////////////////////////////////////////////////
    786              ////////////////////////////////////////////////
    787              else if(Mci_Control_State == MCI_INITIALIZING)
    788              {
    789          		// if no error found, then move to the next state
    790          		if(!Mci_Error)
    791          		{
    792          			if(MotorSafetyMgr__IsInIdle() == TRUE)
    793          			{
    794          				Mci_Error_Holder = 0;
    795          
    796          				MCI_IDLE_ENTRY();
    797          				Mci_Control_State = MCI_IDLE;
    798          			}
    799          		}
    800              }
    801          
    802              ////////////////////////////////////////////////
    803              ////////////////////////////////////////////////
    804              ////////////////////////////////////////////////
    805              ////////////////////////////////////////////////
    806              else if(Mci_Control_State == MCI_IDLE)
    807              {
    808                  Mcl_IO.Speed_Rot_Ref = 0;
    809          
    810                  MCI_CLR_FLOW_CTL(MCI_REQUESTED_STOP);
    811                  MCI_CLR_FLOW_CTL(MCI_ALL_DEVICES_OFF);
    812                  MCI_CLR_FLOW_CTL(MCI_FORCE_LOWERS_ON);
    813          
    814          #if defined MCI_IDLE_2ND_PWM
    815          
    816                  if(pwm_post_scaler & 0x01)
    817                  {
    818                      MCI_IDLE_PWM();
    819                  }
    820                  else
    821                  {
    822                      MCI_IDLE_2ND_PWM();
    823                  }
    824          
    825          #else
    826          
    827                  MCI_IDLE_PWM();
    828          
    829          #endif
    830          
    831                  Drive_The_Motor();
    832          
    833                  if(((BIT_TEST(Mci_Flow_Control, MCI_REQUESTED_START))       ||
    834                      (BIT_TEST(Mci_Flow_Control, MCI_REQUESTED_FVT_MODE))    ||
    835                      (Mci_Flow_Control & MCI_REQ_MANUAL_INJECTION_FLOW_FLAGS) ) &&
    836                      (MCI_IDLE_LEAVE()))
    837                  {
    838                      MCI_IDLE_EXIT();
    839                      Mci_GP_Timer = 0;
    840                      Mci_Control_State = MCI_CLASS_B_STARTING;
    841                  }
    842              }
    843          
    844          
    845          
    846          
    847              ////////////////////////////////////////////////
    848              ////////////////////////////////////////////////
    849              ////////////////////////////////////////////////
    850              ////////////////////////////////////////////////
    851              else if(Mci_Control_State == MCI_DEBUGGING)
    852              {
    853          
    854              }
    855          
    856              ////////////////////////////////////////////////
    857              ////////////////////////////////////////////////
    858              ////////////////////////////////////////////////
    859              ////////////////////////////////////////////////
    860              else if(Mci_Control_State == MCI_MANUAL_CONTROL)
    861              {
    862          
    863          #if defined MCI_MANUAL_INJECTION_2ND_PWM
    864          
    865                  if(pwm_post_scaler & 0x01)
    866                  {
    867                      MCI_MANUAL_INJECTION_PWM();
    868                  }
    869                  else
    870                  {
    871                      MCI_MANUAL_INJECTION_2ND_PWM();
    872                  }
    873          
    874          #else
    875          
    876                  MCI_MANUAL_INJECTION_PWM();
    877          
    878          #endif
    879          
    880                  Drive_The_Motor();
    881          
    882                  if(BIT_TEST(Mci_Flow_Control, MCI_REQUESTED_STOP))
    883                  {
    884                      // Clear all requests.
    885                      MCI_CLR_FLOW_CTL(MCI_REQUESTED_MANUAL_DC_VOLTAGE);
    886                      MCI_CLR_FLOW_CTL(MCI_REQUESTED_MANUAL_AC_VOLTAGE);
    887                      MCI_CLR_FLOW_CTL(MCI_REQUESTED_MANUAL_DC_CURRENT);
    888                      MCI_CLR_FLOW_CTL(MCI_REQUESTED_MANUAL_AC_CURRENT);
    889          
    890                      MCI_MANUAL_INJECTION_EXIT();
    891                      Mci_Control_State = MCI_CLASS_B_STOPPING;
    892                  }
    893              }
    894          
    895              ////////////////////////////////////////////////
    896              ////////////////////////////////////////////////
    897              ////////////////////////////////////////////////
    898              ////////////////////////////////////////////////
    899          #if defined MCI_FVT_PMW
    900              else if(Mci_Control_State == MCI_FVT_MODE)
    901              {
    902          
    903                  #if defined MCI_FVT_2ND_PWM
    904          
    905                      if(pwm_post_scaler & 0x01)
    906                      {
    907                          MCI_FVT_PMW();
    908                      }
    909                      else
    910                      {
    911                          MCI_FVT_2ND_PWM();
    912                      }
    913          
    914                  #else
    915          
    916                          MCI_FVT_PMW();
    917          
    918                  #endif
    919          
    920                  Drive_The_Motor();
    921          
    922                  if( (MCI_FVT_GUARD_EXIT() == TRUE) ||
    923                      (BIT_TEST(Mci_Flow_Control, MCI_REQUESTED_STOP)))
    924                  {
    925                      if(!Mci_Error)
    926                      {
    927                          Mci_Error_Holder = 0;
    928          
    929                          MCI_CLR_FLOW_CTL(MCI_REQUESTED_FVT_MODE);
    930          
    931                          MCI_FVT_EXIT();
    932                          Mci_Control_State = MCI_CLASS_B_STOPPING;
    933                      }
    934                  }
    935              }
    936          
    937          #endif
    938          
    939              ////////////////////////////////////////////////
    940              ////////////////////////////////////////////////
    941              ////////////////////////////////////////////////
    942              ////////////////////////////////////////////////
    943              else // MCI_FAILED
    944              {
    945          #if defined MCI_FAILED_2ND_PWM
    946          
    947                  if(pwm_post_scaler & 0x01)
    948                  {
    949                      MotorSafetyMgr__Prepare2StopMotor();
    950          
    951                      MCI_FAILED_PWM();
    952                  }
    953                  else
    954                  {
    955                      MCI_FAILED_2ND_PWM();
    956                  }
    957          
    958          #else
    959          
    960                  MotorSafetyMgr__Prepare2StopMotor();
   \                     ??Mci__PwmHandler_7: (+1)
   \   00000128   0x.... 0x....      BL       SRMotorSafetyMgr__Prepare2StopMotor
    961          
    962                  MCI_FAILED_PWM();
    963          
    964          #endif
    965          
    966                  if(MotorSafetyMgr__IsInIdle() == TRUE)
   \   0000012C   0xF204 0x3173      ADDW     R1,R4,#+883
   \   00000130   0xF204 0x3072      ADDW     R0,R4,#+882
   \   00000134   0x.... 0x....      BL       SRData__CheckByte
   \   00000138   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   0000013C   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000140   0x.... 0x....      BL       SRData__CheckByte
   \   00000144   0xF894 0x0372      LDRB     R0,[R4, #+882]
   \   00000148   0xF8B4 0x13A6      LDRH     R1,[R4, #+934]
   \   0000014C   0x2802             CMP      R0,#+2
   \   0000014E   0xD11D             BNE.N    ??Mci__PwmHandler_6
   \   00000150   0x0748             LSLS     R0,R1,#+29
   \   00000152   0xD41B             BMI.N    ??Mci__PwmHandler_6
    967                  {
    968                  	// Ensure the initialization error flag will be reset
    969                  	// in a later call of Check_Errors_5ms_Handler()
    970                  	Mci_GP_Timer = 0;
   \   00000154   0x2000             MOVS     R0,#+0
   \   00000156   0xF8A4 0x037A      STRH     R0,[R4, #+890]
    971          
    972                      SpeedRefGen__Initialize();
   \   0000015A   0xF8C4 0x04D8      STR      R0,[R4, #+1240]
   \   0000015E   0xF8C4 0x04DC      STR      R0,[R4, #+1244]
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable11_2  ;; 0x3a80adfd
   \   00000166   0xF8C4 0x04D0      STR      R0,[R4, #+1232]
   \   0000016A   0x2000             MOVS     R0,#+0
   \   0000016C   0xF884 0x036B      STRB     R0,[R4, #+875]
    973          
    974                      if(!Mci_Error)
   \   00000170   0xF8D4 0x03E0      LDR      R0,[R4, #+992]
   \   00000174   0xB950             CBNZ.N   R0,??Mci__PwmHandler_6
    975                      {
    976                          MCI_CLR_FLOW_CTL(MCI_REQUESTED_START);
    977                          MCI_CLR_FLOW_CTL(MCI_ALL_DEVICES_OFF);
    978                          MCI_CLR_FLOW_CTL(MCI_REQUESTED_FVT_MODE);
    979                          MCI_CLR_FLOW_CTL(MCI_REQUESTED_MANUAL_DC_VOLTAGE);
    980                          MCI_CLR_FLOW_CTL(MCI_REQUESTED_MANUAL_AC_VOLTAGE);
    981                          MCI_CLR_FLOW_CTL(MCI_REQUESTED_MANUAL_DC_CURRENT);
    982                          MCI_CLR_FLOW_CTL(MCI_REQUESTED_MANUAL_AC_CURRENT);
   \   00000176   0xF8D4 0x03E8      LDR      R0,[R4, #+1000]
   \   0000017A   0xF420 0x70FD      BIC      R0,R0,#0x1FA
   \   0000017E   0xF8C4 0x03E8      STR      R0,[R4, #+1000]
    983          
    984                          MCI_FAILED_EXIT();
    985                          MCI_IDLE_ENTRY();
   \                     ??Mci__PwmHandler_8: (+1)
   \   00000182   0x.... 0x....      BL       Mcl__ResetAll
    986                          Mci_Control_State = MCI_IDLE;
   \   00000186   0x2003             MOVS     R0,#+3
   \                     ??Mci__PwmHandler_9: (+1)
   \   00000188   0xF884 0x0354      STRB     R0,[R4, #+852]
    987                      }
    988                  }
    989              }
    990          
    991              // Callback running at pwm rate, executed at end of pwm call
    992              MCI_END_PWM_CALLBACK();
   \                     ??Mci__PwmHandler_6: (+1)
   \   0000018C   0xB001             ADD      SP,SP,#+4
   \   0000018E   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   00000192   0x.... 0x....      B.W      BoardDebugging__PwmHandler
   \                     ??Mci__PwmHandler_3: (+1)
   \   00000196   0x2808             CMP      R0,#+8
   \   00000198   0xF040 0x80AC      BNE.W    ??Mci__PwmHandler_10
   \   0000019C   0x07E8             LSLS     R0,R5,#+31
   \   0000019E   0xD518             BPL.N    ??Mci__PwmHandler_11
   \   000001A0   0x.... 0x....      BL       Mcl__RunningHandler
   \   000001A4   0x2001             MOVS     R0,#+1
   \   000001A6   0x.... 0x....      BL       Mcl__GetDigital
   \   000001AA   0x2801             CMP      R0,#+1
   \   000001AC   0xD115             BNE.N    ??Mci__PwmHandler_12
   \   000001AE   0xF894 0x00E4      LDRB     R0,[R4, #+228]
   \   000001B2   0x07C0             LSLS     R0,R0,#+31
   \   000001B4   0xD509             BPL.N    ??Mci__PwmHandler_13
   \   000001B6   0xF504 0x7046      ADD      R0,R4,#+792
   \   000001BA   0x.... 0x....      BL       MclSpeedCtrl__ResetState
   \   000001BE   0xF504 0x71CE      ADD      R1,R4,#+412
   \   000001C2   0xF504 0x70FE      ADD      R0,R4,#+508
   \   000001C6   0x.... 0x....      BL       MclObserver__ResetState
   \                     ??Mci__PwmHandler_13: (+1)
   \   000001CA   0x2009             MOVS     R0,#+9
   \   000001CC   0xF884 0x0354      STRB     R0,[R4, #+852]
   \   000001D0   0xE003             B.N      ??Mci__PwmHandler_12
   \                     ??Mci__PwmHandler_11: (+1)
   \   000001D2   0x.... 0x....      BL       SpeedRefGen__Generator
   \   000001D6   0xED84 0x0A55      VSTR     S0,[R4, #+340]
   \                     ??Mci__PwmHandler_12: (+1)
   \   000001DA   0xF8D4 0x03E8      LDR      R0,[R4, #+1000]
   \   000001DE   0x07C1             LSLS     R1,R0,#+31
   \   000001E0   0xD469             BMI.N    ??Mci__PwmHandler_14
   \   000001E2   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   000001E6   0xB1C8             CBZ.N    R0,??Mci__PwmHandler_15
   \                     ??Mci__PwmHandler_16: (+1)
   \   000001E8   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   000001EC   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   000001F0   0x.... 0x....      BL       SRData__CheckShort
   \   000001F4   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   000001F8   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   000001FC   0x2800             CMP      R0,#+0
   \   000001FE   0xD0C5             BEQ.N    ??Mci__PwmHandler_6
   \   00000200   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40038008
   \   00000204   0x6D81             LDR      R1,[R0, #+88]
   \   00000206   0xF041 0x013F      ORR      R1,R1,#0x3F
   \   0000020A   0x6581             STR      R1,[R0, #+88]
   \   0000020C   0x6EC1             LDR      R1,[R0, #+108]
   \   0000020E   0x060A             LSLS     R2,R1,#+24
   \   00000210   0x0FD2             LSRS     R2,R2,#+31
   \   00000212   0xD0BB             BEQ.N    ??Mci__PwmHandler_6
   \   00000214   0xF021 0x018F      BIC      R1,R1,#0x8F
   \   00000218   0x66C1             STR      R1,[R0, #+108]
   \   0000021A   0xE7B7             B.N      ??Mci__PwmHandler_6
   \                     ??Mci__PwmHandler_15: (+1)
   \   0000021C   0xF894 0x018D      LDRB     R0,[R4, #+397]
   \   00000220   0xF894 0x118C      LDRB     R1,[R4, #+396]
   \   00000224   0xFA50 0xF281      UXTAB    R2,R0,R1
   \   00000228   0xB122             CBZ.N    R2,??Mci__PwmHandler_17
   \   0000022A   0x2900             CMP      R1,#+0
   \   0000022C   0xD143             BNE.N    ??Mci__PwmHandler_14
   \   0000022E   0x2800             CMP      R0,#+0
   \   00000230   0xD0AC             BEQ.N    ??Mci__PwmHandler_6
   \   00000232   0xE7D9             B.N      ??Mci__PwmHandler_16
   \                     ??Mci__PwmHandler_17: (+1)
   \   00000234   0xED9F 0x0AC8      VLDR.W   S0,??Mci__PwmHandler_18  ;; 0x47000000
   \   00000238   0xEDD4 0x0A5F      VLDR     S1,[R4, #+380]
   \   0000023C   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000240   0xEEFD 0x0AE0      VCVT.S32.F32 S1,S1
   \   00000244   0xEE10 0x7A90      VMOV     R7,S1
   \   00000248   0xEDD4 0x0A5E      VLDR     S1,[R4, #+376]
   \   0000024C   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000250   0xEEFD 0x0AE0      VCVT.S32.F32 S1,S1
   \   00000254   0xEE10 0x6A90      VMOV     R6,S1
   \   00000258   0xEDD4 0x0A5D      VLDR     S1,[R4, #+372]
   \   0000025C   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   00000260   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000264   0xEE10 0x5A10      VMOV     R5,S0
   \   00000268   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   0000026C   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000270   0x.... 0x....      BL       SRData__CheckShort
   \   00000274   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   00000278   0x0780             LSLS     R0,R0,#+30
   \   0000027A   0xD587             BPL.N    ??Mci__PwmHandler_6
   \   0000027C   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40038008
   \   00000280   0x6801             LDR      R1,[R0, #+0]
   \   00000282   0x1C49             ADDS     R1,R1,#+1
   \   00000284   0xFB07 0xF201      MUL      R2,R7,R1
   \   00000288   0xFB06 0xF301      MUL      R3,R6,R1
   \   0000028C   0x4369             MULS     R1,R1,R5
   \   0000028E   0x0049             LSLS     R1,R1,#+1
   \   00000290   0x1409             ASRS     R1,R1,#+16
   \   00000292   0x6301             STR      R1,[R0, #+48]
   \   00000294   0x005B             LSLS     R3,R3,#+1
   \   00000296   0x4249             RSBS     R1,R1,#+0
   \   00000298   0x6281             STR      R1,[R0, #+40]
   \   0000029A   0x141B             ASRS     R3,R3,#+16
   \   0000029C   0x4259             RSBS     R1,R3,#+0
   \   0000029E   0x0052             LSLS     R2,R2,#+1
   \   000002A0   0x6181             STR      R1,[R0, #+24]
   \   000002A2   0x1412             ASRS     R2,R2,#+16
   \   000002A4   0x4251             RSBS     R1,R2,#+0
   \   000002A6   0x6081             STR      R1,[R0, #+8]
   \   000002A8   0x6203             STR      R3,[R0, #+32]
   \   000002AA   0xF44F 0x7100      MOV      R1,#+512
   \   000002AE   0x6102             STR      R2,[R0, #+16]
   \   000002B0   0xF8C0 0x1090      STR      R1,[R0, #+144]
   \   000002B4   0xE76A             B.N      ??Mci__PwmHandler_6
   \                     ??Mci__PwmHandler_14: (+1)
   \   000002B6   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   000002BA   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   000002BE   0x.... 0x....      BL       SRData__CheckShort
   \   000002C2   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   000002C6   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   000002CA   0x2800             CMP      R0,#+0
   \   000002CC   0xF43F 0xAF5E      BEQ.W    ??Mci__PwmHandler_6
   \   000002D0   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40038008
   \   000002D4   0x2100             MOVS     R1,#+0
   \   000002D6   0x6301             STR      R1,[R0, #+48]
   \   000002D8   0x6281             STR      R1,[R0, #+40]
   \   000002DA   0x6201             STR      R1,[R0, #+32]
   \   000002DC   0x6181             STR      R1,[R0, #+24]
   \   000002DE   0x6101             STR      R1,[R0, #+16]
   \   000002E0   0x6081             STR      R1,[R0, #+8]
   \   000002E2   0xF44F 0x7100      MOV      R1,#+512
   \   000002E6   0xF8C0 0x1090      STR      R1,[R0, #+144]
   \   000002EA   0x6D81             LDR      R1,[R0, #+88]
   \   000002EC   0x0989             LSRS     R1,R1,#+6
   \   000002EE   0x0189             LSLS     R1,R1,#+6
   \   000002F0   0x6581             STR      R1,[R0, #+88]
   \   000002F2   0xE74B             B.N      ??Mci__PwmHandler_6
   \                     ??Mci__PwmHandler_10: (+1)
   \   000002F4   0x2807             CMP      R0,#+7
   \   000002F6   0xF040 0x80AF      BNE.W    ??Mci__PwmHandler_19
   \   000002FA   0x07E8             LSLS     R0,R5,#+31
   \   000002FC   0xD509             BPL.N    ??Mci__PwmHandler_20
   \   000002FE   0xF894 0x0357      LDRB     R0,[R4, #+855]
   \   00000302   0x2801             CMP      R0,#+1
   \   00000304   0xD105             BNE.N    ??Mci__PwmHandler_20
   \   00000306   0x.... 0x....      BL       ??Estimate_Stator_Resistance
   \   0000030A   0xB110             CBZ.N    R0,??Mci__PwmHandler_20
   \   0000030C   0x2003             MOVS     R0,#+3
   \   0000030E   0xF884 0x0357      STRB     R0,[R4, #+855]
   \                     ??Mci__PwmHandler_20: (+1)
   \   00000312   0xF8D4 0x03E8      LDR      R0,[R4, #+1000]
   \   00000316   0x07C1             LSLS     R1,R0,#+31
   \   00000318   0xD468             BMI.N    ??Mci__PwmHandler_21
   \   0000031A   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000031E   0xB950             CBNZ.N   R0,??Mci__PwmHandler_22
   \   00000320   0xF894 0x018D      LDRB     R0,[R4, #+397]
   \   00000324   0xF894 0x118C      LDRB     R1,[R4, #+396]
   \   00000328   0xFA50 0xF281      UXTAB    R2,R0,R1
   \   0000032C   0xB1EA             CBZ.N    R2,??Mci__PwmHandler_23
   \   0000032E   0x2900             CMP      R1,#+0
   \   00000330   0xD15C             BNE.N    ??Mci__PwmHandler_21
   \   00000332   0x2800             CMP      R0,#+0
   \   00000334   0xD076             BEQ.N    ??Mci__PwmHandler_24
   \                     ??Mci__PwmHandler_22: (+1)
   \   00000336   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   0000033A   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   0000033E   0x.... 0x....      BL       SRData__CheckShort
   \   00000342   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   00000346   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000034A   0x2800             CMP      R0,#+0
   \   0000034C   0xD06A             BEQ.N    ??Mci__PwmHandler_24
   \   0000034E   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40038008
   \   00000352   0x6D81             LDR      R1,[R0, #+88]
   \   00000354   0xF041 0x013F      ORR      R1,R1,#0x3F
   \   00000358   0x6581             STR      R1,[R0, #+88]
   \   0000035A   0x6EC1             LDR      R1,[R0, #+108]
   \   0000035C   0x060A             LSLS     R2,R1,#+24
   \   0000035E   0x0FD2             LSRS     R2,R2,#+31
   \   00000360   0xD060             BEQ.N    ??Mci__PwmHandler_24
   \   00000362   0xF021 0x018F      BIC      R1,R1,#0x8F
   \   00000366   0x66C1             STR      R1,[R0, #+108]
   \   00000368   0xE05C             B.N      ??Mci__PwmHandler_24
   \                     ??Mci__PwmHandler_23: (+1)
   \   0000036A   0xED9F 0x0A7B      VLDR.W   S0,??Mci__PwmHandler_18  ;; 0x47000000
   \   0000036E   0xEDD4 0x0A5F      VLDR     S1,[R4, #+380]
   \   00000372   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000376   0xEEFD 0x0AE0      VCVT.S32.F32 S1,S1
   \   0000037A   0xEE10 0x7A90      VMOV     R7,S1
   \   0000037E   0xEDD4 0x0A5E      VLDR     S1,[R4, #+376]
   \   00000382   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000386   0xEEFD 0x0AE0      VCVT.S32.F32 S1,S1
   \   0000038A   0xEE10 0x6A90      VMOV     R6,S1
   \   0000038E   0xEDD4 0x0A5D      VLDR     S1,[R4, #+372]
   \   00000392   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   00000396   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000039A   0xEE10 0x5A10      VMOV     R5,S0
   \   0000039E   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   000003A2   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   000003A6   0x.... 0x....      BL       SRData__CheckShort
   \   000003AA   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   000003AE   0x0780             LSLS     R0,R0,#+30
   \   000003B0   0xD538             BPL.N    ??Mci__PwmHandler_24
   \   000003B2   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40038008
   \   000003B6   0x6801             LDR      R1,[R0, #+0]
   \   000003B8   0x1C49             ADDS     R1,R1,#+1
   \   000003BA   0xFB07 0xF201      MUL      R2,R7,R1
   \   000003BE   0xFB06 0xF301      MUL      R3,R6,R1
   \   000003C2   0x4369             MULS     R1,R1,R5
   \   000003C4   0x0049             LSLS     R1,R1,#+1
   \   000003C6   0x1409             ASRS     R1,R1,#+16
   \   000003C8   0x6301             STR      R1,[R0, #+48]
   \   000003CA   0x005B             LSLS     R3,R3,#+1
   \   000003CC   0x4249             RSBS     R1,R1,#+0
   \   000003CE   0x6281             STR      R1,[R0, #+40]
   \   000003D0   0x141B             ASRS     R3,R3,#+16
   \   000003D2   0x4259             RSBS     R1,R3,#+0
   \   000003D4   0x0052             LSLS     R2,R2,#+1
   \   000003D6   0x6181             STR      R1,[R0, #+24]
   \   000003D8   0x1412             ASRS     R2,R2,#+16
   \   000003DA   0x4251             RSBS     R1,R2,#+0
   \   000003DC   0x6081             STR      R1,[R0, #+8]
   \   000003DE   0x6203             STR      R3,[R0, #+32]
   \   000003E0   0xF44F 0x7100      MOV      R1,#+512
   \   000003E4   0x6102             STR      R2,[R0, #+16]
   \   000003E6   0xF8C0 0x1090      STR      R1,[R0, #+144]
   \   000003EA   0xE01B             B.N      ??Mci__PwmHandler_24
   \                     ??Mci__PwmHandler_21: (+1)
   \   000003EC   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   000003F0   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   000003F4   0x.... 0x....      BL       SRData__CheckShort
   \   000003F8   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   000003FC   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000400   0xB180             CBZ.N    R0,??Mci__PwmHandler_24
   \   00000402   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40038008
   \   00000406   0x2100             MOVS     R1,#+0
   \   00000408   0x6301             STR      R1,[R0, #+48]
   \   0000040A   0x6281             STR      R1,[R0, #+40]
   \   0000040C   0x6201             STR      R1,[R0, #+32]
   \   0000040E   0x6181             STR      R1,[R0, #+24]
   \   00000410   0x6101             STR      R1,[R0, #+16]
   \   00000412   0x6081             STR      R1,[R0, #+8]
   \   00000414   0xF44F 0x7100      MOV      R1,#+512
   \   00000418   0xF8C0 0x1090      STR      R1,[R0, #+144]
   \   0000041C   0x6D81             LDR      R1,[R0, #+88]
   \   0000041E   0x0989             LSRS     R1,R1,#+6
   \   00000420   0x0189             LSLS     R1,R1,#+6
   \   00000422   0x6581             STR      R1,[R0, #+88]
   \                     ??Mci__PwmHandler_24: (+1)
   \   00000424   0xF8D4 0x03E8      LDR      R0,[R4, #+1000]
   \   00000428   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   0000042C   0xB108             CBZ.N    R0,??Mci__PwmHandler_25
   \   0000042E   0x2005             MOVS     R0,#+5
   \   00000430   0xE00C             B.N      ??Mci__PwmHandler_26
   \                     ??Mci__PwmHandler_25: (+1)
   \   00000432   0x.... 0x....      BL       Mcl__GetDigital
   \   00000436   0x2801             CMP      R0,#+1
   \   00000438   0xD10A             BNE.N    ??Mci__PwmHandler_27
   \   0000043A   0x.... 0x....      BL       Mcl__RunningReset
   \   0000043E   0xF8D4 0x00E4      LDR      R0,[R4, #+228]
   \   00000442   0xF040 0x0010      ORR      R0,R0,#0x10
   \   00000446   0xF8C4 0x00E4      STR      R0,[R4, #+228]
   \   0000044A   0x2008             MOVS     R0,#+8
   \                     ??Mci__PwmHandler_26: (+1)
   \   0000044C   0xF884 0x0354      STRB     R0,[R4, #+852]
   \                     ??Mci__PwmHandler_27: (+1)
   \   00000450   0x2000             MOVS     R0,#+0
   \   00000452   0x.... 0x....      BL       Mcl__GetDigital
   \   00000456   0xE699             B.N      ??Mci__PwmHandler_6
   \                     ??Mci__PwmHandler_19: (+1)
   \   00000458   0x2804             CMP      R0,#+4
   \   0000045A   0xF040 0x809F      BNE.W    ??Mci__PwmHandler_28
   \   0000045E   0x.... 0x....      BL       SRMotorSafetyMgr__Prepare2StartMotor
   \   00000462   0xF8D4 0x03E8      LDR      R0,[R4, #+1000]
   \   00000466   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   0000046A   0xB108             CBZ.N    R0,??Mci__PwmHandler_29
   \   0000046C   0x2005             MOVS     R0,#+5
   \   0000046E   0xE68B             B.N      ??Mci__PwmHandler_9
   \                     ??Mci__PwmHandler_29: (+1)
   \   00000470   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000474   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000478   0x.... 0x....      BL       SRData__CheckShort
   \   0000047C   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   00000480   0x0780             LSLS     R0,R0,#+30
   \   00000482   0xF57F 0xAE83      BPL.W    ??Mci__PwmHandler_6
   \   00000486   0xF8D4 0x03E8      LDR      R0,[R4, #+1000]
   \   0000048A   0xF010 0x0FF0      TST      R0,#0xF0
   \   0000048E   0xBF18             IT       NE 
   \   00000490   0x200B             MOVNE    R0,#+11
   \   00000492   0xD17A             BNE.N    ??Mci__PwmHandler_30
   \   00000494   0xF3C0 0x01C0      UBFX     R1,R0,#+3,#+1
   \   00000498   0x2900             CMP      R1,#+0
   \   0000049A   0xD070             BEQ.N    ??Mci__PwmHandler_31
   \   0000049C   0x2000             MOVS     R0,#+0
   \   0000049E   0xF8C4 0x04DC      STR      R0,[R4, #+1244]
   \   000004A2   0x2100             MOVS     R1,#+0
   \   000004A4   0xF8D4 0x02F4      LDR      R0,[R4, #+756]
   \   000004A8   0x6041             STR      R1,[R0, #+4]
   \   000004AA   0xEEB6 0x0A00      VMOV.F32 S0,#0.5
   \   000004AE   0xF8D4 0x02F4      LDR      R0,[R4, #+756]
   \   000004B2   0x6081             STR      R1,[R0, #+8]
   \   000004B4   0xED9F 0x1A29      VLDR.W   S2,??Mci__PwmHandler_18+0x4  ;; 0x3f866666
   \   000004B8   0xF8D4 0x0300      LDR      R0,[R4, #+768]
   \   000004BC   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   000004C0   0xEDDF 0x1A27      VLDR.W   S3,??Mci__PwmHandler_18+0x8  ;; 0x3f733333
   \   000004C4   0xF8D4 0x0300      LDR      R0,[R4, #+768]
   \   000004C8   0xED80 0x0A01      VSTR     S0,[R0, #+4]
   \   000004CC   0xF8D4 0x0300      LDR      R0,[R4, #+768]
   \   000004D0   0xED80 0x0A02      VSTR     S0,[R0, #+8]
   \   000004D4   0xED9F 0x0A23      VLDR.W   S0,??Mci__PwmHandler_18+0xC  ;; 0x3dd67750
   \   000004D8   0xF8D4 0x0338      LDR      R0,[R4, #+824]
   \   000004DC   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   000004E0   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   000004E4   0xF204 0x406C      ADDW     R0,R4,#+1132
   \   000004E8   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   000004EC   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
   \   000004F0   0xF8D4 0x0338      LDR      R0,[R4, #+824]
   \   000004F4   0xED90 0x1A00      VLDR     S2,[R0, #0]
   \   000004F8   0xEE21 0x1A21      VMUL.F32 S2,S2,S3
   \   000004FC   0xF204 0x4070      ADDW     R0,R4,#+1136
   \   00000500   0xEE21 0x0A00      VMUL.F32 S0,S2,S0
   \   00000504   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   00000508   0xF204 0x4074      ADDW     R0,R4,#+1140
   \   0000050C   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
   \   00000510   0xF894 0x038C      LDRB     R0,[R4, #+908]
   \   00000514   0x07C0             LSLS     R0,R0,#+31
   \   00000516   0xD527             BPL.N    ??Mci__PwmHandler_32
   \   00000518   0xF8C4 0x14B8      STR      R1,[R4, #+1208]
   \   0000051C   0x2101             MOVS     R1,#+1
   \   0000051E   0xF8D4 0x03F4      LDR      R0,[R4, #+1012]
   \   00000522   0xF884 0x1367      STRB     R1,[R4, #+871]
   \   00000526   0x30E4             ADDS     R0,R0,#+228
   \   00000528   0x6901             LDR      R1,[R0, #+16]
   \   0000052A   0xF8A4 0x1392      STRH     R1,[R4, #+914]
   \   0000052E   0x6801             LDR      R1,[R0, #+0]
   \   00000530   0xF8A4 0x1394      STRH     R1,[R4, #+916]
   \   00000534   0xF894 0x1366      LDRB     R1,[R4, #+870]
   \   00000538   0x2901             CMP      R1,#+1
   \   0000053A   0xD10A             BNE.N    ??Mci__PwmHandler_33
   \   0000053C   0x2102             MOVS     R1,#+2
   \   0000053E   0xF884 0x1366      STRB     R1,[R4, #+870]
   \   00000542   0xF894 0x1368      LDRB     R1,[R4, #+872]
   \   00000546   0x1C49             ADDS     R1,R1,#+1
   \   00000548   0xF884 0x1368      STRB     R1,[R4, #+872]
   \   0000054C   0x6C40             LDR      R0,[R0, #+68]
   \   0000054E   0xF8A4 0x0390      STRH     R0,[R4, #+912]
   \                     ??Mci__PwmHandler_33: (+1)
   \   00000552   0x2001             MOVS     R0,#+1
   \   00000554   0xE009             B.N      ??Mci__PwmHandler_34
   \   00000556   0xBF00             Nop      
   \                     ??Mci__PwmHandler_18:
   \   00000558   0x47000000         DC32     0x47000000
   \   0000055C   0x3F866666         DC32     0x3f866666
   \   00000560   0x3F733333         DC32     0x3f733333
   \   00000564   0x3DD67750         DC32     0x3dd67750
   \                     ??Mci__PwmHandler_32: (+1)
   \   00000568   0x2003             MOVS     R0,#+3
   \                     ??Mci__PwmHandler_34: (+1)
   \   0000056A   0xF884 0x0357      STRB     R0,[R4, #+855]
   \   0000056E   0xF894 0x0358      LDRB     R0,[R4, #+856]
   \   00000572   0xF000 0x00F7      AND      R0,R0,#0xF7
   \   00000576   0xF884 0x0358      STRB     R0,[R4, #+856]
   \   0000057A   0x2007             MOVS     R0,#+7
   \   0000057C   0xE005             B.N      ??Mci__PwmHandler_30
   \                     ??Mci__PwmHandler_31: (+1)
   \   0000057E   0xF3C0 0x2000      UBFX     R0,R0,#+8,#+1
   \   00000582   0xB120             CBZ.N    R0,??Mci__PwmHandler_35
   \   00000584   0x.... 0x....      BL       MclFvt__Entry
   \   00000588   0x2001             MOVS     R0,#+1
   \                     ??Mci__PwmHandler_30: (+1)
   \   0000058A   0xF884 0x0354      STRB     R0,[R4, #+852]
   \                     ??Mci__PwmHandler_35: (+1)
   \   0000058E   0xF8D4 0x03E8      LDR      R0,[R4, #+1000]
   \   00000592   0xF020 0x0008      BIC      R0,R0,#0x8
   \   00000596   0xF8C4 0x03E8      STR      R0,[R4, #+1000]
   \   0000059A   0xE5F7             B.N      ??Mci__PwmHandler_6
   \                     ??Mci__PwmHandler_28: (+1)
   \   0000059C   0x2809             CMP      R0,#+9
   \   0000059E   0xD124             BNE.N    ??Mci__PwmHandler_36
   \   000005A0   0x07E8             LSLS     R0,R5,#+31
   \   000005A2   0xD508             BPL.N    ??Mci__PwmHandler_37
   \   000005A4   0x.... 0x....      BL       Mcl__StoppingHandler
   \   000005A8   0x2002             MOVS     R0,#+2
   \   000005AA   0x.... 0x....      BL       Mcl__GetDigital
   \   000005AE   0xB110             CBZ.N    R0,??Mci__PwmHandler_37
   \   000005B0   0x2005             MOVS     R0,#+5
   \   000005B2   0xF884 0x0354      STRB     R0,[R4, #+852]
   \                     ??Mci__PwmHandler_37: (+1)
   \   000005B6   0xF8D4 0x03E8      LDR      R0,[R4, #+1000]
   \   000005BA   0x07C1             LSLS     R1,R0,#+31
   \   000005BC   0xF53F 0xAE7B      BMI.W    ??Mci__PwmHandler_14
   \   000005C0   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   000005C4   0x2800             CMP      R0,#+0
   \   000005C6   0xF47F 0xAE0F      BNE.W    ??Mci__PwmHandler_16
   \   000005CA   0xF894 0x018D      LDRB     R0,[R4, #+397]
   \   000005CE   0xF894 0x118C      LDRB     R1,[R4, #+396]
   \   000005D2   0xFA50 0xF281      UXTAB    R2,R0,R1
   \   000005D6   0x2A00             CMP      R2,#+0
   \   000005D8   0xF43F 0xAE2C      BEQ.W    ??Mci__PwmHandler_17
   \   000005DC   0x2900             CMP      R1,#+0
   \   000005DE   0xF47F 0xAE6A      BNE.W    ??Mci__PwmHandler_14
   \   000005E2   0x2800             CMP      R0,#+0
   \   000005E4   0xF43F 0xADD2      BEQ.W    ??Mci__PwmHandler_6
   \   000005E8   0xE5FE             B.N      ??Mci__PwmHandler_16
   \                     ??Mci__PwmHandler_36: (+1)
   \   000005EA   0x2805             CMP      R0,#+5
   \   000005EC   0xD124             BNE.N    ??Mci__PwmHandler_5
   \   000005EE   0x.... 0x....      BL       SRMotorSafetyMgr__Prepare2StopMotor
   \   000005F2   0xF204 0x3173      ADDW     R1,R4,#+883
   \   000005F6   0xF204 0x3072      ADDW     R0,R4,#+882
   \   000005FA   0x.... 0x....      BL       SRData__CheckByte
   \   000005FE   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000602   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000606   0x.... 0x....      BL       SRData__CheckByte
   \   0000060A   0xF894 0x0372      LDRB     R0,[R4, #+882]
   \   0000060E   0xF8B4 0x13A6      LDRH     R1,[R4, #+934]
   \   00000612   0x2802             CMP      R0,#+2
   \   00000614   0xF47F 0xADBA      BNE.W    ??Mci__PwmHandler_6
   \   00000618   0x0748             LSLS     R0,R1,#+29
   \   0000061A   0xF53F 0xADB7      BMI.W    ??Mci__PwmHandler_6
   \   0000061E   0x2000             MOVS     R0,#+0
   \   00000620   0xF8C4 0x04D8      STR      R0,[R4, #+1240]
   \   00000624   0xF8C4 0x04DC      STR      R0,[R4, #+1244]
   \   00000628   0x.... 0x....      LDR.W    R0,??DataTable11_2  ;; 0x3a80adfd
   \   0000062C   0xF8C4 0x04D0      STR      R0,[R4, #+1232]
   \   00000630   0x2000             MOVS     R0,#+0
   \   00000632   0xF884 0x036B      STRB     R0,[R4, #+875]
   \   00000636   0xE5A4             B.N      ??Mci__PwmHandler_8
   \                     ??Mci__PwmHandler_5: (+1)
   \   00000638   0x2802             CMP      R0,#+2
   \   0000063A   0xD11C             BNE.N    ??Mci__PwmHandler_38
   \   0000063C   0x2900             CMP      R1,#+0
   \   0000063E   0xF47F 0xADA5      BNE.W    ??Mci__PwmHandler_6
   \   00000642   0xF204 0x3173      ADDW     R1,R4,#+883
   \   00000646   0xF204 0x3072      ADDW     R0,R4,#+882
   \   0000064A   0x.... 0x....      BL       SRData__CheckByte
   \   0000064E   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000652   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000656   0x.... 0x....      BL       SRData__CheckByte
   \   0000065A   0xF894 0x0372      LDRB     R0,[R4, #+882]
   \   0000065E   0xF8B4 0x13A6      LDRH     R1,[R4, #+934]
   \   00000662   0x2802             CMP      R0,#+2
   \   00000664   0xF47F 0xAD92      BNE.W    ??Mci__PwmHandler_6
   \   00000668   0x0748             LSLS     R0,R1,#+29
   \   0000066A   0xF53F 0xAD8F      BMI.W    ??Mci__PwmHandler_6
   \   0000066E   0x2000             MOVS     R0,#+0
   \   00000670   0xF8C4 0x03E4      STR      R0,[R4, #+996]
   \   00000674   0xE585             B.N      ??Mci__PwmHandler_8
   \                     ??Mci__PwmHandler_38: (+1)
   \   00000676   0x2803             CMP      R0,#+3
   \   00000678   0xF040 0x8096      BNE.W    ??Mci__PwmHandler_39
   \   0000067C   0x2000             MOVS     R0,#+0
   \   0000067E   0xF8C4 0x0154      STR      R0,[R4, #+340]
   \   00000682   0xF8D4 0x03E8      LDR      R0,[R4, #+1000]
   \   00000686   0xF894 0x118C      LDRB     R1,[R4, #+396]
   \   0000068A   0x08C0             LSRS     R0,R0,#+3
   \   0000068C   0x00C0             LSLS     R0,R0,#+3
   \   0000068E   0xF8C4 0x03E8      STR      R0,[R4, #+1000]
   \   00000692   0xF894 0x018D      LDRB     R0,[R4, #+397]
   \   00000696   0xFA50 0xF281      UXTAB    R2,R0,R1
   \   0000069A   0xB1EA             CBZ.N    R2,??Mci__PwmHandler_40
   \   0000069C   0x2900             CMP      R1,#+0
   \   0000069E   0xD15C             BNE.N    ??Mci__PwmHandler_41
   \   000006A0   0x2800             CMP      R0,#+0
   \   000006A2   0xD076             BEQ.N    ??Mci__PwmHandler_42
   \   000006A4   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   000006A8   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   000006AC   0x.... 0x....      BL       SRData__CheckShort
   \   000006B0   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   000006B4   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   000006B8   0x2800             CMP      R0,#+0
   \   000006BA   0xD06A             BEQ.N    ??Mci__PwmHandler_42
   \   000006BC   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40038008
   \   000006C0   0x6D81             LDR      R1,[R0, #+88]
   \   000006C2   0xF041 0x013F      ORR      R1,R1,#0x3F
   \   000006C6   0x6581             STR      R1,[R0, #+88]
   \   000006C8   0x6EC1             LDR      R1,[R0, #+108]
   \   000006CA   0x060A             LSLS     R2,R1,#+24
   \   000006CC   0x0FD2             LSRS     R2,R2,#+31
   \   000006CE   0xD060             BEQ.N    ??Mci__PwmHandler_42
   \   000006D0   0xF021 0x018F      BIC      R1,R1,#0x8F
   \   000006D4   0x66C1             STR      R1,[R0, #+108]
   \   000006D6   0xE05C             B.N      ??Mci__PwmHandler_42
   \                     ??Mci__PwmHandler_40: (+1)
   \   000006D8   0xED9F 0x....      VLDR.W   S0,??DataTable11  ;; 0x47000000
   \   000006DC   0xEDD4 0x0A5F      VLDR     S1,[R4, #+380]
   \   000006E0   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   000006E4   0xEEFD 0x0AE0      VCVT.S32.F32 S1,S1
   \   000006E8   0xEE10 0x7A90      VMOV     R7,S1
   \   000006EC   0xEDD4 0x0A5E      VLDR     S1,[R4, #+376]
   \   000006F0   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   000006F4   0xEEFD 0x0AE0      VCVT.S32.F32 S1,S1
   \   000006F8   0xEE10 0x6A90      VMOV     R6,S1
   \   000006FC   0xEDD4 0x0A5D      VLDR     S1,[R4, #+372]
   \   00000700   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   00000704   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000708   0xEE10 0x5A10      VMOV     R5,S0
   \   0000070C   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000710   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000714   0x.... 0x....      BL       SRData__CheckShort
   \   00000718   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   0000071C   0x0780             LSLS     R0,R0,#+30
   \   0000071E   0xD538             BPL.N    ??Mci__PwmHandler_42
   \   00000720   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40038008
   \   00000724   0x6801             LDR      R1,[R0, #+0]
   \   00000726   0x1C49             ADDS     R1,R1,#+1
   \   00000728   0xFB07 0xF201      MUL      R2,R7,R1
   \   0000072C   0xFB06 0xF301      MUL      R3,R6,R1
   \   00000730   0x4369             MULS     R1,R1,R5
   \   00000732   0x0049             LSLS     R1,R1,#+1
   \   00000734   0x1409             ASRS     R1,R1,#+16
   \   00000736   0x6301             STR      R1,[R0, #+48]
   \   00000738   0x005B             LSLS     R3,R3,#+1
   \   0000073A   0x4249             RSBS     R1,R1,#+0
   \   0000073C   0x6281             STR      R1,[R0, #+40]
   \   0000073E   0x141B             ASRS     R3,R3,#+16
   \   00000740   0x4259             RSBS     R1,R3,#+0
   \   00000742   0x0052             LSLS     R2,R2,#+1
   \   00000744   0x6181             STR      R1,[R0, #+24]
   \   00000746   0x1412             ASRS     R2,R2,#+16
   \   00000748   0x4251             RSBS     R1,R2,#+0
   \   0000074A   0x6081             STR      R1,[R0, #+8]
   \   0000074C   0x6203             STR      R3,[R0, #+32]
   \   0000074E   0xF44F 0x7100      MOV      R1,#+512
   \   00000752   0x6102             STR      R2,[R0, #+16]
   \   00000754   0xF8C0 0x1090      STR      R1,[R0, #+144]
   \   00000758   0xE01B             B.N      ??Mci__PwmHandler_42
   \                     ??Mci__PwmHandler_41: (+1)
   \   0000075A   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   0000075E   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000762   0x.... 0x....      BL       SRData__CheckShort
   \   00000766   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   0000076A   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000076E   0xB180             CBZ.N    R0,??Mci__PwmHandler_42
   \   00000770   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40038008
   \   00000774   0x2100             MOVS     R1,#+0
   \   00000776   0x6301             STR      R1,[R0, #+48]
   \   00000778   0x6281             STR      R1,[R0, #+40]
   \   0000077A   0x6201             STR      R1,[R0, #+32]
   \   0000077C   0x6181             STR      R1,[R0, #+24]
   \   0000077E   0x6101             STR      R1,[R0, #+16]
   \   00000780   0x6081             STR      R1,[R0, #+8]
   \   00000782   0xF44F 0x7100      MOV      R1,#+512
   \   00000786   0xF8C0 0x1090      STR      R1,[R0, #+144]
   \   0000078A   0x6D81             LDR      R1,[R0, #+88]
   \   0000078C   0x0989             LSRS     R1,R1,#+6
   \   0000078E   0x0189             LSLS     R1,R1,#+6
   \   00000790   0x6581             STR      R1,[R0, #+88]
   \                     ??Mci__PwmHandler_42: (+1)
   \   00000792   0xF8D4 0x03E8      LDR      R0,[R4, #+1000]
   \   00000796   0xF410 0x7FFC      TST      R0,#0x1F8
   \   0000079A   0xF43F 0xACF7      BEQ.W    ??Mci__PwmHandler_6
   \   0000079E   0x2000             MOVS     R0,#+0
   \   000007A0   0xF8A4 0x037A      STRH     R0,[R4, #+890]
   \   000007A4   0x2004             MOVS     R0,#+4
   \   000007A6   0xE4EF             B.N      ??Mci__PwmHandler_9
   \                     ??Mci__PwmHandler_39: (+1)
   \   000007A8   0x280A             CMP      R0,#+10
   \   000007AA   0xF43F 0xACEF      BEQ.W    ??Mci__PwmHandler_6
   \   000007AE   0x280B             CMP      R0,#+11
   \   000007B0   0xF040 0x8096      BNE.W    ??Mci__PwmHandler_43
   \   000007B4   0xF8D4 0x03E8      LDR      R0,[R4, #+1000]
   \   000007B8   0x07C1             LSLS     R1,R0,#+31
   \   000007BA   0xD468             BMI.N    ??Mci__PwmHandler_44
   \   000007BC   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   000007C0   0xB950             CBNZ.N   R0,??Mci__PwmHandler_45
   \   000007C2   0xF894 0x018D      LDRB     R0,[R4, #+397]
   \   000007C6   0xF894 0x118C      LDRB     R1,[R4, #+396]
   \   000007CA   0xFA50 0xF281      UXTAB    R2,R0,R1
   \   000007CE   0xB1EA             CBZ.N    R2,??Mci__PwmHandler_46
   \   000007D0   0x2900             CMP      R1,#+0
   \   000007D2   0xD15C             BNE.N    ??Mci__PwmHandler_44
   \   000007D4   0x2800             CMP      R0,#+0
   \   000007D6   0xD076             BEQ.N    ??Mci__PwmHandler_47
   \                     ??Mci__PwmHandler_45: (+1)
   \   000007D8   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   000007DC   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   000007E0   0x.... 0x....      BL       SRData__CheckShort
   \   000007E4   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   000007E8   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   000007EC   0x2800             CMP      R0,#+0
   \   000007EE   0xD06A             BEQ.N    ??Mci__PwmHandler_47
   \   000007F0   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40038008
   \   000007F4   0x6D81             LDR      R1,[R0, #+88]
   \   000007F6   0xF041 0x013F      ORR      R1,R1,#0x3F
   \   000007FA   0x6581             STR      R1,[R0, #+88]
   \   000007FC   0x6EC1             LDR      R1,[R0, #+108]
   \   000007FE   0x060A             LSLS     R2,R1,#+24
   \   00000800   0x0FD2             LSRS     R2,R2,#+31
   \   00000802   0xD060             BEQ.N    ??Mci__PwmHandler_47
   \   00000804   0xF021 0x018F      BIC      R1,R1,#0x8F
   \   00000808   0x66C1             STR      R1,[R0, #+108]
   \   0000080A   0xE05C             B.N      ??Mci__PwmHandler_47
   \                     ??Mci__PwmHandler_46: (+1)
   \   0000080C   0xED9F 0x....      VLDR.W   S0,??DataTable11  ;; 0x47000000
   \   00000810   0xEDD4 0x0A5F      VLDR     S1,[R4, #+380]
   \   00000814   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000818   0xEEFD 0x0AE0      VCVT.S32.F32 S1,S1
   \   0000081C   0xEE10 0x7A90      VMOV     R7,S1
   \   00000820   0xEDD4 0x0A5E      VLDR     S1,[R4, #+376]
   \   00000824   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000828   0xEEFD 0x0AE0      VCVT.S32.F32 S1,S1
   \   0000082C   0xEE10 0x6A90      VMOV     R6,S1
   \   00000830   0xEDD4 0x0A5D      VLDR     S1,[R4, #+372]
   \   00000834   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   00000838   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000083C   0xEE10 0x5A10      VMOV     R5,S0
   \   00000840   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000844   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000848   0x.... 0x....      BL       SRData__CheckShort
   \   0000084C   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   00000850   0x0780             LSLS     R0,R0,#+30
   \   00000852   0xD538             BPL.N    ??Mci__PwmHandler_47
   \   00000854   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40038008
   \   00000858   0x6801             LDR      R1,[R0, #+0]
   \   0000085A   0x1C49             ADDS     R1,R1,#+1
   \   0000085C   0xFB07 0xF201      MUL      R2,R7,R1
   \   00000860   0xFB06 0xF301      MUL      R3,R6,R1
   \   00000864   0x4369             MULS     R1,R1,R5
   \   00000866   0x0049             LSLS     R1,R1,#+1
   \   00000868   0x1409             ASRS     R1,R1,#+16
   \   0000086A   0x6301             STR      R1,[R0, #+48]
   \   0000086C   0x005B             LSLS     R3,R3,#+1
   \   0000086E   0x4249             RSBS     R1,R1,#+0
   \   00000870   0x6281             STR      R1,[R0, #+40]
   \   00000872   0x141B             ASRS     R3,R3,#+16
   \   00000874   0x4259             RSBS     R1,R3,#+0
   \   00000876   0x0052             LSLS     R2,R2,#+1
   \   00000878   0x6181             STR      R1,[R0, #+24]
   \   0000087A   0x1412             ASRS     R2,R2,#+16
   \   0000087C   0x4251             RSBS     R1,R2,#+0
   \   0000087E   0x6081             STR      R1,[R0, #+8]
   \   00000880   0x6203             STR      R3,[R0, #+32]
   \   00000882   0xF44F 0x7100      MOV      R1,#+512
   \   00000886   0x6102             STR      R2,[R0, #+16]
   \   00000888   0xF8C0 0x1090      STR      R1,[R0, #+144]
   \   0000088C   0xE01B             B.N      ??Mci__PwmHandler_47
   \                     ??Mci__PwmHandler_44: (+1)
   \   0000088E   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000892   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000896   0x.... 0x....      BL       SRData__CheckShort
   \   0000089A   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   0000089E   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   000008A2   0xB180             CBZ.N    R0,??Mci__PwmHandler_47
   \   000008A4   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40038008
   \   000008A8   0x2100             MOVS     R1,#+0
   \   000008AA   0x6301             STR      R1,[R0, #+48]
   \   000008AC   0x6281             STR      R1,[R0, #+40]
   \   000008AE   0x6201             STR      R1,[R0, #+32]
   \   000008B0   0x6181             STR      R1,[R0, #+24]
   \   000008B2   0x6101             STR      R1,[R0, #+16]
   \   000008B4   0x6081             STR      R1,[R0, #+8]
   \   000008B6   0xF44F 0x7100      MOV      R1,#+512
   \   000008BA   0xF8C0 0x1090      STR      R1,[R0, #+144]
   \   000008BE   0x6D81             LDR      R1,[R0, #+88]
   \   000008C0   0x0989             LSRS     R1,R1,#+6
   \   000008C2   0x0189             LSLS     R1,R1,#+6
   \   000008C4   0x6581             STR      R1,[R0, #+88]
   \                     ??Mci__PwmHandler_47: (+1)
   \   000008C6   0xF8D4 0x03E8      LDR      R0,[R4, #+1000]
   \   000008CA   0xF3C0 0x0180      UBFX     R1,R0,#+2,#+1
   \   000008CE   0x2900             CMP      R1,#+0
   \   000008D0   0xF43F 0xAC5C      BEQ.W    ??Mci__PwmHandler_6
   \   000008D4   0xF020 0x00F0      BIC      R0,R0,#0xF0
   \   000008D8   0xF8C4 0x03E8      STR      R0,[R4, #+1000]
   \   000008DC   0x2005             MOVS     R0,#+5
   \   000008DE   0xE453             B.N      ??Mci__PwmHandler_9
   \                     ??Mci__PwmHandler_43: (+1)
   \   000008E0   0x2801             CMP      R0,#+1
   \   000008E2   0xF47F 0xAC21      BNE.W    ??Mci__PwmHandler_7
   \   000008E6   0x07E8             LSLS     R0,R5,#+31
   \   000008E8   0xBF48             IT       MI 
   \   000008EA   0x.... 0x....      BLMI     MclFvt__PwmHandler
   \   000008EE   0xF8D4 0x03E8      LDR      R0,[R4, #+1000]
   \   000008F2   0x07C1             LSLS     R1,R0,#+31
   \   000008F4   0xD468             BMI.N    ??Mci__PwmHandler_48
   \   000008F6   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   000008FA   0xB950             CBNZ.N   R0,??Mci__PwmHandler_49
   \   000008FC   0xF894 0x018D      LDRB     R0,[R4, #+397]
   \   00000900   0xF894 0x118C      LDRB     R1,[R4, #+396]
   \   00000904   0xFA50 0xF281      UXTAB    R2,R0,R1
   \   00000908   0xB1EA             CBZ.N    R2,??Mci__PwmHandler_50
   \   0000090A   0x2900             CMP      R1,#+0
   \   0000090C   0xD15C             BNE.N    ??Mci__PwmHandler_48
   \   0000090E   0x2800             CMP      R0,#+0
   \   00000910   0xD076             BEQ.N    ??Mci__PwmHandler_51
   \                     ??Mci__PwmHandler_49: (+1)
   \   00000912   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000916   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   0000091A   0x.... 0x....      BL       SRData__CheckShort
   \   0000091E   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   00000922   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000926   0x2800             CMP      R0,#+0
   \   00000928   0xD06A             BEQ.N    ??Mci__PwmHandler_51
   \   0000092A   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40038008
   \   0000092E   0x6D81             LDR      R1,[R0, #+88]
   \   00000930   0xF041 0x013F      ORR      R1,R1,#0x3F
   \   00000934   0x6581             STR      R1,[R0, #+88]
   \   00000936   0x6EC1             LDR      R1,[R0, #+108]
   \   00000938   0x060A             LSLS     R2,R1,#+24
   \   0000093A   0x0FD2             LSRS     R2,R2,#+31
   \   0000093C   0xD060             BEQ.N    ??Mci__PwmHandler_51
   \   0000093E   0xF021 0x018F      BIC      R1,R1,#0x8F
   \   00000942   0x66C1             STR      R1,[R0, #+108]
   \   00000944   0xE05C             B.N      ??Mci__PwmHandler_51
   \                     ??Mci__PwmHandler_50: (+1)
   \   00000946   0xED9F 0x....      VLDR.W   S0,??DataTable11  ;; 0x47000000
   \   0000094A   0xEDD4 0x0A5F      VLDR     S1,[R4, #+380]
   \   0000094E   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000952   0xEEFD 0x0AE0      VCVT.S32.F32 S1,S1
   \   00000956   0xEE10 0x7A90      VMOV     R7,S1
   \   0000095A   0xEDD4 0x0A5E      VLDR     S1,[R4, #+376]
   \   0000095E   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000962   0xEEFD 0x0AE0      VCVT.S32.F32 S1,S1
   \   00000966   0xEE10 0x6A90      VMOV     R6,S1
   \   0000096A   0xEDD4 0x0A5D      VLDR     S1,[R4, #+372]
   \   0000096E   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   00000972   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000976   0xEE10 0x5A10      VMOV     R5,S0
   \   0000097A   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   0000097E   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000982   0x.... 0x....      BL       SRData__CheckShort
   \   00000986   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   0000098A   0x0780             LSLS     R0,R0,#+30
   \   0000098C   0xD538             BPL.N    ??Mci__PwmHandler_51
   \   0000098E   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40038008
   \   00000992   0x6801             LDR      R1,[R0, #+0]
   \   00000994   0x1C49             ADDS     R1,R1,#+1
   \   00000996   0xFB07 0xF201      MUL      R2,R7,R1
   \   0000099A   0xFB06 0xF301      MUL      R3,R6,R1
   \   0000099E   0x4369             MULS     R1,R1,R5
   \   000009A0   0x0049             LSLS     R1,R1,#+1
   \   000009A2   0x1409             ASRS     R1,R1,#+16
   \   000009A4   0x6301             STR      R1,[R0, #+48]
   \   000009A6   0x005B             LSLS     R3,R3,#+1
   \   000009A8   0x4249             RSBS     R1,R1,#+0
   \   000009AA   0x6281             STR      R1,[R0, #+40]
   \   000009AC   0x141B             ASRS     R3,R3,#+16
   \   000009AE   0x4259             RSBS     R1,R3,#+0
   \   000009B0   0x0052             LSLS     R2,R2,#+1
   \   000009B2   0x6181             STR      R1,[R0, #+24]
   \   000009B4   0x1412             ASRS     R2,R2,#+16
   \   000009B6   0x4251             RSBS     R1,R2,#+0
   \   000009B8   0x6081             STR      R1,[R0, #+8]
   \   000009BA   0x6203             STR      R3,[R0, #+32]
   \   000009BC   0xF44F 0x7100      MOV      R1,#+512
   \   000009C0   0x6102             STR      R2,[R0, #+16]
   \   000009C2   0xF8C0 0x1090      STR      R1,[R0, #+144]
   \   000009C6   0xE01B             B.N      ??Mci__PwmHandler_51
   \                     ??Mci__PwmHandler_48: (+1)
   \   000009C8   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   000009CC   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   000009D0   0x.... 0x....      BL       SRData__CheckShort
   \   000009D4   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   000009D8   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   000009DC   0xB180             CBZ.N    R0,??Mci__PwmHandler_51
   \   000009DE   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40038008
   \   000009E2   0x2100             MOVS     R1,#+0
   \   000009E4   0x6301             STR      R1,[R0, #+48]
   \   000009E6   0x6281             STR      R1,[R0, #+40]
   \   000009E8   0x6201             STR      R1,[R0, #+32]
   \   000009EA   0x6181             STR      R1,[R0, #+24]
   \   000009EC   0x6101             STR      R1,[R0, #+16]
   \   000009EE   0x6081             STR      R1,[R0, #+8]
   \   000009F0   0xF44F 0x7100      MOV      R1,#+512
   \   000009F4   0xF8C0 0x1090      STR      R1,[R0, #+144]
   \   000009F8   0x6D81             LDR      R1,[R0, #+88]
   \   000009FA   0x0989             LSRS     R1,R1,#+6
   \   000009FC   0x0189             LSLS     R1,R1,#+6
   \   000009FE   0x6581             STR      R1,[R0, #+88]
   \                     ??Mci__PwmHandler_51: (+1)
   \   00000A00   0xF894 0x0363      LDRB     R0,[R4, #+867]
   \   00000A04   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000A08   0xF080 0x0001      EOR      R0,R0,#0x1
   \   00000A0C   0x2801             CMP      R0,#+1
   \   00000A0E   0xD006             BEQ.N    ??Mci__PwmHandler_52
   \   00000A10   0xF8D4 0x03E8      LDR      R0,[R4, #+1000]
   \   00000A14   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   00000A18   0x2800             CMP      R0,#+0
   \   00000A1A   0xF43F 0xABB7      BEQ.W    ??Mci__PwmHandler_6
   \                     ??Mci__PwmHandler_52: (+1)
   \   00000A1E   0xF8D4 0x03E0      LDR      R0,[R4, #+992]
   \   00000A22   0x2800             CMP      R0,#+0
   \   00000A24   0xF47F 0xABB2      BNE.W    ??Mci__PwmHandler_6
   \   00000A28   0xF8C4 0x03E4      STR      R0,[R4, #+996]
   \   00000A2C   0xF8D4 0x03E8      LDR      R0,[R4, #+1000]
   \   00000A30   0xF420 0x7080      BIC      R0,R0,#0x100
   \   00000A34   0xF8C4 0x03E8      STR      R0,[R4, #+1000]
   \   00000A38   0xF104 0x0088      ADD      R0,R4,#+136
   \   00000A3C   0xF8C4 0x01E0      STR      R0,[R4, #+480]
   \   00000A40   0x2005             MOVS     R0,#+5
   \   00000A42   0xF7FF 0xBBA1      B.W      ??Mci__PwmHandler_9
    993          }
    994          
    995          
    996          
    997          
    998          //---------------------------------------------------------------------------------------------------------------------
    999          /**
   1000           *  @brief      Handle Mci events every Hall interrupt.
   1001           *
   1002           *  @param
   1003           *  @return
   1004           */

   \                                 In section .text, align 2, keep-with-next
   1005          void Mci__HallHandler(void)
   1006          {
   1007              MCI_HALLS_CALLBACK();
   1008          }
   \                     Mci__HallHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1009          
   1010          
   1011          
   1012          
   1013          //---------------------------------------------------------------------------------------------------------------------
   1014          /**
   1015           *  @brief      Handle Mci events of 250us.
   1016           *
   1017           *  @param
   1018           *  @return
   1019           */

   \                                 In section .text, align 2, keep-with-next
   1020          void Mci__250usHandler(void)
   1021          {
   \                     Mci__250usHandler: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1022              MCI_250US_CALLBACK();
   \   00000004   0x.... 0x....      BL       BoardDebugging__250usHandler
   1023          
   1024              Mcl__250usHandler();
   \   00000008   0xB001             ADD      SP,SP,#+4
   \   0000000A   0xF85D 0xEB04      POP      {LR}
   \   0000000E   0x.... 0x....      B.W      Mcl__250usHandler
   1025          }
   1026          
   1027          
   1028          
   1029          
   1030          //---------------------------------------------------------------------------------------------------------------------
   1031          /**
   1032           *  @brief      Handle Mci events of 1ms.
   1033           *
   1034           *  @param      none
   1035           *  @return     none
   1036           */

   \                                 In section .text, align 2, keep-with-next
   1037          void Mci__1msHandler(void)
   1038          {
   1039              MCI_1MS_CALLBACK();
   1040          
   1041              Mcl__1msHandler();
   \                     Mci__1msHandler: (+1)
   \   00000000   0x.... 0x....      B.W      Mcl__1msHandler
   1042          }
   1043          
   1044          
   1045          
   1046          
   1047          //---------------------------------------------------------------------------------------------------------------------
   1048          /**
   1049           *  @brief      Handle Mci events of 5ms.
   1050           *
   1051           *  @param
   1052           *  @return
   1053           */

   \                                 In section .text, align 4, keep-with-next
   1054          void Mci__5msHandler(void)
   1055          {
   \                     Mci__5msHandler: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   1056              MCI_5MS_CALLBACK();
   1057          
   1058              Check_Errors_5ms_Handler();
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable25
   \   00000006   0xF8D4 0x03E4      LDR      R0,[R4, #+996]
   \   0000000A   0xED94 0x0A51      VLDR     S0,[R4, #+324]
   \   0000000E   0xF8D4 0x13E0      LDR      R1,[R4, #+992]
   \   00000012   0xEDDF 0x0A9A      VLDR.W   S1,??Mci__5msHandler_0  ;; 0x43d70000
   \   00000016   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000001A   0xB081             SUB      SP,SP,#+4
   \   0000001C   0xEEF1 0xFA10      FMSTAT   
   \   00000020   0xDB04             BLT.N    ??Mci__5msHandler_1
   \   00000022   0xF040 0x0005      ORR      R0,R0,#0x5
   \   00000026   0xF041 0x0104      ORR      R1,R1,#0x4
   \   0000002A   0xE008             B.N      ??Mci__5msHandler_2
   \                     ??Mci__5msHandler_1: (+1)
   \   0000002C   0xEDDF 0x0A94      VLDR.W   S1,??Mci__5msHandler_0+0x4  ;; 0x43bb0001
   \   00000030   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000034   0xEEF1 0xFA10      FMSTAT   
   \   00000038   0xBF48             IT       MI 
   \   0000003A   0xF021 0x0104      BICMI    R1,R1,#0x4
   \                     ??Mci__5msHandler_2: (+1)
   \   0000003E   0xEDDF 0x0A91      VLDR.W   S1,??Mci__5msHandler_0+0x8  ;; 0x430c0001
   \   00000042   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000046   0xEEF1 0xFA10      FMSTAT   
   \   0000004A   0xD504             BPL.N    ??Mci__5msHandler_3
   \   0000004C   0xF040 0x0009      ORR      R0,R0,#0x9
   \   00000050   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000054   0xE008             B.N      ??Mci__5msHandler_4
   \                     ??Mci__5msHandler_3: (+1)
   \   00000056   0xEDDF 0x0A8C      VLDR.W   S1,??Mci__5msHandler_0+0xC  ;; 0x42c80000
   \   0000005A   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000005E   0xEEF1 0xFA10      FMSTAT   
   \   00000062   0xBFA8             IT       GE 
   \   00000064   0xF021 0x0108      BICGE    R1,R1,#0x8
   \                     ??Mci__5msHandler_4: (+1)
   \   00000068   0xF894 0x236C      LDRB     R2,[R4, #+876]
   \   0000006C   0x2A02             CMP      R2,#+2
   \   0000006E   0xBF18             IT       NE 
   \   00000070   0x2A04             CMPNE    R2,#+4
   \   00000072   0xBF0F             ITEEE    EQ 
   \   00000074   0xF421 0x0180      BICEQ    R1,R1,#0x400000
   \   00000078   0xF440 0x0080      ORRNE    R0,R0,#0x400000
   \   0000007C   0xF040 0x0001      ORRNE    R0,R0,#0x1
   \   00000080   0xF441 0x0180      ORRNE    R1,R1,#0x400000
   \   00000084   0xF8C4 0x13E0      STR      R1,[R4, #+992]
   \   00000088   0xF8C4 0x03E4      STR      R0,[R4, #+996]
   \   0000008C   0xF504 0x7171      ADD      R1,R4,#+964
   \   00000090   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   00000094   0x.... 0x....      BL       SRData__CheckShort
   \   00000098   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   0000009C   0xF8D4 0x13E0      LDR      R1,[R4, #+992]
   \   000000A0   0x0640             LSLS     R0,R0,#+25
   \   000000A2   0xD509             BPL.N    ??Mci__5msHandler_5
   \   000000A4   0xF8D4 0x03E4      LDR      R0,[R4, #+996]
   \   000000A8   0xF640 0x0201      MOVW     R2,#+2049
   \   000000AC   0x4310             ORRS     R0,R2,R0
   \   000000AE   0xF8C4 0x03E4      STR      R0,[R4, #+996]
   \   000000B2   0xF441 0x6000      ORR      R0,R1,#0x800
   \   000000B6   0xE001             B.N      ??Mci__5msHandler_6
   \                     ??Mci__5msHandler_5: (+1)
   \   000000B8   0xF421 0x6000      BIC      R0,R1,#0x800
   \                     ??Mci__5msHandler_6: (+1)
   \   000000BC   0xF8C4 0x03E0      STR      R0,[R4, #+992]
   \   000000C0   0xF894 0x0356      LDRB     R0,[R4, #+854]
   \   000000C4   0xB118             CBZ.N    R0,??Mci__5msHandler_7
   \   000000C6   0x1E40             SUBS     R0,R0,#+1
   \   000000C8   0xF884 0x0356      STRB     R0,[R4, #+854]
   \   000000CC   0xE166             B.N      ??Mci__5msHandler_8
   \                     ??Mci__5msHandler_7: (+1)
   \   000000CE   0x203C             MOVS     R0,#+60
   \   000000D0   0xF884 0x0356      STRB     R0,[R4, #+854]
   \   000000D4   0xF504 0x7171      ADD      R1,R4,#+964
   \   000000D8   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   000000DC   0x.... 0x....      BL       SRData__CheckShort
   \   000000E0   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   000000E4   0x2501             MOVS     R5,#+1
   \   000000E6   0xB900             CBNZ.N   R0,??Mci__5msHandler_9
   \   000000E8   0x2500             MOVS     R5,#+0
   \                     ??Mci__5msHandler_9: (+1)
   \   000000EA   0x2D00             CMP      R5,#+0
   \   000000EC   0xF000 0x80AD      BEQ.W    ??Mci__5msHandler_10
   \   000000F0   0xF504 0x7171      ADD      R1,R4,#+964
   \   000000F4   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   000000F8   0x.... 0x....      BL       SRData__CheckShort
   \   000000FC   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   00000100   0x07C0             LSLS     R0,R0,#+31
   \   00000102   0xD50C             BPL.N    ??Mci__5msHandler_11
   \   00000104   0xF8D4 0x03E4      LDR      R0,[R4, #+996]
   \   00000108   0xF240 0x1101      MOVW     R1,#+257
   \   0000010C   0x4308             ORRS     R0,R1,R0
   \   0000010E   0xF8C4 0x03E4      STR      R0,[R4, #+996]
   \   00000112   0xF8D4 0x03E0      LDR      R0,[R4, #+992]
   \   00000116   0xF440 0x7080      ORR      R0,R0,#0x100
   \   0000011A   0xF8C4 0x03E0      STR      R0,[R4, #+992]
   \                     ??Mci__5msHandler_11: (+1)
   \   0000011E   0xF504 0x7171      ADD      R1,R4,#+964
   \   00000122   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   00000126   0x.... 0x....      BL       SRData__CheckShort
   \   0000012A   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   0000012E   0x0780             LSLS     R0,R0,#+30
   \   00000130   0xD50C             BPL.N    ??Mci__5msHandler_12
   \   00000132   0xF8D4 0x03E4      LDR      R0,[R4, #+996]
   \   00000136   0xF240 0x2101      MOVW     R1,#+513
   \   0000013A   0x4308             ORRS     R0,R1,R0
   \   0000013C   0xF8C4 0x03E4      STR      R0,[R4, #+996]
   \   00000140   0xF8D4 0x03E0      LDR      R0,[R4, #+992]
   \   00000144   0xF440 0x7000      ORR      R0,R0,#0x200
   \   00000148   0xF8C4 0x03E0      STR      R0,[R4, #+992]
   \                     ??Mci__5msHandler_12: (+1)
   \   0000014C   0xF504 0x7171      ADD      R1,R4,#+964
   \   00000150   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   00000154   0x.... 0x....      BL       SRData__CheckShort
   \   00000158   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   0000015C   0x0740             LSLS     R0,R0,#+29
   \   0000015E   0xD50D             BPL.N    ??Mci__5msHandler_13
   \   00000160   0xF8D4 0x03E4      LDR      R0,[R4, #+996]
   \   00000164   0xF440 0x2000      ORR      R0,R0,#0x80000
   \   00000168   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000016C   0xF8C4 0x03E4      STR      R0,[R4, #+996]
   \   00000170   0xF8D4 0x03E0      LDR      R0,[R4, #+992]
   \   00000174   0xF440 0x2000      ORR      R0,R0,#0x80000
   \   00000178   0xF8C4 0x03E0      STR      R0,[R4, #+992]
   \                     ??Mci__5msHandler_13: (+1)
   \   0000017C   0xF504 0x7171      ADD      R1,R4,#+964
   \   00000180   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   00000184   0x.... 0x....      BL       SRData__CheckShort
   \   00000188   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   0000018C   0x0600             LSLS     R0,R0,#+24
   \   0000018E   0x0FC0             LSRS     R0,R0,#+31
   \   00000190   0xD00D             BEQ.N    ??Mci__5msHandler_14
   \   00000192   0xF8D4 0x03E4      LDR      R0,[R4, #+996]
   \   00000196   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   0000019A   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000019E   0xF8C4 0x03E4      STR      R0,[R4, #+996]
   \   000001A2   0xF8D4 0x03E0      LDR      R0,[R4, #+992]
   \   000001A6   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   000001AA   0xF8C4 0x03E0      STR      R0,[R4, #+992]
   \                     ??Mci__5msHandler_14: (+1)
   \   000001AE   0xF504 0x7171      ADD      R1,R4,#+964
   \   000001B2   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   000001B6   0x.... 0x....      BL       SRData__CheckShort
   \   000001BA   0xF8D4 0x03E0      LDR      R0,[R4, #+992]
   \   000001BE   0xF8B4 0x13A2      LDRH     R1,[R4, #+930]
   \   000001C2   0x0A49             LSRS     R1,R1,#+9
   \   000001C4   0xF001 0x0101      AND      R1,R1,#0x1
   \   000001C8   0xF3C0 0x0280      UBFX     R2,R0,#+2,#+1
   \   000001CC   0x4391             BICS     R1,R1,R2
   \   000001CE   0xF3C0 0x02C0      UBFX     R2,R0,#+3,#+1
   \   000001D2   0x43D2             MVNS     R2,R2
   \   000001D4   0x4211             TST      R1,R2
   \   000001D6   0xD00B             BEQ.N    ??Mci__5msHandler_15
   \   000001D8   0xF8D4 0x13E4      LDR      R1,[R4, #+996]
   \   000001DC   0xF441 0x1100      ORR      R1,R1,#0x200000
   \   000001E0   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000001E4   0xF440 0x1000      ORR      R0,R0,#0x200000
   \   000001E8   0xF8C4 0x13E4      STR      R1,[R4, #+996]
   \   000001EC   0xF8C4 0x03E0      STR      R0,[R4, #+992]
   \                     ??Mci__5msHandler_15: (+1)
   \   000001F0   0xF504 0x7171      ADD      R1,R4,#+964
   \   000001F4   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   000001F8   0x.... 0x....      BL       SRData__CheckShort
   \   000001FC   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   00000200   0x0700             LSLS     R0,R0,#+28
   \   00000202   0xD50D             BPL.N    ??Mci__5msHandler_16
   \   00000204   0xF8D4 0x03E4      LDR      R0,[R4, #+996]
   \   00000208   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   0000020C   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000210   0xF8C4 0x03E4      STR      R0,[R4, #+996]
   \   00000214   0xF8D4 0x03E0      LDR      R0,[R4, #+992]
   \   00000218   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   0000021C   0xF8C4 0x03E0      STR      R0,[R4, #+992]
   \                     ??Mci__5msHandler_16: (+1)
   \   00000220   0xF504 0x7171      ADD      R1,R4,#+964
   \   00000224   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   00000228   0x.... 0x....      BL       SRData__CheckShort
   \   0000022C   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   00000230   0x05C0             LSLS     R0,R0,#+23
   \   00000232   0xD531             BPL.N    ??Mci__5msHandler_17
   \   00000234   0xF8D4 0x03E4      LDR      R0,[R4, #+996]
   \   00000238   0xF040 0x0081      ORR      R0,R0,#0x81
   \   0000023C   0xF8C4 0x03E4      STR      R0,[R4, #+996]
   \   00000240   0xF8D4 0x03E0      LDR      R0,[R4, #+992]
   \   00000244   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000248   0xE024             B.N      ??Mci__5msHandler_18
   \                     ??Mci__5msHandler_10: (+1)
   \   0000024A   0xF8D4 0x03E0      LDR      R0,[R4, #+992]
   \   0000024E   0x.... 0x....      LDR.W    R1,??DataTable25_4  ;; 0xffd7ec7f
   \   00000252   0x4008             ANDS     R0,R1,R0
   \   00000254   0xF8C4 0x03E0      STR      R0,[R4, #+992]
   \   00000258   0x2006             MOVS     R0,#+6
   \   0000025A   0x.... 0x....      BL       Mcl__GetDigital
   \   0000025E   0xB1A8             CBZ.N    R0,??Mci__5msHandler_19
   \   00000260   0xF8D4 0x03E4      LDR      R0,[R4, #+996]
   \   00000264   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   00000268   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000026C   0xF8C4 0x03E4      STR      R0,[R4, #+996]
   \   00000270   0xF8D4 0x03E0      LDR      R0,[R4, #+992]
   \   00000274   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   00000278   0xE00C             B.N      ??Mci__5msHandler_18
   \   0000027A   0xBF00             Nop      
   \                     ??Mci__5msHandler_0:
   \   0000027C   0x43D70000         DC32     0x43d70000
   \   00000280   0x43BB0001         DC32     0x43bb0001
   \   00000284   0x430C0001         DC32     0x430c0001
   \   00000288   0x42C80000         DC32     0x42c80000
   \                     ??Mci__5msHandler_19: (+1)
   \   0000028C   0xF8D4 0x03E0      LDR      R0,[R4, #+992]
   \   00000290   0xF420 0x5000      BIC      R0,R0,#0x2000
   \                     ??Mci__5msHandler_18: (+1)
   \   00000294   0xF8C4 0x03E0      STR      R0,[R4, #+992]
   \                     ??Mci__5msHandler_17: (+1)
   \   00000298   0xF894 0x0354      LDRB     R0,[R4, #+852]
   \   0000029C   0x2808             CMP      R0,#+8
   \   0000029E   0xBF18             IT       NE 
   \   000002A0   0x2807             CMPNE    R0,#+7
   \   000002A2   0xD023             BEQ.N    ??Mci__5msHandler_20
   \   000002A4   0x2802             CMP      R0,#+2
   \   000002A6   0xD10F             BNE.N    ??Mci__5msHandler_21
   \   000002A8   0xF8B4 0x037A      LDRH     R0,[R4, #+890]
   \   000002AC   0xF5B0 0x7F50      CMP      R0,#+832
   \   000002B0   0xDD18             BLE.N    ??Mci__5msHandler_22
   \   000002B2   0xF8D4 0x03E4      LDR      R0,[R4, #+996]
   \   000002B6   0xF040 0x0003      ORR      R0,R0,#0x3
   \   000002BA   0xF8C4 0x03E4      STR      R0,[R4, #+996]
   \   000002BE   0xF8D4 0x03E0      LDR      R0,[R4, #+992]
   \   000002C2   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000002C6   0xE02B             B.N      ??Mci__5msHandler_23
   \                     ??Mci__5msHandler_21: (+1)
   \   000002C8   0x2806             CMP      R0,#+6
   \   000002CA   0xD105             BNE.N    ??Mci__5msHandler_24
   \   000002CC   0xF8D4 0x03E0      LDR      R0,[R4, #+992]
   \   000002D0   0x.... 0x....      LDR.W    R1,??DataTable26  ;; 0xfffbfffd
   \   000002D4   0x4008             ANDS     R0,R1,R0
   \   000002D6   0xE023             B.N      ??Mci__5msHandler_23
   \                     ??Mci__5msHandler_24: (+1)
   \   000002D8   0x2804             CMP      R0,#+4
   \   000002DA   0xD123             BNE.N    ??Mci__5msHandler_25
   \   000002DC   0xF8B4 0x037A      LDRH     R0,[R4, #+890]
   \   000002E0   0x2821             CMP      R0,#+33
   \   000002E2   0xDA11             BGE.N    ??Mci__5msHandler_26
   \                     ??Mci__5msHandler_22: (+1)
   \   000002E4   0x1C40             ADDS     R0,R0,#+1
   \   000002E6   0xF8A4 0x037A      STRH     R0,[R4, #+890]
   \   000002EA   0xE01B             B.N      ??Mci__5msHandler_25
   \                     ??Mci__5msHandler_20: (+1)
   \   000002EC   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   000002F0   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   000002F4   0x.... 0x....      BL       SRData__CheckShort
   \   000002F8   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   000002FC   0x0600             LSLS     R0,R0,#+24
   \   000002FE   0x0E40             LSRS     R0,R0,#+25
   \   00000300   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000304   0x4328             ORRS     R0,R5,R0
   \   00000306   0xD10D             BNE.N    ??Mci__5msHandler_25
   \                     ??Mci__5msHandler_26: (+1)
   \   00000308   0xF8D4 0x03E4      LDR      R0,[R4, #+996]
   \   0000030C   0xF440 0x2080      ORR      R0,R0,#0x40000
   \   00000310   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000314   0xF8C4 0x03E4      STR      R0,[R4, #+996]
   \   00000318   0xF8D4 0x03E0      LDR      R0,[R4, #+992]
   \   0000031C   0xF440 0x2080      ORR      R0,R0,#0x40000
   \                     ??Mci__5msHandler_23: (+1)
   \   00000320   0xF8C4 0x03E0      STR      R0,[R4, #+992]
   \                     ??Mci__5msHandler_25: (+1)
   \   00000324   0xF894 0x0354      LDRB     R0,[R4, #+852]
   \   00000328   0x2807             CMP      R0,#+7
   \   0000032A   0xDB0F             BLT.N    ??Mci__5msHandler_27
   \   0000032C   0xF894 0x03EC      LDRB     R0,[R4, #+1004]
   \   00000330   0x0680             LSLS     R0,R0,#+26
   \   00000332   0xD40B             BMI.N    ??Mci__5msHandler_27
   \   00000334   0xF8D4 0x03E4      LDR      R0,[R4, #+996]
   \   00000338   0xF040 0x0003      ORR      R0,R0,#0x3
   \   0000033C   0xF8C4 0x03E4      STR      R0,[R4, #+996]
   \   00000340   0xF8D4 0x03E0      LDR      R0,[R4, #+992]
   \   00000344   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000348   0xF8C4 0x03E0      STR      R0,[R4, #+992]
   \                     ??Mci__5msHandler_27: (+1)
   \   0000034C   0x2004             MOVS     R0,#+4
   \   0000034E   0x.... 0x....      BL       Mcl__GetDigital
   \   00000352   0xF8D4 0x13E0      LDR      R1,[R4, #+992]
   \   00000356   0xB140             CBZ.N    R0,??Mci__5msHandler_28
   \   00000358   0xF8D4 0x03E4      LDR      R0,[R4, #+996]
   \   0000035C   0xF040 0x0021      ORR      R0,R0,#0x21
   \   00000360   0xF8C4 0x03E4      STR      R0,[R4, #+996]
   \   00000364   0xF041 0x0020      ORR      R0,R1,#0x20
   \   00000368   0xE001             B.N      ??Mci__5msHandler_29
   \                     ??Mci__5msHandler_28: (+1)
   \   0000036A   0xF021 0x0020      BIC      R0,R1,#0x20
   \                     ??Mci__5msHandler_29: (+1)
   \   0000036E   0xF8C4 0x03E0      STR      R0,[R4, #+992]
   \   00000372   0x2005             MOVS     R0,#+5
   \   00000374   0x.... 0x....      BL       Mcl__GetDigital
   \   00000378   0xB150             CBZ.N    R0,??Mci__5msHandler_30
   \   0000037A   0xF8D4 0x03E4      LDR      R0,[R4, #+996]
   \   0000037E   0xF040 0x0041      ORR      R0,R0,#0x41
   \   00000382   0xF8C4 0x03E4      STR      R0,[R4, #+996]
   \   00000386   0xF8D4 0x03E0      LDR      R0,[R4, #+992]
   \   0000038A   0xF040 0x0040      ORR      R0,R0,#0x40
   \   0000038E   0xE003             B.N      ??Mci__5msHandler_31
   \                     ??Mci__5msHandler_30: (+1)
   \   00000390   0xF8D4 0x03E0      LDR      R0,[R4, #+992]
   \   00000394   0xF020 0x0040      BIC      R0,R0,#0x40
   \                     ??Mci__5msHandler_31: (+1)
   \   00000398   0xF8C4 0x03E0      STR      R0,[R4, #+992]
   1059              Update_Status();
   \                     ??Mci__5msHandler_8: (+1)
   \   0000039C   0xF894 0x1354      LDRB     R1,[R4, #+852]
   \   000003A0   0xF8D4 0x03EC      LDR      R0,[R4, #+1004]
   \   000003A4   0x2903             CMP      R1,#+3
   \   000003A6   0xD103             BNE.N    ??Mci__5msHandler_32
   \   000003A8   0x2105             MOVS     R1,#+5
   \   000003AA   0xF361 0x0044      BFI      R0,R1,#+1,#+4
   \   000003AE   0xE016             B.N      ??Mci__5msHandler_33
   \                     ??Mci__5msHandler_32: (+1)
   \   000003B0   0xF020 0x000A      BIC      R0,R0,#0xA
   \   000003B4   0x2908             CMP      R1,#+8
   \   000003B6   0xD110             BNE.N    ??Mci__5msHandler_34
   \   000003B8   0xF040 0x0010      ORR      R0,R0,#0x10
   \   000003BC   0xF8C4 0x03EC      STR      R0,[R4, #+1004]
   \   000003C0   0x.... 0x....      BL       SpeedRefGen__GetStatus
   \   000003C4   0x2803             CMP      R0,#+3
   \   000003C6   0xF8D4 0x13EC      LDR      R1,[R4, #+1004]
   \   000003CA   0xBF0C             ITE      EQ 
   \   000003CC   0xF041 0x0004      ORREQ    R0,R1,#0x4
   \   000003D0   0xF021 0x0004      BICNE    R0,R1,#0x4
   \   000003D4   0x0840             LSRS     R0,R0,#+1
   \   000003D6   0x0040             LSLS     R0,R0,#+1
   \   000003D8   0xE001             B.N      ??Mci__5msHandler_33
   \                     ??Mci__5msHandler_34: (+1)
   \   000003DA   0xF020 0x0004      BIC      R0,R0,#0x4
   \                     ??Mci__5msHandler_33: (+1)
   \   000003DE   0xF8C4 0x03EC      STR      R0,[R4, #+1004]
   \   000003E2   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   000003E6   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   000003EA   0x.... 0x....      BL       SRData__CheckShort
   \   000003EE   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   000003F2   0xF894 0x20E4      LDRB     R2,[R4, #+228]
   \   000003F6   0xF8D4 0x13EC      LDR      R1,[R4, #+1004]
   \   000003FA   0x0A40             LSRS     R0,R0,#+9
   \   000003FC   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000400   0xF002 0x0201      AND      R2,R2,#0x1
   \   00000404   0x1810             ADDS     R0,R2,R0
   \   00000406   0xB2C0             UXTB     R0,R0
   \   00000408   0x2802             CMP      R0,#+2
   \   0000040A   0xBF0C             ITE      EQ 
   \   0000040C   0xF041 0x0020      ORREQ    R0,R1,#0x20
   \   00000410   0xF021 0x0020      BICNE    R0,R1,#0x20
   \   00000414   0xF8C4 0x03EC      STR      R0,[R4, #+1004]
   1060          
   1061              Mcl__5msHandler();
   \   00000418   0xF894 0x00E4      LDRB     R0,[R4, #+228]
   \   0000041C   0x07C0             LSLS     R0,R0,#+31
   \   0000041E   0xD504             BPL.N    ??Mci__5msHandler_35
   \   00000420   0xB001             ADD      SP,SP,#+4
   \   00000422   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   00000426   0x.... 0x....      B.W      ??Running_Parallel_5msHandler
   1062          }
   \                     ??Mci__5msHandler_35: (+1)
   \   0000042A   0xB001             ADD      SP,SP,#+4
   \   0000042C   0xBD30             POP      {R4,R5,PC}       ;; return
   1063          
   1064          
   1065          
   1066          
   1067          //---------------------------------------------------------------------------------------------------------------------
   1068          /**
   1069           *  @brief      Handle Mci events of 25ms.
   1070           *
   1071           *  @param      none
   1072           *  @return     none
   1073           */

   \                                 In section .text, align 2, keep-with-next
   1074          void Mci__25msHandler(void)
   1075          {
   \                     Mci__25msHandler: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1076              MCI_25MS_CALLBACK();
   \   00000004   0x.... 0x....      BL       BoardDebugging__25msHandler
   1077          
   1078              SURGE_RELAY_25MS_HANDLER();
   \   00000008   0x.... 0x....      BL       SurgeRelay__25msHandler
   1079              INVERTER_TEMP_25MS_HANDLER();
   1080              POWERMODULEMANAGER__25MS_HANDLER();
   1081          
   1082              Mcl__25msHandler();
   \   0000000C   0xB001             ADD      SP,SP,#+4
   \   0000000E   0xF85D 0xEB04      POP      {LR}
   \   00000012   0x.... 0x....      B.W      Mcl__25msHandler
   1083          }
   1084          
   1085          
   1086          
   1087          
   1088          /**
   1089           * Run the motor, this will start the motor to run from zero RPM until a given speed with a given RPM/s. And also,
   1090           * if the motor is already running, the speed can be changed using this method.
   1091           * @param motor selects which motor to be used (one motor application, uses only MOTOR0)
   1092           * @param target_rpm is the next required speed
   1093           * @param rpm_per_s is the acceleration to the next speed. This parameter is POSITIVE the Mci will take care of its
   1094           * sign if a negative speed or deceleration is needed.
   1095           * @return MCI_CMD_INDEX_OUT_RANGE     -7 - [T/F] - command was denied by Mci because selected motor does not exist
   1096           * @return MCI_CMD_STOP_REQUESTED      -6 - [T/F] - command was denied by Mci because motor is stopping by user request
   1097           * @return MCI_CMD_PARAM_NOT_LOADED    -5 - [T/F] - denied because parameters are not loaded
   1098           * @return MCI_CMD_TIMEOUT             -4 - [T/F] - timeout due to long feedback time
   1099           * @return MCI_CMD_RAMP_OUT_OF_RANGE   -3 - [T/F] - denied due to acceleration out of range
   1100           * @return MCI_CMD_SPEED_OUT_OF_RANGE  -2 - [T/F] - denied due to speed out of range
   1101           * @return MCI_CMD_DENIED              -1 - [T/F] - denied due reason not disclosed.
   1102           * @return MCI_CMD_ACCEPTED             0 - [T/F] - accepted
   1103           */

   \                                 In section .text, align 4, keep-with-next
   1104          MCI_CMD_RESPONSE_TYPE Mci__Run(MOTOR_ENUM_TYPE motor, sint32 speed_rpm, sint32 ramp_rpm_per_s)
   1105          {
   \                     Mci__Run: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   1106              MCI_CMD_RESPONSE_TYPE response;
   1107              sint16 temp_s16;
   1108          
   1109              response = MCI_CMD_DENIED;
   \   00000002   0xF04F 0x33FF      MOV      R3,#-1
   1110          
   1111          	#ifdef MAX_ACCELERATION_SAT
   1112              if(ramp_rpm_per_s > MAX_ACCELERATION_SAT)
   1113              {
   1114                  ramp_rpm_per_s = MAX_ACCELERATION_SAT;
   1115              }
   1116          	#endif
   1117          
   1118              if(motor == MOTOR0)
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xF040 0x808E      BNE.W    ??Mci__Run_0
   1119              {
   1120                  if(BIT_TEST(Mci_Status_Control, MCI_DI_PARAMETERS_LOADED))
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000010   0xF8D0 0x43EC      LDR      R4,[R0, #+1004]
   \   00000014   0xF3C4 0x1440      UBFX     R4,R4,#+5,#+1
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xF000 0x8080      BEQ.W    ??Mci__Run_1
   1121                  {
   1122                      if(!(BIT_TEST(Mci_Flow_Control, MCI_REQUESTED_STOP)))
   \   0000001E   0xF8D0 0x43E8      LDR      R4,[R0, #+1000]
   \   00000022   0xF3C4 0x0580      UBFX     R5,R4,#+2,#+1
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD174             BNE.N    ??Mci__Run_2
   1123                      {
   1124                          temp_s16 = MATHCALC__ABS(speed_rpm);
   \   0000002A   0x2900             CMP      R1,#+0
   \   0000002C   0xBF4C             ITE      MI 
   \   0000002E   0x424D             RSBMI    R5,R1,#+0
   \   00000030   0x460D             MOVPL    R5,R1
   1125          
   1126                          if( (temp_s16 <= MAX_SPEED_RPM) &&
   1127                              (temp_s16 >= MIN_SPEED_RPM) )
   \   00000032   0xB22D             SXTH     R5,R5
   \   00000034   0x3D64             SUBS     R5,R5,#+100
   \   00000036   0xF644 0x46F5      MOVW     R6,#+19701
   \   0000003A   0x42B5             CMP      R5,R6
   \   0000003C   0xD265             BCS.N    ??Mci__Run_3
   1128                          {
   1129                              temp_s16 = MATHCALC__ABS(ramp_rpm_per_s);
   \   0000003E   0x2A00             CMP      R2,#+0
   \   00000040   0xBF4C             ITE      MI 
   \   00000042   0x4255             RSBMI    R5,R2,#+0
   \   00000044   0x4615             MOVPL    R5,R2
   1130          
   1131                              if( (temp_s16 <= MAX_RPM_PER_SEC_ACCEL) &&
   1132                                  (temp_s16 >= MIN_RPM_PER_SEC_ACCEL) )
   \   00000046   0xB22D             SXTH     R5,R5
   \   00000048   0x1E6D             SUBS     R5,R5,#+1
   \   0000004A   0xF5B5 0x6F7A      CMP      R5,#+4000
   \   0000004E   0xD257             BCS.N    ??Mci__Run_4
   \   00000050   0xF890 0x5354      LDRB     R5,[R0, #+852]
   \   00000054   0x2D03             CMP      R5,#+3
   \   00000056   0xD104             BNE.N    ??Mci__Run_5
   1133                              {
   1134                                  if(Mci_Control_State == MCI_IDLE)
   1135                                  {
   1136                                      MCI_SET_FLOW_CTL(MCI_REQUESTED_START);
   \   00000058   0xF044 0x0308      ORR      R3,R4,#0x8
   \   0000005C   0xF8C0 0x33E8      STR      R3,[R0, #+1000]
   1137          
   1138                                      SpeedRefGen__SetNewSpeed(speed_rpm, ramp_rpm_per_s);
   \   00000060   0xE001             B.N      ??Mci__Run_6
   1139          
   1140                                      response = MCI_CMD_ACCEPTED;
   1141                                  }
   1142                                  else if(Mci_Control_State == MCI_RUNNING)
   \                     ??Mci__Run_5: (+1)
   \   00000062   0x2D08             CMP      R5,#+8
   \   00000064   0xD162             BNE.N    ??Mci__Run_7
   1143                                  {
   1144                                      SpeedRefGen__SetNewSpeed(speed_rpm, ramp_rpm_per_s);
   \                     ??Mci__Run_6: (+1)
   \   00000066   0x2A00             CMP      R2,#+0
   \   00000068   0xBF48             IT       MI 
   \   0000006A   0x4252             RSBMI    R2,R2,#+0
   \   0000006C   0xED9F 0x....      VLDR.W   S0,??DataTable15  ;; 0x3dd67750
   \   00000070   0xBB52             CBNZ.N   R2,??Mci__Run_8
   \   00000072   0x000A             MOVS     R2,R1
   \   00000074   0xBF48             IT       MI 
   \   00000076   0x4252             RSBMI    R2,R2,#+0
   \   00000078   0xEE00 0x2A90      VMOV     S1,R2
   \   0000007C   0xF8D0 0x24DC      LDR      R2,[R0, #+1244]
   \   00000080   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000084   0xF022 0x4200      BIC      R2,R2,#0x80000000
   \   00000088   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   0000008C   0xEE01 0x2A10      VMOV     S2,R2
   \   00000090   0xEE70 0x0AC1      VSUB.F32 S1,S1,S2
   \   00000094   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   00000098   0xEEF1 0xFA10      FMSTAT   
   \   0000009C   0xD52C             BPL.N    ??Mci__Run_9
   \   0000009E   0xEE00 0x1A90      VMOV     S1,R1
   \   000000A2   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   000000A6   0xF200 0x41DC      ADDW     R1,R0,#+1244
   \   000000AA   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   000000AE   0xED81 0x0A00      VSTR     S0,[R1, #0]
   \   000000B2   0xF200 0x41D8      ADDW     R1,R0,#+1240
   1145          
   1146                                      response = MCI_CMD_ACCEPTED;
   \   000000B6   0x2300             MOVS     R3,#+0
   \   000000B8   0xED81 0x0A00      VSTR     S0,[R1, #0]
   \   000000BC   0x2100             MOVS     R1,#+0
   \   000000BE   0xF8C0 0x14D4      STR      R1,[R0, #+1236]
   1147                                  }
   1148                              }
   1149                          #if defined MCL_SET_RUNNING_COAST_DOWN
   1150                              else if(temp_s16 == 0)
   1151                              {
   1152                                  if(Mci_Control_State == MCI_RUNNING)
   1153                                  {
   1154                                      if(SpeedRefGen__SetNewSpeed(speed_rpm, 0) == SPEED_REF_NEG_STEP)
   1155                                      {
   1156                                          if(MCL_SET_RUNNING_COAST_DOWN(TRUE) == TRUE)
   1157                                          {
   1158                                              response = MCI_CMD_ACCEPTED;
   1159                                          }
   1160                                      }
   1161                                  }
   1162                              }
   1163                          #endif
   1164                              else
   1165                              {
   1166                                  response = MCI_CMD_RAMP_OUT_OF_RANGE;
   1167                              }
   1168                          }
   1169                          else
   1170                          {
   1171                              response = MCI_CMD_SPEED_OUT_OF_RANGE;
   1172                          }
   1173                      }
   1174                      else
   1175                      {
   1176                          response = MCI_CMD_STOP_REQUESTED;
   1177                      }
   1178                  }
   1179                  else
   1180                  {
   1181                      response = MCI_CMD_PARAM_NOT_LOADED;
   1182                  }
   1183              }
   1184              else
   1185              {
   1186          		response = MCI_CMD_INDEX_OUT_RANGE;
   1187              }
   1188          
   1189              API220_RUN_CALLBACK(motor, speed_rpm, ramp_rpm_per_s, response);
   1190          
   1191              return(response);
   \   000000C2   0x4618             MOV      R0,R3
   \   000000C4   0xBC70             POP      {R4-R6}
   \   000000C6   0x4770             BX       LR
   \                     ??Mci__Run_8: (+1)
   \   000000C8   0xEE00 0x1A90      VMOV     S1,R1
   \   000000CC   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   000000D0   0xF200 0x41D8      ADDW     R1,R0,#+1240
   \   000000D4   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   000000D8   0xEDC1 0x0A00      VSTR     S1,[R1, #0]
   \   000000DC   0xEE00 0x2A90      VMOV     S1,R2
   \   000000E0   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   000000E4   0xED9F 0x....      VLDR.W   S2,??DataTable15_1  ;; 0x3903126f
   \   000000E8   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   000000EC   0xF200 0x40D4      ADDW     R0,R0,#+1236
   \   000000F0   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   000000F4   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \                     ??Mci__Run_9: (+1)
   \   000000F8   0x2300             MOVS     R3,#+0
   \   000000FA   0xBC70             POP      {R4-R6}
   \   000000FC   0x4618             MOV      R0,R3
   \   000000FE   0x4770             BX       LR
   \                     ??Mci__Run_4: (+1)
   \   00000100   0xBC70             POP      {R4-R6}
   \   00000102   0xF06F 0x0302      MVN      R3,#+2
   \   00000106   0x4618             MOV      R0,R3
   \   00000108   0x4770             BX       LR
   \                     ??Mci__Run_3: (+1)
   \   0000010A   0xBC70             POP      {R4-R6}
   \   0000010C   0xF06F 0x0301      MVN      R3,#+1
   \   00000110   0x4618             MOV      R0,R3
   \   00000112   0x4770             BX       LR
   \                     ??Mci__Run_2: (+1)
   \   00000114   0xBC70             POP      {R4-R6}
   \   00000116   0xF06F 0x0305      MVN      R3,#+5
   \   0000011A   0x4618             MOV      R0,R3
   \   0000011C   0x4770             BX       LR
   \                     ??Mci__Run_1: (+1)
   \   0000011E   0xBC70             POP      {R4-R6}
   \   00000120   0xF06F 0x0304      MVN      R3,#+4
   \   00000124   0x4618             MOV      R0,R3
   \   00000126   0x4770             BX       LR
   \                     ??Mci__Run_0: (+1)
   \   00000128   0xF06F 0x0306      MVN      R3,#+6
   \                     ??Mci__Run_7: (+1)
   \   0000012C   0xBC70             POP      {R4-R6}
   \   0000012E   0x4618             MOV      R0,R3
   \   00000130   0x4770             BX       LR               ;; return
   1192          }
   1193          
   1194          
   1195          
   1196          
   1197          //---------------------------------------------------------------------------------------------------------------------
   1198          /**
   1199           * Manual injection - used to control manually voltage or current injection in the motor.
   1200           *
   1201           * @param   motor - motor indexer. Select what motor will be manually controlled
   1202           * @param   method - select method to be controlled. Methods implemented are:
   1203           *                         MCI_MANUAL_INJECTION_DC_VOLTAGE - DC voltage, requires voltage level and position
   1204           *                         MCI_MANUAL_INJECTION_AC_VOLTAGE - AC voltage, requires voltage level and frequency
   1205           *                         MCI_MANUAL_INJECTION_DC_CURRENT - DC current, requires current level [A], current rate [A/s] and position [degree]
   1206           *                         MCI_MANUAL_INJECTION_AC_CURRENT - AC current, requires current level and frequency
   1207           *
   1208           * @param   level_x32 - targeted level x32;  [V] if selected method is voltage;
   1209           *                                           [A] if method is current
   1210           * @param   level_rate_x32 - level rate x32; [V/s] if selected method is voltage;
   1211           *                                           [A/s] if method is current
   1212           * @param   param_x32 - auxiliary parameter x32; [Hz] if selected method is AC voltage/current;
   1213           *                                               [degree] if method is DC voltage/current
   1214           * @param   param_rate_x32 - auxiliary parameter rate x32; [Hz/s] if selected method is AC voltage/current;
   1215           *                                                         not used if method is DC voltage/current
   1216           * @return MCI_CMD_INDEX_OUT_RANGE     -7 - [T/F] - command was denied by Mci because selected motor does not exist
   1217           * @return MCI_CMD_STOP_REQUESTED      -6 - [T/F] - command was denied by Mci because motor is stopping by user request
   1218           * @return MCI_CMD_PARAM_NOT_LOADED    -5 - [T/F] - denied because parameters are not loaded
   1219           * @return MCI_CMD_TIMEOUT             -4 - [T/F] - timeout due to long feedback time
   1220           * @return MCI_CMD_RAMP_OUT_OF_RANGE   -3 - [T/F] - denied due to acceleration out of range
   1221           * @return MCI_CMD_SPEED_OUT_OF_RANGE  -2 - [T/F] - denied due to speed out of range
   1222           * @return MCI_CMD_DENIED              -1 - [T/F] - denied due reason not disclosed.
   1223           * @return MCI_CMD_ACCEPTED             0 - [T/F] - accepted
   1224           *
   1225           */

   \                                 In section .text, align 4, keep-with-next
   1226          MCI_CMD_RESPONSE_TYPE Mci__Manual_Injection(MOTOR_ENUM_TYPE motor, MCI_INJECTION_TYPE method, sint32 level_x32, sint32 level_rate_x32, sint32 param_x32, sint32 param_rate_x32)
   1227          {
   \                     Mci__Manual_Injection: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1228              MCI_CMD_RESPONSE_TYPE response;
   1229          
   1230              response = MCI_CMD_DENIED;
   1231          
   1232              if(motor == MOTOR0)
   \   00000002   0x.... 0x....      LDR.W    R5,??DataTable25
   \   00000006   0xF8D5 0x73E8      LDR      R7,[R5, #+1000]
   \   0000000A   0xF895 0x6358      LDRB     R6,[R5, #+856]
   \   0000000E   0x461C             MOV      R4,R3
   \   00000010   0xF04F 0x33FF      MOV      R3,#-1
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xF040 0x8098      BNE.W    ??Mci__Manual_Injection_1
   1233              {
   1234                  if(BIT_TEST(Mci_Status_Control, MCI_DI_PARAMETERS_LOADED))
   \   0000001A   0xF8D5 0x03EC      LDR      R0,[R5, #+1004]
   \   0000001E   0xF3C0 0x1040      UBFX     R0,R0,#+5,#+1
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xF000 0x8088      BEQ.W    ??Mci__Manual_Injection_2
   1235                  {
   1236                      if(!(BIT_TEST(Mci_Flow_Control, MCI_REQUESTED_STOP)))
   \   00000028   0xF3C7 0x0080      UBFX     R0,R7,#+2,#+1
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xF040 0x807A      BNE.W    ??Mci__Manual_Injection_3
   1237                      {
   1238                          Mcl_IO.Manual_Injection_Level = MATHCALC__ABS(level_x32);
   \   00000032   0x0010             MOVS     R0,R2
   \   00000034   0xBF48             IT       MI 
   \   00000036   0x4240             RSBMI    R0,R0,#+0
   \   00000038   0xF8C5 0x0158      STR      R0,[R5, #+344]
   1239                          Mcl_IO.Manual_Injection_Level_Rate = MATHCALC__ABS(level_rate_x32);
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0xBF48             IT       MI 
   \   00000040   0x4240             RSBMI    R0,R0,#+0
   \   00000042   0xF8C5 0x015C      STR      R0,[R5, #+348]
   1240          
   1241                          switch(method)
   \   00000046   0x2903             CMP      R1,#+3
   \   00000048   0x9804             LDR      R0,[SP, #+16]
   \   0000004A   0x9A05             LDR      R2,[SP, #+20]
   \   0000004C   0xD85B             BHI.N    ??Mci__Manual_Injection_4
   \   0000004E   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??Mci__Manual_Injection_0:
   \   00000052   0x02 0x17          DC8      0x2,0x17,0x2E,0x43
   \              0x2E 0x43    
   1242                          {
   1243                              case MCI_MANUAL_INJECTION_DC_VOLTAGE:
   1244          
   1245                                  Mcl_IO.Manual_Injection_Param = param_x32;
   \                     ??Mci__Manual_Injection_5: (+1)
   \   00000056   0xF8C5 0x0160      STR      R0,[R5, #+352]
   1246                                  Mcl_IO.Manual_Injection_Param_Rate = 0;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF8C5 0x0164      STR      R0,[R5, #+356]
   1247          
   1248                                  if(Mci_Control_State == MCI_IDLE)
   \   00000060   0xF895 0x0354      LDRB     R0,[R5, #+852]
   \   00000064   0x2803             CMP      R0,#+3
   \   00000066   0xD172             BNE.N    ??Mci__Manual_Injection_6
   1249                                  {
   1250                                      if(Mcl__SetDigital(MCL_WRITE_INJECTION_DC_VOLTAGE))
   \   00000068   0xF046 0x0610      ORR      R6,R6,#0x10
   1251                                      {
   1252                                          response = MCI_CMD_ACCEPTED;
   1253                                          MCI_SET_FLOW_CTL(MCI_REQUESTED_MANUAL_DC_VOLTAGE);
   \   0000006C   0xF047 0x0710      ORR      R7,R7,#0x10
   \   00000070   0xF885 0x6358      STRB     R6,[R5, #+856]
   \   00000074   0xF8C5 0x73E8      STR      R7,[R5, #+1000]
   \   00000078   0x2300             MOVS     R3,#+0
   1254                                      }
   1255                                  }
   1256                                  break;
   1257          
   1258                              case MCI_MANUAL_INJECTION_AC_VOLTAGE:
   1259          
   1260                                  Mcl_IO.Manual_Injection_Param = param_x32;
   1261                                  Mcl_IO.Manual_Injection_Param_Rate = MATHCALC__ABS(param_rate_x32);
   1262          
   1263                                  if(Mci_Control_State == MCI_IDLE)
   1264                                  {
   1265                                      if(Mcl__SetDigital(MCL_WRITE_INJECTION_AC_VOLTAGE))
   1266                                      {
   1267                                          response = MCI_CMD_ACCEPTED;
   1268                                          MCI_SET_FLOW_CTL(MCI_REQUESTED_MANUAL_AC_VOLTAGE);
   1269                                      }
   1270                                  }
   1271                                  break;
   1272          
   1273                              case MCI_MANUAL_INJECTION_DC_CURRENT:
   1274          
   1275                                  Mcl_IO.Manual_Injection_Param = param_x32;
   1276                                  Mcl_IO.Manual_Injection_Param_Rate = 0;
   1277          
   1278                                  if(Mci_Control_State == MCI_IDLE)
   1279                                  {
   1280                                      if(Mcl__SetDigital(MCL_WRITE_INJECTION_DC_CURRENT))
   1281                                      {
   1282                                          response = MCI_CMD_ACCEPTED;
   1283                                          MCI_SET_FLOW_CTL(MCI_REQUESTED_MANUAL_DC_CURRENT);
   1284                                      }
   1285                                  }
   1286                                  break;
   1287          
   1288                              case MCI_MANUAL_INJECTION_AC_CURRENT:
   1289          
   1290                                  Mcl_IO.Manual_Injection_Param = param_x32;
   1291                                  Mcl_IO.Manual_Injection_Param_Rate = MATHCALC__ABS(param_rate_x32);
   1292          
   1293                                  if(Mci_Control_State == MCI_IDLE)
   1294                                  {
   1295                                      if(Mcl__SetDigital(MCL_WRITE_INJECTION_AC_CURRENT))
   1296                                      {
   1297                                          response = MCI_CMD_ACCEPTED;
   1298                                          MCI_SET_FLOW_CTL(MCI_REQUESTED_MANUAL_AC_CURRENT);
   1299                                      }
   1300                                  }
   1301                                  break;
   1302          
   1303                              default:
   1304                                  Mcl_IO.Manual_Injection_Level = 0;
   1305                                  Mcl_IO.Manual_Injection_Level_Rate = 0;
   1306                                  Mcl_IO.Manual_Injection_Param = 0;
   1307                                  Mcl_IO.Manual_Injection_Param_Rate = 0;
   1308                                  break;
   1309                          };
   1310                      }
   1311                      else
   1312                      {
   1313                          response = MCI_CMD_STOP_REQUESTED;
   1314                      }
   1315                  }
   1316                  else
   1317                  {
   1318                      response = MCI_CMD_PARAM_NOT_LOADED;
   1319                  }
   1320              }
   1321              else
   1322              {
   1323          		response = MCI_CMD_INDEX_OUT_RANGE;
   1324              }
   1325              API220_MANUAL_INJECTION_CALLBACK(motor, method, level_x32, level_rate_x32, param_x32, param_rate_x32, response);
   1326          
   1327              return response;
   \   0000007A   0xBCF0             POP      {R4-R7}
   \   0000007C   0x4618             MOV      R0,R3
   \   0000007E   0x4770             BX       LR
   \                     ??Mci__Manual_Injection_7: (+1)
   \   00000080   0xF8C5 0x0160      STR      R0,[R5, #+352]
   \   00000084   0x0010             MOVS     R0,R2
   \   00000086   0xBF48             IT       MI 
   \   00000088   0x4240             RSBMI    R0,R0,#+0
   \   0000008A   0xF8C5 0x0164      STR      R0,[R5, #+356]
   \   0000008E   0xF895 0x0354      LDRB     R0,[R5, #+852]
   \   00000092   0x2803             CMP      R0,#+3
   \   00000094   0xD15B             BNE.N    ??Mci__Manual_Injection_6
   \   00000096   0xF046 0x0620      ORR      R6,R6,#0x20
   \   0000009A   0xF047 0x0720      ORR      R7,R7,#0x20
   \   0000009E   0xF885 0x6358      STRB     R6,[R5, #+856]
   \   000000A2   0xF8C5 0x73E8      STR      R7,[R5, #+1000]
   \   000000A6   0x2300             MOVS     R3,#+0
   \   000000A8   0xBCF0             POP      {R4-R7}
   \   000000AA   0x4618             MOV      R0,R3
   \   000000AC   0x4770             BX       LR
   \                     ??Mci__Manual_Injection_8: (+1)
   \   000000AE   0xF8C5 0x0160      STR      R0,[R5, #+352]
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xF8C5 0x0164      STR      R0,[R5, #+356]
   \   000000B8   0xF895 0x0354      LDRB     R0,[R5, #+852]
   \   000000BC   0x2803             CMP      R0,#+3
   \   000000BE   0xD146             BNE.N    ??Mci__Manual_Injection_6
   \   000000C0   0xF046 0x0640      ORR      R6,R6,#0x40
   \   000000C4   0xF047 0x0740      ORR      R7,R7,#0x40
   \   000000C8   0xF885 0x6358      STRB     R6,[R5, #+856]
   \   000000CC   0xF8C5 0x73E8      STR      R7,[R5, #+1000]
   \   000000D0   0x2300             MOVS     R3,#+0
   \   000000D2   0xBCF0             POP      {R4-R7}
   \   000000D4   0x4618             MOV      R0,R3
   \   000000D6   0x4770             BX       LR
   \                     ??Mci__Manual_Injection_9: (+1)
   \   000000D8   0xF8C5 0x0160      STR      R0,[R5, #+352]
   \   000000DC   0x0010             MOVS     R0,R2
   \   000000DE   0xBF48             IT       MI 
   \   000000E0   0x4240             RSBMI    R0,R0,#+0
   \   000000E2   0xF8C5 0x0164      STR      R0,[R5, #+356]
   \   000000E6   0xF895 0x0354      LDRB     R0,[R5, #+852]
   \   000000EA   0x2803             CMP      R0,#+3
   \   000000EC   0xD12F             BNE.N    ??Mci__Manual_Injection_6
   \   000000EE   0xF046 0x0680      ORR      R6,R6,#0x80
   \   000000F2   0xF047 0x0780      ORR      R7,R7,#0x80
   \   000000F6   0xF885 0x6358      STRB     R6,[R5, #+856]
   \   000000FA   0xF8C5 0x73E8      STR      R7,[R5, #+1000]
   \   000000FE   0x2300             MOVS     R3,#+0
   \   00000100   0xBCF0             POP      {R4-R7}
   \   00000102   0x4618             MOV      R0,R3
   \   00000104   0x4770             BX       LR
   \                     ??Mci__Manual_Injection_4: (+1)
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0xF885 0x6358      STRB     R6,[R5, #+856]
   \   0000010C   0xF8C5 0x73E8      STR      R7,[R5, #+1000]
   \   00000110   0xF8C5 0x0158      STR      R0,[R5, #+344]
   \   00000114   0xF8C5 0x015C      STR      R0,[R5, #+348]
   \   00000118   0xF8C5 0x0160      STR      R0,[R5, #+352]
   \   0000011C   0xF8C5 0x0164      STR      R0,[R5, #+356]
   \   00000120   0x4618             MOV      R0,R3
   \   00000122   0xBCF0             POP      {R4-R7}
   \   00000124   0x4770             BX       LR
   \                     ??Mci__Manual_Injection_3: (+1)
   \   00000126   0xF885 0x6358      STRB     R6,[R5, #+856]
   \   0000012A   0xF8C5 0x73E8      STR      R7,[R5, #+1000]
   \   0000012E   0xF06F 0x0305      MVN      R3,#+5
   \   00000132   0xBCF0             POP      {R4-R7}
   \   00000134   0x4618             MOV      R0,R3
   \   00000136   0x4770             BX       LR
   \                     ??Mci__Manual_Injection_2: (+1)
   \   00000138   0xF885 0x6358      STRB     R6,[R5, #+856]
   \   0000013C   0xF8C5 0x73E8      STR      R7,[R5, #+1000]
   \   00000140   0xF06F 0x0304      MVN      R3,#+4
   \   00000144   0xBCF0             POP      {R4-R7}
   \   00000146   0x4618             MOV      R0,R3
   \   00000148   0x4770             BX       LR
   \                     ??Mci__Manual_Injection_1: (+1)
   \   0000014A   0xF06F 0x0306      MVN      R3,#+6
   \                     ??Mci__Manual_Injection_6: (+1)
   \   0000014E   0xF885 0x6358      STRB     R6,[R5, #+856]
   \   00000152   0xF8C5 0x73E8      STR      R7,[R5, #+1000]
   \   00000156   0x4618             MOV      R0,R3
   \   00000158   0xBCF0             POP      {R4-R7}
   \   0000015A   0x4770             BX       LR               ;; return
   1328          }
   1329          
   1330          
   1331          
   1332          
   1333          //---------------------------------------------------------------------------------------------------------------------
   1334          /**
   1335           * Stop the motor regardless its speed with a desired rate. This command
   1336           * is always accepted.
   1337           * @param rpm_per_s - ramp down in rpm/s that the motor shall deaccelerates
   1338           * @param ramp_rpm_per_s equal to zero means coasting stopping.
   1339           * @param ramp_rpm_per_s higher than  MAX_RPM_PER_SEC_DECEL means lowers on mode stopping.
   1340           * @param ramp_rpm_per_s lower than  MAX_RPM_PER_SEC_DECEL (but not zero) means all devices off stopping.
   1341           * @return MCI_CMD_ACCEPTED             0 - [T/F] - accepted - always accepted
   1342           */

   \                                 In section .text, align 4, keep-with-next
   1343          MCI_CMD_RESPONSE_TYPE Mci__Stop(MOTOR_ENUM_TYPE motor, sint32 ramp_rpm_per_s)
   1344          {
   \                     Mci__Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1345              if(motor == MOTOR0)
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xF040 0x8080      BNE.W    ??Mci__Stop_0
   1346              {
   1347                  MCI_CLR_FLOW_CTL(MCI_REQUESTED_START);
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable25
   \   0000000C   0xF8D4 0x03E8      LDR      R0,[R4, #+1000]
   1348          
   1349                  if(BIT_TEST(Mci_Status_Control, MCI_DI_PARAMETERS_LOADED))
   \   00000010   0xF8D4 0x23EC      LDR      R2,[R4, #+1004]
   \   00000014   0xF020 0x0008      BIC      R0,R0,#0x8
   \   00000018   0xF3C2 0x1240      UBFX     R2,R2,#+5,#+1
   \   0000001C   0xF8C4 0x03E8      STR      R0,[R4, #+1000]
   \   00000020   0x2A00             CMP      R2,#+0
   \   00000022   0xD05F             BEQ.N    ??Mci__Stop_1
   1350                  {
   1351                      if(!(BIT_TEST(Mci_Flow_Control, MCI_REQUESTED_STOP)))
   \   00000024   0xF3C0 0x0280      UBFX     R2,R0,#+2,#+1
   \   00000028   0x2A00             CMP      R2,#+0
   \   0000002A   0xD16D             BNE.N    ??Mci__Stop_0
   \   0000002C   0xF894 0x2354      LDRB     R2,[R4, #+852]
   \   00000030   0x2A08             CMP      R2,#+8
   \   00000032   0xBF1C             ITT      NE 
   \   00000034   0x2A07             CMPNE    R2,#+7
   \   00000036   0x2A04             CMPNE    R2,#+4
   \   00000038   0xD146             BNE.N    ??Mci__Stop_2
   1352                      {
   1353                          if( (Mci_Control_State == MCI_RUNNING)          ||
   1354                              (Mci_Control_State == MCI_STARTING)         ||
   1355                              (Mci_Control_State == MCI_CLASS_B_STARTING)  )
   1356                          {
   1357                              ramp_rpm_per_s = MATHCALC__ABS(ramp_rpm_per_s);
   \   0000003A   0x2900             CMP      R1,#+0
   \   0000003C   0xBF48             IT       MI 
   \   0000003E   0x4249             RSBMI    R1,R1,#+0
   1358          
   1359                              if(ramp_rpm_per_s == 0)
   \   00000040   0xF894 0x2358      LDRB     R2,[R4, #+856]
   \   00000044   0xB911             CBNZ.N   R1,??Mci__Stop_3
   1360                              {
   1361                                  MCL_SET_STOPPING_COAST_DOWN();
   \   00000046   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000004A   0xE008             B.N      ??Mci__Stop_4
   1362                              }
   1363                              else if(ramp_rpm_per_s > MAX_RPM_PER_SEC_DECEL)
   \                     ??Mci__Stop_3: (+1)
   \   0000004C   0xF5B1 0x6F7A      CMP      R1,#+4000
   \   00000050   0xBFC6             ITTE     GT 
   1364                              {
   1365                                  ramp_rpm_per_s = MAX_RPM_PER_SEC_DECEL;
   \   00000052   0xF44F 0x617A      MOVGT    R1,#+4000
   1366          
   1367                                  MCL_SET_STOPPING_LOWERS_ON();
   \   00000056   0xF042 0x0204      ORRGT    R2,R2,#0x4
   1368                              }
   1369                              else
   1370                              {
   1371                                  MCL_SET_STOPPING_REQUEST();
   \   0000005A   0xF042 0x0202      ORRLE    R2,R2,#0x2
   1372                              }
   1373          
   1374                              MCI_SET_FLOW_CTL(MCI_REQUESTED_STOP);
   \                     ??Mci__Stop_4: (+1)
   \   0000005E   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000062   0xF8C4 0x03E8      STR      R0,[R4, #+1000]
   \   00000066   0xF884 0x2358      STRB     R2,[R4, #+856]
   1375          
   1376                              SpeedRefGen__SetNewSpeed(0, ramp_rpm_per_s);
   \   0000006A   0x0008             MOVS     R0,R1
   \   0000006C   0xBF48             IT       MI 
   \   0000006E   0x4240             RSBMI    R0,R0,#+0
   \   00000070   0xB9A8             CBNZ.N   R0,??Mci__Stop_5
   \   00000072   0xF8D4 0x04DC      LDR      R0,[R4, #+1244]
   \   00000076   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   0000007A   0xEE00 0x0A10      VMOV     S0,R0
   \   0000007E   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   00000082   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000086   0xEEF1 0xFA10      FMSTAT   
   \   0000008A   0xD53D             BPL.N    ??Mci__Stop_0
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xF8C4 0x04DC      STR      R0,[R4, #+1244]
   \   00000092   0xF8C4 0x04D8      STR      R0,[R4, #+1240]
   \   00000096   0xF8C4 0x04D4      STR      R0,[R4, #+1236]
   1377                          }
   1378                          else if(Mci_Control_State == MCI_MANUAL_CONTROL)
   1379                          {
   1380                              Mcl__ResetDigital(MCL_WRITE_ALL_INJECTION_METHOD);
   1381                              MCI_SET_FLOW_CTL(MCI_REQUESTED_STOP);
   1382                          }
   1383                      }
   1384                  }
   1385                  else
   1386                  {
   1387                      MotorSafetyMgr__ForceStop();
   1388                  }
   1389              }
   1390          
   1391              API220_STOP_CALLBACK(motor, ramp_rpm_per_s, MCI_CMD_ACCEPTED);
   1392          
   1393              return(MCI_CMD_ACCEPTED);
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xBD10             POP      {R4,PC}
   \                     ??Mci__Stop_5: (+1)
   \   0000009E   0xEE00 0x0A10      VMOV     S0,R0
   \   000000A2   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000000A6   0xEDDF 0x....      VLDR.W   S1,??DataTable15_1  ;; 0x3903126f
   \   000000AA   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000000AE   0xEDDF 0x....      VLDR.W   S1,??DataTable15  ;; 0x3dd67750
   \   000000B2   0xF204 0x40D4      ADDW     R0,R4,#+1236
   \   000000B6   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000000BA   0x2100             MOVS     R1,#+0
   \   000000BC   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   000000C0   0xF8C4 0x14D8      STR      R1,[R4, #+1240]
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0xBD10             POP      {R4,PC}
   \                     ??Mci__Stop_2: (+1)
   \   000000C8   0x2A0B             CMP      R2,#+11
   \   000000CA   0xD11D             BNE.N    ??Mci__Stop_0
   \   000000CC   0xF894 0x1358      LDRB     R1,[R4, #+856]
   \   000000D0   0xF040 0x0004      ORR      R0,R0,#0x4
   \   000000D4   0xF8C4 0x03E8      STR      R0,[R4, #+1000]
   \   000000D8   0xF001 0x010F      AND      R1,R1,#0xF
   \   000000DC   0xF884 0x1358      STRB     R1,[R4, #+856]
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0xBD10             POP      {R4,PC}
   \                     ??Mci__Stop_1: (+1)
   \   000000E4   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   000000E8   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   000000EC   0x.... 0x....      BL       SRData__CheckShort
   \   000000F0   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   000000F4   0xF440 0x6200      ORR      R2,R0,#0x800
   \   000000F8   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   000000FC   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000100   0x.... 0x....      BL       SRData__UpdateShort
   \   00000104   0x.... 0x....      BL       SRMotorSafetyMgr__Prepare2StopMotor
   \                     ??Mci__Stop_0: (+1)
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0xBD10             POP      {R4,PC}          ;; return
   1394          }
   1395          
   1396          
   1397          
   1398          
   1399          //---------------------------------------------------------------------------------------------------------------------
   1400          /**
   1401           * Read any digital error from the MCI
   1402           * @param input is index of the parameter. See the Mci.h file
   1403           * @return TRUE/FALSE according to the type of the passed parameter. The default return is TRUE.
   1404           */

   \                                 In section .text, align 4, keep-with-next
   1405          uint8 Mci__GetError(MOTOR_ENUM_TYPE motor, MCI_ERROR_TYPE read_error)
   1406          {
   1407              uint8 ret_val;
   1408          
   1409              ret_val = FALSE;
   \                     Mci__GetError: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   1410          
   1411              if(motor == MOTOR0)
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xF040 0x80BB      BNE.W    ??Mci__GetError_1
   1412              {
   1413                  if(Mci_Control_State > MCI_INITIALIZING)
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable25
   \   0000000C   0xF890 0x3354      LDRB     R3,[R0, #+852]
   \   00000010   0x2B03             CMP      R3,#+3
   \   00000012   0xF2C0 0x80B4      BLT.W    ??Mci__GetError_1
   1414                  {
   1415                      switch(read_error)
   \   00000016   0x2916             CMP      R1,#+22
   \   00000018   0xF200 0x80B0      BHI.W    ??Mci__GetError_2
   \   0000001C   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??Mci__GetError_0:
   \   00000020   0x0C 0x76          DC8      0xC,0x76,0x14,0x1B
   \              0x14 0x1B    
   \   00000024   0x22 0x30          DC8      0x22,0x30,0x37,0x4C
   \              0x37 0x4C    
   \   00000028   0x84 0x8B          DC8      0x84,0x8B,0x53,0x5A
   \              0x53 0x5A    
   \   0000002C   0x61 0x3E          DC8      0x61,0x3E,0x68,0x6F
   \              0x68 0x6F    
   \   00000030   0x45 0x29          DC8      0x45,0x29,0x7D,0x92
   \              0x7D 0x92    
   \   00000034   0x99 0xA0          DC8      0x99,0xA0,0xA7,0x0
   \              0xA7 0x00    
   1416                     {
   1417                          case MCI_ERROR_ANY_ERROR_FOUND:                         // Any error found?
   1418                               ret_val = GET_TRUE_FALSE(Mci_Error_Holder);
   \                     ??Mci__GetError_3: (+1)
   \   00000038   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   0000003C   0x1E42             SUBS     R2,R0,#+1
   \   0000003E   0x4192             SBCS     R2,R2,R2
   \   00000040   0x43D2             MVNS     R2,R2
   \   00000042   0x0FD2             LSRS     R2,R2,#+31
   1419                               break;
   1420          
   1421                          case MCI_ERROR_DCBUS_OVER_VOLTAGE:                      // DC bus link over voltage detected
   1422                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_DCBUS_OVER_VOLTAGE));
   1423                              break;
   1424          
   1425                          case MCI_ERROR_DCBUS_UNDER_VOLTAGE:                     // DC bus link under voltage detected
   1426                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_DCBUS_UNDER_VOLTAGE));
   1427                              break;
   1428          
   1429                          case MCI_ERROR_INVERTER_OVER_TEMP:                      // Module over temperature
   1430                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_INVERTER_OVER_TEMP));
   1431                              break;
   1432          
   1433                          case MCI_ERROR_STATOR_OVER_TEMP:                        // Stator temperature exceeded the limit and will prevent start for 30 seconds
   1434                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_STATOR_OVER_TEMP));
   1435                              break;
   1436          
   1437                          case MCI_ERROR_LOCKED_ROTOR_AT_STARTUP:                 // Rotor is locked by class A detection
   1438                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_LOCKED_ROTOR_AT_STARTUP));
   1439                              break;
   1440          
   1441                          case MCI_ERROR_LOCKED_ROTOR_IN_RUNNING:                 // Rotor is locked by class B detection
   1442                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_LOCKED_ROTOR_IN_RUNNING));
   1443                              break;
   1444          
   1445                          case MCI_ERROR_PHASE_LOST:                              // Phsae lost is detected.
   1446                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_PHASE_LOST));
   1447                              break;
   1448          
   1449                          case MCI_ERROR_INT_DISABLED:                            // Interrupt is disabled
   1450                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_INT_DISABLED));
   1451                              break;
   1452          
   1453                          case MCI_ERROR_MOTOR_OVERHEATING:                       // Motor is overheated!
   1454                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_MOTOR_OVERHEATING));
   1455                              break;
   1456          
   1457                          case MCI_ERROR_SW_OVER_CURRENT:                         // Motor over current detected by logic/software
   1458                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_SW_OVER_CURRENT));
   1459                              break;
   1460          
   1461                          case MCI_ERROR_HW_OVER_CURRENT:                         // Motor over current detected by peripheral/hardware
   1462                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_HW_OVER_CURRENT));
   1463                              break;
   1464          
   1465                          case MCI_ERROR_SPEED_CHECK_FAILED:                      // Speed check timeout
   1466                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_SPEED_CHECK_FAILED));
   1467                              break;
   1468          
   1469                          case MCI_ERROR_INPUTCAPTURE_PLAUSIBILITY_MIN_FAILED:    // Plausibility check for Input Capture failed
   1470                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_INPUTCAPTURE_PLAUSIBILITY_MIN_FAILED));
   1471                              break;
   1472          
   1473                          case MCI_ERROR_INPUTCAPTURE_PLAUSIBILITY_MAX_FAILED:    // Plausibility check for Input Capture maximum speed change failed
   1474                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_INPUTCAPTURE_PLAUSIBILITY_MAX_FAILED));
   1475                              break;
   1476          
   1477                          case MCI_ERROR_INITIALIZATION_FAILED:                   // Initialization is failed
   1478                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_INITIALIZATION_FAILED));
   1479                              break;
   1480          
   1481                          case MCI_ERROR_CLASS_B_FORCE2STOP:                      // Class B was forced to stop
   1482                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_CLASS_B_FORCE2STOP));
   1483                                  break;
   1484          
   1485                          case MCI_ERROR_CURRENT_SENSOR_FAILED:                   // Error found in at least one current sensor
   1486                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_CURRENT_SENSOR_FAILED));
   1487                                  break;
   1488          
   1489                          case MCI_ERROR_VOLTAGE_SENSOR_FAILED:                   // Error found in voltage sensor
   1490                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_VOLTAGE_SENSOR_FAILED));
   1491                                  break;
   1492          
   1493                          case MCI_ERROR_SHUTDOWN_HARDWARE_FAILED:                // Error found in the hardware shut down
   1494                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_SHUTDOWN_HARDWARE_FAILED));
   1495                                  break;
   1496          
   1497                          case MCI_ERROR_OBSERVER_FAILURE:                        // Observer failure - lost observability
   1498                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_OBSERVER_FAILURE));
   1499                                  break;
   1500          
   1501                          case MCI_ERROR_DCBUS_OUT_OF_RANGE:                      // From Class B - SR_FAULT_DC_VOLTAGE_OUT_OF_RANGE
   1502                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_DCBUS_OUT_OF_RANGE));
   1503                                  break;
   1504          
   1505                          case MCI_ERROR_SURGE_RELAY_OPEN:                     	// Surge relay open error
   1506                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Error_Holder, MCI_ERROR_SURGE_RELAY_OPEN));
   1507                              break;
   1508          
   1509                          default:
   1510                              ret_val = TRUE;
   1511                              break;
   1512                      }
   1513                  }
   1514              }
   1515          
   1516          
   1517              return(ret_val);
   \   00000044   0x4610             MOV      R0,R2
   \   00000046   0x4770             BX       LR
   \                     ??Mci__GetError_4: (+1)
   \   00000048   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   0000004C   0x0880             LSRS     R0,R0,#+2
   \   0000004E   0xF000 0x0201      AND      R2,R0,#0x1
   \   00000052   0x4610             MOV      R0,R2
   \   00000054   0x4770             BX       LR
   \                     ??Mci__GetError_5: (+1)
   \   00000056   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   0000005A   0x08C0             LSRS     R0,R0,#+3
   \   0000005C   0xF000 0x0201      AND      R2,R0,#0x1
   \   00000060   0x4610             MOV      R0,R2
   \   00000062   0x4770             BX       LR
   \                     ??Mci__GetError_6: (+1)
   \   00000064   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   00000068   0x0900             LSRS     R0,R0,#+4
   \   0000006A   0xF000 0x0201      AND      R2,R0,#0x1
   \   0000006E   0x4610             MOV      R0,R2
   \   00000070   0x4770             BX       LR
   \                     ??Mci__GetError_7: (+1)
   \   00000072   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   00000076   0x0C40             LSRS     R0,R0,#+17
   \   00000078   0xF000 0x0201      AND      R2,R0,#0x1
   \   0000007C   0x4610             MOV      R0,R2
   \   0000007E   0x4770             BX       LR
   \                     ??Mci__GetError_8: (+1)
   \   00000080   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   00000084   0x0940             LSRS     R0,R0,#+5
   \   00000086   0xF000 0x0201      AND      R2,R0,#0x1
   \   0000008A   0x4610             MOV      R0,R2
   \   0000008C   0x4770             BX       LR
   \                     ??Mci__GetError_9: (+1)
   \   0000008E   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   00000092   0x0980             LSRS     R0,R0,#+6
   \   00000094   0xF000 0x0201      AND      R2,R0,#0x1
   \   00000098   0x4610             MOV      R0,R2
   \   0000009A   0x4770             BX       LR
   \                     ??Mci__GetError_10: (+1)
   \   0000009C   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   000000A0   0x0B40             LSRS     R0,R0,#+13
   \   000000A2   0xF000 0x0201      AND      R2,R0,#0x1
   \   000000A6   0x4610             MOV      R0,R2
   \   000000A8   0x4770             BX       LR
   \                     ??Mci__GetError_11: (+1)
   \   000000AA   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   000000AE   0x0C00             LSRS     R0,R0,#+16
   \   000000B0   0xF000 0x0201      AND      R2,R0,#0x1
   \   000000B4   0x4610             MOV      R0,R2
   \   000000B6   0x4770             BX       LR
   \                     ??Mci__GetError_12: (+1)
   \   000000B8   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   000000BC   0x09C0             LSRS     R0,R0,#+7
   \   000000BE   0xF000 0x0201      AND      R2,R0,#0x1
   \   000000C2   0x4610             MOV      R0,R2
   \   000000C4   0x4770             BX       LR
   \                     ??Mci__GetError_13: (+1)
   \   000000C6   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   000000CA   0x0A80             LSRS     R0,R0,#+10
   \   000000CC   0xF000 0x0201      AND      R2,R0,#0x1
   \   000000D0   0x4610             MOV      R0,R2
   \   000000D2   0x4770             BX       LR
   \                     ??Mci__GetError_14: (+1)
   \   000000D4   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   000000D8   0x0AC0             LSRS     R0,R0,#+11
   \   000000DA   0xF000 0x0201      AND      R2,R0,#0x1
   \   000000DE   0x4610             MOV      R0,R2
   \   000000E0   0x4770             BX       LR
   \                     ??Mci__GetError_15: (+1)
   \   000000E2   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   000000E6   0x0B00             LSRS     R0,R0,#+12
   \   000000E8   0xF000 0x0201      AND      R2,R0,#0x1
   \   000000EC   0x4610             MOV      R0,R2
   \   000000EE   0x4770             BX       LR
   \                     ??Mci__GetError_16: (+1)
   \   000000F0   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   000000F4   0x0B80             LSRS     R0,R0,#+14
   \   000000F6   0xF000 0x0201      AND      R2,R0,#0x1
   \   000000FA   0x4610             MOV      R0,R2
   \   000000FC   0x4770             BX       LR
   \                     ??Mci__GetError_17: (+1)
   \   000000FE   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   00000102   0x0BC0             LSRS     R0,R0,#+15
   \   00000104   0xF000 0x0201      AND      R2,R0,#0x1
   \   00000108   0x4610             MOV      R0,R2
   \   0000010A   0x4770             BX       LR
   \                     ??Mci__GetError_18: (+1)
   \   0000010C   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   00000110   0x0840             LSRS     R0,R0,#+1
   \   00000112   0xF000 0x0201      AND      R2,R0,#0x1
   \   00000116   0x4610             MOV      R0,R2
   \   00000118   0x4770             BX       LR
   \                     ??Mci__GetError_19: (+1)
   \   0000011A   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   0000011E   0x0C80             LSRS     R0,R0,#+18
   \   00000120   0xF000 0x0201      AND      R2,R0,#0x1
   \   00000124   0x4610             MOV      R0,R2
   \   00000126   0x4770             BX       LR
   \                     ??Mci__GetError_20: (+1)
   \   00000128   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   0000012C   0x0A00             LSRS     R0,R0,#+8
   \   0000012E   0xF000 0x0201      AND      R2,R0,#0x1
   \   00000132   0x4610             MOV      R0,R2
   \   00000134   0x4770             BX       LR
   \                     ??Mci__GetError_21: (+1)
   \   00000136   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   0000013A   0x0A40             LSRS     R0,R0,#+9
   \   0000013C   0xF000 0x0201      AND      R2,R0,#0x1
   \   00000140   0x4610             MOV      R0,R2
   \   00000142   0x4770             BX       LR
   \                     ??Mci__GetError_22: (+1)
   \   00000144   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   00000148   0x0CC0             LSRS     R0,R0,#+19
   \   0000014A   0xF000 0x0201      AND      R2,R0,#0x1
   \   0000014E   0x4610             MOV      R0,R2
   \   00000150   0x4770             BX       LR
   \                     ??Mci__GetError_23: (+1)
   \   00000152   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   00000156   0x0D00             LSRS     R0,R0,#+20
   \   00000158   0xF000 0x0201      AND      R2,R0,#0x1
   \   0000015C   0x4610             MOV      R0,R2
   \   0000015E   0x4770             BX       LR
   \                     ??Mci__GetError_24: (+1)
   \   00000160   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   00000164   0x0D40             LSRS     R0,R0,#+21
   \   00000166   0xF000 0x0201      AND      R2,R0,#0x1
   \   0000016A   0x4610             MOV      R0,R2
   \   0000016C   0x4770             BX       LR
   \                     ??Mci__GetError_25: (+1)
   \   0000016E   0xF8D0 0x03E4      LDR      R0,[R0, #+996]
   \   00000172   0x0D80             LSRS     R0,R0,#+22
   \   00000174   0xF000 0x0201      AND      R2,R0,#0x1
   \   00000178   0x4610             MOV      R0,R2
   \   0000017A   0x4770             BX       LR
   \                     ??Mci__GetError_2: (+1)
   \   0000017C   0x2201             MOVS     R2,#+1
   \                     ??Mci__GetError_1: (+1)
   \   0000017E   0x4610             MOV      R0,R2
   \   00000180   0x4770             BX       LR               ;; return
   1518          
   1519          }
   1520          
   1521          
   1522          
   1523          
   1524          //---------------------------------------------------------------------------------------------------------------------
   1525          /**
   1526           * Get the error structure
   1527           * @param motor =  index to the motor. See the Mci.h file
   1528           * @return ret_val = Mci error holder variable value.
   1529           */

   \                                 In section .text, align 2, keep-with-next
   1530          uint32 Mci__GetErrorList(MOTOR_ENUM_TYPE motor)
   1531          {
   1532              uint32 ret_val;
   1533              ret_val = 0;
   \                     Mci__GetErrorList: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   1534          
   1535              if(motor == MOTOR0)
   \   00000002   0xB938             CBNZ.N   R0,??Mci__GetErrorList_0
   1536              {
   1537                  if(Mci_Control_State > MCI_INITIALIZING)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000008   0xF890 0x2354      LDRB     R2,[R0, #+852]
   \   0000000C   0x2A03             CMP      R2,#+3
   \   0000000E   0xBFA8             IT       GE 
   1538                  {
   1539                      ret_val = Mci_Error_Holder;
   \   00000010   0xF8D0 0x13E4      LDRGE    R1,[R0, #+996]
   1540                  }
   1541              }
   1542          
   1543              return(ret_val);
   \                     ??Mci__GetErrorList_0: (+1)
   \   00000014   0x4608             MOV      R0,R1
   \   00000016   0x4770             BX       LR               ;; return
   1544          }
   1545          
   1546          
   1547          
   1548          
   1549          //---------------------------------------------------------------------------------------------------------------------
   1550          /**
   1551           * Read any digital data from the MCI
   1552           * @param input is index of the parameter. See the Mci.h file
   1553           * @return TRUE/FALSE according to the type of the passed parameter. The default return is FALSE.
   1554           */

   \                                 In section .text, align 4, keep-with-next
   1555          uint8 Mci__GetDigital(MOTOR_ENUM_TYPE motor, MCI_DI_TYPE read_data)
   1556          {
   1557              uint8 ret_val;
   1558          
   1559              ret_val = FALSE;
   \                     Mci__GetDigital: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   1560          
   1561              if(motor == MOTOR0)
   \   00000002   0xBB20             CBNZ.N   R0,??Mci__GetDigital_1
   1562              {
   1563                  if(Mci_Control_State > MCI_INITIALIZING)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000008   0xF890 0x3354      LDRB     R3,[R0, #+852]
   \   0000000C   0x2B03             CMP      R3,#+3
   \   0000000E   0xDB1E             BLT.N    ??Mci__GetDigital_1
   1564                  {
   1565                      switch(read_data)
   \   00000010   0x2905             CMP      R1,#+5
   \   00000012   0xD81C             BHI.N    ??Mci__GetDigital_1
   \   00000014   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??Mci__GetDigital_0:
   \   00000018   0x03 0x06          DC8      0x3,0x6,0xA,0xE
   \              0x0A 0x0E    
   \   0000001C   0x12 0x16          DC8      0x12,0x16
   1566                      {
   1567                          case MCI_DI_OVER_TORQUE:            //!<  0 - [T/F] Over torque detected
   1568                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Status_Control, MCI_DI_OVER_TORQUE));
   \                     ??Mci__GetDigital_2: (+1)
   \   0000001E   0xF890 0x03EC      LDRB     R0,[R0, #+1004]
   \   00000022   0xE012             B.N      ??Mci__GetDigital_3
   1569                              break;
   1570          
   1571                          case MCI_DI_MOTOR_STOP:             //!<  1 - [T/F] Is motor stopped?
   1572                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Status_Control, MCI_DI_MOTOR_STOP));
   \                     ??Mci__GetDigital_4: (+1)
   \   00000024   0xF8D0 0x03EC      LDR      R0,[R0, #+1004]
   \   00000028   0x0840             LSRS     R0,R0,#+1
   \   0000002A   0xE00E             B.N      ??Mci__GetDigital_3
   1573                              break;
   1574          
   1575                          case MCI_DI_REACHED_TARGET_SPEED:   //!<  2 - [T/F] Target speed == reference speed
   1576                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Status_Control, MCI_DI_REACHED_TARGET_SPEED));
   \                     ??Mci__GetDigital_5: (+1)
   \   0000002C   0xF8D0 0x03EC      LDR      R0,[R0, #+1004]
   \   00000030   0x0880             LSRS     R0,R0,#+2
   \   00000032   0xE00A             B.N      ??Mci__GetDigital_3
   1577                              break;
   1578          
   1579                          case MCI_DI_IDLE:                   //!<  3 - [T/F] Motor idle, if the speed is zero, no error found.
   1580                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Status_Control, MCI_DI_IDLE));
   \                     ??Mci__GetDigital_6: (+1)
   \   00000034   0xF8D0 0x03EC      LDR      R0,[R0, #+1004]
   \   00000038   0x08C0             LSRS     R0,R0,#+3
   \   0000003A   0xE006             B.N      ??Mci__GetDigital_3
   1581                              break;
   1582          
   1583                          case MCI_DI_MOTOR_RUNNING:          //!<  4 - [T/F] Motor is running
   1584                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Status_Control, MCI_DI_MOTOR_RUNNING));
   \                     ??Mci__GetDigital_7: (+1)
   \   0000003C   0xF8D0 0x03EC      LDR      R0,[R0, #+1004]
   \   00000040   0x0900             LSRS     R0,R0,#+4
   \   00000042   0xE002             B.N      ??Mci__GetDigital_3
   1585                              break;
   1586          
   1587                          case MCI_DI_PARAMETERS_LOADED:      //!<  6 - [T/F] Read parameter loaded status
   1588                              ret_val = GET_TRUE_FALSE(BIT_TEST(Mci_Status_Control, MCI_DI_PARAMETERS_LOADED));
   \                     ??Mci__GetDigital_8: (+1)
   \   00000044   0xF8D0 0x03EC      LDR      R0,[R0, #+1004]
   \   00000048   0x0940             LSRS     R0,R0,#+5
   \                     ??Mci__GetDigital_3: (+1)
   \   0000004A   0xF000 0x0201      AND      R2,R0,#0x1
   1589                              break;
   1590          
   1591                          default:
   1592                              //
   1593                              ret_val = FALSE;                // Return a non expected valued, just in case.
   1594                              break;
   1595                      }
   1596                  }
   1597              }
   1598          
   1599              return(ret_val);
   \                     ??Mci__GetDigital_1: (+1)
   \   0000004E   0x4610             MOV      R0,R2
   \   00000050   0x4770             BX       LR               ;; return
   1600          }
   1601          
   1602          
   1603          
   1604          
   1605          //---------------------------------------------------------------------------------------------------------------------
   1606          /**
   1607           * Get the digital structure
   1608           * @param motor =  index to the motor. See the Mci.h file
   1609           * @return ret_val = Mci status control variable value.
   1610           */

   \                                 In section .text, align 2, keep-with-next
   1611          uint32 Mci__GetDigitalList(MOTOR_ENUM_TYPE motor)
   1612          {
   1613              uint32 ret_val;
   1614              ret_val = 0;
   \                     Mci__GetDigitalList: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   1615          
   1616              if(motor == MOTOR0)
   \   00000002   0xB930             CBNZ.N   R0,??Mci__GetDigitalList_0
   1617              {
   1618                  if(Mci_Control_State > MCI_INITIALIZING)
   \   00000004   0x....             LDR.N    R0,??DataTable25
   \   00000006   0xF890 0x2354      LDRB     R2,[R0, #+852]
   \   0000000A   0x2A03             CMP      R2,#+3
   \   0000000C   0xBFA8             IT       GE 
   1619                  {
   1620                      ret_val = Mci_Status_Control;
   \   0000000E   0xF8D0 0x13EC      LDRGE    R1,[R0, #+1004]
   1621                  }
   1622              }
   1623          
   1624              return(ret_val);
   \                     ??Mci__GetDigitalList_0: (+1)
   \   00000012   0x4608             MOV      R0,R1
   \   00000014   0x4770             BX       LR               ;; return
   1625          }
   1626          
   1627          
   1628          
   1629          
   1630          //---------------------------------------------------------------------------------------------------------------------
   1631          /**
   1632           * Read analog data from the MCI
   1633           * @param read_data index to the parameter. See the Mci.h file
   1634           * @return the parameter value. The default return is zero. Not implemented functions returns -1
   1635           */

   \                                 In section .text, align 4, keep-with-next
   1636          sint32 Mci__GetAnalog(MOTOR_ENUM_TYPE motor, MCI_AI_TYPE read_data)
   1637          {
   1638              sint32 ret_val;
   1639          
   1640              ret_val = MIN_SINT32;
   \                     Mci__GetAnalog: (+1)
   \   00000000   0xF04F 0x4200      MOV      R2,#-2147483648
   1641          
   1642              if(motor == MOTOR0)
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xF040 0x807F      BNE.W    ??Mci__GetAnalog_1
   1643              {
   1644                  switch(read_data)
   \   0000000A   0x2918             CMP      R1,#+24
   \   0000000C   0xF200 0x807C      BHI.W    ??Mci__GetAnalog_1
   \   00000010   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??Mci__GetAnalog_0:
   \   00000014   0x0D 0x1B          DC8      0xD,0x1B,0x28,0x7A
   \              0x28 0x7A    
   \   00000018   0x35 0x42          DC8      0x35,0x42,0x46,0x7A
   \              0x46 0x7A    
   \   0000001C   0x7A 0x6E          DC8      0x7A,0x6E,0x4A,0x7A
   \              0x4A 0x7A    
   \   00000020   0x7A 0x4E          DC8      0x7A,0x4E,0x7A,0x7A
   \              0x7A 0x7A    
   \   00000024   0x52 0x56          DC8      0x52,0x56,0x5A,0x7A
   \              0x5A 0x7A    
   \   00000028   0x5E 0x62          DC8      0x5E,0x62,0x66,0x6A
   \              0x66 0x6A    
   \   0000002C   0x77 0x00          DC8      0x77,0x0
   1645                  {
   1646          
   1647          #if defined MCL_GET_TARGET_SPEED_RPM_S16
   1648                      case MCI_AI_TARGET_SPEED_RPM_S16:       //!<  0 - Target rotor shaft speed in RPM - x65536 - (1<<16)
   1649                          ret_val = MCL_GET_TARGET_SPEED_RPM_S16();
   \                     ??Mci__GetAnalog_2: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable37_2
   \   00000032   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000036   0xEDDF 0x....      VLDR.W   S1,??DataTable24  ;; 0x4918c9eb
   \   0000003A   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000003E   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000042   0xEE10 0x2A10      VMOV     R2,S0
   1650                          break;
   1651          #endif
   1652          
   1653          #if defined MCL_GET_SPEED_REFERENCE_RPM_S16
   1654                      case MCI_AI_SPEED_REFERENCE_RPM_S16:    //!<  1 - Speed reference in RPM - x65536 - (1<<16)
   1655                          ret_val = MCL_GET_SPEED_REFERENCE_RPM_S16();
   1656                          break;
   1657          #endif
   1658          
   1659          #if defined MCL_GET_ACTUAL_SPEED_S16
   1660                      case MCI_AI_ACTUAL_SPEED_S16:           //!<  2 - Estimated rotor shaft speed in RPM - x65536 - (1<<16)
   1661                          ret_val = MCL_GET_ACTUAL_SPEED_S16();
   1662                          break;
   1663          #endif
   1664          
   1665          #if defined MCL_GET_SPEED_ERROR_RPM_S16
   1666                      case MCI_AI_SPEED_ERROR_RPM_S16:        //!<  3 - Difference between estimated and reference speeds in RPM - x65536 - (1<<16)
   1667                          ret_val = MCL_GET_SPEED_ERROR_RPM_S16();
   1668                          break;
   1669          #endif
   1670          
   1671          #if defined MCL_GET_MEAN_SPEED_S16
   1672                      case MCI_AI_MEAN_SPEED_S16:             //!<  4 - Mean rotor speed calculation - x65536 - (1<<16)
   1673                          ret_val = MCL_GET_MEAN_SPEED_S16();
   1674                          break;
   1675          #endif
   1676          
   1677          #if defined MCL_GET_RMS_MOTOR_CURRENT_S16
   1678                      case MCI_AI_RMS_MOTOR_CURRENT_S16:      //!<  5 - RMS Motor current - x65536 - (1<<16)
   1679                          ret_val = MCL_GET_RMS_MOTOR_CURRENT_S16();
   1680                          break;
   1681          #endif
   1682          
   1683          #if defined MCL_GET_ACTIVE_POWER_S16
   1684                      case MCI_AI_ACTIVE_POWER_S16:           //!<  6 - Measured active power in Watts - x65536 - (1<<16)
   1685                          ret_val = MCL_GET_ACTIVE_POWER_S16();
   1686                          break;
   1687          #endif
   1688          
   1689          #if defined MCL_GET_SHAFT_POWER_S16
   1690                      case MCI_AI_SHAFT_POWER_S16:            //!<  7 - Estimated shaft output power in Watts from estimated torque - x65536 - (1<<16)
   1691                          ret_val = MCL_GET_SHAFT_POWER_S16();
   1692                          break;
   1693          #endif
   1694          
   1695          #if defined MCL_GET_ROTOR_TEMP_S16
   1696                      case MCI_AI_ROTOR_TEMP_S16:             //!<  8 - Motor temperature in Celsius - x65536 - (1<<16)
   1697                          ret_val = MCL_GET_ROTOR_TEMP_S16();
   1698                          break;
   1699          #endif
   1700          
   1701          #if defined MCL_GET_LOAD_TORQUE_S16
   1702                      case MCI_AI_LOAD_TORQUE_S16:            //!<  9 - Read the load torque in Nm - x65536 - (1<<16)
   1703                          ret_val = MCL_GET_LOAD_TORQUE_S16();
   1704                          break;
   1705          #endif
   1706          
   1707          #if defined MCL_GET_SHAFT_POSITION_DEG_S16
   1708                      case MCI_AI_SHAFT_POSITION_DEG_S16:     //!< 10 - Estimated rotor position in deg - x65536 - (1<<16)
   1709                          ret_val = MCL_GET_SHAFT_POSITION_DEG_S16();
   1710                          break;
   1711          #endif
   1712          
   1713          #if defined MCL_GET_BUS_CURRENT_S16
   1714                      case MCI_AI_BUS_CURRENT_S16:            //!< 12 - Bus current in Amps - x65536 - (1<<16)
   1715                          ret_val = MCL_GET_BUS_CURRENT_S16();
   1716                          break;
   1717          #endif
   1718          
   1719          #if defined MCL_GET_BUS_VOLTAGE_S16
   1720                      case MCI_AI_BUS_VOLTAGE_S16:            //!< 13 - Bus voltage in Volts - x65536 - (1<<16)
   1721                          ret_val = MCL_GET_BUS_VOLTAGE_S16();
   1722                          break;
   1723          #endif
   1724          
   1725          #if defined INVERTER_TEMP_GET_TEMP_S16
   1726                      case MCI_AI_INVERTER_TEMP_S16:          //!< 14 - Inverter temperature in Celsius - x65536 - (1<<16)
   1727                          ret_val = INVERTER_TEMP_GET_TEMP_S16();
   1728                          break;
   1729          #endif
   1730          
   1731          #if defined INVERTER_TEMP_GET_TEMP_RAW_DATA
   1732                      case MCI_AI_INVERTER_TEMP_RAW_DATA:     //!< 15 - Inverter temperature in raw data [ADC counts]
   1733                          ret_val = INVERTER_TEMP_GET_TEMP_RAW_DATA();
   1734                          break;
   1735          #endif
   1736          
   1737          #if defined MCL_GET_VOLTAGE_PHASE_A_S16
   1738                      case MCI_AI_VOLTAGE_PHASE_A_S16:        //!< 16 - Motor phase A voltage in Volts - x65536 - (1<<16)
   1739                          ret_val = MCL_GET_VOLTAGE_PHASE_A_S16();
   1740                          break;
   1741          #endif
   1742          
   1743          #if defined MCL_GET_VOLTAGE_PHASE_B_S16
   1744                      case MCI_AI_VOLTAGE_PHASE_B_S16:        //!< 17 - Motor phase B voltage in Volts - x65536 - (1<<16)
   1745                          ret_val = MCL_GET_VOLTAGE_PHASE_B_S16();
   1746                          break;
   1747          #endif
   1748          
   1749          #if defined MCL_GET_VOLTAGE_PHASE_C_S16
   1750                      case MCI_AI_VOLTAGE_PHASE_C_S16:        //!< 18 - Motor phase C voltage in Volts - x65536 - (1<<16)
   1751                          ret_val = MCL_GET_VOLTAGE_PHASE_C_S16();
   1752                          break;
   1753          #endif
   1754          
   1755          #if defined MCL_GET_SPEED_LOOP_GAIN_TABLE_INDEX
   1756                      case MCI_AI_SPEED_LOOP_GAIN_TABLE_INDEX://!< 19 - Select index of speed loop gain table
   1757                          ret_val = MCL_GET_SPEED_LOOP_GAIN_TABLE_INDEX();
   1758                          break;
   1759          #endif
   1760          
   1761          #if defined MCL_GET_CURR_PHASE_A_S16
   1762                      case MCI_AI_CURR_PHASE_A_S16:           //!< 20 - Phase current A in A - x65536 - (1<<16)
   1763                          ret_val = MCL_GET_CURR_PHASE_A_S16();
   1764                          break;
   1765          #endif
   1766          
   1767          #if defined MCL_GET_CURR_PHASE_B_S16
   1768                      case MCI_AI_CURR_PHASE_B_S16:           //!< 21 - Phase current B in A - x65536 - (1<<16)
   1769                          ret_val = MCL_GET_CURR_PHASE_B_S16();
   1770                          break;
   1771          #endif
   1772          
   1773          #if defined MCL_GET_CURR_PHASE_C_S16
   1774                      case MCI_AI_CURR_PHASE_C_S16:           //!< 22 - Phase current C in A - x65536 - (1<<16)
   1775                          ret_val = MCL_GET_CURR_PHASE_C_S16();
   1776                          break;
   1777          #endif
   1778          
   1779          #if defined MCL_GET_STATOR_RESISTANCE_S16
   1780                      case MCI_AI_STATOR_RESISTANCE_S16:      //!< 23 - Stator resistance in Ohm - x65536 - (1<<16)
   1781                          ret_val = MCL_GET_STATOR_RESISTANCE_S16();
   1782                          break;
   1783          #endif
   1784          
   1785          #if defined MCL_GET_STATOR_TEMP_S16
   1786                      case MCI_AI_STATOR_TEMP_S16:            //!< 24 - Stator temperature calculated by stator resistance - x65536 - (1<<16)
   1787                          ret_val = MCL_GET_STATOR_TEMP_S16();
   1788                          break;
   1789          #endif
   1790          
   1791                      case MCI_AI_INTERNAL_MCI_STATE:         //!< 25 - Returns the internal Mci state
   1792                          ret_val = Mci_Control_State;
   1793                          break;
   1794          
   1795                      default:
   1796                          ret_val = MIN_SINT32;               //!< Return a non expected valued, just in case.
   1797                          break;
   1798                  };
   1799              }
   1800          
   1801              return(ret_val);
   \   00000046   0x4610             MOV      R0,R2
   \   00000048   0x4770             BX       LR
   \                     ??Mci__GetAnalog_3: (+1)
   \   0000004A   0x....             LDR.N    R0,??DataTable25
   \   0000004C   0xED90 0x0A55      VLDR     S0,[R0, #+340]
   \   00000050   0xEDDF 0x....      VLDR.W   S1,??DataTable24  ;; 0x4918c9eb
   \   00000054   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000058   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000005C   0xEE10 0x2A10      VMOV     R2,S0
   \   00000060   0x4610             MOV      R0,R2
   \   00000062   0x4770             BX       LR
   \                     ??Mci__GetAnalog_4: (+1)
   \   00000064   0x....             LDR.N    R0,??DataTable25
   \   00000066   0xED90 0x0A1E      VLDR     S0,[R0, #+120]
   \   0000006A   0xEDDF 0x....      VLDR.W   S1,??DataTable24  ;; 0x4918c9eb
   \   0000006E   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000072   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000076   0xEE10 0x2A10      VMOV     R2,S0
   \   0000007A   0x4610             MOV      R0,R2
   \   0000007C   0x4770             BX       LR
   \                     ??Mci__GetAnalog_5: (+1)
   \   0000007E   0x....             LDR.N    R0,??DataTable25
   \   00000080   0xED90 0x0A32      VLDR     S0,[R0, #+200]
   \   00000084   0xEDDF 0x....      VLDR.W   S1,??DataTable24  ;; 0x4918c9eb
   \   00000088   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000008C   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000090   0xEE10 0x2A10      VMOV     R2,S0
   \   00000094   0x4610             MOV      R0,R2
   \   00000096   0x4770             BX       LR
   \                     ??Mci__GetAnalog_6: (+1)
   \   00000098   0x....             LDR.N    R0,??DataTable25
   \   0000009A   0xED90 0x0A33      VLDR     S0,[R0, #+204]
   \   0000009E   0xE02A             B.N      ??Mci__GetAnalog_7
   \                     ??Mci__GetAnalog_8: (+1)
   \   000000A0   0x....             LDR.N    R0,??DataTable25
   \   000000A2   0xED90 0x0A36      VLDR     S0,[R0, #+216]
   \   000000A6   0xE026             B.N      ??Mci__GetAnalog_7
   \                     ??Mci__GetAnalog_9: (+1)
   \   000000A8   0x....             LDR.N    R0,??DataTable25
   \   000000AA   0xED90 0x0A37      VLDR     S0,[R0, #+220]
   \   000000AE   0xE022             B.N      ??Mci__GetAnalog_7
   \                     ??Mci__GetAnalog_10: (+1)
   \   000000B0   0x....             LDR.N    R0,??DataTable25
   \   000000B2   0xED90 0x0A51      VLDR     S0,[R0, #+324]
   \   000000B6   0xE01E             B.N      ??Mci__GetAnalog_7
   \                     ??Mci__GetAnalog_11: (+1)
   \   000000B8   0x....             LDR.N    R0,??DataTable25
   \   000000BA   0xED90 0x0A0E      VLDR     S0,[R0, #+56]
   \   000000BE   0xE01A             B.N      ??Mci__GetAnalog_7
   \                     ??Mci__GetAnalog_12: (+1)
   \   000000C0   0x....             LDR.N    R0,??DataTable25
   \   000000C2   0xED90 0x0A0F      VLDR     S0,[R0, #+60]
   \   000000C6   0xE016             B.N      ??Mci__GetAnalog_7
   \                     ??Mci__GetAnalog_13: (+1)
   \   000000C8   0x....             LDR.N    R0,??DataTable25
   \   000000CA   0xED90 0x0A10      VLDR     S0,[R0, #+64]
   \   000000CE   0xE012             B.N      ??Mci__GetAnalog_7
   \                     ??Mci__GetAnalog_14: (+1)
   \   000000D0   0x....             LDR.N    R0,??DataTable25
   \   000000D2   0xED90 0x0A52      VLDR     S0,[R0, #+328]
   \   000000D6   0xE00E             B.N      ??Mci__GetAnalog_7
   \                     ??Mci__GetAnalog_15: (+1)
   \   000000D8   0x....             LDR.N    R0,??DataTable25
   \   000000DA   0xED90 0x0A53      VLDR     S0,[R0, #+332]
   \   000000DE   0xE00A             B.N      ??Mci__GetAnalog_7
   \                     ??Mci__GetAnalog_16: (+1)
   \   000000E0   0x....             LDR.N    R0,??DataTable25
   \   000000E2   0xED90 0x0A54      VLDR     S0,[R0, #+336]
   \   000000E6   0xE006             B.N      ??Mci__GetAnalog_7
   \                     ??Mci__GetAnalog_17: (+1)
   \   000000E8   0x....             LDR.N    R0,??DataTable25
   \   000000EA   0xED90 0x0A34      VLDR     S0,[R0, #+208]
   \   000000EE   0xE002             B.N      ??Mci__GetAnalog_7
   \                     ??Mci__GetAnalog_18: (+1)
   \   000000F0   0x....             LDR.N    R0,??DataTable25
   \   000000F2   0xED90 0x0A1A      VLDR     S0,[R0, #+104]
   \                     ??Mci__GetAnalog_7: (+1)
   \   000000F6   0xEEBE 0x0AC8      VCVT.S32.F32 S0,S0,#+16
   \   000000FA   0xEE10 0x2A10      VMOV     R2,S0
   \   000000FE   0x4610             MOV      R0,R2
   \   00000100   0x4770             BX       LR
   \                     ??Mci__GetAnalog_19: (+1)
   \   00000102   0x....             LDR.N    R0,??DataTable25
   \   00000104   0xF890 0x2354      LDRB     R2,[R0, #+852]
   \                     ??Mci__GetAnalog_1: (+1)
   \   00000108   0x4610             MOV      R0,R2
   \   0000010A   0x4770             BX       LR               ;; return
   1802          }
   1803          
   1804          
   1805          
   1806          
   1807          //---------------------------------------------------------------------------------------------------------------------
   1808          /**
   1809           * Clear the error holder
   1810           * @param motor =  index to the motor. See the Mci.h file
   1811           * @return TRUE = All errors are clear.
   1812           * @return FALSE = mci error state.
   1813           */

   \                                 In section .text, align 2, keep-with-next
   1814          uint8 Mci__ClearError(MOTOR_ENUM_TYPE motor)
   1815          {
   1816              uint32 ret_val;
   1817              uint32 temp_error;
   1818          
   1819              ret_val = FALSE;
   1820          
   1821              if(motor == MOTOR0)
   \                     Mci__ClearError: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable25
   \   00000002   0xF8D2 0x33E4      LDR      R3,[R2, #+996]
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0xB938             CBNZ.N   R0,??Mci__ClearError_0
   1822              {
   1823                  // Check if the internal flag is already clear
   1824                  // before reseting the mirror one, prevent glitch on the bits
   1825                  temp_error = Mci_Error;                     // Use stack variable to prevent timings/glitch
   \   0000000A   0xF8D2 0x03E0      LDR      R0,[R2, #+992]
   1826                  Mci_Error_Holder &= temp_error;
   \   0000000E   0x4003             ANDS     R3,R0,R3
   1827          
   1828                  if(temp_error)
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xBF14             ITE      NE 
   1829                  {
   1830                      BIT_SET(Mci_Error_Holder, MCI_ERROR_ANY_ERROR_FOUND);
   \   00000014   0xF043 0x0301      ORRNE    R3,R3,#0x1
   1831                  }
   1832                  else
   1833                  {
   1834                      ret_val = TRUE;
   \   00000018   0x2101             MOVEQ    R1,#+1
   \                     ??Mci__ClearError_0: (+1)
   \   0000001A   0xF8C2 0x33E4      STR      R3,[R2, #+996]
   1835                  }
   1836              }
   1837          
   1838              return(ret_val);
   \   0000001E   0x4608             MOV      R0,R1
   \   00000020   0x4770             BX       LR               ;; return
   1839          }
   1840          
   1841          
   1842          
   1843          
   1844          //---------------------------------------------------------------------------------------------------------------------
   1845          /**
   1846           * Write a digital data to the MCI.
   1847           * @param write_data is the index to the data. See the Mci.h file.
   1848           * @param value TRUE/FALSE according to the selected data
   1849           * @return  TRUE - value accepted
   1850           *          FALSE - value denied - default answer.
   1851           */

   \                                 In section .text, align 2, keep-with-next
   1852          uint8 Mci__SetDigital(MOTOR_ENUM_TYPE motor, MCI_DO_TYPE write_data, uint8 value)
                                                                                            ^
Remark[Pe826]: parameter "value" was never referenced
   1853          {
   1854              uint8 ret_val;
   1855          
   1856              ret_val = FALSE;
   1857          
   1858              if(motor == MOTOR0)
   1859              {
   1860                  switch(write_data)
   1861                  {
   1862          
   1863          #if defined MCL_VA_WASH_STATE
   1864                      case MCI_DO_VA_WASH_STATE:   //!< 3 - [T/F] - TRUE = Agi / FALSE = Spin
   1865                          ret_val = MCL_VA_WASH_STATE(value);
   1866                          break;
   1867          #endif
   1868          
   1869                      default:
   1870                          ret_val = FALSE;
   1871                          break;
   1872                  }
   1873              }
   1874          
   1875              API220_PUBLISHDIGITAL_CALLBACK(motor, write_data, value, ret_val);
   1876          
   1877              return(ret_val);
   \                     Mci__SetDigital: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
   1878          }
   1879          
   1880          
   1881          
   1882          
   1883          //---------------------------------------------------------------------------------------------------------------------
   1884          /**
   1885           * Write an analog data to the MCI.
   1886           * @param write_data is the index to the data. See Mci.h file
   1887           * @param value is the value to the data
   1888           * @return  TRUE - value accepted
   1889           *          FALSE - value denied - default answer.
   1890           */

   \                                 In section .text, align 4, keep-with-next
   1891          uint8 Mci__SetAnalog(MOTOR_ENUM_TYPE motor, MCI_AO_TYPE write_data, sint32 value)
   1892          {
   \                     Mci__SetAnalog: (+1)
   \   00000000   0xEE00 0x2A10      VMOV     S0,R2
   1893              uint8 ret_val = FALSE;
   \   00000004   0x2200             MOVS     R2,#+0
   1894          
   1895              if(motor == MOTOR0)
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD15D             BNE.N    ??Mci__SetAnalog_0
   1896              {
   1897                  switch(write_data)
   \   0000000A   0x2902             CMP      R1,#+2
   \   0000000C   0xD005             BEQ.N    ??Mci__SetAnalog_1
   \   0000000E   0x2905             CMP      R1,#+5
   \   00000010   0xD019             BEQ.N    ??Mci__SetAnalog_2
   \   00000012   0x2907             CMP      R1,#+7
   \   00000014   0xD032             BEQ.N    ??Mci__SetAnalog_3
   1898                  {
   1899          
   1900          #if defined MCL_SET_SPEED_LOOP_PROP_GAIN_S16
   1901                      case MCI_AO_SPEED_LOOP_PROP_GAIN_S16:   //!<  0 - Proportional speed loop gain - x128 (1<<7)
   1902                          ret_val = MCL_SET_SPEED_LOOP_PROP_GAIN_S16(value);
   1903                          break;
   1904          #endif
   1905          
   1906          #if defined MCL_SET_SPEED_LOOP_INT_GAIN_S16
   1907                      case MCI_AO_SPEED_LOOP_INT_GAIN_S16:    //!<  1 - Integral speed loop gain - x128 (1<<7)
   1908                          ret_val = MCL_SET_SPEED_LOOP_INT_GAIN_S16(value);
   1909                          break;
   1910          #endif
   1911          
   1912          #if defined MCL_SET_SPEED_LOOP_GAIN_TABLE_INDEX
   1913                      case MCI_AO_SPEED_LOOP_GAIN_TABLE_INDEX://!<  2 - Select index of speed loop gain table
   1914                          ret_val = MCL_SET_SPEED_LOOP_GAIN_TABLE_INDEX(value);
   1915                          break;
   1916          #endif
   1917          
   1918          #if defined MCL_SET_SPEED_FIR_TAPS_TABLE_INDEX
   1919                      case MCI_AO_SPEED_FIR_TAPS_TABLE_INDEX: //!<  3 - Select index of speed fir taps
   1920                          ret_val = MCL_SET_SPEED_FIR_TAPS_TABLE_INDEX(value);
   1921                          break;
   1922          #endif
   1923          
   1924          #if defined MCL_SET_SOFTSTART_COUNTER_INDEX
   1925                      case MCI_AO_SOFTSTART_COUNTER_INDEX:    //!<  4 - Select index of soft start counter
   1926                          ret_val = MCL_SET_SOFTSTART_COUNTER_INDEX(value);
   1927                          break;
   1928          #endif
   1929          
   1930          #if defined MCL_SET_SPEED_LIMIT_INDEX
   1931                      case MCI_AO_SPEED_LIMIT_INDEX:          //!<  5 - Select index of speed controller limit
   1932                          ret_val = MCL_SET_SPEED_LIMIT_INDEX(value);
   1933                          break;
   1934          #endif
   1935          
   1936          #if defined MCL_SET_ADD_DELTA_SPEED_REF_S16
   1937                      case MCI_AO_ADD_DELTA_SPEED_REF_S16:    //!<  7 - Add (force) a delta speed on the speed reference - x65536 (1<<16)
   1938                          ret_val = MCL_SET_ADD_DELTA_SPEED_REF_S16(value);
   1939                          break;
   1940          #endif
   1941          
   1942          
   1943                      default:
   1944                          ret_val = FALSE;
   1945                          break;
   1946                  }
   1947              }
   1948          
   1949          //    API220_PUBLISHANALOG_CALLBACK(motor, write_data, value, ret_val);
   1950          
   1951              return(ret_val);
   \   00000016   0x4610             MOV      R0,R2
   \   00000018   0x4770             BX       LR
   \                     ??Mci__SetAnalog_1: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable25
   \   0000001C   0xF8D0 0x1318      LDR      R1,[R0, #+792]
   \   00000020   0xEE10 0x3A10      VMOV     R3,S0
   \   00000024   0xEB01 0x1103      ADD      R1,R1,R3, LSL #+4
   \   00000028   0xEDD1 0x0A09      VLDR     S1,[R1, #+36]
   \   0000002C   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   00000030   0xEEF1 0xFA10      FMSTAT   
   \   00000034   0xD047             BEQ.N    ??Mci__SetAnalog_0
   \   00000036   0xEE10 0x1A10      VMOV     R1,S0
   \   0000003A   0xF880 0x135F      STRB     R1,[R0, #+863]
   \   0000003E   0x2150             MOVS     R1,#+80
   \   00000040   0xF8A0 0x1384      STRH     R1,[R0, #+900]
   \   00000044   0xE03E             B.N      ??Mci__SetAnalog_4
   \                     ??Mci__SetAnalog_2: (+1)
   \   00000046   0xEEBA 0x0AC8      VCVT.F32.S32 S0,S0,#+16
   \   0000004A   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000004E   0x....             LDR.N    R0,??DataTable25
   \   00000050   0xEEF1 0xFA10      FMSTAT   
   \   00000054   0xD90D             BLS.N    ??Mci__SetAnalog_5
   \   00000056   0xF8D0 0x1488      LDR      R1,[R0, #+1160]
   \   0000005A   0xEE00 0x1A90      VMOV     S1,R1
   \   0000005E   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   00000062   0xEEF1 0xFA10      FMSTAT   
   \   00000066   0xD404             BMI.N    ??Mci__SetAnalog_5
   \   00000068   0xF200 0x408C      ADDW     R0,R0,#+1164
   \   0000006C   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   00000070   0xE028             B.N      ??Mci__SetAnalog_4
   \                     ??Mci__SetAnalog_5: (+1)
   \   00000072   0xF8D0 0x1488      LDR      R1,[R0, #+1160]
   \   00000076   0xF8C0 0x148C      STR      R1,[R0, #+1164]
   \   0000007A   0xE023             B.N      ??Mci__SetAnalog_4
   \                     ??Mci__SetAnalog_3: (+1)
   \   0000007C   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000080   0x....             LDR.N    R0,??DataTable25
   \   00000082   0xF8D0 0x1308      LDR      R1,[R0, #+776]
   \   00000086   0xEDDF 0x....      VLDR.W   S1,??DataTable25_1  ;; 0x35d67750
   \   0000008A   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000008E   0xEDD1 0x0A00      VLDR     S1,[R1, #0]
   \   00000092   0xEE70 0x0A20      VADD.F32 S1,S0,S1
   \   00000096   0xEEF0 0x0AE0      VABS.F32 S1,S1
   \   0000009A   0xED9F 0x....      VLDR.W   S2,??DataTable25_2  ;; 0x469ab001
   \   0000009E   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   000000A2   0xEEF1 0xFA10      FMSTAT   
   \   000000A6   0xD50E             BPL.N    ??Mci__SetAnalog_0
   \   000000A8   0xED9F 0x....      VLDR.W   S2,??DataTable25_3  ;; 0x42c80000
   \   000000AC   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   000000B0   0xEEF1 0xFA10      FMSTAT   
   \   000000B4   0xDB07             BLT.N    ??Mci__SetAnalog_0
   \   000000B6   0xF200 0x4180      ADDW     R1,R0,#+1152
   \   000000BA   0xED81 0x0A00      VSTR     S0,[R1, #0]
   \   000000BE   0x2114             MOVS     R1,#+20
   \   000000C0   0xF8A0 0x1386      STRH     R1,[R0, #+902]
   \                     ??Mci__SetAnalog_4: (+1)
   \   000000C4   0x2201             MOVS     R2,#+1
   \                     ??Mci__SetAnalog_0: (+1)
   \   000000C6   0x4610             MOV      R0,R2
   \   000000C8   0x4770             BX       LR               ;; return
   1952          }
   1953          
   1954          //---------------------------------------------------------------------------------------------------------------------
   1955          /**
   1956           *  @brief      Write the addresses of Mcl parameters.
   1957           *  @details
   1958           *
   1959           * @return  TRUE - value accepted
   1960           *          FALSE - value denied - default answer.
   1961           */
   1962          

   \                                 In section .text, align 2, keep-with-next
   1963          uint8 Mci__SetParams(void*  params_address)
   1964          {
   1965              uint8 ret_val;
   1966          #if defined MCL_SET_MCL_PARAMETERS_ADDRESS
   1967              ret_val = MCL_SET_MCL_PARAMETERS_ADDRESS(params_address);
   1968          #else
   1969              ret_val = FALSE;
   1970          #endif
   1971              return(ret_val);
   \                     Mci__SetParams: (+1)
   \   00000000   0x.... 0x....      B.W      Mcl__SetParams
   1972          }
   1973          
   1974          
   1975          
   1976          
   1977          #if MCI_FVT_TESTS == ENABLED
   1978          
   1979          //---------------------------------------------------------------------------------------------------------------------
   1980          /**
   1981           * Start FVT tests
   1982           * @param  motor - directs the test to a specific motor or inverter
   1983           * @return MCI_CMD_ACCEPTED             0 - [T/F] - accepted - always accepted
   1984           */

   \                                 In section .text, align 2, keep-with-next
   1985          MCI_CMD_RESPONSE_TYPE Mci__FvtStart(MOTOR_ENUM_TYPE motor)
   1986          {
   \                     Mci__FvtStart: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1987              MCI_CMD_RESPONSE_TYPE response;
   1988          
   1989              response = MCI_CMD_DENIED;
   \   00000002   0xF04F 0x30FF      MOV      R0,#-1
   1990          
   1991              if(motor == MOTOR0)
   \   00000006   0xD153             BNE.N    ??Mci__FvtStart_0
   1992              {
   1993                  if(BIT_TEST(Mci_Status_Control, MCI_DI_PARAMETERS_LOADED))
   \   00000008   0x....             LDR.N    R1,??DataTable25
   \   0000000A   0xF8D1 0x23EC      LDR      R2,[R1, #+1004]
   \   0000000E   0xF3C2 0x1240      UBFX     R2,R2,#+5,#+1
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD049             BEQ.N    ??Mci__FvtStart_1
   1994                  {
   1995                      if(!(BIT_TEST(Mci_Flow_Control, MCI_REQUESTED_STOP)))
   \   00000016   0xF8D1 0x23E8      LDR      R2,[R1, #+1000]
   \   0000001A   0xF3C2 0x0380      UBFX     R3,R2,#+2,#+1
   \   0000001E   0x2B00             CMP      R3,#+0
   \   00000020   0xD140             BNE.N    ??Mci__FvtStart_2
   1996                      {
   1997                          if(Mci_Control_State == MCI_IDLE)
   \   00000022   0xF891 0x3354      LDRB     R3,[R1, #+852]
   \   00000026   0x2B03             CMP      R3,#+3
   \   00000028   0xD144             BNE.N    ??Mci__FvtStart_3
   1998                          {
   1999                              response = MCI_CMD_ACCEPTED;
   2000          
   2001                              MCI_FVT_ENTRY();
   \   0000002A   0xF891 0x3363      LDRB     R3,[R1, #+867]
   \   0000002E   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000032   0xF881 0x3363      STRB     R3,[R1, #+867]
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x2301             MOVS     R3,#+1
   \   0000003A   0xF881 0x3362      STRB     R3,[R1, #+866]
   2002                              MCI_SET_FLOW_CTL(MCI_REQUESTED_FVT_MODE);
   \   0000003E   0xF442 0x7280      ORR      R2,R2,#0x100
   \   00000042   0xF44F 0x53FA      MOV      R3,#+8000
   \   00000046   0xF8C1 0x3240      STR      R3,[R1, #+576]
   \   0000004A   0xF8A1 0x338A      STRH     R3,[R1, #+906]
   \   0000004E   0xF881 0x0364      STRB     R0,[R1, #+868]
   \   00000052   0xF881 0x018D      STRB     R0,[R1, #+397]
   \   00000056   0xF881 0x018C      STRB     R0,[R1, #+396]
   \   0000005A   0xF8C1 0x0238      STR      R0,[R1, #+568]
   \   0000005E   0xF8C1 0x0220      STR      R0,[R1, #+544]
   \   00000062   0xF8C1 0x0224      STR      R0,[R1, #+548]
   \   00000066   0xF8C1 0x0228      STR      R0,[R1, #+552]
   \   0000006A   0xF8C1 0x022C      STR      R0,[R1, #+556]
   \   0000006E   0xF8C1 0x0230      STR      R0,[R1, #+560]
   \   00000072   0xF8C1 0x0234      STR      R0,[R1, #+564]
   \   00000076   0xF8C1 0x023C      STR      R0,[R1, #+572]
   \   0000007A   0xF8C1 0x049C      STR      R0,[R1, #+1180]
   \   0000007E   0xF881 0x0361      STRB     R0,[R1, #+865]
   \   00000082   0xF881 0x0365      STRB     R0,[R1, #+869]
   \   00000086   0xF8C1 0x23E8      STR      R2,[R1, #+1000]
   \   0000008A   0x.... 0x....      LDR.W    R3,??DataTable42  ;; 0x3f19999a
   \   0000008E   0xF8C1 0x34A0      STR      R3,[R1, #+1184]
   \   00000092   0x.... 0x....      LDR.W    R3,??DataTable30  ;; 0x3903126f
   \   00000096   0xF8C1 0x34A4      STR      R3,[R1, #+1188]
   \   0000009A   0x.... 0x....      LDR.W    R3,??DataTable43  ;; 0x3fc90fdb
   \   0000009E   0xF8C1 0x34A8      STR      R3,[R1, #+1192]
   \   000000A2   0x4770             BX       LR
   2003                          }
   2004                      }
   2005                      else
   2006                      {
   2007                          response = MCI_CMD_STOP_REQUESTED;
   \                     ??Mci__FvtStart_2: (+1)
   \   000000A4   0xF06F 0x0005      MVN      R0,#+5
   \   000000A8   0x4770             BX       LR
   2008                      }
   2009                  }
   2010                  else
   2011                  {
   2012                      response = MCI_CMD_PARAM_NOT_LOADED;
   \                     ??Mci__FvtStart_1: (+1)
   \   000000AA   0xF06F 0x0004      MVN      R0,#+4
   \   000000AE   0x4770             BX       LR
   2013                  }
   2014              }
   2015              else
   2016              {
   2017                  response = MCI_CMD_INDEX_OUT_RANGE;
   \                     ??Mci__FvtStart_0: (+1)
   \   000000B0   0xF06F 0x0006      MVN      R0,#+6
   2018              }
   2019          
   2020          //    API220_MANUAL_INJECTION_CALLBACK(motor, method, level_x32, level_rate_x32, param_x32, param_rate_x32, response);
   2021          
   2022              return(response);
   \                     ??Mci__FvtStart_3: (+1)
   \   000000B4   0x4770             BX       LR               ;; return
   2023          }
   2024          
   2025          
   2026          
   2027          
   2028          
   2029          
   2030          
   2031          
   2032          
   2033          
   2034          //---------------------------------------------------------------------------------------------------------------------
   2035          /**
   2036           * Stop the FVT tests
   2037           * @param  motor - directs the test to a specific motor or inverter
   2038           * @return MCI_CMD_ACCEPTED             0 - [T/F] - accepted - always accepted
   2039           */

   \                                 In section .text, align 2, keep-with-next
   2040          MCI_CMD_RESPONSE_TYPE Mci__FvtStop(MOTOR_ENUM_TYPE motor)
   2041          {
   \                     Mci__FvtStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2042              if(motor == MOTOR0)
   \   00000002   0xBB40             CBNZ.N   R0,??Mci__FvtStop_0
   2043              {
   2044                  if(BIT_TEST(Mci_Status_Control, MCI_DI_PARAMETERS_LOADED))
   \   00000004   0x....             LDR.N    R4,??DataTable25
   \   00000006   0xF8D4 0x03EC      LDR      R0,[R4, #+1004]
   \   0000000A   0xF3C0 0x1040      UBFX     R0,R0,#+5,#+1
   \   0000000E   0xB180             CBZ.N    R0,??Mci__FvtStop_1
   \   00000010   0xF894 0x0354      LDRB     R0,[R4, #+852]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xBF1C             ITT      NE 
   \   00000018   0x2807             CMPNE    R0,#+7
   \   0000001A   0x2804             CMPNE    R0,#+4
   \   0000001C   0xD11B             BNE.N    ??Mci__FvtStop_0
   2045                  {
   2046                      if( (Mci_Control_State == MCI_FVT_MODE)         ||
   2047                          (Mci_Control_State == MCI_STARTING)         ||
   2048                          (Mci_Control_State == MCI_CLASS_B_STARTING)  )
   2049                      {
   2050                          MCI_CLR_FLOW_CTL(MCI_REQUESTED_START);
   2051                          MCI_CLR_FLOW_CTL(MCI_REQUESTED_FVT_MODE);
   2052                          MCI_SET_FLOW_CTL(MCI_REQUESTED_STOP);
   \   0000001E   0xF8D4 0x03E8      LDR      R0,[R4, #+1000]
   \   00000022   0xF420 0x7084      BIC      R0,R0,#0x108
   \   00000026   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000002A   0xF8C4 0x03E8      STR      R0,[R4, #+1000]
   2053                      }
   2054                  }
   2055                  else
   2056                  {
   2057                      MotorSafetyMgr__ForceStop();
   2058                  }
   2059              }
   2060          
   2061          //    API220_STOP_CALLBACK(motor, ramp_rpm_per_s, MCI_CMD_ACCEPTED);
   2062          
   2063              return(MCI_CMD_ACCEPTED);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD10             POP      {R4,PC}
   \                     ??Mci__FvtStop_1: (+1)
   \   00000032   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000036   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   0000003A   0x.... 0x....      BL       SRData__CheckShort
   \   0000003E   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   00000042   0xF440 0x6200      ORR      R2,R0,#0x800
   \   00000046   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   0000004A   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   0000004E   0x.... 0x....      BL       SRData__UpdateShort
   \   00000052   0x.... 0x....      BL       SRMotorSafetyMgr__Prepare2StopMotor
   \                     ??Mci__FvtStop_0: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
   2064          }
   2065          
   2066          
   2067          
   2068          
   2069          //---------------------------------------------------------------------------------------------------------------------
   2070          /**
   2071           * Get FVT tests status
   2072           * @param  motor - directs the test to a specific motor or inverter
   2073           * @param  MCI_FVT_STATUS_TYPE             0 - [T/F] - MCI_FVT_STATUS_STARTED
   2074           * @param  MCI_FVT_STATUS_TYPE             1 - [T/F] - MCI_FVT_STATUS_FINISHED
   2075           * @return status                          [T/F] - refer to the requested status
   2076           */

   \                                 In section .text, align 2, keep-with-next
   2077          uint8 Mci__FvtGetStatus(MOTOR_ENUM_TYPE motor, MCI_FVT_STATUS_TYPE this_status)
   2078          {
   2079              uint8 ret_val;
   2080          
   2081              ret_val = FALSE;
   \                     Mci__FvtGetStatus: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   2082          
   2083              if(motor == MOTOR0)
   \   00000002   0xB960             CBNZ.N   R0,??Mci__FvtGetStatus_0
   2084              {
   2085                  if(this_status < MCI_FVT_STATUS_TOTAL)
   \   00000004   0x2902             CMP      R1,#+2
   \   00000006   0xDA0A             BGE.N    ??Mci__FvtGetStatus_0
   2086                  {
   2087                      ret_val = MCI_FVT_GET_STATUS(this_status);
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xD105             BNE.N    ??Mci__FvtGetStatus_1
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable45
   \   00000010   0xF890 0x0362      LDRB     R0,[R0, #+866]
   \   00000014   0x2803             CMP      R0,#+3
   \   00000016   0xE000             B.N      ??Mci__FvtGetStatus_2
   \                     ??Mci__FvtGetStatus_1: (+1)
   \   00000018   0x2900             CMP      R1,#+0
   \                     ??Mci__FvtGetStatus_2: (+1)
   \   0000001A   0xBF08             IT       EQ 
   \   0000001C   0x2201             MOVEQ    R2,#+1
   2088                  }
   2089              }
   2090          
   2091              return(ret_val);
   \                     ??Mci__FvtGetStatus_0: (+1)
   \   0000001E   0x4610             MOV      R0,R2
   \   00000020   0x4770             BX       LR               ;; return
   2092          }
   2093          
   2094          
   2095          
   2096          
   2097          //---------------------------------------------------------------------------------------------------------------------
   2098          /**
   2099           * Get FVT results
   2100           * @param  motor - request result of the test to a specific motor or inverter
   2101           * @param  MCI_FVT_TEST_RESULT_TYPE - *fvt_data_result pointer to the data
   2102           */

   \                                 In section .text, align 2, keep-with-next
   2103          void Mci__FvtGetResult(MOTOR_ENUM_TYPE motor, MCI_FVT_TEST_RESULT_TYPE *fvt_data_result)
   2104          {
   2105              if(motor == MOTOR0)
   \                     Mci__FvtGetResult: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xBF04             ITT      EQ 
   2106              {
   2107                  MCI_FVT_GET_RESULT(fvt_data_result);
   \   00000004   0x4608             MOVEQ    R0,R1
   \   00000006   0x.... 0x....      BEQ.W    MclFvt__GetResult
   2108              }
   2109          }
   \   0000000A   0x4770             BX       LR               ;; return
   2110          #endif
   2111          
   2112          
   2113          //=====================================================================================================================
   2114          //-------------------------------------- Private Functions ------------------------------------------------------------
   2115          //=====================================================================================================================
   2116          
   2117          
   2118          //---------------------------------------------------------------------------------------------------------------------
   2119          /**
   2120           *  @brief  Updates the pwm output according to the required pattern.
   2121           */
   2122          #ifdef __IAR_SYSTEMS_ICC__
   2123          #pragma inline = forced
   2124          #endif
   2125          void Drive_The_Motor(void)
   2126          {
   2127              sint32 dutyA;
   2128              sint32 dutyB;
   2129              sint32 dutyC;
   2130          
   2131              // LowersOn should have higher priority than All Devices Off
   2132              if(BIT_TEST(Mci_Flow_Control, MCI_FORCE_LOWERS_ON))
   2133              {
   2134                  MotorSafetyMgr__ConfigPwmPattern(OUTPUT_PATTERN_LOWERS_ON);
   2135              }
   2136              else if(BIT_TEST(Mci_Flow_Control, MCI_ALL_DEVICES_OFF))
   2137              {
   2138                  MotorSafetyMgr__ConfigPwmPattern(OUTPUT_PATTERN_ALL_DEV_OFF);
   2139              }
   2140              else
   2141              {
   2142                  // Check if there is any lower on or all device off commands
   2143                  if(Mcl_IO.Lowers_On + Mcl_IO.All_Devices_Off)
   2144                  {
   2145                      if(Mcl_IO.Lowers_On)
   2146                      {
   2147                          MotorSafetyMgr__ConfigPwmPattern(OUTPUT_PATTERN_LOWERS_ON);
   2148                      }
   2149                      else if(Mcl_IO.All_Devices_Off)
   2150                      {
   2151                          MotorSafetyMgr__ConfigPwmPattern(OUTPUT_PATTERN_ALL_DEV_OFF);
   2152                      }
   2153                  }
   2154                  else
   2155                  {
   2156                      dutyA = MCL_DUTY(Mcl_IO.Duty.A);
   2157                      dutyB = MCL_DUTY(Mcl_IO.Duty.B);
   2158                      dutyC = MCL_DUTY(Mcl_IO.Duty.C);
   2159                      MotorSafetyMgr__UpdatePwm(dutyA, dutyB, dutyC);
   2160                  }
   2161              }
   2162          }
   2163          
   2164          
   2165          
   2166          
   2167          //---------------------------------------------------------------------------------------------------------------------
   2168          /**
   2169           * @brief   Check for all error used in the control. Hardware and peripheral may
   2170           *          support to decrease the error polling rate.
   2171           */
   2172          #ifdef __IAR_SYSTEMS_ICC__
   2173          #pragma inline = forced
   2174          #endif
   2175          void Check_Errors_Pwm_Handler(void)
   2176          {
   2177              MCL_NOTATION_TYPE ia_abs;
   2178              MCL_NOTATION_TYPE ib_abs;
   2179              MCL_NOTATION_TYPE ic_abs;
   2180          
   2181              if(Mci_Control_State >= MCI_STARTING)
   2182              {
   2183                  ia_abs = MCL__ABS(Mcl_IO.Is_ABC.A);
   2184                  ib_abs = MCL__ABS(Mcl_IO.Is_ABC.B);
   2185                  ic_abs = MCL__ABS(Mcl_IO.Is_ABC.C);
   2186          
   2187                  if( (ia_abs >= MCI_MAXIMAL_MOTOR_CURRENT_ALLOWED)   ||
   2188                      (ib_abs >= MCI_MAXIMAL_MOTOR_CURRENT_ALLOWED)   ||
   2189                      (ic_abs >= MCI_MAXIMAL_MOTOR_CURRENT_ALLOWED) )
   2190                  {
   2191                      MCI_SET_ERROR(MCI_ERROR_SW_OVER_CURRENT);
   2192                  }
   2193                  else
   2194                  {
   2195                      MCI_CLR_ERROR(MCI_ERROR_SW_OVER_CURRENT);
   2196                  }
   2197              }
   2198              else
   2199              {
   2200                  MCI_CLR_ERROR(MCI_ERROR_SW_OVER_CURRENT);
   2201              }
   2202          }
   2203          
   2204          
   2205          
   2206          
   2207          //---------------------------------------------------------------------------------------------------------------------
   2208          /**
   2209           * @brief   Check for all error used in the control. Hardware and peripheral may
   2210           *          support to decrease the error polling rate.
   2211           */
   2212          #ifdef __IAR_SYSTEMS_ICC__
   2213          #pragma inline = forced
   2214          #endif
   2215          void Check_Errors_5ms_Handler(void)
   2216          {
   2217          	uint8 any_class_B_error_found;
   2218              uint8 temp_u8;
   2219              static uint8 time_postscaler = 0;
   2220          #if (defined MCI_HW_OC_DEBOUNCE_TIME) && (defined MCI_HW_OC_PORT) && (defined MCI_HW_OC_PIN) && (defined MCI_HW_OC_LEVEL)
   2221              static uint8 hw_oc_debouncer = (uint8)(MCI_HW_OC_DEBOUNCE_TIME/0.005f);
   2222              uint8 hw_pin_in;
   2223          #endif
   2224          
   2225              //////////////////////////////////////////////////////////////////////////////////////////
   2226              //// DC Bus voltage monitor
   2227              // High voltage events in Class A
   2228              if(Mcl_IO.Vdc >= MCI_MAX_BUS_VOLTAGE)
   2229              {
   2230                  MCI_SET_ERROR(MCI_ERROR_DCBUS_OVER_VOLTAGE);
   2231              }
   2232              else if(Mcl_IO.Vdc <= MCI_MAX_IDLE_BUS_VOLTAGE)
   2233              {
   2234                  MCI_CLR_ERROR(MCI_ERROR_DCBUS_OVER_VOLTAGE);
   2235              }
   2236          
   2237              // Low voltage events in Class A
   2238          
   2239              if(Mcl_IO.Vdc <= MCI_MIN_BUS_VOLTAGE_RUN)
   2240              {
   2241                  MCI_SET_ERROR(MCI_ERROR_DCBUS_UNDER_VOLTAGE);
   2242              }
   2243              else if(Mcl_IO.Vdc >= MCI_MIN_BUS_VOLTAGE_IDLE)
   2244              {
   2245                  MCI_CLR_ERROR(MCI_ERROR_DCBUS_UNDER_VOLTAGE);
   2246              }
   2247          
   2248              if(!SURGE_RELAY_READY())
   2249              {
   2250                  MCI_SET_ERROR(MCI_ERROR_SURGE_RELAY_OPEN);
   2251              }
   2252              else
   2253              {
   2254                  MCI_CLR_ERROR(MCI_ERROR_SURGE_RELAY_OPEN);
   2255              }
   2256          
   2257              //////////////////////////////////////////////////////////////////////////////////////////
   2258              // DC Bus (over) current monitor
   2259              temp_u8 = MotorSafetyMgr__GetFault(SR_FAULT_OVER_CURRENT_TRIPPED);
   2260          
   2261          #if (defined MCI_HW_OC_DEBOUNCE_TIME) && (defined MCI_HW_OC_PORT) && (defined MCI_HW_OC_PIN) && (defined MCI_HW_OC_LEVEL)
   2262          
   2263              // Refresh input config
   2264              Gpio__PinConfig(MCI_HW_OC_PORT, MCI_HW_OC_PIN, INPUT_FLOAT);
   2265          
   2266              // Read input oc pin
   2267              hw_pin_in = Gpio__PinRead(MCI_HW_OC_PORT, MCI_HW_OC_PIN);
   2268          
   2269              // Debounce oc pin, if the failure is found
   2270              if(hw_pin_in == MCI_HW_OC_LEVEL)
   2271              {
   2272              	// count up the time
   2273              	if(hw_oc_debouncer < (uint8)(MCI_HW_OC_DEBOUNCE_TIME/0.005f))
   2274              	{
   2275              		hw_oc_debouncer++;
   2276              	}
   2277              	else
   2278              	{
   2279              		temp_u8 = TRUE;
   2280              	}
   2281              }
   2282              else
   2283              {
   2284              	// count down the time
   2285              	if(hw_oc_debouncer)
   2286              	{
   2287              		hw_oc_debouncer--;
   2288              	}
   2289              }
   2290          
   2291          #endif
   2292          
   2293          
   2294              if(temp_u8)
   2295              {
   2296                  MCI_SET_ERROR(MCI_ERROR_HW_OVER_CURRENT);
   2297              }
   2298              else
   2299              {
   2300                  MCI_CLR_ERROR(MCI_ERROR_HW_OVER_CURRENT);
   2301              }
   2302          
   2303              // Time post scaler, reduce from 5 ms to MCI_CHECKERR_POSTSCALER
   2304              if(time_postscaler)
   2305              {
   2306                  time_postscaler--;
   2307              }
   2308              else
   2309              {
   2310                  time_postscaler = MCI_CHECKERR_POSTSCALER;
   2311          
   2312                  // Any error found
   2313                  any_class_B_error_found = MotorSafetyMgr__AnyFaultFound();
   2314                  if(any_class_B_error_found)
   2315                  {
   2316                      // Look for electronics failure, OR wise operation across the flags below
   2317                      temp_u8  = MotorSafetyMgr__GetFault(SR_FAULT_CURRENT_SENSOR_FAILED);
   2318                      if(temp_u8)
   2319                      {
   2320                          MCI_SET_ERROR(MCI_ERROR_CURRENT_SENSOR_FAILED);
   2321                      }
   2322          
   2323                      temp_u8 = MotorSafetyMgr__GetFault(SR_FAULT_VOLTAGE_SENSOR_FAILED);
   2324                      if(temp_u8)
   2325                      {
   2326                          MCI_SET_ERROR(MCI_ERROR_VOLTAGE_SENSOR_FAILED);
   2327                      }
   2328          
   2329                      temp_u8 = MotorSafetyMgr__GetFault(SR_FAULT_SHUTDOWN_HARDWARE_FAILED);
   2330                      if(temp_u8)
   2331                      {
   2332                          MCI_SET_ERROR(MCI_ERROR_SHUTDOWN_HARDWARE_FAILED);
   2333                      }
   2334          
   2335          
   2336                      // Look for phase lost detection
   2337                      temp_u8  = MotorSafetyMgr__GetFault(SR_FAULT_PHASE_LOST);
   2338                      if(temp_u8)
   2339                      {
   2340                          MCI_SET_ERROR(MCI_ERROR_PHASE_LOST);
   2341                      }
   2342          
   2343                      //////////////////////////////////////////////////////////////////////////////////////////
   2344                      //// Class B check
   2345                      // Voltage is out of range from Class B
   2346                      temp_u8 = MotorSafetyMgr__GetFault(SR_FAULT_DC_VOLTAGE_OUT_OF_RANGE);
   2347                      temp_u8 &= ~(BIT_TEST(Mci_Error, MCI_ERROR_DCBUS_OVER_VOLTAGE));
   2348                      temp_u8 &= ~(BIT_TEST(Mci_Error, MCI_ERROR_DCBUS_UNDER_VOLTAGE));
   2349                      if(temp_u8)
   2350                      {
   2351                          MCI_SET_ERROR(MCI_ERROR_DCBUS_OUT_OF_RANGE);
   2352                      }
   2353          
   2354                      //// Check unlock door speed failed
   2355                      temp_u8 = MotorSafetyMgr__GetFault(SR_FAULT_UNLOCK_DOOR_SPEED_FAILED);
   2356                      if(temp_u8)
   2357                      {
   2358                          MCI_SET_ERROR(MCI_ERROR_SPEED_CHECK_FAILED);
   2359                      }
   2360          
   2361          
   2362                      //// Check input capture plausibility faults
   2363                      #if defined MCL_GET_FAULT_INPUTCAPTURE_PLAUSIBILITY_MIN_FAILED
   2364                          // Min Tach Fault
   2365                          temp_u8 = MCL_GET_FAULT_INPUTCAPTURE_PLAUSIBILITY_MIN_FAILED();
   2366                          if(temp_u8)
   2367                          {
   2368                          	MCI_SET_ERROR(MCI_ERROR_INPUTCAPTURE_PLAUSIBILITY_MIN_FAILED);
   2369                          }
   2370                      #endif
   2371          
   2372                      #if defined MCL_GET_FAULT_INPUTCAPTURE_PLAUSIBILITY_MAX_FAILED
   2373                          // Max Speed change Fault
   2374                          temp_u8 = MCL_GET_FAULT_INPUTCAPTURE_PLAUSIBILITY_MAX_FAILED();
   2375                          if(temp_u8)
   2376                          {
   2377                          	MCI_SET_ERROR(MCI_ERROR_INPUTCAPTURE_PLAUSIBILITY_MAX_FAILED);
   2378                          }
   2379                      #endif
   2380          
   2381                      // Check for motor over heating
   2382                      temp_u8 = MotorSafetyMgr__GetFault(SR_FAULT_OVER_HEATING);
   2383                      if(temp_u8)
   2384                      {
   2385                         MCI_SET_ERROR(MCI_ERROR_MOTOR_OVERHEATING);
   2386                      }
   2387                  }
   2388                  else
   2389                  {
   2390                      MCI_CLR_ERROR(MCI_ERROR_CURRENT_SENSOR_FAILED);
   2391                      MCI_CLR_ERROR(MCI_ERROR_VOLTAGE_SENSOR_FAILED);
   2392                      MCI_CLR_ERROR(MCI_ERROR_SHUTDOWN_HARDWARE_FAILED);
   2393                      MCI_CLR_ERROR(MCI_ERROR_DCBUS_OUT_OF_RANGE);
   2394                      MCI_CLR_ERROR(MCI_ERROR_SPEED_CHECK_FAILED);
   2395          
   2396                      //// Check input capture plausibility faults
   2397                      #if defined MCL_GET_FAULT_INPUTCAPTURE_PLAUSIBILITY_MIN_FAILED
   2398                          MCI_CLR_ERROR(MCI_ERROR_INPUTCAPTURE_PLAUSIBILITY_MIN_FAILED);
   2399                      #endif
   2400          
   2401                      #if defined MCL_GET_FAULT_INPUTCAPTURE_PLAUSIBILITY_MAX_FAILED
   2402                          MCI_CLR_ERROR(MCI_ERROR_INPUTCAPTURE_PLAUSIBILITY_MAX_FAILED);
   2403                      #endif
   2404          
   2405                      MCI_CLR_ERROR(MCI_ERROR_MOTOR_OVERHEATING);
   2406          
   2407                      // Look for phase lost detection
   2408          #if defined MCL_GET_MOTOR_DISCONNECTED
   2409                      // Motor disconnection check
   2410                      temp_u8 = MCL_GET_MOTOR_DISCONNECTED();
   2411          #endif
   2412                      if(temp_u8)
   2413                      {
   2414                          MCI_SET_ERROR(MCI_ERROR_PHASE_LOST);
   2415                      }
   2416                      else
   2417                      {
   2418                          MCI_CLR_ERROR(MCI_ERROR_PHASE_LOST);
   2419                      }
   2420                  }
   2421          
   2422          
   2423                  //////////////////////////////////////////
   2424                  ////// MCI_RUNNING
   2425                  if(Mci_Control_State == MCI_RUNNING)
   2426                  {
   2427                      temp_u8 = MotorSafetyMgr__DoesClassAHaveAccessToPwm();
   2428                      if(temp_u8 == FALSE)
   2429                      {
   2430                      	if(!any_class_B_error_found)
   2431                      	{
   2432                      		MCI_SET_ERROR(MCI_ERROR_CLASS_B_FORCE2STOP);
   2433                      	}
   2434                      }
   2435                  }
   2436                  //////////////////////////////////////////
   2437                  ////// MCI_STARTING
   2438                  else if(Mci_Control_State == MCI_STARTING)
   2439                  {
   2440                      temp_u8 = MotorSafetyMgr__DoesClassAHaveAccessToPwm();
   2441                      if(temp_u8 == FALSE)
   2442                      {
   2443                      	if(!any_class_B_error_found)
   2444                      	{
   2445                      		MCI_SET_ERROR(MCI_ERROR_CLASS_B_FORCE2STOP);
   2446                      	}
   2447                      }
   2448                  }
   2449                  //////////////////////////////////////////
   2450                  ////// MCI_INITIALIZING
   2451                  else if(Mci_Control_State == MCI_INITIALIZING)
   2452                  {
   2453                      if(Mci_GP_Timer < MCI_INIT_ERROR_THRES)
   2454                      {
   2455                          Mci_GP_Timer++;
   2456                      }
   2457                      else
   2458                      {
   2459                          MCI_SET_ERROR(MCI_ERROR_INITIALIZATION_FAILED);
   2460                      }
   2461                  }
   2462                  //////////////////////////////////////////
   2463                  ////// MCI_FAILED
   2464                  else if(Mci_Control_State == MCI_FAILED)
   2465                  {
   2466                      MCI_CLR_ERROR(MCI_ERROR_INITIALIZATION_FAILED);
   2467                      MCI_CLR_ERROR(MCI_ERROR_CLASS_B_FORCE2STOP);
   2468                  }
   2469                  //////////////////////////////////////////
   2470                  ////// MCI_CLASS_B_STARTING
   2471                  else if(Mci_Control_State == MCI_CLASS_B_STARTING)
   2472                  {
   2473                      if(Mci_GP_Timer < MCI_CLASS_B_STARTUP_THRES)
   2474                      {
   2475                          Mci_GP_Timer++;
   2476                      }
   2477                      else
   2478                      {
   2479                      	MCI_SET_ERROR(MCI_ERROR_CLASS_B_FORCE2STOP);
   2480                      }
   2481                  }
   2482          
   2483                  // Check if pwm is accessible by class A, then
   2484                  if(Mci_Control_State >= MCI_STARTING)
   2485                  {
   2486                      temp_u8 = BIT_TEST(Mci_Status_Control, MCI_DI_PARAMETERS_LOADED);
   2487                      if(!temp_u8)
   2488                      {
   2489                          MCI_SET_ERROR(MCI_ERROR_INITIALIZATION_FAILED);
   2490                      }
   2491                  }
   2492          
   2493          #if defined MCI_MEASURE_INVERTER_TEMP
   2494          
   2495                  if(InverterTemp__AboveThreshold_s16((MODULE_TEMP_TO_STOP<<16)) == TRUE)
   2496                  {
   2497                      MCI_SET_ERROR(MCI_ERROR_INVERTER_OVER_TEMP);
   2498                  }
   2499                  if(InverterTemp__AboveThreshold_s16((MODULE_TEMP_TO_START<<16)) == FALSE)
   2500                  {
   2501                      MCI_CLR_ERROR(MCI_ERROR_INVERTER_OVER_TEMP);
   2502                  }
   2503          
   2504          #endif
   2505          
   2506          
   2507          #if defined MCL_GET_LOCKED_ROTOR_AT_STARTUP
   2508          
   2509                 // Locked rotor by algorithm - startup phase
   2510                 temp_u8 = MCL_GET_LOCKED_ROTOR_AT_STARTUP();
   2511                 if(temp_u8)
   2512                 {
   2513                     MCI_SET_ERROR(MCI_ERROR_LOCKED_ROTOR_AT_STARTUP);
   2514                 }
   2515                 else
   2516                 {
   2517                     MCI_CLR_ERROR(MCI_ERROR_LOCKED_ROTOR_AT_STARTUP);
   2518                 }
   2519          
   2520          #endif
   2521          
   2522          
   2523          #if defined MCL_GET_LOCKED_ROTOR_IN_RUNNING
   2524          
   2525                 // Locked rotor by algorithm - motor running
   2526                 temp_u8 = MCL_GET_LOCKED_ROTOR_IN_RUNNING();
   2527                 if(temp_u8)
   2528                 {
   2529                     MCI_SET_ERROR(MCI_ERROR_LOCKED_ROTOR_IN_RUNNING);
   2530                 }
   2531                 else
   2532                 {
   2533                     MCI_CLR_ERROR(MCI_ERROR_LOCKED_ROTOR_IN_RUNNING);
   2534                 }
   2535          
   2536          #endif
   2537          
   2538          
   2539          #if defined MCL_GET_OBSERVER_FAILURE
   2540          
   2541                 // Observer failure found
   2542                 temp_u8 = MCL_GET_OBSERVER_FAILURE();
   2543                 if(temp_u8)
   2544                 {
   2545                     MCI_SET_ERROR(MCI_ERROR_OBSERVER_FAILURE);
   2546                 }
   2547                 else
   2548                 {
   2549                     MCI_CLR_ERROR(MCI_ERROR_OBSERVER_FAILURE);
   2550                 }
   2551          
   2552          #endif
   2553          
   2554          
   2555          #if defined MCL_GET_STATOR_OVER_TEMP
   2556          
   2557                 // Motor over temperature
   2558                 temp_u8 = MCL_GET_STATOR_OVER_TEMP();
   2559                 if(temp_u8)
   2560                 {
   2561                     MCI_SET_ERROR(MCI_ERROR_STATOR_OVER_TEMP);
   2562                 }
   2563                 else
   2564                 {
   2565                     MCI_CLR_ERROR(MCI_ERROR_STATOR_OVER_TEMP);
   2566                 }
   2567          
   2568          #endif
   2569          
   2570          
   2571          #if defined MCL_GET_INT_DISABLED
   2572          
   2573                 // Motor over temperature
   2574                 temp_u8 = MCL_GET_INT_DISABLED();
   2575                 if(temp_u8)
   2576                 {
   2577                     MCI_SET_ERROR(MCI_ERROR_INT_DISABLED);
   2578                 }
   2579                 else
   2580                 {
   2581                     MCI_CLR_ERROR(MCI_ERROR_INT_DISABLED);
   2582                 }
   2583          
   2584          #endif
   2585              }
   2586          }
   2587          
   2588          
   2589          
   2590          
   2591          //---------------------------------------------------------------------------------------------------------------------
   2592          /**
   2593           * @brief   Check for all flow control that the algorithm uses.
   2594           */
   2595          #ifdef __IAR_SYSTEMS_ICC__
   2596          #pragma inline = forced
   2597          #endif
   2598          void Update_Status(void)
   2599          {
   2600              uint8 temp_u8;
   2601          
   2602              //////////////////////////////////////////////////////////////////////////////////////////
   2603              //// Check the flag MCI_IS_MOTOR_STOPPED & MCI_MOTOR_IDLE
   2604              // If the state is in IDLE
   2605              if(Mci_Control_State == MCI_IDLE)
   2606              {
   2607                  // Motor state is idle
   2608                  MCI_SET_STATUS_CTL(MCI_DI_IDLE);
   2609          
   2610                  // Motor state is in IDLE, therefore the motor shall not be being drive anymore
   2611                  MCI_CLR_STATUS_CTL(MCI_DI_MOTOR_RUNNING);
   2612          
   2613                  MCI_SET_STATUS_CTL(MCI_DI_MOTOR_STOP);
   2614          
   2615                  MCI_CLR_STATUS_CTL(MCI_DI_REACHED_TARGET_SPEED);
   2616              }
   2617              else // otherwise
   2618              {
   2619                  // the motor is not stopped
   2620                  MCI_CLR_STATUS_CTL(MCI_DI_MOTOR_STOP);
   2621          
   2622                  // Motor state not idle
   2623                  MCI_CLR_STATUS_CTL(MCI_DI_IDLE);
   2624          
   2625                  // If the main state is running
   2626                  if(Mci_Control_State == MCI_RUNNING)
   2627                  {
   2628                      // Set the motor running flag
   2629                      MCI_SET_STATUS_CTL(MCI_DI_MOTOR_RUNNING);
   2630          
   2631                      if(SpeedRefGen__GetStatus() == SPEED_REF_AT_PLATEAU)
   2632                      {
   2633                          MCI_SET_STATUS_CTL(MCI_DI_REACHED_TARGET_SPEED);
   2634                      }
   2635                      else
   2636                      {
   2637                          MCI_CLR_STATUS_CTL(MCI_DI_REACHED_TARGET_SPEED);
   2638                      }
   2639          
   2640          #if defined MCL_GET_OVER_TORQUE
   2641          
   2642                      temp_u8 = MCL_GET_OVER_TORQUE();
   2643                      if(temp_u8)
   2644                      {
   2645                          MCI_SET_STATUS_CTL(MCI_DI_OVER_TORQUE);
   2646                      }
   2647                      else
   2648                      {
   2649                          MCI_CLR_STATUS_CTL(MCI_DI_OVER_TORQUE);
   2650                      }
   2651          
   2652          #else
   2653          
   2654                      MCI_CLR_STATUS_CTL(MCI_DI_OVER_TORQUE);
   2655          
   2656          #endif
   2657                  }
   2658                  else
   2659                  {
   2660                          MCI_CLR_STATUS_CTL(MCI_DI_REACHED_TARGET_SPEED);
   2661                  }
   2662              }
   2663          
   2664          
   2665              // Check if parameters are loaded
   2666              temp_u8  = MotorSafetyMgr__GetFlag(SR_FLAG_MC_PARAMETERS_LOADED);
   2667              temp_u8 += MCL_GET_PARAMETERS_LOADED();
   2668          #if (INVERTER_TEMP_SETTINGFILE_SUPPORT == ENABLED)
   2669              temp_u8 += (uint8) InverterTemp__GetParameterLoaded();
   2670          #endif
   2671          #if (POWERMODULE_MANAGER_USED == ENABLED)
   2672              temp_u8 += (uint8) PowerModuleManager__GetParameterLoaded();
   2673          #endif
   2674              if(temp_u8 == MCI_PARAMS_LOADED_CHECKS)
   2675              {
   2676                  MCI_SET_STATUS_CTL(MCI_DI_PARAMETERS_LOADED);
   2677              }
   2678              else
   2679              {
   2680                  MCI_CLR_STATUS_CTL(MCI_DI_PARAMETERS_LOADED);
   2681              }
   2682          
   2683          
   2684          }
   2685          
   2686          
   2687          
   2688          
   2689          //---------------------------------------------------------------------------------------------------------------------
   2690          /**
   2691           * @brief   Initialize the analog interface variables
   2692           */
   2693          
   2694          #ifdef __IAR_SYSTEMS_ICC__
   2695          #pragma inline = forced
   2696          #endif
   2697          void Initialize_Current_DCBus_Voltage(void)
   2698          {
   2699              Mcl_IO.Is_ABC.A = (MCL_NOTATION_TYPE)0;
   2700              Mcl_IO.Is_ABC.B = (MCL_NOTATION_TYPE)0;
   2701              Mcl_IO.Is_ABC.C = (MCL_NOTATION_TYPE)0;
   2702              Mcl_IO.Vdc      = (MCL_NOTATION_TYPE)0;
   2703          }
   2704          
   2705          
   2706          
   2707          
   2708          //---------------------------------------------------------------------------------------------------------------------
   2709          /**
   2710           * @brief   Convert data from peripherals into requested to the motor control
   2711           */
   2712          #ifdef __IAR_SYSTEMS_ICC__
   2713          #pragma inline = forced
   2714          #endif
   2715          void Read_Current_DCBus_Voltage(sint32 ia_adc, sint32 ib_adc, sint32 ic_adc, sint32 dcbus_adc)
   2716          {
   2717          #ifndef MCI_CURRENT_SENSOR_GAIN_POSITIVE
   2718          
   2719              // Mcl interface Update
   2720              Mcl_IO.Is_ABC.A = MCL_CURRENT(((-ia_adc) << 4));
   2721              Mcl_IO.Is_ABC.B = MCL_CURRENT(((-ib_adc) << 4));
   2722              Mcl_IO.Is_ABC.C = MCL_CURRENT(((-ic_adc) << 4));
   2723          
   2724          #else
   2725          
   2726              // Mcl interface Update
   2727              Mcl_IO.Is_ABC.A = MCL_CURRENT(((ia_adc) << 4));
   2728              Mcl_IO.Is_ABC.B = MCL_CURRENT(((ib_adc) << 4));
   2729              Mcl_IO.Is_ABC.C = MCL_CURRENT(((ic_adc) << 4));
   2730          
   2731          #endif
   2732          
   2733              Mcl_IO.Vdc = MCL_VOLTAGE((dcbus_adc << 3));
   2734          }
   2735          
   2736          
   2737          
   2738          #if(API220_DEBUG_MODE == ENABLED)
   2739          /*
   2740           * @brief   Force error to emulate mci reaction. Used for debugging purposes
   2741           *          of high level application, like cycle manager and other modules.
   2742           * @param   emulate_this_error [MCI_ERROR_TYPE] - error index.
   2743           */
   2744          void Mci__Emulate_Error(uint8 emulate_this_error)
   2745          {
   2746          
   2747              switch(emulate_this_error)
   2748              {
   2749                  case MCI_ERROR_INITIALIZATION_FAILED:
   2750                      MCI_SET_ERROR(MCI_ERROR_INITIALIZATION_FAILED);
   2751                      break;
   2752          
   2753                  case MCI_ERROR_DCBUS_OVER_VOLTAGE:
   2754                      MCI_SET_ERROR(MCI_ERROR_DCBUS_OVER_VOLTAGE);
   2755                      break;
   2756          
   2757                  case MCI_ERROR_DCBUS_UNDER_VOLTAGE:
   2758                      MCI_SET_ERROR(MCI_ERROR_DCBUS_UNDER_VOLTAGE);
   2759                      break;
   2760          
   2761          #if defined MCI_MEASURE_INVERTER_TEMP
   2762          
   2763                  case MCI_ERROR_INVERTER_OVER_TEMP:
   2764                      MCI_SET_ERROR(MCI_ERROR_INVERTER_OVER_TEMP);
   2765                      break;
   2766          
   2767          #endif
   2768          
   2769          #if defined MCL_GET_LOCKED_ROTOR_AT_STARTUP
   2770          
   2771                  case MCI_ERROR_LOCKED_ROTOR_AT_STARTUP:
   2772                      MCI_SET_ERROR(MCI_ERROR_LOCKED_ROTOR_AT_STARTUP);
   2773                      break;
   2774          
   2775          #endif
   2776          
   2777          #if defined MCL_GET_LOCKED_ROTOR_IN_RUNNING
   2778          
   2779                  case MCI_ERROR_LOCKED_ROTOR_IN_RUNNING:
   2780                      MCI_SET_ERROR(MCI_ERROR_LOCKED_ROTOR_IN_RUNNING);
   2781                      break;
   2782          
   2783          #endif
   2784          
   2785                  case MCI_ERROR_MOTOR_OVERHEATING:
   2786                      MCI_SET_ERROR(MCI_ERROR_MOTOR_OVERHEATING);
   2787                      break;
   2788          
   2789                  case MCI_ERROR_CURRENT_SENSOR_FAILED:
   2790                      MCI_SET_ERROR(MCI_ERROR_CURRENT_SENSOR_FAILED);
   2791                      break;
   2792          
   2793                  case MCI_ERROR_VOLTAGE_SENSOR_FAILED:
   2794                      MCI_SET_ERROR(MCI_ERROR_VOLTAGE_SENSOR_FAILED);
   2795                      break;
   2796          
   2797                  case MCI_ERROR_SW_OVER_CURRENT:
   2798                      MCI_SET_ERROR(MCI_ERROR_SW_OVER_CURRENT);
   2799                      break;
   2800          
   2801                  case MCI_ERROR_HW_OVER_CURRENT:
   2802                      MCI_SET_ERROR(MCI_ERROR_HW_OVER_CURRENT);
   2803                      break;
   2804          
   2805                  case MCI_ERROR_SPEED_CHECK_FAILED:
   2806                      MCI_SET_ERROR(MCI_ERROR_SPEED_CHECK_FAILED);
   2807                      break;
   2808          
   2809                  case MCI_ERROR_PHASE_LOST:
   2810                      MCI_SET_ERROR(MCI_ERROR_PHASE_LOST);
   2811                      break;
   2812          
   2813          #if defined MCL_GET_FAULT_INPUTCAPTURE_PLAUSIBILITY_MIN_FAILED
   2814          
   2815                  case MCI_ERROR_INPUTCAPTURE_PLAUSIBILITY_MIN_FAILED:
   2816                      MCI_SET_ERROR(MCI_ERROR_INPUTCAPTURE_PLAUSIBILITY_MIN_FAILED);
   2817                      break;
   2818          
   2819          #endif
   2820          
   2821          #if defined MCL_GET_FAULT_INPUTCAPTURE_PLAUSIBILITY_MAX_FAILED
   2822          
   2823                  case MCI_ERROR_INPUTCAPTURE_PLAUSIBILITY_MAX_FAILED:
   2824                      MCI_SET_ERROR(MCI_ERROR_INPUTCAPTURE_PLAUSIBILITY_MAX_FAILED);
   2825                      break;
   2826          
   2827          #endif
   2828          
   2829          #if defined MCL_GET_INT_DISABLED
   2830          
   2831                  case MCI_ERROR_INT_DISABLED:
   2832                      MCI_SET_ERROR(MCI_ERROR_INT_DISABLED);
   2833                      break;
   2834          
   2835          #endif
   2836          
   2837          #if defined MCL_GET_STATOR_OVER_TEMP
   2838          
   2839                  case MCI_ERROR_STATOR_OVER_TEMP:
   2840                      MCI_SET_ERROR(MCI_ERROR_STATOR_OVER_TEMP);
   2841                      break;
   2842          
   2843          #endif
   2844          
   2845                  case MCI_ERROR_CLASS_B_FORCE2STOP:
   2846                      MCI_SET_ERROR(MCI_ERROR_CLASS_B_FORCE2STOP);
   2847                      break;
   2848          
   2849                  case MCI_ERROR_SHUTDOWN_HARDWARE_FAILED:
   2850                      MCI_SET_ERROR(MCI_ERROR_SHUTDOWN_HARDWARE_FAILED);
   2851                      break;
   2852          
   2853          #if defined MCL_GET_OBSERVER_FAILURE
   2854          
   2855                  case MCI_ERROR_OBSERVER_FAILURE:
   2856                      MCI_SET_ERROR(MCI_ERROR_OBSERVER_FAILURE);
   2857                      break;
   2858          
   2859          #endif
   2860          
   2861                  case MCI_ERROR_DCBUS_OUT_OF_RANGE:
   2862                      MCI_SET_ERROR(MCI_ERROR_DCBUS_OUT_OF_RANGE);
   2863                      break;
   2864          
   2865                  case MCI_ERROR_SURGE_RELAY_OPEN:
   2866                  	MCI_SET_ERROR(MCI_ERROR_SURGE_RELAY_OPEN);
   2867                  	break;
   2868          
   2869                  default:
   2870                      //
   2871                      break;
   2872              }
   2873          
   2874          
   2875          }
   2876          #endif
C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\Mcl\Mcl.c
      1          /**
      2           *  @file
      3           *  @brief       Motor Control Loop 3-phase motors.
      4           *  @details     This module implements the motor oriented control loop for 3-phase motors (DD, BPM, CIM).
      5           *  @author      alessio.beato/luigi.fagnano  (only temporary, since it is not integrated in MKS)
      6           *  $Header: FOC/Mcl.c 1.12 2015/11/25 18:36:02CET Luigi Fagnano (FAGNAL) Exp  $
      7           * @copyright Copyright 2012 - $Date: 2015/11/25 18:36:02CET $. Whirlpool Corporation. All rights reserved  CONFIDENTIAL
      8          */
      9          /*
     10           *
     11           *---------------------------------------------------------------------------------------------------------------------
     12           *---------------------------------------------------------------------------------------------------------------------
     13           */
     14          //-------------------------------------- Include Files ----------------------------------------------------------------
     15          //MCL macro-block inclusion
     16          #include "Mcl.h"
     17          #include "MclConfig.h"
     18          #include "McMathCalc_macros.h"
     19          #include "MathCalc.h"
     20          #include "Filters.h"
     21          #include "ClrkPark.h"
     22          #include "Mci_prm.h"
     23          
     24          #if (THERMAL_MODEL_EXE == ENABLED)
     25          #include "ThermalModel.h"
     26          #endif
     27          
     28          
     29          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     30          
     31          float32 My_Measured_Temp;
     32          
     33          
     34          
     35          
     36          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     37          #ifndef RPM_TO_RADS
     38              #define RPM_TO_RADS     0.10471975511965977461542144610932f
     39          #endif
     40          
     41          #ifndef STOP_RAMP_DURING_INVERSION
     42              #define STOP_RAMP_DURING_INVERSION  DISABLED
     43          #endif
     44          
     45          #define INV_3           (float32)(1.0f/3.0f)
     46          #define INV_10          (float32)(1.0f/10.0f)
     47          #define TWO_PI			(float32)(6.283185307179586476925286766559f)
     48          
     49          typedef enum
     50          {
     51              STOP_COAST_DOWN_REQUESTED = 0,                  //!< 0 - Stop by coasting down requested
     52              STOP_REQUESTED,                                 //!< 1 - Stop with braking is requested
     53              STOP_LOWERS_ON_REQUESTED,                       //!< 2 - Stop with lowers on is requested
     54              RUNNING_MIN_SPEED_STOP_REACHED,                 //!< 3 - Stop requested and minimum speed was reached
     55          
     56              MANUAL_DC_VOLT_INJECTION,                       //!< 4 - inject DC voltage manually
     57              MANUAL_AC_VOLT_INJECTION,                       //!< 5 - inject AC voltage manually
     58              MANUAL_DC_CURRENT_INJECTION,                    //!< 6 - inject DC current manually
     59              MANUAL_AC_CURRENT_INJECTION,                    //!< 7 - inject AC current manually
     60          } MCL_FLOW_MANAGER_TYPE;
     61          
     62          
     63          
     64          typedef enum
     65          {
     66              MCL_STARTING_NOT_DEFINED = 0,
     67              MCL_RESISTANCE_ESTIMATION,
     68              MCL_BUILD_MOTOR_FLUX,
     69              MCL_STARTING_FINISHED
     70          } MCL_STARTING_STATE_TYPE;
     71          
     72          
     73          #ifndef MAX_U16
     74              #define MAX_U16     65535
     75          #endif
     76          
     77          #ifndef MAX_UINT32
     78              #define MAX_UINT32                     (uint32)((1ULL<<32)-1)
     79          #endif
     80          
     81          //MCL_PARAMS_TYPE Mcl_Params; //!< MCL parameters
     82          MCL_CS_TYPE Mcl_Cs;         //!< MCL control specific variables
     83          
     84          //Input Output Structures declarations ------ begin
     85          MCL_IO_TYPE Mcl_IO; //!< MCL IO
     86          
     87          //Input Processing IO
     88          MCL_INPUT_PROC_IO_F_TYPE Mcl_Input_Proc_IO;
     89          
     90          //Observer IO
     91          MCL_OBSERVER_IO_F_TYPE Mcl_Observer_IO;
     92          
     93          //Speed Controller IO
     94          MCL_SPEED_CTRL_IO_F_TYPE Mcl_Speed_Ctrl_IO;
     95          
     96          //DQ Reference Generator Controller IO
     97          MCL_DQ_REF_IO_F_TYPE Mcl_DQ_Ref_IO;
     98          
     99          //DQ Controllers IO
    100          MCL_DQ_CTRL_IO_F_TYPE Mcl_DQ_Ctrl_IO;
    101          
    102          //Pwm IO
    103          MCL_PWM_IO_F_TYPE Mcl_Pwm_IO;
    104          ////Input Output Structures declarations ------ end
    105          
    106          MCL_PARAMS_DISPL1_TYPE*  Mcl_Params_Displ1;                         //!< MCL parameters displacement 1
    107          MCL_PARAMS_DISPL3_TYPE*  Mcl_Params_Displ3;                         //!< MCL parameters displacement 3
    108          MCL_PARAMS_DISPL4_TYPE*  Mcl_Params_Displ4;                         //!< MCL parameters displacement 4
    109          MCL_PARAMS_DISPL9_TYPE*  Mcl_Params_Displ9;                         //!< MCL parameters displacement 9
    110          MCL_PARAMS_DISPL10_TYPE* Mcl_Params_Displ10;                        //!< MCL parameters displacement 10
    111          MCL_PARAMS_DISPL11_TYPE* Mcl_Params_Displ11;                        //!< MCL parameters displacement 11
    112          
    113          
    114          /* additional structures of parameters */
    115          MCLOBSERVER_JOINT_PARAMS_TYPE   MclObserver_Params;
    116          MCLSPEEDCTRL_JOINT_PARAMS_TYPE  MclSpeedCtrl_Params;
    117          MCLDQREF_JOINT_PARAMS_TYPE      MclDqRef_Params;
    118          MCLPWM_JOINT_PARAMS_TYPE        MclPwm_Params;
    119          
    120          MCL_QUANTITIES_TYPE Mcl_Quantities;                 //!< MCL quantities
    121          
    122          RES_EST_IO_TYPE Res_Est_IO;
    123          
    124          MCL_STARTING_STATE_TYPE Mcl_Starting_State;
    125          
    126          MCL_FLOW_MANAGER_TYPE Mcl_Flow_Manager;
    127          
    128          float32 Manual_Inject_Level;                         //!< [A or V] Q17.15 - define the level used in the manual injection
    129          float32 Manual_Inject_Param;                         //!< [rad or Hz] Q17.15 - define the position of frequency of a given method
    130          float32 Manual_Pos_Reference;                        //!< [rad] Q17.15 - angle to calculate direct/inverse transformation
    131          
    132          float32 I1_Rms_Sum;
    133          float32 I2_Rms_Sum;
    134          float32 I3_Rms_Sum;
    135          float32 Mean_Speed_Sum;
    136          uint16 N_Samples;
    137          float32 N_Samples_inv;
    138          

   \                                 In section .bss, align 4
    139          float32 Previous_Target_Speed;
   \                     Previous_Target_Speed:
   \   00000000                      DS8 4
    140          
    141          uint16 Over_Torque_Time_Counter;                    //!< [5ms ticks] time when the torque is too high
    142          //! MCL_FLOW_MANAGER_TYPE controls the algorithm flow
    143          #define MCL_SET_FLOW_MANAGER(mcl_flowcontrol)   BIT_SET(Mcl_Flow_Manager, (mcl_flowcontrol))
    144          #define MCL_CLR_FLOW_MANAGER(mcl_flowcontrol)   BIT_CLR(Mcl_Flow_Manager, (mcl_flowcontrol))
    145          
    146          //! Define multiples test cases in one shot because the compiler is optimizing and ignoring the BIT_TEST macro
    147          #define MANUAL_VOLTAGE_INJECTION_FLAGS  (((MCL_FLOW_MANAGER_TYPE)1<<(MANUAL_DC_VOLT_INJECTION)) + ((MCL_FLOW_MANAGER_TYPE)1<<(MANUAL_AC_VOLT_INJECTION)))
    148          #define MANUAL_CURRENT_INJECTION_FLAGS  (((MCL_FLOW_MANAGER_TYPE)1<<(MANUAL_DC_CURRENT_INJECTION)) + (((MCL_FLOW_MANAGER_TYPE)1<<(MANUAL_AC_CURRENT_INJECTION))))
    149          
    150          
    151          //! Define the flags used to declare running finished.
    152          #define RUNNING_FINISHED_FLOW_FLAGS     ((MCL_FLOW_MANAGER_TYPE)1<<STOP_LOWERS_ON_REQUESTED)  +   \
    153                                                  ((MCL_FLOW_MANAGER_TYPE)1<<STOP_COAST_DOWN_REQUESTED) +   \
    154                                                  ((MCL_FLOW_MANAGER_TYPE)1<<STOP_REQUESTED)
    155          
    156          
    157          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
    158          void ResetQuantities(void);
    159          
    160          
    161          static BOOL_TYPE Estimate_Stator_Resistance(void);
    162          static void Running_Parallel_5msHandler(void);
    163          static BOOL_TYPE Manual_Injection_Control(void);
    164          static void Calc_MeanSpeed_CurrentRMS(void);
    165          static float32 Calc_Temperature_By_Resistance(void);
    166          static float32 Calc_Resistance_By_Temperature(void);
    167          #if (MCL__ELECTRICAL_POWER == ENABLED)
    168          static void Calc_ElectricalPower(void);
    169          #endif
    170          static void Calc_TorqueForApplication(void);
    171          static void TimeHandler(void);
    172          static void Flags_Management(void);
    173          
    174          //=====================================================================================================================
    175          //-------------------------------------- Public Functions -------------------------------------------------------------
    176          //=====================================================================================================================
    177          
    178          
    179          //---------------------------------------------------------------------------------------------------------------------
    180          /**
    181           *  @brief      Motor Control Loop initialization.
    182           *  @details    In this routine are called all initialization functions.
    183           *
    184           *
    185           *  @param[in]     
    186           *  @param[out]     
    187           *  @param[in]      
    188           *  @return        
    189           */

   \                                 In section .text, align 2, keep-with-next
    190          void Mcl__Initialize(void)
    191          {
   \                     Mcl__Initialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    192              Mcl_Cs.flags.all                        = 0;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable45
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF8C4 0x00E4      STR      R0,[R4, #+228]
    193              Mcl_Cs.All_Devices_Off                  = &Mcl_IO.All_Devices_Off;
    194              Mcl_Cs.Lowers_On                        = &Mcl_IO.Lowers_On;
    195              Mcl_Cs.Speed_Rot_Ref_Abs                = &Mcl_Quantities.Speed_Rot_Ref_Abs;
    196              Mcl_Cs.Speed_Rotor_Observed             = &Mcl_Quantities.Speed_Rot;
    197              Mcl_Cs.Speed_Rotor_Observed_Mech        = &Mcl_Quantities.Speed_Rot_Mech;
    198              Mcl_Cs.Speed_Rotor_Observed_Mech_Abs    = &Mcl_Quantities.Speed_Rot_Mech_Abs;
    199              Mcl_Cs.Elapsed_Time_After_Starting      = &Mcl_Quantities.Elapsed_Time_After_Starting;
    200              Mcl_Cs.Id_stator_current                = &Mcl_Quantities.Id_stator_current;
    201              Mcl_Cs.Iq_stator_current                = &Mcl_Quantities.Iq_stator_current;
    202              Mcl_Cs.Id_Rotor_Current                 = &Mcl_Quantities.Id_rotor_current;
    203              Mcl_Cs.Torque                           = &Mcl_Quantities.Torque;
    204              Mcl_Cs.Stator_Resistance                = &Mcl_Quantities.Stator_Resistance;
    205              Mcl_Cs.Vs_Flux                          = &Mcl_Quantities.Vs_Flux;
    206              Mcl_Cs.Flux_Ref                         = &Mcl_Quantities.Flux_Ref;
    207              Mcl_Cs.Flux_Limit_By_Speed              = &Mcl_Quantities.Flux_Limit_By_Speed;
    208              Mcl_Cs.Stator_Flux_Mag                  = &Mcl_Quantities.Stator_Flux_Mag;
    209              Mcl_Cs.Load_Angle_Sin_Cos               = &Mcl_Quantities.Load_Angle_Sin_Cos;
    210              Mcl_Cs.Ldq_Ind                          = &Mcl_Quantities.Ldq_Ind;
    211              Mcl_Cs.Ldq_Cross_Ind                    = &Mcl_Quantities.Ldq_Cross_Ind;
    212              Mcl_Cs.Lqd_Cross_Ind                    = &Mcl_Quantities.Lqd_Cross_Ind;
    213              Mcl_Cs.Is_Abs                           = &Mcl_Quantities.Is_Abs;
    214              Mcl_Cs.DcInjection_Angle                = &Mcl_Quantities.DcInjection_Angle;
    215              Mcl_Cs.Rotor_Flux                       = &Mcl_Quantities.Rotor_Flux;
    216          
    217          
    218              //////////////////////////////////////////////////////////////
    219          	//----------- Input Processing Interface Set ------------------
    220          	Mcl_Input_Proc_IO.Is_ABC                = &Mcl_IO.Is_ABC;
    221          	Mcl_Input_Proc_IO.Vdc                   = &Mcl_IO.Vdc;
    222          	Mcl_Input_Proc_IO.Duty                  = &Mcl_IO.Duty_bc;
    223          	Mcl_Input_Proc_IO.Is_Alpha_Beta         = &Mcl_Quantities.Is_Alpha_Beta;
   \   0000000C   0xF8C4 0x4250      STR      R4,[R4, #+592]
   \   00000010   0xF204 0x108D      ADDW     R0,R4,#+397
   \   00000014   0xF8C4 0x0140      STR      R0,[R4, #+320]
    224          	Mcl_Input_Proc_IO.Vs_Max_Filt           = &Mcl_Quantities.Vs_Max_Filt;
    225          	Mcl_Input_Proc_IO.Vs_Alpha_Beta_Rec     = &Mcl_Quantities.Vs_Alpha_Beta_Rec;
    226          	Mcl_Input_Proc_IO.Vabc_Rec              = &Mcl_Quantities.Vabc_Rec;
    227          
    228          	Mcl_Input_Proc_IO.Ctrl_Specific         = &Mcl_Cs;
    229          	//-----------------------------------------------------------
    230          
    231          
    232          
    233          
    234          	//////////////////////////////////////////////////////////////
    235          	//------------------ Observer Interface Set -----------------
    236              Mcl_Observer_IO.Is_Alpha_Beta           = &Mcl_Quantities.Is_Alpha_Beta;
   \   00000018   0xF8C4 0x41FC      STR      R4,[R4, #+508]
   \   0000001C   0xF504 0x70C6      ADD      R0,R4,#+396
   \   00000020   0xF8C4 0x013C      STR      R0,[R4, #+316]
   \   00000024   0xF104 0x006C      ADD      R0,R4,#+108
   \   00000028   0xF8C4 0x00E8      STR      R0,[R4, #+232]
   \   0000002C   0xF104 0x0070      ADD      R0,R4,#+112
   \   00000030   0xF8C4 0x00EC      STR      R0,[R4, #+236]
   \   00000034   0xF104 0x0078      ADD      R0,R4,#+120
   \   00000038   0xF8C4 0x00F0      STR      R0,[R4, #+240]
   \   0000003C   0xF104 0x0074      ADD      R0,R4,#+116
   \   00000040   0xF8C4 0x00F4      STR      R0,[R4, #+244]
   \   00000044   0xF104 0x00B8      ADD      R0,R4,#+184
   \   00000048   0xF8C4 0x00F8      STR      R0,[R4, #+248]
   \   0000004C   0xF104 0x00A0      ADD      R0,R4,#+160
   \   00000050   0xF8C4 0x0100      STR      R0,[R4, #+256]
   \   00000054   0xF104 0x00A4      ADD      R0,R4,#+164
   \   00000058   0xF8C4 0x0104      STR      R0,[R4, #+260]
   \   0000005C   0xF104 0x009C      ADD      R0,R4,#+156
   \   00000060   0xF8C4 0x0108      STR      R0,[R4, #+264]
   \   00000064   0xF104 0x00AC      ADD      R0,R4,#+172
   \   00000068   0xF8C4 0x010C      STR      R0,[R4, #+268]
   \   0000006C   0xF104 0x00D0      ADD      R0,R4,#+208
   \   00000070   0xF8C4 0x00FC      STR      R0,[R4, #+252]
   \   00000074   0xF104 0x00C0      ADD      R0,R4,#+192
   \   00000078   0xF8C4 0x0110      STR      R0,[R4, #+272]
   \   0000007C   0xF104 0x00B0      ADD      R0,R4,#+176
   \   00000080   0xF8C4 0x0114      STR      R0,[R4, #+276]
   \   00000084   0xF104 0x00B4      ADD      R0,R4,#+180
   \   00000088   0xF8C4 0x0118      STR      R0,[R4, #+280]
   \   0000008C   0xF104 0x0058      ADD      R0,R4,#+88
   \   00000090   0xF8C4 0x011C      STR      R0,[R4, #+284]
   \   00000094   0xF104 0x0060      ADD      R0,R4,#+96
   \   00000098   0xF8C4 0x0124      STR      R0,[R4, #+292]
   \   0000009C   0xF104 0x0044      ADD      R0,R4,#+68
   \   000000A0   0xF8C4 0x0128      STR      R0,[R4, #+296]
   \   000000A4   0xF104 0x0050      ADD      R0,R4,#+80
   \   000000A8   0xF8C4 0x012C      STR      R0,[R4, #+300]
   \   000000AC   0xF104 0x0054      ADD      R0,R4,#+84
   \   000000B0   0xF8C4 0x0130      STR      R0,[R4, #+304]
   \   000000B4   0xF104 0x0024      ADD      R0,R4,#+36
   \   000000B8   0xF8C4 0x0134      STR      R0,[R4, #+308]
   \   000000BC   0xF104 0x00D4      ADD      R0,R4,#+212
   \   000000C0   0xF8C4 0x0120      STR      R0,[R4, #+288]
   \   000000C4   0xF104 0x00E0      ADD      R0,R4,#+224
   \   000000C8   0xF8C4 0x0138      STR      R0,[R4, #+312]
   \   000000CC   0xF504 0x70A4      ADD      R0,R4,#+328
   \   000000D0   0xF8C4 0x024C      STR      R0,[R4, #+588]
   \   000000D4   0xF504 0x70A2      ADD      R0,R4,#+324
   \   000000D8   0xF8C4 0x0244      STR      R0,[R4, #+580]
   \   000000DC   0xF504 0x70C0      ADD      R0,R4,#+384
   \   000000E0   0xF8C4 0x0248      STR      R0,[R4, #+584]
   \   000000E4   0xF104 0x0028      ADD      R0,R4,#+40
   \   000000E8   0xF8C4 0x025C      STR      R0,[R4, #+604]
   \   000000EC   0xF104 0x002C      ADD      R0,R4,#+44
   \   000000F0   0xF8C4 0x0254      STR      R0,[R4, #+596]
   \   000000F4   0xF104 0x0038      ADD      R0,R4,#+56
   \   000000F8   0xF8C4 0x0258      STR      R0,[R4, #+600]
   \   000000FC   0xF104 0x00E4      ADD      R0,R4,#+228
   \   00000100   0xF8C4 0x0260      STR      R0,[R4, #+608]
    237              Mcl_Observer_IO.Vs_Alpha_Beta           = &Mcl_Quantities.Vs_Alpha_Beta_Rec;
   \   00000104   0xF104 0x002C      ADD      R0,R4,#+44
   \   00000108   0xF8C4 0x0200      STR      R0,[R4, #+512]
    238              Mcl_Observer_IO.Sin_Cos_Position_Flux   = &Mcl_Quantities.Sin_Cos_Position_Flux;
   \   0000010C   0xF104 0x0088      ADD      R0,R4,#+136
   \   00000110   0xF8C4 0x020C      STR      R0,[R4, #+524]
    239              Mcl_Observer_IO.Load_Angle              = &Mcl_Quantities.Load_Angle;
   \   00000114   0xF104 0x005C      ADD      R0,R4,#+92
   \   00000118   0xF8C4 0x0218      STR      R0,[R4, #+536]
    240              Mcl_Observer_IO.Speed_Rotor_Observed    = &Mcl_Quantities.Speed_Rot;
   \   0000011C   0xF104 0x0070      ADD      R0,R4,#+112
   \   00000120   0xF8C4 0x0210      STR      R0,[R4, #+528]
    241              Mcl_Observer_IO.Vdc                     = &Mcl_IO.Vdc;
   \   00000124   0xF504 0x70A2      ADD      R0,R4,#+324
   \   00000128   0xF8C4 0x0208      STR      R0,[R4, #+520]
    242              Mcl_Observer_IO.Rotor_Position          = &Mcl_Quantities.Rotor_Position;
   \   0000012C   0xF104 0x00C4      ADD      R0,R4,#+196
   \   00000130   0xF8C4 0x0214      STR      R0,[R4, #+532]
    243              Mcl_Observer_IO.Is_ABC                  = &Mcl_IO.Is_ABC;
   \   00000134   0xF504 0x70A4      ADD      R0,R4,#+328
   \   00000138   0xF8C4 0x0204      STR      R0,[R4, #+516]
    244          
    245              Mcl_Observer_IO.Ctrl_Specific           = &Mcl_Cs;
   \   0000013C   0xF104 0x00E4      ADD      R0,R4,#+228
   \   00000140   0xF8C4 0x021C      STR      R0,[R4, #+540]
    246          	//------------------------------------------------------------
    247          
    248          
    249          
    250          
    251          	//////////////////////////////////////////////////////////////
    252          	//------- Speed Controller Interface Set ---------------------
    253          	Mcl_Speed_Ctrl_IO.Speed_Rot_Ref         = &Mcl_IO.Speed_Rot_Ref;
   \   00000144   0xF504 0x70AA      ADD      R0,R4,#+340
   \   00000148   0xF8C4 0x0308      STR      R0,[R4, #+776]
    254          	Mcl_Speed_Ctrl_IO.Speed_Rot             = &Mcl_Quantities.Speed_Rot_Mech;
   \   0000014C   0xF104 0x0078      ADD      R0,R4,#+120
   \   00000150   0xF8C4 0x030C      STR      R0,[R4, #+780]
    255          	Mcl_Speed_Ctrl_IO.Torque_Ref            = &Mcl_Quantities.Torque_Ref;
   \   00000154   0xF104 0x0090      ADD      R0,R4,#+144
   \   00000158   0xF8C4 0x0310      STR      R0,[R4, #+784]
    256          
    257          	Mcl_Speed_Ctrl_IO.Ctrl_Specific         = &Mcl_Cs;
   \   0000015C   0xF104 0x00E4      ADD      R0,R4,#+228
   \   00000160   0xF8C4 0x0314      STR      R0,[R4, #+788]
    258          	//------------------------------------------------------------
    259          
    260          
    261          
    262          
    263          	//////////////////////////////////////////////////////////////
    264          	//-------- DQ Reference Generator Interface set --------------
    265          
    266          	Mcl_DQ_Ref_IO.Torque_Ref    = &Mcl_Quantities.Torque_Ref;
   \   00000164   0xF104 0x0090      ADD      R0,R4,#+144
   \   00000168   0xF8C4 0x0264      STR      R0,[R4, #+612]
    267              Mcl_DQ_Ref_IO.Force_D_Ref   = &Mcl_Quantities.Force_Stator_Flux_Ref;
   \   0000016C   0xF104 0x00BC      ADD      R0,R4,#+188
   \   00000170   0xF8C4 0x026C      STR      R0,[R4, #+620]
    268              Mcl_DQ_Ref_IO.Force_Q_Ref   = &Mcl_Quantities.Force_Torque_Ref;
   \   00000174   0xF104 0x0094      ADD      R0,R4,#+148
   \   00000178   0xF8C4 0x0268      STR      R0,[R4, #+616]
    269              Mcl_DQ_Ref_IO.Vdc           = &Mcl_IO.Vdc;
   \   0000017C   0xF504 0x70A2      ADD      R0,R4,#+324
   \   00000180   0xF8C4 0x0270      STR      R0,[R4, #+624]
    270          	Mcl_DQ_Ref_IO.Q_Ref         = &Mcl_Quantities.Q_Torque_Ref;
   \   00000184   0xF104 0x0098      ADD      R0,R4,#+152
   \   00000188   0xF8C4 0x0274      STR      R0,[R4, #+628]
    271          	Mcl_DQ_Ref_IO.D_Ref         = &Mcl_Quantities.Flux_Ref;
   \   0000018C   0xF104 0x00B0      ADD      R0,R4,#+176
   \   00000190   0xF8C4 0x0278      STR      R0,[R4, #+632]
    272          
    273          	Mcl_DQ_Ref_IO.Ctrl_Specific = &Mcl_Cs;
   \   00000194   0xF104 0x00E4      ADD      R0,R4,#+228
   \   00000198   0xF8C4 0x027C      STR      R0,[R4, #+636]
    274          	//------------------------------------------------------------
    275          
    276          
    277          
    278          
    279              //////////////////////////////////////////////////////////////
    280              //----------------- DQ controllers Interface set  ------------
    281              Mcl_DQ_Ctrl_IO.Q_Ref            = &Mcl_Quantities.Q_Torque_Ref;
   \   0000019C   0xF104 0x0098      ADD      R0,R4,#+152
   \   000001A0   0xF8C4 0x01D8      STR      R0,[R4, #+472]
    282              Mcl_DQ_Ctrl_IO.Q_Est            = &Mcl_Quantities.Torque;
   \   000001A4   0xF104 0x00AC      ADD      R0,R4,#+172
   \   000001A8   0xF8C4 0x01DC      STR      R0,[R4, #+476]
    283              Mcl_DQ_Ctrl_IO.Vdc              = &Mcl_IO.Vdc;
   \   000001AC   0xF504 0x70A2      ADD      R0,R4,#+324
   \   000001B0   0xF8C4 0x01EC      STR      R0,[R4, #+492]
    284              Mcl_DQ_Ctrl_IO.D_Ref            = &Mcl_Quantities.Flux_Ref;
   \   000001B4   0xF104 0x00B0      ADD      R0,R4,#+176
   \   000001B8   0xF8C4 0x01D0      STR      R0,[R4, #+464]
    285              Mcl_DQ_Ctrl_IO.D_Est            = &Mcl_Quantities.Stator_Flux_Mag;
   \   000001BC   0xF104 0x0058      ADD      R0,R4,#+88
   \   000001C0   0xF8C4 0x01D4      STR      R0,[R4, #+468]
    286              Mcl_DQ_Ctrl_IO.Vs_DQ            = &Mcl_Quantities.Vs_DQ;
   \   000001C4   0xF104 0x0018      ADD      R0,R4,#+24
   \   000001C8   0xF8C4 0x01F0      STR      R0,[R4, #+496]
    287              Mcl_DQ_Ctrl_IO.Vs_Alpha_Beta    = &Mcl_Quantities.Vs_Alpha_Beta;
   \   000001CC   0xF104 0x000C      ADD      R0,R4,#+12
   \   000001D0   0xF8C4 0x01F4      STR      R0,[R4, #+500]
    288              Mcl_DQ_Ctrl_IO.Sin_Cos          = &Mcl_Quantities.Sin_Cos_Position_Flux;
   \   000001D4   0xF104 0x0088      ADD      R0,R4,#+136
   \   000001D8   0xF8C4 0x01E0      STR      R0,[R4, #+480]
    289              Mcl_DQ_Ctrl_IO.Force_Out_Volt   = &Mcl_Quantities.Force_Out_Volt;
   \   000001DC   0xF104 0x007C      ADD      R0,R4,#+124
   \   000001E0   0xF8C4 0x01E4      STR      R0,[R4, #+484]
    290          
    291              Mcl_DQ_Ctrl_IO.Ctrl_Specific    = &Mcl_Cs;
   \   000001E4   0xF104 0x00E4      ADD      R0,R4,#+228
   \   000001E8   0xF8C4 0x01F8      STR      R0,[R4, #+504]
    292              //------------------------------------------------------------
    293          
    294          
    295          
    296          
    297              //////////////////////////////////////////////////////////////
    298              //-------- Pwm Interface Set -----------------------
    299              Mcl_Pwm_IO.Vs_Alpha_Beta        = &Mcl_Quantities.Vs_Alpha_Beta;
   \   000001EC   0xF104 0x000C      ADD      R0,R4,#+12
   \   000001F0   0xF8C4 0x02F4      STR      R0,[R4, #+756]
    300              Mcl_Pwm_IO.Duty                 = &Mcl_IO.Duty;
   \   000001F4   0xF504 0x70BA      ADD      R0,R4,#+372
   \   000001F8   0xF8C4 0x0300      STR      R0,[R4, #+768]
    301              Mcl_Pwm_IO.Duty_bc              = &Mcl_IO.Duty_bc;
   \   000001FC   0xF504 0x70C0      ADD      R0,R4,#+384
   \   00000200   0xF8C4 0x02FC      STR      R0,[R4, #+764]
    302              Mcl_Pwm_IO.Vdc                  = &Mcl_IO.Vdc;
   \   00000204   0xF504 0x70A2      ADD      R0,R4,#+324
   \   00000208   0xF8C4 0x02F0      STR      R0,[R4, #+752]
    303              Mcl_Pwm_IO.Is_ABC               = &Mcl_IO.Is_ABC;
   \   0000020C   0xF504 0x70A4      ADD      R0,R4,#+328
   \   00000210   0xF8C4 0x02F8      STR      R0,[R4, #+760]
    304          
    305          
    306              Mcl_Pwm_IO.Ctrl_Specific        = &Mcl_Cs;
   \   00000214   0xF104 0x00E4      ADD      R0,R4,#+228
   \   00000218   0xF8C4 0x0304      STR      R0,[R4, #+772]
    307              //------------------------------------------------------------
    308          
    309          
    310          
    311          
    312              //////////////////////////////////////////////////////////////
    313              //-------- Estimation Parameters Interface Set -----------------------
    314              Res_Est_IO.Ctrl_Specific        = &Mcl_Cs;
   \   0000021C   0xF8C4 0x0350      STR      R0,[R4, #+848]
    315              //------------------------------------------------------------
    316          
    317          
    318          
    319          	// Initialize and reset some variables
    320          	Braking__ResetState();
   \   00000220   0x2000             MOVS     R0,#+0
   \   00000222   0xF8C4 0x042C      STR      R0,[R4, #+1068]
   \   00000226   0x.... 0x....      LDR.W    R0,??DataTable46  ;; 0x3dcccccd
   \   0000022A   0xF8C4 0x043C      STR      R0,[R4, #+1084]
    321          	Braking__Initialize();
   \   0000022E   0x.... 0x....      LDR.W    R0,??DataTable46_1  ;; 0x400ccccd
   \   00000232   0xF8C4 0x0440      STR      R0,[R4, #+1088]
   \   00000236   0x.... 0x....      LDR.W    R0,??DataTable46_3  ;; 0x3e4ccccd
   \   0000023A   0xF8C4 0x0444      STR      R0,[R4, #+1092]
   \   0000023E   0x2000             MOVS     R0,#+0
   \   00000240   0xF8C4 0x0448      STR      R0,[R4, #+1096]
    322          	Mcl_Cs.flags.bit.braking_active = 0;
   \   00000244   0xF8C4 0x00E4      STR      R0,[R4, #+228]
    323          	Mcl__RunningReset();
   \   00000248   0x.... 0x....      BL       Mcl__RunningReset
    324          	Mcl__StoppingReset();
   \   0000024C   0xF894 0x00E4      LDRB     R0,[R4, #+228]
   \   00000250   0x07C0             LSLS     R0,R0,#+31
   \   00000252   0xD509             BPL.N    ??Mcl__Initialize_0
   \   00000254   0xF504 0x7046      ADD      R0,R4,#+792
   \   00000258   0x.... 0x....      BL       MclSpeedCtrl__ResetState
   \   0000025C   0xF504 0x71CE      ADD      R1,R4,#+412
   \   00000260   0xF504 0x70FE      ADD      R0,R4,#+508
   \   00000264   0x.... 0x....      BL       MclObserver__ResetState
    325          
    326          	Mcl_Flow_Manager = (MCL_FLOW_MANAGER_TYPE)0;
   \                     ??Mcl__Initialize_0: (+1)
   \   00000268   0x2000             MOVS     R0,#+0
   \   0000026A   0xF884 0x0358      STRB     R0,[R4, #+856]
    327          
    328          #if (THERMAL_MODEL_EXE == ENABLED)
    329          	ThermalModel__Initialize();
   \   0000026E   0x.... 0x....      BL       ThermalModel__Initialize
    330          #endif
    331          
    332          	My_Measured_Temp = 30.0f;
   \   00000272   0x.... 0x....      LDR.W    R0,??DataTable46_6  ;; 0x41f00000
   \   00000276   0xF8C4 0x03F0      STR      R0,[R4, #+1008]
    333          }
   \   0000027A   0xBD10             POP      {R4,PC}          ;; return
    334          
    335          

   \                                 In section .text, align 4, keep-with-next
    336          void Mcl__ParamsInitialize(void)
    337          {
   \                     Mcl__ParamsInitialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    338          
    339              if(Mcl_Cs.flags.bit.params_ready == 1)
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable45
   \   00000006   0xF8D4 0x00E4      LDR      R0,[R4, #+228]
   \   0000000A   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xF000 0x80E9      BEQ.W    ??Mcl__ParamsInitialize_0
    340              {
    341          
    342                  /* Prepare structures of joint parameters */
    343                  MclObserver_Params.ObsPrm               = &Mcl_Params_Displ1->ObserverPrm;
   \   00000014   0xF8D4 0x03F4      LDR      R0,[R4, #+1012]
   \   00000018   0x1D01             ADDS     R1,R0,#+4
   \   0000001A   0xF8C4 0x119C      STR      R1,[R4, #+412]
    344                  MclObserver_Params.Ld_lut.ptr_LUT       = Mcl_Params_Displ3->Ld_Lut;
   \   0000001E   0xF8D4 0x13F8      LDR      R1,[R4, #+1016]
    345                  MclObserver_Params.Ld_lut.sizeof_lut    = &Mcl_Params_Displ3->sizeof_Ld_Lq_Lut;
   \   00000022   0xF8C4 0x11A8      STR      R1,[R4, #+424]
   \   00000026   0xF101 0x0208      ADD      R2,R1,#+8
   \   0000002A   0xF8C4 0x21A0      STR      R2,[R4, #+416]
    346                  MclObserver_Params.Ld_lut.step_inv      = &Mcl_Params_Displ3->step_inv_L_Lut;
    347          
    348                  MclObserver_Params.Lq_lut.ptr_LUT       = Mcl_Params_Displ3->Lq_Lut;
    349                  MclObserver_Params.Lq_lut.sizeof_lut    = &Mcl_Params_Displ3->sizeof_Ld_Lq_Lut;
   \   0000002E   0xF8C4 0x11B4      STR      R1,[R4, #+436]
   \   00000032   0x1D0A             ADDS     R2,R1,#+4
   \   00000034   0xF8C4 0x21A4      STR      R2,[R4, #+420]
    350                  MclObserver_Params.Lq_lut.step_inv      = &Mcl_Params_Displ3->step_inv_L_Lut;
    351          
    352                  MclObserver_Params.Ldq_lut.ptr_LUT      = Mcl_Params_Displ3->Ldq_Lut;
    353                  MclObserver_Params.Ldq_lut.sizeof_lut   = &Mcl_Params_Displ3->sizeof_Ld_Lq_Lut;
   \   00000038   0xF8C4 0x11C0      STR      R1,[R4, #+448]
   \   0000003C   0xF101 0x0248      ADD      R2,R1,#+72
   \   00000040   0xF8C4 0x21AC      STR      R2,[R4, #+428]
   \   00000044   0x1D0A             ADDS     R2,R1,#+4
   \   00000046   0xF8C4 0x21B0      STR      R2,[R4, #+432]
   \   0000004A   0xF101 0x0288      ADD      R2,R1,#+136
    354                  MclObserver_Params.Ldq_lut.step_inv     = &Mcl_Params_Displ3->step_inv_L_Lut;
   \   0000004E   0x1D09             ADDS     R1,R1,#+4
   \   00000050   0xF8C4 0x11BC      STR      R1,[R4, #+444]
   \   00000054   0xF8C4 0x21B8      STR      R2,[R4, #+440]
    355          
    356                  if (Mcl_Params_Displ11 != NULL)
   \   00000058   0xF8D4 0x1408      LDR      R1,[R4, #+1032]
   \   0000005C   0xB149             CBZ.N    R1,??Mcl__ParamsInitialize_1
    357                  {
    358                      MclObserver_Params.Rotor_Flux_lut.ptr_LUT    = Mcl_Params_Displ11->Flux_Lut;
    359                      MclObserver_Params.Rotor_Flux_lut.sizeof_lut = &Mcl_Params_Displ11->sizeof_Flux_Lut;
   \   0000005E   0xF8C4 0x11CC      STR      R1,[R4, #+460]
   \   00000062   0xF101 0x0208      ADD      R2,R1,#+8
    360                      MclObserver_Params.Rotor_Flux_lut.step_inv   = &Mcl_Params_Displ11->step_inv_Flux_Lut;
   \   00000066   0x1D09             ADDS     R1,R1,#+4
   \   00000068   0xF8C4 0x21C4      STR      R2,[R4, #+452]
   \   0000006C   0xF8C4 0x11C8      STR      R1,[R4, #+456]
   \   00000070   0xE001             B.N      ??Mcl__ParamsInitialize_2
    361                  }
    362                  else
    363                  {
    364                      MclObserver_Params.Rotor_Flux_lut.ptr_LUT = NULL; // the rotor flux lut is disabled
   \                     ??Mcl__ParamsInitialize_1: (+1)
   \   00000072   0xF8C4 0x11C4      STR      R1,[R4, #+452]
    365                  }
    366          
    367                  MclSpeedCtrl_Params.SpeedCtrlPrm        = &Mcl_Params_Displ4->SpeedCtrlPrm;
   \                     ??Mcl__ParamsInitialize_2: (+1)
   \   00000076   0xF8D4 0x13FC      LDR      R1,[R4, #+1020]
   \   0000007A   0xF8C4 0x1318      STR      R1,[R4, #+792]
    368                  MclSpeedCtrl_Params.MTPVPrm.ptr_LUT     = Mcl_Params_Displ10->Tq_Limit_Lut;
   \   0000007E   0xF8D4 0x1404      LDR      R1,[R4, #+1028]
    369                  MclSpeedCtrl_Params.MTPVPrm.sizeof_lut  = &Mcl_Params_Displ10->sizeof_mtpv;
   \   00000082   0xF8C4 0x1324      STR      R1,[R4, #+804]
   \   00000086   0xF101 0x0208      ADD      R2,R1,#+8
    370                  MclSpeedCtrl_Params.MTPVPrm.step_inv    = &Mcl_Params_Displ10->step_inv_mtpv;
   \   0000008A   0x1D09             ADDS     R1,R1,#+4
   \   0000008C   0xF8C4 0x1320      STR      R1,[R4, #+800]
   \   00000090   0xF8C4 0x231C      STR      R2,[R4, #+796]
    371          
    372                  MclDqRef_Params.DqRefPrm                = &Mcl_Params_Displ1->DQRefPrm;
   \   00000094   0xF100 0x019C      ADD      R1,R0,#+156
   \   00000098   0xF8C4 0x1328      STR      R1,[R4, #+808]
    373                  MclDqRef_Params.MTPAPrm.ptr_LUT         = Mcl_Params_Displ9->Mtpa_Lut;
   \   0000009C   0xF8D4 0x1400      LDR      R1,[R4, #+1024]
    374                  MclDqRef_Params.MTPAPrm.sizeof_lut      = &Mcl_Params_Displ9->sizeof_mtpa_lut;
   \   000000A0   0xF8C4 0x1334      STR      R1,[R4, #+820]
   \   000000A4   0xF101 0x0208      ADD      R2,R1,#+8
    375                  MclDqRef_Params.MTPAPrm.step_inv        = &Mcl_Params_Displ9->step_inv_mtpa;
   \   000000A8   0x1D09             ADDS     R1,R1,#+4
   \   000000AA   0xF8C4 0x1330      STR      R1,[R4, #+816]
   \   000000AE   0xF8C4 0x232C      STR      R2,[R4, #+812]
    376          
    377                  MclPwm_Params.PwmPrm                    = &Mcl_Params_Displ1->PwmPrm;
   \   000000B2   0xF500 0x71D8      ADD      R1,R0,#+432
   \   000000B6   0xF8C4 0x1338      STR      R1,[R4, #+824]
    378          
    379                  Mcl_Quantities.Stator_Resistance        = Mcl_Params_Displ1->ObserverPrm.Stator_Resistance;
   \   000000BA   0x6841             LDR      R1,[R0, #+4]
   \   000000BC   0xF8C4 0x10D0      STR      R1,[R4, #+208]
    380          
    381                  // Init DC Injection Angle
    382                  Mcl_Quantities.DcInjection_Angle = 0.0f;
    383          
    384          
    385                  ResistanceEstimation__Initialize(&Mcl_Params_Displ1->Res_Est_Param);
   \   000000C0   0x30E4             ADDS     R0,R0,#+228
   \   000000C2   0x2100             MOVS     R1,#+0
   \   000000C4   0xF8C4 0x10D4      STR      R1,[R4, #+212]
   \   000000C8   0x.... 0x....      BL       ResistanceEstimation__Initialize
    386                  SpeedRefGen__SetSpeedParams(Mcl_Params_Displ1->Mcl_SpeedRef_Params.SpeedRef_Default_Accel);
   \   000000CC   0xEDDF 0x....      VLDR.W   S1,??DataTable30  ;; 0x3903126f
   \   000000D0   0xF8D4 0x03F4      LDR      R0,[R4, #+1012]
   \   000000D4   0xED90 0x0A54      VLDR     S0,[R0, #+336]
   \   000000D8   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000000DC   0xEDDF 0x....      VLDR.W   S1,??DataTable30_1  ;; 0x3dd67750
   \   000000E0   0xF204 0x40D0      ADDW     R0,R4,#+1232
   \   000000E4   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000000E8   0xED80 0x0A00      VSTR     S0,[R0, #0]
    387          
    388                  //Input Processing Initialization
    389                  MclInputProc__Initialize();
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0xF8C4 0x0464      STR      R0,[R4, #+1124]
    390          
    391                  //Observer Initialization
    392                  MclObserver__Initialize(&Mcl_Observer_IO, &MclObserver_Params);
   \   000000F2   0xF504 0x71CE      ADD      R1,R4,#+412
   \   000000F6   0xF504 0x70FE      ADD      R0,R4,#+508
   \   000000FA   0x.... 0x....      BL       MclObserver__Initialize
    393          
    394                  //Speed Controller Initialization
    395                  MclSpeedCtrl__Initialize(&MclSpeedCtrl_Params);
   \   000000FE   0xF8D4 0x0318      LDR      R0,[R4, #+792]
   \   00000102   0x6940             LDR      R0,[R0, #+20]
   \   00000104   0xF8C4 0x02E0      STR      R0,[R4, #+736]
   \   00000108   0xEEB7 0x0A00      VMOV.F32 S0,#1.0
   \   0000010C   0xF8D4 0x0318      LDR      R0,[R4, #+792]
   \   00000110   0x6980             LDR      R0,[R0, #+24]
   \   00000112   0xF8C4 0x02E4      STR      R0,[R4, #+740]
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0xF8C4 0x02EC      STR      R0,[R4, #+748]
   \   0000011C   0xF8D4 0x0318      LDR      R0,[R4, #+792]
   \   00000120   0x69C0             LDR      R0,[R0, #+28]
   \   00000122   0xF8C4 0x02C4      STR      R0,[R4, #+708]
   \   00000126   0xF8D4 0x0318      LDR      R0,[R4, #+792]
   \   0000012A   0x6A00             LDR      R0,[R0, #+32]
   \   0000012C   0xF8C4 0x02C8      STR      R0,[R4, #+712]
   \   00000130   0x2000             MOVS     R0,#+0
   \   00000132   0xF8C4 0x02C0      STR      R0,[R4, #+704]
   \   00000136   0xF8C4 0x02BC      STR      R0,[R4, #+700]
   \   0000013A   0xF8D4 0x0318      LDR      R0,[R4, #+792]
   \   0000013E   0x6840             LDR      R0,[R0, #+4]
   \   00000140   0xF8C4 0x02E8      STR      R0,[R4, #+744]
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0xF8C4 0x02DC      STR      R0,[R4, #+732]
   \   0000014A   0xF8D4 0x02E8      LDR      R0,[R4, #+744]
   \   0000014E   0xF8C4 0x02D8      STR      R0,[R4, #+728]
   \   00000152   0x2000             MOVS     R0,#+0
   \   00000154   0xF8C4 0x0480      STR      R0,[R4, #+1152]
   \   00000158   0xF8D4 0x0318      LDR      R0,[R4, #+792]
   \   0000015C   0x6840             LDR      R0,[R0, #+4]
   \   0000015E   0xF8C4 0x0488      STR      R0,[R4, #+1160]
   \   00000162   0xF8D4 0x0318      LDR      R0,[R4, #+792]
   \   00000166   0x6840             LDR      R0,[R0, #+4]
   \   00000168   0xF8C4 0x048C      STR      R0,[R4, #+1164]
   \   0000016C   0xF8D4 0x0318      LDR      R0,[R4, #+792]
   \   00000170   0x6800             LDR      R0,[R0, #+0]
   \   00000172   0xF8C4 0x0484      STR      R0,[R4, #+1156]
   \   00000176   0x2000             MOVS     R0,#+0
   \   00000178   0xF884 0x035F      STRB     R0,[R4, #+863]
   \   0000017C   0xF8A4 0x0384      STRH     R0,[R4, #+900]
   \   00000180   0xF204 0x4090      ADDW     R0,R4,#+1168
   \   00000184   0xED80 0x0A00      VSTR     S0,[R0, #0]
    396          
    397                  //Dq reference generation Initialization
    398                  MclDqRef__Initialize();
   \   00000188   0xF204 0x4060      ADDW     R0,R4,#+1120
   \   0000018C   0xED80 0x0A00      VSTR     S0,[R0, #0]
    399          
    400                  //Dq controllers Initialization
    401                  MclDqCtrl__Initialize(&Mcl_DQ_Ctrl_IO, &Mcl_Params_Displ1->DQCtrlPrm);
   \   00000190   0xF8D4 0x03F4      LDR      R0,[R4, #+1012]
   \   00000194   0xF100 0x0144      ADD      R1,R0,#+68
   \   00000198   0xF504 0x70E8      ADD      R0,R4,#+464
   \   0000019C   0x.... 0x....      BL       MclDqCtrl__ResetState
    402          
    403                  //Pwm Initialization
    404                  MclPwm__Initialize(&MclPwm_Params);
   \   000001A0   0x2000             MOVS     R0,#+0
   \   000001A2   0xF884 0x035D      STRB     R0,[R4, #+861]
    405          
    406          
    407                  // Mean Irms and speed
    408                  N_Samples_inv = 1.0f / (float32) Mcl_Params_Displ1->ResTempCalc.Samples_Number;
   \   000001A6   0xEEF7 0x0A00      VMOV.F32 S1,#1.0
   \   000001AA   0xF504 0x60B3      ADD      R0,R4,#+1432
   \   000001AE   0xF8C4 0x033C      STR      R0,[R4, #+828]
   \   000001B2   0xF204 0x70A4      ADDW     R0,R4,#+1956
   \   000001B6   0xF8C4 0x0344      STR      R0,[R4, #+836]
   \   000001BA   0xF504 0x60F4      ADD      R0,R4,#+1952
   \   000001BE   0xF8C4 0x0340      STR      R0,[R4, #+832]
   \   000001C2   0xF8D4 0x03F4      LDR      R0,[R4, #+1012]
   \   000001C6   0xED90 0x0A53      VLDR     S0,[R0, #+332]
   \   000001CA   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000001CE   0xF204 0x4028      ADDW     R0,R4,#+1064
   \   000001D2   0xEE80 0x0A80      VDIV.F32 S0,S1,S0
   \   000001D6   0xED80 0x0A00      VSTR     S0,[R0, #0]
    409          
    410                  Mcl_Cs.flags.bit.params_loaded = 1;
   \   000001DA   0xF8D4 0x00E4      LDR      R0,[R4, #+228]
   \   000001DE   0xF040 0x0001      ORR      R0,R0,#0x1
   \   000001E2   0xF8C4 0x00E4      STR      R0,[R4, #+228]
    411          
    412              }
    413          }
   \                     ??Mcl__ParamsInitialize_0: (+1)
   \   000001E6   0xBD10             POP      {R4,PC}          ;; return
    414          
    415          

   \                                 In section .text, align 2, keep-with-next
    416          void Mcl__1msHandler(void)
    417          {
   \                     Mcl__1msHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    418          
    419              if(Mcl_Cs.flags.bit.params_loaded == 1)
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable46_7
   \   00000006   0xF894 0x00E4      LDRB     R0,[R4, #+228]
   \   0000000A   0x07C0             LSLS     R0,R0,#+31
   \   0000000C   0xD530             BPL.N    ??Mcl__1msHandler_0
    420              {
    421                  // update elapsed time after start
    422                  TimeHandler();
   \   0000000E   0xF8D4 0x00B8      LDR      R0,[R4, #+184]
   \   00000012   0xF110 0x0F01      CMN      R0,#+1
   \   00000016   0xBF1C             ITT      NE 
   \   00000018   0x1C40             ADDNE    R0,R0,#+1
   \   0000001A   0xF8C4 0x00B8      STRNE    R0,[R4, #+184]
    423          
    424                  // Calculate the absolute value of the speed reference
    425                  Mcl_Quantities.Speed_Rot_Ref_Abs = MATHCALC__ABS(Mcl_IO.Speed_Rot_Ref);
   \   0000001E   0xED94 0x0A55      VLDR     S0,[R4, #+340]
   \   00000022   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000026   0xEEF1 0xFA10      FMSTAT   
   \   0000002A   0xBF48             IT       MI 
   \   0000002C   0xEEB1 0x0A40      VNEGMI.F32 S0,S0
    426              	// Input Processing Handler
    427              	MclInputProc__1msRunningHandler(&Mcl_Input_Proc_IO, &Mcl_Params_Displ1->InputProcPrm);
   \   00000030   0xF8D4 0x13F4      LDR      R1,[R4, #+1012]
   \   00000034   0xED84 0x0A1B      VSTR     S0,[R4, #+108]
   \   00000038   0xF504 0x7011      ADD      R0,R4,#+580
   \   0000003C   0x.... 0x....      BL       MclInputProc__1msRunningHandler
    428              	// Observer Handler
    429                  MclObserver__1msHandler(&Mcl_Observer_IO, &MclObserver_Params);
   \   00000040   0xF504 0x71CE      ADD      R1,R4,#+412
   \   00000044   0xF504 0x70FE      ADD      R0,R4,#+508
   \   00000048   0x.... 0x....      BL       MclObserver__1msHandler
    430                  MclSpeedCtrl__1msHandler(&Mcl_Speed_Ctrl_IO, &MclSpeedCtrl_Params);
   \   0000004C   0xF8D4 0x1318      LDR      R1,[R4, #+792]
   \   00000050   0xF504 0x7042      ADD      R0,R4,#+776
   \   00000054   0x.... 0x....      BL       Braking__SpeedCtrlHandler
   \   00000058   0xF204 0x407C      ADDW     R0,R4,#+1148
    431                  MclDqRef__1msHandler(&Mcl_DQ_Ref_IO, &MclDqRef_Params);
   \   0000005C   0xF504 0x714A      ADD      R1,R4,#+808
   \   00000060   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   00000064   0xF504 0x7019      ADD      R0,R4,#+612
   \   00000068   0xE8BD 0x4010      POP      {R4,LR}
   \   0000006C   0x.... 0x....      B.W      MclDqRef__1msHandler
    432              }
    433          }
   \                     ??Mcl__1msHandler_0: (+1)
   \   00000070   0xBD10             POP      {R4,PC}          ;; return
    434          
    435          
    436          
    437          
    438          

   \                                 In section .text, align 2, keep-with-next
    439          void Mcl__5msHandler(void)
    440          {
    441              if(Mcl_Cs.flags.bit.params_loaded == 1)
   \                     Mcl__5msHandler: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable45
   \   00000004   0xF890 0x00E4      LDRB     R0,[R0, #+228]
   \   00000008   0x07C0             LSLS     R0,R0,#+31
   \   0000000A   0xBF48             IT       MI 
    442              {
    443                  // Runs in parallel with all macro blocks
    444                  Running_Parallel_5msHandler();
   \   0000000C   0x.... 0x....      BMI.W    ??Running_Parallel_5msHandler
    445              }
    446          }
   \   00000010   0x4770             BX       LR               ;; return
    447          
    448          
    449          
    450          

   \                                 In section .text, align 4, keep-with-next
    451          void Mcl__25msHandler(void)
    452          {
   \                     Mcl__25msHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    453              float32 temp;
    454          
    455          #if (THERMAL_MODEL_EXE == ENABLED)
    456              ThermalModel__Handler25ms();
   \   00000002   0x.... 0x....      BL       ThermalModel__Handler25ms
    457          #endif
    458          
    459              if(Mcl_Cs.flags.bit.params_loaded == 1)
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable45
   \   0000000A   0xF894 0x00E4      LDRB     R0,[R4, #+228]
   \   0000000E   0x07C0             LSLS     R0,R0,#+31
   \   00000010   0xD573             BPL.N    ??Mcl__25msHandler_0
    460              {
    461          #if (THERMAL_MODEL_EXE == ENABLED)
    462                  Mcl_Quantities.Stator_Temperature = ThermalModel__GetStatorTemperature();
   \   00000012   0x.... 0x....      BL       ThermalModel__GetStatorTemperature
    463          #ifndef DISABLE_RESISTANCE_UPDATE  // Thermal model in open-loop if defined
    464                  Mcl_Quantities.Stator_Resistance  = Calc_Resistance_By_Temperature();
   \   00000016   0xF8D4 0x03F4      LDR      R0,[R4, #+1012]
    465          #endif
    466          #else
    467                  Mcl_Quantities.Stator_Temperature = My_Measured_Temp;
    468                  Mcl_Quantities.Stator_Resistance  = Calc_Resistance_By_Temperature();
    469          #endif
    470                  ResistanceEstimation__Handler25ms(&Mcl_Params_Displ1->Res_Est_Param);
   \   0000001A   0xF8D4 0x14B4      LDR      R1,[R4, #+1204]
   \   0000001E   0xED84 0x0A1A      VSTR     S0,[R4, #+104]
   \   00000022   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \   00000026   0xEDD0 0x0A52      VLDR     S1,[R0, #+328]
   \   0000002A   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   0000002E   0xEDD0 0x0A51      VLDR     S1,[R0, #+324]
   \   00000032   0xEE00 0x1A20      VMLA.F32 S2,S0,S1
   \   00000036   0xED90 0x0A4E      VLDR     S0,[R0, #+312]
   \   0000003A   0xEE21 0x0A00      VMUL.F32 S0,S2,S0
   \   0000003E   0xED84 0x0A34      VSTR     S0,[R4, #+208]
   \   00000042   0x30E4             ADDS     R0,R0,#+228
   \   00000044   0xB111             CBZ.N    R1,??Mcl__25msHandler_1
   \   00000046   0x1E49             SUBS     R1,R1,#+1
   \   00000048   0xF8C4 0x14B4      STR      R1,[R4, #+1204]
   \                     ??Mcl__25msHandler_1: (+1)
   \   0000004C   0x.... 0x....      BL       ??TimerDefinition
    471          
    472                  MclSpeedCtrl__25msHandler(&Mcl_Speed_Ctrl_IO, &MclSpeedCtrl_Params);
   \   00000050   0xF504 0x7042      ADD      R0,R4,#+776
   \   00000054   0xF8D4 0x1318      LDR      R1,[R4, #+792]
   \   00000058   0x.... 0x....      BL       Speed_Gain_Scheduler
   \   0000005C   0xF8B4 0x0386      LDRH     R0,[R4, #+902]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xBF1A             ITTE     NE 
   \   00000064   0x1E40             SUBNE    R0,R0,#+1
   \   00000066   0xF8A4 0x0386      STRHNE   R0,[R4, #+902]
   \   0000006A   0xF8C4 0x0480      STREQ    R0,[R4, #+1152]
    473                  MclDqCtrl__25msHandler(&Mcl_DQ_Ctrl_IO, &Mcl_Params_Displ1->DQCtrlPrm);
   \   0000006E   0xF8D4 0x03F4      LDR      R0,[R4, #+1012]
   \   00000072   0xF100 0x0144      ADD      R1,R0,#+68
   \   00000076   0xF504 0x70E8      ADD      R0,R4,#+464
   \   0000007A   0x.... 0x....      BL       Torque_Flux_Gains_Scheduler
    474                  MclPwm__25msHandler(&Mcl_Pwm_IO);
   \   0000007E   0xF8D4 0x0304      LDR      R0,[R4, #+772]
   \   00000082   0x6900             LDR      R0,[R0, #+16]
   \   00000084   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000088   0xF8D4 0x0474      LDR      R0,[R4, #+1140]
   \   0000008C   0xEE00 0x0A90      VMOV     S1,R0
   \   00000090   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000094   0xEEF1 0xFA10      FMSTAT   
   \   00000098   0xDB06             BLT.N    ??Mcl__25msHandler_2
   \   0000009A   0xF8D4 0x0470      LDR      R0,[R4, #+1136]
   \   0000009E   0xF8C4 0x0474      STR      R0,[R4, #+1140]
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0xF884 0x035D      STRB     R0,[R4, #+861]
   \                     ??Mcl__25msHandler_2: (+1)
   \   000000A8   0xF8D4 0x0474      LDR      R0,[R4, #+1140]
   \   000000AC   0xEE00 0x0A90      VMOV     S1,R0
   \   000000B0   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   000000B4   0xEEF1 0xFA10      FMSTAT   
   \   000000B8   0xDB06             BLT.N    ??Mcl__25msHandler_3
   \   000000BA   0xF8D4 0x046C      LDR      R0,[R4, #+1132]
   \   000000BE   0xF8C4 0x0474      STR      R0,[R4, #+1140]
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xF884 0x035D      STRB     R0,[R4, #+861]
    475          
    476                  temp = Mcl_Params_Displ1->Mcl_SpeedRef_Params.SpeedRef_Min_Speed_Default_Accel * RPM_TO_RADS;
   \                     ??Mcl__25msHandler_3: (+1)
   \   000000C8   0xEDDF 0x....      VLDR.W   S1,??DataTable30_1  ;; 0x3dd67750
   \   000000CC   0xF8D4 0x03F4      LDR      R0,[R4, #+1012]
   \   000000D0   0xED90 0x0A55      VLDR     S0,[R0, #+340]
   \   000000D4   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
    477                  if( (Mcl_Quantities.Speed_Rot_Ref_Abs >= temp) &&
    478                      (Mcl_Quantities.Speed_Rot_Mech_Abs >= temp))
   \   000000D8   0xEDD4 0x0A1B      VLDR     S1,[R4, #+108]
   \   000000DC   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   000000E0   0xEEF1 0xFA10      FMSTAT   
   \   000000E4   0xBFA2             ITTT     GE 
   \   000000E6   0xEDD4 0x0A1D      VLDRGE   S1,[R4, #+116]
   \   000000EA   0xEEF4 0x0A40      VCMPGE.F32 S1,S0
   \   000000EE   0xEEF1 0xFA10      FMSTATGE 
   \   000000F2   0xBFA4             ITT      GE 
    479                  {
    480                      SpeedRefGen__ApplyDefaultAccel(FALSE);
   \   000000F4   0x2000             MOVGE    R0,#+0
   \   000000F6   0xF884 0x036B      STRBGE   R0,[R4, #+875]
    481                  }
    482          
    483              }
    484          }
   \                     ??Mcl__25msHandler_0: (+1)
   \   000000FA   0xBD10             POP      {R4,PC}          ;; return
    485          
    486          

   \                                 In section .text, align 4, keep-with-next
    487          void Mcl__250usHandler(void)
    488          {
   \                     Mcl__250usHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    489              if(Mcl_Cs.flags.bit.params_loaded == 1)
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable45
   \   00000006   0xED2D 0x8B02      VPUSH    {D8}
   \   0000000A   0xF894 0x00E4      LDRB     R0,[R4, #+228]
   \   0000000E   0x07C0             LSLS     R0,R0,#+31
   \   00000010   0xF140 0x809F      BPL.W    ??Mcl__250usHandler_0
    490              {
    491                  Calc_MeanSpeed_CurrentRMS();
   \   00000014   0xF8D4 0x0418      LDR      R0,[R4, #+1048]
   \   00000018   0xED94 0x0A52      VLDR     S0,[R4, #+328]
   \   0000001C   0xED94 0x2A1D      VLDR     S4,[R4, #+116]
   \   00000020   0xF8D4 0x13F4      LDR      R1,[R4, #+1012]
   \   00000024   0xEE00 0x0A90      VMOV     S1,R0
   \   00000028   0xF204 0x4018      ADDW     R0,R4,#+1048
   \   0000002C   0xEE40 0x0A00      VMLA.F32 S1,S0,S0
   \   00000030   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
   \   00000034   0xF8D4 0x041C      LDR      R0,[R4, #+1052]
   \   00000038   0xED94 0x0A53      VLDR     S0,[R4, #+332]
   \   0000003C   0xEE01 0x0A10      VMOV     S2,R0
   \   00000040   0xF204 0x401C      ADDW     R0,R4,#+1052
   \   00000044   0xEE00 0x1A00      VMLA.F32 S2,S0,S0
   \   00000048   0xED80 0x1A00      VSTR     S2,[R0, #0]
   \   0000004C   0xF8D4 0x0420      LDR      R0,[R4, #+1056]
   \   00000050   0xED94 0x0A54      VLDR     S0,[R4, #+336]
   \   00000054   0xEE01 0x0A90      VMOV     S3,R0
   \   00000058   0xF204 0x4020      ADDW     R0,R4,#+1056
   \   0000005C   0xEE40 0x1A00      VMLA.F32 S3,S0,S0
   \   00000060   0xEDC0 0x1A00      VSTR     S3,[R0, #0]
   \   00000064   0xF8D4 0x0424      LDR      R0,[R4, #+1060]
   \   00000068   0xEE00 0x0A10      VMOV     S0,R0
   \   0000006C   0xF204 0x4024      ADDW     R0,R4,#+1060
   \   00000070   0xEE30 0x0A02      VADD.F32 S0,S0,S4
   \   00000074   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   00000078   0xF8B4 0x037C      LDRH     R0,[R4, #+892]
   \   0000007C   0x1C40             ADDS     R0,R0,#+1
   \   0000007E   0xF8A4 0x037C      STRH     R0,[R4, #+892]
   \   00000082   0xB280             UXTH     R0,R0
   \   00000084   0xF8D1 0x114C      LDR      R1,[R1, #+332]
   \   00000088   0x4288             CMP      R0,R1
   \   0000008A   0xDB28             BLT.N    ??Mcl__250usHandler_1
   \   0000008C   0xF8D4 0x0428      LDR      R0,[R4, #+1064]
   \   00000090   0xEE70 0x0A81      VADD.F32 S1,S1,S2
   \   00000094   0xEE70 0x0AA1      VADD.F32 S1,S1,S3
   \   00000098   0xED9F 0x....      VLDR.W   S2,??DataTable35  ;; 0x3eaaaaab
   \   0000009C   0xEE02 0x0A10      VMOV     S4,R0
   \   000000A0   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   000000A4   0xEE60 0x0A82      VMUL.F32 S1,S1,S4
   \   000000A8   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   000000AC   0xEEF1 0xFA10      FMSTAT   
   \   000000B0   0xDB02             BLT.N    ??Mcl__250usHandler_2
   \   000000B2   0xEEF1 0x0AE0      VSQRT.F32 S1,S1
   \   000000B6   0xE001             B.N      ??Mcl__250usHandler_3
   \                     ??Mcl__250usHandler_2: (+1)
   \   000000B8   0xEDDF 0x....      VLDR.W   S1,??DataTable36  ;; 0x0
   \                     ??Mcl__250usHandler_3: (+1)
   \   000000BC   0xEE20 0x0A02      VMUL.F32 S0,S0,S4
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xEDC4 0x0A33      VSTR     S1,[R4, #+204]
   \   000000C6   0xED84 0x0A32      VSTR     S0,[R4, #+200]
   \   000000CA   0xF8A4 0x037C      STRH     R0,[R4, #+892]
   \   000000CE   0xF8C4 0x0418      STR      R0,[R4, #+1048]
   \   000000D2   0xF8C4 0x041C      STR      R0,[R4, #+1052]
   \   000000D6   0xF8C4 0x0420      STR      R0,[R4, #+1056]
   \   000000DA   0xF8C4 0x0424      STR      R0,[R4, #+1060]
    492          #if (MCL__ELECTRICAL_POWER == ENABLED)
    493                  Calc_ElectricalPower();
   \                     ??Mcl__250usHandler_1: (+1)
   \   000000DE   0xED94 0x0A0C      VLDR     S0,[R4, #+48]
   \   000000E2   0xEDD4 0x0A01      VLDR     S1,[R4, #+4]
   \   000000E6   0xED94 0x1A02      VLDR     S2,[R4, #+8]
   \   000000EA   0xF894 0x018D      LDRB     R0,[R4, #+397]
   \   000000EE   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000000F2   0xEDD4 0x0A0D      VLDR     S1,[R4, #+52]
   \   000000F6   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   \   000000FA   0xEEF7 0x0A08      VMOV.F32 S1,#1.5
   \   000000FE   0xEE20 0x8A20      VMUL.F32 S16,S0,S1
   \   00000102   0xB9B0             CBNZ.N   R0,??Mcl__250usHandler_4
   \   00000104   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000108   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   0000010C   0x.... 0x....      BL       SRData__CheckShort
   \   00000110   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   00000114   0x0780             LSLS     R0,R0,#+30
   \   00000116   0xD50C             BPL.N    ??Mcl__250usHandler_4
   \   00000118   0xED94 0x0A36      VLDR     S0,[R4, #+216]
   \   0000011C   0xEDDF 0x....      VLDR.W   S1,??DataTable37  ;; 0x3f7ae148
   \   00000120   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000124   0xEDDF 0x....      VLDR.W   S1,??DataTable37_1  ;; 0x3ca3d70a
   \   00000128   0xEE08 0x0A20      VMLA.F32 S0,S16,S1
   \   0000012C   0xED84 0x0A36      VSTR     S0,[R4, #+216]
   \   00000130   0xE002             B.N      ??Mcl__250usHandler_5
   \                     ??Mcl__250usHandler_4: (+1)
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0xF8C4 0x00D8      STR      R0,[R4, #+216]
    494          #endif
    495                  Calc_TorqueForApplication();
   \                     ??Mcl__250usHandler_5: (+1)
   \   00000138   0xEDD4 0x0A55      VLDR     S1,[R4, #+340]
   \   0000013C   0xED94 0x0A2B      VLDR     S0,[R4, #+172]
   \   00000140   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   00000144   0xEEF1 0xFA10      FMSTAT   
   \   00000148   0xBF48             IT       MI 
   \   0000014A   0xEEB1 0x0A40      VNEGMI.F32 S0,S0
   \   0000014E   0xED84 0x0A37      VSTR     S0,[R4, #+220]
    496              }
    497          }
   \                     ??Mcl__250usHandler_0: (+1)
   \   00000152   0xECBD 0x8B02      VPOP     {D8}
   \   00000156   0xBD10             POP      {R4,PC}          ;; return
    498          
    499          
    500          
    501          
    502          

   \                                 In section .text, align 4, keep-with-next
    503          void Mcl__StartingReset(void)
    504          {
    505              MclPwm__ResetState(&Mcl_Pwm_IO, &MclPwm_Params);
   \                     Mcl__StartingReset: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable45
   \   00000004   0xF8D0 0x12F4      LDR      R1,[R0, #+756]
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x604A             STR      R2,[R1, #+4]
   \   0000000C   0xEEB6 0x0A00      VMOV.F32 S0,#0.5
   \   00000010   0xF8D0 0x12F4      LDR      R1,[R0, #+756]
   \   00000014   0x608A             STR      R2,[R1, #+8]
   \   00000016   0xED9F 0x....      VLDR.W   S2,??DataTable38  ;; 0x3f866666
   \   0000001A   0xF8D0 0x1300      LDR      R1,[R0, #+768]
   \   0000001E   0xED81 0x0A00      VSTR     S0,[R1, #0]
   \   00000022   0xEDDF 0x....      VLDR.W   S3,??DataTable38_1  ;; 0x3f733333
   \   00000026   0xF8D0 0x1300      LDR      R1,[R0, #+768]
   \   0000002A   0xED81 0x0A01      VSTR     S0,[R1, #+4]
   \   0000002E   0xF8D0 0x1300      LDR      R1,[R0, #+768]
   \   00000032   0xED81 0x0A02      VSTR     S0,[R1, #+8]
   \   00000036   0xED9F 0x....      VLDR.W   S0,??DataTable38_2  ;; 0x3dd67750
   \   0000003A   0xF8D0 0x1338      LDR      R1,[R0, #+824]
   \   0000003E   0xEDD1 0x0A00      VLDR     S1,[R1, #0]
   \   00000042   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   00000046   0xF200 0x416C      ADDW     R1,R0,#+1132
   \   0000004A   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   0000004E   0xEDC1 0x0A00      VSTR     S1,[R1, #0]
   \   00000052   0xF8D0 0x1338      LDR      R1,[R0, #+824]
   \   00000056   0xED91 0x1A00      VLDR     S2,[R1, #0]
   \   0000005A   0xEE21 0x1A21      VMUL.F32 S2,S2,S3
   \   0000005E   0xF200 0x4170      ADDW     R1,R0,#+1136
   \   00000062   0xEE21 0x0A00      VMUL.F32 S0,S2,S0
   \   00000066   0xED81 0x0A00      VSTR     S0,[R1, #0]
   \   0000006A   0xF200 0x4174      ADDW     R1,R0,#+1140
   \   0000006E   0xEDC1 0x0A00      VSTR     S1,[R1, #0]
    506          
    507              if(ResistanceEstimation__Requested())
   \   00000072   0xF890 0x138C      LDRB     R1,[R0, #+908]
   \   00000076   0x07C9             LSLS     R1,R1,#+31
   \   00000078   0xD51E             BPL.N    ??Mcl__StartingReset_0
    508              {
    509                  ResistanceEstimation__Start(&Mcl_Params_Displ1->Res_Est_Param);
   \   0000007A   0xF8C0 0x24B8      STR      R2,[R0, #+1208]
   \   0000007E   0x2201             MOVS     R2,#+1
   \   00000080   0xF8D0 0x13F4      LDR      R1,[R0, #+1012]
   \   00000084   0xF880 0x2367      STRB     R2,[R0, #+871]
   \   00000088   0x31E4             ADDS     R1,R1,#+228
   \   0000008A   0x690A             LDR      R2,[R1, #+16]
   \   0000008C   0xF8A0 0x2392      STRH     R2,[R0, #+914]
   \   00000090   0x680A             LDR      R2,[R1, #+0]
   \   00000092   0xF8A0 0x2394      STRH     R2,[R0, #+916]
   \   00000096   0xF890 0x2366      LDRB     R2,[R0, #+870]
   \   0000009A   0x2A01             CMP      R2,#+1
   \   0000009C   0xD10A             BNE.N    ??Mcl__StartingReset_1
   \   0000009E   0x2202             MOVS     R2,#+2
   \   000000A0   0xF880 0x2366      STRB     R2,[R0, #+870]
   \   000000A4   0xF890 0x2368      LDRB     R2,[R0, #+872]
   \   000000A8   0x1C52             ADDS     R2,R2,#+1
   \   000000AA   0xF880 0x2368      STRB     R2,[R0, #+872]
   \   000000AE   0x6C49             LDR      R1,[R1, #+68]
   \   000000B0   0xF8A0 0x1390      STRH     R1,[R0, #+912]
    510          
    511                  Mcl_Starting_State = MCL_RESISTANCE_ESTIMATION;
   \                     ??Mcl__StartingReset_1: (+1)
   \   000000B4   0x2101             MOVS     R1,#+1
   \   000000B6   0xE000             B.N      ??Mcl__StartingReset_2
    512              }
    513              else
    514              {
    515                  Mcl_Starting_State = MCL_STARTING_FINISHED;
   \                     ??Mcl__StartingReset_0: (+1)
   \   000000B8   0x2103             MOVS     R1,#+3
   \                     ??Mcl__StartingReset_2: (+1)
   \   000000BA   0xF880 0x1357      STRB     R1,[R0, #+855]
    516              }
    517          
    518          
    519              MCL_CLR_FLOW_MANAGER(RUNNING_MIN_SPEED_STOP_REACHED);
   \   000000BE   0xF890 0x1358      LDRB     R1,[R0, #+856]
   \   000000C2   0xF001 0x01F7      AND      R1,R1,#0xF7
   \   000000C6   0xF880 0x1358      STRB     R1,[R0, #+856]
    520          }
   \   000000CA   0x4770             BX       LR               ;; return
    521          
    522          
    523          
    524          
    525          

   \                                 In section .text, align 2, keep-with-next
    526          void Mcl__StartingHandler(void)
    527          {
   \                     Mcl__StartingHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    528              ////////////////////////////////////////////////
    529              // just two states:
    530              // - MCL_RESISTANCE_ESTIMATION
    531              // - MCL_STARTING_FINISHED
    532              ////////////////////////////////////////////////
    533              if(Mcl_Starting_State == MCL_RESISTANCE_ESTIMATION)
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable46_7
   \   00000006   0xF894 0x0357      LDRB     R0,[R4, #+855]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD105             BNE.N    ??Mcl__StartingHandler_0
    534              {
    535                  if(Estimate_Stator_Resistance())
   \   0000000E   0x.... 0x....      BL       ??Estimate_Stator_Resistance
   \   00000012   0xB110             CBZ.N    R0,??Mcl__StartingHandler_0
    536                  {
    537                      Mcl_Starting_State = MCL_STARTING_FINISHED;
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0xF884 0x0357      STRB     R0,[R4, #+855]
    538                  }
    539              }
    540          }
   \                     ??Mcl__StartingHandler_0: (+1)
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    541          
    542          
    543          
    544          
    545          
    546          //---------------------------------------------------------------------------------------------------------------------
    547          /**
    548           *  @brief      Reset all Mcl quantities.
    549           *  @details    This routine reset all Mcl quantities, it has to be called at every time the pwm is switched off (motor stop or free down ramp).
    550           *
    551           *
    552           *  @param[in]
    553           *  @param[out]
    554           *  @return
    555           */

   \                                 In section .text, align 4, keep-with-next
    556          void Mcl__RunningReset(void)
    557          {
   \                     Mcl__RunningReset: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    558              ResetQuantities();
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable45
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF8C4 0x00B8      STR      R0,[R4, #+184]
   \   0000000C   0xF884 0x018D      STRB     R0,[R4, #+397]
   \   00000010   0xF884 0x018C      STRB     R0,[R4, #+396]
   \   00000014   0xF8D4 0x00E4      LDR      R0,[R4, #+228]
   \   00000018   0xF420 0x7001      BIC      R0,R0,#0x204
   \   0000001C   0xF8C4 0x00E4      STR      R0,[R4, #+228]
    559              if (Mcl_Cs.flags.bit.params_loaded == 1)
   \   00000020   0x07C0             LSLS     R0,R0,#+31
   \   00000022   0xD536             BPL.N    ??Mcl__RunningReset_0
    560              {
    561                  SpeedRefGen__SetSpeedParams(Mcl_Params_Displ1->Mcl_SpeedRef_Params.SpeedRef_Default_Accel);
   \   00000024   0xF8D4 0x03F4      LDR      R0,[R4, #+1012]
   \   00000028   0xED90 0x0A54      VLDR     S0,[R0, #+336]
   \   0000002C   0xEDDF 0x....      VLDR.W   S1,??DataTable39  ;; 0x3903126f
   \   00000030   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000034   0xEDDF 0x....      VLDR.W   S1,??DataTable38_2  ;; 0x3dd67750
   \   00000038   0xF204 0x40D0      ADDW     R0,R4,#+1232
   \   0000003C   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000040   0xED80 0x0A00      VSTR     S0,[R0, #0]
    562                  SpeedRefGen__ApplyDefaultAccel(TRUE);
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xF884 0x036B      STRB     R0,[R4, #+875]
    563          
    564                  // reset all macro-blocks
    565                  MclObserver__ResetState(&Mcl_Observer_IO, &MclObserver_Params);
   \   0000004A   0xF504 0x71CE      ADD      R1,R4,#+412
   \   0000004E   0xF504 0x70FE      ADD      R0,R4,#+508
   \   00000052   0x.... 0x....      BL       MclObserver__ResetState
    566                  MclSpeedCtrl__ResetState(&MclSpeedCtrl_Params);
   \   00000056   0xF504 0x7046      ADD      R0,R4,#+792
   \   0000005A   0x.... 0x....      BL       MclSpeedCtrl__ResetState
    567                  MclDqRef__ResetState(&MclDqRef_Params);
   \   0000005E   0xF04F 0x507E      MOV      R0,#+1065353216
   \   00000062   0xF8C4 0x0454      STR      R0,[R4, #+1108]
   \   00000066   0xF8D4 0x0328      LDR      R0,[R4, #+808]
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF8C4 0x045C      STR      R0,[R4, #+1116]
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xF8C4 0x0458      STR      R0,[R4, #+1112]
    568                  MclDqCtrl__ResetState(&Mcl_DQ_Ctrl_IO, &Mcl_Params_Displ1->DQCtrlPrm);
   \   00000076   0xF8D4 0x03F4      LDR      R0,[R4, #+1012]
   \   0000007A   0xF100 0x0144      ADD      R1,R0,#+68
   \   0000007E   0xF504 0x70E8      ADD      R0,R4,#+464
   \   00000082   0x.... 0x....      BL       MclDqCtrl__ResetState
    569                  MclPwm__ResetState(&Mcl_Pwm_IO, &MclPwm_Params);
   \   00000086   0xF504 0x714E      ADD      R1,R4,#+824
   \   0000008A   0xF504 0x703C      ADD      R0,R4,#+752
   \   0000008E   0x.... 0x....      BL       MclPwm__ResetState
    570              }
    571              Mcl_DQ_Ctrl_IO.Force_Out_Volt->D = 0.0f;
   \                     ??Mcl__RunningReset_0: (+1)
   \   00000092   0xF8D4 0x01E4      LDR      R0,[R4, #+484]
   \   00000096   0x2100             MOVS     R1,#+0
   \   00000098   0x6041             STR      R1,[R0, #+4]
    572              Mcl_DQ_Ctrl_IO.Force_Out_Volt->Q = 0.0f;
   \   0000009A   0xF8D4 0x01E4      LDR      R0,[R4, #+484]
   \   0000009E   0x6081             STR      R1,[R0, #+8]
    573          }
   \   000000A0   0xBD10             POP      {R4,PC}          ;; return
    574          
    575          
    576          
    577          
    578          
    579          //---------------------------------------------------------------------------------------------------------------------
    580          /**
    581           *  @brief     Motor Control Loop for 3-Phase motors (DD,BPM,CIM).
    582           *  @details   Motor control loop routine for 3-Phase motors :
    583           *             - d axis: rotor flux position
    584           *             - q axis: rotor flux quadrature axis
    585           *
    586           *             This routine is composed by six parts:
    587           *             - Input processing: tachometer signal processing
    588           *                                 motor speed reference absolute value
    589           *                                 motor phase currents swapping in order to work with a positive speed reference.
    590           *                                 dc voltage filtering
    591           *
    592           *             - Observer:		   rotor flux speed estimation
    593           *             					   flux position estimation (FOC: rotor flux, DTC: stator flux)
    594           *
    595           *             - Speed Controller: speed PI execution
    596           *								   torque reference generation
    597           *
    598           *             - Dq Reference Gen: Mtpa
    599           *                                 Flux Weaking
    600           *             					   d-reference generation (FOC: current Id, DTC: flux reference)
    601           *             					   q reference generation (FOC: current Id, DTC: torque reference)
    602           *								   torque reference generation
    603           *
    604           *             - Dq Controller:   DQ PI execution (FOC: current PI, DTC: flux/torque PI)
    605           *								  alpha-beta voltage reference generation
    606           *
    607           *             - Pwm:   		  DC voltage compensation
    608           *             					  Deadtime compensation
    609           *             					  PWM Duties generation
    610           *  @param[in]     
    611           *  @param[out]     
    612           *  @param[in]
    613           *  @return        
    614           */

   \                                 In section .text, align 2, keep-with-next
    615          void Mcl__RunningHandler(void)
    616          {
   \                     Mcl__RunningHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    617          
    618              Flags_Management();
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable46_7
   \   00000006   0xF8D4 0x14D8      LDR      R1,[R4, #+1240]
   \   0000000A   0xEDD4 0x0A1C      VLDR     S1,[R4, #+112]
   \   0000000E   0xF8D4 0x00E4      LDR      R0,[R4, #+228]
   \   00000012   0xEE00 0x1A10      VMOV     S0,R1
   \   00000016   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000001A   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000001E   0xEEF1 0xFA10      FMSTAT   
   \   00000022   0xBF4C             ITE      MI 
   \   00000024   0xF040 0x0004      ORRMI    R0,R0,#0x4
   \   00000028   0xF020 0x0004      BICPL    R0,R0,#0x4
   \   0000002C   0xF8C4 0x00E4      STR      R0,[R4, #+228]
   \   00000030   0xF8D4 0x00E4      LDR      R0,[R4, #+228]
   \   00000034   0xF3C0 0x11C0      UBFX     R1,R0,#+7,#+1
   \   00000038   0xB171             CBZ.N    R1,??Mcl__RunningHandler_0
   \   0000003A   0x.... 0x....      BL       SpeedRefGen__GetStatus
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD12D             BNE.N    ??Mcl__RunningHandler_1
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF8C4 0x04D0      STR      R0,[R4, #+1232]
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xF884 0x036B      STRB     R0,[R4, #+875]
   \   0000004E   0xF8D4 0x00E4      LDR      R0,[R4, #+228]
   \   00000052   0xF440 0x7000      ORR      R0,R0,#0x200
   \   00000056   0xE020             B.N      ??Mcl__RunningHandler_2
   \                     ??Mcl__RunningHandler_0: (+1)
   \   00000058   0xF3C0 0x2040      UBFX     R0,R0,#+9,#+1
   \   0000005C   0xB140             CBZ.N    R0,??Mcl__RunningHandler_3
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF884 0x036B      STRB     R0,[R4, #+875]
   \   00000064   0xF8D4 0x00E4      LDR      R0,[R4, #+228]
   \   00000068   0xF420 0x7000      BIC      R0,R0,#0x200
   \   0000006C   0xF8C4 0x00E4      STR      R0,[R4, #+228]
   \                     ??Mcl__RunningHandler_3: (+1)
   \   00000070   0xED94 0x0A55      VLDR     S0,[R4, #+340]
   \   00000074   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000078   0xEEF1 0xFA10      FMSTAT   
   \   0000007C   0xDD04             BLE.N    ??Mcl__RunningHandler_4
   \   0000007E   0xF8D4 0x00E4      LDR      R0,[R4, #+228]
   \   00000082   0xF440 0x7080      ORR      R0,R0,#0x100
   \   00000086   0xE008             B.N      ??Mcl__RunningHandler_2
   \                     ??Mcl__RunningHandler_4: (+1)
   \   00000088   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000008C   0xEEF1 0xFA10      FMSTAT   
   \   00000090   0xD505             BPL.N    ??Mcl__RunningHandler_1
   \   00000092   0xF8D4 0x00E4      LDR      R0,[R4, #+228]
   \   00000096   0xF420 0x7080      BIC      R0,R0,#0x100
   \                     ??Mcl__RunningHandler_2: (+1)
   \   0000009A   0xF8C4 0x00E4      STR      R0,[R4, #+228]
    619          
    620              // Input Processing Handler
    621          	MclInputProc__RunningHandler(&Mcl_Input_Proc_IO);
   \                     ??Mcl__RunningHandler_1: (+1)
   \   0000009E   0xF504 0x7011      ADD      R0,R4,#+580
   \   000000A2   0x.... 0x....      BL       MclInputProc__RunningHandler
    622          
    623          	// Observer Handler
    624          	MclObserver__RunningHandler(&Mcl_Observer_IO, &MclObserver_Params);
   \   000000A6   0xF504 0x71CE      ADD      R1,R4,#+412
   \   000000AA   0xF504 0x70FE      ADD      R0,R4,#+508
   \   000000AE   0x.... 0x....      BL       MclObserver__RunningHandler
    625          
    626          	// Speed Controller Handler
    627          	MclSpeedCtrl__RunningHandler(&Mcl_Speed_Ctrl_IO, &MclSpeedCtrl_Params);
   \   000000B2   0xF504 0x7146      ADD      R1,R4,#+792
   \   000000B6   0xF504 0x7042      ADD      R0,R4,#+776
   \   000000BA   0x.... 0x....      BL       MclSpeedCtrl__RunningHandler
    628          
    629          	// Dq reference generation Handler
    630          	MclDqRef__RunningHandler(&Mcl_DQ_Ref_IO, &MclDqRef_Params);
   \   000000BE   0xF504 0x714A      ADD      R1,R4,#+808
   \   000000C2   0xF504 0x7019      ADD      R0,R4,#+612
   \   000000C6   0x.... 0x....      BL       MclDqRef__RunningHandler
    631          
    632          	// Dq controllers Handler
    633          	MclDqCtrl__RunningHandler(&Mcl_DQ_Ctrl_IO, &Mcl_Params_Displ1->DQCtrlPrm);
   \   000000CA   0xF8D4 0x03F4      LDR      R0,[R4, #+1012]
   \   000000CE   0xF100 0x0144      ADD      R1,R0,#+68
   \   000000D2   0xF504 0x70E8      ADD      R0,R4,#+464
   \   000000D6   0x.... 0x....      BL       MclDqCtrl__RunningHandler
    634          
    635          	// Pwm Handler
    636          	MclPwm__RunningHandler(&Mcl_Pwm_IO, &MclPwm_Params);
   \   000000DA   0xF504 0x714E      ADD      R1,R4,#+824
   \   000000DE   0xF504 0x703C      ADD      R0,R4,#+752
   \   000000E2   0xE8BD 0x4010      POP      {R4,LR}
   \   000000E6   0x.... 0x....      B.W      MclPwm__RunningHandler
    637          }
    638          #ifdef PWM_DOUBLE_SLOT
    639          void Mcl__2ndRunningHandler(void)
    640          {
    641              // Dq controllers Handler
    642              MclDqCtrl__2ndRunningHandler(&Mcl_DQ_Ctrl_IO, &Mcl_Params_Displ1->DQCtrlPrm);
    643          
    644              // Pwm Handler
    645              MclPwm__RunningHandler(&Mcl_Pwm_IO, &MclPwm_Params);
    646          }
    647          #endif
    648          
    649          
    650          

   \                                 In section .text, align 2, keep-with-next
    651          void Mcl__StoppingReset(void)
    652          {
   \                     Mcl__StoppingReset: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    653              if (Mcl_Cs.flags.bit.params_loaded == 1)
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable46_7
   \   00000006   0xF894 0x00E4      LDRB     R0,[R4, #+228]
   \   0000000A   0x07C0             LSLS     R0,R0,#+31
   \   0000000C   0xD50B             BPL.N    ??Mcl__StoppingReset_0
    654              {
    655                  MclSpeedCtrl__ResetState(&MclSpeedCtrl_Params);
   \   0000000E   0xF504 0x7046      ADD      R0,R4,#+792
   \   00000012   0x.... 0x....      BL       MclSpeedCtrl__ResetState
    656                  MclObserver__ResetState(&Mcl_Observer_IO, &MclObserver_Params);
   \   00000016   0xF504 0x71CE      ADD      R1,R4,#+412
   \   0000001A   0xF504 0x70FE      ADD      R0,R4,#+508
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x.... 0x....      B.W      MclObserver__ResetState
    657              }
    658          }
   \                     ??Mcl__StoppingReset_0: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    659          
    660          
    661          
    662          

   \                                 In section .text, align 2, keep-with-next
    663          void Mcl__StoppingHandler(void)
    664          {
    665              Braking__ResetState();
   \                     Mcl__StoppingHandler: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable46_7
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0xF8C0 0x142C      STR      R1,[R0, #+1068]
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable55_1  ;; 0x3dcccccd
   \   0000000E   0xF8C0 0x143C      STR      R1,[R0, #+1084]
    666              Mcl_Cs.flags.bit.braking_active = 0;
   \   00000012   0xF8D0 0x10E4      LDR      R1,[R0, #+228]
   \   00000016   0xF021 0x0180      BIC      R1,R1,#0x80
   \   0000001A   0xF8C0 0x10E4      STR      R1,[R0, #+228]
    667              Mcl_Quantities.Speed_Rot = 0.0f;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x6701             STR      R1,[R0, #+112]
    668              Mcl_Quantities.Speed_Rot_Mech = 0.0f;
   \   00000022   0x6781             STR      R1,[R0, #+120]
    669              Mcl_Quantities.Torque = 0.0f;
   \   00000024   0xF8C0 0x10AC      STR      R1,[R0, #+172]
    670              Mcl_Quantities.Torque_Ref = 0.0f;
   \   00000028   0xF8C0 0x1090      STR      R1,[R0, #+144]
    671              Mcl_Quantities.Speed_Rot_Ref_Abs = 0.0f;
   \   0000002C   0x66C1             STR      R1,[R0, #+108]
    672              Mcl_Quantities.Speed_Rot_Mech_Abs = 0.0f;
   \   0000002E   0x6741             STR      R1,[R0, #+116]
    673              Mcl_IO.Speed_Rot_Ref = 0.0f;
   \   00000030   0xF8C0 0x1154      STR      R1,[R0, #+340]
    674          
    675              Mcl_Cs.flags.bit.wait_pll_engagement = 0;
   \   00000034   0xF8D0 0x10E4      LDR      R1,[R0, #+228]
   \   00000038   0xF021 0x0110      BIC      R1,R1,#0x10
   \   0000003C   0xF8C0 0x10E4      STR      R1,[R0, #+228]
    676          }
   \   00000040   0x4770             BX       LR               ;; return
    677          
    678          
    679          
    680          

   \                                 In section .text, align 2, keep-with-next
    681          void Mcl__ManualReset(void)
    682          {
    683              if (Mcl_Cs.flags.bit.params_loaded == 1)
   \                     Mcl__ManualReset: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable46_7
   \   00000004   0xF890 0x10E4      LDRB     R1,[R0, #+228]
   \   00000008   0x07C9             LSLS     R1,R1,#+31
   \   0000000A   0xD527             BPL.N    ??Mcl__ManualReset_0
    684              {
    685                  MclDqCtrl__ResetState(&Mcl_DQ_Ctrl_IO, &Mcl_Params_Displ1->Manual_Injection);
   \   0000000C   0xF8D0 0x21F4      LDR      R2,[R0, #+500]
   \   00000010   0xF8D0 0x13F4      LDR      R1,[R0, #+1012]
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0x6053             STR      R3,[R2, #+4]
   \   00000018   0xF501 0x71AC      ADD      R1,R1,#+344
   \   0000001C   0xF8D0 0x21F4      LDR      R2,[R0, #+500]
   \   00000020   0x6093             STR      R3,[R2, #+8]
   \   00000022   0x690A             LDR      R2,[R1, #+16]
   \   00000024   0xF8C0 0x22A8      STR      R2,[R0, #+680]
   \   00000028   0x694A             LDR      R2,[R1, #+20]
   \   0000002A   0xF8C0 0x22AC      STR      R2,[R0, #+684]
   \   0000002E   0xF8C0 0x32A0      STR      R3,[R0, #+672]
   \   00000032   0xF8C0 0x32A4      STR      R3,[R0, #+676]
   \   00000036   0x698A             LDR      R2,[R1, #+24]
   \   00000038   0xF8C0 0x228C      STR      R2,[R0, #+652]
   \   0000003C   0x69CA             LDR      R2,[R1, #+28]
   \   0000003E   0xF8C0 0x2290      STR      R2,[R0, #+656]
   \   00000042   0xF8C0 0x3288      STR      R3,[R0, #+648]
   \   00000046   0xF8C0 0x3284      STR      R3,[R0, #+644]
   \   0000004A   0x680A             LDR      R2,[R1, #+0]
   \   0000004C   0xF8C0 0x2294      STR      R2,[R0, #+660]
   \   00000050   0xED91 0x0A00      VLDR     S0,[R1, #0]
   \   00000054   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   00000058   0xED80 0x0AA6      VSTR     S0,[R0, #+664]
    686              }
    687          
    688              Manual_Inject_Level = 0;
   \                     ??Mcl__ManualReset_0: (+1)
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0xF8C0 0x140C      STR      R1,[R0, #+1036]
    689              Manual_Inject_Param = 0;
   \   00000062   0xF8C0 0x1410      STR      R1,[R0, #+1040]
    690              Manual_Pos_Reference = 0;
   \   00000066   0xF8C0 0x1414      STR      R1,[R0, #+1044]
    691          }
   \   0000006A   0x4770             BX       LR               ;; return
    692          
    693          
    694          
    695          

   \                                 In section .text, align 2, keep-with-next
    696          void Mcl__ManualHandler(void)
    697          {
    698              Manual_Injection_Control();
   \                     Mcl__ManualHandler: (+1)
   \   00000000   0x....             B.N      ??Manual_Injection_Control
    699          }
    700          
    701          
    702          

   \                                 In section .text, align 2, keep-with-next
    703          void Mcl__ResetAll(void)
    704          {
   \                     Mcl__ResetAll: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    705              Mcl__RunningReset();
   \   00000002   0x.... 0x....      BL       Mcl__RunningReset
    706              Mcl__StoppingReset();
   \   00000006   0x....             LDR.N    R4,??DataTable45
   \   00000008   0xF894 0x00E4      LDRB     R0,[R4, #+228]
   \   0000000C   0x07C0             LSLS     R0,R0,#+31
   \   0000000E   0xD515             BPL.N    ??Mcl__ResetAll_0
   \   00000010   0xF504 0x7046      ADD      R0,R4,#+792
   \   00000014   0x.... 0x....      BL       MclSpeedCtrl__ResetState
   \   00000018   0xF504 0x71CE      ADD      R1,R4,#+412
   \   0000001C   0xF504 0x70FE      ADD      R0,R4,#+508
   \   00000020   0x.... 0x....      BL       MclObserver__ResetState
    707              Mcl__ManualReset();
   \   00000024   0xF894 0x00E4      LDRB     R0,[R4, #+228]
   \   00000028   0x07C0             LSLS     R0,R0,#+31
   \   0000002A   0xD507             BPL.N    ??Mcl__ResetAll_0
   \   0000002C   0xF8D4 0x03F4      LDR      R0,[R4, #+1012]
   \   00000030   0xF500 0x71AC      ADD      R1,R0,#+344
   \   00000034   0xF504 0x70E8      ADD      R0,R4,#+464
   \   00000038   0x.... 0x....      BL       MclDqCtrl__ResetState
   \                     ??Mcl__ResetAll_0: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xF8C4 0x040C      STR      R0,[R4, #+1036]
   \   00000042   0xF8C4 0x0410      STR      R0,[R4, #+1040]
   \   00000046   0xF8C4 0x0414      STR      R0,[R4, #+1044]
    708          
    709              Mcl_Quantities.Speed_Rot = 0.0f;
   \   0000004A   0x6720             STR      R0,[R4, #+112]
    710              Mcl_Quantities.Speed_Rot_Mech = 0.0f;
   \   0000004C   0x67A0             STR      R0,[R4, #+120]
    711              Mcl_Quantities.Torque = 0.0f;
   \   0000004E   0xF8C4 0x00AC      STR      R0,[R4, #+172]
    712              Mcl_Quantities.Torque_Ref = 0.0f;
   \   00000052   0xF8C4 0x0090      STR      R0,[R4, #+144]
    713              Mcl_Quantities.Speed_Rot_Ref_Abs = 0.0f;
   \   00000056   0x66E0             STR      R0,[R4, #+108]
    714              Mcl_Quantities.Speed_Rot_Mech_Abs = 0.0f;
   \   00000058   0x6760             STR      R0,[R4, #+116]
    715              Mcl_IO.Speed_Rot_Ref = 0.0f;
   \   0000005A   0xF8C4 0x0154      STR      R0,[R4, #+340]
    716          
    717              Mcl_Cs.flags.bit.wait_pll_engagement = 0;
   \   0000005E   0xF8D4 0x00E4      LDR      R0,[R4, #+228]
   \   00000062   0xF020 0x0010      BIC      R0,R0,#0x10
   \   00000066   0xF8C4 0x00E4      STR      R0,[R4, #+228]
    718          
    719              Mcl_Quantities.Electrical_Power = 0.0f;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xF8C4 0x00D8      STR      R0,[R4, #+216]
    720          }
   \   00000070   0xBD10             POP      {R4,PC}          ;; return
    721          
    722          
    723          
    724          
    725          
    726          
    727          
    728          

   \                                 In section .text, align 4, keep-with-next
    729          BOOL_TYPE Mcl__GetDigital(MCL_READ_DIGITAL_DATA_ENUM read_bit)
    730          {
   \                     Mcl__GetDigital: (+1)
   \   00000000   0x4601             MOV      R1,R0
    731              BOOL_TYPE bit_value;
    732          
    733              bit_value = FALSE;
   \   00000002   0x2000             MOVS     R0,#+0
    734          
    735          
    736              switch(read_bit)
   \   00000004   0x2906             CMP      R1,#+6
   \   00000006   0xD900             BLS.N    ??Mcl__GetDigital_1
   \   00000008   0x4770             BX       LR
   \                     ??Mcl__GetDigital_1: (+1)
   \   0000000A   0xB410             PUSH     {R4}
   \   0000000C   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??Mcl__GetDigital_0:
   \   00000010   0x04 0x0B          DC8      0x4,0xB,0x53,0x12
   \              0x53 0x12    
   \   00000014   0x1A 0x32          DC8      0x1A,0x32,0x49,0x0
   \              0x49 0x00    
    737              {
    738                  case MCL_READ_STARTING_FINISHED:
    739                      if(Mcl_Starting_State == MCL_STARTING_FINISHED)
   \                     ??Mcl__GetDigital_2: (+1)
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable46_7
   \   0000001C   0xF891 0x1357      LDRB     R1,[R1, #+855]
   \   00000020   0x2903             CMP      R1,#+3
   \   00000022   0xD149             BNE.N    ??Mcl__GetDigital_3
    740                      {
    741                          bit_value = TRUE;
   \   00000024   0xE047             B.N      ??Mcl__GetDigital_4
    742                      }
    743                      break;
    744          
    745                  case MCL_READ_RUNNING_FINISHED:
    746                      if(Mcl_Flow_Manager & (1<<RUNNING_MIN_SPEED_STOP_REACHED))
   \                     ??Mcl__GetDigital_5: (+1)
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable46_7
   \   0000002A   0xF891 0x1358      LDRB     R1,[R1, #+856]
   \   0000002E   0x0709             LSLS     R1,R1,#+28
   \   00000030   0xD542             BPL.N    ??Mcl__GetDigital_3
    747                      {
    748                          bit_value = TRUE;
   \   00000032   0xE040             B.N      ??Mcl__GetDigital_4
    749                      }
    750                      break;
    751          
    752                  case MCL_READ_STOPPING_FINISHED:
    753                      bit_value = TRUE;
    754                      break;
    755          
    756                  case MCL_READ_PARAMETERS_LOADED:
    757                      if (Mcl_Cs.flags.bit.params_loaded == 1)
    758                      {
    759                          bit_value = TRUE;
    760                      }
    761                      else
    762                      {
    763                          bit_value = FALSE;
   \                     ??Mcl__GetDigital_6: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable46_7
   \   00000038   0xF890 0x00E4      LDRB     R0,[R0, #+228]
    764                      }
    765                      break;
    766          
    767                  case MCL_READ_LOCKED_ROTOR_STARTING:
    768                      if (Mcl_Cs.flags.bit.params_loaded == 1)
    769                      {
    770                          if(Mcl_Quantities.Elapsed_Time_After_Starting < Mcl_Params_Displ1->Running.Locked_Rotor_Starting_Or_Running)
    771                          {
    772                              if(Over_Torque_Time_Counter > Mcl_Params_Displ1->Running.Locked_Rotor_Starting_Threshold)
    773                              {
    774                                  Over_Torque_Time_Counter = 0;
    775                                  bit_value = TRUE;
    776                              }
    777                          }
    778                      }
    779                      break;
    780          
    781                  case MCL_READ_LOCKED_ROTOR_RUNNING:
    782                      if (Mcl_Cs.flags.bit.params_loaded == 1)
    783                      {
    784                          if(Mcl_Quantities.Elapsed_Time_After_Starting > Mcl_Params_Displ1->Running.Locked_Rotor_Starting_Or_Running)
    785                          {
    786                              if(Over_Torque_Time_Counter > Mcl_Params_Displ1->Running.Locked_Rotor_Running_Threshold)
    787                              {
    788                                  Over_Torque_Time_Counter = 0;
    789                                  bit_value = TRUE;
    790                              }
    791                          }
    792                      }
    793                      break;
    794          
    795          
    796                  case MCL_READ_MOTOR_NOT_CONNECTED_ERROR:
    797                      if(Mcl_Cs.flags.bit.resistance_est_error == 1)
    798                      {
    799                      	Mcl_Cs.flags.bit.resistance_est_error = 0;
    800                          bit_value = TRUE;
    801                      }
    802                      else
    803                      {
    804                          bit_value = FALSE;
    805                      }
    806                      break;
    807          
    808                  default:
    809                      // Left blank intentionally
    810                      break;
    811              }
    812          
    813              return bit_value;
   \   0000003C   0xBC10             POP      {R4}
   \   0000003E   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000042   0x4770             BX       LR
   \                     ??Mcl__GetDigital_7: (+1)
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable46_7
   \   00000048   0xF891 0x20E4      LDRB     R2,[R1, #+228]
   \   0000004C   0x07D2             LSLS     R2,R2,#+31
   \   0000004E   0xD533             BPL.N    ??Mcl__GetDigital_3
   \   00000050   0xF8D1 0x23F4      LDR      R2,[R1, #+1012]
   \   00000054   0xF8D1 0x30B8      LDR      R3,[R1, #+184]
   \   00000058   0xF8D2 0x40D4      LDR      R4,[R2, #+212]
   \   0000005C   0x42A3             CMP      R3,R4
   \   0000005E   0xBF3E             ITTT     CC 
   \   00000060   0xF8D2 0x20D8      LDRCC    R2,[R2, #+216]
   \   00000064   0xF8B1 0x137E      LDRHCC   R1,[R1, #+894]
   \   00000068   0x428A             CMPCC    R2,R1
   \   0000006A   0xD225             BCS.N    ??Mcl__GetDigital_3
   \   0000006C   0x....             LDR.N    R1,??DataTable46_7
   \   0000006E   0xF8A1 0x037E      STRH     R0,[R1, #+894]
   \   00000072   0xE020             B.N      ??Mcl__GetDigital_4
   \                     ??Mcl__GetDigital_8: (+1)
   \   00000074   0x....             LDR.N    R1,??DataTable46_7
   \   00000076   0xF891 0x20E4      LDRB     R2,[R1, #+228]
   \   0000007A   0x07D2             LSLS     R2,R2,#+31
   \   0000007C   0xD51C             BPL.N    ??Mcl__GetDigital_3
   \   0000007E   0xF8D1 0x23F4      LDR      R2,[R1, #+1012]
   \   00000082   0xF8D1 0x40B8      LDR      R4,[R1, #+184]
   \   00000086   0xF8D2 0x30D4      LDR      R3,[R2, #+212]
   \   0000008A   0x42A3             CMP      R3,R4
   \   0000008C   0xBF3E             ITTT     CC 
   \   0000008E   0xF8D2 0x20DC      LDRCC    R2,[R2, #+220]
   \   00000092   0xF8B1 0x137E      LDRHCC   R1,[R1, #+894]
   \   00000096   0x428A             CMPCC    R2,R1
   \   00000098   0xD20E             BCS.N    ??Mcl__GetDigital_3
   \   0000009A   0x....             LDR.N    R1,??DataTable46_7
   \   0000009C   0xF8A1 0x037E      STRH     R0,[R1, #+894]
   \   000000A0   0xE009             B.N      ??Mcl__GetDigital_4
   \                     ??Mcl__GetDigital_9: (+1)
   \   000000A2   0x....             LDR.N    R1,??DataTable46_7
   \   000000A4   0xF8D1 0x20E4      LDR      R2,[R1, #+228]
   \   000000A8   0xF3C2 0x1340      UBFX     R3,R2,#+5,#+1
   \   000000AC   0xB123             CBZ.N    R3,??Mcl__GetDigital_3
   \   000000AE   0xF022 0x0020      BIC      R0,R2,#0x20
   \   000000B2   0xF8C1 0x00E4      STR      R0,[R1, #+228]
   \                     ??Mcl__GetDigital_4: (+1)
   \   000000B6   0x2001             MOVS     R0,#+1
   \                     ??Mcl__GetDigital_3: (+1)
   \   000000B8   0xBC10             POP      {R4}
   \   000000BA   0x4770             BX       LR               ;; return
    814          }
    815          
    816          
    817          
    818          

   \                                 In section .text, align 4, keep-with-next
    819          BOOL_TYPE Mcl__SetDigital(MCL_SET_DIGITAL_DATA_ENUM set_bit)
    820          {
    821              BOOL_TYPE accepted;
    822          
    823              accepted = FALSE;
   \                     Mcl__SetDigital: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    824          
    825              switch(set_bit)
   \   00000002   0x2806             CMP      R0,#+6
   \   00000004   0xD831             BHI.N    ??Mcl__SetDigital_1
   \   00000006   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??Mcl__SetDigital_0:
   \   0000000A   0x04 0x0A          DC8      0x4,0xA,0x10,0x16
   \              0x10 0x16    
   \   0000000E   0x1C 0x22          DC8      0x1C,0x22,0x28,0x0
   \              0x28 0x00    
    826              {
    827                  case MCL_WRITE_STOP_COAST_DOWN_REQ:
    828                      MCL_SET_FLOW_MANAGER(STOP_COAST_DOWN_REQUESTED);
   \                     ??Mcl__SetDigital_2: (+1)
   \   00000012   0x....             LDR.N    R0,??DataTable46_7
   \   00000014   0xF890 0x1358      LDRB     R1,[R0, #+856]
   \   00000018   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000001C   0xE022             B.N      ??Mcl__SetDigital_3
    829          
    830                      accepted = TRUE;
    831                      break;
    832          
    833          
    834                  case MCL_WRITE_STOP_LOWERS_ON_REQ:
    835                      MCL_SET_FLOW_MANAGER(STOP_LOWERS_ON_REQUESTED);
   \                     ??Mcl__SetDigital_4: (+1)
   \   0000001E   0x....             LDR.N    R0,??DataTable46_7
   \   00000020   0xF890 0x1358      LDRB     R1,[R0, #+856]
   \   00000024   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000028   0xE01C             B.N      ??Mcl__SetDigital_3
    836          
    837                      accepted = TRUE;
    838                      break;
    839          
    840          
    841                  case MCL_WRITE_STOP_REQ:
    842                      MCL_SET_FLOW_MANAGER(STOP_REQUESTED);
   \                     ??Mcl__SetDigital_5: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable46_7
   \   0000002C   0xF890 0x1358      LDRB     R1,[R0, #+856]
   \   00000030   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000034   0xE016             B.N      ??Mcl__SetDigital_3
    843          
    844                      accepted = TRUE;
    845                      break;
    846          
    847          
    848                  case MCL_WRITE_INJECTION_DC_VOLTAGE:
    849                      MCL_SET_FLOW_MANAGER(MANUAL_DC_VOLT_INJECTION);
   \                     ??Mcl__SetDigital_6: (+1)
   \   00000036   0x....             LDR.N    R0,??DataTable46_7
   \   00000038   0xF890 0x1358      LDRB     R1,[R0, #+856]
   \   0000003C   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000040   0xE010             B.N      ??Mcl__SetDigital_3
    850          
    851                      accepted = TRUE;
    852                      break;
    853          
    854          
    855                  case MCL_WRITE_INJECTION_AC_VOLTAGE:
    856                      MCL_SET_FLOW_MANAGER(MANUAL_AC_VOLT_INJECTION);
   \                     ??Mcl__SetDigital_7: (+1)
   \   00000042   0x....             LDR.N    R0,??DataTable46_7
   \   00000044   0xF890 0x1358      LDRB     R1,[R0, #+856]
   \   00000048   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000004C   0xE00A             B.N      ??Mcl__SetDigital_3
    857          
    858                      accepted = TRUE;
    859                      break;
    860          
    861          
    862                  case MCL_WRITE_INJECTION_DC_CURRENT:
    863                      MCL_SET_FLOW_MANAGER(MANUAL_DC_CURRENT_INJECTION);
   \                     ??Mcl__SetDigital_8: (+1)
   \   0000004E   0x....             LDR.N    R0,??DataTable46_7
   \   00000050   0xF890 0x1358      LDRB     R1,[R0, #+856]
   \   00000054   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000058   0xE004             B.N      ??Mcl__SetDigital_3
    864          
    865                      accepted = TRUE;
    866                      break;
    867          
    868          
    869                  case MCL_WRITE_INJECTION_AC_CURRENT:
    870                      MCL_SET_FLOW_MANAGER(MANUAL_AC_CURRENT_INJECTION);
   \                     ??Mcl__SetDigital_9: (+1)
   \   0000005A   0x....             LDR.N    R0,??DataTable46_7
   \   0000005C   0xF890 0x1358      LDRB     R1,[R0, #+856]
   \   00000060   0xF041 0x0180      ORR      R1,R1,#0x80
   \                     ??Mcl__SetDigital_3: (+1)
   \   00000064   0xF880 0x1358      STRB     R1,[R0, #+856]
    871          
    872                      accepted = TRUE;
   \   00000068   0x2101             MOVS     R1,#+1
    873                      break;
    874          
    875                  default:
    876                      // Left blank intentionally
    877                      break;
    878              }
    879          
    880              return accepted;
   \                     ??Mcl__SetDigital_1: (+1)
   \   0000006A   0x4608             MOV      R0,R1
   \   0000006C   0x4770             BX       LR               ;; return
    881          }
    882          
    883          

   \                                 In section .text, align 2, keep-with-next
    884          BOOL_TYPE Mcl__ResetDigital(MCL_SET_DIGITAL_DATA_ENUM reset_bit)
    885          {
    886              BOOL_TYPE accepted;
    887          
    888              accepted = FALSE;
   \                     Mcl__ResetDigital: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    889          
    890              switch(reset_bit)
   \   00000002   0x2807             CMP      R0,#+7
   \   00000004   0xD107             BNE.N    ??Mcl__ResetDigital_0
    891              {
    892                  case MCL_WRITE_ALL_INJECTION_METHOD:
    893                      MCL_CLR_FLOW_MANAGER(MANUAL_DC_VOLT_INJECTION);
    894                      MCL_CLR_FLOW_MANAGER(MANUAL_AC_VOLT_INJECTION);
    895                      MCL_CLR_FLOW_MANAGER(MANUAL_DC_CURRENT_INJECTION);
    896                      MCL_CLR_FLOW_MANAGER(MANUAL_AC_CURRENT_INJECTION);
   \   00000006   0x....             LDR.N    R0,??DataTable46_7
   \   00000008   0xF890 0x1358      LDRB     R1,[R0, #+856]
   \   0000000C   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000010   0xF880 0x1358      STRB     R1,[R0, #+856]
    897          
    898                      accepted = TRUE;
   \   00000014   0x2101             MOVS     R1,#+1
    899                      break;
    900          
    901          
    902          //        case MCL_WRITE_INJECTION_DC_CURRENT:
    903          //            MCL_SET_FLOW_MANAGER(MANUAL_DC_CURRENT_INJECTION);
    904          //            break;
    905          //
    906          //        case MCL_WRITE_INJECTION_AC_CURRENT:
    907          //            MCL_SET_FLOW_MANAGER(MANUAL_AC_CURRENT_INJECTION);
    908          //            break;
    909          
    910                  default:
    911                      // Left blank intentionally
    912                      break;
    913              }
    914          
    915              return accepted;
   \                     ??Mcl__ResetDigital_0: (+1)
   \   00000016   0x4608             MOV      R0,R1
   \   00000018   0x4770             BX       LR               ;; return
    916          }
    917          
    918          
    919          
    920          
    921          

   \                                 In section .text, align 4, keep-with-next
    922          BOOL_TYPE Mcl__SetAnalog(MCL_AO_TYPE write_data, sint32 value)
    923          {
   \                     Mcl__SetAnalog: (+1)
   \   00000000   0xEE00 0x1A10      VMOV     S0,R1
    924              BOOL_TYPE accepted;
    925          
    926              accepted = FALSE;
   \   00000004   0x2100             MOVS     R1,#+0
    927          
    928              switch(write_data)
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD005             BEQ.N    ??Mcl__SetAnalog_0
   \   0000000A   0x2805             CMP      R0,#+5
   \   0000000C   0xD019             BEQ.N    ??Mcl__SetAnalog_1
   \   0000000E   0x2807             CMP      R0,#+7
   \   00000010   0xD032             BEQ.N    ??Mcl__SetAnalog_2
    929              {
    930          
    931                  case MCL_AO_SPEED_LOOP_PROP_GAIN_S16:
    932                      break;
    933          
    934                  case MCL_AO_SPEED_LOOP_INT_GAIN_S16:
    935                      break;
    936          
    937                  case MCL_AO_SPEED_LOOP_GAIN_TABLE_INDEX:
    938                      accepted = MclSpeedCtrl__SetSpeedGainIndex(value, &MclSpeedCtrl_Params);
    939                      break;
    940          
    941                  case MCL_AO_SPEED_FIR_TAPS_TABLE_INDEX:
    942                      break;
    943          
    944                  case MCL_AO_SOFTSTART_COUNTER_INDEX:
    945                      break;
    946          
    947                  case MCL_AO_SPEED_LIMIT_INDEX:
    948                  	accepted = MclSpeedCtrl__SetSpeedRegLimit(value);
    949                      break;
    950          
    951                  case MCL_AO_ADD_DELTA_SPEED_REF_S16:
    952                      accepted = MclSpeedCtrl__SetDeltaSpeedRef(value, &Mcl_Speed_Ctrl_IO);
    953                      break;
    954          
    955          
    956                  default:
    957                      // Left blank intentionally
    958                      break;
    959              }
    960          
    961          
    962              return accepted;
   \   00000012   0x4608             MOV      R0,R1
   \   00000014   0x4770             BX       LR
   \                     ??Mcl__SetAnalog_0: (+1)
   \   00000016   0x....             LDR.N    R0,??DataTable46_7
   \   00000018   0xF8D0 0x2318      LDR      R2,[R0, #+792]
   \   0000001C   0xEE10 0x3A10      VMOV     R3,S0
   \   00000020   0xEB02 0x1203      ADD      R2,R2,R3, LSL #+4
   \   00000024   0xEDD2 0x0A09      VLDR     S1,[R2, #+36]
   \   00000028   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   0000002C   0xEEF1 0xFA10      FMSTAT   
   \   00000030   0xD047             BEQ.N    ??Mcl__SetAnalog_3
   \   00000032   0xEE10 0x1A10      VMOV     R1,S0
   \   00000036   0xF880 0x135F      STRB     R1,[R0, #+863]
   \   0000003A   0x2150             MOVS     R1,#+80
   \   0000003C   0xF8A0 0x1384      STRH     R1,[R0, #+900]
   \   00000040   0xE03E             B.N      ??Mcl__SetAnalog_4
   \                     ??Mcl__SetAnalog_1: (+1)
   \   00000042   0xEEBA 0x0AC8      VCVT.F32.S32 S0,S0,#+16
   \   00000046   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000004A   0x....             LDR.N    R0,??DataTable46_7
   \   0000004C   0xEEF1 0xFA10      FMSTAT   
   \   00000050   0xD90D             BLS.N    ??Mcl__SetAnalog_5
   \   00000052   0xF8D0 0x1488      LDR      R1,[R0, #+1160]
   \   00000056   0xEE00 0x1A90      VMOV     S1,R1
   \   0000005A   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   0000005E   0xEEF1 0xFA10      FMSTAT   
   \   00000062   0xD404             BMI.N    ??Mcl__SetAnalog_5
   \   00000064   0xF200 0x408C      ADDW     R0,R0,#+1164
   \   00000068   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   0000006C   0xE028             B.N      ??Mcl__SetAnalog_4
   \                     ??Mcl__SetAnalog_5: (+1)
   \   0000006E   0xF8D0 0x1488      LDR      R1,[R0, #+1160]
   \   00000072   0xF8C0 0x148C      STR      R1,[R0, #+1164]
   \   00000076   0xE023             B.N      ??Mcl__SetAnalog_4
   \                     ??Mcl__SetAnalog_2: (+1)
   \   00000078   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000007C   0x....             LDR.N    R0,??DataTable46_7
   \   0000007E   0xF8D0 0x2308      LDR      R2,[R0, #+776]
   \   00000082   0xEDDF 0x....      VLDR.W   S1,??DataTable46_2  ;; 0x35d67750
   \   00000086   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000008A   0xEDD2 0x0A00      VLDR     S1,[R2, #0]
   \   0000008E   0xEE70 0x0A20      VADD.F32 S1,S0,S1
   \   00000092   0xEEF0 0x0AE0      VABS.F32 S1,S1
   \   00000096   0xED9F 0x....      VLDR.W   S2,??DataTable46_4  ;; 0x469ab001
   \   0000009A   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   0000009E   0xEEF1 0xFA10      FMSTAT   
   \   000000A2   0xD50E             BPL.N    ??Mcl__SetAnalog_3
   \   000000A4   0xED9F 0x....      VLDR.W   S2,??DataTable46_5  ;; 0x42c80000
   \   000000A8   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   000000AC   0xEEF1 0xFA10      FMSTAT   
   \   000000B0   0xDB07             BLT.N    ??Mcl__SetAnalog_3
   \   000000B2   0xF200 0x4180      ADDW     R1,R0,#+1152
   \   000000B6   0xED81 0x0A00      VSTR     S0,[R1, #0]
   \   000000BA   0x2114             MOVS     R1,#+20
   \   000000BC   0xF8A0 0x1386      STRH     R1,[R0, #+902]
   \                     ??Mcl__SetAnalog_4: (+1)
   \   000000C0   0x2101             MOVS     R1,#+1
   \                     ??Mcl__SetAnalog_3: (+1)
   \   000000C2   0x4608             MOV      R0,R1
   \   000000C4   0x4770             BX       LR               ;; return
    963          }
    964          
    965          
    966          
    967          
    968          //---------------------------------------------------------------------------------------------------------------------
    969          /**
    970           *  @brief      Write the address of mcl parameters.
    971           *  @details
    972           *
    973           * @return  TRUE - value accepted
    974           *          FALSE - value denied - default answer.
    975           */
    976          

   \                                 In section .text, align 2, keep-with-next
    977          BOOL_TYPE Mcl__SetParams(void*  mcl_params_address)
    978          {
   \                     Mcl__SetParams: (+1)
   \   00000000   0x4601             MOV      R1,R0
    979              BOOL_TYPE ret_val = FALSE;
   \   00000002   0x2000             MOVS     R0,#+0
    980          
    981              if (mcl_params_address != NULL)
   \   00000004   0xB901             CBNZ.N   R1,??Mcl__SetParams_0
   \   00000006   0x4770             BX       LR
    982              {
    983                  // TODO: to be consistent with the MciParametersLoader
    984                  Mcl_Params_Displ1 = (MCL_PARAMS_DISPL1_TYPE*) (*(addr_t*)mcl_params_address);
   \                     ??Mcl__SetParams_0: (+1)
   \   00000008   0xB500             PUSH     {LR}
   \   0000000A   0xB081             SUB      SP,SP,#+4
   \   0000000C   0x....             LDR.N    R0,??DataTable45
   \   0000000E   0x680A             LDR      R2,[R1, #+0]
   \   00000010   0xF8C0 0x23F4      STR      R2,[R0, #+1012]
    985                  Mcl_Params_Displ3 = (MCL_PARAMS_DISPL3_TYPE*) (*((addr_t*)mcl_params_address + 1));
   \   00000014   0x684A             LDR      R2,[R1, #+4]
   \   00000016   0xF8C0 0x23F8      STR      R2,[R0, #+1016]
    986                  Mcl_Params_Displ4 = (MCL_PARAMS_DISPL4_TYPE*) (*((addr_t*)mcl_params_address + 2));
   \   0000001A   0x688A             LDR      R2,[R1, #+8]
   \   0000001C   0xF8C0 0x23FC      STR      R2,[R0, #+1020]
    987                  Mcl_Params_Displ9 = (MCL_PARAMS_DISPL9_TYPE*) (*((addr_t*)mcl_params_address + 3));
   \   00000020   0x68CA             LDR      R2,[R1, #+12]
   \   00000022   0xF8C0 0x2400      STR      R2,[R0, #+1024]
    988                  Mcl_Params_Displ10= (MCL_PARAMS_DISPL10_TYPE*)(*((addr_t*)mcl_params_address + 4));
   \   00000026   0x690A             LDR      R2,[R1, #+16]
   \   00000028   0xF8C0 0x2404      STR      R2,[R0, #+1028]
    989                  Mcl_Params_Displ11= (MCL_PARAMS_DISPL11_TYPE*)(*((addr_t*)mcl_params_address + 5));
   \   0000002C   0x6949             LDR      R1,[R1, #+20]
   \   0000002E   0xF8C0 0x1408      STR      R1,[R0, #+1032]
    990          
    991                  Mcl_Cs.flags.bit.params_ready = 1;
   \   00000032   0xF8D0 0x10E4      LDR      R1,[R0, #+228]
   \   00000036   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000003A   0xF8C0 0x10E4      STR      R1,[R0, #+228]
    992          
    993                  Mcl__ParamsInitialize();
   \   0000003E   0x.... 0x....      BL       Mcl__ParamsInitialize
    994          
    995                  ret_val = TRUE;
   \   00000042   0x2001             MOVS     R0,#+1
    996              }
    997          
    998              return ret_val;
   \   00000044   0xB001             ADD      SP,SP,#+4
   \   00000046   0xBD00             POP      {PC}             ;; return
    999          }
   1000          
   1001          
   1002          
   1003          
   1004          //---------------------------------------------------------------------------------------------------------------------
   1005          /**
   1006           *  @brief     Reset Foc quantities
   1007           *  @param[in]
   1008           *  @param[out]
   1009           *  @param[in]
   1010           *  @return
   1011           */

   \                                 In section .text, align 2, keep-with-next
   1012          void ResetQuantities(void)
   1013          {
   1014              Mcl_Quantities.Elapsed_Time_After_Starting = 0;
   \                     ResetQuantities: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable59_3
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0xF8C0 0x10B8      STR      R1,[R0, #+184]
   1015          
   1016              Mcl_IO.All_Devices_Off = FALSE;
   \   0000000A   0xF880 0x118D      STRB     R1,[R0, #+397]
   1017              Mcl_IO.Lowers_On = FALSE;
   \   0000000E   0xF880 0x118C      STRB     R1,[R0, #+396]
   1018          
   1019              Mcl_Cs.flags.bit.wrong_speed_direction = 0;
   1020              Mcl_Cs.flags.bit.stopped_ramp = 0;
   \   00000012   0xF8D0 0x10E4      LDR      R1,[R0, #+228]
   \   00000016   0xF421 0x7101      BIC      R1,R1,#0x204
   \   0000001A   0xF8C0 0x10E4      STR      R1,[R0, #+228]
   1021          }
   \   0000001E   0x4770             BX       LR               ;; return
   1022          
   1023          
   1024          
   1025          

   \                                 In section .text, align 2, keep-with-next
   1026          void Running_Parallel_5msHandler(void)
   1027          {
   1028              static uint16 local_debouncer;
   1029              float32 temp;
                             ^
Warning[Pe177]: variable "temp" was declared but never referenced
   1030          
   1031              // If requested to stop and the minimum speed is already reached...
   1032              if(Mcl_Flow_Manager & RUNNING_FINISHED_FLOW_FLAGS)
   \                     ??Running_Parallel_5msHandler: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable59_3
   \   00000004   0xF8B0 0x1380      LDRH     R1,[R0, #+896]
   \   00000008   0xF890 0x2358      LDRB     R2,[R0, #+856]
   \   0000000C   0x2307             MOVS     R3,#+7
   \   0000000E   0x421A             TST      R2,R3
   \   00000010   0xD07B             BEQ.N    ??Running_Parallel_5msHandler_1
   1033              {
   1034                  if(Mcl_Flow_Manager & ((MCL_FLOW_MANAGER_TYPE)1<<STOP_REQUESTED))
   \   00000012   0x0793             LSLS     R3,R2,#+30
   \   00000014   0xD518             BPL.N    ??Running_Parallel_5msHandler_2
   1035                  {
   1036                      if(Mcl_Quantities.Speed_Rot_Mech_Abs < Mcl_Params_Displ1->Running.Min_Speed_Before_Stopping)
   \   00000016   0xF8D0 0x33F4      LDR      R3,[R0, #+1012]
   \   0000001A   0xED90 0x0A1D      VLDR     S0,[R0, #+116]
   \   0000001E   0xEDD3 0x0A32      VLDR     S1,[R3, #+200]
   \   00000022   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000026   0xEEF1 0xFA10      FMSTAT   
   \   0000002A   0xD56E             BPL.N    ??Running_Parallel_5msHandler_1
   1037                      {
   1038                          if(local_debouncer)
   \   0000002C   0x2900             CMP      R1,#+0
   \   0000002E   0xD156             BNE.N    ??Running_Parallel_5msHandler_3
   1039                          {
   1040                              local_debouncer--;
   1041                          }
   1042                          else
   1043                          {
   1044                              MCL_CLR_FLOW_MANAGER(STOP_LOWERS_ON_REQUESTED);
   1045                              MCL_CLR_FLOW_MANAGER(STOP_COAST_DOWN_REQUESTED);
   1046                              MCL_CLR_FLOW_MANAGER(STOP_REQUESTED);
   1047          
   1048                              MCL_SET_FLOW_MANAGER(RUNNING_MIN_SPEED_STOP_REACHED);
   1049                          }
   1050                      }
   1051                      else
   1052                      {
   1053                          local_debouncer = Mcl_Params_Displ1->Running.Debounce_Off_Running_Finished;
   1054                      }
   1055                  }
   1056                  else if(Mcl_Flow_Manager & ((MCL_FLOW_MANAGER_TYPE)1<<STOP_COAST_DOWN_REQUESTED))
   1057                  {
   1058                      if( Mcl_IO.All_Devices_Off == FALSE )
   1059                      {
   1060                          if(Mcl_Quantities.Speed_Rot_Mech_Abs < Mcl_Params_Displ1->Running.Min_Speed_Before_All_Devices_Off)
   1061                          {
   1062                              if(local_debouncer)
   1063                              {
   1064                                  local_debouncer--;
   1065                              }
   1066                              else
   1067                              {
   1068                                  local_debouncer = Mcl_Params_Displ1->Running.Time_All_Dev_Below_Min_Speed;
   1069          
   1070                                  Mcl_IO.All_Devices_Off = TRUE;
   1071                                  Mcl_IO.Lowers_On = FALSE;
   1072                              }
   1073                          }
   1074                          else
   1075                          {
   1076                              Mcl_IO.Lowers_On = TRUE;
   1077          
   1078                              local_debouncer = Mcl_Params_Displ1->Running.Debounce_Off_Running_Finished;
   1079                          }
   1080                      }
   1081                      else
   1082                      {
   1083                          if(local_debouncer)
   1084                          {
   1085                              local_debouncer--;
   1086                          }
   1087                          else
   1088                          {
   1089          
   1090                              MCL_CLR_FLOW_MANAGER(STOP_LOWERS_ON_REQUESTED);
   1091                              MCL_CLR_FLOW_MANAGER(STOP_COAST_DOWN_REQUESTED);
   1092                              MCL_CLR_FLOW_MANAGER(STOP_REQUESTED);
   1093          
   1094                              Mcl_IO.Lowers_On = FALSE;
   1095                              Mcl_IO.All_Devices_Off = FALSE;
   1096          
   1097                              MCL_SET_FLOW_MANAGER(RUNNING_MIN_SPEED_STOP_REACHED);
   1098          
   1099                          }
   1100                      }
   1101                  }
   1102                  else // default --> if(Mcl_Flow_Manager & ((MCL_FLOW_MANAGER_TYPE)1<<STOP_LOWERS_ON_REQUESTED))
   1103                  {
   1104                      Mcl_IO.Lowers_On = TRUE;
   1105          
   1106                      if(Mcl_Quantities.Speed_Rot_Mech_Abs < Mcl_Params_Displ1->Running.Min_Speed_Before_Stopping)
   1107                      {
   1108                          if(local_debouncer)
   1109                          {
   1110                              local_debouncer--;
   1111                          }
   1112                          else
   1113                          {
   1114                              MCL_CLR_FLOW_MANAGER(STOP_LOWERS_ON_REQUESTED);
   1115                              MCL_CLR_FLOW_MANAGER(STOP_COAST_DOWN_REQUESTED);
   1116                              MCL_CLR_FLOW_MANAGER(STOP_REQUESTED);
   1117          
   1118                              Mcl_IO.Lowers_On = FALSE;
   1119          
   1120                              MCL_SET_FLOW_MANAGER(RUNNING_MIN_SPEED_STOP_REACHED);
   \   00000030   0xF8A0 0x1380      STRH     R1,[R0, #+896]
   \   00000034   0xF002 0x02F8      AND      R2,R2,#0xF8
   \   00000038   0xF042 0x0208      ORR      R2,R2,#0x8
   1121                          }
   1122                      }
   1123                      else
   1124                      {
   1125                          local_debouncer = Mcl_Params_Displ1->Running.Debounce_Off_Running_Finished;
   1126                      }
   1127                  }
   1128              }
   1129              else
   1130              {
   1131                  local_debouncer = Mcl_Params_Displ1->Running.Debounce_Off_Running_Finished;
   1132              }
   1133          
   1134          
   1135          
   1136              ////////////////////////////////////////////////////////////////////////////////////////
   1137              ////////////////////////////////////////////////////////////////////////////////////////
   1138              ////////////////////////////////////////////////////////////////////////////////////////
   1139              // Over torque detection
   1140          
   1141          //    // If motor is started...
   1142          //    if(Mcl_Quantities.Elapsed_Time_After_Starting)
   1143          //    {
   1144          //        temp  = Mcl_IO.Is_ABC.A*Mcl_IO.Is_ABC.A;
   1145          //        temp += Mcl_IO.Is_ABC.B*Mcl_IO.Is_ABC.B;
   1146          //        temp += Mcl_IO.Is_ABC.C*Mcl_IO.Is_ABC.C;
   1147          //
   1148          //        // If observed torque hit limit...
   1149          //        if((temp > Mcl_Params_Displ1->Running.Locked_Rotor_Current_Threshold) || (Mcl_Cs.flags.bit.wait_pll_engagement == 1))
   1150          //        {
   1151          //            if(Over_Torque_Time_Counter < MAX_U16)
   1152          //            {
   1153          //                Over_Torque_Time_Counter++;         // increment counter
   1154          //            }
   1155          //        }
   1156          //        else
   1157          //        {
   1158          //            if(Over_Torque_Time_Counter)
   1159          //            {
   1160          //                Over_Torque_Time_Counter--;         // decrement counter
   1161          //            }
   1162          //        }
   1163          //    }
   1164          //    else // else motor is stop
   1165              {
   1166                  Over_Torque_Time_Counter = 0;               // reset counter
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0xF880 0x2358      STRB     R2,[R0, #+856]
   \   00000042   0xF8A0 0x137E      STRH     R1,[R0, #+894]
   1167              }
   1168          }
   \   00000046   0x4770             BX       LR
   \                     ??Running_Parallel_5msHandler_2: (+1)
   \   00000048   0x07D3             LSLS     R3,R2,#+31
   \   0000004A   0xD539             BPL.N    ??Running_Parallel_5msHandler_4
   \   0000004C   0xF890 0x318D      LDRB     R3,[R0, #+397]
   \   00000050   0xBB23             CBNZ.N   R3,??Running_Parallel_5msHandler_5
   \   00000052   0xF8D0 0x23F4      LDR      R2,[R0, #+1012]
   \   00000056   0xED90 0x0A1D      VLDR     S0,[R0, #+116]
   \   0000005A   0xEDD2 0x0A31      VLDR     S1,[R2, #+196]
   \   0000005E   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000062   0xEEF1 0xFA10      FMSTAT   
   \   00000066   0xD50E             BPL.N    ??Running_Parallel_5msHandler_6
   \   00000068   0xBBC9             CBNZ.N   R1,??Running_Parallel_5msHandler_3
   \   0000006A   0xF8D2 0x10D0      LDR      R1,[R2, #+208]
   \   0000006E   0xF8A0 0x1380      STRH     R1,[R0, #+896]
   \   00000072   0x2201             MOVS     R2,#+1
   \   00000074   0xF880 0x218D      STRB     R2,[R0, #+397]
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0x2200             MOVS     R2,#+0
   \   0000007C   0xF880 0x218C      STRB     R2,[R0, #+396]
   \   00000080   0xF8A0 0x137E      STRH     R1,[R0, #+894]
   \   00000084   0x4770             BX       LR
   \                     ??Running_Parallel_5msHandler_6: (+1)
   \   00000086   0x2101             MOVS     R1,#+1
   \   00000088   0xF880 0x118C      STRB     R1,[R0, #+396]
   \   0000008C   0xF8D2 0x10CC      LDR      R1,[R2, #+204]
   \   00000090   0xF8A0 0x1380      STRH     R1,[R0, #+896]
   \   00000094   0x2100             MOVS     R1,#+0
   \   00000096   0xF8A0 0x137E      STRH     R1,[R0, #+894]
   \   0000009A   0x4770             BX       LR
   \                     ??Running_Parallel_5msHandler_5: (+1)
   \   0000009C   0xB9F9             CBNZ.N   R1,??Running_Parallel_5msHandler_3
   \   0000009E   0xF8A0 0x1380      STRH     R1,[R0, #+896]
   \   000000A2   0xF002 0x02F8      AND      R2,R2,#0xF8
   \   000000A6   0x2300             MOVS     R3,#+0
   \   000000A8   0xF042 0x0208      ORR      R2,R2,#0x8
   \   000000AC   0x2100             MOVS     R1,#+0
   \   000000AE   0xF880 0x318C      STRB     R3,[R0, #+396]
   \   000000B2   0xF880 0x318D      STRB     R3,[R0, #+397]
   \   000000B6   0xF880 0x2358      STRB     R2,[R0, #+856]
   \   000000BA   0xF8A0 0x137E      STRH     R1,[R0, #+894]
   \   000000BE   0x4770             BX       LR
   \                     ??Running_Parallel_5msHandler_4: (+1)
   \   000000C0   0x2301             MOVS     R3,#+1
   \   000000C2   0xF880 0x318C      STRB     R3,[R0, #+396]
   \   000000C6   0xED90 0x0A1D      VLDR     S0,[R0, #+116]
   \   000000CA   0xF8D0 0x33F4      LDR      R3,[R0, #+1012]
   \   000000CE   0xEDD3 0x0A32      VLDR     S1,[R3, #+200]
   \   000000D2   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   000000D6   0xEEF1 0xFA10      FMSTAT   
   \   000000DA   0xD516             BPL.N    ??Running_Parallel_5msHandler_1
   \   000000DC   0xB131             CBZ.N    R1,??Running_Parallel_5msHandler_7
   \                     ??Running_Parallel_5msHandler_3: (+1)
   \   000000DE   0x1E49             SUBS     R1,R1,#+1
   \   000000E0   0xF8A0 0x1380      STRH     R1,[R0, #+896]
   \   000000E4   0x2100             MOVS     R1,#+0
   \   000000E6   0xF8A0 0x137E      STRH     R1,[R0, #+894]
   \   000000EA   0x4770             BX       LR
   \                     ??Running_Parallel_5msHandler_7: (+1)
   \   000000EC   0xF8A0 0x1380      STRH     R1,[R0, #+896]
   \   000000F0   0xF002 0x02F8      AND      R2,R2,#0xF8
   \   000000F4   0x2300             MOVS     R3,#+0
   \   000000F6   0xF042 0x0208      ORR      R2,R2,#0x8
   \   000000FA   0x2100             MOVS     R1,#+0
   \   000000FC   0xF880 0x318C      STRB     R3,[R0, #+396]
   \   00000100   0xF880 0x2358      STRB     R2,[R0, #+856]
   \   00000104   0xF8A0 0x137E      STRH     R1,[R0, #+894]
   \   00000108   0x4770             BX       LR
   \                     ??Running_Parallel_5msHandler_1: (+1)
   \   0000010A   0xF8D0 0x13F4      LDR      R1,[R0, #+1012]
   \   0000010E   0xF8D1 0x10CC      LDR      R1,[R1, #+204]
   \   00000112   0xF8A0 0x1380      STRH     R1,[R0, #+896]
   \   00000116   0x2100             MOVS     R1,#+0
   \   00000118   0xF8A0 0x137E      STRH     R1,[R0, #+894]
   \   0000011C   0x4770             BX       LR               ;; return
   1169          
   1170          
   1171          

   \                                 In section .text, align 4, keep-with-next
   1172          BOOL_TYPE Manual_Injection_Control(void)
   1173          {
   \                     ??Manual_Injection_Control: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1174          	float32 temp_level_target;
   1175          	float32 temp_level_rate;
   1176          	float32 temp_param_target;
   1177          	float32 temp_param_rate;
   1178          	DQ_COOR_SYST_F_TYPE manual_dq;
   1179          	SIN_COS_F_TYPE manual_sin_cos;
   1180          
   1181          	Mcl_Quantities.Elapsed_Time_After_Starting = 0;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable59_3
   \   00000006   0xED2D 0x8B02      VPUSH    {D8}
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF8C4 0x00B8      STR      R0,[R4, #+184]
   \   00000010   0xB082             SUB      SP,SP,#+8
   1182          
   1183          	// Input Processing Handler
   1184          	MclInputProc__RunningHandler(&Mcl_Input_Proc_IO);
   \   00000012   0xF504 0x7011      ADD      R0,R4,#+580
   \   00000016   0x.... 0x....      BL       MclInputProc__RunningHandler
   1185          
   1186          	// Observer Handler
   1187          	MclObserver__RunningHandler(&Mcl_Observer_IO, &MclObserver_Params);
   \   0000001A   0xF504 0x71CE      ADD      R1,R4,#+412
   \   0000001E   0xF504 0x70FE      ADD      R0,R4,#+508
   \   00000022   0x.... 0x....      BL       MclObserver__RunningHandler
   1188          
   1189          	Mcl_DQ_Ctrl_IO.Sin_Cos = &manual_sin_cos;
   \   00000026   0xA800             ADD      R0,SP,#+0
   \   00000028   0xF8C4 0x01E0      STR      R0,[R4, #+480]
   1190          
   1191          
   1192          	// Check if AC or DC voltage was selected
   1193          	if(Mcl_Flow_Manager & MANUAL_VOLTAGE_INJECTION_FLAGS)
   \   0000002C   0x2130             MOVS     R1,#+48
   \   0000002E   0xF894 0x0358      LDRB     R0,[R4, #+856]
   \   00000032   0x4208             TST      R0,R1
   \   00000034   0xF000 0x809E      BEQ.W    ??Manual_Injection_Control_1
   1194          	{
   1195          
   1196          		// Variables and its meaning in MANUAL_AC_VOLT_INJECTION
   1197          		// Mcl_IO.Manual_Injection_Level            - define the voltage
   1198          		// Mcl_IO.Manual_Injection_Level_Rate       - define the voltage rate in volts/s
   1199          		// Mcl_IO.Manual_Injection_Param            - define the frequency
   1200          		// Mcl_IO.Manual_Injection_Param_Rate       - define the frequency rate in Hz/s
   1201          
   1202          		// Variables and its meaning in MANUAL_DC_VOLT_INJECTION
   1203          		// Mcl_IO.Manual_Injection_Level            - define the voltage
   1204          		// Mcl_IO.Manual_Injection_Level_Rate       - define the voltage rate in volts/s
   1205          		// Mcl_IO.Manual_Injection_Param            - define position of the voltage vector in degrees
   1206          		// Mcl_IO.Manual_Injection_Param_Rate       - not used
   1207          
   1208          		temp_level_target = Mcl_IO.Manual_Injection_Level/(32.0f);
   \   00000038   0xED94 0x0A56      VLDR     S0,[R4, #+344]
   1209          		temp_level_rate  = Mcl_IO.Manual_Injection_Level_Rate/(32.0f);
   1210          
   1211          
   1212          		// Handle the voltage target increase
   1213          		if(Manual_Inject_Level < temp_level_target)
   \   0000003C   0xF8D4 0x140C      LDR      R1,[R4, #+1036]
   \   00000040   0xEDDF 0x....      VLDR.W   S1,??DataTable47  ;; 0x3d000000
   \   00000044   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000048   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000004C   0xEE01 0x1A10      VMOV     S2,R1
   \   00000050   0xEEB4 0x1A40      VCMP.F32 S2,S0
   \   00000054   0xEEF1 0xFA10      FMSTAT   
   \   00000058   0xD50C             BPL.N    ??Manual_Injection_Control_2
   1214          		{
   1215          			Manual_Inject_Level += (TS*temp_level_rate);
   \   0000005A   0xED94 0x0A57      VLDR     S0,[R4, #+348]
   \   0000005E   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000062   0xEDDF 0x....      VLDR.W   S3,??DataTable47_1  ;; 0x3683126f
   \   00000066   0xF204 0x410C      ADDW     R1,R4,#+1036
   \   0000006A   0xEE00 0x1A21      VMLA.F32 S2,S0,S3
   \   0000006E   0xED81 0x1A00      VSTR     S2,[R1, #0]
   \   00000072   0xE003             B.N      ??Manual_Injection_Control_3
   1216          		}
   1217          		else
   1218          		{
   1219          			Manual_Inject_Level = temp_level_target;
   \                     ??Manual_Injection_Control_2: (+1)
   \   00000074   0xF204 0x410C      ADDW     R1,R4,#+1036
   \   00000078   0xED81 0x0A00      VSTR     S0,[R1, #0]
   1220          		}
   1221          
   1222          		temp_level_target = Manual_Inject_Level;
   \                     ??Manual_Injection_Control_3: (+1)
   \   0000007C   0x0680             LSLS     R0,R0,#+26
   \   0000007E   0xF8D4 0x140C      LDR      R1,[R4, #+1036]
   \   00000082   0xED94 0x0A58      VLDR     S0,[R4, #+352]
   \   00000086   0xEE08 0x1A10      VMOV     S16,R1
   \   0000008A   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000008E   0xD54F             BPL.N    ??Manual_Injection_Control_4
   1223          
   1224          		if(Mcl_Flow_Manager & ((MCL_FLOW_MANAGER_TYPE)1<<MANUAL_AC_VOLT_INJECTION))
   1225          		{
   1226          			// Handle the frequency
   1227          			temp_param_target = Mcl_IO.Manual_Injection_Param/32.0f;      // temp_param_target = (Mcl_IO.Manual_Injection_Param << 15)/(sint32)(32.0);
   1228          			temp_param_rate  = Mcl_IO.Manual_Injection_Param_Rate/32.0f;      // temp_param_rate  = (Mcl_IO.Manual_Injection_Param_Rate)/(sint32)(32.0);
   \   00000090   0xED94 0x1A59      VLDR     S2,[R4, #+356]
   1229          
   1230          			if(MATHCALC__ABS(Manual_Inject_Param) < MATHCALC__ABS(temp_param_target))
   \   00000094   0xF8D4 0x0410      LDR      R0,[R4, #+1040]
   \   00000098   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000009C   0xEEB8 0x1AC1      VCVT.F32.S32 S2,S2
   \   000000A0   0xEE61 0x0A20      VMUL.F32 S1,S2,S1
   \   000000A4   0xEE01 0x0A10      VMOV     S2,R0
   \   000000A8   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   000000AC   0xEEF1 0xFA10      FMSTAT   
   \   000000B0   0xBF4C             ITE      MI 
   \   000000B2   0xEEF1 0x1A41      VNEGMI.F32 S3,S2
   \   000000B6   0xEEF0 0x1A41      VMOVPL.F32 S3,S2
   \   000000BA   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000000BE   0xEEF1 0xFA10      FMSTAT   
   \   000000C2   0xBF4C             ITE      MI 
   \   000000C4   0xEEB1 0x2A40      VNEGMI.F32 S4,S0
   \   000000C8   0xEEB0 0x2A40      VMOVPL.F32 S4,S0
   \   000000CC   0xEEF4 0x1A42      VCMP.F32 S3,S4
   \   000000D0   0xEEF1 0xFA10      FMSTAT   
   \   000000D4   0xD50C             BPL.N    ??Manual_Injection_Control_5
   1231          			{
   1232          				if(temp_param_target > 0)
   \   000000D6   0xEDDF 0x....      VLDR.W   S3,??DataTable47_2  ;; 0x3903126f
   \   000000DA   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000000DE   0xEE60 0x0AA1      VMUL.F32 S1,S1,S3
   \   000000E2   0xEEF1 0xFA10      FMSTAT   
   \   000000E6   0xBFCC             ITE      GT 
   1233          				{
   1234          					Manual_Inject_Param += TS*temp_param_rate;
   \   000000E8   0xEE30 0x0A81      VADDGT.F32 S0,S1,S2
   1235          				}
   1236          				else
   1237          				{
   1238          					Manual_Inject_Param -= TS*temp_param_rate;
   \   000000EC   0xEE31 0x0A60      VSUBLE.F32 S0,S2,S1
   1239          				}
   1240          			}
   1241          			else
   1242          			{
   1243          				Manual_Inject_Param = temp_param_target;
   \                     ??Manual_Injection_Control_5: (+1)
   \   000000F0   0xF204 0x4010      ADDW     R0,R4,#+1040
   \   000000F4   0xED9F 0x....      VLDR.W   S2,??DataTable47_3  ;; 0x3a4de32f
   \   000000F8   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   000000FC   0xF8D4 0x0410      LDR      R0,[R4, #+1040]
   \   00000100   0xEE00 0x0A90      VMOV     S1,R0
   \   00000104   0xF8D4 0x0414      LDR      R0,[R4, #+1044]
   \   00000108   0xEE00 0x0A10      VMOV     S0,R0
   \   0000010C   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   \   00000110   0xF204 0x4014      ADDW     R0,R4,#+1044
   1244          			}
   1245          
   1246          			Manual_Pos_Reference += TS*TWO_PI * Manual_Inject_Param;
   1247          			if(Manual_Pos_Reference > TWO_PI)
   \   00000114   0xEDDF 0x....      VLDR.W   S1,??DataTable48  ;; 0x40c90fdc
   \   00000118   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000011C   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   00000120   0xEEF1 0xFA10      FMSTAT   
   \   00000124   0xDB0C             BLT.N    ??Manual_Injection_Control_6
   1248          			{
   1249          				Manual_Pos_Reference = Manual_Pos_Reference - TWO_PI;
   \   00000126   0xEDDF 0x....      VLDR.W   S1,??DataTable49  ;; 0xc0c90fdb
   \   0000012A   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   0000012E   0xE005             B.N      ??Manual_Injection_Control_7
   1250          			}
   1251          		}
   1252          		else // MANUAL_DC_VOLT_INJECTION
   1253          		{
   1254          			Manual_Pos_Reference = (float32)(Mcl_IO.Manual_Injection_Param ) * (TWO_PI / (32.0f *360.0f));
   \                     ??Manual_Injection_Control_4: (+1)
   \   00000130   0xEDDF 0x....      VLDR.W   S1,??DataTable50  ;; 0x3a0efa35
   \   00000134   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000138   0xF204 0x4014      ADDW     R0,R4,#+1044
   \                     ??Manual_Injection_Control_7: (+1)
   \   0000013C   0xED80 0x0A00      VSTR     S0,[R0, #0]
   1255          		}
   1256          
   1257          
   1258          		// Set proper voltage
   1259          		if(!temp_level_target)
   \                     ??Manual_Injection_Control_6: (+1)
   \   00000140   0xEEB5 0x8A40      VCMP.F32 S16,#0.0
   \   00000144   0xEEF1 0xFA10      FMSTAT   
   \   00000148   0xBF08             IT       EQ 
   1260          		{
   1261          			temp_level_target = 1;
   \   0000014A   0xEEB7 0x8A00      VMOVEQ.F32 S16,#1.0
   1262          		}
   1263          
   1264          		MathCalc__SinCosF(Manual_Pos_Reference, &manual_sin_cos);
   \   0000014E   0xF8D4 0x1414      LDR      R1,[R4, #+1044]
   \   00000152   0xA800             ADD      R0,SP,#+0
   \   00000154   0xEE00 0x1A10      VMOV     S0,R1
   \   00000158   0x.... 0x....      BL       MathCalc__SinCosF
   1265          
   1266          		Mcl_DQ_Ctrl_IO.Sin_Cos = &manual_sin_cos;
   \   0000015C   0xA800             ADD      R0,SP,#+0
   \   0000015E   0xF8C4 0x01E0      STR      R0,[R4, #+480]
   1267          		Mcl_DQ_Ctrl_IO.Force_Out_Volt->D = temp_level_target;
   1268          		Mcl_DQ_Ctrl_IO.Force_Out_Volt->Q = 0.0f;
   \   00000162   0x2100             MOVS     R1,#+0
   \   00000164   0xF8D4 0x01E4      LDR      R0,[R4, #+484]
   \   00000168   0xED80 0x8A01      VSTR     S16,[R0, #+4]
   \   0000016C   0xF8D4 0x01E4      LDR      R0,[R4, #+484]
   \   00000170   0x6081             STR      R1,[R0, #+8]
   \   00000172   0xE0AF             B.N      ??Manual_Injection_Control_8
   1269          
   1270          	}
   1271          	else if(Mcl_Flow_Manager & MANUAL_CURRENT_INJECTION_FLAGS)
   \                     ??Manual_Injection_Control_1: (+1)
   \   00000174   0x21C0             MOVS     R1,#+192
   \   00000176   0x4208             TST      R0,R1
   \   00000178   0xF000 0x80AC      BEQ.W    ??Manual_Injection_Control_8
   1272          	{
   1273          
   1274          		// Variables and its meaning in MANUAL_AC_CURRENT_INJECTION
   1275          		// Mcl_IO.Manual_Injection_Level            - define the current level
   1276          		// Mcl_IO.Manual_Injection_Level_Rate       - define the current rate in volts/s
   1277          		// Mcl_IO.Manual_Injection_Param            - define the frequency
   1278          		// Mcl_IO.Manual_Injection_Param_Rate       - define the frequency rate in Hz/s
   1279          
   1280          		// Variables and its meaning in MANUAL_DC_CURRENT_INJECTION
   1281          		// Mcl_IO.Manual_Injection_Level            - define the current level
   1282          		// Mcl_IO.Manual_Injection_Level_Rate       - define the current rate in volts/s
   1283          		// Mcl_IO.Manual_Injection_Param            - define position of the voltage vector in degrees
   1284          		// Mcl_IO.Manual_Injection_Param_Rate       - not used
   1285          
   1286          
   1287          		// Zero the forced voltage, this allows the controller to proper
   1288          		// generate the voltage references
   1289          		Mcl_DQ_Ctrl_IO.Force_Out_Volt->D = 0.0f;
   \   0000017C   0xF8D4 0x01E4      LDR      R0,[R4, #+484]
   \   00000180   0x2100             MOVS     R1,#+0
   \   00000182   0x6041             STR      R1,[R0, #+4]
   1290          		Mcl_DQ_Ctrl_IO.Force_Out_Volt->Q = 0.0f;
   1291          
   1292          
   1293          		temp_level_target = Mcl_IO.Manual_Injection_Level/(32.0f);
   \   00000184   0xEDDF 0x....      VLDR.W   S1,??DataTable47  ;; 0x3d000000
   \   00000188   0xF8D4 0x01E4      LDR      R0,[R4, #+484]
   \   0000018C   0x6081             STR      R1,[R0, #+8]
   \   0000018E   0xED94 0x0A56      VLDR     S0,[R4, #+344]
   1294          		temp_level_rate  = Mcl_IO.Manual_Injection_Level_Rate/(32.0f);
   1295          
   1296          
   1297          		// Handle the voltage target increase
   1298          		if(Manual_Inject_Level < temp_level_target)
   \   00000192   0xF8D4 0x040C      LDR      R0,[R4, #+1036]
   \   00000196   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000019A   0xEE20 0x1A20      VMUL.F32 S2,S0,S1
   \   0000019E   0xEE00 0x0A10      VMOV     S0,R0
   \   000001A2   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   000001A6   0xEEF1 0xFA10      FMSTAT   
   \   000001AA   0xD509             BPL.N    ??Manual_Injection_Control_9
   1299          		{
   1300          			Manual_Inject_Level += TS*temp_level_rate;
   \   000001AC   0xED94 0x1A57      VLDR     S2,[R4, #+348]
   \   000001B0   0xEEF8 0x1AC1      VCVT.F32.S32 S3,S2
   \   000001B4   0xED9F 0x....      VLDR.W   S4,??DataTable47_1  ;; 0x3683126f
   \   000001B8   0xEEB0 0x1A40      VMOV.F32 S2,S0
   \   000001BC   0xEE01 0x1A82      VMLA.F32 S2,S3,S4
   1301          		}
   1302          		else
   1303          		{
   1304          			Manual_Inject_Level = temp_level_target;
   \                     ??Manual_Injection_Control_9: (+1)
   \   000001C0   0xF204 0x400C      ADDW     R0,R4,#+1036
   1305          		}
   1306          
   1307          
   1308          		temp_level_target = Manual_Inject_Level;
   1309          
   1310          		if(Mcl_Flow_Manager & ((MCL_FLOW_MANAGER_TYPE)1<<MANUAL_AC_CURRENT_INJECTION))
   \   000001C4   0xED94 0x0A58      VLDR     S0,[R4, #+352]
   \   000001C8   0xED80 0x1A00      VSTR     S2,[R0, #0]
   \   000001CC   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000001D0   0xF8D4 0x040C      LDR      R0,[R4, #+1036]
   \   000001D4   0xEE08 0x0A10      VMOV     S16,R0
   \   000001D8   0xF8D4 0x0410      LDR      R0,[R4, #+1040]
   \   000001DC   0xEE01 0x0A10      VMOV     S2,R0
   \   000001E0   0xF894 0x0358      LDRB     R0,[R4, #+856]
   \   000001E4   0x0600             LSLS     R0,R0,#+24
   \   000001E6   0xD542             BPL.N    ??Manual_Injection_Control_10
   1311          		{
   1312          
   1313          			// Handle the frequency
   1314          			temp_param_target = Mcl_IO.Manual_Injection_Param/32.0f;      // temp_param_target = (Mcl_IO.Manual_Injection_Param << 15)/(sint32)(32.0);
   1315          			temp_param_rate  = Mcl_IO.Manual_Injection_Param_Rate/32.0f;      // temp_param_rate  = (Mcl_IO.Manual_Injection_Param_Rate)/(sint32)(32.0);
   \   000001E8   0xEDD4 0x1A59      VLDR     S3,[R4, #+356]
   \   000001EC   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000001F0   0xEEF8 0x1AE1      VCVT.F32.S32 S3,S3
   1316          
   1317          			if(MATHCALC__ABS(Manual_Inject_Param) < MATHCALC__ABS(temp_param_target))
   \   000001F4   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   000001F8   0xEE61 0x0AA0      VMUL.F32 S1,S3,S1
   \   000001FC   0xEEF1 0xFA10      FMSTAT   
   \   00000200   0xBF4C             ITE      MI 
   \   00000202   0xEEF1 0x1A41      VNEGMI.F32 S3,S2
   \   00000206   0xEEF0 0x1A41      VMOVPL.F32 S3,S2
   \   0000020A   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000020E   0xEEF1 0xFA10      FMSTAT   
   \   00000212   0xBF4C             ITE      MI 
   \   00000214   0xEEB1 0x2A40      VNEGMI.F32 S4,S0
   \   00000218   0xEEB0 0x2A40      VMOVPL.F32 S4,S0
   \   0000021C   0xEEF4 0x1A42      VCMP.F32 S3,S4
   \   00000220   0xEEF1 0xFA10      FMSTAT   
   \   00000224   0xD50D             BPL.N    ??Manual_Injection_Control_11
   1318          			{
   1319          				if(temp_param_target > 0)
   \   00000226   0xEDDF 0x....      VLDR.W   S3,??DataTable47_2  ;; 0x3903126f
   \   0000022A   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000022E   0xEE60 0x0AA1      VMUL.F32 S1,S1,S3
   \   00000232   0xEEF1 0xFA10      FMSTAT   
   \   00000236   0xBFD4             ITE      LE 
   1320          				{
   1321          					Manual_Inject_Param += TS*temp_param_rate;
   1322          				}
   1323          				else
   1324          				{
   1325          					Manual_Inject_Param -= TS*temp_param_rate;
   \   00000238   0xEE31 0x1A60      VSUBLE.F32 S2,S2,S1
   1326          				}
   \   0000023C   0xEE30 0x1A81      VADDGT.F32 S2,S1,S2
   \   00000240   0xE001             B.N      ??Manual_Injection_Control_12
   1327          			}
   1328          			else
   1329          			{
   1330          				Manual_Inject_Param = temp_param_target;
   \                     ??Manual_Injection_Control_11: (+1)
   \   00000242   0xEEB0 0x1A40      VMOV.F32 S2,S0
   1331          			}
   1332          
   1333          			Manual_Pos_Reference += TS*TWO_PI*Manual_Inject_Param;
   \                     ??Manual_Injection_Control_12: (+1)
   \   00000246   0xF8D4 0x0414      LDR      R0,[R4, #+1044]
   \   0000024A   0xEDDF 0x....      VLDR.W   S1,??DataTable47_3  ;; 0x3a4de32f
   \   0000024E   0xEE00 0x0A10      VMOV     S0,R0
   \   00000252   0xEE01 0x0A20      VMLA.F32 S0,S2,S1
   1334          			if(Manual_Pos_Reference > TWO_PI)
   \   00000256   0xEDDF 0x....      VLDR.W   S1,??DataTable48  ;; 0x40c90fdc
   \   0000025A   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000025E   0xEEF1 0xFA10      FMSTAT   
   \   00000262   0xDB08             BLT.N    ??Manual_Injection_Control_13
   1335          			{
   1336          				Manual_Pos_Reference = Manual_Pos_Reference -TWO_PI;
   \   00000264   0xEDDF 0x....      VLDR.W   S1,??DataTable49  ;; 0xc0c90fdb
   \   00000268   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   0000026C   0xE003             B.N      ??Manual_Injection_Control_13
   1337          			}
   1338          
   1339          		}
   1340          		else // MANUAL_DC_CURRENT_INJECTION
   1341          		{
   1342          			Manual_Pos_Reference = (float32)(Mcl_IO.Manual_Injection_Param ) * (TWO_PI / (32.0f *360.0f));
   \                     ??Manual_Injection_Control_10: (+1)
   \   0000026E   0xEDDF 0x....      VLDR.W   S1,??DataTable50  ;; 0x3a0efa35
   \   00000272   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \                     ??Manual_Injection_Control_13: (+1)
   \   00000276   0xF204 0x4014      ADDW     R0,R4,#+1044
   \   0000027A   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   0000027E   0xF204 0x4010      ADDW     R0,R4,#+1040
   \   00000282   0xED80 0x1A00      VSTR     S2,[R0, #0]
   1343          		}
   1344          
   1345          		MathCalc__SinCosF(Manual_Pos_Reference, &manual_sin_cos);
   \   00000286   0xA800             ADD      R0,SP,#+0
   \   00000288   0x.... 0x....      BL       MathCalc__SinCosF
   1346          
   1347          		manual_dq.ZeroSequence = 0;
   1348          		ClrkPark__DirectParkF(Mcl_Input_Proc_IO.Is_Alpha_Beta, &manual_dq, &manual_sin_cos);
   \   0000028C   0xF8D4 0x0250      LDR      R0,[R4, #+592]
   \   00000290   0xEDDD 0x0A01      VLDR     S1,[SP, #+4]
   \   00000294   0xED90 0x1A01      VLDR     S2,[R0, #+4]
   \   00000298   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   0000029C   0xED9D 0x2A00      VLDR     S4,[SP, #+0]
   1349          
   1350          		*Mcl_DQ_Ctrl_IO.D_Ref = 0;
   \   000002A0   0xF8D4 0x01D0      LDR      R0,[R4, #+464]
   \   000002A4   0xEE61 0x1A20      VMUL.F32 S3,S2,S1
   \   000002A8   0xEE40 0x1A02      VMLA.F32 S3,S0,S4
   \   000002AC   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000002B0   0xEDDD 0x0A00      VLDR     S1,[SP, #+0]
   \   000002B4   0x2100             MOVS     R1,#+0
   \   000002B6   0x6001             STR      R1,[R0, #+0]
   \   000002B8   0xEE01 0x0A60      VMLS.F32 S0,S2,S1
   1351          		*Mcl_DQ_Ctrl_IO.D_Est = manual_dq.D;
   \   000002BC   0xF8D4 0x01D4      LDR      R0,[R4, #+468]
   \   000002C0   0xEDC0 0x1A00      VSTR     S3,[R0, #0]
   1352          
   1353          		*Mcl_DQ_Ctrl_IO.Q_Ref = temp_level_target;
   \   000002C4   0xF8D4 0x01D8      LDR      R0,[R4, #+472]
   \   000002C8   0xED80 0x8A00      VSTR     S16,[R0, #0]
   1354          		*Mcl_DQ_Ctrl_IO.Q_Est = manual_dq.Q;
   \   000002CC   0xF8D4 0x01DC      LDR      R0,[R4, #+476]
   \   000002D0   0xED80 0x0A00      VSTR     S0,[R0, #0]
   1355          
   1356          	}
   1357          
   1358          	// Dq controllers Handler
   1359          	MclDqCtrl__OverrideRegGains(&Mcl_Params_Displ1->Manual_Injection);
   \                     ??Manual_Injection_Control_8: (+1)
   \   000002D4   0xF8D4 0x03F4      LDR      R0,[R4, #+1012]
   \   000002D8   0xF500 0x71AC      ADD      R1,R0,#+344
   \   000002DC   0x690A             LDR      R2,[R1, #+16]
   \   000002DE   0xF8C4 0x22A8      STR      R2,[R4, #+680]
   \   000002E2   0x694A             LDR      R2,[R1, #+20]
   \   000002E4   0xF8C4 0x22AC      STR      R2,[R4, #+684]
   \   000002E8   0x698A             LDR      R2,[R1, #+24]
   \   000002EA   0xF8C4 0x228C      STR      R2,[R4, #+652]
   \   000002EE   0x69C9             LDR      R1,[R1, #+28]
   \   000002F0   0xF8C4 0x1290      STR      R1,[R4, #+656]
   1360          	MclDqCtrl__RunningHandler(&Mcl_DQ_Ctrl_IO, &Mcl_Params_Displ1->Manual_Injection);
   \   000002F4   0xF500 0x71AC      ADD      R1,R0,#+344
   \   000002F8   0xF504 0x70E8      ADD      R0,R4,#+464
   \   000002FC   0x.... 0x....      BL       MclDqCtrl__RunningHandler
   1361          
   1362          	// Pwm Handler
   1363          	MclPwm__RunningHandler(&Mcl_Pwm_IO, &MclPwm_Params);
   \   00000300   0xF504 0x714E      ADD      R1,R4,#+824
   \   00000304   0xF504 0x703C      ADD      R0,R4,#+752
   \   00000308   0x.... 0x....      BL       MclPwm__RunningHandler
   1364          
   1365          	return FALSE;
   \   0000030C   0xB002             ADD      SP,SP,#+8
   \   0000030E   0x2000             MOVS     R0,#+0
   \   00000310   0xECBD 0x8B02      VPOP     {D8}
   \   00000314   0xBD10             POP      {R4,PC}          ;; return
   1366          }
   1367          
   1368          
   1369          uint8 switching_angle = 0;

   \                                 In section .text, align 4, keep-with-next
   1370          static BOOL_TYPE Estimate_Stator_Resistance(void)
   1371          {
   \                     ??Estimate_Stator_Resistance: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1372              BOOL_TYPE estimation_finished;
   1373              float32 vs_voltage_abs;
   1374              SIN_COS_F_TYPE est_res_sin_cos_pos;
   1375              float32 initial_position;
   1376              float32 voltage_level;
   1377          
   1378              estimation_finished = FALSE;
   1379          
   1380              Mcl_Quantities.Elapsed_Time_After_Starting = 0;
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable59_3
   \   00000008   0xED2D 0x8B02      VPUSH    {D8}
   \   0000000C   0x2500             MOVS     R5,#+0
   \   0000000E   0xB084             SUB      SP,SP,#+16
   \   00000010   0xF8C4 0x50B8      STR      R5,[R4, #+184]
   1381          
   1382              // Input Processing Handler
   1383              MclInputProc__RunningHandler(&Mcl_Input_Proc_IO);
   \   00000014   0xF504 0x7011      ADD      R0,R4,#+580
   \   00000018   0x.... 0x....      BL       MclInputProc__RunningHandler
   1384          
   1385              // Observer Handler -- to check speed oscillation
   1386              MclObserver__RunningHandler(&Mcl_Observer_IO, &MclObserver_Params);
   \   0000001C   0xF504 0x71CE      ADD      R1,R4,#+412
   \   00000020   0xF504 0x70FE      ADD      R0,R4,#+508
   \   00000024   0x.... 0x....      BL       MclObserver__RunningHandler
   \   00000028   0xF8D4 0x0254      LDR      R0,[R4, #+596]
   \   0000002C   0xED90 0x0A01      VLDR     S0,[R0, #+4]
   \   00000030   0xF8D4 0x0254      LDR      R0,[R4, #+596]
   \   00000034   0xEE20 0x0A00      VMUL.F32 S0,S0,S0
   \   00000038   0xED8D 0x0A01      VSTR     S0,[SP, #+4]
   \   0000003C   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   00000040   0xEDDD 0x0A01      VLDR     S1,[SP, #+4]
   \   00000044   0xEE40 0x0A00      VMLA.F32 S1,S0,S0
   1387          
   1388          
   1389              // Calculate the voltage magnitude applied to the motor
   1390              // The voltage magnitude is calculated here and not in the MclInputProc because the
   1391              // output voltage magnitude is only used here until now (it saves a sqrt call when controlling the motor)
   1392              vs_voltage_abs  = (Mcl_Input_Proc_IO.Vs_Alpha_Beta_Rec->Alpha) * (Mcl_Input_Proc_IO.Vs_Alpha_Beta_Rec->Alpha);
   1393              vs_voltage_abs += (Mcl_Input_Proc_IO.Vs_Alpha_Beta_Rec->Beta)  * (Mcl_Input_Proc_IO.Vs_Alpha_Beta_Rec->Beta);
   1394              vs_voltage_abs = MC_SQRT_F(vs_voltage_abs);
   \   00000048   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   0000004C   0xEEF1 0xFA10      FMSTAT   
   \   00000050   0xDB02             BLT.N    ??Estimate_Stator_Resistance_1
   \   00000052   0xEEB1 0x0AE0      VSQRT.F32 S0,S1
   \   00000056   0xE001             B.N      ??Estimate_Stator_Resistance_2
   \                     ??Estimate_Stator_Resistance_1: (+1)
   \   00000058   0xED9F 0x....      VLDR.W   S0,??DataTable51  ;; 0x0
   1395          
   1396          
   1397              // These variables needs to be always connected to the pointers, since these variables
   1398              // may have different memory position on stack
   1399              Res_Est_IO.vs_voltage_abs = &vs_voltage_abs;
   \                     ??Estimate_Stator_Resistance_2: (+1)
   \   0000005C   0xA801             ADD      R0,SP,#+4
   \   0000005E   0xF8C4 0x0348      STR      R0,[R4, #+840]
   \   00000062   0xED8D 0x0A01      VSTR     S0,[SP, #+4]
   1400              Res_Est_IO.level_injection_out = &voltage_level;
   \   00000066   0xA800             ADD      R0,SP,#+0
   \   00000068   0xF8C4 0x034C      STR      R0,[R4, #+844]
   1401          
   1402              if(ResistanceEstimation__Calculate(&Res_Est_IO, &Mcl_Params_Displ1->Res_Est_Param))
   \   0000006C   0xED9F 0x....      VLDR.W   S16,??DataTable51_1  ;; 0x40c90fdb
   \   00000070   0xF8D4 0x03F4      LDR      R0,[R4, #+1012]
   \   00000074   0xF100 0x01E4      ADD      R1,R0,#+228
   \   00000078   0xF504 0x7052      ADD      R0,R4,#+840
   \   0000007C   0x.... 0x....      BL       ResistanceEstimation__Calculate
   \   00000080   0xB3B0             CBZ.N    R0,??Estimate_Stator_Resistance_3
   1403              {
   1404                  Mcl_Quantities.Stator_Resistance  = ResistanceEstimation__GetResistance();
   \   00000082   0xF8D4 0x04AC      LDR      R0,[R4, #+1196]
   \   00000086   0xEE00 0x0A10      VMOV     S0,R0
   1405                  Mcl_Quantities.Stator_Temperature = Calc_Temperature_By_Resistance();
   \   0000008A   0xF8D4 0x03F4      LDR      R0,[R4, #+1012]
   \   0000008E   0xED84 0x0A34      VSTR     S0,[R4, #+208]
   \   00000092   0xEDD0 0x0A4E      VLDR     S1,[R0, #+312]
   \   00000096   0xED90 0x1A50      VLDR     S2,[R0, #+320]
   \   0000009A   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   0000009E   0xEDD0 0x0A4F      VLDR     S1,[R0, #+316]
   \   000000A2   0xEE60 0x0A20      VMUL.F32 S1,S0,S1
   \   000000A6   0xED90 0x0A52      VLDR     S0,[R0, #+328]
   \   000000AA   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   \   000000AE   0xED84 0x0A1A      VSTR     S0,[R4, #+104]
   1406          #if (THERMAL_MODEL_EXE == ENABLED)
   1407                  ThermalModel__SetStatorTemperature(Mcl_Quantities.Stator_Temperature);
   \   000000B2   0x.... 0x....      BL       ThermalModel__SetStatorTemperature
   1408          #endif
   1409                  initial_position = -(float32) switching_angle * RESISTANCE_EST_ALIGNMENT_STEP_VALUE;
   1410          
   1411                  // initialize the initial angle of the observer
   1412                  Mcl_Quantities.DcInjection_Angle = initial_position;
   \   000000B6   0xEEF8 0x0A08      VMOV.F32 S1,#-3.0
   \   000000BA   0xF894 0x0359      LDRB     R0,[R4, #+857]
   \   000000BE   0xEE00 0x0A10      VMOV     S0,R0
   1413                  // re-connect the angle pointer from Observer to DqCtrl
   1414                  Mcl_DQ_Ctrl_IO.Sin_Cos = &Mcl_Quantities.Sin_Cos_Position_Flux;
   1415          
   1416                  estimation_finished = TRUE;
   1417                  switching_angle++;
   \   000000C2   0x1C40             ADDS     R0,R0,#+1
   \   000000C4   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   000000C8   0xF884 0x0359      STRB     R0,[R4, #+857]
   \   000000CC   0xEE20 0x0A08      VMUL.F32 S0,S0,S16
   \   000000D0   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   000000D4   0xF104 0x0188      ADD      R1,R4,#+136
   \   000000D8   0x2501             MOVS     R5,#+1
   1418                  if(switching_angle > (RESISTANCE_EST_ALIGNMENT_STEPS-1))
   \   000000DA   0xB2C0             UXTB     R0,R0
   \   000000DC   0xED84 0x0A35      VSTR     S0,[R4, #+212]
   \   000000E0   0xF8C4 0x11E0      STR      R1,[R4, #+480]
   \   000000E4   0x2803             CMP      R0,#+3
   \   000000E6   0xDB29             BLT.N    ??Estimate_Stator_Resistance_4
   1419                  {
   1420                      switching_angle = 0;
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0xF884 0x0359      STRB     R0,[R4, #+857]
   \   000000EE   0xE025             B.N      ??Estimate_Stator_Resistance_4
   1421                  }
   1422              }
   1423              else
   1424              {
   1425                  // todo silvamc - Set initial angle from another module? e.g. angle tracking
   1426                  initial_position = -(float32) switching_angle * RESISTANCE_EST_ALIGNMENT_STEP_VALUE;
   \                     ??Estimate_Stator_Resistance_3: (+1)
   \   000000F0   0xEEF8 0x0A08      VMOV.F32 S1,#-3.0
   \   000000F4   0xF894 0x0359      LDRB     R0,[R4, #+857]
   \   000000F8   0xEE00 0x0A10      VMOV     S0,R0
   \   000000FC   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000100   0xEE20 0x0A08      VMUL.F32 S0,S0,S16
   \   00000104   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   1427                  // The voltage reference has to be different of zero, since the forced voltage has to be different of zero
   1428                  // in order to overwrite the DQ references.
   1429                  if(voltage_level==0.0f)
   \   00000108   0xEDDD 0x0A00      VLDR     S1,[SP, #+0]
   \   0000010C   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   00000110   0xEEF1 0xFA10      FMSTAT   
   \   00000114   0xBF04             ITT      EQ 
   1430                  {
   1431                      voltage_level = 0.01f;
   \   00000116   0x.... 0x....      LDREQ.W  R0,??DataTable65  ;; 0x3c23d70a
   \   0000011A   0x9000             STREQ    R0,[SP, #+0]
   1432                  }
   1433          
   1434                  MathCalc__SinCosF(initial_position, &est_res_sin_cos_pos);
   \   0000011C   0xA802             ADD      R0,SP,#+8
   \   0000011E   0x.... 0x....      BL       MathCalc__SinCosF
   1435          
   1436                  Mcl_DQ_Ctrl_IO.Sin_Cos = &est_res_sin_cos_pos;
   \   00000122   0xA802             ADD      R0,SP,#+8
   \   00000124   0xF8C4 0x01E0      STR      R0,[R4, #+480]
   1437                  Mcl_DQ_Ctrl_IO.Force_Out_Volt->D = voltage_level;
   \   00000128   0xF8D4 0x01E4      LDR      R0,[R4, #+484]
   \   0000012C   0x9900             LDR      R1,[SP, #+0]
   \   0000012E   0x6041             STR      R1,[R0, #+4]
   1438                  Mcl_DQ_Ctrl_IO.Force_Out_Volt->Q = 0.0f;
   \   00000130   0xF8D4 0x01E4      LDR      R0,[R4, #+484]
   \   00000134   0x6085             STR      R5,[R0, #+8]
   1439                  Mcl_DQ_Ctrl_IO.Force_Out_Volt->ZeroSequence = 0.0f;
   \   00000136   0xF8D4 0x01E4      LDR      R0,[R4, #+484]
   \   0000013A   0x6005             STR      R5,[R0, #+0]
   1440          
   1441              }
   1442          
   1443          
   1444              // Dq controllers Handler
   1445              MclDqCtrl__RunningHandler(&Mcl_DQ_Ctrl_IO, &Mcl_Params_Displ1->DQCtrlPrm);
   \                     ??Estimate_Stator_Resistance_4: (+1)
   \   0000013C   0xF8D4 0x03F4      LDR      R0,[R4, #+1012]
   \   00000140   0xF100 0x0144      ADD      R1,R0,#+68
   \   00000144   0xF504 0x70E8      ADD      R0,R4,#+464
   \   00000148   0x.... 0x....      BL       MclDqCtrl__RunningHandler
   1446          
   1447              // Pwm Handler
   1448              MclPwm__RunningHandler(&Mcl_Pwm_IO, &MclPwm_Params);
   \   0000014C   0xF504 0x714E      ADD      R1,R4,#+824
   \   00000150   0xF504 0x703C      ADD      R0,R4,#+752
   \   00000154   0x.... 0x....      BL       MclPwm__RunningHandler
   1449          
   1450          
   1451              return estimation_finished;
   \   00000158   0xB004             ADD      SP,SP,#+16
   \   0000015A   0x4628             MOV      R0,R5
   \   0000015C   0xECBD 0x8B02      VPOP     {D8}
   \   00000160   0xB001             ADD      SP,SP,#+4
   \   00000162   0xBD30             POP      {R4,R5,PC}       ;; return
   1452          }
   1453          
   1454          
   1455          /**
   1456           *  @brief      Calculate RMS values and mean speed value in 4khz handler (256ms time windows)
   1457           *  @param[in]  Motor currents and rotor speed.
   1458           *  @param[out] Mean RMS current of the three motor phasesa and the mean speed.
   1459           *  @param[in]  SAMPLES_NUMBER: 10 suitable choice to have ~250ms of time window at 4Khz
   1460           *  @return none
   1461           */
   1462          void Calc_MeanSpeed_CurrentRMS(void)
   1463          {
   1464          
   1465              I1_Rms_Sum += (Mcl_IO.Is_ABC.A * Mcl_IO.Is_ABC.A);
   1466              I2_Rms_Sum += (Mcl_IO.Is_ABC.B * Mcl_IO.Is_ABC.B);
   1467              I3_Rms_Sum += (Mcl_IO.Is_ABC.C * Mcl_IO.Is_ABC.C);
   1468              Mean_Speed_Sum += Mcl_Quantities.Speed_Rot_Mech_Abs;
   1469          
   1470              N_Samples++;
   1471          
   1472              if(N_Samples >= Mcl_Params_Displ1->ResTempCalc.Samples_Number)
   1473              {
   1474          
   1475                  Mcl_Quantities.IsRMS = MC_SQRT_F((I1_Rms_Sum+I2_Rms_Sum+I3_Rms_Sum)*INV_3* N_Samples_inv);
   1476                  Mcl_Quantities.Mean_Speed = Mean_Speed_Sum * N_Samples_inv;
   1477          
   1478                  N_Samples  = 0;
   1479                  I1_Rms_Sum = 0.0f;
   1480                  I2_Rms_Sum = 0.0f;
   1481                  I3_Rms_Sum = 0.0f;
   1482                  Mean_Speed_Sum = 0.0f;
   1483              }
   1484          }
   1485          
   1486          
   1487          
   1488          
   1489          /**
   1490           *  @brief      Calculating temperature from resistance
   1491           *  @param[in]
   1492           *  @param[out]
   1493           *  @param[in]  Temperature coefficient and Resistance base temperature
   1494           *  @return     Stator temperature in [C]
   1495           */
   1496          float32 Calc_Temperature_By_Resistance(void)
   1497          {
   1498              float32 temp_1;
   1499              float32 temp_2;
   1500          
   1501              // T = (R-Rs0)/(Rs0*alpha)  + T0
   1502          
   1503              temp_1 = Mcl_Quantities.Stator_Resistance - Mcl_Params_Displ1->ResTempCalc.Rs0;
   1504          
   1505              temp_2 = Mcl_Params_Displ1->ResTempCalc.Temp_Coeff * temp_1 * Mcl_Params_Displ1->ResTempCalc.Rs0_inv;
   1506              temp_2 += Mcl_Params_Displ1->ResTempCalc.T0;
   1507          
   1508              return(temp_2);
   1509          }
   1510          
   1511          
   1512          
   1513          /**
   1514           *  @brief      Calculating resistance from temperature
   1515           *  @param[in]  Temperature coefficient and Resistance base temperature
   1516           *  @param[out]
   1517           *  @param[in]
   1518           *  @return Updated stator resistance in [Ohm]
   1519           */
   1520          float32 Calc_Resistance_By_Temperature(void)
   1521          {
   1522              float32 temp_1;
   1523              float32 temp_2;
   1524              // Rs = Rs0*(1+1/alpha (T + T0))
   1525              temp_1 = 1 + Mcl_Params_Displ1->ResTempCalc.Temp_Coeff_inv * (Mcl_Quantities.Stator_Temperature - Mcl_Params_Displ1->ResTempCalc.T0);
   1526              //temp_1 = 1 + Mcl_Params_Displ1->ResTempCalc.Temp_Coeff_inv * (My_Measured_Temp - Mcl_Params_Displ1->ResTempCalc.T0);
   1527              temp_2 = Mcl_Params_Displ1->ResTempCalc.Rs0 * temp_1;
   1528          
   1529              return(temp_2);
   1530          }
   1531          
   1532          #if (MCL__ELECTRICAL_POWER == ENABLED)
   1533          #include "MotorSafetyMgr.h"
   1534          #ifdef __IAR_SYSTEMS_ICC__
   1535          #pragma inline = forced
   1536          #endif
   1537          /**
   1538           *  @brief      Calculate RMS values and mean speed value in 4khz handler (256ms time windows)
   1539           *  @param[in]  Motor currents and rotor speed.
   1540           *  @param[out] Mean RMS current of the three motor phasesa and the mean speed.
   1541           *  @param[in]  SAMPLES_NUMBER: 10 suitable choice to have ~250ms of time window at 4Khz
   1542           *  @return none
   1543           */
   1544          void Calc_ElectricalPower(void)
   1545          {
   1546              float32 electrical_power;
   1547              // instantaneous power
   1548              electrical_power = 1.5f * (Mcl_Quantities.Vs_Alpha_Beta_Rec.Alpha * Mcl_Quantities.Is_Alpha_Beta.Alpha + Mcl_Quantities.Vs_Alpha_Beta_Rec.Beta * Mcl_Quantities.Is_Alpha_Beta.Beta);
   1549          
   1550              if ((Mcl_IO.All_Devices_Off == FALSE) && (MotorSafetyMgr__DoesClassAHaveAccessToPwm() == TRUE))
   1551              {
   1552                  Mcl_Quantities.Electrical_Power = FILTERS__LOWPASSFILTER_F(Mcl_Quantities.Electrical_Power, MCL__EL_POWER_LPF, electrical_power);
   1553              }
   1554              else
   1555              {
   1556                  Mcl_Quantities.Electrical_Power = 0.0f;
   1557              }
   1558          }
   1559          #endif
   1560          #ifdef __IAR_SYSTEMS_ICC__
   1561          #pragma inline = forced
   1562          #endif
   1563          void TimeHandler(void)
   1564          {
   1565              // Count time after every starting
   1566              if( Mcl_Quantities.Elapsed_Time_After_Starting < MAX_UINT32)
   1567              {
   1568              	Mcl_Quantities.Elapsed_Time_After_Starting = Mcl_Quantities.Elapsed_Time_After_Starting + 1;
   1569              }
   1570          }
   1571          
   1572          
   1573          #ifdef __IAR_SYSTEMS_ICC__
   1574          #pragma inline = forced
   1575          #endif
   1576          /**
   1577           *  @brief      Calculate the torque value for the application layer according to the following convention:
   1578           *              torque is positive when motoring and negative when braking whatever is the motor speed direction.
   1579           *  @param[in]  Motor Torque (from Observer) and motor speed reference.
   1580           *  @param[out] Torque for the application layer.
   1581           *  @return none
   1582           */
   1583          void Calc_TorqueForApplication(void)
   1584          {
   1585              // check the sign of the speed reference
   1586              if (Mcl_IO.Speed_Rot_Ref<0)
   1587              {   //adjust the sign of the torque if needed
   1588                  Mcl_Quantities.Torque_Application = -Mcl_Quantities.Torque;
   1589              }
   1590              else
   1591              {// sign is correct
   1592                  Mcl_Quantities.Torque_Application = Mcl_Quantities.Torque;
   1593              }
   1594          
   1595          }
   1596          
   1597          /**
   1598           *  @brief      Management of some MCL flags during the running handler
   1599           *  @return none
   1600           */
   1601          void Flags_Management(void)
   1602          {
   1603              float32 target_speed;
   1604              // logic to detect wrong speed direction
   1605              target_speed   = SpeedRefGen__GetSpeedTarget();
   1606              if ((target_speed * Mcl_Quantities.Speed_Rot) < 0)
   1607              {
   1608                  Mcl_Cs.flags.bit.wrong_speed_direction = 1;
   1609              }
   1610              else
   1611              {
   1612                  Mcl_Cs.flags.bit.wrong_speed_direction = 0;
   1613              }
   1614          
   1615          
   1616              if (Mcl_Cs.flags.bit.braking_active == 1)
   1617              {
   1618          #if (STOP_RAMP_DURING_INVERSION == ENABLED)
   1619                  // stop the ramp if the reference is accelerating while in braking mode
   1620                  if (SpeedRefGen__GetStatus() == SPEED_REF_ACCELERATING)
   1621                  {
   1622                      SpeedRefGen__SetSpeedParams(0.0f);
   1623                      SpeedRefGen__ApplyDefaultAccel(TRUE);
   1624                      Mcl_Cs.flags.bit.stopped_ramp = 1;
   1625                  }
   1626          #endif
   1627              }
   1628              else
   1629              {
   1630          #if (STOP_RAMP_DURING_INVERSION == ENABLED)
   1631                  // braking is ended: restart the ramp if it was stopped (default deceleration is 0)
   1632                  if (Mcl_Cs.flags.bit.stopped_ramp == 1)
   1633                  {
   1634                      SpeedRefGen__ApplyDefaultAccel(FALSE);
   1635                      Mcl_Cs.flags.bit.stopped_ramp = 0;
   1636                  }
   1637          #endif
   1638                  // logic to detect motor direction
   1639                  // update motor direction (if not braking)
   1640                  if (Mcl_IO.Speed_Rot_Ref>0)
   1641                  {
   1642                      Mcl_Cs.flags.bit.motor_direction = 1;
   1643                  }
   1644                  else if (Mcl_IO.Speed_Rot_Ref<0)
   1645                  {
   1646                      Mcl_Cs.flags.bit.motor_direction = 0;
   1647                  }
   1648              }
   1649          }
C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\Mcl\Braking\Braking.c
      1          /**
      2           *  @file       
      3           *
      4           *  @brief      Basic description of file contents
      5           *
      6           *  @details    Detailed description of the file contents
      7           *
      8           *  @section    Applicable_Documents
      9           *					List here all the applicable documents if needed. <tr>	
     10           *
     11           *  $Header: $
     12           *
     13           *  @copyright  Copyright 2016-$Date$. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     14           */
     15          //---------------------------------------------------------------------------------------------------------------------
     16          //---------------------------------------------------------------------------------------------------------------------
     17          
     18          
     19          //-------------------------------------- Include Files ----------------------------------------------------------------
     20          #include "Braking.h"
     21          #include "MclConfig.h"
     22          #include "McMathCalc_macros.h"
     23          #include "Filters.h"
     24          #include "SpeedRefGen.h"
     25          
     26          
     27          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     28          
     29          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     30          /* Braking variables */

   \                                 In section .bss, align 4
   \   00000000                      DS8 4
     31          static float32 Max_Joule_Loss;          //!< [W] - Max Joule Losses
     32          static float32 Id_Braking;              //!< [A] - Calculated amount of id current to apply during braking
     33          static float32 Id_Braking_Max;          //!< [A] - Calculated max amount of id current to apply during braking
     34          static float32 Torque_Brake_Max;        //!< [Nm] - Max torque available for braking
     35          static float32 Speed_Filtered;

   \                                 In section .bss, align 4
   \   00000000                      DS8 4
     36          static float32 Braking_Resistance;

   \                                 In section .bss, align 4
   \   00000000                      DS8 4
     37          static float32 Id_Braking_Target;
     38          static float32 Torque_Brake_Max_thr;
     39          
     40          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
     41          
     42          
     43          //=====================================================================================================================
     44          //-------------------------------------- Public Functions -------------------------------------------------------------
     45          //=====================================================================================================================
     46          
     47          //---------------------------------------------------------------------------------------------------------------------
     48          /**
     49           *  @brief      It Initializes the module Braking and its variables
     50           *
     51           */
     52          
     53          float32 My_Max_Braking_Current;
     54          float32 My_Max_Braking_Torque;
     55          float32 My_Is_Abs;
     56          

   \                                 In section .text, align 2, keep-with-next
     57          void Braking__Initialize(void)
     58          {
     59          	My_Max_Braking_Current = 2.2f;
   \                     Braking__Initialize: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable59_3
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable64_2  ;; 0x400ccccd
   \   00000008   0xF8C0 0x1440      STR      R1,[R0, #+1088]
     60          	My_Max_Braking_Torque = 0.2f;
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable66_1  ;; 0x3e4ccccd
   \   00000010   0xF8C0 0x1444      STR      R1,[R0, #+1092]
     61          	My_Is_Abs = 0.0f;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0xF8C0 0x1448      STR      R1,[R0, #+1096]
     62          }
   \   0000001A   0x4770             BX       LR               ;; return
     63          

   \                                 In section .text, align 2, keep-with-next
     64          void Braking__ResetState(void)
     65          {
     66              //Braking Parameters - Reseting before start
     67              Id_Braking        = 0;
   \                     Braking__ResetState: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable59_3
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0xF8C0 0x142C      STR      R1,[R0, #+1068]
     68              Id_Braking_Target = 0;
     69              Torque_Brake_Max_thr = MIN_BRAKE_TORQUE;
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable62_2  ;; 0x3dcccccd
   \   0000000E   0xF8C0 0x143C      STR      R1,[R0, #+1084]
     70          }
   \   00000012   0x4770             BX       LR               ;; return
     71          
     72          /* Executed in 1ms handler */

   \                                 In section .text, align 4, keep-with-next
     73          float32 Braking__SpeedCtrlHandler(MCL_SPEED_CTRL_IO_F_TYPE *io, MCL_SPEED_CTRL_PARAMS_TYPE *params)
                                                                                                             ^
Remark[Pe826]: parameter "params" was never referenced
     74          {
     75              float32 speed_abs;
     76              float32 is;
     77          
     78              Braking_Resistance = (*io->Ctrl_Specific->Stator_Resistance) * BRAKING_RESISTANCE_PERC;
   \                     Braking__SpeedCtrlHandler: (+1)
   \   00000000   0x68C1             LDR      R1,[R0, #+12]
   \   00000002   0x6989             LDR      R1,[R1, #+24]
   \   00000004   0xED91 0x0A00      VLDR     S0,[R1, #0]
     79          
     80              Id_Braking_Max = -My_Max_Braking_Current;
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable59_3
   \   0000000C   0xF8D1 0x3440      LDR      R3,[R1, #+1088]
   \   00000010   0xEDDF 0x....      VLDR.W   S1,??DataTable55  ;; 0x3f733333
   \   00000014   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000018   0xF201 0x4230      ADDW     R2,R1,#+1072
   \   0000001C   0xEE00 0x3A90      VMOV     S1,R3
   \   00000020   0xEEF1 0x0A60      VNEG.F32 S1,S1
   \   00000024   0xEDC2 0x0A00      VSTR     S1,[R2, #0]
     81              /*==============================================================*/
     82              /*           Tmax for Braking                                   */
     83              /*==============================================================*/
     84          
     85              speed_abs = *(io->Ctrl_Specific->Speed_Rotor_Observed_Mech_Abs)+0.1f;  //Just in case to avoid zero division;
     86          
     87              // Filter the observed speed
     88              Speed_Filtered = FILTERS__LOWPASSFILTER_F(Speed_Filtered, BRAKING_SPEED_LPF_COEF, speed_abs);
   \   00000028   0xEDDF 0x....      VLDR.W   S1,??DataTable55_1  ;; 0x3dcccccd
   \   0000002C   0xF8D1 0x2438      LDR      R2,[R1, #+1080]
   \   00000030   0xEE01 0x2A10      VMOV     S2,R2
   \   00000034   0x68C2             LDR      R2,[R0, #+12]
   \   00000036   0x6912             LDR      R2,[R2, #+16]
   \   00000038   0xEEF6 0x1A0F      VMOV.F32 S3,#9.6875E-1
   \   0000003C   0xEE21 0x1A21      VMUL.F32 S2,S2,S3
   \   00000040   0xEDD2 0x1A00      VLDR     S3,[R2, #0]
   \   00000044   0xEE71 0x1AA0      VADD.F32 S3,S3,S1
   \   00000048   0xED9F 0x....      VLDR.W   S4,??DataTable55_2  ;; 0x3d000000
   \   0000004C   0xF201 0x4238      ADDW     R2,R1,#+1080
   \   00000050   0xEE01 0x1A82      VMLA.F32 S2,S3,S4
   \   00000054   0xED82 0x1A00      VSTR     S2,[R2, #0]
     89          
     90          
     91              if (io->Ctrl_Specific->flags.bit.braking_active == 1)
   \   00000058   0x68C0             LDR      R0,[R0, #+12]
   \   0000005A   0x6802             LDR      R2,[R0, #+0]
   \   0000005C   0xF3C2 0x12C0      UBFX     R2,R2,#+7,#+1
   \   00000060   0x2A00             CMP      R2,#+0
   \   00000062   0xD044             BEQ.N    ??Braking__SpeedCtrlHandler_0
     92              {
     93              #ifdef BRAKING__CONSERVATIVE_VARIANT
     94                  // braking strategy for IPM
     95                  is = (*io->Ctrl_Specific->Is_Abs);
     96                  My_Is_Abs = is;
   \   00000064   0x6D00             LDR      R0,[R0, #+80]
   \   00000066   0xEDD0 0x1A00      VLDR     S3,[R0, #0]
   \   0000006A   0xF201 0x4048      ADDW     R0,R1,#+1096
     97              #else
     98                  // braking strategy for SPM
     99                  is = Id_Braking_Max;
    100              #endif
    101          
    102          		Max_Joule_Loss = (1.5f* Braking_Resistance * My_Is_Abs * My_Is_Abs);  //Max power available for high speed
    103          		Torque_Brake_Max = Max_Joule_Loss / Speed_Filtered;                         // Max torque calculation
   \   0000006E   0xEEB7 0x2A08      VMOV.F32 S4,#1.5
   \   00000072   0xEE20 0x0A02      VMUL.F32 S0,S0,S4
   \   00000076   0xEDC0 0x1A00      VSTR     S3,[R0, #0]
   \   0000007A   0xEE20 0x0A21      VMUL.F32 S0,S0,S3
   \   0000007E   0xEE20 0x0A21      VMUL.F32 S0,S0,S3
   \   00000082   0xF201 0x4034      ADDW     R0,R1,#+1076
   \   00000086   0xEE80 0x0A01      VDIV.F32 S0,S0,S2
   \   0000008A   0xED80 0x0A00      VSTR     S0,[R0, #0]
    104          
    105          		if(Torque_Brake_Max > (My_Max_Braking_Torque))
   \   0000008E   0xF8D1 0x0444      LDR      R0,[R1, #+1092]
   \   00000092   0xEE01 0x0A10      VMOV     S2,R0
   \   00000096   0xEEB4 0x1A40      VCMP.F32 S2,S0
   \   0000009A   0xEEF1 0xFA10      FMSTAT   
   \   0000009E   0xD508             BPL.N    ??Braking__SpeedCtrlHandler_1
    106          		{
    107          			Torque_Brake_Max = (My_Max_Braking_Torque);
   \   000000A0   0xF201 0x4034      ADDW     R0,R1,#+1076
   \   000000A4   0xED80 0x1A00      VSTR     S2,[R0, #0]
    108          		}
    109          		else
    110          		{
    111          			if (Torque_Brake_Max < Torque_Brake_Max_thr)
    112          			{
    113          				Torque_Brake_Max = 0;
    114          				Torque_Brake_Max_thr = MIN_BRAKE_TORQUE;
    115          			}
    116          			else
    117          			{   // hysteresis threshold updated
    118          			    Torque_Brake_Max_thr = MIN_BRAKE_TORQUE_THR * MIN_BRAKE_TORQUE;
    119          			}
    120          		}
    121              }
    122              else
    123              {
    124                  if (SpeedRefGen__GetStatus() == SPEED_REF_ACCELERATING)
    125                  {
    126                      // Keep max braking to Tmax_no_braking_request according to target speed
    127                      if (SpeedRefGen__GetSpeedTarget() < BRAKING_SPEED_THR)
    128                      {
    129                          Torque_Brake_Max = TMAX_BRAKING_NO_REQ_LOW_SPEED;
    130                      }
    131                      else
    132                      {
    133                          Torque_Brake_Max = TMAX_BRAKING_NO_REQ_HIGH_SPEED;
    134                      }
    135                  }
    136              }
    137          
    138              return(Torque_Brake_Max);
   \   000000A8   0xF8D1 0x0434      LDR      R0,[R1, #+1076]
   \   000000AC   0xEE00 0x0A10      VMOV     S0,R0
   \   000000B0   0x4770             BX       LR
   \                     ??Braking__SpeedCtrlHandler_1: (+1)
   \   000000B2   0xF8D1 0x043C      LDR      R0,[R1, #+1084]
   \   000000B6   0xEE01 0x0A10      VMOV     S2,R0
   \   000000BA   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   000000BE   0xEEF1 0xFA10      FMSTAT   
   \   000000C2   0xD50B             BPL.N    ??Braking__SpeedCtrlHandler_2
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0xF8C1 0x0434      STR      R0,[R1, #+1076]
   \   000000CA   0xF201 0x403C      ADDW     R0,R1,#+1084
   \   000000CE   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
   \   000000D2   0xF8D1 0x0434      LDR      R0,[R1, #+1076]
   \   000000D6   0xEE00 0x0A10      VMOV     S0,R0
   \   000000DA   0x4770             BX       LR
   \                     ??Braking__SpeedCtrlHandler_2: (+1)
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable66_3  ;; 0x3da3d70b
   \   000000E0   0xF8C1 0x043C      STR      R0,[R1, #+1084]
   \   000000E4   0xF8D1 0x0434      LDR      R0,[R1, #+1076]
   \   000000E8   0xEE00 0x0A10      VMOV     S0,R0
   \   000000EC   0x4770             BX       LR
   \                     ??Braking__SpeedCtrlHandler_0: (+1)
   \   000000EE   0xF8D1 0x04D8      LDR      R0,[R1, #+1240]
   \   000000F2   0xEE00 0x0A10      VMOV     S0,R0
   \   000000F6   0xF8D1 0x04DC      LDR      R0,[R1, #+1244]
   \   000000FA   0xEEF0 0x0AC0      VABS.F32 S1,S0
   \   000000FE   0xEE01 0x0A10      VMOV     S2,R0
   \   00000102   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   00000106   0xEEF0 0x1AC1      VABS.F32 S3,S2
   \   0000010A   0xEE20 0x2A01      VMUL.F32 S4,S0,S2
   \   0000010E   0xEEF1 0xFA10      FMSTAT   
   \   00000112   0xBF07             ITTEE    EQ 
   \   00000114   0xEEF5 0x1A40      VCMPEQ.F32 S3,#0.0
   \   00000118   0xEEF1 0xFA10      FMSTATEQ 
   \   0000011C   0xEEB4 0x0A41      VCMPNE.F32 S0,S2
   \   00000120   0xEEF1 0xFA10      FMSTATNE 
   \   00000124   0xD015             BEQ.N    ??Braking__SpeedCtrlHandler_3
   \   00000126   0xEEB5 0x2A40      VCMP.F32 S4,#0.0
   \   0000012A   0xEEF1 0xFA10      FMSTAT   
   \   0000012E   0xDB10             BLT.N    ??Braking__SpeedCtrlHandler_3
   \   00000130   0xEEF4 0x0A61      VCMP.F32 S1,S3
   \   00000134   0xEEF1 0xFA10      FMSTAT   
   \   00000138   0xD40B             BMI.N    ??Braking__SpeedCtrlHandler_3
   \   0000013A   0xEDDF 0x....      VLDR.W   S1,??DataTable55_3  ;; 0x4346f7b0
   \   0000013E   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000142   0xEEF1 0xFA10      FMSTAT   
   \   00000146   0xBF4C             ITE      MI 
   \   00000148   0x.... 0x....      LDRMI.W  R0,??DataTable66_1  ;; 0x3e4ccccd
   \   0000014C   0x2000             MOVPL    R0,#+0
   \   0000014E   0xF8C1 0x0434      STR      R0,[R1, #+1076]
   \                     ??Braking__SpeedCtrlHandler_3: (+1)
   \   00000152   0xF8D1 0x0434      LDR      R0,[R1, #+1076]
   \   00000156   0xEE00 0x0A10      VMOV     S0,R0
   \   0000015A   0x4770             BX       LR               ;; return
    139          }
    140          
    141          /* Executed in 1ms handler */

   \                                 In section .text, align 4, keep-with-next
    142          float32 Braking__DqRefHandler(MCL_DQ_REF_IO_F_TYPE *io, MCL_DQ_REF_PARAMS_TYPE *params)
                                                                                                 ^
Remark[Pe826]: parameter "params" was never referenced
    143          {
    144          #ifndef BRAKING__CONSERVATIVE_VARIANT
    145              float32 iq;
    146              float32 iq_2;
    147              float32 id_2;
    148              float32 is_2;
    149              float32 torque_abs;
    150              float32 stator_resistance;
    151              float32 power_mech;
    152          #endif
    153              float32 speed;
    154          
    155              speed = *(io->Ctrl_Specific->Speed_Rotor_Observed_Mech);
   \                     Braking__DqRefHandler: (+1)
   \   00000000   0x6982             LDR      R2,[R0, #+24]
   \   00000002   0x68D1             LDR      R1,[R2, #+12]
   \   00000004   0xED91 0x0A00      VLDR     S0,[R1, #0]
    156          
    157          
    158              // Check if in braking state
    159              if(SpeedRefGen__GetStatus() == SPEED_REF_DECELERATING)
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable59_3
   \   0000000C   0xF8D1 0x34D8      LDR      R3,[R1, #+1240]
   \   00000010   0xEE00 0x3A90      VMOV     S1,R3
   \   00000014   0xF8D1 0x34DC      LDR      R3,[R1, #+1244]
   \   00000018   0xEEB0 0x1AE0      VABS.F32 S2,S1
   \   0000001C   0xEE01 0x3A90      VMOV     S3,R3
   \   00000020   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   00000024   0xEEB0 0x2AE1      VABS.F32 S4,S3
   \   00000028   0xEE60 0x2AA1      VMUL.F32 S5,S1,S3
   \   0000002C   0xEEF1 0xFA10      FMSTAT   
   \   00000030   0xBF07             ITTEE    EQ 
   \   00000032   0xEEB5 0x2A40      VCMPEQ.F32 S4,#0.0
   \   00000036   0xEEF1 0xFA10      FMSTATEQ 
   \   0000003A   0xEEF4 0x0A61      VCMPNE.F32 S1,S3
   \   0000003E   0xEEF1 0xFA10      FMSTATNE 
   \   00000042   0xD02B             BEQ.N    ??Braking__DqRefHandler_0
   \   00000044   0xEEF5 0x2A40      VCMP.F32 S5,#0.0
   \   00000048   0xEEF1 0xFA10      FMSTAT   
   \   0000004C   0xDB04             BLT.N    ??Braking__DqRefHandler_1
   \   0000004E   0xEEB4 0x1A42      VCMP.F32 S2,S4
   \   00000052   0xEEF1 0xFA10      FMSTAT   
   \   00000056   0xD521             BPL.N    ??Braking__DqRefHandler_0
    160              {
    161                  if(speed > 0)
   \                     ??Braking__DqRefHandler_1: (+1)
   \   00000058   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000005C   0xEEF1 0xFA10      FMSTAT   
   \   00000060   0xDD0B             BLE.N    ??Braking__DqRefHandler_2
    162                  {
    163                      if((*io->Torque_Ref) <= 0)
   \   00000062   0x6803             LDR      R3,[R0, #+0]
   \   00000064   0xED93 0x0A00      VLDR     S0,[R3, #0]
   \   00000068   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000006C   0xEEF1 0xFA10      FMSTAT   
   \   00000070   0xD837             BHI.N    ??Braking__DqRefHandler_3
    164                      {
    165                          io->Ctrl_Specific->flags.bit.braking_active = 1;
    166                      }
    167                  }
    168                  else if(speed < 0)
    169                  {
    170                      if((*io->Torque_Ref) > 0)
    171                      {
    172                          io->Ctrl_Specific->flags.bit.braking_active = 1;
   \   00000072   0x6813             LDR      R3,[R2, #+0]
   \   00000074   0xF043 0x0380      ORR      R3,R3,#0x80
   \   00000078   0xE032             B.N      ??Braking__DqRefHandler_4
   \                     ??Braking__DqRefHandler_2: (+1)
   \   0000007A   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000007E   0xEEF1 0xFA10      FMSTAT   
   \   00000082   0xD52E             BPL.N    ??Braking__DqRefHandler_3
   \   00000084   0x6803             LDR      R3,[R0, #+0]
   \   00000086   0xED93 0x0A00      VLDR     S0,[R3, #0]
   \   0000008A   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000008E   0xEEF1 0xFA10      FMSTAT   
   \   00000092   0xDD26             BLE.N    ??Braking__DqRefHandler_3
   \   00000094   0x6813             LDR      R3,[R2, #+0]
   \   00000096   0xF043 0x0380      ORR      R3,R3,#0x80
   \   0000009A   0xE021             B.N      ??Braking__DqRefHandler_4
    173                      }
    174                  }
    175              }
    176              else
    177              {
    178                  if(speed > 0 && (*io->Torque_Ref) > 0)
   \                     ??Braking__DqRefHandler_0: (+1)
   \   0000009C   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000000A0   0xEEF1 0xFA10      FMSTAT   
   \   000000A4   0xBFC1             ITTTT    GT 
   \   000000A6   0x6803             LDRGT    R3,[R0, #+0]
   \   000000A8   0xEDD3 0x0A00      VLDRGT   S1,[R3, #0]
   \   000000AC   0xEEF5 0x0A40      VCMPGT.F32 S1,#0.0
   \   000000B0   0xEEF1 0xFA10      FMSTATGT 
   \   000000B4   0xDD03             BLE.N    ??Braking__DqRefHandler_5
    179                  {
    180                      io->Ctrl_Specific->flags.bit.braking_active = 0;
   \   000000B6   0x6813             LDR      R3,[R2, #+0]
   \   000000B8   0xF023 0x0380      BIC      R3,R3,#0x80
   \   000000BC   0x6013             STR      R3,[R2, #+0]
    181                  }
    182          
    183                  if(speed < 0 && (*io->Torque_Ref) < 0)
   \                     ??Braking__DqRefHandler_5: (+1)
   \   000000BE   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000000C2   0xEEF1 0xFA10      FMSTAT   
   \   000000C6   0xBF41             ITTTT    MI 
   \   000000C8   0x6802             LDRMI    R2,[R0, #+0]
   \   000000CA   0xED92 0x0A00      VLDRMI   S0,[R2, #0]
   \   000000CE   0xEEB5 0x0A40      VCMPMI.F32 S0,#0.0
   \   000000D2   0xEEF1 0xFA10      FMSTATMI 
   \   000000D6   0xD504             BPL.N    ??Braking__DqRefHandler_3
    184                  {
    185                      io->Ctrl_Specific->flags.bit.braking_active = 0;
   \   000000D8   0x6982             LDR      R2,[R0, #+24]
   \   000000DA   0x6813             LDR      R3,[R2, #+0]
   \   000000DC   0xF023 0x0380      BIC      R3,R3,#0x80
   \                     ??Braking__DqRefHandler_4: (+1)
   \   000000E0   0x6013             STR      R3,[R2, #+0]
    186                  }
    187              }
    188          
    189          
    190          
    191          
    192              /*==============================================================================================*/
    193              /*           Braking Calculation for Id injection - Rotor reference frame with SPM approximation*/
    194              /*==============================================================================================*/
    195              /*
    196               * Calculation of Id for braking
    197               * Id = sqrt[T*w/Rs - (T/Kt)^2]
    198               * */
    199              if(io->Ctrl_Specific->flags.bit.braking_active == 1)
   \                     ??Braking__DqRefHandler_3: (+1)
   \   000000E2   0x6980             LDR      R0,[R0, #+24]
   \   000000E4   0xF8D1 0x242C      LDR      R2,[R1, #+1068]
   \   000000E8   0x6800             LDR      R0,[R0, #+0]
   \   000000EA   0xEE00 0x2A90      VMOV     S1,R2
   \   000000EE   0xF3C0 0x10C0      UBFX     R0,R0,#+7,#+1
   \   000000F2   0xB188             CBZ.N    R0,??Braking__DqRefHandler_6
    200              {
    201              #ifndef BRAKING__CONSERVATIVE_VARIANT
    202                  if (Torque_Brake_Max>0)
    203                  {
    204                              
    205                      power_mech =  *(io->Torque_Ref) * speed;
    206                      if (power_mech < 0)  // check if real brake request
    207                      {
    208                          torque_abs = MATHCALC__FABS(*(io->Torque_Ref));
    209                          power_mech = torque_abs * Speed_Filtered;
    210          
    211          
    212                          stator_resistance = Braking_Resistance + 0.01f;     // Avoid zero division.
    213                          is_2 = power_mech / (1.5f*stator_resistance);       // I_max_braking^2 = Pmech / Rs
    214                          iq = torque_abs * params->K_torque_inv;               // Iq current calculation
    215                          iq_2 = (iq * iq);                                   // Iq squared current calculation
    216          
    217          
    218                          id_2 = (is_2 - iq_2);
    219                          if(id_2 > 0 )
    220                          {
    221                               Id_Braking_Target = -MC_SQRT_F(id_2);         // Id_Braking here is a module (need to handle signal)
    222                          }
    223                          // do not update Id_Braking if the argument of the square root is negative
    224                          if(Id_Braking_Target < Id_Braking_Max)
    225                          { /* clamp to the maximum value of Id */
    226                             Id_Braking_Target = Id_Braking_Max;
    227                          }
    228                          Id_Braking -= ID_BRAKING_PROP_GAIN * (Id_Braking - Id_Braking_Target);
    229          
    230                       }
    231                      // do not update Id_Braking if torque and speed have the same sign
    232                  }
    233              #else
    234                  Id_Braking_Target = Id_Braking_Max;
    235                  Id_Braking -= ID_BRAKING_PROP_GAIN * (Id_Braking - Id_Braking_Target);
   \   000000F4   0xF8D1 0x0430      LDR      R0,[R1, #+1072]
   \   000000F8   0xEE00 0x0A10      VMOV     S0,R0
   \   000000FC   0xEE30 0x1A60      VSUB.F32 S2,S0,S1
   \   00000100   0xEDDF 0x....      VLDR.W   S3,??DataTable56  ;; 0x3ca3d70a
   \   00000104   0xEE41 0x0A21      VMLA.F32 S1,S2,S3
    236              #endif
    237          
    238          
    239                  if(Id_Braking < Id_Braking_Max)
   \   00000108   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   0000010C   0xEEF1 0xFA10      FMSTAT   
   \   00000110   0xD50D             BPL.N    ??Braking__DqRefHandler_7
    240                  { /* clamp to the maximum value of Id */
    241                     Id_Braking = Id_Braking_Max;
   \   00000112   0xEEF0 0x0A40      VMOV.F32 S1,S0
   \   00000116   0xE00A             B.N      ??Braking__DqRefHandler_7
    242                  }
    243              }
    244              else
    245              {
    246                  /* Here there is not braking required (flag_under_braking is zero)
    247                   * If not braking then move Id_Braking slowly towards zero.
    248                   */
    249                  if (Id_Braking < 0)
   \                     ??Braking__DqRefHandler_6: (+1)
   \   00000118   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   0000011C   0xEEF1 0xFA10      FMSTAT   
   \   00000120   0xBF46             ITTE     MI 
    250                  {
    251                      Id_Braking += ID_BRAKE_STEP;
   \   00000122   0xED9F 0x....      VLDRMI.W S0,??DataTable56_1  ;; 0x3d4ccccd
   \   00000126   0xEE70 0x0A80      VADDMI.F32 S1,S1,S0
    252                  }
    253                  else
    254                  {
    255                      Id_Braking = 0;
   \   0000012A   0xEDDF 0x....      VLDRPL.W S1,??DataTable56_2  ;; 0x0
   \                     ??Braking__DqRefHandler_7: (+1)
   \   0000012E   0xF201 0x402C      ADDW     R0,R1,#+1068
   \   00000132   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
    256                  }
    257              }
    258              return(Id_Braking);
   \   00000136   0xF8D1 0x042C      LDR      R0,[R1, #+1068]
   \   0000013A   0xEE00 0x0A10      VMOV     S0,R0
   \   0000013E   0x4770             BX       LR               ;; return
    259          }
    260          //=====================================================================================================================
    261          //-------------------------------------- Private Functions ------------------------------------------------------------
    262          //=====================================================================================================================
C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\Mcl\MacroBlocks\MclDqCtrl.c
      1          /**
      2           *  @file
      3           *  @brief       Motor Control Loop Speed Controller .
      4           *  @details     This module implements the Speed Control module.
      5           *  @author      alessio.beato/luigi.fagnano  (only temporary, since it is not integrated in MKS)
      6           *  $Header: FOC/Mcl.c 1.12 2015/11/25 18:36:02CET Luigi Fagnano (FAGNAL) Exp  $
      7           * @copyright Copyright 2012 - $Date: 2015/11/25 18:36:02CET $. Whirlpool Corporation. All rights reserved  CONFIDENTIAL
      8          */
      9          /*
     10           *
     11           *---------------------------------------------------------------------------------------------------------------------
     12           *---------------------------------------------------------------------------------------------------------------------
     13           */
     14          //-------------------------------------- Include Files ----------------------------------------------------------------
     15          #include "MclDqCtrl.h"
     16          #include "MclConfig.h"
     17          #include "McMathCalc_macros.h"
     18          #include "Pi.h"
     19          #include "MathCalc.h"
     20          #include "ClrkPark.h"
     21          
     22          
     23          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     24          #ifndef SQRT3_INV
     25              #define SQRT3_INV     (float32) (1.0f/1.7320508075688772935274463415059f)
     26          #endif
     27          
     28          #ifndef RPM_TO_RADS
     29              #define RPM_TO_RADS     0.10471975511965977461542144610932f
     30          #endif
     31          
     32          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     33          
     34          
     35          PI_CONTROLLER_F_TYPE Flux_Controller;
     36          PI_CONTROLLER_F_TYPE Torque_Controller;
     37          
     38          
     39          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
     40          
     41          void Torque_Flux_Gains_Scheduler(MCL_DQ_CTRL_IO_F_TYPE *io, MCL_DQ_CTRL_PARAMS_TYPE *params);
     42          float32 HexagonTrajectoryCalculation(MCL_DQ_CTRL_IO_F_TYPE *io);
     43          
     44          
     45          //=====================================================================================================================
     46          //-------------------------------------- Public Functions -------------------------------------------------------------
     47          //=====================================================================================================================
     48          
     49          
     50          
     51          
     52          //---------------------------------------------------------------------------------------------------------------------
     53          /**
     54           *  @brief      Reset all Mcl Dq Reference Controllers quantities.
     55           *  @details    This routine reset all q Reference Controllers quantities, it has to be called at every time the pwm is switched off (motor stop or free down ramp).
     56           *
     57           *
     58           *  @param[in]     
     59           *  @param[Out]
     60           *  @return        
     61           */

   \                                 In section .text, align 2, keep-with-next
     62          void MclDqCtrl__ResetState(MCL_DQ_CTRL_IO_F_TYPE *io, MCL_DQ_CTRL_PARAMS_TYPE *params)
     63          {
     64              //Private variables reset
     65              io->Vs_Alpha_Beta->Alpha = 0.0f;
   \                     MclDqCtrl__ResetState: (+1)
   \   00000000   0x6A42             LDR      R2,[R0, #+36]
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x6053             STR      R3,[R2, #+4]
     66              io->Vs_Alpha_Beta->Beta = 0.0f;
   \   00000006   0x6A40             LDR      R0,[R0, #+36]
   \   00000008   0x6083             STR      R3,[R0, #+8]
     67          
     68              Torque_Controller.Kp = params->gains[0].torque_kp;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable64_3
   \   0000000E   0x690A             LDR      R2,[R1, #+16]
   \   00000010   0xF8C0 0x22A8      STR      R2,[R0, #+680]
     69              Torque_Controller.Ki = params->gains[0].torque_ki;
   \   00000014   0x694A             LDR      R2,[R1, #+20]
   \   00000016   0xF8C0 0x22AC      STR      R2,[R0, #+684]
     70          
     71              Torque_Controller.Integ_K_1 = 0.0f;
   \   0000001A   0xF8C0 0x32A0      STR      R3,[R0, #+672]
     72              Torque_Controller.Out = 0.0f;
   \   0000001E   0xF8C0 0x32A4      STR      R3,[R0, #+676]
     73          
     74              Flux_Controller.Kp = params->gains[0].flux_kp;
   \   00000022   0x698A             LDR      R2,[R1, #+24]
   \   00000024   0xF8C0 0x228C      STR      R2,[R0, #+652]
     75              Flux_Controller.Ki = params->gains[0].flux_ki;
   \   00000028   0x69CA             LDR      R2,[R1, #+28]
   \   0000002A   0xF8C0 0x2290      STR      R2,[R0, #+656]
     76          
     77              Flux_Controller.Out = 0.0f;
   \   0000002E   0xF8C0 0x3288      STR      R3,[R0, #+648]
     78              Flux_Controller.Integ_K_1 = 0.0f;
   \   00000032   0xF8C0 0x3284      STR      R3,[R0, #+644]
     79          
     80              Flux_Controller.Upper_Limit =  params->Vd_Max;
   \   00000036   0x680A             LDR      R2,[R1, #+0]
   \   00000038   0xF8C0 0x2294      STR      R2,[R0, #+660]
     81              Flux_Controller.Lower_Limit = -params->Vd_Max;
   \   0000003C   0xED91 0x0A00      VLDR     S0,[R1, #0]
   \   00000040   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   00000044   0xED80 0x0AA6      VSTR     S0,[R0, #+664]
     82          }
   \   00000048   0x4770             BX       LR               ;; return
     83          
     84          
     85          //---------------------------------------------------------------------------------------------------------------------
     86          /**
     87           *  @brief      Motor Control Loop initialization.
     88           *  @details    In this routine are called all initialization functions.
     89           *
     90           *
     91           *  @param[in]     
     92           *  @param[Out]
     93           *  @param[in]      
     94           *  @return        
     95           */

   \                                 In section .text, align 2, keep-with-next
     96          void MclDqCtrl__Initialize(MCL_DQ_CTRL_IO_F_TYPE *io, MCL_DQ_CTRL_PARAMS_TYPE *params)
     97          {
     98          	// reset MCL quantities
     99          	MclDqCtrl__ResetState(io, params);
   \                     MclDqCtrl__Initialize: (+1)
   \   00000000   0x6A42             LDR      R2,[R0, #+36]
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x6053             STR      R3,[R2, #+4]
   \   00000006   0x6A40             LDR      R0,[R0, #+36]
   \   00000008   0x6083             STR      R3,[R0, #+8]
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable64_3
   \   0000000E   0x690A             LDR      R2,[R1, #+16]
   \   00000010   0xF8C0 0x22A8      STR      R2,[R0, #+680]
   \   00000014   0x694A             LDR      R2,[R1, #+20]
   \   00000016   0xF8C0 0x22AC      STR      R2,[R0, #+684]
   \   0000001A   0xF8C0 0x32A0      STR      R3,[R0, #+672]
   \   0000001E   0xF8C0 0x32A4      STR      R3,[R0, #+676]
   \   00000022   0x698A             LDR      R2,[R1, #+24]
   \   00000024   0xF8C0 0x228C      STR      R2,[R0, #+652]
   \   00000028   0x69CA             LDR      R2,[R1, #+28]
   \   0000002A   0xF8C0 0x2290      STR      R2,[R0, #+656]
   \   0000002E   0xF8C0 0x3288      STR      R3,[R0, #+648]
   \   00000032   0xF8C0 0x3284      STR      R3,[R0, #+644]
   \   00000036   0x680A             LDR      R2,[R1, #+0]
   \   00000038   0xF8C0 0x2294      STR      R2,[R0, #+660]
   \   0000003C   0xED91 0x0A00      VLDR     S0,[R1, #0]
   \   00000040   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   00000044   0xED80 0x0AA6      VSTR     S0,[R0, #+664]
    100          }
   \   00000048   0x4770             BX       LR               ;; return
    101          

   \                                 In section .text, align 2, keep-with-next
    102          void MclDqCtrl__OverrideRegGains(MCL_DQ_CTRL_PARAMS_TYPE *params)
    103          {
    104          
    105              Torque_Controller.Kp = params->gains[0].torque_kp;
   \                     MclDqCtrl__OverrideRegGains: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable64_3
   \   00000004   0x6902             LDR      R2,[R0, #+16]
   \   00000006   0xF8C1 0x22A8      STR      R2,[R1, #+680]
    106              Torque_Controller.Ki = params->gains[0].torque_ki;
   \   0000000A   0x6942             LDR      R2,[R0, #+20]
   \   0000000C   0xF8C1 0x22AC      STR      R2,[R1, #+684]
    107              Flux_Controller.Kp = params->gains[0].flux_kp;
   \   00000010   0x6982             LDR      R2,[R0, #+24]
   \   00000012   0xF8C1 0x228C      STR      R2,[R1, #+652]
    108              Flux_Controller.Ki = params->gains[0].flux_ki;
   \   00000016   0x69C0             LDR      R0,[R0, #+28]
   \   00000018   0xF8C1 0x0290      STR      R0,[R1, #+656]
    109          }
   \   0000001C   0x4770             BX       LR               ;; return
    110          
    111          //---------------------------------------------------------------------------------------------------------------------
    112          /**
    113           *  @brief     Dq Reference Controllers
    114           *  @details   Dq Controller:   DQ PI execution (FOC: current PI, DTC: flux/torque PI)
    115           *                              alpha-beta voltage reference generation
    116           *  @param[in]     
    117           *  @param[Out]
    118           *  @param[in]      
    119           *  @return        
    120           */

   \                                 In section .text, align 4, keep-with-next
    121          void MclDqCtrl__RunningHandler(MCL_DQ_CTRL_IO_F_TYPE *io, MCL_DQ_CTRL_PARAMS_TYPE *params)
    122          {
   \                     MclDqCtrl__RunningHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    123              float32 vs_max;
    124              float32 vd_out;
    125              float32 vq_out_max;
    126              float32 temp;
    127              ALPHA_BETA_COOR_SYST_F_TYPE temp_vdq;  // used for phase advance angle rotation
    128              DQ_COOR_SYST_F_TYPE dq_in;
    129              SIN_COS_F_TYPE sin_cos;
    130          
    131              dq_in.ZeroSequence = 0.0f;
    132              temp_vdq.ZeroSequence = 0.0f;
    133          
    134              //==========================================================================//
    135              //                           Flux control loop                              //
    136              //==========================================================================//
    137              Flux_Controller.Err = *(io->D_Ref) -  *(io->D_Est);
   \   00000004   0x....             LDR.N    R6,??DataTable59_3
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   0000000C   0x6860             LDR      R0,[R4, #+4]
   \   0000000E   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000012   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   00000016   0x460D             MOV      R5,R1
   \   00000018   0xED86 0x0AA0      VSTR     S0,[R6, #+640]
    138              Pi__CalcPiF(&Flux_Controller);
   \   0000001C   0xF506 0x7020      ADD      R0,R6,#+640
   \   00000020   0x.... 0x....      BL       Pi__CalcPiF
    139              vd_out = Flux_Controller.Out;
    140          
    141          
    142              //==========================================================================//
    143              //                          Torque control loop                             //
    144              //==========================================================================//
    145          #ifdef DQCTRL__HEXAGON_LIMIT
    146              //hexagon trajectory
    147              temp = HexagonTrajectoryCalculation(io);
    148              // Calculate the maximum available vq voltage considering the desired usage of available DC bus voltage
    149                  vs_max = (*(io->Vdc) * SQRT3_INV) * temp;
    150          #else
    151                  vs_max = (*(io->Vdc) * SQRT3_INV) * params->m_index;
   \   00000024   0x69E0             LDR      R0,[R4, #+28]
   \   00000026   0xED96 0x0AA2      VLDR     S0,[R6, #+648]
   \   0000002A   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   0000002E   0xED9F 0x....      VLDR.W   S2,??DataTable58  ;; 0x3f13cd3a
   \   00000032   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   00000036   0xED95 0x1A03      VLDR     S2,[R5, #+12]
   \   0000003A   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
    152          #endif
    153          
    154          
    155              /*! Vq limitation is given by:
    156               * \f[
    157               * \begin{aligned}
    158               *      &V_{qmax} = \sqrt{V_{smax}^2 - v_{ds}^2}
    159               * \end{aligned}
    160               * \f]
    161               */
    162              vq_out_max  = vs_max*vs_max;
    163              vq_out_max -= vd_out*vd_out;
    164              vq_out_max = MC_SQRT_F(vq_out_max);
   \   0000003E   0xEE60 0x0AA0      VMUL.F32 S1,S1,S1
   \   00000042   0xEE40 0x0A40      VMLS.F32 S1,S0,S0
   \   00000046   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   0000004A   0xEEF1 0xFA10      FMSTAT   
   \   0000004E   0xDB02             BLT.N    ??MclDqCtrl__RunningHandler_0
   \   00000050   0xEEB1 0x0AE0      VSQRT.F32 S0,S1
   \   00000054   0xE001             B.N      ??MclDqCtrl__RunningHandler_1
   \                     ??MclDqCtrl__RunningHandler_0: (+1)
   \   00000056   0xED9F 0x....      VLDR.W   S0,??DataTable56_2  ;; 0x0
    165          
    166          
    167              Torque_Controller.Upper_Limit =  vq_out_max;
   \                     ??MclDqCtrl__RunningHandler_1: (+1)
   \   0000005A   0xED86 0x0AAC      VSTR     S0,[R6, #+688]
    168              Torque_Controller.Lower_Limit = -vq_out_max;
   \   0000005E   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   00000062   0xED86 0x0AAD      VSTR     S0,[R6, #+692]
    169          
    170              Torque_Controller.Err = *(io->Q_Ref) -  *(io->Q_Est);
   \   00000066   0x68A0             LDR      R0,[R4, #+8]
   \   00000068   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   0000006C   0x68E0             LDR      R0,[R4, #+12]
   \   0000006E   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000072   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   00000076   0xED86 0x0AA7      VSTR     S0,[R6, #+668]
    171              Pi__CalcPiF(&Torque_Controller);
   \   0000007A   0xF506 0x7027      ADD      R0,R6,#+668
   \   0000007E   0x.... 0x....      BL       Pi__CalcPiF
    172          
    173          
    174              //==========================================================================//
    175              //          Check and if requested, overwrite the output voltage            //
    176              //==========================================================================//
    177              if( (io->Force_Out_Volt->D != 0) ||
    178                  (io->Force_Out_Volt->Q != 0) )
   \   00000082   0x6960             LDR      R0,[R4, #+20]
   \   00000084   0xED90 0x0A01      VLDR     S0,[R0, #+4]
   \   00000088   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000008C   0xEEF1 0xFA10      FMSTAT   
   \   00000090   0xBF02             ITTT     EQ 
   \   00000092   0xEDD0 0x0A02      VLDREQ   S1,[R0, #+8]
   \   00000096   0xEEF5 0x0A40      VCMPEQ.F32 S1,#0.0
   \   0000009A   0xEEF1 0xFA10      FMSTATEQ 
   \   0000009E   0xD011             BEQ.N    ??MclDqCtrl__RunningHandler_2
    179              {
    180                  dq_in.D = io->Force_Out_Volt->D;
    181                  temp    = io->Force_Out_Volt->D;
    182          
    183                  // Load the integral of PI with the output voltage
    184                  Flux_Controller.Integ_K_1= temp;
   \   000000A0   0xED86 0x0AA1      VSTR     S0,[R6, #+644]
    185                  Flux_Controller.Out = temp;
   \   000000A4   0xED86 0x0AA2      VSTR     S0,[R6, #+648]
   \   000000A8   0x6960             LDR      R0,[R4, #+20]
   \   000000AA   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
    186          
    187          
    188                  dq_in.Q  = io->Force_Out_Volt->Q;
    189                  temp     = io->Force_Out_Volt->Q;
    190          
    191                  // Load the integral of PI with the output voltage
    192                  Torque_Controller.Integ_K_1 = temp;
   \   000000AE   0xEDC6 0x0AA8      VSTR     S1,[R6, #+672]
    193                  Torque_Controller.Out = temp;
   \   000000B2   0xEDC6 0x0AA9      VSTR     S1,[R6, #+676]
    194          
    195                  io->Vs_DQ->D = dq_in.D;
   \   000000B6   0x6A20             LDR      R0,[R4, #+32]
   \   000000B8   0xED80 0x0A01      VSTR     S0,[R0, #+4]
    196                  io->Vs_DQ->Q = dq_in.Q;
   \   000000BC   0x6A20             LDR      R0,[R4, #+32]
   \   000000BE   0xEDC0 0x0A02      VSTR     S1,[R0, #+8]
   \   000000C2   0xE062             B.N      ??MclDqCtrl__RunningHandler_3
    197          
    198              }
    199              else
    200              {
    201                  dq_in.D = Flux_Controller.Out;
    202                  dq_in.Q = Torque_Controller.Out;
    203          
    204                  io->Vs_DQ->D = dq_in.D;
   \                     ??MclDqCtrl__RunningHandler_2: (+1)
   \   000000C4   0x6A20             LDR      R0,[R4, #+32]
   \   000000C6   0xED96 0x0AA2      VLDR     S0,[R6, #+648]
   \   000000CA   0xED96 0x1AA9      VLDR     S2,[R6, #+676]
   \   000000CE   0xED80 0x0A01      VSTR     S0,[R0, #+4]
    205                  io->Vs_DQ->Q = dq_in.Q;
   \   000000D2   0x6A20             LDR      R0,[R4, #+32]
   \   000000D4   0xED80 0x1A02      VSTR     S2,[R0, #+8]
    206          
    207          
    208                  //==========================================================================//
    209                  //                        Phase Advance                                     //
    210                  //==========================================================================//
    211                  #ifdef PWM_DOUBLE_SLOT
    212                  temp = ( *(io->Ctrl_Specific->Speed_Rotor_Observed) * params->Phase_Advance_Coeff * 0.5f); //half the Ts due to double slot (shift 16 instead of 15)
    213                  #else
    214                  temp = ( *(io->Ctrl_Specific->Speed_Rotor_Observed) * params->Phase_Advance_Coeff );
    215                  #endif
    216          
    217                  MathCalc__SinCosF(temp,  &sin_cos);
   \   000000D8   0x6AA0             LDR      R0,[R4, #+40]
   \   000000DA   0xEDD5 0x1A02      VLDR     S3,[R5, #+8]
   \   000000DE   0x6880             LDR      R0,[R0, #+8]
   \   000000E0   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   000000E4   0xEE60 0x0AA1      VMUL.F32 S1,S1,S3
   \   000000E8   0xEDDF 0x....      VLDR.W   S3,??DataTable59  ;; 0x3e22f983
   \   000000EC   0xEE60 0x0AA1      VMUL.F32 S1,S1,S3
   \   000000F0   0xEEFD 0x1AE0      VCVT.S32.F32 S3,S1
   \   000000F4   0xEE11 0x0A90      VMOV     R0,S3
   \   000000F8   0xEDDF 0x....      VLDR.W   S3,??DataTable59_1  ;; 0xb4800000
   \   000000FC   0xEEF4 0x0A61      VCMP.F32 S1,S3
   \   00000100   0xEEF1 0xFA10      FMSTAT   
   \   00000104   0xBF48             IT       MI 
   \   00000106   0x1E40             SUBMI    R0,R0,#+1
   \   00000108   0xEE01 0x0A90      VMOV     S3,R0
   \   0000010C   0xEEF8 0x1AE1      VCVT.F32.S32 S3,S3
   \   00000110   0xEE70 0x0AE1      VSUB.F32 S1,S1,S3
   \   00000114   0xEDDF 0x....      VLDR.W   S3,??DataTable59_2  ;; 0x44000000
   \   00000118   0xEE60 0x0AA1      VMUL.F32 S1,S1,S3
   \   0000011C   0xEEFD 0x1AE0      VCVT.S32.F32 S3,S1
   \   00000120   0xEE11 0x0A90      VMOV     R0,S3
   \   00000124   0x05C0             LSLS     R0,R0,#+23
   \   00000126   0x0DC0             LSRS     R0,R0,#+23
   \   00000128   0xF100 0x0180      ADD      R1,R0,#+128
   \   0000012C   0x4602             MOV      R2,R0
   \   0000012E   0x05C9             LSLS     R1,R1,#+23
   \   00000130   0xEE01 0x2A90      VMOV     S3,R2
   \   00000134   0x0DC9             LSRS     R1,R1,#+23
   \   00000136   0x.... 0x....      LDR.W    R2,??DataTable66_9
   \   0000013A   0xEEF8 0x1A61      VCVT.F32.U32 S3,S3
   \   0000013E   0xEB02 0x0381      ADD      R3,R2,R1, LSL #+2
   \   00000142   0xEE70 0x0AE1      VSUB.F32 S1,S1,S3
   \   00000146   0xEB02 0x0181      ADD      R1,R2,R1, LSL #+2
   \   0000014A   0xEEF7 0x1A00      VMOV.F32 S3,#1.0
   \   0000014E   0xEE71 0x1AE0      VSUB.F32 S3,S3,S1
   \   00000152   0xED93 0x2A00      VLDR     S4,[R3, #0]
   \   00000156   0xEDD1 0x2A01      VLDR     S5,[R1, #+4]
   \   0000015A   0xEE21 0x2A82      VMUL.F32 S4,S3,S4
   \   0000015E   0xEB02 0x0180      ADD      R1,R2,R0, LSL #+2
   \   00000162   0xEE00 0x2AA2      VMLA.F32 S4,S1,S5
   \   00000166   0xEDD1 0x2A00      VLDR     S5,[R1, #0]
   \   0000016A   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \   0000016E   0xEE61 0x1AA2      VMUL.F32 S3,S3,S5
   \   00000172   0xEDD0 0x2A01      VLDR     S5,[R0, #+4]
   \   00000176   0xEE40 0x1AA2      VMLA.F32 S3,S1,S5
    218          
    219          
    220                  ClrkPark__InverseParkF(&dq_in, &temp_vdq, &sin_cos);
   \   0000017A   0xEE60 0x0A21      VMUL.F32 S1,S0,S3
    221          
    222                  dq_in.D = temp_vdq.Alpha;
   \   0000017E   0xEE20 0x0A02      VMUL.F32 S0,S0,S4
   \   00000182   0xEE41 0x0A02      VMLA.F32 S1,S2,S4
   \   00000186   0xEE01 0x0A61      VMLS.F32 S0,S2,S3
    223                  dq_in.Q = temp_vdq.Beta;
    224              }
    225          
    226              //==========================================================================//
    227              //                Inverse Park transformation (dq-abc)                      //
    228              //==========================================================================//
    229              ClrkPark__InverseParkF(&dq_in, io->Vs_Alpha_Beta, io->Sin_Cos);
   \                     ??MclDqCtrl__RunningHandler_3: (+1)
   \   0000018A   0x6920             LDR      R0,[R4, #+16]
   \   0000018C   0x6A61             LDR      R1,[R4, #+36]
   \   0000018E   0xED90 0x1A01      VLDR     S2,[R0, #+4]
   \   00000192   0xEDD0 0x1A00      VLDR     S3,[R0, #0]
   \   00000196   0xEE20 0x1A01      VMUL.F32 S2,S0,S2
   \   0000019A   0xEE00 0x1AE1      VMLS.F32 S2,S1,S3
   \   0000019E   0xED81 0x1A01      VSTR     S2,[R1, #+4]
   \   000001A2   0xED90 0x1A00      VLDR     S2,[R0, #0]
   \   000001A6   0xEE20 0x0A01      VMUL.F32 S0,S0,S2
   \   000001AA   0xED90 0x1A01      VLDR     S2,[R0, #+4]
   \   000001AE   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   \   000001B2   0xED81 0x0A02      VSTR     S0,[R1, #+8]
   \   000001B6   0x2000             MOVS     R0,#+0
   \   000001B8   0x6008             STR      R0,[R1, #+0]
    230          }
   \   000001BA   0xBD70             POP      {R4-R6,PC}       ;; return
    231          
    232          #ifdef PWM_DOUBLE_SLOT
    233          void MclDqCtrl__2ndRunningHandler(MCL_DQ_CTRL_IO_F_TYPE *io, MCL_DQ_CTRL_PARAMS_TYPE *params)
    234          {
    235              float32 temp_vd;
    236              float32 temp_vq;
    237              float32 temp;
    238              DQ_COOR_SYST_F_TYPE dq_in;
    239              SIN_COS_F_TYPE sin_cos;
    240          
    241              dq_in.D = (io->Vs_DQ->D);
    242              dq_in.Q = (io->Vs_DQ->Q);
    243          
    244              //==========================================================================//
    245              //                        Phase Advance (advance of 1Ts)                    //
    246              //==========================================================================//
    247          #ifdef SIM_SENSORED_MODE
    248              temp = ( *(io->Ctrl_Specific->Speed_Rotor_Observed) * params->Phase_Advance_Coeff * 0.5f); // the sincos is updated from simulation so we just need one phase advance step (halved due to double slot)
    249          #else
    250              temp = ( *(io->Ctrl_Specific->Speed_Rotor_Observed) * params->Phase_Advance_Coeff ); // the sincos is the internal one, so we need two steps (halved due to double slot)
    251          #endif
    252              MathCalc__SinCosF(temp,  &sin_cos);
    253          
    254              temp_vd  = (dq_in.D * sin_cos.Cos); //(Flux_Controller.Out * sin_cos.Cos)>>15;
    255              temp_vd -= (dq_in.Q * sin_cos.Sin); //(Torque_Controller.Out * sin_cos.Sin)>>15;
    256              temp_vq  = (dq_in.D * sin_cos.Sin); //(Flux_Controller.Out * sin_cos.Sin)>>15;
    257              temp_vq += (dq_in.Q * sin_cos.Cos); //(Torque_Controller.Out * sin_cos.Cos)>>15;
    258          
    259              dq_in.D = temp_vd;//Flux_Controller.Out = temp_vd;
    260              dq_in.Q = temp_vq;//Torque_Controller.Out = temp_vq;
    261          
    262          
    263              //==========================================================================//
    264              //                Inverse Park transformation (dq-abc)                      //
    265              //==========================================================================//
    266              ClrkPark__InverseParkF(&dq_in, io->Vs_Alpha_Beta, io->Sin_Cos);
    267          
    268          }
    269          #endif
    270          
    271          

   \                                 In section .text, align 4, keep-with-next
    272          void MclDqCtrl__25msHandler(MCL_DQ_CTRL_IO_F_TYPE *io, MCL_DQ_CTRL_PARAMS_TYPE *params)
   \                     MclDqCtrl__25msHandler: (+1)
   \   00000000   0xBF00             Nop      
   \   00000002   0xBF00             Nop      
    273          {
    274              Torque_Flux_Gains_Scheduler(io, params);
   \   00000004                      REQUIRE Torque_Flux_Gains_Scheduler
   \   00000004                      ;; // Fall through to label Torque_Flux_Gains_Scheduler
    275          }
    276          
    277          
    278          
    279          
    280          
    281          
    282          

   \                                 In section .text, align 4, keep-with-next
    283          void Torque_Flux_Gains_Scheduler(MCL_DQ_CTRL_IO_F_TYPE *io, MCL_DQ_CTRL_PARAMS_TYPE *params)
    284          {
   \                     Torque_Flux_Gains_Scheduler: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    285              static sint32 gains_indexer_previous;
    286              static sint32 gains_indexer;
    287              static sint16 relative_time;
    288              float32 temp_speed_table;
    289              float32 speed_rotor_abs;
    290              float32 delta;
    291              float32 temp_flux_kp;
    292              float32 temp_flux_ki;
    293              float32 temp_torque_kp;
    294              float32 temp_torque_ki;
    295          
    296          
    297              // During starting, use default gains.
    298              if( (*io->Ctrl_Specific->Elapsed_Time_After_Starting) <= (uint32)params->Force_Gains_Starting_Time )
   \   00000002   0x6A82             LDR      R2,[R0, #+40]
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable64_3
   \   00000008   0x6954             LDR      R4,[R2, #+20]
   \   0000000A   0x684B             LDR      R3,[R1, #+4]
   \   0000000C   0x6824             LDR      R4,[R4, #+0]
   \   0000000E   0x42A3             CMP      R3,R4
   \   00000010   0xD314             BCC.N    ??Torque_Flux_Gains_Scheduler_0
    299              {
    300                  Torque_Controller.Kp = params->gains[0].torque_kp;
   \   00000012   0x690A             LDR      R2,[R1, #+16]
   \   00000014   0xF8C0 0x22A8      STR      R2,[R0, #+680]
    301                  Torque_Controller.Ki = params->gains[0].torque_ki;
   \   00000018   0x694A             LDR      R2,[R1, #+20]
   \   0000001A   0xF8C0 0x22AC      STR      R2,[R0, #+684]
    302          
    303                  Flux_Controller.Kp = params->gains[0].flux_kp;
   \   0000001E   0x698A             LDR      R2,[R1, #+24]
   \   00000020   0xF8C0 0x228C      STR      R2,[R0, #+652]
    304                  Flux_Controller.Ki = params->gains[0].flux_ki;
   \   00000024   0x69C9             LDR      R1,[R1, #+28]
   \   00000026   0xF8C0 0x1290      STR      R1,[R0, #+656]
    305          
    306                  // Initialize the variable, since it is starting now...
    307                  gains_indexer_previous = 0;
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0xF8C0 0x144C      STR      R1,[R0, #+1100]
    308                  gains_indexer = 0;
   \   00000030   0xF8C0 0x1450      STR      R1,[R0, #+1104]
    309                  relative_time = 0;
   \   00000034   0xF8A0 0x1382      STRH     R1,[R0, #+898]
    310              }
    311              else // Starting time is already over, so, look for new regions
    312              {
    313                  // Look for new index only if the transition between regions is already done.
    314                  if(gains_indexer == gains_indexer_previous)
    315                  {
    316                      // Save the speed on stack
    317                      speed_rotor_abs = *(io->Ctrl_Specific->Speed_Rotor_Observed_Mech_Abs);
    318          
    319                      // Look for the indexer
    320                      for(gains_indexer = 0; gains_indexer < 5; gains_indexer++)
    321                      {
    322                          // Only one indexed reading is performed
    323                          temp_speed_table = (params->gains[gains_indexer].abs_speed) * RPM_TO_RADS;
    324          
    325                          if(temp_speed_table > 0)
    326                          {
    327                              if( speed_rotor_abs < temp_speed_table )
    328                              {
    329                                  break;
    330                              }
    331                          }
    332                          else
    333                          {
    334                              break;
    335                          }
    336                      }
    337          
    338                      relative_time = 0;
    339                  }
    340                  else //if(gains_indexer != gains_indexer_previous)
    341                  {
    342                      relative_time++;
    343          
    344                      // Calculate flux gains - kp
    345                      delta = (params->gains[gains_indexer].flux_kp) - (params->gains[gains_indexer_previous].flux_kp);
    346                      delta = delta*relative_time;
    347                      delta = delta/(params->gains[gains_indexer].transition_time);
    348                      temp_flux_kp = delta + (params->gains[gains_indexer_previous].flux_kp);
    349          
    350                      // Calculate flux gains - ki
    351                      delta = (params->gains[gains_indexer].flux_ki) - (params->gains[gains_indexer_previous].flux_ki);
    352                      delta = delta*relative_time;
    353                      delta = delta/(params->gains[gains_indexer].transition_time);
    354                      temp_flux_ki = delta + (params->gains[gains_indexer_previous].flux_ki);
    355          
    356          
    357                      // Calculate torque gains - kp
    358                      delta = (params->gains[gains_indexer].torque_kp) - (params->gains[gains_indexer_previous].torque_kp);
    359                      delta = delta*relative_time;
    360                      delta = delta/(params->gains[gains_indexer].transition_time);
    361                      temp_torque_kp = delta + (params->gains[gains_indexer_previous].torque_kp);
    362          
    363                      // Calculate torque gains - ki
    364                      delta = (params->gains[gains_indexer].torque_ki) - (params->gains[gains_indexer_previous].torque_ki);
    365                      delta = delta*relative_time;
    366                      delta = delta/(params->gains[gains_indexer].transition_time);
    367                      temp_torque_ki = delta + (params->gains[gains_indexer_previous].torque_ki);
    368          
    369          
    370                      if(relative_time >= (params->gains[gains_indexer].transition_time))
    371                      {
    372                          gains_indexer_previous = gains_indexer;
    373          
    374                          temp_flux_kp = (params->gains[gains_indexer].flux_kp);
    375                          temp_flux_ki = (params->gains[gains_indexer].flux_ki);
    376          
    377                          temp_torque_kp = (params->gains[gains_indexer].torque_kp);
    378                          temp_torque_ki = (params->gains[gains_indexer].torque_ki);
    379                      }
    380          
    381                      Flux_Controller.Kp = temp_flux_kp;
    382                      Flux_Controller.Ki = temp_flux_ki;
    383          
    384                      Torque_Controller.Kp = temp_torque_kp;
    385                      Torque_Controller.Ki = temp_torque_ki;
    386                  }
    387              }
    388          }
   \   00000038   0xBCF0             POP      {R4-R7}
   \   0000003A   0x4770             BX       LR
   \                     ??Torque_Flux_Gains_Scheduler_0: (+1)
   \   0000003C   0xF8D0 0x344C      LDR      R3,[R0, #+1100]
   \   00000040   0xF8D0 0x4450      LDR      R4,[R0, #+1104]
   \   00000044   0x429C             CMP      R4,R3
   \   00000046   0xD157             BNE.N    ??Torque_Flux_Gains_Scheduler_1
   \   00000048   0x6912             LDR      R2,[R2, #+16]
   \   0000004A   0xED91 0x1A08      VLDR     S2,[R1, #+32]
   \   0000004E   0xED92 0x0A00      VLDR     S0,[R2, #0]
   \   00000052   0xEDDF 0x....      VLDR.W   S1,??DataTable59_4  ;; 0x3dd67750
   \   00000056   0xEE21 0x1A20      VMUL.F32 S2,S2,S1
   \   0000005A   0x2200             MOVS     R2,#+0
   \   0000005C   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   00000060   0xEEF1 0xFA10      FMSTAT   
   \   00000064   0xDD41             BLE.N    ??Torque_Flux_Gains_Scheduler_2
   \   00000066   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   0000006A   0xEEF1 0xFA10      FMSTAT   
   \   0000006E   0xD43C             BMI.N    ??Torque_Flux_Gains_Scheduler_2
   \   00000070   0xED91 0x1A0E      VLDR     S2,[R1, #+56]
   \   00000074   0xEE21 0x1A20      VMUL.F32 S2,S2,S1
   \   00000078   0x2201             MOVS     R2,#+1
   \   0000007A   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   0000007E   0xEEF1 0xFA10      FMSTAT   
   \   00000082   0xDD32             BLE.N    ??Torque_Flux_Gains_Scheduler_2
   \   00000084   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   00000088   0xEEF1 0xFA10      FMSTAT   
   \   0000008C   0xD42D             BMI.N    ??Torque_Flux_Gains_Scheduler_2
   \   0000008E   0xED91 0x1A14      VLDR     S2,[R1, #+80]
   \   00000092   0xEE21 0x1A20      VMUL.F32 S2,S2,S1
   \   00000096   0x2202             MOVS     R2,#+2
   \   00000098   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   0000009C   0xEEF1 0xFA10      FMSTAT   
   \   000000A0   0xDD23             BLE.N    ??Torque_Flux_Gains_Scheduler_2
   \   000000A2   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   000000A6   0xEEF1 0xFA10      FMSTAT   
   \   000000AA   0xD41E             BMI.N    ??Torque_Flux_Gains_Scheduler_2
   \   000000AC   0xED91 0x1A1A      VLDR     S2,[R1, #+104]
   \   000000B0   0xEE21 0x1A20      VMUL.F32 S2,S2,S1
   \   000000B4   0x2203             MOVS     R2,#+3
   \   000000B6   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   000000BA   0xEEF1 0xFA10      FMSTAT   
   \   000000BE   0xDD14             BLE.N    ??Torque_Flux_Gains_Scheduler_2
   \   000000C0   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   000000C4   0xEEF1 0xFA10      FMSTAT   
   \   000000C8   0xD40F             BMI.N    ??Torque_Flux_Gains_Scheduler_2
   \   000000CA   0xED91 0x1A20      VLDR     S2,[R1, #+128]
   \   000000CE   0xEE61 0x0A20      VMUL.F32 S1,S2,S1
   \   000000D2   0x2204             MOVS     R2,#+4
   \   000000D4   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   000000D8   0xEEF1 0xFA10      FMSTAT   
   \   000000DC   0xDD05             BLE.N    ??Torque_Flux_Gains_Scheduler_2
   \   000000DE   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   000000E2   0xEEF1 0xFA10      FMSTAT   
   \   000000E6   0xBF58             IT       PL 
   \   000000E8   0x2205             MOVPL    R2,#+5
   \                     ??Torque_Flux_Gains_Scheduler_2: (+1)
   \   000000EA   0x2100             MOVS     R1,#+0
   \   000000EC   0xF8C0 0x2450      STR      R2,[R0, #+1104]
   \   000000F0   0xF8A0 0x1382      STRH     R1,[R0, #+898]
   \   000000F4   0xBCF0             POP      {R4-R7}
   \   000000F6   0x4770             BX       LR
   \                     ??Torque_Flux_Gains_Scheduler_1: (+1)
   \   000000F8   0xF8B0 0x2382      LDRH     R2,[R0, #+898]
   \   000000FC   0x1C52             ADDS     R2,R2,#+1
   \   000000FE   0xEB04 0x0544      ADD      R5,R4,R4, LSL #+1
   \   00000102   0xF8A0 0x2382      STRH     R2,[R0, #+898]
   \   00000106   0xEB01 0x05C5      ADD      R5,R1,R5, LSL #+3
   \   0000010A   0xEB03 0x0743      ADD      R7,R3,R3, LSL #+1
   \   0000010E   0xEB01 0x01C7      ADD      R1,R1,R7, LSL #+3
   \   00000112   0x6A6E             LDR      R6,[R5, #+36]
   \   00000114   0xEDD1 0x0A06      VLDR     S1,[R1, #+24]
   \   00000118   0xED95 0x1A06      VLDR     S2,[R5, #+24]
   \   0000011C   0xEDD5 0x2A07      VLDR     S5,[R5, #+28]
   \   00000120   0xEDD5 0x3A04      VLDR     S7,[R5, #+16]
   \   00000124   0xEDD5 0x4A05      VLDR     S9,[R5, #+20]
   \   00000128   0xB212             SXTH     R2,R2
   \   0000012A   0xEE01 0x2A90      VMOV     S3,R2
   \   0000012E   0xEE00 0x6A10      VMOV     S0,R6
   \   00000132   0xEEF8 0x1AE1      VCVT.F32.S32 S3,S3
   \   00000136   0xEE31 0x2A60      VSUB.F32 S4,S2,S1
   \   0000013A   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000013E   0xEE22 0x2A21      VMUL.F32 S4,S4,S3
   \   00000142   0xEE82 0x2A00      VDIV.F32 S4,S4,S0
   \   00000146   0xEE72 0x0A20      VADD.F32 S1,S4,S1
   \   0000014A   0xED91 0x2A07      VLDR     S4,[R1, #+28]
   \   0000014E   0xEE32 0x3AC2      VSUB.F32 S6,S5,S4
   \   00000152   0xEE23 0x3A21      VMUL.F32 S6,S6,S3
   \   00000156   0xEE83 0x3A00      VDIV.F32 S6,S6,S0
   \   0000015A   0xEE33 0x2A02      VADD.F32 S4,S6,S4
   \   0000015E   0xED91 0x3A04      VLDR     S6,[R1, #+16]
   \   00000162   0xEE33 0x4AC3      VSUB.F32 S8,S7,S6
   \   00000166   0xEE24 0x4A21      VMUL.F32 S8,S8,S3
   \   0000016A   0xEE84 0x4A00      VDIV.F32 S8,S8,S0
   \   0000016E   0xEE34 0x3A03      VADD.F32 S6,S8,S6
   \   00000172   0xED91 0x4A05      VLDR     S8,[R1, #+20]
   \   00000176   0xEE34 0x5AC4      VSUB.F32 S10,S9,S8
   \   0000017A   0xEE65 0x1A21      VMUL.F32 S3,S10,S3
   \   0000017E   0xEE81 0x0A80      VDIV.F32 S0,S3,S0
   \   00000182   0xEE30 0x0A04      VADD.F32 S0,S0,S8
   \   00000186   0x42B2             CMP      R2,R6
   \   00000188   0xDB09             BLT.N    ??Torque_Flux_Gains_Scheduler_3
   \   0000018A   0xF8C0 0x444C      STR      R4,[R0, #+1100]
   \   0000018E   0xEEF0 0x0A41      VMOV.F32 S1,S2
   \   00000192   0xEEB0 0x2A62      VMOV.F32 S4,S5
   \   00000196   0xEEB0 0x3A63      VMOV.F32 S6,S7
   \   0000019A   0xEEB0 0x0A64      VMOV.F32 S0,S9
   \                     ??Torque_Flux_Gains_Scheduler_3: (+1)
   \   0000019E   0xEDC0 0x0AA3      VSTR     S1,[R0, #+652]
   \   000001A2   0xED80 0x2AA4      VSTR     S4,[R0, #+656]
   \   000001A6   0xED80 0x3AAA      VSTR     S6,[R0, #+680]
   \   000001AA   0xED80 0x0AAB      VSTR     S0,[R0, #+684]
   \   000001AE   0xBCF0             POP      {R4-R7}
   \   000001B0   0x4770             BX       LR               ;; return
    389          
    390          
    391          
    392          #ifdef __IAR_SYSTEMS_ICC__
    393          #pragma inline = forced
    394          #endif
    395          float32 HexagonTrajectoryCalculation(MCL_DQ_CTRL_IO_F_TYPE *io)
    396          {
    397              SIN_COS_F_TYPE sin_cos_reduced;
    398              float32 hexagon;
    399              //reduced sine and cosine to 0 - pi/3 range
    400              sin_cos_reduced.Cos = io->Sin_Cos->Cos;
    401              sin_cos_reduced.Sin = io->Sin_Cos->Sin;
    402          
    403              if (sin_cos_reduced.Sin < 0)
    404              {
    405                  sin_cos_reduced.Sin = -sin_cos_reduced.Sin;
    406                  sin_cos_reduced.Cos = -sin_cos_reduced.Cos;
    407              }
    408          
    409              if ((sin_cos_reduced.Cos < 0.5f) && (sin_cos_reduced.Cos > -0.5f))
    410              {
    411                  hexagon = 1.0f/sin_cos_reduced.Sin;
    412              }
    413              else if ((sin_cos_reduced.Cos < -0.5f))
    414              {
    415                  hexagon = 2.0f / (-F_SQRT3 * sin_cos_reduced.Cos + sin_cos_reduced.Sin);
    416              }
    417              else
    418              {
    419                  hexagon = 2.0f / (F_SQRT3 * sin_cos_reduced.Cos + sin_cos_reduced.Sin);
    420              }
    421              return(hexagon);
    422          }
C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\Mcl\MacroBlocks\MclDqRef.c
      1          /**
      2           *  @file
      3           *  @brief       Motor Control Loop Speed Controller .
      4           *  @details     This module implements the Speed Control module.
      5           *  @author      alessio.beato/luigi.fagnano  (only temporary, since it is not integrated in MKS)
      6           *  $Header: FOC/Mcl.c 1.12 2015/11/25 18:36:02CET Luigi Fagnano (FAGNAL) Exp  $
      7           * @copyright Copyright 2012 - $Date: 2015/11/25 18:36:02CET $. Whirlpool Corporation. All rights reserved  CONFIDENTIAL
      8          */
      9          /*
     10           *
     11           *---------------------------------------------------------------------------------------------------------------------
     12           *---------------------------------------------------------------------------------------------------------------------
     13           */
     14          //-------------------------------------- Include Files ----------------------------------------------------------------
     15          #include "MclDqRef.h"
     16          #include "MclConfig.h"
     17          #include "McMathCalc_macros.h"
     18          #include "MathCalc.h"
     19          #include "Braking.h"
     20          
     21          
     22          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     23          
     24          #ifndef SQRT3_INV
     25              #define SQRT3_INV    (float32) (1.0f / 1.7320508075688772935274463415059f)
     26          #endif
     27          
     28          #ifndef DQREF__FLUX_ADAPTATION
     29              #define DQREF__FLUX_ADAPTATION  DISABLED
     30          #endif
     31          
     32          #define OVER_FLUX_ACTIVE_THR   1.0f
     33          
     34          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     35          
     36          float32 Over_Flux_Ratio;
     37          float32 Id_Braking;
     38          float32 Flux_Min;
     39          
     40          #if (DQREF__FLUX_ADAPTATION==ENABLED)
     41          static float32 Flux_M_Braking;
     42          #endif
     43          
     44          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
     45          
     46          
     47          
     48          //=====================================================================================================================
     49          //-------------------------------------- Public Functions -------------------------------------------------------------
     50          //=====================================================================================================================
     51          
     52          float32 Calculate_Flux_MTPA(MCL_DQ_REF_IO_F_TYPE *io, MCLDQREF_JOINT_PARAMS_TYPE *params);
     53          float32 Calculate_Flux_MTPV(MCL_DQ_REF_IO_F_TYPE *io, MCL_DQ_REF_PARAMS_TYPE *params);
     54          
     55          
     56          
     57          
     58          //---------------------------------------------------------------------------------------------------------------------
     59          /**
     60           *  @brief      Reset all Mcl Dq Reference Generator quantities.
     61           *  @details    This routine reset all q Reference Generator quantities, it has to be called at every
     62           *              time the pwm is switched off (motor stop or free down ramp).
     63           *
     64           *  @param[in]     
     65           *  @param[out]
     66           *  @return        
     67           */

   \                                 In section .text, align 2, keep-with-next
     68          void MclDqRef__ResetState(MCLDQREF_JOINT_PARAMS_TYPE* params)
     69          {
     70              Over_Flux_Ratio 	= 1.0f;
   \                     MclDqRef__ResetState: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable64_3
   \   00000004   0xF04F 0x527E      MOV      R2,#+1065353216
   \   00000008   0xF8C1 0x2454      STR      R2,[R1, #+1108]
     71              Flux_Min 			= Over_Flux_Ratio*params->DqRefPrm->Rotor_Flux_Nominal;
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF8C1 0x045C      STR      R0,[R1, #+1116]
     72              Id_Braking        	= 0.0f;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF8C1 0x0458      STR      R0,[R1, #+1112]
     73          #if (DQREF__FLUX_ADAPTATION==ENABLED)
     74              Flux_M_Braking      = params->DqRefPrm->Rotor_Flux_Nominal;
     75          #endif
     76          }
   \   0000001A   0x4770             BX       LR               ;; return
     77          
     78          
     79          
     80          
     81          //---------------------------------------------------------------------------------------------------------------------
     82          /**
     83           *  @brief      Motor Control Loop initialization.
     84           *  @details    In this routine are called all initialization functions.
     85           *
     86           *
     87           *  @param[in]     
     88           *  @param[out]     
     89           *  @param[in]      
     90           *  @return        
     91           */
     92          float32 My_Flux_Gain;

   \                                 In section .text, align 2, keep-with-next
     93          void MclDqRef__Initialize(void)
     94          {
     95          	My_Flux_Gain = 1.0f;
   \                     MclDqRef__Initialize: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable64_3
   \   00000004   0xF04F 0x517E      MOV      R1,#+1065353216
   \   00000008   0xF8C0 0x1460      STR      R1,[R0, #+1120]
     96          }
   \   0000000C   0x4770             BX       LR               ;; return
     97          
     98          
     99          
    100          
    101          
    102          //---------------------------------------------------------------------------------------------------------------------
    103          /**
    104           *  @brief     Dq Reference Generation
    105           *  @details   Dq Reference Gen: Mtpa
    106           *                               Flux Weaking
    107           *                               d-reference generation (FOC: current Id, DTC: flux reference)
    108           *                               q-reference generation (FOC: current Id, DTC: torque reference)
    109           *                               torque reference generation
    110           *  @param[in]     
    111           *  @param[out]     
    112           *  @param[in]      
    113           *  @return        
    114           */
    115          uint8 My_WbLim_Flag;
    116          uint8 My_Mflux_Flag;

   \                                 In section .text, align 4, keep-with-next
    117          void MclDqRef__RunningHandler(MCL_DQ_REF_IO_F_TYPE *io, MCLDQREF_JOINT_PARAMS_TYPE *params)
    118          {
   \                     MclDqRef__RunningHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xED2D 0x8B02      VPUSH    {D8}
   \   00000008   0x460D             MOV      R5,R1
    119              float32 flux_ref_mtpa;
    120              float32 flux_limit_by_speed;
    121              float32 temp_f;
    122          
    123              *(io->Q_Ref) = *(io->Torque_Ref);
   \   0000000A   0x6821             LDR      R1,[R4, #+0]
   \   0000000C   0x6920             LDR      R0,[R4, #+16]
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0x6001             STR      R1,[R0, #+0]
    124          
    125              //===========================================================================//
    126              //                   MTPV stator flux reference calculation                  //
    127              //           Calculate the flux limit for field weakening operation          //
    128              //===========================================================================//
    129              flux_limit_by_speed = Calculate_Flux_MTPV(io, params->DqRefPrm);
   \   00000012   0xEDDF 0x....      VLDR.W   S3,??DataTable62  ;; 0x3f13cd3a
   \   00000016   0x69A1             LDR      R1,[R4, #+24]
   \   00000018   0x6828             LDR      R0,[R5, #+0]
   \   0000001A   0x6A0A             LDR      R2,[R1, #+32]
   \   0000001C   0x6812             LDR      R2,[R2, #+0]
   \   0000001E   0xF022 0x4200      BIC      R2,R2,#0x80000000
   \   00000022   0xEE00 0x2A10      VMOV     S0,R2
   \   00000026   0x688A             LDR      R2,[R1, #+8]
   \   00000028   0x6812             LDR      R2,[R2, #+0]
   \   0000002A   0xF022 0x4200      BIC      R2,R2,#0x80000000
   \   0000002E   0xEE00 0x2A90      VMOV     S1,R2
   \   00000032   0x68E2             LDR      R2,[R4, #+12]
   \   00000034   0xED92 0x1A00      VLDR     S2,[R2, #0]
   \   00000038   0x698A             LDR      R2,[R1, #+24]
   \   0000003A   0xEE21 0x1A21      VMUL.F32 S2,S2,S3
   \   0000003E   0xEDD0 0x1A08      VLDR     S3,[R0, #+32]
   \   00000042   0xEE21 0x1A21      VMUL.F32 S2,S2,S3
   \   00000046   0xEDD2 0x1A00      VLDR     S3,[R2, #0]
   \   0000004A   0x69CA             LDR      R2,[R1, #+28]
   \   0000004C   0xED92 0x2A00      VLDR     S4,[R2, #0]
   \   00000050   0xEE61 0x1A82      VMUL.F32 S3,S3,S4
   \   00000054   0xEE21 0x1A01      VMUL.F32 S2,S2,S2
   \   00000058   0xEE01 0x1AE1      VMLS.F32 S2,S3,S3
   \   0000005C   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   00000060   0xEEF1 0xFA10      FMSTAT   
   \   00000064   0xDB02             BLT.N    ??MclDqRef__RunningHandler_0
   \   00000066   0xEEB1 0x1AC1      VSQRT.F32 S2,S2
   \   0000006A   0xE001             B.N      ??MclDqRef__RunningHandler_1
   \                     ??MclDqRef__RunningHandler_0: (+1)
   \   0000006C   0xED9F 0x....      VLDR.W   S2,??DataTable62_1  ;; 0x0
   \                     ??MclDqRef__RunningHandler_1: (+1)
   \   00000070   0x698A             LDR      R2,[R1, #+24]
   \   00000072   0x6AC9             LDR      R1,[R1, #+44]
   \   00000074   0xEDD2 0x1A00      VLDR     S3,[R2, #0]
   \   00000078   0xEE01 0x1AC0      VMLS.F32 S2,S3,S0
   \   0000007C   0xED81 0x1A00      VSTR     S2,[R1, #0]
   \   00000080   0xED9F 0x....      VLDR.W   S0,??DataTable62_2  ;; 0x3dcccccd
   \   00000084   0x69A1             LDR      R1,[R4, #+24]
   \   00000086   0x694A             LDR      R2,[R1, #+20]
   \   00000088   0x6883             LDR      R3,[R0, #+8]
   \   0000008A   0x6812             LDR      R2,[R2, #+0]
   \   0000008C   0xEE30 0x0A80      VADD.F32 S0,S1,S0
   \   00000090   0xEE81 0x8A00      VDIV.F32 S16,S2,S0
   \   00000094   0x429A             CMP      R2,R3
   \   00000096   0xD331             BCC.N    ??MclDqRef__RunningHandler_2
   \   00000098   0x6922             LDR      R2,[R4, #+16]
   \   0000009A   0xED92 0x0A00      VLDR     S0,[R2, #0]
   \   0000009E   0x6A8A             LDR      R2,[R1, #+40]
   \   000000A0   0xEDD2 0x0A00      VLDR     S1,[R2, #0]
   \   000000A4   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   000000A8   0xEDD0 0x0A06      VLDR     S1,[R0, #+24]
   \   000000AC   0xEE60 0x0A20      VMUL.F32 S1,S0,S1
   \   000000B0   0xED90 0x0A07      VLDR     S0,[R0, #+28]
   \   000000B4   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   000000B8   0xEEF1 0xFA10      FMSTAT   
   \   000000BC   0xBFA8             IT       GE 
   \   000000BE   0xEEF0 0x0A40      VMOVGE.F32 S1,S0
   \   000000C2   0xDA06             BGE.N    ??MclDqRef__RunningHandler_3
   \   000000C4   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   000000C8   0xEEF1 0xFA10      FMSTAT   
   \   000000CC   0xBF98             IT       LS 
   \   000000CE   0xEDDF 0x....      VLDRLS.W S1,??DataTable62_1  ;; 0x0
   \                     ??MclDqRef__RunningHandler_3: (+1)
   \   000000D2   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000000D6   0xEE08 0x0A60      VMLS.F32 S0,S16,S1
   \   000000DA   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   000000DE   0xED90 0x0A01      VLDR     S0,[R0, #+4]
   \   000000E2   0xEEB4 0x8A40      VCMP.F32 S16,S0
   \   000000E6   0xEEF1 0xFA10      FMSTAT   
   \   000000EA   0xDA07             BGE.N    ??MclDqRef__RunningHandler_2
   \   000000EC   0xEEB5 0x8A40      VCMP.F32 S16,#0.0
   \   000000F0   0xEEF1 0xFA10      FMSTAT   
   \   000000F4   0xD804             BHI.N    ??MclDqRef__RunningHandler_4
   \   000000F6   0xED9F 0x....      VLDR.W   S16,??DataTable62_1  ;; 0x0
   \   000000FA   0xE001             B.N      ??MclDqRef__RunningHandler_4
   \                     ??MclDqRef__RunningHandler_2: (+1)
   \   000000FC   0xED90 0x8A01      VLDR     S16,[R0, #+4]
    130              *(io->Ctrl_Specific->Flux_Limit_By_Speed) = flux_limit_by_speed;
   \                     ??MclDqRef__RunningHandler_4: (+1)
   \   00000100   0x6B48             LDR      R0,[R1, #+52]
    131          
    132          
    133              //===========================================================================//
    134              //                 MTPA - Maximum Torque Per Ampere calculation              //
    135              //===========================================================================//
    136          
    137              // MTPA BASED ON LUT
    138              flux_ref_mtpa = Calculate_Flux_MTPA(io,params);
   \   00000102   0x.... 0x....      LDR.W    R6,??DataTable64_3
   \   00000106   0xED80 0x8A00      VSTR     S16,[R0, #0]
   \   0000010A   0xF8D6 0x0458      LDR      R0,[R6, #+1112]
   \   0000010E   0xEE00 0x0A10      VMOV     S0,R0
   \   00000112   0x6820             LDR      R0,[R4, #+0]
   \   00000114   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000118   0xEEF1 0xFA10      FMSTAT   
   \   0000011C   0xD10A             BNE.N    ??MclDqRef__RunningHandler_5
   \   0000011E   0x6800             LDR      R0,[R0, #+0]
   \   00000120   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   00000124   0xEE00 0x0A10      VMOV     S0,R0
   \   00000128   0x1D28             ADDS     R0,R5,#+4
   \   0000012A   0x.... 0x....      BL       MathCalc__GetInterpolationFastF
   \   0000012E   0xEEF0 0x0A40      VMOV.F32 S1,S0
   \   00000132   0xE02A             B.N      ??MclDqRef__RunningHandler_6
   \                     ??MclDqRef__RunningHandler_5: (+1)
   \   00000134   0x69A1             LDR      R1,[R4, #+24]
   \   00000136   0xEDD0 0x2A00      VLDR     S5,[R0, #0]
   \   0000013A   0x6C49             LDR      R1,[R1, #+68]
   \   0000013C   0xEDD1 0x0A01      VLDR     S1,[R1, #+4]
   \   00000140   0xED91 0x1A02      VLDR     S2,[R1, #+8]
   \   00000144   0x6829             LDR      R1,[R5, #+0]
   \   00000146   0xEDD1 0x1A00      VLDR     S3,[R1, #0]
   \   0000014A   0xED91 0x3A09      VLDR     S6,[R1, #+36]
   \   0000014E   0xEEB0 0x2A61      VMOV.F32 S4,S3
   \   00000152   0xEE00 0x2A80      VMLA.F32 S4,S1,S0
   \   00000156   0xEE62 0x2A83      VMUL.F32 S5,S5,S6
   \   0000015A   0xEE62 0x2AA1      VMUL.F32 S5,S5,S3
   \   0000015E   0xEE70 0x0AC1      VSUB.F32 S1,S1,S2
   \   00000162   0xEE40 0x1A80      VMLA.F32 S3,S1,S0
   \   00000166   0xEE82 0x0AA1      VDIV.F32 S0,S5,S3
   \   0000016A   0xEE20 0x0A01      VMUL.F32 S0,S0,S2
   \   0000016E   0xEE62 0x0A02      VMUL.F32 S1,S4,S4
   \   00000172   0xEE40 0x0A00      VMLA.F32 S1,S0,S0
   \   00000176   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   0000017A   0xEEF1 0xFA10      FMSTAT   
   \   0000017E   0xDB02             BLT.N    ??MclDqRef__RunningHandler_7
   \   00000180   0xEEF1 0x0AE0      VSQRT.F32 S1,S1
   \   00000184   0xE001             B.N      ??MclDqRef__RunningHandler_6
   \                     ??MclDqRef__RunningHandler_7: (+1)
   \   00000186   0xEDDF 0x....      VLDR.W   S1,??DataTable62_1  ;; 0x0
    139          
    140              //flux_ref_mtpa = My_Flux_Gain * flux_ref_mtpa;
    141          
    142              if(flux_ref_mtpa > flux_limit_by_speed)
   \                     ??MclDqRef__RunningHandler_6: (+1)
   \   0000018A   0xEEB4 0x8A60      VCMP.F32 S16,S1
   \   0000018E   0xEEF1 0xFA10      FMSTAT   
   \   00000192   0xBF4C             ITE      MI 
    143              {
    144              	My_WbLim_Flag = 1;
   \   00000194   0x2001             MOVMI    R0,#+1
    145              }
    146              else
    147              {
    148              	My_WbLim_Flag = 0;
   \   00000196   0x2000             MOVPL    R0,#+0
   \   00000198   0xF886 0x035A      STRB     R0,[R6, #+858]
    149              }
    150          
    151          
    152              // Select the appropriate flux reference
    153              temp_f = MATHCALC__SATURATE(Flux_Min,  flux_ref_mtpa, flux_limit_by_speed);
   \   0000019C   0xF8D6 0x045C      LDR      R0,[R6, #+1116]
   \   000001A0   0xEE00 0x0A10      VMOV     S0,R0
   \   000001A4   0xEEB4 0x8A40      VCMP.F32 S16,S0
   \   000001A8   0xEEF1 0xFA10      FMSTAT   
   \   000001AC   0xDB0C             BLT.N    ??MclDqRef__RunningHandler_8
   \   000001AE   0xEEF4 0x0A48      VCMP.F32 S1,S16
   \   000001B2   0xEEF1 0xFA10      FMSTAT   
   \   000001B6   0xDA16             BGE.N    ??MclDqRef__RunningHandler_9
   \   000001B8   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   000001BC   0xEEF1 0xFA10      FMSTAT   
   \   000001C0   0xDB0F             BLT.N    ??MclDqRef__RunningHandler_10
   \   000001C2   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   000001C6   0xE00E             B.N      ??MclDqRef__RunningHandler_9
   \                     ??MclDqRef__RunningHandler_8: (+1)
   \   000001C8   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   000001CC   0xEEF1 0xFA10      FMSTAT   
   \   000001D0   0xDB02             BLT.N    ??MclDqRef__RunningHandler_11
   \   000001D2   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   000001D6   0xE006             B.N      ??MclDqRef__RunningHandler_9
   \                     ??MclDqRef__RunningHandler_11: (+1)
   \   000001D8   0xEEB4 0x8A60      VCMP.F32 S16,S1
   \   000001DC   0xEEF1 0xFA10      FMSTAT   
   \   000001E0   0xDA01             BGE.N    ??MclDqRef__RunningHandler_9
   \                     ??MclDqRef__RunningHandler_10: (+1)
   \   000001E2   0xEEB0 0x8A60      VMOV.F32 S16,S1
    154          
    155              *(io->D_Ref) = temp_f*My_Flux_Gain;
   \                     ??MclDqRef__RunningHandler_9: (+1)
   \   000001E6   0xF8D6 0x0460      LDR      R0,[R6, #+1120]
   \   000001EA   0xEE00 0x0A10      VMOV     S0,R0
   \   000001EE   0x6960             LDR      R0,[R4, #+20]
   \   000001F0   0xEE28 0x0A00      VMUL.F32 S0,S16,S0
   \   000001F4   0xED80 0x0A00      VSTR     S0,[R0, #0]
    156          
    157              if(*(io->D_Ref) > params->DqRefPrm->Rotor_Flux_Nominal)
   \   000001F8   0x6828             LDR      R0,[R5, #+0]
   \   000001FA   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   000001FE   0x6960             LDR      R0,[R4, #+20]
   \   00000200   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000204   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000208   0xEEF1 0xFA10      FMSTAT   
   \   0000020C   0xBF4C             ITE      MI 
    158              {
    159              	My_Mflux_Flag = 0;
   \   0000020E   0x2000             MOVMI    R0,#+0
    160              }
    161              else
    162              {
    163              	My_Mflux_Flag = 1;
   \   00000210   0x2001             MOVPL    R0,#+1
   \   00000212   0xF886 0x035B      STRB     R0,[R6, #+859]
    164              }
    165          
    166          
    167              // Overflux strategy (low speed & low torque)
    168          	if (*(io->Ctrl_Specific->Speed_Rotor_Observed_Mech_Abs) < params->DqRefPrm->Over_Flux_Speed_Threshold)
   \   00000216   0x69A0             LDR      R0,[R4, #+24]
   \   00000218   0x6900             LDR      R0,[R0, #+16]
   \   0000021A   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   0000021E   0x6828             LDR      R0,[R5, #+0]
   \   00000220   0xEDD0 0x0A04      VLDR     S1,[R0, #+16]
   \   00000224   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000228   0xEEF1 0xFA10      FMSTAT   
   \   0000022C   0xD539             BPL.N    ??MclDqRef__RunningHandler_12
    169          	{
    170          		Over_Flux_Ratio += DQREF__OVERFLUX_CHARGING;
   \   0000022E   0xF8D6 0x0454      LDR      R0,[R6, #+1108]
   \   00000232   0xEE00 0x0A10      VMOV     S0,R0
   \   00000236   0xEDDF 0x....      VLDR.W   S1,??DataTable64  ;; 0x3a83126f
   \   0000023A   0xF206 0x4054      ADDW     R0,R6,#+1108
   \   0000023E   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   00000242   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   00000246   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \   0000024A   0x6828             LDR      R0,[R5, #+0]
   \   0000024C   0xEDD0 0x0A05      VLDR     S1,[R0, #+20]
   \   00000250   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   00000254   0xEEF1 0xFA10      FMSTAT   
   \   00000258   0xDB10             BLT.N    ??MclDqRef__RunningHandler_13
   \   0000025A   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000025E   0xEEF1 0xFA10      FMSTAT   
   \   00000262   0xDA1A             BGE.N    ??MclDqRef__RunningHandler_14
   \   00000264   0xEDDF 0x....      VLDR.W   S1,??DataTable64_1  ;; 0x3f800001
   \   00000268   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000026C   0xEEF1 0xFA10      FMSTAT   
   \   00000270   0xD517             BPL.N    ??MclDqRef__RunningHandler_12
   \   00000272   0xF04F 0x507E      MOV      R0,#+1065353216
   \   00000276   0xF8C6 0x0454      STR      R0,[R6, #+1108]
   \   0000027A   0xE01B             B.N      ??MclDqRef__RunningHandler_15
   \                     ??MclDqRef__RunningHandler_13: (+1)
   \   0000027C   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   00000280   0xEEF1 0xFA10      FMSTAT   
   \   00000284   0xDB04             BLT.N    ??MclDqRef__RunningHandler_16
   \   00000286   0xF04F 0x507E      MOV      R0,#+1065353216
   \   0000028A   0xF8C6 0x0454      STR      R0,[R6, #+1108]
   \   0000028E   0xE011             B.N      ??MclDqRef__RunningHandler_15
   \                     ??MclDqRef__RunningHandler_16: (+1)
   \   00000290   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   00000294   0xEEF1 0xFA10      FMSTAT   
   \   00000298   0xDB03             BLT.N    ??MclDqRef__RunningHandler_12
   \                     ??MclDqRef__RunningHandler_14: (+1)
   \   0000029A   0xF206 0x4054      ADDW     R0,R6,#+1108
   \   0000029E   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
    171          		Over_Flux_Ratio = MATHCALC__SATURATE(1.0f, Over_Flux_Ratio,params->DqRefPrm->Over_Flux_Ratio_Max);
    172          	}
    173          
    174              if((Over_Flux_Ratio>DQREF__MIN_FLUX)&&(Id_Braking == 0))
   \                     ??MclDqRef__RunningHandler_12: (+1)
   \   000002A2   0xF8D6 0x0454      LDR      R0,[R6, #+1108]
   \   000002A6   0xEE00 0x0A10      VMOV     S0,R0
   \   000002AA   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000002AE   0xEEF1 0xFA10      FMSTAT   
   \   000002B2   0xDD16             BLE.N    ??MclDqRef__RunningHandler_17
   \                     ??MclDqRef__RunningHandler_15: (+1)
   \   000002B4   0xF8D6 0x0458      LDR      R0,[R6, #+1112]
   \   000002B8   0xEE00 0x0A10      VMOV     S0,R0
   \   000002BC   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000002C0   0xEEF1 0xFA10      FMSTAT   
   \   000002C4   0xD10D             BNE.N    ??MclDqRef__RunningHandler_17
    175              {
    176                  Over_Flux_Ratio -= params->DqRefPrm->Over_Flux_Decrement;      //Decrease the starting flux factor towards zero in a rate of 125us.
   \   000002C6   0xF8D6 0x0454      LDR      R0,[R6, #+1108]
   \   000002CA   0xEE00 0x0A10      VMOV     S0,R0
   \   000002CE   0x6828             LDR      R0,[R5, #+0]
   \   000002D0   0xEDD0 0x0A03      VLDR     S1,[R0, #+12]
   \   000002D4   0xF206 0x4054      ADDW     R0,R6,#+1108
   \   000002D8   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   000002DC   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   000002E0   0xE002             B.N      ??MclDqRef__RunningHandler_18
    177              }
    178              else
    179              {
    180              	Over_Flux_Ratio = DQREF__MIN_FLUX;
   \                     ??MclDqRef__RunningHandler_17: (+1)
   \   000002E2   0x2000             MOVS     R0,#+0
   \   000002E4   0xF8C6 0x0454      STR      R0,[R6, #+1108]
    181              }
    182          
    183              Flux_Min = Over_Flux_Ratio*params->DqRefPrm->Rotor_Flux_Nominal;
   \                     ??MclDqRef__RunningHandler_18: (+1)
   \   000002E8   0xF8D6 0x0454      LDR      R0,[R6, #+1108]
   \   000002EC   0xEE00 0x0A10      VMOV     S0,R0
   \   000002F0   0x6828             LDR      R0,[R5, #+0]
   \   000002F2   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   000002F6   0xF206 0x405C      ADDW     R0,R6,#+1116
   \   000002FA   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000002FE   0xED80 0x0A00      VSTR     S0,[R0, #0]
    184          
    185          }
   \   00000302   0xECBD 0x8B02      VPOP     {D8}
   \   00000306   0xBD70             POP      {R4-R6,PC}       ;; return
    186          

   \                                 In section .text, align 4, keep-with-next
    187          void MclDqRef__1msHandler(MCL_DQ_REF_IO_F_TYPE *io, MCLDQREF_JOINT_PARAMS_TYPE *params)
    188          {
   \                     MclDqRef__1msHandler: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
    189              if( *(io->Ctrl_Specific->Elapsed_Time_After_Starting) > (params->DqRefPrm->Starting_Threshold) )
   \   00000006   0x69AA             LDR      R2,[R5, #+24]
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x6952             LDR      R2,[R2, #+20]
   \   0000000C   0x6888             LDR      R0,[R1, #+8]
   \   0000000E   0x6812             LDR      R2,[R2, #+0]
   \   00000010   0x....             LDR.N    R4,??DataTable64_3
   \   00000012   0x4290             CMP      R0,R2
   \   00000014   0xD206             BCS.N    ??MclDqRef__1msHandler_0
    190              {
    191                  Id_Braking = Braking__DqRefHandler(io, params->DqRefPrm);
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       Braking__DqRefHandler
   \   0000001C   0xF204 0x4058      ADDW     R0,R4,#+1112
   \   00000020   0xED80 0x0A00      VSTR     S0,[R0, #0]
    192              }
    193          
    194              // manage overflux flag
    195              if (Over_Flux_Ratio>OVER_FLUX_ACTIVE_THR)
   \                     ??MclDqRef__1msHandler_0: (+1)
   \   00000024   0x69A8             LDR      R0,[R5, #+24]
   \   00000026   0xF8D4 0x2454      LDR      R2,[R4, #+1108]
   \   0000002A   0xEE00 0x2A10      VMOV     S0,R2
   \   0000002E   0xEDDF 0x....      VLDR.W   S1,??DataTable64_1  ;; 0x3f800001
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000038   0xEEF1 0xFA10      FMSTAT   
   \   0000003C   0xBFAC             ITE      GE 
    196              {
    197                  io->Ctrl_Specific->flags.bit.overflux_active = 1;
   \   0000003E   0xF041 0x0140      ORRGE    R1,R1,#0x40
    198              }
    199              else
    200              {
    201                  io->Ctrl_Specific->flags.bit.overflux_active = 0;
   \   00000042   0xF021 0x0140      BICLT    R1,R1,#0x40
   \   00000046   0x6001             STR      R1,[R0, #+0]
    202              }
    203          }
   \   00000048   0xB001             ADD      SP,SP,#+4
   \   0000004A   0xBD30             POP      {R4,R5,PC}       ;; return
    204          
    205          
    206          
    207          #ifdef __IAR_SYSTEMS_ICC__
    208          #pragma inline = forced
    209          #endif
    210          float32 Calculate_Flux_MTPV(MCL_DQ_REF_IO_F_TYPE *io, MCL_DQ_REF_PARAMS_TYPE *params)
    211          {
    212              float32 flux_limit_by_speed;
    213              float32 speed_abs_rotor;
    214              float32 vs_max;
    215              float32 temp_1_s32;
    216              float32 temp_2_s32;
    217              float32 temp_3_s32;
    218              float32 torque_error_factor;
    219              float32 iq_stator_current_abs;
    220          
    221              iq_stator_current_abs = MATHCALC__FABS(*(io->Ctrl_Specific->Iq_stator_current));
    222              speed_abs_rotor = MATHCALC__FABS(*(io->Ctrl_Specific->Speed_Rotor_Observed));
    223          
    224          //    MATHCALC__FILTER_CALC(speed_abs_rotor, speed_abs_rotor_sum, FILTER_SHIFT_FS_1KHZ_FC_1HZ);
    225          //    speed_abs_rotor = MATHCALC__FILTER_GET_FILTERED_VAR(speed_abs_rotor_sum, FILTER_SHIFT_FS_1KHZ_FC_1HZ);
    226          
    227              speed_abs_rotor = speed_abs_rotor + 0.1f;                              // Prevent zero division
    228          
    229              vs_max = (*(io->Vdc) * SQRT3_INV) * params->m_index;
    230          
    231              // Complete field weakening equation
    232          
    233              // (Rs * Id)
    234              temp_1_s32 = (*(io->Ctrl_Specific->Stator_Resistance) * *(io->Ctrl_Specific->Id_stator_current));
    235          
    236              // (Rs * Id)^2
    237              temp_1_s32 = (temp_1_s32 * temp_1_s32);
    238          
    239              // Vs_max^2
    240              temp_2_s32 = vs_max * vs_max;
    241          
    242              // sqrt(Vs_max^2 - Rs*Id^2)
    243              temp_1_s32 = MC_SQRT_F(temp_2_s32 - temp_1_s32);
    244          
    245              // Rs * Iq
    246              temp_2_s32 = *(io->Ctrl_Specific->Stator_Resistance) * iq_stator_current_abs;
    247          
    248              // sqrt(Vs_max^2 - Rs*Id^2) - Rs*Iq
    249              temp_1_s32 = temp_1_s32 - temp_2_s32;
    250              *(io->Ctrl_Specific->Vs_Flux) = (temp_1_s32);
    251          
    252              // (sqrt(Vs_max^2 - Rs*Id^2) - Rs*Iq)/abs(speed_r)
    253              flux_limit_by_speed = temp_1_s32/speed_abs_rotor;
    254          
    255          
    256              // Force at maximum flux at starting (prevent glitches on max flux)
    257              if( *(io->Ctrl_Specific->Elapsed_Time_After_Starting) < (params->Starting_Threshold) )
    258              {
    259                  flux_limit_by_speed = params->Max_Flux;
    260              }
    261              else
    262              {
    263          
    264                  temp_3_s32 = *(io->Q_Ref) - *(io->Ctrl_Specific->Torque);
    265                  torque_error_factor = (temp_3_s32 * params->Torque_Err_K);
    266                  torque_error_factor = MATHCALC__SATURATE_DIRECT(0, torque_error_factor, params->Torque_Err_Sat);
    267          
    268                  flux_limit_by_speed -= flux_limit_by_speed *  torque_error_factor;
    269          
    270                  // Limit the maximum flux
    271                  flux_limit_by_speed = MATHCALC__SATURATE_DIRECT(0, flux_limit_by_speed, (params->Max_Flux));
    272              }
    273              return flux_limit_by_speed;
    274          }
    275          
    276          
    277          
    278          
    279          
    280          #ifdef __IAR_SYSTEMS_ICC__
    281          #pragma inline = forced
    282          #endif
    283          float32 Calculate_Flux_MTPA(MCL_DQ_REF_IO_F_TYPE *io, MCLDQREF_JOINT_PARAMS_TYPE *params)
    284          {
    285          
    286              //Id injection equations: general formulation
    287              float32 iq_braking;
    288              float32 ld;
    289              float32 lq;
    290              float32 flux_m;
    291              float32 flux_d;
    292              float32 flux_q;
    293              float32 flux_ref_mtpa;
    294              float32 total_squared_flux;
    295              float32 temp_1;
    296          
    297          
    298              // understand if there is a braking request (check for Id braking)
    299              if (Id_Braking == 0)
    300              {// motoring mode --> MTPA Trajectory
    301                  temp_1 =  MATHCALC__FABS(*(io->Torque_Ref));
    302                  flux_ref_mtpa = MathCalc__GetInterpolationFastF(temp_1, &params->MTPAPrm);
    303          #if (DQREF__FLUX_ADAPTATION==ENABLED)
    304                  Flux_M_Braking = params->DqRefPrm->Rotor_Flux_Nominal;      // reset to nominal value when not braking
    305          #endif
    306              }
    307              else
    308              {// braking mode --> non-regenerative trajectory
    309                  ld = io->Ctrl_Specific->Ldq_Ind->D;
    310                  lq = io->Ctrl_Specific->Ldq_Ind->Q;
    311                  flux_m = params->DqRefPrm->Rotor_Flux_Nominal;
    312          #if (DQREF__FLUX_ADAPTATION==ENABLED)
    313                  // adaptive calculation of magnet flux
    314                  Flux_M_Braking += DQREF__G_FLUX_ADAPT_GAIN * (Id_Braking - *io->Ctrl_Specific->Id_Rotor_Current);
    315                  // saturate if needed
    316                  if (Flux_M_Braking < DQREF__FLUX_ADAPT_SAT_LOW * flux_m)
    317                  {
    318                      Flux_M_Braking = DQREF__FLUX_ADAPT_SAT_LOW * flux_m;
    319                  }
    320                  else if (Flux_M_Braking > DQREF__FLUX_ADAPT_SAT_HI * flux_m)
    321                  {
    322                      Flux_M_Braking = DQREF__FLUX_ADAPT_SAT_HI * flux_m;
    323                  }
    324                  flux_m = Flux_M_Braking;
    325          #else
    326                  flux_m = params->DqRefPrm->Rotor_Flux_Nominal;
    327          #endif
    328                  // iq_braking given torque_ref and id_braking
    329                  temp_1 = flux_m + (ld-lq)*Id_Braking;
    330                  iq_braking = *(io->Torque_Ref) * params->DqRefPrm->K_torque_inv * params->DqRefPrm->Rotor_Flux_Nominal / temp_1;
    331          
    332                  flux_d = flux_m + ld * Id_Braking;
    333                  flux_q = lq * iq_braking;
    334          
    335                  total_squared_flux = flux_d * flux_d + flux_q * flux_q;
    336                  flux_ref_mtpa = MC_SQRT_F(total_squared_flux);
    337              }
    338              return flux_ref_mtpa;
    339          
    340          }
C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\Mcl\MacroBlocks\MclInputProc.c
      1          /**
      2           *  @file
      3           *  @brief       Motor Control Loop Input Processing.
      4           *  @details     This module implements the DC-Bus voltage filtering, the motor current clarke transformation.
      5           *  @author      alessio.beato/luigi.fagnano  (only temporary, since it is not integrated in MKS)
      6           *  $Header: FOC/Mcl.c 1.12 2015/11/25 18:36:02CET Luigi Fagnano (FAGNAL) Exp  $
      7           * @copyright Copyright 2012 - $Date: 2015/11/25 18:36:02CET $. Whirlpool Corporation. All rights reserved  CONFIDENTIAL
      8          */
      9          /*
     10           *
     11           *---------------------------------------------------------------------------------------------------------------------
     12           *---------------------------------------------------------------------------------------------------------------------
     13           */
     14          //-------------------------------------- Include Files ----------------------------------------------------------------
     15          #include "MclInputProc.h"
     16          #include "MclConfig.h"
     17          #include "McMathCalc_macros.h"
     18          #include "Filters.h"
     19          #include "MathCalc.h"
     20          #include "ClrkPark.h"
     21          
     22          
     23          
     24          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     25          
     26          
     27          #define MCL_INPUT_CALL_RATE_HZ              8000.0f // [Hz] define the call rate of the main handler
     28          #define MCL_INPUT_1MS_CALL_RATE_HZ          1000.0f // [Hz] define the call rate of the main handler
     29          
     30          #ifndef INV_3
     31              #define INV_3                           (float32) (1.0f/3.0f)
     32          #endif
     33          
     34          
     35          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     36          #if (INPUTPROC__VDCFILTER_MINIMUM == ENABLED)
     37          static float32 DC_Bus_Min;                           // [V] Instant minimum DC bus voltage
     38          static float32 DC_Bus_Min_temp;                      // [V] Instant minimum DC bus voltage - temporary
     39          
     40          static float32 DC_Bus_Min_Sum;                       // [V] dc bus filtering history
     41          static float32 DC_Bus_Min_Sum_2nd;                   // [V] dc bus filtering history
     42          #endif
     43          
     44          #if (INPUTPROC__VDC_RMS == ENABLED)
     45          static float32  DC_Bus_RMS_Sum;
     46          static volatile float32 DC_Bus_RMS;
     47          #endif
     48          
     49          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
     50          
     51          static void VdcFilter(MCL_INPUT_PROC_IO_F_TYPE *io, MCL_INPUT_PROC_PARAMS_TYPE *params);
     52          static void PhaseVoltageReconstruction(MCL_INPUT_PROC_IO_F_TYPE *io);
     53          static void CurrentClarkTransform(MCL_INPUT_PROC_IO_F_TYPE *io);
     54          static void CalcStatorCurrentMagnitude(MCL_INPUT_PROC_IO_F_TYPE *io);
     55          
     56          
     57          //=====================================================================================================================
     58          //-------------------------------------- Public Functions -------------------------------------------------------------
     59          //=====================================================================================================================
     60          
     61          
     62          
     63          
     64          
     65          //---------------------------------------------------------------------------------------------------------------------
     66          /**
     67           *  @brief      Reset all Mcl Init Processing quantities.
     68           *  @details    This routine reset all Mcl Init Processing quantities, it has to be called at every time the pwm is switched off (motor stop or free down ramp).
     69           *
     70           *
     71           *  @param[in]     
     72           *  @param[out]
     73           *  @return        
     74           */

   \                                 In section .text, align 2, keep-with-next
     75          void MclInputProc__ResetState(void)
     76          {
     77          
     78          }
   \                     MclInputProc__ResetState: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     79          
     80          
     81          
     82          
     83          //---------------------------------------------------------------------------------------------------------------------
     84          /**
     85           *  @brief      Motor Control Loop initialization.
     86           *  @details    In this routine are called all initialization functions.
     87           *
     88           *
     89           *  @param[in]     
     90           *  @param[out]     
     91           *  @param[in]      
     92           *  @return        
     93           */

   \                                 In section .text, align 2, keep-with-next
     94          void MclInputProc__Initialize(void)
     95          {
     96          #if (INPUTPROC__VDCFILTER_MINIMUM == ENABLED)
     97              DC_Bus_Min_Sum      = 0.0f;
     98              DC_Bus_Min_Sum_2nd  = 0.0f;
     99          #endif
    100          #if (INPUTPROC__VDC_RMS == ENABLED)
    101              DC_Bus_RMS_Sum = 0;
   \                     MclInputProc__Initialize: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable64_3
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0xF8C0 0x1464      STR      R1,[R0, #+1124]
    102          #endif
    103          
    104          
    105          }
   \   00000008   0x4770             BX       LR               ;; return
    106          
    107          
    108          
    109          //---------------------------------------------------------------------------------------------------------------------
    110          /**
    111           *  @brief     Input processing
    112           *  @details   Input processing:   motor speed reference absolute value
    113           *                                 motor phase currents swapping in order to work with a positive speed reference.
    114           *                                 dc voltage filtering
    115           *                                 alpha-beta motor phase currents calculation.
    116           *
    117           *  @param[in]     
    118           *  @param[out]     
    119           *  @param[in]      
    120           *  @return        
    121           */

   \                                 In section .text, align 4, keep-with-next
    122          void MclInputProc__RunningHandler(MCL_INPUT_PROC_IO_F_TYPE *io)
    123          {
    124          
    125          
    126              //==========================================================================//
    127              //                                                                          //
    128              //                     Forward Clarke Transform                             //
    129              //       Transforms ABC currents to Alpha/Beta coordinate system            //
    130              //                                                                          //
    131              //==========================================================================//
    132              CurrentClarkTransform(io);
   \                     MclInputProc__RunningHandler: (+1)
   \   00000000   0x6882             LDR      R2,[R0, #+8]
   \   00000002   0xEDD2 0x0A00      VLDR     S1,[R2, #0]
   \   00000006   0xED92 0x1A01      VLDR     S2,[R2, #+4]
   \   0000000A   0x68C1             LDR      R1,[R0, #+12]
   \   0000000C   0xEE70 0x0A81      VADD.F32 S1,S1,S2
   \   00000010   0xED92 0x1A02      VLDR     S2,[R2, #+8]
   \   00000014   0xED9F 0x....      VLDR.W   S0,??DataTable66  ;; 0x3eaaaaab
   \   00000018   0xEE70 0x0A81      VADD.F32 S1,S1,S2
   \   0000001C   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000020   0xEDC1 0x0A00      VSTR     S1,[R1, #0]
   \   00000024   0xED92 0x1A00      VLDR     S2,[R2, #0]
   \   00000028   0xEE71 0x0A60      VSUB.F32 S1,S2,S1
   \   0000002C   0xEDC1 0x0A01      VSTR     S1,[R1, #+4]
   \   00000030   0xED92 0x1A01      VLDR     S2,[R2, #+4]
   \   00000034   0xEDD2 0x1A02      VLDR     S3,[R2, #+8]
   \   00000038   0xEDDF 0x....      VLDR.W   S1,??DataTable66_2  ;; 0x3f13cd3a
   \   0000003C   0xEE31 0x1A61      VSUB.F32 S2,S2,S3
   \   00000040   0xEE21 0x1A20      VMUL.F32 S2,S2,S1
   \   00000044   0xED81 0x1A02      VSTR     S2,[R1, #+8]
    133          
    134          
    135              //==========================================================================//
    136              //                                                                          //
    137              //                    Phase voltage reconstruction                          //
    138              //                                                                          //
    139              //==========================================================================//
    140              PhaseVoltageReconstruction(io);
   \   00000048   0x69C1             LDR      R1,[R0, #+28]
   \   0000004A   0x6D89             LDR      R1,[R1, #+88]
   \   0000004C   0x7809             LDRB     R1,[R1, #+0]
   \   0000004E   0xB159             CBZ.N    R1,??MclInputProc__RunningHandler_0
   \   00000050   0x6901             LDR      R1,[R0, #+16]
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x604A             STR      R2,[R1, #+4]
   \   00000056   0x6901             LDR      R1,[R0, #+16]
   \   00000058   0x608A             STR      R2,[R1, #+8]
   \   0000005A   0x6941             LDR      R1,[R0, #+20]
   \   0000005C   0x600A             STR      R2,[R1, #+0]
   \   0000005E   0x6941             LDR      R1,[R0, #+20]
   \   00000060   0x604A             STR      R2,[R1, #+4]
   \   00000062   0x6940             LDR      R0,[R0, #+20]
   \   00000064   0x6082             STR      R2,[R0, #+8]
   \   00000066   0x4770             BX       LR
   \                     ??MclInputProc__RunningHandler_0: (+1)
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0xED91 0x1A00      VLDR     S2,[R1, #0]
   \   0000006E   0x6841             LDR      R1,[R0, #+4]
   \   00000070   0xEDD1 0x1A00      VLDR     S3,[R1, #0]
   \   00000074   0x6941             LDR      R1,[R0, #+20]
   \   00000076   0xEE61 0x1A81      VMUL.F32 S3,S3,S2
   \   0000007A   0xEDC1 0x1A00      VSTR     S3,[R1, #0]
   \   0000007E   0x6841             LDR      R1,[R0, #+4]
   \   00000080   0xEDD1 0x1A01      VLDR     S3,[R1, #+4]
   \   00000084   0x6941             LDR      R1,[R0, #+20]
   \   00000086   0xEE61 0x1A81      VMUL.F32 S3,S3,S2
   \   0000008A   0xEDC1 0x1A01      VSTR     S3,[R1, #+4]
   \   0000008E   0x6841             LDR      R1,[R0, #+4]
   \   00000090   0xEDD1 0x1A02      VLDR     S3,[R1, #+8]
   \   00000094   0x6941             LDR      R1,[R0, #+20]
   \   00000096   0xEE21 0x1A81      VMUL.F32 S2,S3,S2
   \   0000009A   0xED81 0x1A02      VSTR     S2,[R1, #+8]
   \   0000009E   0x6941             LDR      R1,[R0, #+20]
   \   000000A0   0xED91 0x1A00      VLDR     S2,[R1, #0]
   \   000000A4   0xEDD1 0x1A01      VLDR     S3,[R1, #+4]
   \   000000A8   0xED91 0x2A02      VLDR     S4,[R1, #+8]
   \   000000AC   0xEE71 0x1A21      VADD.F32 S3,S2,S3
   \   000000B0   0xEE71 0x1A82      VADD.F32 S3,S3,S4
   \   000000B4   0xEE61 0x1A80      VMUL.F32 S3,S3,S0
   \   000000B8   0xEE31 0x1A61      VSUB.F32 S2,S2,S3
   \   000000BC   0xED81 0x1A00      VSTR     S2,[R1, #0]
   \   000000C0   0x6941             LDR      R1,[R0, #+20]
   \   000000C2   0xED91 0x1A01      VLDR     S2,[R1, #+4]
   \   000000C6   0xEE31 0x1A61      VSUB.F32 S2,S2,S3
   \   000000CA   0xED81 0x1A01      VSTR     S2,[R1, #+4]
   \   000000CE   0x6941             LDR      R1,[R0, #+20]
   \   000000D0   0xED91 0x1A02      VLDR     S2,[R1, #+8]
   \   000000D4   0xEE31 0x1A61      VSUB.F32 S2,S2,S3
   \   000000D8   0xED81 0x1A02      VSTR     S2,[R1, #+8]
   \   000000DC   0x6901             LDR      R1,[R0, #+16]
   \   000000DE   0x6940             LDR      R0,[R0, #+20]
   \   000000E0   0xED90 0x1A00      VLDR     S2,[R0, #0]
   \   000000E4   0xEDD0 0x1A01      VLDR     S3,[R0, #+4]
   \   000000E8   0xEE31 0x1A21      VADD.F32 S2,S2,S3
   \   000000EC   0xEDD0 0x1A02      VLDR     S3,[R0, #+8]
   \   000000F0   0xEE31 0x1A21      VADD.F32 S2,S2,S3
   \   000000F4   0xEE21 0x0A00      VMUL.F32 S0,S2,S0
   \   000000F8   0xED81 0x0A00      VSTR     S0,[R1, #0]
   \   000000FC   0xED90 0x1A00      VLDR     S2,[R0, #0]
   \   00000100   0xEE31 0x0A40      VSUB.F32 S0,S2,S0
   \   00000104   0xED81 0x0A01      VSTR     S0,[R1, #+4]
   \   00000108   0xED90 0x0A01      VLDR     S0,[R0, #+4]
   \   0000010C   0xED90 0x1A02      VLDR     S2,[R0, #+8]
   \   00000110   0xEE30 0x0A41      VSUB.F32 S0,S0,S2
   \   00000114   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000118   0xED81 0x0A02      VSTR     S0,[R1, #+8]
    141          }
   \   0000011C   0x4770             BX       LR               ;; return
    142          
    143          

   \                                 In section .text, align 4, keep-with-next
    144          void MclInputProc__1msRunningHandler(MCL_INPUT_PROC_IO_F_TYPE *io, MCL_INPUT_PROC_PARAMS_TYPE *params)
    145          {
    146              //==========================================================================//
    147              //                                                                          //
    148              //              Calculating the stator current magnitude                    //
    149              //                                                                          //
    150              //==========================================================================//
    151              CalcStatorCurrentMagnitude(io);
   \                     MclInputProc__1msRunningHandler: (+1)
   \   00000000   0x68C1             LDR      R1,[R0, #+12]
   \   00000002   0xEDD1 0x0A01      VLDR     S1,[R1, #+4]
   \   00000006   0xED91 0x0A02      VLDR     S0,[R1, #+8]
   \   0000000A   0xEE60 0x0AA0      VMUL.F32 S1,S1,S1
   \   0000000E   0xEE40 0x0A00      VMLA.F32 S1,S0,S0
   \   00000012   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   00000016   0xEEF1 0xFA10      FMSTAT   
   \   0000001A   0xDB02             BLT.N    ??MclInputProc__1msRunningHandler_0
   \   0000001C   0xEEB1 0x0AE0      VSQRT.F32 S0,S1
   \   00000020   0xE001             B.N      ??MclInputProc__1msRunningHandler_1
   \                     ??MclInputProc__1msRunningHandler_0: (+1)
   \   00000022   0xED9F 0x....      VLDR.W   S0,??DataTable66_4  ;; 0x0
   \                     ??MclInputProc__1msRunningHandler_1: (+1)
   \   00000026   0x69C1             LDR      R1,[R0, #+28]
   \   00000028   0x6D09             LDR      R1,[R1, #+80]
   \   0000002A   0xED81 0x0A00      VSTR     S0,[R1, #0]
    152          
    153          
    154              //==========================================================================//
    155              //                                                                          //
    156              //              Filter DC bus and track lowest voltage                      //
    157              //                                                                          //
    158              //==========================================================================//
    159              VdcFilter(io, params);
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000034   0x....             LDR.N    R0,??DataTable64_3
   \   00000036   0xF8D0 0x1464      LDR      R1,[R0, #+1124]
   \   0000003A   0xEE00 0x1A90      VMOV     S1,R1
   \   0000003E   0xF890 0x135C      LDRB     R1,[R0, #+860]
   \   00000042   0x1E49             SUBS     R1,R1,#+1
   \   00000044   0xEE40 0x0A00      VMLA.F32 S1,S0,S0
   \   00000048   0xB2C9             UXTB     R1,R1
   \   0000004A   0xB9A1             CBNZ.N   R1,??MclInputProc__1msRunningHandler_2
   \   0000004C   0xED9F 0x....      VLDR.W   S0,??DataTable66_5  ;; 0x3c4ccccd
   \   00000050   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   00000054   0x2150             MOVS     R1,#+80
   \   00000056   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000005A   0xEEF1 0xFA10      FMSTAT   
   \   0000005E   0xDB02             BLT.N    ??MclInputProc__1msRunningHandler_3
   \   00000060   0xEEB1 0x0AC0      VSQRT.F32 S0,S0
   \   00000064   0xE001             B.N      ??MclInputProc__1msRunningHandler_4
   \                     ??MclInputProc__1msRunningHandler_3: (+1)
   \   00000066   0xED9F 0x....      VLDR.W   S0,??DataTable66_4  ;; 0x0
   \                     ??MclInputProc__1msRunningHandler_4: (+1)
   \   0000006A   0xF200 0x4268      ADDW     R2,R0,#+1128
   \   0000006E   0xEDDF 0x....      VLDR.W   S1,??DataTable66_4  ;; 0x0
   \   00000072   0xED82 0x0A00      VSTR     S0,[R2, #0]
   \                     ??MclInputProc__1msRunningHandler_2: (+1)
   \   00000076   0xF880 0x135C      STRB     R1,[R0, #+860]
   \   0000007A   0xF200 0x4064      ADDW     R0,R0,#+1124
   \   0000007E   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
    160          }
   \   00000082   0x4770             BX       LR               ;; return
    161          
    162          
    163          
    164          #ifdef __IAR_SYSTEMS_ICC__
    165          #pragma inline = forced
    166          #endif
    167          //---------------------------------------------------------------------------------------------------------------------
    168          /**
    169           *  @brief      Apply Clarke transform to the currents.
    170           *  @details    By applying Clarke transformation to the currents, it shall provide the alpha and beta currents
    171           *              from the measured currents a, b and c.
    172           *
    173           *  @param[in]  MCL_INPUT_PROC_IO_TYPE *io
    174           *  @param[out] MCL_INPUT_PROC_IO_TYPE *io
    175           *  @return     none
    176           */
    177          void CurrentClarkTransform(MCL_INPUT_PROC_IO_F_TYPE *io)
    178          {
    179              ClrkPark__DirectClarkeF(io->Is_ABC, io->Is_Alpha_Beta);
    180          }
    181          
    182          
    183          
    184          
    185          //---------------------------------------------------------------------------------------------------------------------
    186          /**
    187           *  @brief      Calculate the peak current (magnitude) from alpha and beta currents
    188           *  @details    By applying Clarke transformation to the currents, it shall provide the alpha and beta currents
    189           *              from the measured currents a, b and c.
    190           *
    191           *  @param[in]  MCL_INPUT_PROC_IO_TYPE *io
    192           *  @param[out] MCL_INPUT_PROC_IO_TYPE *io
    193           *  @return     none
    194           */
    195          void CalcStatorCurrentMagnitude(MCL_INPUT_PROC_IO_F_TYPE *io)
    196          {
    197              float32 temp;
    198          
    199              temp  = (io->Is_Alpha_Beta->Alpha) * (io->Is_Alpha_Beta->Alpha);
    200              temp += (io->Is_Alpha_Beta->Beta)  * (io->Is_Alpha_Beta->Beta);
    201          
    202              *(io->Ctrl_Specific->Is_Abs) = MC_SQRT_F(temp);
    203          }
    204          
    205          
    206          
    207          
    208          //---------------------------------------------------------------------------------------------------------------------
    209          /**
    210           *  @brief      Tracks the minimum instant dc bus voltage
    211           *  @details    This algorithm tracks the minimum instant dc bus voltage voltage, keep the minimum for certain
    212           *              amount of time before reseting the temporary minimum and update the value. In this algorithm,
    213           *              the minimum is always keep at the minimum of the instant voltage.
    214           *
    215           *  @param[in]  MCL_INPUT_PROC_IO_TYPE *io
    216           *  @param[out] MCL_INPUT_PROC_IO_TYPE *io
    217           *  @return     none
    218           */
    219          void VdcFilter(MCL_INPUT_PROC_IO_F_TYPE *io, MCL_INPUT_PROC_PARAMS_TYPE *params)
                                                                                          ^
Remark[Pe826]: parameter "params" was never referenced
    220          {
    221          #if (INPUTPROC__VDCFILTER_MINIMUM == ENABLED)
    222              static uint8 prescaler_25ms = (uint8)(MCL_INPUT_1MS_CALL_RATE_HZ/40.0f);
    223          #endif
    224          #if (INPUTPROC__VDC_RMS == ENABLED)
    225              static uint8 window_avg = 80;
    226              float32 Vdc;
    227          #endif
    228          #if (INPUTPROC__VDCFILTER_MINIMUM == ENABLED)
    229              // Filter the minimum instant dc bus voltage
    230              DC_Bus_Min_Sum = FILTERS__LOWPASSFILTER_F(DC_Bus_Min_Sum, DC_BUS_LPF_COEF, DC_Bus_Min);
    231          
    232          	DC_Bus_Min_Sum_2nd = FILTERS__LOWPASSFILTER_F(DC_Bus_Min_Sum_2nd, DC_BUS_LPF_COEF, DC_Bus_Min_Sum);
    233          
    234          	*(io->Vs_Max_Filt) = DC_Bus_Min_Sum_2nd;
    235          
    236          	*(io->Vs_Max_Filt) = params->Max_Available_Voltage_Factor * *(io->Vs_Max_Filt);
    237          
    238          
    239              // every 25 ms, the temporary minimum is reset
    240              prescaler_25ms--;
    241              if(!prescaler_25ms)
    242              {
    243                  prescaler_25ms = (uint8)(MCL_INPUT_1MS_CALL_RATE_HZ/40.0f);
    244          
    245                  // This is to bring up the Dc_Bus_Pu_Min because in AtodISR it only get reduced.
    246                  // dcbus_pu_min_target is reset periodically.
    247                  if(DC_Bus_Min < DC_Bus_Min_temp)
    248                  {
    249                      DC_Bus_Min = DC_Bus_Min_temp;
    250                  }
    251          
    252                  //Reset dcbus_pu_min_target. Bring it up. It get reduced at AtodISR.
    253                  DC_Bus_Min_temp = *(io->Vdc);
    254              }
    255          
    256          
    257              // Look for the minimum value
    258              if(*(io->Vdc) < DC_Bus_Min)
    259              {
    260                  DC_Bus_Min = *(io->Vdc);
    261              }
    262              if(*(io->Vdc) < DC_Bus_Min_temp)
    263              {
    264                  DC_Bus_Min_temp = *(io->Vdc);
    265              }
    266          #endif
    267          #if (INPUTPROC__VDC_RMS == ENABLED)
    268          
    269              Vdc = *(io->Vdc);
    270              DC_Bus_RMS_Sum += (Vdc * Vdc);
    271          
    272              // every 80 samples we update the RMS (8000Hz / 100Hz = 80)
    273              window_avg--;
    274              if(!window_avg)
    275              {
    276                  window_avg = 80;
    277                  DC_Bus_RMS = MC_SQRT_F(0.0125f * DC_Bus_RMS_Sum);  // RMS calculation
    278                  DC_Bus_RMS_Sum = 0.0f;
    279              }
    280          #endif
    281          
    282          }
    283          
    284          
    285          
    286          #ifdef __IAR_SYSTEMS_ICC__
    287          #pragma inline = forced
    288          #endif
    289          //---------------------------------------------------------------------------------------------------------------------
    290          /**
    291           *  @brief      Reconstruct applied phase voltage from the last pwm command duty cycles.
    292           *  @details
    293           *
    294           *  @param[in]  MCL_INPUT_PROC_IO_TYPE *io
    295           *  @param[out] MCL_INPUT_PROC_IO_TYPE *io
    296           *  @return     none
    297           */
    298          void PhaseVoltageReconstruction(MCL_INPUT_PROC_IO_F_TYPE *io)
    299          {
    300              float32 temp_vdc;
    301              float32 temp_common_mode;
    302          
    303              // Check if the command to enable lowers on was enabled, if it was enabled
    304              if( *(io->Ctrl_Specific->Lowers_On) )
    305              {
    306                  // voltages applied to the motor is zero.
    307                  io->Vs_Alpha_Beta_Rec->Alpha = 0.0f;
    308                  io->Vs_Alpha_Beta_Rec->Beta = 0.0f;
    309          
    310                  io->Vabc_Rec->A = 0.0f;
    311                  io->Vabc_Rec->B = 0.0f;
    312                  io->Vabc_Rec->C = 0.0f;
    313          
    314              }
    315              else
    316              {
    317                  // Read the last duty cycle and scale it to the DC bus voltage.
    318                  // Note: assume the DC bus voltage is kept constant within one pwm period.
    319                  temp_vdc = *(io->Vdc);
    320                  io->Vabc_Rec->A = (io->Duty->A * temp_vdc);
    321                  io->Vabc_Rec->B = (io->Duty->B * temp_vdc);
    322                  io->Vabc_Rec->C = (io->Duty->C * temp_vdc);
    323          
    324                  //ClrkPark__DirectClarkeF(io->Vabc_Rec, io->Vs_Alpha_Beta_Rec);
    325          
    326                  temp_common_mode = (io->Vabc_Rec->A) + (io->Vabc_Rec->B) + (io->Vabc_Rec->C);
    327                  temp_common_mode = temp_common_mode * INV_3 ;
    328          
    329                  io->Vabc_Rec->A -= temp_common_mode;
    330                  io->Vabc_Rec->B -= temp_common_mode;
    331                  io->Vabc_Rec->C -= temp_common_mode;
    332          
    333                  ClrkPark__DirectClarkeF(io->Vabc_Rec, io->Vs_Alpha_Beta_Rec);
    334          
    335              }
    336          }
    337          
    338          
C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\Mcl\MacroBlocks\MclObserver.c
      1          /**
      2           *  @file
      3           *  @brief       Motor Control Loop Observer .
      4           *  @details     This module implements the Observer module.
      5           *  @author      alessio.beato/luigi.fagnano  (only temporary, since it is not integrated in MKS)
      6           *  $Header: FOC/Mcl.c 1.12 2015/11/25 18:36:02CET Luigi Fagnano (FAGNAL) Exp  $
      7           * @copyright Copyright 2012 - $Date: 2015/11/25 18:36:02CET $. Whirlpool Corporation. All rights reserved  CONFIDENTIAL
      8          */
      9          /*
     10           *
     11           *---------------------------------------------------------------------------------------------------------------------
     12           *---------------------------------------------------------------------------------------------------------------------
     13           */
     14          //-------------------------------------- Include Files ----------------------------------------------------------------
     15          #include "MclObserver.h"
     16          #include "MclConfig.h"
     17          #include "McMathCalc_macros.h"
     18          #include "ClrkPark.h"
     19          #include "Filters.h"
     20          #include "MathCalc.h"
     21          #if (OBS__INVERTER_DISTORSION_COMPENSATION == ENABLED)
     22          #include "InverterComp.h"
     23          #endif
     24          #include "Mci_prm.h"
     25          
     26          
     27          

   \                                 In section .bss, align 4
     28          float32 Rotor_Curr_Id;
     29          float32 Rotor_Curr_Iq;
     30          float32 Rotor_Curr_Iq_Abs;
     31          float32 Rotor_Curr_Id_Abs;
     32          
     33          float32 Pole_Pairs_Inv;
     34          
     35          
     36          //! PLL variables and parameters structure
     37          typedef struct
     38          {
     39              float kp;
     40              float ki;
     41              float in_alpha;
     42              float in_beta;
     43              float speed;
     44              float speed_old;
     45              float integral;
     46              float angle;
     47              float alpha;
     48              float beta;
     49              float error;
     50              float error_old;
     51              float integ_k;                                  //!< Constant for integration
     52              float speed_2pu;                                //!< pll convert to speed pu
     53          } XPLL_TYPE;
     54          
     55          XPLL_TYPE XPLLVars;
     56          
     57          #ifndef PI
     58              #define PI  3.1415926535897932384626433832795f
     59          #endif
     60          #define  PARAMS_EMF_INT_CONSTANT    0.5f * TS
     61          
     62          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     63          
     64          
     65          
     66          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     67          #if (OBS__INVERTER_DISTORSION_COMPENSATION == ENABLED)
     68          ALPHA_BETA_COOR_SYST_F_TYPE Inverter_Distortion;
     69          INVERTER_COMP_TYPE Inv_Dist_Pointer;
     70          #endif
     71          ALPHA_BETA_COOR_SYST_F_TYPE Stator_Emf;
     72          ALPHA_BETA_COOR_SYST_F_TYPE Stator_Emf_Err;
     73          ALPHA_BETA_COOR_SYST_F_TYPE Stator_Lambda;        //!< [Vs] Q30 format! - stator flux from integrated voltages (emf, losses, etc.)
     74          ALPHA_BETA_COOR_SYST_F_TYPE Rotor_Lambda;
     75          float32 Rotor_Lambda_Mod;
     76          float32 Sin_Rot_k1;
     77          float32 Cos_Rot_k1;
     78          float32 EM_Torque;                               //!< [Nm] Q15 - instantaneous electromagnetic torque
     79          float32 EM_Torque_Filt_Sum;
     80          
     81          
     82          float32 dLambdas_alpha_old;
     83          float32 dLambdas_beta_old;
     84          float32 Rotor_Position;
     85          float32 Rotor_Mech_Position;
     86          float32 Flux_Error;                              //!< [Vs/rad] Q15 - flux error to close one loop in the observer stator resistance adaptation
     87          XPLL_TYPE Speed_PLL;
   \                     Speed_PLL:
   \   00000000                      DS8 56
   \                     Stator_Emf:
   \   00000038                      DS8 12
   \                     Stator_Emf_Err:
   \   00000044                      DS8 12
   \                     Stator_Lambda:
   \   00000050                      DS8 12
   \                     Rotor_Lambda:
   \   0000005C                      DS8 12
   \                     Rotor_Curr_Id:
   \   00000068                      DS8 4
   \                     Rotor_Curr_Iq:
   \   0000006C                      DS8 4
   \                     Rotor_Curr_Iq_Abs:
   \   00000070                      DS8 4
   \                     Rotor_Curr_Id_Abs:
   \   00000074                      DS8 4
   \                     Pole_Pairs_Inv:
   \   00000078                      DS8 4
   \                     Rotor_Lambda_Mod:
   \   0000007C                      DS8 4
   \                     Sin_Rot_k1:
   \   00000080                      DS8 4
   \                     Cos_Rot_k1:
   \   00000084                      DS8 4
   \                     EM_Torque:
   \   00000088                      DS8 4
   \                     EM_Torque_Filt_Sum:
   \   0000008C                      DS8 4
   \                     dLambdas_alpha_old:
   \   00000090                      DS8 4
   \                     dLambdas_beta_old:
   \   00000094                      DS8 4
   \                     Rotor_Position:
   \   00000098                      DS8 4
   \                     Flux_Error:
   \   0000009C                      DS8 4
     88          
     89          float32 Obs_Speed_Stator_Flux;
   \                     Obs_Speed_Stator_Flux:
   \   000000A0                      DS8 4
     90          float32 Obs_Speed_Rotor_Flux;
   \                     Obs_Speed_Rotor_Flux:
   \   000000A4                      DS8 4
     91          
     92          float32 Last_Mech_Rotor_Pos;
     93          float32 Mech_Rotor_Pos_Acc_Err;
     94          
     95          float32 Obs_Speed_Rotor_Flux_sum;                //!< Rotor flux speed history
   \                     Obs_Speed_Rotor_Flux_sum:
   \   000000A8                      DS8 4
     96          
     97          float32 Error_Flux_Alpha_1;
   \                     Error_Flux_Alpha_1:
   \   000000AC                      DS8 4
     98          float32 Error_Flux_Beta_1;
   \                     Error_Flux_Beta_1:
   \   000000B0                      DS8 4
     99          
    100          float32 Stator_Resistance_Corr;
   \                     Stator_Resistance_Corr:
   \   000000B4                      DS8 4
    101          float32 Err_Lim_Lower;
   \                     Err_Lim_Lower:
   \   000000B8                      DS8 4
    102          float32 Err_Lim_Upper;
   \                     Err_Lim_Upper:
   \   000000BC                      DS8 4
    103          
    104          uint32 Speed_Transition_Counter;
   \                     Speed_Transition_Counter:
   \   000000C0                      DS8 4

   \                                 In section .bss, align 4
   \                     XPLLVars:
   \   00000000                      DS8 56

   \                                 In section .bss, align 4
   \                     Rotor_Mech_Position:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     Last_Mech_Rotor_Pos:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     Mech_Rotor_Pos_Acc_Err:
   \   00000000                      DS8 4
    105          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
    106          
    107          //=====================================================================================================================
    108          //-------------------------------------- Public Functions -------------------------------------------------------------
    109          //=====================================================================================================================
    110          #if (OBS__VOLTAGE_PHASE_SHIFT == ENABLED)
    111          void Voltage_Phase_Shift(MCL_OBSERVER_IO_F_TYPE *io, MCL_OBSERVER_PARAMS_TYPE *params);
    112          #endif
    113          #if (OBS__INVERTER_DISTORSION_COMPENSATION == ENABLED)
    114          void InvDistortion_Comp(MCL_OBSERVER_IO_F_TYPE *io, MCL_OBSERVER_PARAMS_TYPE *params);
    115          #endif
    116          void Resistance_Adaptation(MCL_OBSERVER_IO_F_TYPE *io, MCL_OBSERVER_PARAMS_TYPE *params);
    117          void Emf_Calc(MCL_OBSERVER_IO_F_TYPE *io);
    118          void Inductance_Correction(MCL_OBSERVER_IO_F_TYPE *io, MCLOBSERVER_JOINT_PARAMS_TYPE *params);
    119          void RotorFlux_Correction(MCL_OBSERVER_IO_F_TYPE *io, MCLOBSERVER_JOINT_PARAMS_TYPE *params);
    120          void StatorFlux_Calc(MCL_OBSERVER_IO_F_TYPE *io, MCL_OBSERVER_PARAMS_TYPE *params);
    121          void Speed_PLL_Calc(void);
    122          void ElectroMagneticTorqueCalc(MCL_OBSERVER_IO_F_TYPE *io, MCL_OBSERVER_PARAMS_TYPE *params);
    123          void Speed_Selector(MCL_OBSERVER_IO_F_TYPE *io, MCL_OBSERVER_PARAMS_TYPE *params);
    124          void Speed_Selector_Check(MCL_OBSERVER_IO_F_TYPE *io, MCL_OBSERVER_PARAMS_TYPE *params);
    125          
    126          
    127          void PLL__fReset(XPLL_TYPE *XPLLVars);
    128          void PLL__fCalc(XPLL_TYPE *XPLLVars);
    129          
    130          
    131          //---------------------------------------------------------------------------------------------------------------------
    132          /**
    133           *  @brief      Reset all Mcl Observer quantities.
    134           *  @details    This routine reset all q Reference Generator quantities, it has to be called at every time the pwm is switched off (motor stop or free down ramp).
    135           *
    136           *
    137           *  @param[in]     
    138           *  @param[out]
    139           *  @return        
    140           */

   \                                 In section .text, align 4, keep-with-next
    141          void MclObserver__ResetState(MCL_OBSERVER_IO_F_TYPE *io, MCLOBSERVER_JOINT_PARAMS_TYPE *params)
                                                                                                         ^
Remark[Pe826]: parameter "params" was never referenced
    142          {
   \                     MclObserver__ResetState: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    143              float32 cmd_flux_level;
    144              SIN_COS_F_TYPE cmd_sin_cos_pos;
    145          
    146          
    147              // Private variables reset
    148              dLambdas_alpha_old = 0.0f;
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable75_3
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0xF8C1 0x2090      STR      R2,[R1, #+144]
    149              dLambdas_beta_old = 0.0f;
   \   0000000C   0xF8C1 0x2094      STR      R2,[R1, #+148]
    150          
    151              Stator_Emf.Alpha = 0.0f;
   \   00000010   0x63CA             STR      R2,[R1, #+60]
    152              Stator_Emf.Beta = 0.0f;
   \   00000012   0x640A             STR      R2,[R1, #+64]
    153              Stator_Emf_Err.Alpha = 0.0f;
   \   00000014   0x648A             STR      R2,[R1, #+72]
    154              Stator_Emf_Err.Beta = 0.0f;
   \   00000016   0x64CA             STR      R2,[R1, #+76]
    155          
    156              // Initialize torque estimator
    157              EM_Torque = 0.0f;
   \   00000018   0xF8C1 0x2088      STR      R2,[R1, #+136]
    158              EM_Torque_Filt_Sum = 0.0f;
   \   0000001C   0xF8C1 0x208C      STR      R2,[R1, #+140]
    159          
    160              PLL__fReset(&Speed_PLL);
   \   00000020   0x610A             STR      R2,[R1, #+16]
   \   00000022   0x614A             STR      R2,[R1, #+20]
   \   00000024   0x628A             STR      R2,[R1, #+40]
   \   00000026   0x62CA             STR      R2,[R1, #+44]
   \   00000028   0x618A             STR      R2,[R1, #+24]
   \   0000002A   0x61CA             STR      R2,[R1, #+28]
   \   0000002C   0x620A             STR      R2,[R1, #+32]
   \   0000002E   0x624A             STR      R2,[R1, #+36]
   \   00000030   0x608A             STR      R2,[R1, #+8]
   \   00000032   0x60CA             STR      R2,[R1, #+12]
    161          
    162              Obs_Speed_Stator_Flux = 0.0f;
   \   00000034   0xF8C1 0x20A0      STR      R2,[R1, #+160]
    163              Obs_Speed_Rotor_Flux = 0.0f;
   \   00000038   0xF8C1 0x20A4      STR      R2,[R1, #+164]
    164          
    165              Rotor_Position = *(io->Ctrl_Specific->DcInjection_Angle);
    166              MathCalc__SinCosF(Rotor_Position, &cmd_sin_cos_pos);
   \   0000003C   0xEDDF 0x....      VLDR.W   S1,??DataTable66_6  ;; 0x3e22f983
   \   00000040   0x6A02             LDR      R2,[R0, #+32]
   \   00000042   0x6BD2             LDR      R2,[R2, #+60]
   \   00000044   0xED92 0x0A00      VLDR     S0,[R2, #0]
   \   00000048   0xED81 0x0A26      VSTR     S0,[R1, #+152]
   \   0000004C   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000050   0xEEFD 0x0AC0      VCVT.S32.F32 S1,S0
   \   00000054   0xEE10 0x2A90      VMOV     R2,S1
   \   00000058   0xEDDF 0x....      VLDR.W   S1,??DataTable66_7  ;; 0xb4800000
   \   0000005C   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000060   0xEEF1 0xFA10      FMSTAT   
   \   00000064   0xBF48             IT       MI 
   \   00000066   0x1E52             SUBMI    R2,R2,#+1
   \   00000068   0xEE00 0x2A90      VMOV     S1,R2
   \   0000006C   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000070   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   00000074   0xEDDF 0x....      VLDR.W   S1,??DataTable66_8  ;; 0x44000000
   \   00000078   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000007C   0xEEFD 0x0AC0      VCVT.S32.F32 S1,S0
   \   00000080   0xEE10 0x2A90      VMOV     R2,S1
   \   00000084   0x05D2             LSLS     R2,R2,#+23
   \   00000086   0x0DD2             LSRS     R2,R2,#+23
   \   00000088   0xF102 0x0380      ADD      R3,R2,#+128
   \   0000008C   0x4614             MOV      R4,R2
   \   0000008E   0x05DB             LSLS     R3,R3,#+23
   \   00000090   0xEE00 0x4A90      VMOV     S1,R4
   \   00000094   0x0DDB             LSRS     R3,R3,#+23
   \   00000096   0x....             LDR.N    R4,??DataTable66_9
   \   00000098   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \   0000009C   0xEB04 0x0583      ADD      R5,R4,R3, LSL #+2
   \   000000A0   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   000000A4   0xEB04 0x0383      ADD      R3,R4,R3, LSL #+2
   \   000000A8   0xEEF7 0x0A00      VMOV.F32 S1,#1.0
   \   000000AC   0xEE70 0x0AC0      VSUB.F32 S1,S1,S0
   \   000000B0   0xED95 0x1A00      VLDR     S2,[R5, #0]
   \   000000B4   0xEDD3 0x1A01      VLDR     S3,[R3, #+4]
   \   000000B8   0xEE20 0x1A81      VMUL.F32 S2,S1,S2
    167          
    168              io->Sin_Cos_Position_Flux->Sin = cmd_sin_cos_pos.Sin;
   \   000000BC   0xEB04 0x0382      ADD      R3,R4,R2, LSL #+2
   \   000000C0   0xEE00 0x1A21      VMLA.F32 S2,S0,S3
   \   000000C4   0xEDD3 0x1A00      VLDR     S3,[R3, #0]
   \   000000C8   0xEB04 0x0282      ADD      R2,R4,R2, LSL #+2
   \   000000CC   0xEE60 0x0AA1      VMUL.F32 S1,S1,S3
   \   000000D0   0xEDD2 0x1A01      VLDR     S3,[R2, #+4]
   \   000000D4   0x6902             LDR      R2,[R0, #+16]
   \   000000D6   0xEE40 0x0A21      VMLA.F32 S1,S0,S3
   \   000000DA   0xEDC2 0x0A00      VSTR     S1,[R2, #0]
    169              io->Sin_Cos_Position_Flux->Cos = cmd_sin_cos_pos.Cos;
   \   000000DE   0x6902             LDR      R2,[R0, #+16]
   \   000000E0   0xED82 0x1A01      VSTR     S2,[R2, #+4]
    170          
    171              Sin_Rot_k1 = io->Sin_Cos_Position_Flux->Sin;
   \   000000E4   0x6902             LDR      R2,[R0, #+16]
   \   000000E6   0x6812             LDR      R2,[R2, #+0]
   \   000000E8   0xF8C1 0x2080      STR      R2,[R1, #+128]
    172              Cos_Rot_k1 = io->Sin_Cos_Position_Flux->Cos;
   \   000000EC   0x6902             LDR      R2,[R0, #+16]
   \   000000EE   0x6852             LDR      R2,[R2, #+4]
   \   000000F0   0xF8C1 0x2084      STR      R2,[R1, #+132]
    173          
    174              // Calculate the flux magnitude
    175              cmd_flux_level = *(io->Ctrl_Specific->Rotor_Flux); // + ((io->Ctrl_Specific->Ldq_Ind->D * (*(io->Is_Abs)))>>15);
   \   000000F4   0x6A02             LDR      R2,[R0, #+32]
   \   000000F6   0x6D53             LDR      R3,[R2, #+84]
    176              *(io->Ctrl_Specific->Stator_Flux_Mag) = cmd_flux_level;
   \   000000F8   0x6B92             LDR      R2,[R2, #+56]
   \   000000FA   0xED93 0x0A00      VLDR     S0,[R3, #0]
   \   000000FE   0xED82 0x0A00      VSTR     S0,[R2, #0]
    177              Rotor_Lambda_Mod = cmd_flux_level;
   \   00000102   0xED81 0x0A1F      VSTR     S0,[R1, #+124]
    178          
    179              // Initialize the stator flux
    180              Stator_Lambda.Alpha  = Cos_Rot_k1 * cmd_flux_level;
   \   00000106   0xEDD1 0x0A21      VLDR     S1,[R1, #+132]
    181              Stator_Lambda.Beta   = Sin_Rot_k1 * cmd_flux_level;
   \   0000010A   0xED91 0x1A20      VLDR     S2,[R1, #+128]
   \   0000010E   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000112   0xEE21 0x0A00      VMUL.F32 S0,S2,S0
   \   00000116   0xED81 0x0A16      VSTR     S0,[R1, #+88]
   \   0000011A   0xEDC1 0x0A15      VSTR     S1,[R1, #+84]
    182          
    183              // Estimated rotor flux is the same from stator
    184              Rotor_Lambda.Alpha = Stator_Lambda.Alpha;
   \   0000011E   0xEDC1 0x0A18      VSTR     S1,[R1, #+96]
    185              Rotor_Lambda.Beta = Stator_Lambda.Beta;
   \   00000122   0x6D8A             LDR      R2,[R1, #+88]
   \   00000124   0x664A             STR      R2,[R1, #+100]
    186          
    187          
    188              Obs_Speed_Rotor_Flux_sum = 0.0f;
   \   00000126   0x2200             MOVS     R2,#+0
   \   00000128   0xF8C1 0x20A8      STR      R2,[R1, #+168]
    189          
    190              Error_Flux_Alpha_1 = 0.0f;
   \   0000012C   0xF8C1 0x20AC      STR      R2,[R1, #+172]
    191              Error_Flux_Beta_1 = 0.0f;
   \   00000130   0xF8C1 0x20B0      STR      R2,[R1, #+176]
    192          
    193              Err_Lim_Lower = 0.0f;
   \   00000134   0xF8C1 0x20B8      STR      R2,[R1, #+184]
    194              Err_Lim_Upper = 0.0f;
   \   00000138   0xF8C1 0x20BC      STR      R2,[R1, #+188]
    195          
    196          #if (OBS__INVERTER_DISTORSION_COMPENSATION == ENABLED)
    197              Inv_Dist_Pointer.Is_ABC = io->Is_ABC;
    198              Inv_Dist_Pointer.Vdc = io->Vdc;
    199              Inv_Dist_Pointer.distortion = &Inverter_Distortion;
    200          #endif
    201          
    202              Stator_Resistance_Corr = OBS__RESISTANCE_ADAPTATION_INIT_VALUE;
   \   0000013C   0xF8C1 0x20B4      STR      R2,[R1, #+180]
    203              Speed_Transition_Counter = 0;
   \   00000140   0xF8C1 0x20C0      STR      R2,[R1, #+192]
    204              io->Ctrl_Specific->flags.bit.pll_engaged = 0;
   \   00000144   0x6A00             LDR      R0,[R0, #+32]
   \   00000146   0x6801             LDR      R1,[R0, #+0]
   \   00000148   0xF021 0x0108      BIC      R1,R1,#0x8
   \   0000014C   0x6001             STR      R1,[R0, #+0]
    205          
    206          
    207          }
   \   0000014E   0xBC30             POP      {R4,R5}
   \   00000150   0x4770             BX       LR               ;; return
    208          
    209          
    210          //---------------------------------------------------------------------------------------------------------------------
    211          /**
    212           *  @brief      Motor Control Loop initialization.
    213           *  @details    In this routine are called all initialization functions.
    214           *
    215           *
    216           *  @param[in]     
    217           *  @param[out]     
    218           *  @param[in]      
    219           *  @return        
    220           */

   \                                 In section .text, align 2, keep-with-next
    221          void MclObserver__Initialize(MCL_OBSERVER_IO_F_TYPE *io, MCLOBSERVER_JOINT_PARAMS_TYPE *params)
    222          {
   \                     MclObserver__Initialize: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460C             MOV      R4,R1
    223              // reset MCL quantities
    224              Inductance_Correction(io, params);  // to initialize Mcl_Quantities inductances
   \   00000008   0x.... 0x....      BL       Inductance_Correction
    225              *(io->Ctrl_Specific->Rotor_Flux) = params->ObsPrm->Rotor_Flux_Nominal;
   \   0000000C   0x6A28             LDR      R0,[R5, #+32]
   \   0000000E   0x6821             LDR      R1,[R4, #+0]
   \   00000010   0x6D40             LDR      R0,[R0, #+84]
   \   00000012   0x6989             LDR      R1,[R1, #+24]
   \   00000014   0x6001             STR      R1,[R0, #+0]
    226          	MclObserver__ResetState(io, params);
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x4621             MOV      R1,R4
   \   0000001A   0x.... 0x....      BL       MclObserver__ResetState
    227          	Pole_Pairs_Inv = 1.0f/ params->ObsPrm->Pole_Pairs;
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable75_3
   \   00000024   0xEDD1 0x0A0B      VLDR     S1,[R1, #+44]
   \   00000028   0xEEB7 0x0A00      VMOV.F32 S0,#1.0
   \   0000002C   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000030   0xED80 0x0A1E      VSTR     S0,[R0, #+120]
    228              // Init Pll parameters
    229              Speed_PLL.kp = params->ObsPrm->PLL_Kp;
   \   00000034   0x6821             LDR      R1,[R4, #+0]
   \   00000036   0x6B49             LDR      R1,[R1, #+52]
   \   00000038   0x6001             STR      R1,[R0, #+0]
    230              Speed_PLL.ki = params->ObsPrm->PLL_Ki;
   \   0000003A   0x6821             LDR      R1,[R4, #+0]
   \   0000003C   0x6B89             LDR      R1,[R1, #+56]
   \   0000003E   0x6041             STR      R1,[R0, #+4]
    231              Speed_PLL.integ_k = params->ObsPrm->Pll_Integ_K;
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6BC9             LDR      R1,[R1, #+60]
   \   00000044   0x6301             STR      R1,[R0, #+48]
    232          
    233          }
   \   00000046   0xB001             ADD      SP,SP,#+4
   \   00000048   0xBD30             POP      {R4,R5,PC}       ;; return
    234          
    235          
    236          
    237          //---------------------------------------------------------------------------------------------------------------------
    238          /**
    239           *  @brief     Observer
    240           *  @details   Observer:  rotor flux speed estimation
    241           *                        flux position estimation (FOC: rotor flux, DTC: stator flux)
    242           *  @param[in]     
    243           *  @param[out]     
    244           *  @param[in]      
    245           *  @return        
    246           */

   \                                 In section .text, align 4, keep-with-next
    247          void MclObserver__RunningHandler(MCL_OBSERVER_IO_F_TYPE *io, MCLOBSERVER_JOINT_PARAMS_TYPE *params)
    248          {
   \                     MclObserver__RunningHandler: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xED2D 0x8B06      VPUSH    {D8-D10}
   \   0000000A   0xB086             SUB      SP,SP,#+24
    249          #if (OBS__VOLTAGE_PHASE_SHIFT == ENABLED)
    250              //==========================================================================//
    251              //                                                                          //
    252              //             Rotate the input voltage according to the speed              //
    253              //                                                                          //
    254              //==========================================================================//
    255              Voltage_Phase_Shift(io, params->ObsPrm);
    256          #endif
    257          
    258          
    259          #if (OBS__INVERTER_DISTORSION_COMPENSATION == ENABLED)
    260              //==========================================================================//
    261              //                                                                          //
    262              //                     Inverter distortion compensation                     //
    263              //                                                                          //
    264              //==========================================================================//
    265              InvDistortion_Comp(io, params->ObsPrm);
    266          #endif
    267          
    268          
    269              //==========================================================================//
    270              //                                                                          //
    271              //                   Electromotive Force (EMF) calculation                  //
    272              //                                                                          //
    273              //==========================================================================//
    274              Emf_Calc(io);
   \   0000000C   0x6A20             LDR      R0,[R4, #+32]
   \   0000000E   0x.... 0x....      LDR.W    R6,??DataTable75_3
   \   00000012   0x6980             LDR      R0,[R0, #+24]
   \   00000014   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0xED90 0x1A01      VLDR     S2,[R0, #+4]
   \   0000001E   0x6860             LDR      R0,[R4, #+4]
   \   00000020   0xED90 0x0A01      VLDR     S0,[R0, #+4]
   \   00000024   0xEE00 0x0AC1      VMLS.F32 S0,S1,S2
   \   00000028   0xED86 0x0A0F      VSTR     S0,[R6, #+60]
   \   0000002C   0x460D             MOV      R5,R1
   \   0000002E   0x6A20             LDR      R0,[R4, #+32]
   \   00000030   0x6980             LDR      R0,[R0, #+24]
   \   00000032   0xED90 0x1A00      VLDR     S2,[R0, #0]
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0xEDD0 0x1A02      VLDR     S3,[R0, #+8]
   \   0000003C   0x6860             LDR      R0,[R4, #+4]
   \   0000003E   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   00000042   0xEE41 0x0A61      VMLS.F32 S1,S2,S3
   \   00000046   0xEDC6 0x0A10      VSTR     S1,[R6, #+64]
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0xED96 0x1A2D      VLDR     S2,[R6, #+180]
   \   00000050   0xEDD0 0x1A01      VLDR     S3,[R0, #+4]
   \   00000054   0xEE01 0x0A61      VMLS.F32 S0,S2,S3
   \   00000058   0xED86 0x0A0F      VSTR     S0,[R6, #+60]
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0xEDD0 0x1A02      VLDR     S3,[R0, #+8]
   \   00000062   0xEE41 0x0A61      VMLS.F32 S1,S2,S3
   \   00000066   0xEDC6 0x0A10      VSTR     S1,[R6, #+64]
    275          
    276          
    277          
    278              //==========================================================================//
    279              //                                                                          //
    280              //                        Stator Flux Observer                              //
    281              //                                                                          //
    282              //==========================================================================//
    283              StatorFlux_Calc(io, params->ObsPrm);
   \   0000006A   0xEDD6 0x0A12      VLDR     S1,[R6, #+72]
   \   0000006E   0x682F             LDR      R7,[R5, #+0]
   \   00000070   0xED96 0x1A24      VLDR     S2,[R6, #+144]
   \   00000074   0xEDD6 0x1A15      VLDR     S3,[R6, #+84]
   \   00000078   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   0000007C   0xEDDF 0x0AA7      VLDR.W   S1,??MclObserver__RunningHandler_0  ;; 0x3883126f
   \   00000080   0xEE30 0x1A01      VADD.F32 S2,S0,S2
   \   00000084   0xEE41 0x1A20      VMLA.F32 S3,S2,S1
   \   00000088   0xED86 0x0A24      VSTR     S0,[R6, #+144]
   \   0000008C   0xED96 0x0A10      VLDR     S0,[R6, #+64]
   \   00000090   0xED96 0x1A13      VLDR     S2,[R6, #+76]
   \   00000094   0xEDC6 0x1A15      VSTR     S3,[R6, #+84]
   \   00000098   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \   0000009C   0xED96 0x1A25      VLDR     S2,[R6, #+148]
   \   000000A0   0xEDD6 0x1A16      VLDR     S3,[R6, #+88]
   \   000000A4   0xED86 0x0A25      VSTR     S0,[R6, #+148]
   \   000000A8   0xEE30 0x1A01      VADD.F32 S2,S0,S2
   \   000000AC   0xEE41 0x1A20      VMLA.F32 S3,S2,S1
   \   000000B0   0xEDC6 0x1A16      VSTR     S3,[R6, #+88]
   \   000000B4   0x6A20             LDR      R0,[R4, #+32]
   \   000000B6   0xED96 0x0A15      VLDR     S0,[R6, #+84]
   \   000000BA   0x6C40             LDR      R0,[R0, #+68]
   \   000000BC   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0xED90 0x1A01      VLDR     S2,[R0, #+4]
   \   000000C6   0xEE00 0x0AC1      VMLS.F32 S0,S1,S2
   \   000000CA   0xED86 0x0A18      VSTR     S0,[R6, #+96]
   \   000000CE   0xEE20 0x0A00      VMUL.F32 S0,S0,S0
   \   000000D2   0x6A20             LDR      R0,[R4, #+32]
   \   000000D4   0xEDD6 0x0A16      VLDR     S1,[R6, #+88]
   \   000000D8   0x6C40             LDR      R0,[R0, #+68]
   \   000000DA   0xED90 0x1A02      VLDR     S2,[R0, #+8]
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0xEDD0 0x1A02      VLDR     S3,[R0, #+8]
   \   000000E4   0xEE41 0x0A61      VMLS.F32 S1,S2,S3
   \   000000E8   0xEE00 0x0AA0      VMLA.F32 S0,S1,S1
   \   000000EC   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000000F0   0xEDC6 0x0A19      VSTR     S1,[R6, #+100]
   \   000000F4   0xEEF1 0xFA10      FMSTAT   
   \   000000F8   0xDB02             BLT.N    ??MclObserver__RunningHandler_1
   \   000000FA   0xEEB1 0x0AC0      VSQRT.F32 S0,S0
   \   000000FE   0xE001             B.N      ??MclObserver__RunningHandler_2
   \                     ??MclObserver__RunningHandler_1: (+1)
   \   00000100   0xED9F 0x0A87      VLDR.W   S0,??MclObserver__RunningHandler_0+0x4  ;; 0x0
   \                     ??MclObserver__RunningHandler_2: (+1)
   \   00000104   0x6E30             LDR      R0,[R6, #+96]
   \   00000106   0x9000             STR      R0,[SP, #+0]
   \   00000108   0xED86 0x0A1F      VSTR     S0,[R6, #+124]
   \   0000010C   0x6E70             LDR      R0,[R6, #+100]
   \   0000010E   0x9001             STR      R0,[SP, #+4]
   \   00000110   0x6FF0             LDR      R0,[R6, #+124]
   \   00000112   0x9002             STR      R0,[SP, #+8]
   \   00000114   0xA800             ADD      R0,SP,#+0
   \   00000116   0x.... 0x....      BL       MathCalc__GetSinCosF
   \   0000011A   0x6820             LDR      R0,[R4, #+0]
   \   0000011C   0xEDDD 0x8A04      VLDR     S17,[SP, #+16]
   \   00000120   0xED9D 0x8A03      VLDR     S16,[SP, #+12]
   \   00000124   0xED90 0x0A01      VLDR     S0,[R0, #+4]
   \   00000128   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   0000012C   0xEEF0 0x9A68      VMOV.F32 S19,S17
   \   00000130   0xEEB0 0x9A48      VMOV.F32 S18,S16
   \   00000134   0xEE20 0x0A29      VMUL.F32 S0,S0,S19
   \   00000138   0xEE00 0x0A89      VMLA.F32 S0,S1,S18
   \   0000013C   0xEEF0 0x0AC0      VABS.F32 S1,S0
   \   00000140   0xED86 0x0A1A      VSTR     S0,[R6, #+104]
   \   00000144   0xEDC6 0x0A1D      VSTR     S1,[R6, #+116]
   \   00000148   0x6A20             LDR      R0,[R4, #+32]
   \   0000014A   0x6A40             LDR      R0,[R0, #+36]
   \   0000014C   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   00000150   0x6820             LDR      R0,[R4, #+0]
   \   00000152   0xED96 0x1A1A      VLDR     S2,[R6, #+104]
   \   00000156   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   0000015A   0xEDD0 0x0A01      VLDR     S1,[R0, #+4]
   \   0000015E   0xED96 0x2A16      VLDR     S4,[R6, #+88]
   \   00000162   0xEDD6 0x2A2B      VLDR     S5,[R6, #+172]
   \   00000166   0xEDD6 0x3A2F      VLDR     S7,[R6, #+188]
   \   0000016A   0xEE20 0x0A29      VMUL.F32 S0,S0,S19
   \   0000016E   0xEE00 0x0AC9      VMLS.F32 S0,S1,S18
   \   00000172   0xEEF0 0x0AC0      VABS.F32 S1,S0
   \   00000176   0xED86 0x0A1B      VSTR     S0,[R6, #+108]
   \   0000017A   0xEDC6 0x0A1C      VSTR     S1,[R6, #+112]
   \   0000017E   0x6A20             LDR      R0,[R4, #+32]
   \   00000180   0xED97 0x3A08      VLDR     S6,[R7, #+32]
   \   00000184   0x6D42             LDR      R2,[R0, #+84]
   \   00000186   0x6C41             LDR      R1,[R0, #+68]
   \   00000188   0xED92 0xAA00      VLDR     S20,[R2, #0]
   \   0000018C   0x6C82             LDR      R2,[R0, #+72]
   \   0000018E   0xEDD1 0x1A01      VLDR     S3,[R1, #+4]
   \   00000192   0x6CC0             LDR      R0,[R0, #+76]
   \   00000194   0xEE01 0xAA21      VMLA.F32 S20,S2,S3
   \   00000198   0xEDD2 0x1A00      VLDR     S3,[R2, #0]
   \   0000019C   0xEE00 0xAAE1      VMLS.F32 S20,S1,S3
   \   000001A0   0xEDD1 0x0A02      VLDR     S1,[R1, #+8]
   \   000001A4   0xEE60 0x1A20      VMUL.F32 S3,S0,S1
   \   000001A8   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   000001AC   0xEE41 0x1A40      VMLS.F32 S3,S2,S0
   \   000001B0   0xEE2A 0x0A29      VMUL.F32 S0,S20,S19
   \   000001B4   0xEE01 0x0AC9      VMLS.F32 S0,S3,S18
   \   000001B8   0xED96 0x1A15      VLDR     S2,[R6, #+84]
   \   000001BC   0xEE30 0x1A41      VSUB.F32 S2,S0,S2
   \   000001C0   0xEE41 0x2A03      VMLA.F32 S5,S2,S6
   \   000001C4   0xEE6A 0x0A09      VMUL.F32 S1,S20,S18
   \   000001C8   0xED96 0x3A2E      VLDR     S6,[R6, #+184]
   \   000001CC   0xEE41 0x0AA9      VMLA.F32 S1,S3,S19
   \   000001D0   0xEEF4 0x3A43      VCMP.F32 S7,S6
   \   000001D4   0xEE30 0x2AC2      VSUB.F32 S4,S1,S4
   \   000001D8   0xEEF1 0xFA10      FMSTAT   
   \   000001DC   0xDB0C             BLT.N    ??MclObserver__RunningHandler_3
   \   000001DE   0xEEF4 0x2A63      VCMP.F32 S5,S7
   \   000001E2   0xEEF1 0xFA10      FMSTAT   
   \   000001E6   0xDA14             BGE.N    ??MclObserver__RunningHandler_4
   \   000001E8   0xEEB4 0x3A62      VCMP.F32 S6,S5
   \   000001EC   0xEEF1 0xFA10      FMSTAT   
   \   000001F0   0xDB11             BLT.N    ??MclObserver__RunningHandler_5
   \   000001F2   0xEEF0 0x2A43      VMOV.F32 S5,S6
   \   000001F6   0xE00E             B.N      ??MclObserver__RunningHandler_5
   \                     ??MclObserver__RunningHandler_3: (+1)
   \   000001F8   0xEEF4 0x2A43      VCMP.F32 S5,S6
   \   000001FC   0xEEF1 0xFA10      FMSTAT   
   \   00000200   0xDB02             BLT.N    ??MclObserver__RunningHandler_6
   \   00000202   0xEEF0 0x2A43      VMOV.F32 S5,S6
   \   00000206   0xE006             B.N      ??MclObserver__RunningHandler_5
   \                     ??MclObserver__RunningHandler_6: (+1)
   \   00000208   0xEEF4 0x3A62      VCMP.F32 S7,S5
   \   0000020C   0xEEF1 0xFA10      FMSTAT   
   \   00000210   0xDB01             BLT.N    ??MclObserver__RunningHandler_5
   \                     ??MclObserver__RunningHandler_4: (+1)
   \   00000212   0xEEF0 0x2A63      VMOV.F32 S5,S7
   \                     ??MclObserver__RunningHandler_5: (+1)
   \   00000216   0xEDC6 0x2A2B      VSTR     S5,[R6, #+172]
   \   0000021A   0xEEF4 0x3A43      VCMP.F32 S7,S6
   \   0000021E   0xEDD7 0x2A07      VLDR     S5,[R7, #+28]
   \   00000222   0xEE21 0x1A22      VMUL.F32 S2,S2,S5
   \   00000226   0xED86 0x1A12      VSTR     S2,[R6, #+72]
   \   0000022A   0xEEF1 0xFA10      FMSTAT   
   \   0000022E   0xEDD6 0x2A2B      VLDR     S5,[R6, #+172]
   \   00000232   0xEE31 0x1A22      VADD.F32 S2,S2,S5
   \   00000236   0xED86 0x1A12      VSTR     S2,[R6, #+72]
   \   0000023A   0xEDD7 0x2A08      VLDR     S5,[R7, #+32]
   \   0000023E   0xED96 0x1A2C      VLDR     S2,[R6, #+176]
   \   00000242   0xEE02 0x1A22      VMLA.F32 S2,S4,S5
   \   00000246   0xDB0A             BLT.N    ??MclObserver__RunningHandler_7
   \   00000248   0xEEB4 0x1A63      VCMP.F32 S2,S7
   \   0000024C   0xEEF1 0xFA10      FMSTAT   
   \   00000250   0xDA0F             BGE.N    ??MclObserver__RunningHandler_8
   \   00000252   0xEEB4 0x3A41      VCMP.F32 S6,S2
   \   00000256   0xEEF1 0xFA10      FMSTAT   
   \   0000025A   0xDA0F             BGE.N    ??MclObserver__RunningHandler_9
   \   0000025C   0xE00C             B.N      ??MclObserver__RunningHandler_10
   \                     ??MclObserver__RunningHandler_7: (+1)
   \   0000025E   0xEEB4 0x1A43      VCMP.F32 S2,S6
   \   00000262   0xEEF1 0xFA10      FMSTAT   
   \   00000266   0xDA09             BGE.N    ??MclObserver__RunningHandler_9
   \   00000268   0xEEF4 0x3A41      VCMP.F32 S7,S2
   \   0000026C   0xEEF1 0xFA10      FMSTAT   
   \   00000270   0xDB02             BLT.N    ??MclObserver__RunningHandler_10
   \                     ??MclObserver__RunningHandler_8: (+1)
   \   00000272   0xEEB0 0x3A63      VMOV.F32 S6,S7
   \   00000276   0xE001             B.N      ??MclObserver__RunningHandler_9
   \                     ??MclObserver__RunningHandler_10: (+1)
   \   00000278   0xEEB0 0x3A41      VMOV.F32 S6,S2
   \                     ??MclObserver__RunningHandler_9: (+1)
   \   0000027C   0xED86 0x3A2C      VSTR     S6,[R6, #+176]
   \   00000280   0xED97 0x1A07      VLDR     S2,[R7, #+28]
   \   00000284   0xEE22 0x1A01      VMUL.F32 S2,S4,S2
   \   00000288   0xED86 0x1A13      VSTR     S2,[R6, #+76]
   \   0000028C   0xED96 0x2A2C      VLDR     S4,[R6, #+176]
   \   00000290   0xEE31 0x1A02      VADD.F32 S2,S2,S4
   \   00000294   0xED86 0x1A13      VSTR     S2,[R6, #+76]
   \   00000298   0x6A20             LDR      R0,[R4, #+32]
   \   0000029A   0x6801             LDR      R1,[R0, #+0]
   \   0000029C   0xF3C1 0x1180      UBFX     R1,R1,#+6,#+1
   \   000002A0   0xB171             CBZ.N    R1,??MclObserver__RunningHandler_11
   \   000002A2   0xEE2A 0x1A0A      VMUL.F32 S2,S20,S20
   \   000002A6   0xEE01 0x1AA1      VMLA.F32 S2,S3,S3
   \   000002AA   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   000002AE   0xEEF1 0xFA10      FMSTAT   
   \   000002B2   0xDB02             BLT.N    ??MclObserver__RunningHandler_12
   \   000002B4   0xEEB1 0x1AC1      VSQRT.F32 S2,S2
   \   000002B8   0xE014             B.N      ??MclObserver__RunningHandler_13
   \                     ??MclObserver__RunningHandler_12: (+1)
   \   000002BA   0xED9F 0x1A19      VLDR.W   S2,??MclObserver__RunningHandler_0+0x4  ;; 0x0
   \   000002BE   0xE011             B.N      ??MclObserver__RunningHandler_13
   \                     ??MclObserver__RunningHandler_11: (+1)
   \   000002C0   0xEDD6 0x1A15      VLDR     S3,[R6, #+84]
   \   000002C4   0xED96 0x1A16      VLDR     S2,[R6, #+88]
   \   000002C8   0xEE61 0x1AA1      VMUL.F32 S3,S3,S3
   \   000002CC   0xEE41 0x1A01      VMLA.F32 S3,S2,S2
   \   000002D0   0xEEF5 0x1A40      VCMP.F32 S3,#0.0
   \   000002D4   0xEEF1 0xFA10      FMSTAT   
   \   000002D8   0xDB02             BLT.N    ??MclObserver__RunningHandler_14
   \   000002DA   0xEEB1 0x1AE1      VSQRT.F32 S2,S3
   \   000002DE   0xE001             B.N      ??MclObserver__RunningHandler_13
   \                     ??MclObserver__RunningHandler_14: (+1)
   \   000002E0   0xED9F 0x1A0F      VLDR.W   S2,??MclObserver__RunningHandler_0+0x4  ;; 0x0
   \                     ??MclObserver__RunningHandler_13: (+1)
   \   000002E4   0x6B80             LDR      R0,[R0, #+56]
   \   000002E6   0xED80 0x1A00      VSTR     S2,[R0, #0]
   \   000002EA   0xED96 0x1A21      VLDR     S2,[R6, #+132]
   \   000002EE   0xEDD6 0x1A20      VLDR     S3,[R6, #+128]
   \   000002F2   0xEE29 0x1A01      VMUL.F32 S2,S18,S2
   \   000002F6   0xEE01 0x1AE9      VMLS.F32 S2,S3,S19
   \   000002FA   0xEDDF 0x....      VLDR.W   S3,??DataTable67  ;; 0x45f9ffff
   \   000002FE   0xEE21 0x1A21      VMUL.F32 S2,S2,S3
   \   00000302   0xED86 0x1A29      VSTR     S2,[R6, #+164]
   \   00000306   0x6A20             LDR      R0,[R4, #+32]
   \   00000308   0x6800             LDR      R0,[R0, #+0]
   \   0000030A   0xF3C0 0x1080      UBFX     R0,R0,#+6,#+1
   \   0000030E   0xB148             CBZ.N    R0,??MclObserver__RunningHandler_15
   \   00000310   0xED8D 0x0A00      VSTR     S0,[SP, #+0]
   \   00000314   0xEDCD 0x0A01      VSTR     S1,[SP, #+4]
   \   00000318   0xE008             B.N      ??MclObserver__RunningHandler_16
   \   0000031A   0xBF00             Nop      
   \                     ??MclObserver__RunningHandler_0:
   \   0000031C   0x3883126F         DC32     0x3883126f
   \   00000320   0x00000000         DC32     0x0
   \                     ??MclObserver__RunningHandler_15: (+1)
   \   00000324   0x6D70             LDR      R0,[R6, #+84]
   \   00000326   0x9000             STR      R0,[SP, #+0]
   \   00000328   0x6DB0             LDR      R0,[R6, #+88]
   \   0000032A   0x9001             STR      R0,[SP, #+4]
   \                     ??MclObserver__RunningHandler_16: (+1)
   \   0000032C   0x6A20             LDR      R0,[R4, #+32]
   \   0000032E   0x6B80             LDR      R0,[R0, #+56]
   \   00000330   0x6800             LDR      R0,[R0, #+0]
   \   00000332   0x9002             STR      R0,[SP, #+8]
   \   00000334   0xA800             ADD      R0,SP,#+0
   \   00000336   0x.... 0x....      BL       MathCalc__GetSinCosF
   \   0000033A   0x6920             LDR      R0,[R4, #+16]
   \   0000033C   0x9903             LDR      R1,[SP, #+12]
   \   0000033E   0x6001             STR      R1,[R0, #+0]
   \   00000340   0x6920             LDR      R0,[R4, #+16]
   \   00000342   0x9904             LDR      R1,[SP, #+16]
   \   00000344   0x6041             STR      R1,[R0, #+4]
   \   00000346   0x6920             LDR      R0,[R4, #+16]
   \   00000348   0x6821             LDR      R1,[R4, #+0]
   \   0000034A   0xEDD0 0x0A01      VLDR     S1,[R0, #+4]
   \   0000034E   0xED90 0x1A00      VLDR     S2,[R0, #0]
   \   00000352   0x6A20             LDR      R0,[R4, #+32]
   \   00000354   0xED91 0x0A01      VLDR     S0,[R1, #+4]
   \   00000358   0x69C0             LDR      R0,[R0, #+28]
   \   0000035A   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000035E   0xEDD1 0x0A02      VLDR     S1,[R1, #+8]
   \   00000362   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   \   00000366   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   0000036A   0x6920             LDR      R0,[R4, #+16]
   \   0000036C   0x6821             LDR      R1,[R4, #+0]
   \   0000036E   0xEDD0 0x0A01      VLDR     S1,[R0, #+4]
   \   00000372   0xED90 0x1A00      VLDR     S2,[R0, #0]
   \   00000376   0x6A20             LDR      R0,[R4, #+32]
   \   00000378   0xED91 0x0A02      VLDR     S0,[R1, #+8]
   \   0000037C   0x6A00             LDR      R0,[R0, #+32]
   \   0000037E   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000382   0xEDD1 0x0A01      VLDR     S1,[R1, #+4]
   \   00000386   0xEE00 0x0AC1      VMLS.F32 S0,S1,S2
   \   0000038A   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   0000038E   0xED96 0x0A15      VLDR     S0,[R6, #+84]
   \   00000392   0x6920             LDR      R0,[R4, #+16]
   \   00000394   0xEDD6 0x0A16      VLDR     S1,[R6, #+88]
   \   00000398   0xED90 0x1A00      VLDR     S2,[R0, #0]
   \   0000039C   0xEE20 0x0A29      VMUL.F32 S0,S0,S19
   \   000003A0   0xEE00 0x0A89      VMLA.F32 S0,S1,S18
   \   000003A4   0xEDD0 0x0A01      VLDR     S1,[R0, #+4]
   \   000003A8   0x6A20             LDR      R0,[R4, #+32]
   \   000003AA   0x6C00             LDR      R0,[R0, #+64]
   \   000003AC   0xEE61 0x1A29      VMUL.F32 S3,S2,S19
   \   000003B0   0xEE40 0x1AC9      VMLS.F32 S3,S1,S18
   \   000003B4   0xEE60 0x0AA9      VMUL.F32 S1,S1,S19
   \   000003B8   0xEE41 0x0A09      VMLA.F32 S1,S2,S18
   \   000003BC   0xEDC0 0x0A01      VSTR     S1,[R0, #+4]
   \   000003C0   0xEE30 0x0A4A      VSUB.F32 S0,S0,S20
   \   000003C4   0x6A20             LDR      R0,[R4, #+32]
   \   000003C6   0x6C00             LDR      R0,[R0, #+64]
   \   000003C8   0xEDC0 0x1A00      VSTR     S3,[R0, #0]
   \   000003CC   0xED86 0x0A27      VSTR     S0,[R6, #+156]
    284          
    285          
    286          
    287              //==========================================================================//
    288              //                                                                          //
    289              //                 Phase Locked Loop to calculate speed                     //
    290              //                                                                          //
    291              //==========================================================================//
    292              Speed_PLL_Calc();
   \   000003D0   0xEDDF 0x....      VLDR.W   S1,??DataTable68  ;; 0x3e22f983
   \   000003D4   0xED96 0x0A07      VLDR     S0,[R6, #+28]
   \   000003D8   0xED86 0x9A20      VSTR     S18,[R6, #+128]
   \   000003DC   0xEE60 0x0A20      VMUL.F32 S1,S0,S1
   \   000003E0   0xEEBD 0x1AE0      VCVT.S32.F32 S2,S1
   \   000003E4   0xEE11 0x0A10      VMOV     R0,S2
   \   000003E8   0xED9F 0x....      VLDR.W   S2,??DataTable68_1  ;; 0xb4800000
   \   000003EC   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   000003F0   0xEDC6 0x9A21      VSTR     S19,[R6, #+132]
   \   000003F4   0xEDC6 0x8A02      VSTR     S17,[R6, #+8]
   \   000003F8   0xED86 0x8A03      VSTR     S16,[R6, #+12]
   \   000003FC   0xEEF1 0xFA10      FMSTAT   
   \   00000400   0xBF48             IT       MI 
   \   00000402   0x1E40             SUBMI    R0,R0,#+1
   \   00000404   0xEE01 0x0A10      VMOV     S2,R0
   \   00000408   0xEEB8 0x1AC1      VCVT.F32.S32 S2,S2
   \   0000040C   0xEE70 0x0AC1      VSUB.F32 S1,S1,S2
   \   00000410   0xED9F 0x....      VLDR.W   S2,??DataTable68_2  ;; 0x44000000
   \   00000414   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   00000418   0xEEBD 0x1AE0      VCVT.S32.F32 S2,S1
   \   0000041C   0xEE11 0x0A10      VMOV     R0,S2
   \   00000420   0x05C0             LSLS     R0,R0,#+23
   \   00000422   0x0DC0             LSRS     R0,R0,#+23
   \   00000424   0x4602             MOV      R2,R0
   \   00000426   0xEE01 0x2A10      VMOV     S2,R2
   \   0000042A   0x.... 0x....      LDR.W    R2,??DataTable86_1
   \   0000042E   0xF852 0x3020      LDR      R3,[R2, R0, LSL #+2]
   \   00000432   0xF100 0x0180      ADD      R1,R0,#+128
   \   00000436   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \   0000043A   0x05C9             LSLS     R1,R1,#+23
   \   0000043C   0x0DC9             LSRS     R1,R1,#+23
   \   0000043E   0xEDD0 0x1A01      VLDR     S3,[R0, #+4]
   \   00000442   0xEEB8 0x1A41      VCVT.F32.U32 S2,S2
   \   00000446   0xEB02 0x0081      ADD      R0,R2,R1, LSL #+2
   \   0000044A   0xEE70 0x0AC1      VSUB.F32 S1,S1,S2
   \   0000044E   0xEEB7 0x2A00      VMOV.F32 S4,#1.0
   \   00000452   0xEE01 0x3A10      VMOV     S2,R3
   \   00000456   0xEE32 0x2A60      VSUB.F32 S4,S4,S1
   \   0000045A   0xEDD0 0x2A00      VLDR     S5,[R0, #0]
   \   0000045E   0xED90 0x3A01      VLDR     S6,[R0, #+4]
   \   00000462   0xEE62 0x2A22      VMUL.F32 S5,S4,S5
   \   00000466   0xEE22 0x1A01      VMUL.F32 S2,S4,S2
   \   0000046A   0xEE40 0x2A83      VMLA.F32 S5,S1,S6
   \   0000046E   0xEE00 0x1AA1      VMLA.F32 S2,S1,S3
   \   00000472   0xEEF1 0x0A41      VNEG.F32 S1,S2
   \   00000476   0xEDC6 0x0A09      VSTR     S1,[R6, #+36]
   \   0000047A   0xEE68 0x0AA0      VMUL.F32 S1,S17,S1
   \   0000047E   0xEE48 0x0A22      VMLA.F32 S1,S16,S5
   \   00000482   0xED96 0x1A0B      VLDR     S2,[R6, #+44]
   \   00000486   0xED96 0x2A01      VLDR     S4,[R6, #+4]
   \   0000048A   0xEDC6 0x2A08      VSTR     S5,[R6, #+32]
   \   0000048E   0xEE70 0x1A81      VADD.F32 S3,S1,S2
   \   00000492   0xED96 0x1A06      VLDR     S2,[R6, #+24]
   \   00000496   0xEDC6 0x0A0A      VSTR     S1,[R6, #+40]
   \   0000049A   0xEE01 0x1A82      VMLA.F32 S2,S3,S4
   \   0000049E   0xED86 0x1A06      VSTR     S2,[R6, #+24]
   \   000004A2   0xEDC6 0x0A0B      VSTR     S1,[R6, #+44]
   \   000004A6   0xEDD6 0x1A00      VLDR     S3,[R6, #0]
   \   000004AA   0xEE00 0x1AA1      VMLA.F32 S2,S1,S3
   \   000004AE   0xEDD6 0x0A05      VLDR     S1,[R6, #+20]
   \   000004B2   0xEDD6 0x1A0C      VLDR     S3,[R6, #+48]
   \   000004B6   0xED86 0x1A04      VSTR     S2,[R6, #+16]
   \   000004BA   0xEE71 0x0A20      VADD.F32 S1,S2,S1
   \   000004BE   0xEE00 0x0AA1      VMLA.F32 S0,S1,S3
   \   000004C2   0xEDDF 0x....      VLDR.W   S1,??DataTable69  ;; 0x40490fdc
   \   000004C6   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   000004CA   0xED86 0x0A07      VSTR     S0,[R6, #+28]
   \   000004CE   0xED86 0x1A05      VSTR     S2,[R6, #+20]
   \   000004D2   0xEEF1 0xFA10      FMSTAT   
   \   000004D6   0xBFA4             ITT      GE 
   \   000004D8   0xEDDF 0x....      VLDRGE.W S1,??DataTable70  ;; 0xc0c90fdb
   \   000004DC   0xEE30 0x0A20      VADDGE.F32 S0,S0,S1
   \   000004E0   0xEDDF 0x....      VLDR.W   S1,??DataTable70_1  ;; 0xc0490fdb
   \   000004E4   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   000004E8   0xEEF1 0xFA10      FMSTAT   
   \   000004EC   0xBF44             ITT      MI 
   \   000004EE   0xEDDF 0x....      VLDRMI.W S1,??DataTable70_2  ;; 0x40c90fdb
   \   000004F2   0xEE30 0x0A20      VADDMI.F32 S0,S0,S1
   \   000004F6   0xED86 0x0A07      VSTR     S0,[R6, #+28]
    293          
    294          
    295              //==========================================================================//
    296              //                                                                          //
    297              //    Algorithm to select which speed shall be used, e.g., from flux PLL    //
    298              //               rotor flux frame or from stator flux frame.                //
    299              //                                                                          //
    300              //==========================================================================//
    301              Speed_Selector(io, params->ObsPrm);
   \   000004FA   0xEDDF 0x....      VLDR.W   S1,??DataTable70_3  ;; 0x3f7e0000
   \   000004FE   0xED96 0x0A2A      VLDR     S0,[R6, #+168]
   \   00000502   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000506   0xEDD6 0x0A29      VLDR     S1,[R6, #+164]
   \   0000050A   0xED9F 0x....      VLDR.W   S2,??DataTable70_4  ;; 0x3c000000
   \   0000050E   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   \   00000512   0xED86 0x0A2A      VSTR     S0,[R6, #+168]
   \   00000516   0x6A20             LDR      R0,[R4, #+32]
   \   00000518   0x6800             LDR      R0,[R0, #+0]
   \   0000051A   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   0000051E   0xB108             CBZ.N    R0,??MclObserver__RunningHandler_17
   \   00000520   0xED96 0x0A04      VLDR     S0,[R6, #+16]
   \                     ??MclObserver__RunningHandler_17: (+1)
   \   00000524   0x6960             LDR      R0,[R4, #+20]
   \   00000526   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   0000052A   0x6A20             LDR      R0,[R4, #+32]
   \   0000052C   0xEDD6 0x0A1E      VLDR     S1,[R6, #+120]
   \   00000530   0x68C0             LDR      R0,[R0, #+12]
   \   00000532   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000536   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   0000053A   0x6A20             LDR      R0,[R4, #+32]
   \   0000053C   0x68C1             LDR      R1,[R0, #+12]
   \   0000053E   0x6809             LDR      R1,[R1, #+0]
   \   00000540   0x6900             LDR      R0,[R0, #+16]
   \   00000542   0xF021 0x4100      BIC      R1,R1,#0x80000000
   \   00000546   0xEE00 0x1A10      VMOV     S0,R1
   \   0000054A   0xED80 0x0A00      VSTR     S0,[R0, #0]
    302          
    303          
    304              //==========================================================================//
    305              //                                                                          //
    306              //                    Electromagnetic Torque calculation                    //
    307              //                                                                          //
    308              //==========================================================================//
    309              ElectroMagneticTorqueCalc(io, params->ObsPrm);
   \   0000054E   0x6A21             LDR      R1,[R4, #+32]
   \   00000550   0x6828             LDR      R0,[R5, #+0]
   \   00000552   0x680A             LDR      R2,[R1, #+0]
   \   00000554   0xF3C2 0x1280      UBFX     R2,R2,#+6,#+1
   \   00000558   0xB96A             CBNZ.N   R2,??MclObserver__RunningHandler_18
   \   0000055A   0x6821             LDR      R1,[R4, #+0]
   \   0000055C   0xED96 0x0A15      VLDR     S0,[R6, #+84]
   \   00000560   0xEDD1 0x0A02      VLDR     S1,[R1, #+8]
   \   00000564   0xED91 0x1A01      VLDR     S2,[R1, #+4]
   \   00000568   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000056C   0xEDD6 0x0A16      VLDR     S1,[R6, #+88]
   \   00000570   0xEE00 0x0AC1      VMLS.F32 S0,S1,S2
   \   00000574   0xE013             B.N      ??MclObserver__RunningHandler_19
   \                     ??MclObserver__RunningHandler_18: (+1)
   \   00000576   0x6C4A             LDR      R2,[R1, #+68]
   \   00000578   0x6D49             LDR      R1,[R1, #+84]
   \   0000057A   0xED92 0x1A01      VLDR     S2,[R2, #+4]
   \   0000057E   0xEDD2 0x1A02      VLDR     S3,[R2, #+8]
   \   00000582   0xEDD6 0x0A1B      VLDR     S1,[R6, #+108]
   \   00000586   0xED91 0x0A00      VLDR     S0,[R1, #0]
   \   0000058A   0xEE31 0x1A61      VSUB.F32 S2,S2,S3
   \   0000058E   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000592   0xEDD6 0x1A1A      VLDR     S3,[R6, #+104]
   \   00000596   0xEE60 0x0AA1      VMUL.F32 S1,S1,S3
   \   0000059A   0xEE01 0x0A20      VMLA.F32 S0,S2,S1
   \                     ??MclObserver__RunningHandler_19: (+1)
   \   0000059E   0xED86 0x0A22      VSTR     S0,[R6, #+136]
   \   000005A2   0xEEF7 0x0A08      VMOV.F32 S1,#1.5
   \   000005A6   0xED90 0x0A0B      VLDR     S0,[R0, #+44]
   \   000005AA   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000005AE   0xEDD6 0x0A22      VLDR     S1,[R6, #+136]
   \   000005B2   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000005B6   0xEDD6 0x0A23      VLDR     S1,[R6, #+140]
   \   000005BA   0xED86 0x0A22      VSTR     S0,[R6, #+136]
   \   000005BE   0xEEB6 0x1A00      VMOV.F32 S2,#0.5
   \   000005C2   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   000005C6   0xEE40 0x0A01      VMLA.F32 S1,S0,S2
   \   000005CA   0xEDC6 0x0A23      VSTR     S1,[R6, #+140]
   \   000005CE   0x6A20             LDR      R0,[R4, #+32]
   \   000005D0   0x6A80             LDR      R0,[R0, #+40]
   \   000005D2   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
    310          
    311          }
   \   000005D6   0xB006             ADD      SP,SP,#+24
   \   000005D8   0xECBD 0x8B06      VPOP     {D8-D10}
   \   000005DC   0xB001             ADD      SP,SP,#+4
   \   000005DE   0xBDF0             POP      {R4-R7,PC}       ;; return
    312          
    313          
    314          
    315          

   \                                 In section .text, align 4, keep-with-next
    316          void MclObserver__1msHandler(MCL_OBSERVER_IO_F_TYPE *io, MCLOBSERVER_JOINT_PARAMS_TYPE *params)
    317          {
   \                     MclObserver__1msHandler: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    318          
    319              //==========================================================================//
    320              //                                                                          //
    321              //                         Inductance calculation                           //
    322              //                                                                          //
    323              //==========================================================================//
    324              Inductance_Correction(io, params);
   \   00000008   0x.... 0x....      BL       Inductance_Correction
    325          
    326              //==========================================================================//
    327              //                                                                          //
    328              //                         Rotor Flux calculation                           //
    329              //                                                                          //
    330              //==========================================================================//
    331              if (params->Rotor_Flux_lut.ptr_LUT != NULL)
   \   0000000C   0x6AA8             LDR      R0,[R5, #+40]
   \   0000000E   0xB158             CBZ.N    R0,??MclObserver__1msHandler_0
    332              {
    333                  RotorFlux_Correction(io,params);
   \   00000010   0x6A21             LDR      R1,[R4, #+32]
   \   00000012   0x6D09             LDR      R1,[R1, #+80]
   \   00000014   0xED91 0x0A00      VLDR     S0,[R1, #0]
   \   00000018   0xF105 0x0028      ADD      R0,R5,#+40
   \   0000001C   0x.... 0x....      BL       MathCalc__GetInterpolationFastF
   \   00000020   0x6A20             LDR      R0,[R4, #+32]
   \   00000022   0x6D40             LDR      R0,[R0, #+84]
   \   00000024   0xED80 0x0A00      VSTR     S0,[R0, #0]
    334              }
    335          
    336              //==========================================================================//
    337              //                                                                          //
    338              //                           Resistance adaptation                          //
    339              //                                                                          //
    340              //==========================================================================//
    341              Resistance_Adaptation(io, params->ObsPrm);
   \                     ??MclObserver__1msHandler_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x6829             LDR      R1,[R5, #+0]
   \   0000002C   0x.... 0x....      BL       Resistance_Adaptation
    342          
    343              Speed_Selector_Check(io, params->ObsPrm);
   \   00000030   0x6828             LDR      R0,[R5, #+0]
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable75_3
   \   00000036   0xED90 0x0A04      VLDR     S0,[R0, #+16]
   \   0000003A   0xEDD0 0x0A0B      VLDR     S1,[R0, #+44]
   \   0000003E   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000042   0xEDD1 0x0A2A      VLDR     S1,[R1, #+168]
   \   00000046   0xEEB0 0x1AE0      VABS.F32 S2,S1
   \   0000004A   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   0000004E   0xEEF1 0xFA10      FMSTAT   
   \   00000052   0xBF4C             ITE      MI 
   \   00000054   0x2201             MOVMI    R2,#+1
   \   00000056   0x2200             MOVPL    R2,#+0
   \   00000058   0xED91 0x0A04      VLDR     S0,[R1, #+16]
   \   0000005C   0xEE30 0x0AC0      VSUB.F32 S0,S1,S0
   \   00000060   0xEEB0 0x0AC0      VABS.F32 S0,S0
   \   00000064   0xEDDF 0x....      VLDR.W   S1,??DataTable72  ;; 0x4185f9db
   \   00000068   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000006C   0xEEF1 0xFA10      FMSTAT   
   \   00000070   0xBF4C             ITE      MI 
   \   00000072   0x2301             MOVMI    R3,#+1
   \   00000074   0x2300             MOVPL    R3,#+0
   \   00000076   0x6A25             LDR      R5,[R4, #+32]
   \   00000078   0x682E             LDR      R6,[R5, #+0]
   \   0000007A   0xF3C6 0x07C0      UBFX     R7,R6,#+3,#+1
   \   0000007E   0xB9CF             CBNZ.N   R7,??MclObserver__1msHandler_1
   \   00000080   0x421A             TST      R2,R3
   \   00000082   0xD005             BEQ.N    ??MclObserver__1msHandler_2
   \   00000084   0x0772             LSLS     R2,R6,#+29
   \   00000086   0xD403             BMI.N    ??MclObserver__1msHandler_2
   \   00000088   0xF8D1 0x20C0      LDR      R2,[R1, #+192]
   \   0000008C   0x1C52             ADDS     R2,R2,#+1
   \   0000008E   0xE000             B.N      ??MclObserver__1msHandler_3
   \                     ??MclObserver__1msHandler_2: (+1)
   \   00000090   0x2200             MOVS     R2,#+0
   \                     ??MclObserver__1msHandler_3: (+1)
   \   00000092   0xF8C1 0x20C0      STR      R2,[R1, #+192]
   \   00000096   0x6B00             LDR      R0,[R0, #+48]
   \   00000098   0xF8D1 0x10C0      LDR      R1,[R1, #+192]
   \   0000009C   0x4288             CMP      R0,R1
   \   0000009E   0xD212             BCS.N    ??MclObserver__1msHandler_4
   \   000000A0   0x6A20             LDR      R0,[R4, #+32]
   \   000000A2   0x6801             LDR      R1,[R0, #+0]
   \   000000A4   0xF041 0x0108      ORR      R1,R1,#0x8
   \   000000A8   0x6001             STR      R1,[R0, #+0]
   \   000000AA   0x6A20             LDR      R0,[R4, #+32]
   \   000000AC   0x6801             LDR      R1,[R0, #+0]
   \   000000AE   0xF021 0x0110      BIC      R1,R1,#0x10
   \   000000B2   0xE007             B.N      ??MclObserver__1msHandler_5
   \                     ??MclObserver__1msHandler_1: (+1)
   \   000000B4   0xB93A             CBNZ.N   R2,??MclObserver__1msHandler_4
   \   000000B6   0xF026 0x0008      BIC      R0,R6,#0x8
   \   000000BA   0x6028             STR      R0,[R5, #+0]
   \   000000BC   0x6A20             LDR      R0,[R4, #+32]
   \   000000BE   0x6801             LDR      R1,[R0, #+0]
   \   000000C0   0xF041 0x0110      ORR      R1,R1,#0x10
   \                     ??MclObserver__1msHandler_5: (+1)
   \   000000C4   0x6001             STR      R1,[R0, #+0]
   \                     ??MclObserver__1msHandler_4: (+1)
   \   000000C6   0x6A20             LDR      R0,[R4, #+32]
   \   000000C8   0x6D81             LDR      R1,[R0, #+88]
   \   000000CA   0x7809             LDRB     R1,[R1, #+0]
   \   000000CC   0xB119             CBZ.N    R1,??MclObserver__1msHandler_6
   \   000000CE   0x6801             LDR      R1,[R0, #+0]
   \   000000D0   0xF021 0x0108      BIC      R1,R1,#0x8
   \   000000D4   0x6001             STR      R1,[R0, #+0]
    344          
    345          
    346          
    347          }
   \                     ??MclObserver__1msHandler_6: (+1)
   \   000000D6   0xB001             ADD      SP,SP,#+4
   \   000000D8   0xBDF0             POP      {R4-R7,PC}       ;; return
    348          
    349          
    350          
    351          #if (OBS__VOLTAGE_PHASE_SHIFT == ENABLED)
    352          //========================================================//
    353          //          Phase Shift on reconstructed voltage          //
    354          //========================================================//
    355          void Voltage_Phase_Shift(MCL_OBSERVER_IO_F_TYPE *io, MCL_OBSERVER_PARAMS_TYPE *params)
    356          {
    357              ALPHA_BETA_COOR_SYST_F_TYPE vs_alpha_beta;
    358              DQ_COOR_SYST_F_TYPE vs_dq;
    359              float32 angle_advance;
    360              SIN_COS_F_TYPE sin_cos_adv;
    361              ALPHA_BETA_COOR_SYST_F_TYPE tmp_dq_adv;
    362          
    363          
    364              vs_alpha_beta.Alpha = io->Vs_Alpha_Beta->Alpha;
    365              vs_alpha_beta.Beta  = io->Vs_Alpha_Beta->Beta;
    366          
    367              // from vs alpha\beta to vs in dq stator flux reference frame
    368              ClrkPark__DirectParkF(&vs_alpha_beta,&vs_dq,io->Sin_Cos_Position_Flux);
    369          
    370              angle_advance = ( *(io->Ctrl_Specific->Speed_Rotor_Observed) * params->Phase_Advance_Coeff );
    371          
    372              MathCalc__SinCosF(angle_advance,  &sin_cos_adv);
    373          
    374              ClrkPark__InverseParkF(&vs_dq, &tmp_dq_adv,  &sin_cos_adv);
    375          
    376              vs_dq.D = tmp_dq_adv.Alpha;
    377              vs_dq.Q = tmp_dq_adv.Beta;
    378          
    379              //==========================================================================//
    380              //                Inverse Park transformation (dq-alpha beta)               //
    381              //==========================================================================//
    382              ClrkPark__InverseParkF(&vs_dq, io->Vs_Alpha_Beta, io->Sin_Cos_Position_Flux);
    383          
    384          }
    385          #endif
    386          
    387          
    388          
    389          
    390          #if (OBS__INVERTER_DISTORSION_COMPENSATION == ENABLED)
    391          //==========================================================================//
    392          //                        Deatime Compensation                              //
    393          //==========================================================================//
    394          void InvDistortion_Comp(MCL_OBSERVER_IO_F_TYPE *io, MCL_OBSERVER_PARAMS_TYPE *params)
    395          {
    396              InverterComp__Calculate(&Inv_Dist_Pointer);
    397          }
    398          #endif
    399          
    400          

   \                                 In section .text, align 4, keep-with-next
    401          void Resistance_Adaptation(MCL_OBSERVER_IO_F_TYPE *io, MCL_OBSERVER_PARAMS_TYPE *params)
    402          {
    403              float32 temp;
    404              float32 lim_lower;
    405          
    406              /*! Resistance adaptation is calculated as:
    407               * \f[
    408               * \begin{aligned}
    409               *      & R_s = R_s + R_{correction} \\
    410               *      & R_{correction} = R_{correction} + R_{gain} * \lambda_{error} \\
    411               *      & \lambda_{error} = \lambda_{m} - \hat{\lambda_{m}}
    412               * \end{aligned}
    413               * \f]
    414               */
    415          
    416              if((*(io->Ctrl_Specific->Speed_Rotor_Observed_Mech_Abs) <= (params->Curr_Resistance_Spd_Threshold)) || ((io->Ctrl_Specific->flags.bit.wrong_speed_direction)==1))
   \                     Resistance_Adaptation: (+1)
   \   00000000   0x6A00             LDR      R0,[R0, #+32]
   \   00000002   0xEDD1 0x0A04      VLDR     S1,[R1, #+16]
   \   00000006   0x6902             LDR      R2,[R0, #+16]
   \   00000008   0xED92 0x0A00      VLDR     S0,[R2, #0]
   \   0000000C   0x.... 0x....      LDR.W    R2,??DataTable75_3
   \   00000010   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   00000014   0xEEF1 0xFA10      FMSTAT   
   \   00000018   0xDA04             BGE.N    ??Resistance_Adaptation_0
   \   0000001A   0x6803             LDR      R3,[R0, #+0]
   \   0000001C   0xF3C3 0x0380      UBFX     R3,R3,#+2,#+1
   \   00000020   0x2B00             CMP      R3,#+0
   \   00000022   0xD03B             BEQ.N    ??Resistance_Adaptation_1
    417              {
    418                  if( *(io->Ctrl_Specific->Is_Abs) > (params->Curr_Resistance_Threshold) )
   \                     ??Resistance_Adaptation_0: (+1)
   \   00000024   0x6D03             LDR      R3,[R0, #+80]
   \   00000026   0xED91 0x0A03      VLDR     S0,[R1, #+12]
   \   0000002A   0xEDD3 0x0A00      VLDR     S1,[R3, #0]
   \   0000002E   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000032   0xEEF1 0xFA10      FMSTAT   
   \   00000036   0xD550             BPL.N    ??Resistance_Adaptation_2
    419                  {
    420                      temp = Stator_Resistance_Corr + Flux_Error * (params->Stator_Resistance_Gain);
    421                      lim_lower = -params->Stator_Resistance_Corr_Limits*(*(io->Ctrl_Specific->Stator_Resistance));
   \   00000038   0x6980             LDR      R0,[R0, #+24]
   \   0000003A   0xED92 0x0A27      VLDR     S0,[R2, #+156]
   \   0000003E   0xED91 0x1A02      VLDR     S2,[R1, #+8]
   \   00000042   0xEDD2 0x0A2D      VLDR     S1,[R2, #+180]
   \   00000046   0xEE40 0x0A01      VMLA.F32 S1,S0,S2
   \   0000004A   0xED91 0x0A01      VLDR     S0,[R1, #+4]
   \   0000004E   0xED90 0x1A00      VLDR     S2,[R0, #0]
   \   00000052   0xEE20 0x0A41      VNMUL.F32 S0,S0,S2
    422                      Stator_Resistance_Corr = MATHCALC__SATURATE(lim_lower, temp, 0);
   \   00000056   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000005A   0xEEF1 0xFA10      FMSTAT   
   \   0000005E   0xD80C             BHI.N    ??Resistance_Adaptation_3
   \   00000060   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   00000064   0xEEF1 0xFA10      FMSTAT   
   \   00000068   0xDA14             BGE.N    ??Resistance_Adaptation_4
   \   0000006A   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000006E   0xEEF1 0xFA10      FMSTAT   
   \   00000072   0xDA07             BGE.N    ??Resistance_Adaptation_5
   \   00000074   0xEDC2 0x0A2D      VSTR     S1,[R2, #+180]
   \   00000078   0xE036             B.N      ??Resistance_Adaptation_6
   \                     ??Resistance_Adaptation_3: (+1)
   \   0000007A   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   0000007E   0xEEF1 0xFA10      FMSTAT   
   \   00000082   0xDB02             BLT.N    ??Resistance_Adaptation_7
   \                     ??Resistance_Adaptation_5: (+1)
   \   00000084   0xED82 0x0A2D      VSTR     S0,[R2, #+180]
   \   00000088   0xE027             B.N      ??Resistance_Adaptation_2
   \                     ??Resistance_Adaptation_7: (+1)
   \   0000008A   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   0000008E   0xEEF1 0xFA10      FMSTAT   
   \   00000092   0xD820             BHI.N    ??Resistance_Adaptation_8
   \                     ??Resistance_Adaptation_4: (+1)
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xF8C2 0x00B4      STR      R0,[R2, #+180]
   \   0000009A   0x4770             BX       LR
    423                  }
    424              }
    425              //else if((*(io->Ctrl_Specific->Speed_Rotor_Observed_Mech_Abs) > Curr_Resistance_Spd_Threshold_High) && ((io->Ctrl_Specific->flags.bit.wrong_speed_direction)==0))
    426              else if(io->Ctrl_Specific->flags.bit.wrong_speed_direction==0)
    427              {
    428                  temp = Stator_Resistance_Corr + OBS__RESISTANCE_ADAPTATION_RECOVERY;
   \                     ??Resistance_Adaptation_1: (+1)
   \   0000009C   0xED9F 0x....      VLDR.W   S2,??DataTable72_1  ;; 0x38aec174
   \   000000A0   0xEDD2 0x0A2D      VLDR     S1,[R2, #+180]
   \   000000A4   0xEE70 0x0A81      VADD.F32 S1,S1,S2
    429                  if (temp>0)
   \   000000A8   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   000000AC   0xEEF1 0xFA10      FMSTAT   
   \   000000B0   0xDD11             BLE.N    ??Resistance_Adaptation_8
    430                  {
    431                      temp = 0;
    432                      if (*(io->Ctrl_Specific->Speed_Rotor_Observed_Mech_Abs) > params->Observer_G_integ_Spd_Threshold)
   \   000000B2   0xED91 0x1A0A      VLDR     S2,[R1, #+40]
   \   000000B6   0xEEB4 0x1A40      VCMP.F32 S2,S0
   \   000000BA   0xEDDF 0x....      VLDR.W   S1,??DataTable72_2  ;; 0x0
   \   000000BE   0xEEF1 0xFA10      FMSTAT   
   \   000000C2   0xD508             BPL.N    ??Resistance_Adaptation_8
    433                      {
    434                          Err_Lim_Lower = -(params->Observer_G_integ_limits);
   \   000000C4   0xED91 0x0A09      VLDR     S0,[R1, #+36]
   \   000000C8   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   000000CC   0xED82 0x0A2E      VSTR     S0,[R2, #+184]
    435                          Err_Lim_Upper = params->Observer_G_integ_limits;
   \   000000D0   0x6A48             LDR      R0,[R1, #+36]
   \   000000D2   0xF8C2 0x00BC      STR      R0,[R2, #+188]
    436                      }
    437                  }
    438                  Stator_Resistance_Corr = temp;
   \                     ??Resistance_Adaptation_8: (+1)
   \   000000D6   0xEDC2 0x0A2D      VSTR     S1,[R2, #+180]
    439              }
    440          
    441              if (Stator_Resistance_Corr < 0)
   \                     ??Resistance_Adaptation_2: (+1)
   \   000000DA   0xED92 0x0A2D      VLDR     S0,[R2, #+180]
   \   000000DE   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000000E2   0xEEF1 0xFA10      FMSTAT   
   \   000000E6   0xD504             BPL.N    ??Resistance_Adaptation_9
    442              {
    443                  Err_Lim_Lower = 0.0f;
   \                     ??Resistance_Adaptation_6: (+1)
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0xF8C2 0x00B8      STR      R0,[R2, #+184]
    444                  Err_Lim_Upper = 0.0f;
   \   000000EE   0xF8C2 0x00BC      STR      R0,[R2, #+188]
    445              }
    446          }
   \                     ??Resistance_Adaptation_9: (+1)
   \   000000F2   0x4770             BX       LR               ;; return
    447          
    448          #ifdef __IAR_SYSTEMS_ICC__
    449          #pragma inline = forced
    450          #endif
    451          void Emf_Calc(MCL_OBSERVER_IO_F_TYPE *io)
    452          {
    453              /*! Emf calculation:
    454               * \f[
    455               * \begin{aligned}
    456               *      & Emf_{alpha} = v_{alpha} - R_{s} * i_{alpha} - vdt_{alpha} \\
    457               *      & Emf_{beta} =  v_{beta}  - R_{s} * i_{beta}  - vdt_{beta} \\
    458               * \end{aligned}
    459               * \f]
    460               */
    461          
    462              // EMF Alpha calculation
    463              Stator_Emf.Alpha  = (io->Vs_Alpha_Beta->Alpha) - (*(io->Ctrl_Specific->Stator_Resistance) * (io->Is_Alpha_Beta->Alpha));
    464          
    465              // EMF Beta calculation
    466              Stator_Emf.Beta   = (io->Vs_Alpha_Beta->Beta)  - (*(io->Ctrl_Specific->Stator_Resistance) * (io->Is_Alpha_Beta->Beta ));
    467          
    468          #if (OBS__INVERTER_DISTORSION_COMPENSATION == ENABLED)
    469              Stator_Emf.Alpha -= Inverter_Distortion.Alpha;
    470              Stator_Emf.Beta -= Inverter_Distortion.Beta;
    471          #endif
    472          
    473              Stator_Emf.Alpha -= Stator_Resistance_Corr * (io->Is_Alpha_Beta->Alpha);
    474              Stator_Emf.Beta  -= Stator_Resistance_Corr * (io->Is_Alpha_Beta->Beta );
    475          
    476          }
    477          
    478          
    479          
    480          

   \                                 In section .text, align 2, keep-with-next
    481          void Inductance_Correction(MCL_OBSERVER_IO_F_TYPE *io, MCLOBSERVER_JOINT_PARAMS_TYPE *params)
    482          {
   \                     Inductance_Correction: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    483              float32 temp;
    484          
    485              temp              = Rotor_Curr_Id_Abs;
    486              (io->Ctrl_Specific->Ldq_Ind->D)    = MathCalc__GetInterpolationFastF(temp, &params->Ld_lut);
   \   00000002   0x.... 0x....      LDR.W    R6,??DataTable75_3
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x1D28             ADDS     R0,R5,#+4
   \   0000000C   0xED96 0x0A1D      VLDR     S0,[R6, #+116]
   \   00000010   0x.... 0x....      BL       MathCalc__GetInterpolationFastF
   \   00000014   0x6A20             LDR      R0,[R4, #+32]
   \   00000016   0x6C40             LDR      R0,[R0, #+68]
   \   00000018   0xED80 0x0A01      VSTR     S0,[R0, #+4]
    487          
    488              temp              = Rotor_Curr_Iq_Abs;
    489              (io->Ctrl_Specific->Ldq_Ind->Q)    = MathCalc__GetInterpolationFastF(temp, &params->Lq_lut);
   \   0000001C   0xF105 0x0010      ADD      R0,R5,#+16
   \   00000020   0xED96 0x0A1C      VLDR     S0,[R6, #+112]
   \   00000024   0x.... 0x....      BL       MathCalc__GetInterpolationFastF
   \   00000028   0x6A20             LDR      R0,[R4, #+32]
   \   0000002A   0x6C40             LDR      R0,[R0, #+68]
   \   0000002C   0xED80 0x0A02      VSTR     S0,[R0, #+8]
    490          
    491              // Capturing the Ldq term from the table
    492              temp = Rotor_Curr_Iq_Abs;
    493              *(io->Ctrl_Specific->Ldq_Cross_Ind) = MathCalc__GetInterpolationFastF(temp, &params->Ldq_lut);
   \   00000030   0xF105 0x001C      ADD      R0,R5,#+28
   \   00000034   0xED96 0x0A1C      VLDR     S0,[R6, #+112]
   \   00000038   0x.... 0x....      BL       MathCalc__GetInterpolationFastF
   \   0000003C   0x6A20             LDR      R0,[R4, #+32]
   \   0000003E   0x6C80             LDR      R0,[R0, #+72]
   \   00000040   0xED80 0x0A00      VSTR     S0,[R0, #0]
    494          
    495              // Capturing the Lqd term from the table
    496              temp = Rotor_Curr_Id_Abs;
    497              *(io->Ctrl_Specific->Lqd_Cross_Ind) = MathCalc__GetInterpolationFastF(temp, &params->Ldq_lut);
   \   00000044   0xF105 0x001C      ADD      R0,R5,#+28
   \   00000048   0xED96 0x0A1D      VLDR     S0,[R6, #+116]
   \   0000004C   0x.... 0x....      BL       MathCalc__GetInterpolationFastF
   \   00000050   0x6A20             LDR      R0,[R4, #+32]
   \   00000052   0x6CC0             LDR      R0,[R0, #+76]
   \   00000054   0xED80 0x0A00      VSTR     S0,[R0, #0]
    498          
    499          }
   \   00000058   0xBD70             POP      {R4-R6,PC}       ;; return
    500          
    501          

   \                                 In section .text, align 2, keep-with-next
    502          void RotorFlux_Correction(MCL_OBSERVER_IO_F_TYPE *io, MCLOBSERVER_JOINT_PARAMS_TYPE *params)
    503          {
    504              float32 temp;
    505          
    506              temp = *(io->Ctrl_Specific->Is_Abs);
    507              *(io->Ctrl_Specific->Rotor_Flux) = MathCalc__GetInterpolationFastF(temp, &params->Rotor_Flux_lut);
   \                     RotorFlux_Correction: (+1)
   \   00000000   0x6A00             LDR      R0,[R0, #+32]
   \   00000002   0x6D02             LDR      R2,[R0, #+80]
   \   00000004   0xED92 0x0A00      VLDR     S0,[R2, #0]
   \   00000008   0x3128             ADDS     R1,R1,#+40
   \   0000000A   0x688A             LDR      R2,[R1, #+8]
   \   0000000C   0x684B             LDR      R3,[R1, #+4]
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0xEDD3 0x0A00      VLDR     S1,[R3, #0]
   \   00000014   0xED91 0x1A00      VLDR     S2,[R1, #0]
   \   00000018   0x6812             LDR      R2,[R2, #+0]
   \   0000001A   0xEE30 0x1A41      VSUB.F32 S2,S0,S2
   \   0000001E   0xEE21 0x1A20      VMUL.F32 S2,S2,S1
   \   00000022   0xEEBD 0x1AC1      VCVT.S32.F32 S2,S2
   \   00000026   0x1E92             SUBS     R2,R2,#+2
   \   00000028   0xEE11 0x3A10      VMOV     R3,S2
   \   0000002C   0x429A             CMP      R2,R3
   \   0000002E   0xDA07             BGE.N    ??RotorFlux_Correction_0
   \   00000030   0xEB01 0x01C2      ADD      R1,R1,R2, LSL #+3
   \   00000034   0x6D40             LDR      R0,[R0, #+84]
   \   00000036   0xED91 0x1A03      VLDR     S2,[R1, #+12]
   \   0000003A   0xED80 0x1A00      VSTR     S2,[R0, #0]
    508          }
   \   0000003E   0x4770             BX       LR
   \                     ??RotorFlux_Correction_0: (+1)
   \   00000040   0x2B00             CMP      R3,#+0
   \   00000042   0xBF48             IT       MI 
   \   00000044   0xED91 0x1A01      VLDRMI   S2,[R1, #+4]
   \   00000048   0xD411             BMI.N    ??RotorFlux_Correction_1
   \   0000004A   0xEB01 0x02C3      ADD      R2,R1,R3, LSL #+3
   \   0000004E   0xEB01 0x01C3      ADD      R1,R1,R3, LSL #+3
   \   00000052   0xED92 0x1A01      VLDR     S2,[R2, #+4]
   \   00000056   0xEDD1 0x1A00      VLDR     S3,[R1, #0]
   \   0000005A   0xEE30 0x0A61      VSUB.F32 S0,S0,S3
   \   0000005E   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000062   0xEDD2 0x0A03      VLDR     S1,[R2, #+12]
   \   00000066   0xEE70 0x0AC1      VSUB.F32 S1,S1,S2
   \   0000006A   0xEE00 0x1A20      VMLA.F32 S2,S0,S1
   \                     ??RotorFlux_Correction_1: (+1)
   \   0000006E   0x6D40             LDR      R0,[R0, #+84]
   \   00000070   0xED80 0x1A00      VSTR     S2,[R0, #0]
   \   00000074   0x4770             BX       LR               ;; return
    509          
    510          
    511          //---------------------------------------------------------------------------------------------------------------------
    512          /**
    513           *  @brief      Stator flux observer (Generic) which supports salient motors, it contains more updates from Prof. Radu.
    514           *
    515           *  @param      motor phase voltages and phase currents => which will result in stator flux, rotor flux and speed computations.
    516           *  @return     none.
    517           */
    518          #ifdef __IAR_SYSTEMS_ICC__
    519          #pragma inline = forced
    520          #endif
    521          void StatorFlux_Calc(MCL_OBSERVER_IO_F_TYPE *io, MCL_OBSERVER_PARAMS_TYPE *params)
    522          {
    523              float32 temp_1;
    524              float32 temp_3;
    525              float32 temp_4;
    526              float32 dLambdas_alpha;
    527              float32 dLambdas_beta;
    528              MATHCALC_MOD_SIN_COS_F_TYPE trig_alpha_beta_mod;
    529              float32 lambda_mag_rot;
    530          
    531              float32 sin_rot;
    532              float32 cos_rot;
    533          
    534              float32 Lambda_d;
    535              float32 Lambda_q;
    536              float32 Lambdas_alpha_fback;
    537              float32 Lambdas_beta_fback;
    538              float32 error_flux_alpha;
    539              float32 error_flux_beta;
    540          
    541              float32 stator_flux_d_forward;
    542          
    543              float32 load_angle_cos;
    544              float32 load_angle_sin;
    545          
    546          #if (OBS__ROTOR_MECH_POSITION  == ENABLED)  // not used
    547              float32 rotor_pos_delta;
    548          #endif
    549          
    550          
    551              //******************************************************************//
    552              //                                                                  //
    553              //              Integrate the emf to find the stator flux           //
    554              //                                                                  //
    555              //******************************************************************//
    556          
    557              //// Alpha flux - trapezoidal integration
    558              dLambdas_alpha  = Stator_Emf.Alpha + Stator_Emf_Err.Alpha;
    559              Stator_Lambda.Alpha += (dLambdas_alpha + dLambdas_alpha_old) * PARAMS_EMF_INT_CONSTANT;
    560              dLambdas_alpha_old = dLambdas_alpha;
    561          
    562          
    563          
    564              //// Beta flux - trapezoidal integration
    565              dLambdas_beta  = Stator_Emf.Beta + Stator_Emf_Err.Beta;
    566              Stator_Lambda.Beta += (dLambdas_beta + dLambdas_beta_old) * PARAMS_EMF_INT_CONSTANT;
    567              dLambdas_beta_old = dLambdas_beta;
    568          
    569          
    570          
    571              //******************************************************************//
    572              //                                                                  //
    573              //                     Estimate rotor flux                          //
    574              //                                                                  //
    575              //******************************************************************//
    576              // Alpha axis rotor flux
    577              Rotor_Lambda.Alpha = Stator_Lambda.Alpha - (io->Ctrl_Specific->Ldq_Ind->Q) * io->Is_Alpha_Beta->Alpha;
    578              // Beta axis rotor flux
    579              Rotor_Lambda.Beta  = Stator_Lambda.Beta  - (io->Ctrl_Specific->Ldq_Ind->Q) * io->Is_Alpha_Beta->Beta;
    580          
    581              // Magnitude (modulus) rotor flux
    582              temp_1 =  Rotor_Lambda.Alpha*Rotor_Lambda.Alpha + Rotor_Lambda.Beta*Rotor_Lambda.Beta;
    583              Rotor_Lambda_Mod = MC_SQRT_F(temp_1);  // Result in Q17.15
    584          
    585          
    586          
    587          
    588              //******************************************************************//
    589              //                                                                  //
    590              //                   ROTOR Sin and Cos calculations                 //
    591              //                                                                  //
    592              //******************************************************************//
    593              trig_alpha_beta_mod.Alpha = Rotor_Lambda.Alpha;
    594              trig_alpha_beta_mod.Beta  = Rotor_Lambda.Beta;
    595              trig_alpha_beta_mod.Mod = Rotor_Lambda_Mod;
    596              MathCalc__GetSinCosF(&trig_alpha_beta_mod);
    597              sin_rot = trig_alpha_beta_mod.Sin;
    598              cos_rot = trig_alpha_beta_mod.Cos;
    599          
    600          
    601          
    602          
    603          
    604              //******************************************************************//
    605              //                                                                  //
    606              //             Id & Iq calculation => Transformation to             //
    607              //                     the ROTOR reference frame                    //
    608              //                                                                  //
    609              //******************************************************************//
    610              Rotor_Curr_Id = ((io->Is_Alpha_Beta->Alpha) * cos_rot) + ((io->Is_Alpha_Beta->Beta) * sin_rot);
    611              Rotor_Curr_Id_Abs = MATHCALC__FABS(Rotor_Curr_Id);
    612              *io->Ctrl_Specific->Id_Rotor_Current = Rotor_Curr_Id;
    613          
    614          
    615              Rotor_Curr_Iq = ((-(io->Is_Alpha_Beta->Alpha)) * sin_rot) + ((io->Is_Alpha_Beta->Beta) * cos_rot);
    616              Rotor_Curr_Iq_Abs = MATHCALC__FABS(Rotor_Curr_Iq);
    617          
    618              // Compute stator flux components in (d,q) frame from magnetic model
    619              Lambda_d  = *(io->Ctrl_Specific->Rotor_Flux) + Rotor_Curr_Id * (io->Ctrl_Specific->Ldq_Ind->D);
    620              Lambda_q  = Rotor_Curr_Iq * (io->Ctrl_Specific->Ldq_Ind->Q);
    621          
    622              Lambda_d  = Lambda_d - (Rotor_Curr_Iq_Abs * (*io->Ctrl_Specific->Ldq_Cross_Ind));
    623              Lambda_q  = Lambda_q - (Rotor_Curr_Id * (*io->Ctrl_Specific->Lqd_Cross_Ind));
    624          
    625          
    626          
    627              //******************************************************************//
    628              //                                                                  //
    629              //             Transform fluxes back to stationary frame            //
    630              //                                                                  //
    631              //******************************************************************//
    632              Lambdas_alpha_fback  = Lambda_d * cos_rot - Lambda_q * sin_rot;
    633              Lambdas_beta_fback   = Lambda_d * sin_rot + Lambda_q * cos_rot;
    634          
    635              // Q30 = Q30 + Q30
    636              error_flux_alpha = Lambdas_alpha_fback - Stator_Lambda.Alpha;
    637          
    638              error_flux_beta  = Lambdas_beta_fback  - Stator_Lambda.Beta;
    639          
    640              temp_1 = Error_Flux_Alpha_1 + error_flux_alpha * params->Observer_G_integ_gain;
    641          
    642              // limit the integral
    643              Error_Flux_Alpha_1 = MATHCALC__SATURATE(Err_Lim_Lower, temp_1, Err_Lim_Upper);
    644          
    645              Stator_Emf_Err.Alpha = error_flux_alpha * (params->Observer_G_gain);
    646          
    647              Stator_Emf_Err.Alpha += Error_Flux_Alpha_1;
    648          
    649              temp_1 = Error_Flux_Beta_1 + error_flux_beta *  params->Observer_G_integ_gain;
    650          
    651              // limit the integral
    652              Error_Flux_Beta_1 = MATHCALC__SATURATE(Err_Lim_Lower, temp_1, Err_Lim_Upper);
    653          
    654          
    655              Stator_Emf_Err.Beta  = error_flux_beta  * (params->Observer_G_gain);
    656              Stator_Emf_Err.Beta += Error_Flux_Beta_1;
    657          
    658          
    659              //******************************************************************//
    660              //                                                                  //
    661              //                 Stator flux magnitude and speed                  //
    662              //                                                                  //
    663              //******************************************************************//
    664              // Square the stator flux and beta, sum and take the square root.
    665              temp_3 = Stator_Lambda.Alpha * Stator_Lambda.Alpha;
    666              temp_4 = Stator_Lambda.Beta  * Stator_Lambda.Beta;
    667          	temp_3 = temp_3 + temp_4;
    668          
    669          	if (io->Ctrl_Specific->flags.bit.overflux_active == 1)
    670              {
    671          	    lambda_mag_rot = MC_SQRT_F(Lambda_d * Lambda_d + Lambda_q * Lambda_q);
    672                  *(io->Ctrl_Specific->Stator_Flux_Mag) = lambda_mag_rot;
    673              }
    674              else
    675              {
    676                  *(io->Ctrl_Specific->Stator_Flux_Mag) = MC_SQRT_F(temp_3);
    677              }
    678          
    679          
    680              //******************************************************************//
    681              //                                                                  //
    682              //     Calculate speed from rotor frame and low pass filter it      //
    683              //                                                                  //
    684              //******************************************************************//
    685              temp_1 = (sin_rot * Cos_Rot_k1) - (Sin_Rot_k1 * cos_rot);
    686              Obs_Speed_Rotor_Flux = temp_1 * (1.0f/TS);
    687          
    688              //******************************************************************//
    689              //                                                                  //
    690              //                   STATOR Sin and Cos calculations                //
    691              //                                                                  //
    692              //******************************************************************//
    693              if (io->Ctrl_Specific->flags.bit.overflux_active == 1)
    694              {
    695                  trig_alpha_beta_mod.Alpha = Lambdas_alpha_fback;
    696                  trig_alpha_beta_mod.Beta  = Lambdas_beta_fback;
    697              }
    698              else
    699              {
    700                  trig_alpha_beta_mod.Alpha = Stator_Lambda.Alpha;
    701                  trig_alpha_beta_mod.Beta  = Stator_Lambda.Beta;
    702              }
    703          
    704              trig_alpha_beta_mod.Mod   = *(io->Ctrl_Specific->Stator_Flux_Mag);
    705              MathCalc__GetSinCosF(&trig_alpha_beta_mod);
    706              io->Sin_Cos_Position_Flux->Sin = trig_alpha_beta_mod.Sin;
    707              io->Sin_Cos_Position_Flux->Cos = trig_alpha_beta_mod.Cos;
    708          
    709              *(io->Ctrl_Specific->Id_stator_current) = (io->Is_Alpha_Beta->Alpha) * (io->Sin_Cos_Position_Flux->Cos) + (io->Is_Alpha_Beta->Beta) * (io->Sin_Cos_Position_Flux->Sin);
    710          
    711              *(io->Ctrl_Specific->Iq_stator_current) = -(io->Is_Alpha_Beta->Alpha) * (io->Sin_Cos_Position_Flux->Sin) + (io->Is_Alpha_Beta->Beta) * (io->Sin_Cos_Position_Flux->Cos);
    712          
    713          
    714          #if (OBS__ROTOR_MECH_POSITION  == ENABLED)  // not used
    715              //******************************************************************//
    716              //                                                                  //
    717              //        Calculate accurately the mechanical rotor position        //
    718              //                                                                  //
    719              //******************************************************************//
    720              Rotor_Position = MC_ATAN2_F(cos_rot, sin_rot);
    721             // rotor_pos_delta = Rotor_Position - Last_Mech_Rotor_Pos;
    722             // Rotor_Mech_Position += (rotor_pos_delta + Mech_Rotor_Pos_Acc_Err) / (params->Pole_Pairs);
    723             // Mech_Rotor_Pos_Acc_Err = (rotor_pos_delta + Mech_Rotor_Pos_Acc_Err) % (params->Pole_Pairs);
    724             // Last_Mech_Rotor_Pos = Rotor_Position;
    725              *(io->Rotor_Position) = Rotor_Position;
    726          
    727          #endif
    728          
    729              //******************************************************************//
    730              //                                                                  //
    731              //       Compute load angle using the same (d,q) stator flux        //
    732              //           components, but computed from (alpha,beta)             //
    733              //                    forward path components                       //
    734              //                                                                  //
    735              //******************************************************************//
    736              stator_flux_d_forward  = Stator_Lambda.Alpha * cos_rot + Stator_Lambda.Beta  * sin_rot;
    737          
    738              load_angle_cos = io->Sin_Cos_Position_Flux->Cos * cos_rot + io->Sin_Cos_Position_Flux->Sin *sin_rot;
    739          
    740              load_angle_sin = io->Sin_Cos_Position_Flux->Sin * cos_rot - io->Sin_Cos_Position_Flux->Cos *sin_rot;
    741          
    742              io->Ctrl_Specific->Load_Angle_Sin_Cos->Cos = load_angle_cos;
    743              io->Ctrl_Specific->Load_Angle_Sin_Cos->Sin = load_angle_sin;
    744          #if(OBS__LOAD_ANGLE_CALCULATION == ENABLED)  // avoid performing load angle calculation if not needed
    745                  *(io->Load_Angle) = MC_ATAN2_F((load_angle_cos), (load_angle_sin));
    746          #endif
    747          
    748          
    749          
    750              //******************************************************************//
    751              //                                                                  //
    752              //              Compute error for stability improvement             //
    753              //                                                                  //
    754              //******************************************************************//
    755              //This equation helps on steady state stability at low load (rs correction works fine)
    756              //However the term LdObs*curr_id introduced a big error_flux at starting which may cause failures
    757              Flux_Error  = stator_flux_d_forward - Lambda_d;
    758          
    759          
    760              // Save the previous rotor sine and cosine
    761              Sin_Rot_k1 = sin_rot;
    762              Cos_Rot_k1 = cos_rot;
    763          }
    764          
    765          
    766          
    767          
    768          
    769          #ifdef __IAR_SYSTEMS_ICC__
    770          #pragma inline = forced
    771          #endif
    772          /*==========================================================================*/
    773          /*                         Speed Calculation                                */
    774          /*==========================================================================*/
    775          void Speed_PLL_Calc()
    776          {
    777              Speed_PLL.in_alpha = Cos_Rot_k1;
    778              Speed_PLL.in_beta  = Sin_Rot_k1;
    779          
    780              PLL__fCalc(&Speed_PLL);
    781          }
    782          
    783          
    784          
    785          
    786          
    787          #ifdef __IAR_SYSTEMS_ICC__
    788          #pragma inline = forced
    789          #endif
    790          void PLL__fReset(XPLL_TYPE *XPLLVars)
    791          {
    792              XPLLVars->speed = 0.0f;
    793              XPLLVars->speed_old = 0.0f;
    794              XPLLVars->error = 0.0f;
    795              XPLLVars->error_old = 0.0f;
    796              XPLLVars->integral = 0.0f;
    797              XPLLVars->angle = 0.0f;
    798          
    799              XPLLVars->alpha = 0.0f;
    800              XPLLVars->beta = 0.0f;
    801              XPLLVars->in_alpha = 0.0f;
    802              XPLLVars->in_beta = 0.0f;
    803          }
    804          
    805          
    806          
    807          
    808          #ifdef __IAR_SYSTEMS_ICC__
    809          #pragma inline = forced
    810          #endif
    811          void PLL__fCalc(XPLL_TYPE *XPLLVars)
    812          {
    813              SIN_COS_F_TYPE sin_cos;
    814          
    815              MathCalc__SinCosF(XPLLVars->angle, &sin_cos);
    816          
    817              XPLLVars->alpha =  sin_cos.Cos;
    818              XPLLVars->beta  = -sin_cos.Sin;
    819          
    820              XPLLVars->error =  (XPLLVars->in_alpha * XPLLVars->beta) + (XPLLVars->in_beta * XPLLVars->alpha);
    821          
    822              XPLLVars->integral += (XPLLVars->error + XPLLVars->error_old) * (XPLLVars->ki);
    823              XPLLVars->error_old = XPLLVars->error;
    824              XPLLVars->speed = XPLLVars->integral + XPLLVars->error * XPLLVars->kp;
    825              XPLLVars->angle += (XPLLVars->speed + XPLLVars->speed_old) * XPLLVars->integ_k;
    826              XPLLVars->speed_old = XPLLVars->speed;
    827          
    828          #if(OBS__PLL_FILTERED_OMEGA == ENABLED)
    829          	// use integral + fraction of proportional as filtered speed
    830          #ifdef OBS__PLL_FILTERED_OMEGA_COEF
    831              XPLLVars->speed = XPLLVars->integral + OBS__PLL_FILTERED_OMEGA_COEF*XPLLVars->error * XPLLVars->kp; //add this line to reduce speed ripple;
    832          #else
    833              XPLLVars->speed = XPLLVars->integral;
    834          #endif
    835          #endif
    836          
    837              if(XPLLVars->angle > PI)
    838              {
    839                  XPLLVars->angle -= (2.0f * PI);
    840              }
    841          
    842              if(XPLLVars->angle < (-PI))
    843              {
    844                  XPLLVars->angle += (2.0f * PI);
    845              }
    846          }
    847          
    848          
    849          
    850          #ifdef __IAR_SYSTEMS_ICC__
    851          #pragma inline = forced
    852          #endif
    853          void Speed_Selector(MCL_OBSERVER_IO_F_TYPE *io, MCL_OBSERVER_PARAMS_TYPE *params)
                                                                                           ^
Remark[Pe826]: parameter "params" was never referenced
    854          {
    855              float32 temp_speed;
    856          
    857              //==========================================================================//
    858              //                       Low pass filter for speed                          //
    859              //==========================================================================//
    860              Obs_Speed_Rotor_Flux_sum = FILTERS__LOWPASSFILTER_F(Obs_Speed_Rotor_Flux_sum,OBS_SPEED_LPF_COEF,Obs_Speed_Rotor_Flux);
    861          
    862          
    863          
    864          
    865              if(io->Ctrl_Specific->flags.bit.pll_engaged == 1)
    866              {
    867                  // Read speed from the flux PLL
    868                  temp_speed = Speed_PLL.speed;
    869              }
    870              else
    871              {
    872                  temp_speed = Obs_Speed_Rotor_Flux_sum;
    873              }
    874          
    875          
    876              // Update the speed variables
    877              *(io->Speed_Rotor_Observed) = temp_speed;
    878              *(io->Ctrl_Specific->Speed_Rotor_Observed_Mech) = temp_speed * Pole_Pairs_Inv;
    879              *(io->Ctrl_Specific->Speed_Rotor_Observed_Mech_Abs) = MATHCALC__FABS(*(io->Ctrl_Specific->Speed_Rotor_Observed_Mech));
    880          }
    881          
    882          
    883          #ifdef __IAR_SYSTEMS_ICC__
    884          #pragma inline = forced
    885          #endif
    886          void Speed_Selector_Check(MCL_OBSERVER_IO_F_TYPE *io, MCL_OBSERVER_PARAMS_TYPE *params)
    887          {
    888              BOOL_TYPE speed_cond_1;
    889              BOOL_TYPE speed_cond_2;
    890              BOOL_TYPE speed_cond_3;
    891          
    892              float32 thr_speed;
    893          
    894              thr_speed = params->Curr_Resistance_Spd_Threshold * params->Pole_Pairs;
    895          
    896              speed_cond_1 = (BOOL_TYPE) (MATHCALC__FABS(Obs_Speed_Rotor_Flux_sum) > thr_speed);
    897              speed_cond_2 = (BOOL_TYPE) (MATHCALC__FABS(Obs_Speed_Rotor_Flux_sum-Speed_PLL.speed) < OBS__PLL_ENGAGE_ERROR_THR);
    898              speed_cond_3 = (BOOL_TYPE) (io->Ctrl_Specific->flags.bit.wrong_speed_direction == 0);
    899          
    900              // condition for speed commutation to pll
    901              if (io->Ctrl_Specific->flags.bit.pll_engaged == 0)
    902              {
    903                  if (speed_cond_1  && speed_cond_2 && speed_cond_3)
    904                  {
    905                      Speed_Transition_Counter++;
    906                  }
    907                  else
    908                  {
    909                      Speed_Transition_Counter = 0;
    910                  }
    911                  if( Speed_Transition_Counter > (params->Starting_Threshold))
    912                  {
    913                      io->Ctrl_Specific->flags.bit.pll_engaged = 1;
    914                      io->Ctrl_Specific->flags.bit.wait_pll_engagement = 0;
    915                  }
    916              }
    917              else
    918              {
    919                  if (speed_cond_1 == FALSE)
    920                  {
    921                      io->Ctrl_Specific->flags.bit.pll_engaged = 0;
    922                      io->Ctrl_Specific->flags.bit.wait_pll_engagement = 1;
    923                  }
    924              }
    925          
    926          
    927              if( *(io->Ctrl_Specific->Lowers_On) )
    928              {
    929                  // Rotor speed is being used when applying lowers on because since PLL gets lost.
    930                  io->Ctrl_Specific->flags.bit.pll_engaged = 0;
    931              }
    932          
    933          }
    934          
    935          
    936          //==========================================================================//
    937          //                       Torque estimator                                   //
    938          /*! Torque estimation is given by:
    939           * \f[
    940           * \begin{aligned}
    941           *      & \hat{T}_e = \hat{\lambda}_{s_{alpha}} * i_{beta} - \hat{\lambda}_{s_{beta}} * i_{alpha} \\
    942           * \end{aligned}
    943           * \f]
    944           */
    945          //==========================================================================//
    946          //uint8 EM_Torque_By_Flux = 1;
    947          #ifdef __IAR_SYSTEMS_ICC__
    948          #pragma inline = forced
    949          #endif
    950          void ElectroMagneticTorqueCalc(MCL_OBSERVER_IO_F_TYPE *io, MCL_OBSERVER_PARAMS_TYPE *params)
    951          {
    952              float32 tmp_1;
    953              float32 tmp_2;
    954          
    955              if(io->Ctrl_Specific->flags.bit.overflux_active == 0)
    956              {
    957              	EM_Torque = Stator_Lambda.Alpha * io->Is_Alpha_Beta->Beta - Stator_Lambda.Beta * io->Is_Alpha_Beta->Alpha;
    958              }
    959              else
    960              {
    961          		tmp_1  = *(io->Ctrl_Specific->Rotor_Flux) * Rotor_Curr_Iq;
    962          		tmp_2 = (Rotor_Curr_Iq*Rotor_Curr_Id);
    963          		EM_Torque = tmp_1 + ((io->Ctrl_Specific->Ldq_Ind->D - io->Ctrl_Specific->Ldq_Ind->Q)*tmp_2);
    964              }
    965          
    966              // Low pass filter the electromagnetic torque
    967              EM_Torque = 1.5f * params->Pole_Pairs * EM_Torque;
    968          
    969              EM_Torque_Filt_Sum = FILTERS__LOWPASSFILTER_F(EM_Torque_Filt_Sum, EM_TORQUE_LPF_COEF, EM_Torque);
    970              *(io->Ctrl_Specific->Torque) = EM_Torque_Filt_Sum;
    971          }
C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\Mcl\MacroBlocks\MclPwm.c
      1          /**
      2           *  @file
      3           *  @brief       Motor Control Loop Pwm.
      4           *  @details     This module implements the Pwm module.
      5           *  @author      alessio.beato/luigi.fagnano  (only temporary, since it is not integrated in MKS)
      6           *  $Header: FOC/Mcl.c 1.12 2015/11/25 18:36:02CET Luigi Fagnano (FAGNAL) Exp  $
      7           * @copyright Copyright 2012 - $Date: 2015/11/25 18:36:02CET $. Whirlpool Corporation. All rights reserved  CONFIDENTIAL
      8          */
      9          /*
     10           *
     11           *---------------------------------------------------------------------------------------------------------------------
     12           *---------------------------------------------------------------------------------------------------------------------
     13           */
     14          //-------------------------------------- Include Files ----------------------------------------------------------------
     15          
     16          #include "MclPwm.h"
     17          #include "MclConfig.h"
     18          //#include "InverterComp.h"
     19          #include "PwmModulation.h"
     20          #include "ClrkPark.h"
     21          #include "MclPwm_prv.h"
     22          
     23          
     24          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     25          
     26          
     27          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     28          // Inverter Compensation types
     29          #define INVERTER_LOSSES_COMP        0       // complete losses compensation
     30          #define DEADTIME_COMP               1       // deadtime compensation
     31          
     32          #define DUTY_INIT       0.5f
     33          
     34          #ifndef RPM_TO_RADS
     35              #define RPM_TO_RADS     0.10471975511965977461542144610932f
     36          #endif
     37          
     38          
     39          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
     40          
     41          //=====================================================================================================================
     42          //-------------------------------------- Public Functions -------------------------------------------------------------
     43          //=====================================================================================================================
     44          #define SPEED_THRESHOLD             (0.05f)         //!< [%] speed hysteresis threshold
     45          
     46          //INVERTER_COMP_TYPE Inverter_Dist_Pointer;
     47          //ALPHA_BETA_COOR_SYST_TYPE Inverter_Distortion_Voltage;
     48          float32 Speed_Threshold_High;                        //!< [absolute rpm] speed hysteresis high limits
     49          float32 Speed_Threshold_Low;                         //!< [absolute rpm] speed hysteresis low limits
     50          float32 Speed_Threshold;                             //!< [absolute rpm] speed hysteresis selector
     51          uint8 Inverter_Compensation_Selector;               //!< inverter compensation selector
     52          uint8 Pwm_Sector;                                   //!< Pwm sector calculation
     53          
     54          //---------------------------------------------------------------------------------------------------------------------
     55          /**
     56           *  @brief      Reset all Mcl Dq Reference Controllers quantities.
     57           *  @details    This routine reset all q Reference Controllers quantities, it has to be called at every time the pwm is switched off (motor stop or free down ramp).
     58           *
     59           *
     60           *  @param[in]     
     61           *  @param[out]
     62           *  @return        
     63           */

   \                                 In section .text, align 4, keep-with-next
     64          void MclPwm__ResetState(MCL_PWM_IO_F_TYPE *io, MCLPWM_JOINT_PARAMS_TYPE *params)
     65          {
     66              io->Vs_Alpha_Beta->Alpha = 0;
   \                     MclPwm__ResetState: (+1)
   \   00000000   0x6842             LDR      R2,[R0, #+4]
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x6053             STR      R3,[R2, #+4]
     67              io->Vs_Alpha_Beta->Beta = 0;
     68          
     69              io->Duty->A = DUTY_INIT;
   \   00000006   0xEEB6 0x0A00      VMOV.F32 S0,#0.5
   \   0000000A   0x6842             LDR      R2,[R0, #+4]
   \   0000000C   0x6093             STR      R3,[R2, #+8]
     70              io->Duty->B = DUTY_INIT;
     71              io->Duty->C = DUTY_INIT;
     72          
     73              Speed_Threshold_High = (params->PwmPrm->Speed_Threshold_InvComp) * (1.0f + SPEED_THRESHOLD) * RPM_TO_RADS;
   \   0000000E   0xED9F 0x....      VLDR.W   S2,??DataTable75  ;; 0x3f866666
   \   00000012   0x6902             LDR      R2,[R0, #+16]
   \   00000014   0xED82 0x0A00      VSTR     S0,[R2, #0]
     74              Speed_Threshold_Low  = (params->PwmPrm->Speed_Threshold_InvComp) * (1.0f - SPEED_THRESHOLD) * RPM_TO_RADS;
   \   00000018   0xEDDF 0x....      VLDR.W   S3,??DataTable75_1  ;; 0x3f733333
   \   0000001C   0x6902             LDR      R2,[R0, #+16]
   \   0000001E   0xED82 0x0A01      VSTR     S0,[R2, #+4]
   \   00000022   0x6900             LDR      R0,[R0, #+16]
   \   00000024   0xED80 0x0A02      VSTR     S0,[R0, #+8]
   \   00000028   0xED9F 0x....      VLDR.W   S0,??DataTable75_2  ;; 0x3dd67750
   \   0000002C   0x6808             LDR      R0,[R1, #+0]
   \   0000002E   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable92
   \   00000036   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   0000003A   0xF200 0x426C      ADDW     R2,R0,#+1132
   \   0000003E   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000042   0xEDC2 0x0A00      VSTR     S1,[R2, #0]
   \   00000046   0x6809             LDR      R1,[R1, #+0]
   \   00000048   0xED91 0x1A00      VLDR     S2,[R1, #0]
   \   0000004C   0xF200 0x4170      ADDW     R1,R0,#+1136
   \   00000050   0xEE21 0x1A21      VMUL.F32 S2,S2,S3
     75              Speed_Threshold = Speed_Threshold_High;
   \   00000054   0xF200 0x4074      ADDW     R0,R0,#+1140
   \   00000058   0xEE21 0x0A00      VMUL.F32 S0,S2,S0
   \   0000005C   0xED81 0x0A00      VSTR     S0,[R1, #0]
   \   00000060   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
     76          }
   \   00000064   0x4770             BX       LR               ;; return
     77          
     78          
     79          //---------------------------------------------------------------------------------------------------------------------
     80          /**
     81           *  @brief      Motor Control Loop initialization.
     82           *  @details    In this routine are called all initialization functions.
     83           *
     84           *
     85           *  @param[in]     
     86           *  @param[out]     
     87           *  @param[in]      
     88           *  @return
     89           */

   \                                 In section .text, align 2, keep-with-next
     90          void MclPwm__Initialize(MCLPWM_JOINT_PARAMS_TYPE* params)
     91          {
     92             // Inverter_Dist_Pointer.Is_ABC = io->Is_ABC;
     93             // Inverter_Dist_Pointer.Vdc = io->Vdc;
     94             // Inverter_Dist_Pointer.distortion = &Inverter_Distortion_Voltage;
     95          
     96              Inverter_Compensation_Selector = INVERTER_LOSSES_COMP;
   \                     MclPwm__Initialize: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable92
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xF881 0x235D      STRB     R2,[R1, #+861]
     97          
     98              params->PwmModulationPrm.ptr_LUT      = Dutycycle_By_Current_LUT;
   \   0000000A   0xF501 0x62B3      ADD      R2,R1,#+1432
   \   0000000E   0x6042             STR      R2,[R0, #+4]
     99              params->PwmModulationPrm.sizeof_lut   = &sizeof_inv_comp_lut;
   \   00000010   0xF201 0x72A4      ADDW     R2,R1,#+1956
   \   00000014   0x60C2             STR      R2,[R0, #+12]
    100              params->PwmModulationPrm.step_inv     = &step_inv_pwm_comp;
   \   00000016   0xF501 0x61F4      ADD      R1,R1,#+1952
   \   0000001A   0x6081             STR      R1,[R0, #+8]
    101          
    102          }
   \   0000001C   0x4770             BX       LR               ;; return
    103          
    104          
    105          
    106          //---------------------------------------------------------------------------------------------------------------------
    107          /**
    108           *  @brief     Pwm
    109           *  @details   Pwm:          DC voltage compensation
    110           *                           Deadtime compensation
    111           *                           PWM Duties generation
    112           *  @param[in]     
    113           *  @param[out]     
    114           *  @param[in]      
    115           *  @return        
    116           */

   \                                 In section .text, align 4, keep-with-next
    117          void MclPwm__RunningHandler(MCL_PWM_IO_F_TYPE *io, MCLPWM_JOINT_PARAMS_TYPE *params)
    118          {
   \                     MclPwm__RunningHandler: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x4602             MOV      R2,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
    119          	// space vector modulation (including ripple compensation)
    120          	Pwm_Sector = PwmModulation__SpaceVectorModulationF(*(io->Vdc), io->Vs_Alpha_Beta, io->Duty_bc, FALSE);
   \   00000006   0x6814             LDR      R4,[R2, #+0]
   \   00000008   0x6853             LDR      R3,[R2, #+4]
   \   0000000A   0xEDD4 0x0A00      VLDR     S1,[R4, #0]
   \   0000000E   0x68D0             LDR      R0,[R2, #+12]
   \   00000010   0xED93 0x1A02      VLDR     S2,[R3, #+8]
   \   00000014   0xED9F 0x....      VLDR.W   S0,??DataTable76  ;; 0x3fddb3d7
   \   00000018   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   0000001C   0xEDD3 0x0A01      VLDR     S1,[R3, #+4]
   \   00000020   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000024   0xEE21 0x0A00      VMUL.F32 S0,S2,S0
   \   00000028   0xEEB6 0x1A00      VMOV.F32 S2,#0.5
   \   0000002C   0xEE20 0x1A01      VMUL.F32 S2,S0,S2
   \   00000030   0xED9F 0x....      VLDR.W   S4,??DataTable76_1  ;; 0x3f5db3d7
   \   00000034   0xEEF0 0x1A41      VMOV.F32 S3,S2
   \   00000038   0xEE40 0x1A82      VMLA.F32 S3,S1,S4
   \   0000003C   0xED9F 0x....      VLDR.W   S4,??DataTable76_2  ;; 0xbf5db3d7
   \   00000040   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000044   0xEE00 0x1A82      VMLA.F32 S2,S1,S4
   \   00000048   0xEEF1 0xFA10      FMSTAT   
   \   0000004C   0xDB1C             BLT.N    ??MclPwm__RunningHandler_1
   \   0000004E   0xEEF5 0x1A40      VCMP.F32 S3,#0.0
   \   00000052   0xEEF1 0xFA10      FMSTAT   
   \   00000056   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   0000005A   0xDD0C             BLE.N    ??MclPwm__RunningHandler_2
   \   0000005C   0xEEF1 0xFA10      FMSTAT   
   \   00000060   0xD803             BHI.N    ??MclPwm__RunningHandler_3
   \   00000062   0x2301             MOVS     R3,#+1
   \   00000064   0xEEF1 0x0A41      VNEG.F32 S1,S2
   \   00000068   0xE029             B.N      ??MclPwm__RunningHandler_4
   \                     ??MclPwm__RunningHandler_3: (+1)
   \   0000006A   0x2302             MOVS     R3,#+2
   \   0000006C   0xEEF0 0x0A41      VMOV.F32 S1,S2
   \   00000070   0xEEB0 0x0A61      VMOV.F32 S0,S3
   \   00000074   0xE023             B.N      ??MclPwm__RunningHandler_4
   \                     ??MclPwm__RunningHandler_2: (+1)
   \   00000076   0xEEF1 0xFA10      FMSTAT   
   \   0000007A   0xDD15             BLE.N    ??MclPwm__RunningHandler_5
   \   0000007C   0xEEF0 0x0A40      VMOV.F32 S1,S0
   \   00000080   0x2303             MOVS     R3,#+3
   \   00000082   0xEEB1 0x0A61      VNEG.F32 S0,S3
   \   00000086   0xE01A             B.N      ??MclPwm__RunningHandler_4
   \                     ??MclPwm__RunningHandler_1: (+1)
   \   00000088   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   0000008C   0xEEF1 0xFA10      FMSTAT   
   \   00000090   0xDD05             BLE.N    ??MclPwm__RunningHandler_6
   \   00000092   0xEEF1 0x0A40      VNEG.F32 S1,S0
   \   00000096   0x2304             MOVS     R3,#+4
   \   00000098   0xEEB0 0x0A41      VMOV.F32 S0,S2
   \   0000009C   0xE00F             B.N      ??MclPwm__RunningHandler_4
   \                     ??MclPwm__RunningHandler_6: (+1)
   \   0000009E   0xEEF5 0x1A40      VCMP.F32 S3,#0.0
   \   000000A2   0xEEF1 0xFA10      FMSTAT   
   \   000000A6   0xDD05             BLE.N    ??MclPwm__RunningHandler_7
   \                     ??MclPwm__RunningHandler_5: (+1)
   \   000000A8   0x2306             MOVS     R3,#+6
   \   000000AA   0xEEF0 0x0A61      VMOV.F32 S1,S3
   \   000000AE   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   000000B2   0xE004             B.N      ??MclPwm__RunningHandler_4
   \                     ??MclPwm__RunningHandler_7: (+1)
   \   000000B4   0x2305             MOVS     R3,#+5
   \   000000B6   0xEEF1 0x0A61      VNEG.F32 S1,S3
   \   000000BA   0xEEB1 0x0A41      VNEG.F32 S0,S2
   \                     ??MclPwm__RunningHandler_4: (+1)
   \   000000BE   0xEE30 0x1A20      VADD.F32 S2,S0,S1
   \   000000C2   0xEDDF 0x....      VLDR.W   S3,??DataTable76_3  ;; 0x3f800001
   \   000000C6   0xEEB4 0x1A61      VCMP.F32 S2,S3
   \   000000CA   0xEEF1 0xFA10      FMSTAT   
   \   000000CE   0xDB06             BLT.N    ??MclPwm__RunningHandler_8
   \   000000D0   0xEE80 0x0A01      VDIV.F32 S0,S0,S2
   \   000000D4   0xEEF7 0x0A00      VMOV.F32 S1,#1.0
   \   000000D8   0xEE70 0x0AC0      VSUB.F32 S1,S1,S0
   \   000000DC   0xE00C             B.N      ??MclPwm__RunningHandler_9
   \                     ??MclPwm__RunningHandler_8: (+1)
   \   000000DE   0xEEF7 0x1A00      VMOV.F32 S3,#1.0
   \   000000E2   0xEE31 0x1AC1      VSUB.F32 S2,S3,S2
   \   000000E6   0xEEF6 0x1A00      VMOV.F32 S3,#0.5
   \   000000EA   0xEE21 0x1A21      VMUL.F32 S2,S2,S3
   \   000000EE   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   000000F2   0xEEF1 0xFA10      FMSTAT   
   \   000000F6   0xD501             BPL.N    ??MclPwm__RunningHandler_10
   \                     ??MclPwm__RunningHandler_9: (+1)
   \   000000F8   0xED9F 0x....      VLDR.W   S2,??DataTable76_4  ;; 0x0
   \                     ??MclPwm__RunningHandler_10: (+1)
   \   000000FC   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \   00000100   0xEDDF 0x....      VLDR.W   S3,??DataTable76_5  ;; 0x3f6b8520
   \   00000104   0xEEB4 0x0A61      VCMP.F32 S0,S3
   \   00000108   0xEE70 0x0A80      VADD.F32 S1,S1,S0
   \   0000010C   0xEEF1 0xFA10      FMSTAT   
   \   00000110   0xBFA8             IT       GE 
   \   00000112   0xED9F 0x....      VLDRGE.W S0,??DataTable76_6  ;; 0x3f6b851f
   \   00000116   0xEDDF 0x....      VLDR.W   S3,??DataTable76_7  ;; 0x3f70a3d8
   \   0000011A   0xEEF4 0x0A61      VCMP.F32 S1,S3
   \   0000011E   0xEEF1 0xFA10      FMSTAT   
   \   00000122   0xBFA8             IT       GE 
   \   00000124   0xEEF7 0x0A00      VMOVGE.F32 S1,#1.0
   \   00000128   0x1E5C             SUBS     R4,R3,#+1
   \   0000012A   0x2C05             CMP      R4,#+5
   \   0000012C   0xD82A             BHI.N    ??MclPwm__RunningHandler_11
   \   0000012E   0xE8DF 0xF004      TBB      [PC, R4]
   \                     ??MclPwm__RunningHandler_0:
   \   00000132   0x24 0x1F          DC8      0x24,0x1F,0x18,0x11
   \              0x18 0x11    
   \   00000136   0x0A 0x03          DC8      0xA,0x3
   \                     ??MclPwm__RunningHandler_12: (+1)
   \   00000138   0xEEB0 0x2A41      VMOV.F32 S4,S2
   \   0000013C   0xEEF0 0x1A60      VMOV.F32 S3,S1
   \   00000140   0xEEB0 0x1A40      VMOV.F32 S2,S0
   \   00000144   0xE024             B.N      ??MclPwm__RunningHandler_13
   \                     ??MclPwm__RunningHandler_14: (+1)
   \   00000146   0xEEB0 0x2A41      VMOV.F32 S4,S2
   \   0000014A   0xEEF0 0x1A40      VMOV.F32 S3,S0
   \   0000014E   0xEEB0 0x1A60      VMOV.F32 S2,S1
   \   00000152   0xE01D             B.N      ??MclPwm__RunningHandler_13
   \                     ??MclPwm__RunningHandler_15: (+1)
   \   00000154   0xEEF0 0x1A41      VMOV.F32 S3,S2
   \   00000158   0xEEB0 0x2A40      VMOV.F32 S4,S0
   \   0000015C   0xEEB0 0x1A60      VMOV.F32 S2,S1
   \   00000160   0xE016             B.N      ??MclPwm__RunningHandler_13
   \                     ??MclPwm__RunningHandler_16: (+1)
   \   00000162   0xEEF0 0x1A41      VMOV.F32 S3,S2
   \   00000166   0xEEB0 0x2A60      VMOV.F32 S4,S1
   \   0000016A   0xEEB0 0x1A40      VMOV.F32 S2,S0
   \   0000016E   0xE00F             B.N      ??MclPwm__RunningHandler_13
   \                     ??MclPwm__RunningHandler_17: (+1)
   \   00000170   0xEEF0 0x1A40      VMOV.F32 S3,S0
   \   00000174   0xEEB0 0x2A60      VMOV.F32 S4,S1
   \   00000178   0xE00A             B.N      ??MclPwm__RunningHandler_13
   \                     ??MclPwm__RunningHandler_18: (+1)
   \   0000017A   0xEEF0 0x1A60      VMOV.F32 S3,S1
   \   0000017E   0xEEB0 0x2A40      VMOV.F32 S4,S0
   \   00000182   0xE005             B.N      ??MclPwm__RunningHandler_13
   \                     ??MclPwm__RunningHandler_11: (+1)
   \   00000184   0xEDDF 0x....      VLDR.W   S3,??DataTable76_4  ;; 0x0
   \   00000188   0xED9F 0x....      VLDR.W   S4,??DataTable76_4  ;; 0x0
   \   0000018C   0xED9F 0x....      VLDR.W   S2,??DataTable76_4  ;; 0x0
   \                     ??MclPwm__RunningHandler_13: (+1)
   \   00000190   0xED80 0x1A02      VSTR     S2,[R0, #+8]
   \   00000194   0xED80 0x2A01      VSTR     S4,[R0, #+4]
   \   00000198   0xEDC0 0x1A00      VSTR     S3,[R0, #0]
   \   0000019C   0x.... 0x....      LDR.W    R4,??DataTable92
   \   000001A0   0xF884 0x335E      STRB     R3,[R4, #+862]
    121          
    122          	// This step is required since the voltage reconstruction uses the duties before compensation
    123          	io->Duty->A = io->Duty_bc->A;
   \   000001A4   0x68D3             LDR      R3,[R2, #+12]
   \   000001A6   0x6910             LDR      R0,[R2, #+16]
   \   000001A8   0x681B             LDR      R3,[R3, #+0]
   \   000001AA   0x6003             STR      R3,[R0, #+0]
    124          	io->Duty->B = io->Duty_bc->B;
   \   000001AC   0x68D3             LDR      R3,[R2, #+12]
   \   000001AE   0x6910             LDR      R0,[R2, #+16]
   \   000001B0   0x685B             LDR      R3,[R3, #+4]
   \   000001B2   0x6043             STR      R3,[R0, #+4]
    125          	io->Duty->C = io->Duty_bc->C;
   \   000001B4   0x68D3             LDR      R3,[R2, #+12]
   \   000001B6   0x6910             LDR      R0,[R2, #+16]
   \   000001B8   0x689B             LDR      R3,[R3, #+8]
   \   000001BA   0x6083             STR      R3,[R0, #+8]
    126          
    127             #ifndef COMPILE_4_SIMULINK
    128              #if (OBS__INVERTER_DISTORSION_COMPENSATION == DISABLED)
    129          	// inverter compensation strategy --> feedforward approach
    130          	if(Inverter_Compensation_Selector == INVERTER_LOSSES_COMP)
   \   000001BC   0x6890             LDR      R0,[R2, #+8]
   \   000001BE   0x6913             LDR      R3,[R2, #+16]
   \   000001C0   0xF894 0x235D      LDRB     R2,[R4, #+861]
   \   000001C4   0xB92A             CBNZ.N   R2,??MclPwm__RunningHandler_19
    131          	{
    132          		PwmModulation__InverterLossCompF(io->Is_ABC, io->Duty, &params->PwmModulationPrm);
   \   000001C6   0xB001             ADD      SP,SP,#+4
   \   000001C8   0x1D0A             ADDS     R2,R1,#+4
   \   000001CA   0xBC10             POP      {R4}
   \   000001CC   0x4619             MOV      R1,R3
   \   000001CE   0x.... 0x....      B.W      PwmModulation__InverterLossCompF
    133          	}
    134          	else
    135          	{
    136          		PwmModulation__DeadtimeCompensationGradientF(io->Is_ABC, io->Duty);
   \                     ??MclPwm__RunningHandler_19: (+1)
   \   000001D2   0xB001             ADD      SP,SP,#+4
   \   000001D4   0xBC10             POP      {R4}
   \   000001D6   0x4619             MOV      R1,R3
   \   000001D8   0x.... 0x....      B.W      PwmModulation__DeadtimeCompensationGradientF
    137          	}
    138              #endif
    139             #endif
    140          }
    141          

   \                                 In section .text, align 2, keep-with-next
    142          void MclPwm__25msHandler(MCL_PWM_IO_F_TYPE *io)
    143          {
    144              float32 temp_abs_speed;
    145          
    146              temp_abs_speed = *(io->Ctrl_Specific->Speed_Rotor_Observed_Mech_Abs);
   \                     MclPwm__25msHandler: (+1)
   \   00000000   0x6940             LDR      R0,[R0, #+20]
   \   00000002   0x6900             LDR      R0,[R0, #+16]
   \   00000004   0xED90 0x0A00      VLDR     S0,[R0, #0]
    147          
    148              if(temp_abs_speed >= Speed_Threshold)
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable92
   \   0000000C   0xF8D0 0x1474      LDR      R1,[R0, #+1140]
   \   00000010   0xEE00 0x1A90      VMOV     S1,R1
   \   00000014   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000018   0xEEF1 0xFA10      FMSTAT   
   \   0000001C   0xDB06             BLT.N    ??MclPwm__25msHandler_0
    149              {
    150                  Speed_Threshold = Speed_Threshold_Low;
   \   0000001E   0xF8D0 0x1470      LDR      R1,[R0, #+1136]
   \   00000022   0xF8C0 0x1474      STR      R1,[R0, #+1140]
    151          
    152                  Inverter_Compensation_Selector = DEADTIME_COMP;
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0xF880 0x135D      STRB     R1,[R0, #+861]
    153              }
    154              if(temp_abs_speed <= Speed_Threshold)
   \                     ??MclPwm__25msHandler_0: (+1)
   \   0000002C   0xF8D0 0x1474      LDR      R1,[R0, #+1140]
   \   00000030   0xEE00 0x1A90      VMOV     S1,R1
   \   00000034   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   00000038   0xEEF1 0xFA10      FMSTAT   
   \   0000003C   0xDB06             BLT.N    ??MclPwm__25msHandler_1
    155              {
    156                  Speed_Threshold = Speed_Threshold_High;
   \   0000003E   0xF8D0 0x146C      LDR      R1,[R0, #+1132]
   \   00000042   0xF8C0 0x1474      STR      R1,[R0, #+1140]
    157          
    158                  Inverter_Compensation_Selector = INVERTER_LOSSES_COMP;
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0xF880 0x135D      STRB     R1,[R0, #+861]
    159              }
    160          }
   \                     ??MclPwm__25msHandler_1: (+1)
   \   0000004C   0x4770             BX       LR               ;; return
    161          
    162          
    163          
    164          
    165          
    166          
C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\Mcl\MacroBlocks\MclSpeedCtrl.c
      1          /**
      2           *  @file
      3           *  @brief       Motor Control Loop Speed Controller .
      4           *  @details     This module implements the Speed Control module.
      5           *  @author      alessio.beato/luigi.fagnano  (only temporary, since it is not integrated in MKS)
      6           *  $Header: FOC/Mcl.c 1.12 2015/11/25 18:36:02CET Luigi Fagnano (FAGNAL) Exp  $
      7           * @copyright Copyright 2012 - $Date: 2015/11/25 18:36:02CET $. Whirlpool Corporation. All rights reserved  CONFIDENTIAL
      8          */
      9          /*
     10           *
     11           *---------------------------------------------------------------------------------------------------------------------
     12           *---------------------------------------------------------------------------------------------------------------------
     13           */
     14          //-------------------------------------- Include Files ----------------------------------------------------------------
     15          
     16          #include "MclSpeedCtrl.h"
     17          #include "MclConfig.h"
     18          #include "McMathCalc_macros.h"
     19          #include "Pi.h"
     20          #include "MathCalc.h"
     21          #include "Filters.h"
     22          #include "Braking.h"
     23          #include "Mci_prm.h"
     24          
     25          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     26          
     27          #ifndef RPM_TO_RADS
     28              #define RPM_TO_RADS     0.10471975511965977461542144610932f
     29          #endif
     30          
     31          
     32          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     33          PI_CONTROLLER_F_TYPE Speed_Controller;
     34          PI_CONTROLLER_F_TYPE Load_Angle_Limiter;
     35          
     36          #if SPEEDCTRL__TORQUE_LIM_OUTPUT_FILTER == ENABLED
     37          static float32 Max_Torque_Lim_Out_Sum;
     38          #endif
     39          #if (SPEEDCTRL__CURR_LIM_IDS_FILTER==ENABLED)
     40          static float32 Id_Stator_Current_Sum;
     41          #endif
     42          
     43          uint8 Forced_Gain_Selector;
     44          uint16 Forced_Gain_Timer;

   \                                 In section .bss, align 2
     45          uint16 Forced_Gain_Timeout;
   \                     Forced_Gain_Timeout:
   \   00000000                      DS8 2
     46          
     47          float32 My_Max_Torque;
     48          
     49          static float32 Torque_Max_Braking;
     50          
     51          float32 Delta_Speed_Rot_Ref;                         //!< [rad/s or rpm] Q17.15 - delta rotor speed to be added to the reference value
     52          uint16 Delta_Speed_Timer;                           //!< [x25 ms] timer to reset the delta speed when application does not use this feature
     53          
     54          static volatile float32 Max_Squared_Inv_Current_Appl;
     55          static volatile float32 Max_Design_Motor_Torque;
     56          static volatile float32 Max_Design_Motor_Torque_Appl;
     57          
     58          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
     59          
     60          
     61          //=====================================================================================================================
     62          //-------------------------------------- Public Functions -------------------------------------------------------------
     63          //=====================================================================================================================
     64          
     65          static float32 CurrentLimitation(MCL_SPEED_CTRL_IO_F_TYPE *io, MCL_SPEED_CTRL_PARAMS_TYPE *params);
     66          static float32 Calculate_MTPV(MCL_SPEED_CTRL_IO_F_TYPE *io, MCLSPEEDCTRL_JOINT_PARAMS_TYPE *params);
     67          void Speed_Gain_Scheduler(MCL_SPEED_CTRL_IO_F_TYPE *io, MCL_SPEED_CTRL_PARAMS_TYPE *params);
     68          void Delta_Speed_Handler(void);
     69          
     70          //---------------------------------------------------------------------------------------------------------------------
     71          /**
     72           *  @brief      Reset all Mcl Speed Controller quantities.
     73           *  @details    This routine reset all Speed Controller quantities, it has to be called at every time the pwm is switched off (motor stop or free down ramp).
     74           *
     75           *
     76           *  @param[in]     
     77           *  @param[Out]
     78           *  @return        
     79           */

   \                                 In section .text, align 2, keep-with-next
     80          void MclSpeedCtrl__ResetState(MCLSPEEDCTRL_JOINT_PARAMS_TYPE *params)
     81          {
     82              Speed_Controller.Kp = params->SpeedCtrlPrm->speed_gains_table[0].kp;
   \                     MclSpeedCtrl__ResetState: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable92
   \   00000006   0x69D2             LDR      R2,[R2, #+28]
   \   00000008   0xF8C1 0x22C4      STR      R2,[R1, #+708]
     83              Speed_Controller.Ki = params->SpeedCtrlPrm->speed_gains_table[0].ki;
   \   0000000C   0x6802             LDR      R2,[R0, #+0]
   \   0000000E   0x6A12             LDR      R2,[R2, #+32]
   \   00000010   0xF8C1 0x22C8      STR      R2,[R1, #+712]
     84          
     85              Speed_Controller.Out        = 0.0f;
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xF8C1 0x22C0      STR      R2,[R1, #+704]
     86              Speed_Controller.Integ_K_1  = 0.0f;
   \   0000001A   0xF8C1 0x22BC      STR      R2,[R1, #+700]
     87          
     88              Load_Angle_Limiter.Upper_Limit = params->SpeedCtrlPrm->Max_Design_Motor_Torque;
   \   0000001E   0x6802             LDR      R2,[R0, #+0]
   \   00000020   0x6852             LDR      R2,[R2, #+4]
   \   00000022   0xF8C1 0x22E8      STR      R2,[R1, #+744]
     89          
     90              Load_Angle_Limiter.Out = 0.0f;
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0xF8C1 0x22DC      STR      R2,[R1, #+732]
     91              // init integral term to saturation
     92              Load_Angle_Limiter.Integ_K_1 = Load_Angle_Limiter.Upper_Limit;
   \   0000002C   0xF8D1 0x22E8      LDR      R2,[R1, #+744]
   \   00000030   0xF8C1 0x22D8      STR      R2,[R1, #+728]
     93              
     94          
     95              //initialize the torque limitation filter
     96          
     97          #if SPEEDCTRL__TORQUE_LIM_OUTPUT_FILTER == ENABLED
     98              Max_Torque_Lim_Out_Sum = params->SpeedCtrlPrm->Max_Design_Motor_Torque;
     99          #endif
    100          
    101          #if (SPEEDCTRL__CURR_LIM_IDS_FILTER==ENABLED)
    102              Id_Stator_Current_Sum = 0.0f;
    103          #endif
    104          
    105          
    106              Delta_Speed_Rot_Ref = 0.0f;
   \   00000034   0x2200             MOVS     R2,#+0
   \   00000036   0xF8C1 0x2480      STR      R2,[R1, #+1152]
    107          
    108              Max_Design_Motor_Torque		    = params->SpeedCtrlPrm->Max_Design_Motor_Torque;
   \   0000003A   0x6802             LDR      R2,[R0, #+0]
   \   0000003C   0x6852             LDR      R2,[R2, #+4]
   \   0000003E   0xF8C1 0x2488      STR      R2,[R1, #+1160]
    109              Max_Design_Motor_Torque_Appl    = params->SpeedCtrlPrm->Max_Design_Motor_Torque;
   \   00000042   0x6802             LDR      R2,[R0, #+0]
   \   00000044   0x6852             LDR      R2,[R2, #+4]
   \   00000046   0xF8C1 0x248C      STR      R2,[R1, #+1164]
    110              Max_Squared_Inv_Current_Appl 	= params->SpeedCtrlPrm->Max_Squared_Inv_Current;
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0xF8C1 0x0484      STR      R0,[R1, #+1156]
    111          
    112              Forced_Gain_Selector = 0;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xF881 0x035F      STRB     R0,[R1, #+863]
    113              Forced_Gain_Timer = 0;
   \   00000058   0xF8A1 0x0384      STRH     R0,[R1, #+900]
    114          }
   \   0000005C   0x4770             BX       LR               ;; return
    115          
    116          
    117          //---------------------------------------------------------------------------------------------------------------------
    118          /**
    119           *  @brief      Motor Control Loop initialization.
    120           *  @details    In this routine are called all initialization functions.
    121           *
    122           *
    123           *  @param[in]     
    124           *  @param[Out]
    125           *  @param[in]      
    126           *  @return        
    127           */
    128          float32 My_Torque_Gain;

   \                                 In section .text, align 2, keep-with-next
    129          void MclSpeedCtrl__Initialize(MCLSPEEDCTRL_JOINT_PARAMS_TYPE* params)
    130          {
    131          
    132              Load_Angle_Limiter.Kp = params->SpeedCtrlPrm->load_angle.Kp;
   \                     MclSpeedCtrl__Initialize: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable96
   \   00000006   0x6952             LDR      R2,[R2, #+20]
   \   00000008   0xF8C1 0x22E0      STR      R2,[R1, #+736]
    133              Load_Angle_Limiter.Ki = params->SpeedCtrlPrm->load_angle.Ki;
   \   0000000C   0x6802             LDR      R2,[R0, #+0]
   \   0000000E   0x6992             LDR      R2,[R2, #+24]
   \   00000010   0xF8C1 0x22E4      STR      R2,[R1, #+740]
    134              Load_Angle_Limiter.Lower_Limit = 0.0f;
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xF8C1 0x22EC      STR      R2,[R1, #+748]
    135          
    136              // reset MCL quantities
    137              MclSpeedCtrl__ResetState(params);
   \   0000001A   0x6802             LDR      R2,[R0, #+0]
   \   0000001C   0x69D2             LDR      R2,[R2, #+28]
   \   0000001E   0xF8C1 0x22C4      STR      R2,[R1, #+708]
   \   00000022   0x6802             LDR      R2,[R0, #+0]
   \   00000024   0x6A12             LDR      R2,[R2, #+32]
   \   00000026   0xF8C1 0x22C8      STR      R2,[R1, #+712]
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0xF8C1 0x22C0      STR      R2,[R1, #+704]
   \   00000030   0xF8C1 0x22BC      STR      R2,[R1, #+700]
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0x6852             LDR      R2,[R2, #+4]
   \   00000038   0xF8C1 0x22E8      STR      R2,[R1, #+744]
   \   0000003C   0x2200             MOVS     R2,#+0
   \   0000003E   0xF8C1 0x22DC      STR      R2,[R1, #+732]
   \   00000042   0xF8D1 0x22E8      LDR      R2,[R1, #+744]
   \   00000046   0xF8C1 0x22D8      STR      R2,[R1, #+728]
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0xF8C1 0x2480      STR      R2,[R1, #+1152]
   \   00000050   0x6802             LDR      R2,[R0, #+0]
   \   00000052   0x6852             LDR      R2,[R2, #+4]
   \   00000054   0xF8C1 0x2488      STR      R2,[R1, #+1160]
   \   00000058   0x6802             LDR      R2,[R0, #+0]
   \   0000005A   0x6852             LDR      R2,[R2, #+4]
   \   0000005C   0xF8C1 0x248C      STR      R2,[R1, #+1164]
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0xF8C1 0x0484      STR      R0,[R1, #+1156]
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xF881 0x035F      STRB     R0,[R1, #+863]
   \   0000006E   0xF8A1 0x0384      STRH     R0,[R1, #+900]
    138          
    139              My_Torque_Gain = 1.0f;
   \   00000072   0xF04F 0x507E      MOV      R0,#+1065353216
   \   00000076   0xF8C1 0x0490      STR      R0,[R1, #+1168]
    140          }
   \   0000007A   0x4770             BX       LR               ;; return
    141          
    142          
    143          
    144          //---------------------------------------------------------------------------------------------------------------------
    145          /**
    146           *  @brief     Speed Controller
    147           *  @details   Speed Controller: speed PI execution
    148           *                              torque reference generation
    149           *  @param[in]     
    150           *  @param[Out]
    151           *  @param[in]      
    152           *  @return        
    153           */
    154          uint8 My_TqLim_Flag;

   \                                 In section .text, align 4, keep-with-next
    155          void MclSpeedCtrl__RunningHandler(MCL_SPEED_CTRL_IO_F_TYPE *io, MCLSPEEDCTRL_JOINT_PARAMS_TYPE *params)
    156          {
   \                     MclSpeedCtrl__RunningHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xED2D 0x8B02      VPUSH    {D8}
   \   00000008   0x460D             MOV      R5,R1
    157              float32 max_torque_voltage;
    158              float32 max_torque;
    159              float32 max_torque_curr_limit;
    160          
    161          
    162          #if (SPEEDCTRL__START_TORQUE_LIM  == ENABLED)
    163              if( (*io->Ctrl_Specific->Elapsed_Time_After_Starting) <= (params->SpeedCtrlPrm->Max_Starting_Torque_Time) )
    164              {
    165                  max_torque = params->SpeedCtrlPrm->Max_Starting_Torque;
    166          
    167              }
    168              else
    169          #else
    170              {
    171          
    172                  // Current limitation - max inverter current
    173                  max_torque_curr_limit = CurrentLimitation(io, params->SpeedCtrlPrm);
   \   0000000A   0x68E1             LDR      R1,[R4, #+12]
   \   0000000C   0x6828             LDR      R0,[R5, #+0]
   \   0000000E   0x69CA             LDR      R2,[R1, #+28]
   \   00000010   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000014   0xED92 0x0A00      VLDR     S0,[R2, #0]
   \   00000018   0xEE40 0x0A40      VMLS.F32 S1,S0,S0
   \   0000001C   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   00000020   0xEEF1 0xFA10      FMSTAT   
   \   00000024   0xDD13             BLE.N    ??MclSpeedCtrl__RunningHandler_0
   \   00000026   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   0000002A   0xEEF1 0xFA10      FMSTAT   
   \   0000002E   0xDB02             BLT.N    ??MclSpeedCtrl__RunningHandler_1
   \   00000030   0xEEB1 0x0AE0      VSQRT.F32 S0,S1
   \   00000034   0xE001             B.N      ??MclSpeedCtrl__RunningHandler_2
   \                     ??MclSpeedCtrl__RunningHandler_1: (+1)
   \   00000036   0xED9F 0x....      VLDR.W   S0,??DataTable82  ;; 0x0
   \                     ??MclSpeedCtrl__RunningHandler_2: (+1)
   \   0000003A   0x6B8A             LDR      R2,[R1, #+56]
   \   0000003C   0xEDD2 0x0A00      VLDR     S1,[R2, #0]
   \   00000040   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000044   0xEDD0 0x0A19      VLDR     S1,[R0, #+100]
   \   00000048   0xEE20 0x8A20      VMUL.F32 S16,S0,S1
   \   0000004C   0xE001             B.N      ??MclSpeedCtrl__RunningHandler_3
   \                     ??MclSpeedCtrl__RunningHandler_0: (+1)
   \   0000004E   0xED9F 0x....      VLDR.W   S16,??DataTable82  ;; 0x0
    174          
    175                  max_torque_voltage = Calculate_MTPV(io, params);
   \                     ??MclSpeedCtrl__RunningHandler_3: (+1)
   \   00000052   0x6B49             LDR      R1,[R1, #+52]
   \   00000054   0xED91 0x0A00      VLDR     S0,[R1, #0]
   \   00000058   0x1D28             ADDS     R0,R5,#+4
   \   0000005A   0x.... 0x....      BL       MathCalc__GetInterpolationFastF
    176          
    177                  max_torque = MATHCALC__SATURATE_DIRECT(0, max_torque_curr_limit, Max_Design_Motor_Torque_Appl);  // Interfacing with Application Layer
   \   0000005E   0x.... 0x....      LDR.W    R6,??DataTable92
   \   00000062   0xF8D6 0x048C      LDR      R0,[R6, #+1164]
   \   00000066   0xEEF0 0x8A40      VMOV.F32 S17,S0
   \   0000006A   0xEE00 0x0A10      VMOV     S0,R0
   \   0000006E   0xEEB4 0x8A40      VCMP.F32 S16,S0
   \   00000072   0xEEF1 0xFA10      FMSTAT   
   \   00000076   0xDB04             BLT.N    ??MclSpeedCtrl__RunningHandler_4
   \   00000078   0xF8D6 0x048C      LDR      R0,[R6, #+1164]
   \   0000007C   0xEE08 0x0A10      VMOV     S16,R0
   \   00000080   0xE006             B.N      ??MclSpeedCtrl__RunningHandler_5
   \                     ??MclSpeedCtrl__RunningHandler_4: (+1)
   \   00000082   0xEEB5 0x8A40      VCMP.F32 S16,#0.0
   \   00000086   0xEEF1 0xFA10      FMSTAT   
   \   0000008A   0xBF98             IT       LS 
   \   0000008C   0xED9F 0x....      VLDRLS.W S16,??DataTable82  ;; 0x0
    178          
    179                  // saturate
    180                  max_torque = MATHCALC__SATURATE_DIRECT(0, max_torque, max_torque_voltage);
   \                     ??MclSpeedCtrl__RunningHandler_5: (+1)
   \   00000090   0xEEB4 0x8A68      VCMP.F32 S16,S17
   \   00000094   0xEEF1 0xFA10      FMSTAT   
   \   00000098   0xBFA8             IT       GE 
   \   0000009A   0xEEB0 0x8A68      VMOVGE.F32 S16,S17
   \   0000009E   0xDA06             BGE.N    ??MclSpeedCtrl__RunningHandler_6
   \   000000A0   0xEEB5 0x8A40      VCMP.F32 S16,#0.0
   \   000000A4   0xEEF1 0xFA10      FMSTAT   
   \   000000A8   0xBF98             IT       LS 
   \   000000AA   0xED9F 0x....      VLDRLS.W S16,??DataTable82  ;; 0x0
    181          
    182                  //==========================================================================//
    183                  //                                  Load Angle Limiter                      //
    184                  //==========================================================================//
    185                   Load_Angle_Limiter.Upper_Limit = max_torque;
   \                     ??MclSpeedCtrl__RunningHandler_6: (+1)
   \   000000AE   0xED86 0x8ABA      VSTR     S16,[R6, #+744]
    186                   Load_Angle_Limiter.Err  = io->Ctrl_Specific->Load_Angle_Sin_Cos->Cos - params->SpeedCtrlPrm->load_angle.Max_Cos;
   \   000000B2   0x68E0             LDR      R0,[R4, #+12]
   \   000000B4   0x6C00             LDR      R0,[R0, #+64]
   \   000000B6   0xED90 0x0A01      VLDR     S0,[R0, #+4]
   \   000000BA   0x6828             LDR      R0,[R5, #+0]
   \   000000BC   0xEDD0 0x0A04      VLDR     S1,[R0, #+16]
   \   000000C0   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   000000C4   0xED86 0x0AB5      VSTR     S0,[R6, #+724]
    187          
    188                   Pi__CalcPiF(&Load_Angle_Limiter);
   \   000000C8   0xF506 0x7035      ADD      R0,R6,#+724
   \   000000CC   0x.... 0x....      BL       Pi__CalcPiF
    189          
    190                   max_torque = Load_Angle_Limiter.Out;
    191          
    192              }
    193          #endif
    194          
    195          
    196          
    197          #if (SPEEDCTRL__TORQUE_LIM_OUTPUT_FILTER==ENABLED)
    198              // Filtering ...
    199              Max_Torque_Lim_Out_Sum = FILTERS__LOWPASSFILTER_F(Max_Torque_Lim_Out_Sum, MAX_TORQUE_LIM_OUT_LPF_COEF, max_torque);
    200              max_torque = Max_Torque_Lim_Out_Sum;
    201          #endif
    202          
    203              max_torque = My_Torque_Gain * max_torque;
   \   000000D0   0xF8D6 0x0490      LDR      R0,[R6, #+1168]
   \   000000D4   0xEDD6 0x0AB7      VLDR     S1,[R6, #+732]
   \   000000D8   0xEE00 0x0A10      VMOV     S0,R0
   \   000000DC   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
    204          
    205              if(max_torque_voltage > max_torque)
   \   000000E0   0xEEB4 0x0A68      VCMP.F32 S0,S17
   \   000000E4   0xEEF1 0xFA10      FMSTAT   
   \   000000E8   0xBF4C             ITE      MI 
    206              {
    207              	My_TqLim_Flag = 1;
   \   000000EA   0x2001             MOVMI    R0,#+1
    208              }
    209              else
    210              {
    211              	My_TqLim_Flag = 0;
   \   000000EC   0x2000             MOVPL    R0,#+0
   \   000000EE   0xF886 0x0360      STRB     R0,[R6, #+864]
    212              }
    213          
    214              My_Max_Torque = max_torque;     // Debug Only
   \   000000F2   0xF206 0x4078      ADDW     R0,R6,#+1144
   \   000000F6   0xED80 0x0A00      VSTR     S0,[R0, #0]
    215          
    216          
    217          
    218              *(io->Speed_Rot_Ref)  = *(io->Speed_Rot_Ref) + Delta_Speed_Rot_Ref;
   \   000000FA   0x6820             LDR      R0,[R4, #+0]
   \   000000FC   0xF8D6 0x1480      LDR      R1,[R6, #+1152]
   \   00000100   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000104   0xEE01 0x1A10      VMOV     S2,R1
   \   00000108   0xEE70 0x0A81      VADD.F32 S1,S1,S2
   \   0000010C   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
    219              Speed_Controller.Err  = *(io->Speed_Rot_Ref) - *(io->Speed_Rot);
   \   00000110   0x6820             LDR      R0,[R4, #+0]
   \   00000112   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000116   0x6860             LDR      R0,[R4, #+4]
   \   00000118   0xED90 0x1A00      VLDR     S2,[R0, #0]
   \   0000011C   0xEE70 0x0AC1      VSUB.F32 S1,S1,S2
   \   00000120   0xEDC6 0x0AAE      VSTR     S1,[R6, #+696]
    220          
    221              // Update Speed controller limits (according to motor direction)
    222              if(io->Ctrl_Specific->flags.bit.motor_direction > 0)
   \   00000124   0x68E0             LDR      R0,[R4, #+12]
   \   00000126   0x6800             LDR      R0,[R0, #+0]
   \   00000128   0xF3C0 0x2000      UBFX     R0,R0,#+8,#+1
   \   0000012C   0x2801             CMP      R0,#+1
   \   0000012E   0xDB06             BLT.N    ??MclSpeedCtrl__RunningHandler_7
    223              {   // positive direction
    224                  Speed_Controller.Upper_Limit = max_torque;
    225                  Speed_Controller.Lower_Limit = -Torque_Max_Braking;
   \   00000130   0xF8D6 0x047C      LDR      R0,[R6, #+1148]
   \   00000134   0xED86 0x0AB3      VSTR     S0,[R6, #+716]
   \   00000138   0xEE00 0x0A10      VMOV     S0,R0
   \   0000013C   0xE003             B.N      ??MclSpeedCtrl__RunningHandler_8
    226              }
    227              else
    228              {   // negative direction
    229                  Speed_Controller.Upper_Limit = Torque_Max_Braking;
   \                     ??MclSpeedCtrl__RunningHandler_7: (+1)
   \   0000013E   0xF8D6 0x047C      LDR      R0,[R6, #+1148]
   \   00000142   0xF8C6 0x02CC      STR      R0,[R6, #+716]
    230                  Speed_Controller.Lower_Limit = -max_torque;
   \                     ??MclSpeedCtrl__RunningHandler_8: (+1)
   \   00000146   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   0000014A   0xED86 0x0AB4      VSTR     S0,[R6, #+720]
    231              }
    232              
    233              Pi__CalcPiF(&Speed_Controller);
   \   0000014E   0xF506 0x702E      ADD      R0,R6,#+696
   \   00000152   0x.... 0x....      BL       Pi__CalcPiF
    234              *(io->Torque_Ref)  = Speed_Controller.Out;
   \   00000156   0x68A0             LDR      R0,[R4, #+8]
   \   00000158   0xF8D6 0x12C0      LDR      R1,[R6, #+704]
   \   0000015C   0x6001             STR      R1,[R0, #+0]
    235          
    236          
    237          }
   \   0000015E   0xECBD 0x8B02      VPOP     {D8}
   \   00000162   0xBD70             POP      {R4-R6,PC}       ;; return
    238          
    239          

   \                                 In section .text, align 2, keep-with-next
    240          void MclSpeedCtrl__1msHandler(MCL_SPEED_CTRL_IO_F_TYPE *io, MCLSPEEDCTRL_JOINT_PARAMS_TYPE* params)
    241          {
   \                     MclSpeedCtrl__1msHandler: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    242              //==========================================================================//
    243              //                                  Braking                                 //
    244              //        Calculating maximum torque according to braking requirement       //
    245              //==========================================================================//
    246              Torque_Max_Braking = Braking__SpeedCtrlHandler(io, params->SpeedCtrlPrm);
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x.... 0x....      BL       Braking__SpeedCtrlHandler
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable96_1
   \   0000000E   0xED80 0x0A00      VSTR     S0,[R0, #0]
    247          }
   \   00000012   0xB001             ADD      SP,SP,#+4
   \   00000014   0xBD00             POP      {PC}             ;; return
    248          
    249          
    250          

   \                                 In section .text, align 2, keep-with-next
    251          void MclSpeedCtrl__25msHandler(MCL_SPEED_CTRL_IO_F_TYPE *io, MCLSPEEDCTRL_JOINT_PARAMS_TYPE* params)
    252          {
   \                     MclSpeedCtrl__25msHandler: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    253          
    254              Speed_Gain_Scheduler(io, params->SpeedCtrlPrm);
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x.... 0x....      BL       Speed_Gain_Scheduler
    255          
    256              Delta_Speed_Handler();
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable96
   \   0000000E   0xF8B0 0x1386      LDRH     R1,[R0, #+902]
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xBF1A             ITTE     NE 
   \   00000016   0x1E49             SUBNE    R1,R1,#+1
   \   00000018   0xF8A0 0x1386      STRHNE   R1,[R0, #+902]
   \   0000001C   0xF8C0 0x1480      STREQ    R1,[R0, #+1152]
    257          
    258          }
   \   00000020   0xB001             ADD      SP,SP,#+4
   \   00000022   0xBD00             POP      {PC}             ;; return
    259          
    260          
    261          
    262          //---------------------------------------------------------------------------------------------------------------------
    263          /**
    264           *  @brief      Set speed controller limitation.
    265           *  @details
    266           *
    267           * @return  TRUE - value accepted
    268           *          FALSE - value denied - default answer.
    269           */
    270          

   \                                 In section .text, align 2, keep-with-next
    271          BOOL_TYPE MclSpeedCtrl__SetSpeedRegLimit(sint32  value)
    272          {
   \                     MclSpeedCtrl__SetSpeedRegLimit: (+1)
   \   00000000   0xEE00 0x0A10      VMOV     S0,R0
    273          	BOOL_TYPE value_accepted;
    274          	float32 value_f;
    275          	value_f = (float32) value / 65536.0f;
   \   00000004   0xEEBA 0x0AC8      VCVT.F32.S32 S0,S0,#+16
    276          	if ((value_f <= 0)||(value_f > Max_Design_Motor_Torque))
   \   00000008   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable96
   \   00000010   0xEEF1 0xFA10      FMSTAT   
   \   00000014   0xD908             BLS.N    ??MclSpeedCtrl__SetSpeedRegLimit_0
   \   00000016   0xF8D0 0x1488      LDR      R1,[R0, #+1160]
   \   0000001A   0xEE00 0x1A90      VMOV     S1,R1
   \   0000001E   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   00000022   0xEEF1 0xFA10      FMSTAT   
   \   00000026   0xD505             BPL.N    ??MclSpeedCtrl__SetSpeedRegLimit_1
    277          	{
    278          		Max_Design_Motor_Torque_Appl = Max_Design_Motor_Torque;
   \                     ??MclSpeedCtrl__SetSpeedRegLimit_0: (+1)
   \   00000028   0xF8D0 0x1488      LDR      R1,[R0, #+1160]
   \   0000002C   0xF8C0 0x148C      STR      R1,[R0, #+1164]
    279          	}
    280          	else
    281          	{
    282          		Max_Design_Motor_Torque_Appl = value_f;
    283          	}
    284          
    285          	value_accepted = TRUE;
    286          
    287          	return(value_accepted);
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x4770             BX       LR
   \                     ??MclSpeedCtrl__SetSpeedRegLimit_1: (+1)
   \   00000034   0xF200 0x408C      ADDW     R0,R0,#+1164
   \   00000038   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x4770             BX       LR               ;; return
    288          }
    289          
    290          
    291          
    292          #ifdef __IAR_SYSTEMS_ICC__
    293          #pragma inline = forced
    294          #endif
    295          float32 CurrentLimitation(MCL_SPEED_CTRL_IO_F_TYPE *io, MCL_SPEED_CTRL_PARAMS_TYPE *params)
    296          {
    297              float32 max_torque_curr_limit;
    298              float32 temp_1;
    299              float32 temp_2;
    300          
    301          
    302              // Limit the maximum torque according to the available current and maximum current of the inverter
    303              temp_1 = params->Max_Squared_Inv_Current;
    304          
    305              temp_2 = *(io->Ctrl_Specific->Id_stator_current);
    306          
    307          #if (SPEEDCTRL__CURR_LIM_IDS_FILTER==ENABLED)
    308              // Filtering ...
    309              Id_Stator_Current_Sum = FILTERS__LOWPASSFILTER_F(Id_Stator_Current_Sum, CURR_LIM_IDS_LPF_COEF, temp_2);
    310              temp_2 = Id_Stator_Current_Sum;
    311          #endif
    312          
    313              temp_2 = (temp_2*temp_2);
    314          
    315              // (Max inverter current)^2 - (Id)^2
    316              temp_1 = temp_1 - temp_2;
    317          
    318              if (temp_1>0)
    319              {
    320                  // Max current = sqrt((Max inverter current)^2 - (Id)^2)
    321                  temp_1 = MC_SQRT_F(temp_1);
    322          
    323                  // Max torque according to available current
    324          		max_torque_curr_limit = params->pole_pairs_factor * (temp_1 * *(io->Ctrl_Specific->Stator_Flux_Mag));
    325          		 
    326              }
    327              else
    328              {
    329                  max_torque_curr_limit = 0.0f;
    330              }
    331          
    332              return max_torque_curr_limit;
    333          }
    334          
    335          
    336          #ifdef __IAR_SYSTEMS_ICC__
    337          #pragma inline = forced
    338          #endif
    339          float32 Calculate_MTPV(MCL_SPEED_CTRL_IO_F_TYPE *io, MCLSPEEDCTRL_JOINT_PARAMS_TYPE *params)
    340          {
    341              float32 max_torque_voltage;
    342              float32 temp_1;
    343          
    344              temp_1 = * io->Ctrl_Specific->Flux_Limit_By_Speed;
    345              max_torque_voltage = MathCalc__GetInterpolationFastF(temp_1, &params->MTPVPrm);
    346          
    347              return(max_torque_voltage);
    348          }
    349          
    350          
    351          
    352          

   \                                 In section .text, align 4, keep-with-next
    353          void Speed_Gain_Scheduler(MCL_SPEED_CTRL_IO_F_TYPE *io, MCL_SPEED_CTRL_PARAMS_TYPE *params)
    354          {
   \                     Speed_Gain_Scheduler: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    355          
    356              static sint32 gains_indexer_previous;
    357              static sint32 gains_indexer;
    358              static sint16 relative_time;
    359              float32 temp_speed_table;
    360              float32 speed_rotor_abs;
    361              float32 delta;
    362              float32 temp_speed_kp;
    363              float32 temp_speed_ki;
    364          
    365          	// If there is no timeout, e.g., application is polling the gains set
    366              if(Forced_Gain_Timer)
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable92
   \   00000006   0xF8B2 0x3384      LDRH     R3,[R2, #+900]
   \   0000000A   0xB173             CBZ.N    R3,??Speed_Gain_Scheduler_0
    367              {
    368                  Forced_Gain_Timer--;
   \   0000000C   0x1E58             SUBS     R0,R3,#+1
   \   0000000E   0xF8A2 0x0384      STRH     R0,[R2, #+900]
    369          
    370                  Speed_Controller.Kp = params->speed_gains_table[Forced_Gain_Selector].kp;
   \   00000012   0xF892 0x035F      LDRB     R0,[R2, #+863]
   \   00000016   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \   0000001A   0x69C1             LDR      R1,[R0, #+28]
   \   0000001C   0xF8C2 0x12C4      STR      R1,[R2, #+708]
    371                  Speed_Controller.Ki = params->speed_gains_table[Forced_Gain_Selector].ki;
   \   00000020   0x6A00             LDR      R0,[R0, #+32]
   \   00000022   0xF8C2 0x02C8      STR      R0,[R2, #+712]
    372              }
    373              else
    374              {
    375                  //// During starting, use default gains.
    376                  if( (*io->Ctrl_Specific->Elapsed_Time_After_Starting) <= (uint32)(params->Force_Default_Gains_Time) )
    377                  {
    378                      Speed_Controller.Kp = params->speed_gains_table[0].kp;
    379                      Speed_Controller.Ki = params->speed_gains_table[0].ki;
    380          
    381                      // Initialize the variable, since it is starting now...
    382                      gains_indexer_previous = 0;
    383                      gains_indexer = 0;
    384                      relative_time = 0;
    385                  }
    386                  else // Starting time is already over, so, look for new regions
    387                  {
    388                      // Look for new index only if the transition between regions is already done.
    389                      if(gains_indexer == gains_indexer_previous)
    390                      {
    391                          // Save the speed on stack
    392                          speed_rotor_abs = *(io->Ctrl_Specific->Speed_Rot_Ref_Abs);//*(io->Speed_Rot_Absolute);
    393          
    394                          // Look for the indexer
    395                          for(gains_indexer = 0; gains_indexer < SPEEDCTRL__SPEED_REGIONS; gains_indexer++)
    396                          {
    397                              // Only one indexed reading is performed
    398                              temp_speed_table = (params->speed_gains_table[gains_indexer].speed_abs) * RPM_TO_RADS;
    399          
    400                              if(temp_speed_table > 0)
    401                              {
    402                                  if( speed_rotor_abs < temp_speed_table )
    403                                  {
    404                                      break;
    405                                  }
    406                              }
    407                              else
    408                              {
    409                                  break;
    410                              }
    411                          }
    412          
    413                          relative_time = 0;
    414                      }
    415                      else //if(gains_indexer != gains_indexer_previous)
    416                      {
    417                          relative_time++;
    418          
    419                          // Calculate flux gains - kp
    420                          delta = (params->speed_gains_table[gains_indexer].kp) - (params->speed_gains_table[gains_indexer_previous].kp);
    421                          delta = delta*relative_time;
    422                          delta = delta/(params->speed_gains_table[gains_indexer].transition_time);
    423                          temp_speed_kp = delta + (params->speed_gains_table[gains_indexer_previous].kp);
    424          
    425                          // Calculate flux gains - ki
    426                          delta = (params->speed_gains_table[gains_indexer].ki) - (params->speed_gains_table[gains_indexer_previous].ki);
    427                          delta = delta*relative_time;
    428                          delta = delta/(params->speed_gains_table[gains_indexer].transition_time);
    429                          temp_speed_ki = delta + (params->speed_gains_table[gains_indexer_previous].ki);
    430          
    431          
    432                          if(relative_time >= (params->speed_gains_table[gains_indexer].transition_time))
    433                          {
    434                              gains_indexer_previous = gains_indexer;
    435          
    436                              temp_speed_kp = (params->speed_gains_table[gains_indexer].kp);
    437                              temp_speed_ki = (params->speed_gains_table[gains_indexer].ki);
    438                          }
    439          
    440                          Speed_Controller.Kp = temp_speed_kp;
    441                          Speed_Controller.Ki = temp_speed_ki;
    442                      }
    443                  }
    444              }
    445          }
   \   00000026   0xBC70             POP      {R4-R6}
   \   00000028   0x4770             BX       LR
   \                     ??Speed_Gain_Scheduler_0: (+1)
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0x68CB             LDR      R3,[R1, #+12]
   \   0000002E   0x6944             LDR      R4,[R0, #+20]
   \   00000030   0x6824             LDR      R4,[R4, #+0]
   \   00000032   0x42A3             CMP      R3,R4
   \   00000034   0xD30E             BCC.N    ??Speed_Gain_Scheduler_1
   \   00000036   0x69C8             LDR      R0,[R1, #+28]
   \   00000038   0xF8C2 0x02C4      STR      R0,[R2, #+708]
   \   0000003C   0x6A08             LDR      R0,[R1, #+32]
   \   0000003E   0xF8C2 0x02C8      STR      R0,[R2, #+712]
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF8C2 0x0494      STR      R0,[R2, #+1172]
   \   00000048   0xF8C2 0x0498      STR      R0,[R2, #+1176]
   \   0000004C   0xF8A2 0x0388      STRH     R0,[R2, #+904]
   \   00000050   0xBC70             POP      {R4-R6}
   \   00000052   0x4770             BX       LR
   \                     ??Speed_Gain_Scheduler_1: (+1)
   \   00000054   0xF8D2 0x3494      LDR      R3,[R2, #+1172]
   \   00000058   0xF8D2 0x4498      LDR      R4,[R2, #+1176]
   \   0000005C   0x429C             CMP      R4,R3
   \   0000005E   0xD148             BNE.N    ??Speed_Gain_Scheduler_2
   \   00000060   0x6840             LDR      R0,[R0, #+4]
   \   00000062   0xED91 0x1A09      VLDR     S2,[R1, #+36]
   \   00000066   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   0000006A   0xEDDF 0x....      VLDR.W   S1,??DataTable86  ;; 0x3dd67750
   \   0000006E   0xEE21 0x1A20      VMUL.F32 S2,S2,S1
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   00000078   0xEEF1 0xFA10      FMSTAT   
   \   0000007C   0xDD32             BLE.N    ??Speed_Gain_Scheduler_3
   \   0000007E   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   00000082   0xEEF1 0xFA10      FMSTAT   
   \   00000086   0xD42D             BMI.N    ??Speed_Gain_Scheduler_3
   \   00000088   0xED91 0x1A0D      VLDR     S2,[R1, #+52]
   \   0000008C   0xEE21 0x1A20      VMUL.F32 S2,S2,S1
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   00000096   0xEEF1 0xFA10      FMSTAT   
   \   0000009A   0xDD23             BLE.N    ??Speed_Gain_Scheduler_3
   \   0000009C   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   000000A0   0xEEF1 0xFA10      FMSTAT   
   \   000000A4   0xD41E             BMI.N    ??Speed_Gain_Scheduler_3
   \   000000A6   0xED91 0x1A11      VLDR     S2,[R1, #+68]
   \   000000AA   0xEE21 0x1A20      VMUL.F32 S2,S2,S1
   \   000000AE   0x2002             MOVS     R0,#+2
   \   000000B0   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   000000B4   0xEEF1 0xFA10      FMSTAT   
   \   000000B8   0xDD14             BLE.N    ??Speed_Gain_Scheduler_3
   \   000000BA   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   000000BE   0xEEF1 0xFA10      FMSTAT   
   \   000000C2   0xD40F             BMI.N    ??Speed_Gain_Scheduler_3
   \   000000C4   0xED91 0x1A15      VLDR     S2,[R1, #+84]
   \   000000C8   0xEE61 0x0A20      VMUL.F32 S1,S2,S1
   \   000000CC   0x2003             MOVS     R0,#+3
   \   000000CE   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   000000D2   0xEEF1 0xFA10      FMSTAT   
   \   000000D6   0xDD05             BLE.N    ??Speed_Gain_Scheduler_3
   \   000000D8   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   000000DC   0xEEF1 0xFA10      FMSTAT   
   \   000000E0   0xBF58             IT       PL 
   \   000000E2   0x2004             MOVPL    R0,#+4
   \                     ??Speed_Gain_Scheduler_3: (+1)
   \   000000E4   0xF8C2 0x0498      STR      R0,[R2, #+1176]
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0xF8A2 0x0388      STRH     R0,[R2, #+904]
   \   000000EE   0xBC70             POP      {R4-R6}
   \   000000F0   0x4770             BX       LR
   \                     ??Speed_Gain_Scheduler_2: (+1)
   \   000000F2   0xF8B2 0x0388      LDRH     R0,[R2, #+904]
   \   000000F6   0x1C40             ADDS     R0,R0,#+1
   \   000000F8   0xF8A2 0x0388      STRH     R0,[R2, #+904]
   \   000000FC   0xEB01 0x1504      ADD      R5,R1,R4, LSL #+4
   \   00000100   0xEB01 0x1103      ADD      R1,R1,R3, LSL #+4
   \   00000104   0x6AAE             LDR      R6,[R5, #+40]
   \   00000106   0xEDD1 0x0A07      VLDR     S1,[R1, #+28]
   \   0000010A   0xED95 0x1A07      VLDR     S2,[R5, #+28]
   \   0000010E   0xEDD5 0x2A08      VLDR     S5,[R5, #+32]
   \   00000112   0xB200             SXTH     R0,R0
   \   00000114   0xEE01 0x0A90      VMOV     S3,R0
   \   00000118   0xEE00 0x6A10      VMOV     S0,R6
   \   0000011C   0xEEF8 0x1AE1      VCVT.F32.S32 S3,S3
   \   00000120   0xEE31 0x2A60      VSUB.F32 S4,S2,S1
   \   00000124   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000128   0xEE22 0x2A21      VMUL.F32 S4,S4,S3
   \   0000012C   0xEE82 0x2A00      VDIV.F32 S4,S4,S0
   \   00000130   0xEE72 0x0A20      VADD.F32 S1,S4,S1
   \   00000134   0xED91 0x2A08      VLDR     S4,[R1, #+32]
   \   00000138   0xEE32 0x3AC2      VSUB.F32 S6,S5,S4
   \   0000013C   0xEE63 0x1A21      VMUL.F32 S3,S6,S3
   \   00000140   0xEE81 0x0A80      VDIV.F32 S0,S3,S0
   \   00000144   0xEE30 0x0A02      VADD.F32 S0,S0,S4
   \   00000148   0x42B0             CMP      R0,R6
   \   0000014A   0xDB05             BLT.N    ??Speed_Gain_Scheduler_4
   \   0000014C   0xF8C2 0x4494      STR      R4,[R2, #+1172]
   \   00000150   0xEEF0 0x0A41      VMOV.F32 S1,S2
   \   00000154   0xEEB0 0x0A62      VMOV.F32 S0,S5
   \                     ??Speed_Gain_Scheduler_4: (+1)
   \   00000158   0xEDC2 0x0AB1      VSTR     S1,[R2, #+708]
   \   0000015C   0xED82 0x0AB2      VSTR     S0,[R2, #+712]
   \   00000160   0xBC70             POP      {R4-R6}
   \   00000162   0x4770             BX       LR               ;; return
    446          
    447          
    448          
    449          
    450          

   \                                 In section .text, align 2, keep-with-next
    451          BOOL_TYPE MclSpeedCtrl__SetSpeedGainIndex(sint32 speed_gains_index, MCLSPEEDCTRL_JOINT_PARAMS_TYPE *params)
    452          {
    453              BOOL_TYPE accepted;
    454              accepted = FALSE;
    455          
    456              // If there is a valid speed set, Kp and Ki should be ok.
    457              if( (params->SpeedCtrlPrm->speed_gains_table[speed_gains_index].speed_abs)  )
   \                     MclSpeedCtrl__SetSpeedGainIndex: (+1)
   \   00000000   0x6809             LDR      R1,[R1, #+0]
   \   00000002   0xEB01 0x1100      ADD      R1,R1,R0, LSL #+4
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0xED91 0x0A09      VLDR     S0,[R1, #+36]
   \   0000000C   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000010   0xEEF1 0xFA10      FMSTAT   
   \   00000014   0xD007             BEQ.N    ??MclSpeedCtrl__SetSpeedGainIndex_0
    458              {
    459                  Forced_Gain_Selector = speed_gains_index;
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable96
   \   0000001A   0xF881 0x035F      STRB     R0,[R1, #+863]
    460          
    461                  Forced_Gain_Timer = (uint16)(2.0f/0.025f);  // Define 2 seconds as timeout, it might be hardcoded
    462                                                              // and the timer is managed at 25 ms.
    463          
    464                  accepted = TRUE;
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x2050             MOVS     R0,#+80
   \   00000022   0xF8A1 0x0384      STRH     R0,[R1, #+900]
    465              }
    466          
    467          
    468              return accepted;
   \                     ??MclSpeedCtrl__SetSpeedGainIndex_0: (+1)
   \   00000026   0x4610             MOV      R0,R2
   \   00000028   0x4770             BX       LR               ;; return
    469          }
    470          
    471          
    472          
    473          

   \                                 In section .text, align 4, keep-with-next
    474          BOOL_TYPE MclSpeedCtrl__SetDeltaSpeedRef(sint32 delta_speed_x65536, MCL_SPEED_CTRL_IO_F_TYPE *io)
    475          {
   \                     MclSpeedCtrl__SetDeltaSpeedRef: (+1)
   \   00000000   0xEE00 0x0A10      VMOV     S0,R0
    476              BOOL_TYPE accepted;
    477              float32 temp_1;
    478              float32 temp_2;
    479          
    480              accepted = FALSE;
    481          
    482              temp_1 = (float32)delta_speed_x65536 / 65536.0f * RPM_TO_RADS;
    483          
    484              temp_2 = temp_1 + *(io->Speed_Rot_Ref);
    485              temp_2 = MATHCALC__FABS(temp_2);
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000000A   0xEDDF 0x....      VLDR.W   S1,??DataTable86_2  ;; 0x35d67750
   \   0000000E   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000012   0xEDD1 0x0A00      VLDR     S1,[R1, #0]
   \   00000016   0xEE70 0x0A20      VADD.F32 S1,S0,S1
   \   0000001A   0xEEF0 0x0AE0      VABS.F32 S1,S1
    486          
    487              if( (temp_2 <= (float32)MAX_SPEED_RPM) &&
    488                  (temp_2 >= (float32)MIN_SPEED_RPM) )
   \   0000001E   0xED9F 0x....      VLDR.W   S2,??DataTable86_3  ;; 0x469ab001
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   00000028   0xEEF1 0xFA10      FMSTAT   
   \   0000002C   0xD510             BPL.N    ??MclSpeedCtrl__SetDeltaSpeedRef_0
   \   0000002E   0xED9F 0x....      VLDR.W   S2,??DataTable86_4  ;; 0x42c80000
   \   00000032   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   00000036   0xEEF1 0xFA10      FMSTAT   
   \   0000003A   0xDB09             BLT.N    ??MclSpeedCtrl__SetDeltaSpeedRef_0
    489              {
    490                  Delta_Speed_Rot_Ref = temp_1;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable96
   \   00000040   0xF200 0x4180      ADDW     R1,R0,#+1152
   \   00000044   0xED81 0x0A00      VSTR     S0,[R1, #0]
    491                  Delta_Speed_Timer = (uint16)(0.5f/0.025f);  // Define 2 seconds as timeout, it might be hardcoded
   \   00000048   0x2114             MOVS     R1,#+20
   \   0000004A   0xF8A0 0x1386      STRH     R1,[R0, #+902]
    492                                                              // and the timer is managed at 25 ms.
    493                  accepted = TRUE;
   \   0000004E   0x2001             MOVS     R0,#+1
    494              }
    495          
    496              return accepted;
   \                     ??MclSpeedCtrl__SetDeltaSpeedRef_0: (+1)
   \   00000050   0x4770             BX       LR               ;; return
    497          }
    498          
    499          
    500          
    501          
    502          

   \                                 In section .text, align 2, keep-with-next
    503          void Delta_Speed_Handler(void)
    504          {
    505              if(Delta_Speed_Timer)
   \                     Delta_Speed_Handler: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable96
   \   00000004   0xF8B0 0x1386      LDRH     R1,[R0, #+902]
   \   00000008   0xB119             CBZ.N    R1,??Delta_Speed_Handler_0
    506              {
    507                  Delta_Speed_Timer--;
   \   0000000A   0x1E49             SUBS     R1,R1,#+1
   \   0000000C   0xF8A0 0x1386      STRH     R1,[R0, #+902]
   \   00000010   0x4770             BX       LR
    508              }
    509              else
    510              {
    511                  Delta_Speed_Rot_Ref = 0;
   \                     ??Delta_Speed_Handler_0: (+1)
   \   00000012   0xF8C0 0x1480      STR      R1,[R0, #+1152]
    512              }
    513          }
   \   00000016   0x4770             BX       LR               ;; return
C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\Mcl\MclFvt\MclFvt.c
      1          /**
      2           *  @file       MclFvt.c
      3           *  @brief      MacroBlock Functional Verification Tests
      4           *
      5           *  @details    It perfoms all required FVT algorithms. Like current and DC bus voltage sensors,
      6           *              over current circuit and surge relay
      7           *
      8              @startuml{MCL_FVT_Class_Diagram.png}
      9          
     10              package "MclFvt"  {
     11                  Gpio :
     12                  SurgeRelay :
     13                  ClrkPark :
     14                  MotorSafetyMgr :
     15                  C_Extensions :
     16                  Mci_API:
     17                  MacroBlocks:
     18              }
     19              @enduml
     20           *
     21           *
     22           *---------------------------------------------------------------------------------------------------------------------
     23           *------------------- Copyright 2017.  Whirlpool Corporation.  All rights reserved - CONFIDENTIAL ---------------------
     24           *---------------------------------------------------------------------------------------------------------------------
     25           */
     26          
     27          //-------------------------------------- Include Files ----------------------------------------------------------------
     28          #include "MclFvt.h"
     29          #include "MclConfig.h"
     30          #include "ClrkPark.h"
     31          #include "MotorSafetyMgr.h"
     32          
     33          
     34          #if defined (SURGE_RELAY_USED) && defined (SURGE_RELAY_FVT)
     35              #include "SurgeRelay.h"
     36          #endif
     37          
     38          // Include Gpio only if OC polling is enabled.
     39          #if (defined MCI_HW_OC_DEBOUNCE_TIME) && (defined MCI_HW_OC_PORT) && (defined MCI_HW_OC_PIN) && (defined MCI_HW_OC_LEVEL)
     40              #include "Gpio.h"
     41          #endif
     42          
     43          
     44          
     45          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     46          
     47          //! Define states of the FVT
     48          typedef enum
     49          {
     50              MCL_FVT_TEST_NOT_DEFINED = 0,                   //!< Not defined, it shall not be used
     51              MCL_FVT_TEST_INJECT_DC_CURRENT,                 //!< Apply controlled dc current to check current and dc bus voltage sensors
     52          #ifdef OC_FVT
     53              MCL_FVT_TEST_OVERCURRENT_CIRCUIT,               //!< Apply high voltage to trigger the over current sensor
     54          #endif
     55          #if defined (SURGE_RELAY_USED) && defined (SURGE_RELAY_FVT)
     56              MCL_FVT_TEST_SURGE_RELAY,                       //!< Apply current and open and close surge relay.
     57          #endif
     58              MCL_FVT_TEST_WAITING,                           //!< Reenable surge relay and wait until it is in normal operation.
     59              MCL_FVT_TEST_FINISHED,                          //!< After finishing all steps, stays here until feedback is read
     60          } MCL_FVT_TEST_SEQUENCE_TYPE;
     61          
     62          
     63          //! Status of FVT
     64          typedef enum
     65          {
     66              MCLFVT_STATUS_ACTIVE = 0,                              //!< FVT is engaged and running; false when all routines is performed
     67          
     68          } MCLFVT_STATUS_TYPE;
     69          
     70          
     71          
     72          
     73          //! Data used to capture the FVT results during dc current injection
     74          typedef struct
     75          {
     76              float Averaged_Phase_Current_A;
     77              float Averaged_Phase_Current_B;
     78              float Averaged_Phase_Current_C;
     79              float Averaged_Phase_Voltage_A;
     80              float Averaged_Phase_Voltage_B;
     81              float Averaged_Phase_Voltage_C;
     82              float Averaged_DC_Bus_Voltage;
     83          
     84              sint32 Sample_Counter;
     85              sint32 Required_Nr_Samples;
     86          
     87          } MCL_FVT_TEST_DATA_SENSORS_DC_CURR_AVERAGE_TYPE;
     88          
     89          
     90          //! Data used to capture the FVT results during surge relay test
     91          typedef struct
     92          {
     93              float Averaged_DC_Bus_Voltage_Relay_Open;
     94              float Averaged_DC_Bus_Voltage_Relay_Closed;
     95          
     96              sint32 Sample_Counter;
     97              sint32 Required_Nr_Samples;
     98          
     99          } MCL_FVT_TEST_DATA_SURGE_RELAY_AVERAGE_TYPE;
    100          
    101          
    102          uint8 MclFvt_Step;                                  //!< Define steps; each state has it own meaning
    103          MCL_FVT_TEST_SEQUENCE_TYPE MclFvt_State;            //!< [MCL_FVT_TEST_SEQUENCE_TYPE] define the state the FVT is performing
    104          
    105          //! [MCL_FVT_TEST_DATA_SENSORS_DC_CURR_AVERAGE_TYPE] Data acquired inject DC current - sensor check algorithm
    106          MCL_FVT_TEST_DATA_SENSORS_DC_CURR_AVERAGE_TYPE MclFvt_Data_Test_Dc_Current;
    107          
    108          #if defined (SURGE_RELAY_USED) && defined (SURGE_RELAY_FVT)
    109              //! [MCL_FVT_TEST_DATA_SURGE_RELAY_AVERAGE_TYPE] data acquired during the surge relay tests
    110              MCL_FVT_TEST_DATA_SURGE_RELAY_AVERAGE_TYPE MclFvt_Data_Test_Surge_Relay;
    111          #endif
    112          #ifdef OC_FVT
    113          uint8 MclFvt_OC_Detected;                           //!< [Boolea] Over current was detected while running FVT
    114          #endif
    115          
    116          MCLFVT_STATUS_TYPE MclFvt_Status;                   //!< Status of fvt tests
    117          float32 MclFvt_Injection_Inst_Level;                 //!< [A] - define the level used in the manual injection
    118          float32 MclFvt_Injection_Level;                      //!< [A] - define the peak level for manual injection according to the user request
    119          float32 MclFvt_Injection_Level_Rate;                 //!< [A] - Rate change of the level in level/s
    120          float32 MclFvt_Injection_Position;                   //!< [rad] - position to apply current
    121          uint16 MclFvt_Generic_Timer;                        //!< [s /pwm rate] - generic timer used to calculate some delays
    122          MCI_FVT_ERROR_TYPE MclFvt_Error_List;               //!< Saves all information during FVT execution
    123          
    124          //! The externalized variables are explicit in order to access the variables
    125          extern MCL_INPUT_PROC_IO_F_TYPE Mcl_Input_Proc_IO;    //!< Input process variables
    126          extern MCL_DQ_CTRL_IO_F_TYPE Mcl_DQ_Ctrl_IO;          //!< DQ Controller variables
    127          extern MCL_PWM_IO_F_TYPE Mcl_Pwm_IO;                  //!< Mcl Pwm variables
    128          extern MCLPWM_JOINT_PARAMS_TYPE MclPwm_Params;      //!< Mcl Pwm joint parameters
    129          
    130          
    131          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
    132          
    133          static void DC_Current_Injection_Control(void);
    134          static uint8 Polls_Hw_OC(void);
    135          
    136          
    137          uint8 fvt_debug_averaging;
    138          
    139          
    140          
    141          //---------------------------------------------------------------------------------------------------------------------
    142          /**
    143           * Entry point to initialize all FVT variables before running tests.
    144           *
    145           */

   \                                 In section .text, align 2, keep-with-next
    146          void MclFvt__Entry(void)
    147          {
    148              BIT_SET(MclFvt_Status, MCLFVT_STATUS_ACTIVE);
   \                     MclFvt__Entry: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable92
   \   00000004   0xF890 0x1363      LDRB     R1,[R0, #+867]
   \   00000008   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000000C   0xF880 0x1363      STRB     R1,[R0, #+867]
    149          
    150              MclFvt_Error_List = (MCI_FVT_ERROR_TYPE)0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0xF880 0x1364      STRB     R1,[R0, #+868]
    151          
    152              Mcl_IO.All_Devices_Off = FALSE;
   \   00000016   0xF880 0x118D      STRB     R1,[R0, #+397]
    153              Mcl_IO.Lowers_On = FALSE;
   \   0000001A   0xF880 0x118C      STRB     R1,[R0, #+396]
    154          
    155              MclFvt_State = MCL_FVT_TEST_INJECT_DC_CURRENT;
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0xF880 0x1362      STRB     R1,[R0, #+866]
    156          
    157              MclFvt_Data_Test_Dc_Current.Averaged_DC_Bus_Voltage = 0.0f;
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0xF8C0 0x1238      STR      R1,[R0, #+568]
    158              MclFvt_Data_Test_Dc_Current.Averaged_Phase_Current_A = 0.0f;
   \   0000002A   0xF8C0 0x1220      STR      R1,[R0, #+544]
    159              MclFvt_Data_Test_Dc_Current.Averaged_Phase_Current_B = 0.0f;
   \   0000002E   0xF8C0 0x1224      STR      R1,[R0, #+548]
    160              MclFvt_Data_Test_Dc_Current.Averaged_Phase_Current_C = 0.0f;
   \   00000032   0xF8C0 0x1228      STR      R1,[R0, #+552]
    161              MclFvt_Data_Test_Dc_Current.Averaged_Phase_Voltage_A = 0.0f;
   \   00000036   0xF8C0 0x122C      STR      R1,[R0, #+556]
    162              MclFvt_Data_Test_Dc_Current.Averaged_Phase_Voltage_B = 0.0f;
   \   0000003A   0xF8C0 0x1230      STR      R1,[R0, #+560]
    163              MclFvt_Data_Test_Dc_Current.Averaged_Phase_Voltage_C = 0.0f;
   \   0000003E   0xF8C0 0x1234      STR      R1,[R0, #+564]
    164              MclFvt_Data_Test_Dc_Current.Sample_Counter = 0;
   \   00000042   0xF8C0 0x123C      STR      R1,[R0, #+572]
    165              MclFvt_Data_Test_Dc_Current.Required_Nr_Samples = 8000;
   \   00000046   0xF44F 0x51FA      MOV      R1,#+8000
   \   0000004A   0xF8C0 0x1240      STR      R1,[R0, #+576]
    166          
    167              MclFvt_Generic_Timer = 8000; // empirically set based on measurements
   \   0000004E   0xF8A0 0x138A      STRH     R1,[R0, #+906]
    168          
    169              MclFvt_Injection_Level      = MCLFVT_INJECTION_LEVEL;
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable96_2  ;; 0x3f19999a
   \   00000056   0xF8C0 0x14A0      STR      R1,[R0, #+1184]
    170              MclFvt_Injection_Level_Rate = MCLFVT_INJECTION_LEVEL_RATE;
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable96_3  ;; 0x3903126f
   \   0000005E   0xF8C0 0x14A4      STR      R1,[R0, #+1188]
    171              MclFvt_Injection_Position   = MCLFVT_INJECTION_POSITION;
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable96_4  ;; 0x3fc90fdb
   \   00000066   0xF8C0 0x14A8      STR      R1,[R0, #+1192]
    172          
    173              MclFvt_Injection_Inst_Level = 0.0f;
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0xF8C0 0x149C      STR      R1,[R0, #+1180]
    174          
    175              MclFvt_Step = 0;
   \   00000070   0xF880 0x1361      STRB     R1,[R0, #+865]
    176          
    177              fvt_debug_averaging = 0;
   \   00000074   0xF880 0x1365      STRB     R1,[R0, #+869]
    178          }
   \   00000078   0x4770             BX       LR               ;; return
    179          
    180          
    181          
    182          
    183          //---------------------------------------------------------------------------------------------------------------------
    184          /**
    185           * Exit point to reset all FVT variables before exiting FVT.
    186           *
    187           */

   \                                 In section .text, align 2, keep-with-next
    188          void MclFvt__Exit(void)
    189          {
    190          #if defined (SURGE_RELAY_USED) && defined (SURGE_RELAY_FVT)
    191          
    192              SurgeRelay__Action(SURGERELAY_NORMAL);
    193          
    194          #endif
    195          
    196              Mcl_DQ_Ctrl_IO.Sin_Cos = &Mcl_Quantities.Sin_Cos_Position_Flux;
   \                     MclFvt__Exit: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable96
   \   00000004   0xF100 0x0188      ADD      R1,R0,#+136
   \   00000008   0xF8C0 0x11E0      STR      R1,[R0, #+480]
    197          }
   \   0000000C   0x4770             BX       LR               ;; return
    198          
    199          
    200          
    201          
    202          //---------------------------------------------------------------------------------------------------------------------
    203          /**
    204           * Pwm handler of FVT. All required tests are performed in this handler. The FVT state machine is
    205           * performed within this handler.
    206          
    207               @startuml{MclFvt_State_Machine.png}
    208          
    209                  title MclFvt - Macroblock Functional Verification Tests - FVT state machine
    210          
    211                  [*] --> MCL_FVT_TEST_INJECT_DC_CURRENT
    212          
    213                  MCL_FVT_TEST_INJECT_DC_CURRENT : Apply controlled dc current to check current and dc bus voltage sensors
    214                  MCL_FVT_TEST_INJECT_DC_CURRENT --> MCL_FVT_TEST_SURGE_RELAY   : [No error found] AND\n[Time is over]
    215          
    216                  MCL_FVT_TEST_SURGE_RELAY : Apply current and open and close surge relay.
    217                  MCL_FVT_TEST_SURGE_RELAY --> MCL_FVT_TEST_OVERCURRENT_CIRCUIT : [No error found] AND\n[Time is over]
    218          
    219                  MCL_FVT_TEST_OVERCURRENT_CIRCUIT : Reenable surge relay and wait until it is in normal operation.
    220                  MCL_FVT_TEST_OVERCURRENT_CIRCUIT --> MCL_FVT_TEST_WAITING   : [[No error found] AND [OC detected]] OR\n[Time is over]
    221          
    222                  MCL_FVT_TEST_WAITING : Waiting for Class B to be finish its checks,\ne.g. perform plausibility check.
    223                  MCL_FVT_TEST_WAITING --> MCL_FVT_TEST_FINISHED               : [No error found] AND\n[Time is over]
    224          
    225                  MCL_FVT_TEST_FINISHED : After finishing all steps, stays here until feedback is read
    226          
    227              @enduml
    228           *
    229           */

   \                                 In section .text, align 4, keep-with-next
    230          void MclFvt__PwmHandler(void)
    231          {
   \                     MclFvt__PwmHandler: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    232              uint8 oc_found;
    233              float temp_f;
    234          
    235              oc_found = Polls_Hw_OC();
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable92
   \   00000008   0xED2D 0x8B08      VPUSH    {D8-D11}
   \   0000000C   0xB082             SUB      SP,SP,#+8
   \   0000000E   0xF504 0x7171      ADD      R1,R4,#+964
   \   00000012   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   00000016   0x.... 0x....      BL       SRData__CheckShort
   \   0000001A   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   0000001E   0x0600             LSLS     R0,R0,#+24
   \   00000020   0x0F80             LSRS     R0,R0,#+30
   \   00000022   0xF000 0x0501      AND      R5,R0,#0x1
   \   00000026   0xF894 0x0362      LDRB     R0,[R4, #+866]
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xF040 0x8139      BNE.W    ??MclFvt__PwmHandler_0
    236          
    237              if(MclFvt_State == MCL_FVT_TEST_INJECT_DC_CURRENT)
    238              {
    239                  DC_Current_Injection_Control();
   \   00000030   0xF504 0x7011      ADD      R0,R4,#+580
   \   00000034   0x.... 0x....      BL       MclInputProc__RunningHandler
   \   00000038   0xA800             ADD      R0,SP,#+0
   \   0000003A   0xF8C4 0x01E0      STR      R0,[R4, #+480]
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0xF8D4 0x01E4      LDR      R0,[R4, #+484]
   \   00000044   0x6041             STR      R1,[R0, #+4]
   \   00000046   0xF8D4 0x01E4      LDR      R0,[R4, #+484]
   \   0000004A   0x6081             STR      R1,[R0, #+8]
   \   0000004C   0xF8D4 0x049C      LDR      R0,[R4, #+1180]
   \   00000050   0xEE00 0x0A10      VMOV     S0,R0
   \   00000054   0xF8D4 0x04A0      LDR      R0,[R4, #+1184]
   \   00000058   0xEE00 0x0A90      VMOV     S1,R0
   \   0000005C   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000060   0xEEF1 0xFA10      FMSTAT   
   \   00000064   0xD506             BPL.N    ??MclFvt__PwmHandler_1
   \   00000066   0xF8D4 0x04A4      LDR      R0,[R4, #+1188]
   \   0000006A   0xEE00 0x0A90      VMOV     S1,R0
   \   0000006E   0xEE70 0x0A20      VADD.F32 S1,S0,S1
   \   00000072   0xE011             B.N      ??MclFvt__PwmHandler_2
   \                     ??MclFvt__PwmHandler_1: (+1)
   \   00000074   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   00000078   0xEEF1 0xFA10      FMSTAT   
   \   0000007C   0xD50C             BPL.N    ??MclFvt__PwmHandler_2
   \   0000007E   0xF8D4 0x04A4      LDR      R0,[R4, #+1188]
   \   00000082   0xEE00 0x0A90      VMOV     S1,R0
   \   00000086   0xEE70 0x0A60      VSUB.F32 S1,S0,S1
   \   0000008A   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   0000008E   0xEEF1 0xFA10      FMSTAT   
   \   00000092   0xBF98             IT       LS 
   \   00000094   0xEDDF 0x....      VLDRLS.W S1,??DataTable90  ;; 0x0
   \                     ??MclFvt__PwmHandler_2: (+1)
   \   00000098   0xF204 0x409C      ADDW     R0,R4,#+1180
   \   0000009C   0xF8D4 0x14A8      LDR      R1,[R4, #+1192]
   \   000000A0   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
   \   000000A4   0xA800             ADD      R0,SP,#+0
   \   000000A6   0xEE00 0x1A10      VMOV     S0,R1
   \   000000AA   0x.... 0x....      BL       MathCalc__SinCosF
   \   000000AE   0xF8D4 0x0250      LDR      R0,[R4, #+592]
   \   000000B2   0xEDDD 0x0A01      VLDR     S1,[SP, #+4]
   \   000000B6   0xED90 0x1A01      VLDR     S2,[R0, #+4]
   \   000000BA   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   000000BE   0xED9D 0x2A00      VLDR     S4,[SP, #+0]
   \   000000C2   0xF8D4 0x01D0      LDR      R0,[R4, #+464]
   \   000000C6   0xEE61 0x1A20      VMUL.F32 S3,S2,S1
   \   000000CA   0xEE40 0x1A02      VMLA.F32 S3,S0,S4
   \   000000CE   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000000D2   0xEDDD 0x0A00      VLDR     S1,[SP, #+0]
   \   000000D6   0x2100             MOVS     R1,#+0
   \   000000D8   0x6001             STR      R1,[R0, #+0]
   \   000000DA   0xEE01 0x0A60      VMLS.F32 S0,S2,S1
   \   000000DE   0xF8D4 0x01D4      LDR      R0,[R4, #+468]
   \   000000E2   0xEDC0 0x1A00      VSTR     S3,[R0, #0]
   \   000000E6   0xF8D4 0x01D8      LDR      R0,[R4, #+472]
   \   000000EA   0xF8D4 0x149C      LDR      R1,[R4, #+1180]
   \   000000EE   0x6001             STR      R1,[R0, #+0]
   \   000000F0   0xF8D4 0x01DC      LDR      R0,[R4, #+476]
   \   000000F4   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   000000F8   0xF8D4 0x03F4      LDR      R0,[R4, #+1012]
   \   000000FC   0xF500 0x71AC      ADD      R1,R0,#+344
   \   00000100   0x690A             LDR      R2,[R1, #+16]
   \   00000102   0xF8C4 0x22A8      STR      R2,[R4, #+680]
   \   00000106   0x694A             LDR      R2,[R1, #+20]
   \   00000108   0xF8C4 0x22AC      STR      R2,[R4, #+684]
   \   0000010C   0x698A             LDR      R2,[R1, #+24]
   \   0000010E   0xF8C4 0x228C      STR      R2,[R4, #+652]
   \   00000112   0x69C9             LDR      R1,[R1, #+28]
   \   00000114   0xF8C4 0x1290      STR      R1,[R4, #+656]
   \   00000118   0xF500 0x71AC      ADD      R1,R0,#+344
   \   0000011C   0xF504 0x70E8      ADD      R0,R4,#+464
   \   00000120   0x.... 0x....      BL       MclDqCtrl__RunningHandler
   \   00000124   0xF504 0x714E      ADD      R1,R4,#+824
   \   00000128   0xF504 0x703C      ADD      R0,R4,#+752
   \   0000012C   0x.... 0x....      BL       MclPwm__RunningHandler
    240          
    241                  // Ramp up current - transient
    242                  if(MclFvt_Step == 0)
   \   00000130   0xF894 0x0361      LDRB     R0,[R4, #+865]
   \   00000134   0xB9C0             CBNZ.N   R0,??MclFvt__PwmHandler_3
    243                  {
    244                      if(MclFvt_Injection_Inst_Level >= MclFvt_Injection_Level)
   \   00000136   0xF8D4 0x049C      LDR      R0,[R4, #+1180]
   \   0000013A   0xEE00 0x0A10      VMOV     S0,R0
   \   0000013E   0xF8D4 0x04A0      LDR      R0,[R4, #+1184]
   \   00000142   0xEE00 0x0A90      VMOV     S1,R0
   \   00000146   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000014A   0xEEF1 0xFA10      FMSTAT   
   \   0000014E   0xF2C0 0x80BC      BLT.W    ??MclFvt__PwmHandler_4
    245                      {
    246                          if(MclFvt_Generic_Timer)
   \   00000152   0xF8B4 0x038A      LDRH     R0,[R4, #+906]
   \   00000156   0x2800             CMP      R0,#+0
   \   00000158   0xBF07             ITTEE    EQ 
    247                          {
    248                              MclFvt_Generic_Timer--;
    249                          }
    250                          else
    251                          {
    252                              MclFvt_Step = 1;
   \   0000015A   0x2001             MOVEQ    R0,#+1
   \   0000015C   0xF884 0x0361      STRBEQ   R0,[R4, #+865]
    253                          }
   \   00000160   0x1E40             SUBNE    R0,R0,#+1
   \   00000162   0xF8A4 0x038A      STRHNE   R0,[R4, #+906]
   \   00000166   0xE0B0             B.N      ??MclFvt__PwmHandler_4
    254                      }
    255                  }
    256          
    257                  // Steady state current
    258                  else if(MclFvt_Step == 1)
   \                     ??MclFvt__PwmHandler_3: (+1)
   \   00000168   0x2801             CMP      R0,#+1
   \   0000016A   0xF040 0x80AE      BNE.W    ??MclFvt__PwmHandler_4
    259                  {
    260                      fvt_debug_averaging = TRUE;
   \   0000016E   0xF884 0x0365      STRB     R0,[R4, #+869]
    261          
    262                      // Accumulate the reading
    263                      MclFvt_Data_Test_Dc_Current.Averaged_DC_Bus_Voltage  += ((1.0f/65536.0f)*Mci__GetAnalog(MOTOR0, MCI_AI_BUS_VOLTAGE_S16));
   \   00000172   0x210D             MOVS     R1,#+13
   \   00000174   0x2000             MOVS     R0,#+0
   \   00000176   0x.... 0x....      BL       Mci__GetAnalog
   \   0000017A   0xEE00 0x0A10      VMOV     S0,R0
   \   0000017E   0xED9F 0x....      VLDR.W   S16,??DataTable91  ;; 0x37800000
   \   00000182   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000186   0xEDD4 0x8A8E      VLDR     S17,[R4, #+568]
   \   0000018A   0xEE40 0x8A08      VMLA.F32 S17,S0,S16
   \   0000018E   0xEDC4 0x8A8E      VSTR     S17,[R4, #+568]
    264                      MclFvt_Data_Test_Dc_Current.Averaged_Phase_Current_A += ((1.0f/65536.0f)*Mci__GetAnalog(MOTOR0, MCI_AI_CURR_PHASE_A_S16));
   \   00000192   0x2114             MOVS     R1,#+20
   \   00000194   0x2000             MOVS     R0,#+0
   \   00000196   0x.... 0x....      BL       Mci__GetAnalog
   \   0000019A   0xEE00 0x0A10      VMOV     S0,R0
   \   0000019E   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000001A2   0xED94 0x9A88      VLDR     S18,[R4, #+544]
   \   000001A6   0xEE00 0x9A08      VMLA.F32 S18,S0,S16
   \   000001AA   0xED84 0x9A88      VSTR     S18,[R4, #+544]
    265                      MclFvt_Data_Test_Dc_Current.Averaged_Phase_Current_B += ((1.0f/65536.0f)*Mci__GetAnalog(MOTOR0, MCI_AI_CURR_PHASE_B_S16));
   \   000001AE   0x2115             MOVS     R1,#+21
   \   000001B0   0x2000             MOVS     R0,#+0
   \   000001B2   0x.... 0x....      BL       Mci__GetAnalog
   \   000001B6   0xEE00 0x0A10      VMOV     S0,R0
   \   000001BA   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000001BE   0xEDD4 0x9A89      VLDR     S19,[R4, #+548]
   \   000001C2   0xEE40 0x9A08      VMLA.F32 S19,S0,S16
   \   000001C6   0xEDC4 0x9A89      VSTR     S19,[R4, #+548]
    266                      MclFvt_Data_Test_Dc_Current.Averaged_Phase_Current_C += ((1.0f/65536.0f)*Mci__GetAnalog(MOTOR0, MCI_AI_CURR_PHASE_C_S16));
   \   000001CA   0x2116             MOVS     R1,#+22
   \   000001CC   0x2000             MOVS     R0,#+0
   \   000001CE   0x.... 0x....      BL       Mci__GetAnalog
   \   000001D2   0xEE00 0x0A10      VMOV     S0,R0
   \   000001D6   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000001DA   0xED94 0xAA8A      VLDR     S20,[R4, #+552]
   \   000001DE   0xEE00 0xAA08      VMLA.F32 S20,S0,S16
   \   000001E2   0xED84 0xAA8A      VSTR     S20,[R4, #+552]
    267                      MclFvt_Data_Test_Dc_Current.Averaged_Phase_Voltage_A += ((1.0f/65536.0f)*Mci__GetAnalog(MOTOR0, MCI_AI_VOLTAGE_PHASE_A_S16));
   \   000001E6   0x2110             MOVS     R1,#+16
   \   000001E8   0x2000             MOVS     R0,#+0
   \   000001EA   0x.... 0x....      BL       Mci__GetAnalog
   \   000001EE   0xEE00 0x0A10      VMOV     S0,R0
   \   000001F2   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000001F6   0xEDD4 0xAA8B      VLDR     S21,[R4, #+556]
   \   000001FA   0xEE40 0xAA08      VMLA.F32 S21,S0,S16
   \   000001FE   0xEDC4 0xAA8B      VSTR     S21,[R4, #+556]
    268                      MclFvt_Data_Test_Dc_Current.Averaged_Phase_Voltage_B += ((1.0f/65536.0f)*Mci__GetAnalog(MOTOR0, MCI_AI_VOLTAGE_PHASE_B_S16));
   \   00000202   0x2111             MOVS     R1,#+17
   \   00000204   0x2000             MOVS     R0,#+0
   \   00000206   0x.... 0x....      BL       Mci__GetAnalog
   \   0000020A   0xEE00 0x0A10      VMOV     S0,R0
   \   0000020E   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000212   0xED94 0xBA8C      VLDR     S22,[R4, #+560]
   \   00000216   0xEE00 0xBA08      VMLA.F32 S22,S0,S16
   \   0000021A   0xED84 0xBA8C      VSTR     S22,[R4, #+560]
    269                      MclFvt_Data_Test_Dc_Current.Averaged_Phase_Voltage_C += ((1.0f/65536.0f)*Mci__GetAnalog(MOTOR0, MCI_AI_VOLTAGE_PHASE_C_S16));
   \   0000021E   0x2112             MOVS     R1,#+18
   \   00000220   0x2000             MOVS     R0,#+0
   \   00000222   0x.... 0x....      BL       Mci__GetAnalog
   \   00000226   0xEE00 0x0A10      VMOV     S0,R0
   \   0000022A   0xEEF8 0x0AC0      VCVT.F32.S32 S1,S0
    270                      MclFvt_Data_Test_Dc_Current.Sample_Counter++;
   \   0000022E   0xF8D4 0x023C      LDR      R0,[R4, #+572]
   \   00000232   0xED94 0x0A8D      VLDR     S0,[R4, #+564]
    271          
    272                      if(MclFvt_Data_Test_Dc_Current.Sample_Counter >= MclFvt_Data_Test_Dc_Current.Required_Nr_Samples)
   \   00000236   0xF8D4 0x1240      LDR      R1,[R4, #+576]
   \   0000023A   0xEE00 0x0A88      VMLA.F32 S0,S1,S16
   \   0000023E   0x1C40             ADDS     R0,R0,#+1
   \   00000240   0xED84 0x0A8D      VSTR     S0,[R4, #+564]
   \   00000244   0xF8C4 0x023C      STR      R0,[R4, #+572]
   \   00000248   0x4288             CMP      R0,R1
   \   0000024A   0xDB3E             BLT.N    ??MclFvt__PwmHandler_4
    273                      {
    274                          temp_f = 1.0f / (float)MclFvt_Data_Test_Dc_Current.Sample_Counter; // Do only one conversion from int to float
   \   0000024C   0xEE00 0x0A90      VMOV     S1,R0
   \   00000250   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000254   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \   00000258   0xEEC1 0x0A20      VDIV.F32 S1,S2,S1
    275          
    276                          // Average all quantities
    277                          MclFvt_Data_Test_Dc_Current.Averaged_DC_Bus_Voltage *= temp_f;
   \   0000025C   0xEE28 0x1AA0      VMUL.F32 S2,S17,S1
   \   00000260   0xED84 0x1A8E      VSTR     S2,[R4, #+568]
    278          
    279                          MclFvt_Data_Test_Dc_Current.Averaged_Phase_Current_A *= temp_f;
   \   00000264   0xEE29 0x1A20      VMUL.F32 S2,S18,S1
   \   00000268   0xED84 0x1A88      VSTR     S2,[R4, #+544]
    280                          MclFvt_Data_Test_Dc_Current.Averaged_Phase_Current_B *= temp_f;
   \   0000026C   0xEE29 0x1AA0      VMUL.F32 S2,S19,S1
   \   00000270   0xED84 0x1A89      VSTR     S2,[R4, #+548]
    281                          MclFvt_Data_Test_Dc_Current.Averaged_Phase_Current_C *= temp_f;
   \   00000274   0xEE2A 0x1A20      VMUL.F32 S2,S20,S1
   \   00000278   0xED84 0x1A8A      VSTR     S2,[R4, #+552]
    282          
    283                          MclFvt_Data_Test_Dc_Current.Averaged_Phase_Voltage_A *= temp_f;
    284                          MclFvt_Data_Test_Dc_Current.Averaged_Phase_Voltage_B *= temp_f;
    285                          MclFvt_Data_Test_Dc_Current.Averaged_Phase_Voltage_C *= temp_f;
    286          
    287          #if defined (SURGE_RELAY_USED) && defined (SURGE_RELAY_FVT)
    288          
    289                          MclFvt_Step = 0;
    290                          MclFvt_Generic_Timer = 20000;
    291                          MclFvt_State = MCL_FVT_TEST_SURGE_RELAY;
    292          
    293          #else
    294          #ifdef OC_FVT
    295                          MclFvt_Generic_Timer = 2000;
    296                          MclFvt_Step = 0;
    297          
    298                          MclFvt_State = MCL_FVT_TEST_OVERCURRENT_CIRCUIT;
    299          #else
    300          
    301                          MclFvt_State = MCL_FVT_TEST_WAITING;
   \   0000027C   0x2002             MOVS     R0,#+2
   \   0000027E   0xEE2A 0x1AA0      VMUL.F32 S2,S21,S1
   \   00000282   0xF884 0x0362      STRB     R0,[R4, #+866]
   \   00000286   0xED84 0x1A8B      VSTR     S2,[R4, #+556]
   \   0000028A   0xEE2B 0x1A20      VMUL.F32 S2,S22,S1
   \   0000028E   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
    302          #endif
    303          
    304          #endif
    305                          fvt_debug_averaging = FALSE;
   \   00000292   0x2000             MOVS     R0,#+0
   \   00000294   0xED84 0x1A8C      VSTR     S2,[R4, #+560]
   \   00000298   0xED84 0x0A8D      VSTR     S0,[R4, #+564]
   \   0000029C   0xF884 0x0365      STRB     R0,[R4, #+869]
   \   000002A0   0xE013             B.N      ??MclFvt__PwmHandler_4
    306                      }
    307                  }
    308              }
    309          
    310              //////////////////////////////////////////////////////////////////////////////
    311              //////////////////////////////////////////////////////////////////////////////
    312              //////////////////////////////////////////////////////////////////////////////
    313              //////////////////////////////////////////////////////////////////////////////
    314          #if defined (SURGE_RELAY_USED) && defined (SURGE_RELAY_FVT)
    315              else if(MclFvt_State == MCL_FVT_TEST_SURGE_RELAY)
    316              {
    317                  if(MclFvt_Step == 0)
    318                  {
    319                      SurgeRelay__Action(SURGERELAY_OPEN);
    320          
    321                      // Delay some time to wait the voltage stabilizes at lower value
    322                      if(MclFvt_Generic_Timer)
    323                      {
    324                          MclFvt_Generic_Timer--;
    325                      }
    326                      else
    327                      {
    328                          MclFvt_Data_Test_Surge_Relay.Averaged_DC_Bus_Voltage_Relay_Open = 0.0f;
    329                          MclFvt_Data_Test_Surge_Relay.Averaged_DC_Bus_Voltage_Relay_Closed = 0.0f;
    330                          MclFvt_Data_Test_Surge_Relay.Sample_Counter = 0;
    331                          MclFvt_Data_Test_Surge_Relay.Required_Nr_Samples = 8000;
    332          
    333                          MclFvt_Step = 1;
    334                      }
    335                  }
    336                  else if(MclFvt_Step == 1)
    337                  {
    338                      fvt_debug_averaging = TRUE;
    339          
    340                      MclFvt_Data_Test_Surge_Relay.Averaged_DC_Bus_Voltage_Relay_Open  += ((1.0f/65536.0f)*Mci__GetAnalog(MOTOR0, MCI_AI_BUS_VOLTAGE_S16));
    341                      MclFvt_Data_Test_Surge_Relay.Sample_Counter++;
    342          
    343                      if(MclFvt_Data_Test_Surge_Relay.Sample_Counter >= MclFvt_Data_Test_Surge_Relay.Required_Nr_Samples)
    344                      {
    345                          temp_f = 1.0f / (float)MclFvt_Data_Test_Surge_Relay.Sample_Counter; // Do only one conversion from int to float
    346          
    347                          // Average all quantities
    348                          MclFvt_Data_Test_Surge_Relay.Averaged_DC_Bus_Voltage_Relay_Open *= temp_f;
    349          
    350                          MclFvt_Generic_Timer = 12000;
    351                          MclFvt_Data_Test_Surge_Relay.Sample_Counter = 0;
    352                          SurgeRelay__Action(SURGERELAY_CLOSE);
    353                          MclFvt_Step = 2;
    354          
    355                          fvt_debug_averaging = FALSE;
    356                      }
    357                  }
    358                  else if(MclFvt_Step == 2)
    359                  {
    360                      // Delay some time to wait the voltage stabilizes at higher valuevalue
    361                      if(MclFvt_Generic_Timer)
    362                      {
    363                          MclFvt_Generic_Timer--;
    364                      }
    365                      else
    366                      {
    367                          MclFvt_Step = 3;
    368                      }
    369                  }
    370                  else if(MclFvt_Step == 3)
    371                  {
    372                      fvt_debug_averaging = TRUE;
    373          
    374                      // Average voltage at higher voltage
    375                      MclFvt_Data_Test_Surge_Relay.Averaged_DC_Bus_Voltage_Relay_Closed  += ((1.0f/65536.0f)*Mci__GetAnalog(MOTOR0, MCI_AI_BUS_VOLTAGE_S16));
    376                      MclFvt_Data_Test_Surge_Relay.Sample_Counter++;
    377          
    378                      if(MclFvt_Data_Test_Surge_Relay.Sample_Counter >= MclFvt_Data_Test_Surge_Relay.Required_Nr_Samples)
    379                      {
    380                          temp_f = 1.0f / (float)MclFvt_Data_Test_Surge_Relay.Sample_Counter; // Do only one conversion from int to float
    381          
    382                          // Average all quantities
    383                          MclFvt_Data_Test_Surge_Relay.Averaged_DC_Bus_Voltage_Relay_Closed *= temp_f;
    384          
    385                          MclFvt_Generic_Timer = 2000;
    386                          MclFvt_Step = 0;
    387                          SurgeRelay__Action(SURGERELAY_CLOSE);
    388          
    389                          MclFvt_State = MCL_FVT_TEST_OVERCURRENT_CIRCUIT;
    390          
    391                          fvt_debug_averaging = FALSE;
    392                      }
    393                  }
    394          
    395                  DC_Current_Injection_Control();
    396              }
    397          #endif
    398          
    399              //////////////////////////////////////////////////////////////////////////////
    400              //////////////////////////////////////////////////////////////////////////////
    401              //////////////////////////////////////////////////////////////////////////////
    402              //////////////////////////////////////////////////////////////////////////////
    403          #ifdef OC_FVT
    404              else if(MclFvt_State == MCL_FVT_TEST_OVERCURRENT_CIRCUIT)
    405              {
    406                  if(MclFvt_Step == 0)
    407                  {
    408                      // Just delay a little bit with relay closed
    409                      if(MclFvt_Generic_Timer)
    410                      {
    411                          MclFvt_Generic_Timer--;
    412                      }
    413                      else
    414                      {
    415                          MclFvt_Generic_Timer = 8000;
    416          
    417                          MclFvt_Step = 1;
    418                      }
    419                  }
    420                  else if(MclFvt_Step == 1)
    421                  {
    422                      // apply high voltage until over current is detected.
    423                      // Pwm Handler
    424                      Mcl_Pwm_IO.Vs_Alpha_Beta->Alpha = MCLFVT_OC_VOLTAGE_LEVEL;
    425                      Mcl_Pwm_IO.Vs_Alpha_Beta->Beta = 0.0f;
    426          
    427                      MclPwm__RunningHandler(&Mcl_Pwm_IO, &MclPwm_Params);
    428          
    429                      // Wait some time looking for hw over current event
    430                      if(MclFvt_Generic_Timer)
    431                      {
    432                          MclFvt_Generic_Timer--;
    433                      }
    434          
    435                      // If hardware OC detected or timeouted
    436                      if( (oc_found == TRUE)   ||
    437                          (MclFvt_Generic_Timer == 0) )
    438                      {
    439                          MclFvt_Step = 2;
    440          
    441                          // Disable output
    442                          Mcl_Pwm_IO.Vs_Alpha_Beta->Alpha = 0.0f;
    443                          Mcl_Pwm_IO.Vs_Alpha_Beta->Beta = 0.0f;
    444          
    445                          // If hw worked within the time, the event is detected!
    446                          if(oc_found == TRUE)
    447                          {
    448                              MclFvt_OC_Detected = TRUE;
    449                          }
    450                          else
    451                          {
    452                              // otherwise, the time is expired.
    453                              MclFvt_OC_Detected = FALSE;
    454                          }
    455          
    456                          if(!MclFvt_Generic_Timer)
    457                          {
    458                              BIT_SET(MclFvt_Error_List, MCI_FVT_ERROR_OC_TIMEOUT);
    459                          }
    460          
    461                          MclFvt_State = MCL_FVT_TEST_WAITING;
    462                          MclPwm__RunningHandler(&Mcl_Pwm_IO, &MclPwm_Params);
    463                      }
    464                  }
    465              }
    466          #endif
    467              //////////////////////////////////////////////////////////////////////////////
    468              //////////////////////////////////////////////////////////////////////////////
    469              //////////////////////////////////////////////////////////////////////////////
    470              //////////////////////////////////////////////////////////////////////////////
    471              else if( MclFvt_State == MCL_FVT_TEST_WAITING)
   \                     ??MclFvt__PwmHandler_0: (+1)
   \   000002A2   0x2802             CMP      R0,#+2
   \   000002A4   0xD109             BNE.N    ??MclFvt__PwmHandler_5
    472              {
    473          #if defined (SURGE_RELAY_USED) && defined (SURGE_RELAY_FVT)
    474          
    475                  SurgeRelay__Action(SURGERELAY_NORMAL);
    476          
    477                  if(SurgeRelay__IsBusReady())
    478                  {
    479                      // Wait until the system is recovered. Prevent false failure reporting
    480                      MclFvt_State = MCL_FVT_TEST_FINISHED;
    481                      BIT_CLR(MclFvt_Error_List, MCI_FVT_ERROR_DATA_OLD);
    482                  }
    483          
    484          #else
    485          
    486                  // Wait until the system is recovered. Prevent false failure reporting
    487                  MclFvt_State = MCL_FVT_TEST_FINISHED;
   \   000002A6   0x2003             MOVS     R0,#+3
   \   000002A8   0xF884 0x0362      STRB     R0,[R4, #+866]
    488                  BIT_CLR(MclFvt_Error_List, MCI_FVT_ERROR_DATA_OLD);
   \   000002AC   0xF894 0x0364      LDRB     R0,[R4, #+868]
   \   000002B0   0xF000 0x00FB      AND      R0,R0,#0xFB
   \   000002B4   0xF884 0x0364      STRB     R0,[R4, #+868]
   \   000002B8   0xE007             B.N      ??MclFvt__PwmHandler_4
    489          
    490          #endif
    491              }
    492          
    493              //////////////////////////////////////////////////////////////////////////////
    494              //////////////////////////////////////////////////////////////////////////////
    495              //////////////////////////////////////////////////////////////////////////////
    496              //////////////////////////////////////////////////////////////////////////////
    497              else if(MclFvt_State == MCL_FVT_TEST_FINISHED)
   \                     ??MclFvt__PwmHandler_5: (+1)
   \   000002BA   0x2803             CMP      R0,#+3
   \   000002BC   0xD105             BNE.N    ??MclFvt__PwmHandler_4
    498              {
    499                  // do nothing, just stay here until the status is read...
    500                  BIT_CLR(MclFvt_Status, MCLFVT_STATUS_ACTIVE);
   \   000002BE   0xF894 0x0363      LDRB     R0,[R4, #+867]
   \   000002C2   0xF000 0x00FE      AND      R0,R0,#0xFE
   \   000002C6   0xF884 0x0363      STRB     R0,[R4, #+867]
    501              }
    502          
    503          
    504              // If OC happened while not testing OC
    505              if(oc_found == TRUE)
   \                     ??MclFvt__PwmHandler_4: (+1)
   \   000002CA   0xB15D             CBZ.N    R5,??MclFvt__PwmHandler_6
    506              {
    507          
    508          #ifdef OC_FVT
    509                  if(MclFvt_State < MCL_FVT_TEST_OVERCURRENT_CIRCUIT)
    510                  {
    511                      Mcl_IO.All_Devices_Off = TRUE;
    512          
    513                      MclFvt_State = MCL_FVT_TEST_WAITING;
    514          
    515                      BIT_SET(MclFvt_Error_List, MCI_FVT_ERROR_WRONG_OC);
    516                  }
    517          
    518          #else
    519                  Mcl_IO.All_Devices_Off = TRUE;
   \   000002CC   0x2001             MOVS     R0,#+1
   \   000002CE   0xF884 0x018D      STRB     R0,[R4, #+397]
    520          
    521                  MclFvt_State = MCL_FVT_TEST_WAITING;
   \   000002D2   0x2002             MOVS     R0,#+2
   \   000002D4   0xF884 0x0362      STRB     R0,[R4, #+866]
    522          
    523                  BIT_SET(MclFvt_Error_List, MCI_FVT_ERROR_WRONG_OC);
   \   000002D8   0xF894 0x0364      LDRB     R0,[R4, #+868]
   \   000002DC   0xF040 0x0001      ORR      R0,R0,#0x1
   \   000002E0   0xF884 0x0364      STRB     R0,[R4, #+868]
    524          
    525          #endif
    526          
    527              }
    528          }
   \                     ??MclFvt__PwmHandler_6: (+1)
   \   000002E4   0xB002             ADD      SP,SP,#+8
   \   000002E6   0xECBD 0x8B08      VPOP     {D8-D11}
   \   000002EA   0xB001             ADD      SP,SP,#+4
   \   000002EC   0xBD30             POP      {R4,R5,PC}       ;; return
    529          
    530          
    531          
    532          
    533          //---------------------------------------------------------------------------------------------------------------------
    534          /**
    535           * Get if the guard condition to exit FVT is met.
    536           * @return TRUE: condition is met; FALSE: condition not met yet. FVT may be still running.
    537           *
    538           */

   \                                 In section .text, align 2, keep-with-next
    539          uint8 MclFvt__GuardCondition(void)
    540          {
    541              return(!BIT_TEST(MclFvt_Status, MCLFVT_STATUS_ACTIVE));
   \                     MclFvt__GuardCondition: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable96
   \   00000004   0xF890 0x0363      LDRB     R0,[R0, #+867]
   \   00000008   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000000C   0xF080 0x0001      EOR      R0,R0,#0x1
   \   00000010   0x4770             BX       LR               ;; return
    542          }
    543          
    544          
    545          
    546          
    547          //---------------------------------------------------------------------------------------------------------------------
    548          /**
    549           * Get status if FVT test sequence is finished.
    550           * @return TRUE: sequence finished; FALSE: test are still running
    551           *
    552           */

   \                                 In section .text, align 2, keep-with-next
    553          uint8 MclFvt__GetStatus(MCI_FVT_STATUS_TYPE this_status)
    554          {
    555              uint8 ret_val;
    556          
    557              ret_val = FALSE;
   \                     MclFvt__GetStatus: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    558          
    559              if(this_status == MCI_FVT_STATUS_FINISHED)
   \   00000002   0x2801             CMP      R0,#+1
   \   00000004   0xD108             BNE.N    ??MclFvt__GetStatus_0
    560              {
    561                  ret_val = (MclFvt_State == MCL_FVT_TEST_FINISHED);
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable96
   \   0000000A   0xF890 0x0362      LDRB     R0,[R0, #+866]
   \   0000000E   0x2803             CMP      R0,#+3
   \   00000010   0xBF08             IT       EQ 
    562              }
    563              else if(this_status == MCI_FVT_STATUS_STARTED)
    564              {
    565                  ret_val = TRUE;
   \   00000012   0x2101             MOVEQ    R1,#+1
    566              }
    567          
    568              return(ret_val);
   \   00000014   0x4608             MOV      R0,R1
   \   00000016   0x4770             BX       LR
   \                     ??MclFvt__GetStatus_0: (+1)
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xBF08             IT       EQ 
   \   0000001C   0x2101             MOVEQ    R1,#+1
   \   0000001E   0x4608             MOV      R0,R1
   \   00000020   0x4770             BX       LR               ;; return
    569          }
    570          
    571          
    572          
    573          
    574          //---------------------------------------------------------------------------------------------------------------------
    575          /**
    576           * Get the FVT tests. The results are updated only after finishing the tests
    577           * @param MCLFVT_TEST_RESULT_TYPE *result: pointer to the result. The caller contains the structure instance
    578           *
    579           */

   \                                 In section .text, align 4, keep-with-next
    580          void MclFvt__GetResult(MCI_FVT_TEST_RESULT_TYPE *fvt_result)
    581          {
    582              if(MclFvt_State == MCL_FVT_TEST_FINISHED)
   \                     MclFvt__GetResult: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable92
   \   00000002   0xF891 0x2362      LDRB     R2,[R1, #+866]
   \   00000006   0x2A03             CMP      R2,#+3
   \   00000008   0xD14B             BNE.N    ??MclFvt__GetResult_0
    583              {
    584                  fvt_result->Sensors_Test_Avg_Curr_A = (sint16)(1024.0f * MclFvt_Data_Test_Dc_Current.Averaged_Phase_Current_A);
   \   0000000A   0xED9F 0x....      VLDR.W   S0,??DataTable92_1  ;; 0x44800000
   \   0000000E   0xEDD1 0x0A88      VLDR     S1,[R1, #+544]
   \   00000012   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000016   0xEEFD 0x0AE0      VCVT.S32.F32 S1,S1
   \   0000001A   0xEE10 0x2A90      VMOV     R2,S1
   \   0000001E   0x8102             STRH     R2,[R0, #+8]
    585                  fvt_result->Sensors_Test_Avg_Curr_B = (sint16)(1024.0f * MclFvt_Data_Test_Dc_Current.Averaged_Phase_Current_B);
   \   00000020   0xEDD1 0x0A89      VLDR     S1,[R1, #+548]
   \   00000024   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000028   0xEEFD 0x0AE0      VCVT.S32.F32 S1,S1
   \   0000002C   0xEE10 0x2A90      VMOV     R2,S1
   \   00000030   0x8142             STRH     R2,[R0, #+10]
    586                  fvt_result->Sensors_Test_Avg_Curr_C = (sint16)(1024.0f * MclFvt_Data_Test_Dc_Current.Averaged_Phase_Current_C);
   \   00000032   0xEDD1 0x0A8A      VLDR     S1,[R1, #+552]
   \   00000036   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   0000003A   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000003E   0xEE10 0x2A10      VMOV     R2,S0
   \   00000042   0x8182             STRH     R2,[R0, #+12]
    587          
    588                  fvt_result->Sensors_Test_Avg_DC_Bus_Volt = (sint16)(64.0f * MclFvt_Data_Test_Dc_Current.Averaged_DC_Bus_Voltage);
   \   00000044   0xED9F 0x....      VLDR.W   S0,??DataTable92_2  ;; 0x42800000
   \   00000048   0xEDD1 0x0A8E      VLDR     S1,[R1, #+568]
   \   0000004C   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000050   0xEEFD 0x0AE0      VCVT.S32.F32 S1,S1
   \   00000054   0xEE10 0x2A90      VMOV     R2,S1
   \   00000058   0x8002             STRH     R2,[R0, #+0]
    589          
    590                  fvt_result->Sensors_Test_Avg_Phase_Volt_A = (sint16)(64.0f * MclFvt_Data_Test_Dc_Current.Averaged_Phase_Voltage_A);
   \   0000005A   0xEDD1 0x0A8B      VLDR     S1,[R1, #+556]
   \   0000005E   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000062   0xEEFD 0x0AE0      VCVT.S32.F32 S1,S1
   \   00000066   0xEE10 0x2A90      VMOV     R2,S1
   \   0000006A   0x8042             STRH     R2,[R0, #+2]
    591                  fvt_result->Sensors_Test_Avg_Phase_Volt_B = (sint16)(64.0f * MclFvt_Data_Test_Dc_Current.Averaged_Phase_Voltage_B);
   \   0000006C   0xEDD1 0x0A8C      VLDR     S1,[R1, #+560]
   \   00000070   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000074   0xEEFD 0x0AE0      VCVT.S32.F32 S1,S1
   \   00000078   0xEE10 0x2A90      VMOV     R2,S1
   \   0000007C   0x8082             STRH     R2,[R0, #+4]
    592                  fvt_result->Sensors_Test_Avg_Phase_Volt_C = (sint16)(64.0f * MclFvt_Data_Test_Dc_Current.Averaged_Phase_Voltage_C);
   \   0000007E   0xEDD1 0x0A8D      VLDR     S1,[R1, #+564]
   \   00000082   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   00000086   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000008A   0xEE10 0x2A10      VMOV     R2,S0
   \   0000008E   0x80C2             STRH     R2,[R0, #+6]
    593          
    594          #if defined (SURGE_RELAY_USED) && defined (SURGE_RELAY_FVT)
    595          
    596                  fvt_result->Surge_Test_Avg_DC_Bus_Volt_Open = (sint16)(64.0f * MclFvt_Data_Test_Surge_Relay.Averaged_DC_Bus_Voltage_Relay_Open);
    597                  fvt_result->Surge_Test_Avg_DC_Bus_Volt_Close = (sint16)(64.0f * MclFvt_Data_Test_Surge_Relay.Averaged_DC_Bus_Voltage_Relay_Closed);
    598          
    599          #else
    600          
    601                  fvt_result->Surge_Test_Avg_DC_Bus_Volt_Open = 0;
   \   00000090   0x2200             MOVS     R2,#+0
   \   00000092   0x81C2             STRH     R2,[R0, #+14]
    602                  fvt_result->Surge_Test_Avg_DC_Bus_Volt_Close = 0;
   \   00000094   0x8202             STRH     R2,[R0, #+16]
    603          
    604          #endif
    605          #ifdef OC_FVT
    606                  fvt_result->OC_Test_Found = MclFvt_OC_Detected;
    607          #else
    608                  fvt_result->OC_Test_Found = 0;
   \   00000096   0x7482             STRB     R2,[R0, #+18]
    609          #endif
    610          
    611                  BIT_CLR(MclFvt_Error_List, MCI_FVT_ERROR_RESULT_NO_FVT_TEST);
   \   00000098   0xF891 0x2364      LDRB     R2,[R1, #+868]
   \   0000009C   0xF002 0x02F7      AND      R2,R2,#0xF7
   \   000000A0   0xE00E             B.N      ??MclFvt__GetResult_1
    612          
    613                  fvt_result->Error_List = MclFvt_Error_List;
    614          
    615                  BIT_SET(MclFvt_Error_List, MCI_FVT_ERROR_DATA_OLD);
    616              }
    617              else
    618              {
    619                  fvt_result->Sensors_Test_Avg_Curr_A = 0;
   \                     ??MclFvt__GetResult_0: (+1)
   \   000000A2   0x2200             MOVS     R2,#+0
   \   000000A4   0x8102             STRH     R2,[R0, #+8]
    620                  fvt_result->Sensors_Test_Avg_Curr_B = 0;
   \   000000A6   0x8142             STRH     R2,[R0, #+10]
    621                  fvt_result->Sensors_Test_Avg_Curr_C = 0;
   \   000000A8   0x8182             STRH     R2,[R0, #+12]
    622          
    623                  fvt_result->Sensors_Test_Avg_DC_Bus_Volt = 0;
   \   000000AA   0x8002             STRH     R2,[R0, #+0]
    624          
    625                  fvt_result->Sensors_Test_Avg_Phase_Volt_A = 0;
   \   000000AC   0x8042             STRH     R2,[R0, #+2]
    626                  fvt_result->Sensors_Test_Avg_Phase_Volt_B = 0;
   \   000000AE   0x8082             STRH     R2,[R0, #+4]
    627                  fvt_result->Sensors_Test_Avg_Phase_Volt_C = 0;
   \   000000B0   0x80C2             STRH     R2,[R0, #+6]
    628          
    629                  fvt_result->Surge_Test_Avg_DC_Bus_Volt_Open = 0;
   \   000000B2   0x81C2             STRH     R2,[R0, #+14]
    630                  fvt_result->Surge_Test_Avg_DC_Bus_Volt_Close = 0;
   \   000000B4   0x8202             STRH     R2,[R0, #+16]
    631          
    632                  fvt_result->OC_Test_Found = FALSE;
   \   000000B6   0x7482             STRB     R2,[R0, #+18]
    633          
    634                  BIT_SET(MclFvt_Error_List, MCI_FVT_ERROR_RESULT_NO_FVT_TEST);
   \   000000B8   0xF891 0x2364      LDRB     R2,[R1, #+868]
   \   000000BC   0xF042 0x0208      ORR      R2,R2,#0x8
   \                     ??MclFvt__GetResult_1: (+1)
   \   000000C0   0xF881 0x2364      STRB     R2,[R1, #+868]
    635          
    636                  fvt_result->Error_List = MclFvt_Error_List;
   \   000000C4   0x74C2             STRB     R2,[R0, #+19]
    637          
    638                  BIT_SET(MclFvt_Error_List, MCI_FVT_ERROR_DATA_OLD);
   \   000000C6   0xF891 0x0364      LDRB     R0,[R1, #+868]
   \   000000CA   0xF040 0x0004      ORR      R0,R0,#0x4
   \   000000CE   0xF881 0x0364      STRB     R0,[R1, #+868]
    639              }
    640          }
   \   000000D2   0x4770             BX       LR               ;; return
    641          
    642          
    643          
    644          
    645          
    646          
    647          //=====================================================================================================================
    648          //-------------------------------------- Private Functions ------------------------------------------------------------
    649          //=====================================================================================================================
    650          
    651          
    652          //---------------------------------------------------------------------------------------------------------------------
    653          /**
    654           *  @brief  Performs current control
    655           */
    656          void DC_Current_Injection_Control(void)
    657          {
    658              DQ_COOR_SYST_F_TYPE manual_dq;
    659              SIN_COS_F_TYPE manual_sin_cos;
    660          
    661              // Input Processing Handler
    662              MclInputProc__RunningHandler(&Mcl_Input_Proc_IO);
    663          
    664              Mcl_DQ_Ctrl_IO.Sin_Cos = &manual_sin_cos;
    665          
    666              // Zero the forced voltage, this allows the controller to proper
    667              // generate the voltage references
    668              Mcl_DQ_Ctrl_IO.Force_Out_Volt->D = 0.0f;
    669              Mcl_DQ_Ctrl_IO.Force_Out_Volt->Q = 0.0f;
    670          
    671              // Handle the voltage target increase
    672              if(MclFvt_Injection_Inst_Level < MclFvt_Injection_Level)
    673              {
    674                  MclFvt_Injection_Inst_Level += MclFvt_Injection_Level_Rate;
    675              }
    676              else if(MclFvt_Injection_Inst_Level > MclFvt_Injection_Level)
    677              {
    678                  MclFvt_Injection_Inst_Level -= MclFvt_Injection_Level_Rate;
    679          
    680                  if(MclFvt_Injection_Inst_Level <= 0)
    681                  {
    682                      MclFvt_Injection_Inst_Level = 0.0f;
    683                  }
    684              }
    685              else
    686              {
    687                  MclFvt_Injection_Inst_Level = MclFvt_Injection_Level;
    688              }
    689          
    690          
    691              MathCalc__SinCosF(MclFvt_Injection_Position, &manual_sin_cos);
    692          
    693              manual_dq.ZeroSequence = 0.0f;
    694          
    695              ClrkPark__DirectParkF(Mcl_Input_Proc_IO.Is_Alpha_Beta, &manual_dq, &manual_sin_cos);
    696          
    697              *Mcl_DQ_Ctrl_IO.D_Ref = 0.0f;
    698              *Mcl_DQ_Ctrl_IO.D_Est = manual_dq.D;
    699          
    700              *Mcl_DQ_Ctrl_IO.Q_Ref = MclFvt_Injection_Inst_Level;
    701              *Mcl_DQ_Ctrl_IO.Q_Est = manual_dq.Q;
    702          
    703              MclDqCtrl__OverrideRegGains(&Mcl_Params_Displ1->Manual_Injection);
    704              // Dq controllers Handler
    705              MclDqCtrl__RunningHandler(&Mcl_DQ_Ctrl_IO, &Mcl_Params_Displ1->Manual_Injection);
    706          
    707              // Pwm Handler
    708              MclPwm__RunningHandler(&Mcl_Pwm_IO, &MclPwm_Params);
    709          }
    710          
    711          
    712          
    713          
    714          //---------------------------------------------------------------------------------------------------------------------
    715          /**
    716           *  @brief  Check if signal of Over Current (OC) hardware is triggered
    717           */
    718          uint8 Polls_Hw_OC(void)
    719          {
    720          #if (defined MCI_HW_OC_DEBOUNCE_TIME) && (defined MCI_HW_OC_PORT) && (defined MCI_HW_OC_PIN) && (defined MCI_HW_OC_LEVEL)
    721              static uint8 hw_oc_debouncer = (uint8)(MCI_HW_OC_DEBOUNCE_TIME/0.005f);
    722              uint8 hw_pin_in;
    723          #endif
    724          
    725              uint8 temp_u8;
    726          
    727              //////////////////////////////////////////////////////////////////////////////////////////
    728              // DC Bus (over) current monitor
    729              temp_u8 = MotorSafetyMgr__GetFault(SR_FAULT_OVER_CURRENT_TRIPPED);
    730          
    731          #if (defined MCI_HW_OC_DEBOUNCE_TIME) && (defined MCI_HW_OC_PORT) && (defined MCI_HW_OC_PIN) && (defined MCI_HW_OC_LEVEL)
    732          
    733              // Refresh input config
    734              Gpio__PinConfig(MCI_HW_OC_PORT, MCI_HW_OC_PIN, INPUT_FLOAT);
    735          
    736              // Read input oc pin
    737              hw_pin_in = Gpio__PinRead(MCI_HW_OC_PORT, MCI_HW_OC_PIN);
    738          
    739              // Debounce oc pin, if the failure is found
    740              if(hw_pin_in == MCI_HW_OC_LEVEL)
    741              {
    742                  // count up the time
    743                  if(hw_oc_debouncer < (uint8)(MCI_HW_OC_DEBOUNCE_TIME/0.005f))
    744                  {
    745                      hw_oc_debouncer++;
    746                  }
    747                  else
    748                  {
    749                      temp_u8 = TRUE;
    750                  }
    751              }
    752              else
    753              {
    754                  // count down the time
    755                  if(hw_oc_debouncer)
    756                  {
    757                      hw_oc_debouncer--;
    758                  }
    759              }
    760          
    761          #endif
    762          
    763              return(temp_u8);
    764          }
C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\Mcl\MicroBlocks\ClrkPark\ClrkPark.c
      1          /**
      2           *  @file
      3           *
      4           *  @brief      Basic description of file contents
      5           *
      6           *  @details    Direct and Inverse Clark and Park Transformation functions using MathCalc that works for the Fixed Point and floating point version.
      7           *
      8           *  @section    Applicable_Documents
      9           *					List here all the applicable documents if needed. <tr>
     10           *
     11           *  $Header: $
     12           *
     13           *  @copyright  Copyright 2015-$Date$. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     14           */
     15          //---------------------------------------------------------------------------------------------------------------------
     16          //---------------------------------------------------------------------------------------------------------------------
     17          
     18          //-------------------------------------- Include Files ----------------------------------------------------------------
     19          
     20          
     21          #include "ClrkPark.h"
     22          #include "McMathCalc_macros.h"
     23          
     24          
     25          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     26          
     27          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     28          
     29          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
     30          
     31          //=====================================================================================================================
     32          //-------------------------------------- Public Functions -------------------------------------------------------------
     33          //=====================================================================================================================
     34          
     35          
     36          
     37          //---------------------------------------------------------------------------------------------------------------------
     38          /**
     39           *  @brief      Calculate Clarke transforms.
     40           *
     41           *  @details   Clarke transformation is given by:
     42           *   \f[
     43           *      \begin{align}
     44           *         & out_{\alpha} = in_a - \frac{in_a + in_b + in_c}{3} \\
     45           *         & out_{\beta} = \frac{in_b - in_c}{\sqrt{3}} \\
     46           *         & out_0 = \frac{in_a + in_b + in_c}{3}
     47           *      \end{align}
     48           *    \f]
     49           *
     50           *  @param[in]  input   = a-b-c components
     51           *  @param[out] output  = alpha-beta-zero components
     52           *
     53           */

   \                                 In section .text, align 2, keep-with-next
     54          void ClrkPark__DirectClarke(ABC_COOR_SYST_TYPE *input , ALPHA_BETA_COOR_SYST_TYPE *output)
     55          {
     56          	output->ZeroSequence = MC_MULT((input->A + input->B + input->C) , MC_ONE_OVER_THREE, IQ15, IQ15, IQ15);
   \                     ClrkPark__DirectClarke: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x6843             LDR      R3,[R0, #+4]
   \   00000004   0x189A             ADDS     R2,R3,R2
   \   00000006   0x6883             LDR      R3,[R0, #+8]
   \   00000008   0x189A             ADDS     R2,R3,R2
   \   0000000A   0xF642 0x23AB      MOVW     R3,#+10923
   \   0000000E   0x435A             MULS     R2,R2,R3
   \   00000010   0x13D2             ASRS     R2,R2,#+15
   \   00000012   0x600A             STR      R2,[R1, #+0]
     57          	output->Alpha = input->A - output->ZeroSequence;
   \   00000014   0x6803             LDR      R3,[R0, #+0]
   \   00000016   0x1A9A             SUBS     R2,R3,R2
   \   00000018   0x604A             STR      R2,[R1, #+4]
     58          	output->Beta = MC_MULT((input->B - input->C), MC_SQRT3_INV, IQ15, IQ15, IQ15);
   \   0000001A   0x6842             LDR      R2,[R0, #+4]
   \   0000001C   0x6880             LDR      R0,[R0, #+8]
   \   0000001E   0x1A10             SUBS     R0,R2,R0
   \   00000020   0xF644 0x12E7      MOVW     R2,#+18919
   \   00000024   0x4350             MULS     R0,R0,R2
   \   00000026   0x13C0             ASRS     R0,R0,#+15
   \   00000028   0x6088             STR      R0,[R1, #+8]
     59          }
   \   0000002A   0x4770             BX       LR               ;; return
     60          
     61          
     62          
     63          /**
     64           *  @brief      Calculate Inverse Clarke transforms.
     65           *
     66           *  @details  Inverse Clarke transformation is given by:
     67           *
     68           *     \f[
     69           *         \begin{aligned}
     70           *          & out_a = in_{\alpha} + in_0 \\
     71           *          & out_b = -\frac{in_{\alpha}}{2} + \frac{in_{\beta}  \cdot \sqrt(3)}{2} + in_0 \\
     72           *          & out_c = -\frac{in_{\alpha}}{2} - \frac{in_{\beta}  \cdot \sqrt(3)}{2} + in_0
     73           *         \end{aligned}
     74           *     \f]
     75           *
     76           *  @param[in]    input     = alpha-beta-zero components
     77           *  @param[out]   output    = a-b-c components
     78           *
     79           */

   \                                 In section .text, align 2, keep-with-next
     80          void ClrkPark__InverseClarke(ALPHA_BETA_COOR_SYST_TYPE *input, ABC_COOR_SYST_TYPE *output)
     81          {
     82              output->A = input->Alpha+input->ZeroSequence;
   \                     ClrkPark__InverseClarke: (+1)
   \   00000000   0x6842             LDR      R2,[R0, #+4]
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x189A             ADDS     R2,R3,R2
   \   00000006   0x600A             STR      R2,[R1, #+0]
     83              output->B = (-input->Alpha*MC_ONE_OVER_TWO + MC_SQRT3_OVER_TWO * input->Beta);
   \   00000008   0xF646 0x62DA      MOVW     R2,#+28378
   \   0000000C   0x6843             LDR      R3,[R0, #+4]
   \   0000000E   0xF8D0 0xC008      LDR      R12,[R0, #+8]
   \   00000012   0x425B             RSBS     R3,R3,#+0
   \   00000014   0x039B             LSLS     R3,R3,#+14
   \   00000016   0xFB02 0x330C      MLA      R3,R2,R12,R3
   \   0000001A   0x604B             STR      R3,[R1, #+4]
     84              output->B = MC_SCALE(output->B, IQ30, IQ15)+input->ZeroSequence ; //No Effect in floating point
   \   0000001C   0xF8D0 0xC000      LDR      R12,[R0, #+0]
   \   00000020   0xEB0C 0x33E3      ADD      R3,R12,R3, ASR #+15
   \   00000024   0x604B             STR      R3,[R1, #+4]
     85              output->C = (-input->Alpha*MC_ONE_OVER_TWO - MC_SQRT3_OVER_TWO * input->Beta);
   \   00000026   0x6843             LDR      R3,[R0, #+4]
   \   00000028   0xF8D0 0xC008      LDR      R12,[R0, #+8]
   \   0000002C   0x425B             RSBS     R3,R3,#+0
   \   0000002E   0x039B             LSLS     R3,R3,#+14
   \   00000030   0xFB02 0x321C      MLS      R2,R2,R12,R3
   \   00000034   0x608A             STR      R2,[R1, #+8]
     86              output->C = MC_SCALE(output->C, IQ30, IQ15)+input->ZeroSequence ; //No Effect in floating point
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xEB00 0x30E2      ADD      R0,R0,R2, ASR #+15
   \   0000003C   0x6088             STR      R0,[R1, #+8]
     87          }
   \   0000003E   0x4770             BX       LR               ;; return
     88          
     89          
     90          
     91          /**
     92           *  @brief      Calculate the Direct Park Transformation and phase advance
     93           *
     94           *  @details Park transformation is given by:
     95           *			 \f[
     96           * 				\begin{aligned}
     97           * 				& out_d = in_{\alpha} * cos(\theta) + in_{\beta} * sin(\theta) \\
     98           *     			& out_q = -in_{\alpha} * sin(\theta) + in_{\beta} * cos(\theta) \\
     99           *     			& out_0 = in_0
    100           * 				\end{aligned}
    101           * 			\f]
    102           *
    103           *  @param[in]  input   = alpha-beta-zero components
    104           *  @param[in]  sincos  = sine and cosine rotating reference
    105           *  @param[out] output  = d-q-zero components
    106           */

   \                                 In section .text, align 2, keep-with-next
    107          void ClrkPark__DirectPark(ALPHA_BETA_COOR_SYST_TYPE *input ,DQ_COOR_SYST_TYPE *output ,SIN_COS_TYPE *sincos)
    108          {
   \                     ClrkPark__DirectPark: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    109              mc_sint32 tmpD;
    110              mc_sint32 tmpQ;
    111              tmpD = input->Alpha * sincos->Cos + input->Beta * sincos->Sin;
    112              tmpQ = -input->Alpha * sincos->Sin + input->Beta * sincos->Cos;
   \   00000002   0x6854             LDR      R4,[R2, #+4]
   \   00000004   0x6885             LDR      R5,[R0, #+8]
   \   00000006   0x6843             LDR      R3,[R0, #+4]
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0xFB04 0xF605      MUL      R6,R4,R5
   \   0000000E   0xFB02 0x6613      MLS      R6,R2,R3,R6
    113              output->D = MC_SCALE(tmpD, IQ30, IQ15);
   \   00000012   0x436A             MULS     R2,R2,R5
   \   00000014   0xFB04 0x2203      MLA      R2,R4,R3,R2
   \   00000018   0x13D2             ASRS     R2,R2,#+15
   \   0000001A   0x604A             STR      R2,[R1, #+4]
    114              output->Q = MC_SCALE(tmpQ, IQ30, IQ15);
   \   0000001C   0x13F2             ASRS     R2,R6,#+15
   \   0000001E   0x608A             STR      R2,[R1, #+8]
    115              output->ZeroSequence =  input->ZeroSequence;
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x6008             STR      R0,[R1, #+0]
    116          }
   \   00000024   0xBC70             POP      {R4-R6}
   \   00000026   0x4770             BX       LR               ;; return
    117          
    118          
    119          
    120          /**
    121           *  @brief      Calculate the Inverse Park Transformation
    122           *
    123           *  @details 	Inverse Park Transformation is given by
    124           *       	\f[
    125           * 				\begin{aligned}
    126           * 				& out_{\alpha} = in_d * cos(\theta) - in_q * sin(\theta) \\
    127           *      		& out_{\beta} = in_d * sin(\theta) + in_q * cos(\theta) \\
    128           *      		& out_0 = in_0
    129           * 				\end{aligned}
    130           * 			\f]
    131           *  @param[in]  input   = d-q-zero components
    132           *  @param[in]  sincos  = sine and cosine rotating reference
    133           *  @param[out] output  = alpha-beta-zero components
    134           */

   \                                 In section .text, align 2, keep-with-next
    135          void ClrkPark__InversePark(DQ_COOR_SYST_TYPE *input ,ALPHA_BETA_COOR_SYST_TYPE *output ,SIN_COS_TYPE *sincos)
    136          {
   \                     ClrkPark__InversePark: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    137              mc_sint32 tmpD;
    138              mc_sint32 tmpQ;
    139              tmpD = input->D * sincos->Cos - input->Q * sincos->Sin;
    140              tmpQ = input->D * sincos->Sin + input->Q * sincos->Cos;
   \   00000002   0x6853             LDR      R3,[R2, #+4]
   \   00000004   0x6884             LDR      R4,[R0, #+8]
   \   00000006   0x6845             LDR      R5,[R0, #+4]
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0xFB03 0xF604      MUL      R6,R3,R4
   \   0000000E   0xFB02 0x6605      MLA      R6,R2,R5,R6
    141              output->Alpha = MC_SCALE(tmpD, IQ30, IQ15);
   \   00000012   0x436B             MULS     R3,R3,R5
   \   00000014   0xFB02 0x3214      MLS      R2,R2,R4,R3
   \   00000018   0x13D2             ASRS     R2,R2,#+15
   \   0000001A   0x604A             STR      R2,[R1, #+4]
    142              output->Beta = MC_SCALE(tmpQ, IQ30, IQ15);
   \   0000001C   0x13F2             ASRS     R2,R6,#+15
   \   0000001E   0x608A             STR      R2,[R1, #+8]
    143              output->ZeroSequence =  input->ZeroSequence;
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x6008             STR      R0,[R1, #+0]
    144          }
   \   00000024   0xBC70             POP      {R4-R6}
   \   00000026   0x4770             BX       LR               ;; return
    145          
    146          
    147          //---------------------------------------------------------------------------------------------------------------------
    148          /**
    149           *  @brief      Calculate Clarke transforms.
    150           *
    151           *  @details   Clarke transformation is given by:
    152           *   \f[
    153           *      \begin{align}
    154           *         & out_{\alpha} = in_a - \frac{in_a + in_b + in_c}{3} \\
    155           *         & out_{\beta} = \frac{in_b - in_c}{\sqrt{3}} \\
    156           *         & out_0 = \frac{in_a + in_b + in_c}{3}
    157           *      \end{align}
    158           *    \f]
    159           *
    160           *  @param[in]  input   = a-b-c components
    161           *  @param[out] output  = alpha-beta-zero components
    162           *
    163           */

   \                                 In section .text, align 4, keep-with-next
    164          void ClrkPark__DirectClarkeF(ABC_COOR_SYST_F_TYPE *input, ALPHA_BETA_COOR_SYST_F_TYPE *output)
    165          {
    166              output->ZeroSequence = (input->A + input->B + input->C) * (1.0f/3.0f);
   \                     ClrkPark__DirectClarkeF: (+1)
   \   00000000   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000004   0xEDD0 0x0A01      VLDR     S1,[R0, #+4]
   \   00000008   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   0000000C   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   00000010   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   00000014   0xEDDF 0x....      VLDR.W   S1,??DataTable94  ;; 0x3eaaaaab
   \   00000018   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000001C   0xED81 0x0A00      VSTR     S0,[R1, #0]
    167              output->Alpha = input->A - output->ZeroSequence;
   \   00000020   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000024   0xEE30 0x0AC0      VSUB.F32 S0,S1,S0
   \   00000028   0xED81 0x0A01      VSTR     S0,[R1, #+4]
    168              output->Beta = (input->B - input->C)*(1.0f/1.732050807f);
   \   0000002C   0xED90 0x0A01      VLDR     S0,[R0, #+4]
   \   00000030   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   00000034   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   00000038   0xEDDF 0x....      VLDR.W   S1,??DataTable94_1  ;; 0x3f13cd3a
   \   0000003C   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000040   0xED81 0x0A02      VSTR     S0,[R1, #+8]
    169          }
   \   00000044   0x4770             BX       LR               ;; return
    170          
    171          
    172          
    173          /**
    174           *  @brief      Calculate Inverse Clarke transforms.
    175           *
    176           *  @details  Inverse Clarke transformation is given by:
    177           *
    178           *     \f[
    179           *         \begin{aligned}
    180           *          & out_a = in_{\alpha} + in_0 \\
    181           *          & out_b = -\frac{in_{\alpha}}{2} + \frac{in_{\beta}  \cdot \sqrt(3)}{2} + in_0 \\
    182           *          & out_c = -\frac{in_{\alpha}}{2} - \frac{in_{\beta}  \cdot \sqrt(3)}{2} + in_0
    183           *         \end{aligned}
    184           *     \f]
    185           *
    186           *  @param[in]    input     = alpha-beta-zero components
    187           *  @param[out]   output    = a-b-c components
    188           *
    189           */

   \                                 In section .text, align 4, keep-with-next
    190          void ClrkPark__InverseClarkeF(ALPHA_BETA_COOR_SYST_F_TYPE *input, ABC_COOR_SYST_F_TYPE *output)
    191          {
    192              output->A = input->Alpha+input->ZeroSequence;
   \                     ClrkPark__InverseClarkeF: (+1)
   \   00000000   0xED90 0x0A01      VLDR     S0,[R0, #+4]
   \   00000004   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000008   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   0000000C   0xED81 0x0A00      VSTR     S0,[R1, #0]
    193              output->B = (-input->Alpha/(2.0f) + input->Beta*(1.732050807f/2.0f)) + input->ZeroSequence;
   \   00000010   0xEEFE 0x0A00      VMOV.F32 S1,#-0.5
   \   00000014   0xED90 0x1A01      VLDR     S2,[R0, #+4]
   \   00000018   0xEDD0 0x1A02      VLDR     S3,[R0, #+8]
   \   0000001C   0xED9F 0x....      VLDR.W   S0,??DataTable95  ;; 0x3f5db3d7
   \   00000020   0xEE21 0x1A20      VMUL.F32 S2,S2,S1
   \   00000024   0xEE01 0x1A80      VMLA.F32 S2,S3,S0
   \   00000028   0xEDD0 0x1A00      VLDR     S3,[R0, #0]
   \   0000002C   0xEE31 0x1A21      VADD.F32 S2,S2,S3
   \   00000030   0xED81 0x1A01      VSTR     S2,[R1, #+4]
    194              output->C = (-input->Alpha/(2.0f) - input->Beta*(1.732050807f/2.0f)) + input->ZeroSequence;
   \   00000034   0xED90 0x1A01      VLDR     S2,[R0, #+4]
   \   00000038   0xEE61 0x0A20      VMUL.F32 S1,S2,S1
   \   0000003C   0xED90 0x1A02      VLDR     S2,[R0, #+8]
   \   00000040   0xEE41 0x0A40      VMLS.F32 S1,S2,S0
   \   00000044   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000048   0xEE30 0x0A80      VADD.F32 S0,S1,S0
   \   0000004C   0xED81 0x0A02      VSTR     S0,[R1, #+8]
    195          }
   \   00000050   0x4770             BX       LR               ;; return
    196          
    197          
    198          
    199          /**
    200           *  @brief      Calculate the Direct Park Transformation and phase advance
    201           *
    202           *  @details Park transformation is given by:
    203           *           \f[
    204           *              \begin{aligned}
    205           *              & out_d = in_{\alpha} * cos(\theta) + in_{\beta} * sin(\theta) \\
    206           *              & out_q = -in_{\alpha} * sin(\theta) + in_{\beta} * cos(\theta) \\
    207           *              & out_0 = in_0
    208           *              \end{aligned}
    209           *          \f]
    210           *
    211           *  @param[in]  input   = alpha-beta-zero components
    212           *  @param[in]  sincos  = sine and cosine rotating reference
    213           *  @param[out] output  = d-q-zero components
    214           */

   \                                 In section .text, align 2, keep-with-next
    215          void ClrkPark__DirectParkF(ALPHA_BETA_COOR_SYST_F_TYPE *input, DQ_COOR_SYST_F_TYPE *output, SIN_COS_F_TYPE *sincos)
    216          {
    217              output->D = input->Alpha * sincos->Cos + input->Beta * sincos->Sin;
   \                     ClrkPark__DirectParkF: (+1)
   \   00000000   0xED90 0x0A01      VLDR     S0,[R0, #+4]
   \   00000004   0xEDD2 0x0A01      VLDR     S1,[R2, #+4]
   \   00000008   0xED92 0x1A00      VLDR     S2,[R2, #0]
   \   0000000C   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000010   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   00000014   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   \   00000018   0xED81 0x0A01      VSTR     S0,[R1, #+4]
    218              output->Q = -input->Alpha * sincos->Sin + input->Beta * sincos->Cos;
   \   0000001C   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   00000020   0xEDD2 0x0A01      VLDR     S1,[R2, #+4]
   \   00000024   0xED92 0x1A00      VLDR     S2,[R2, #0]
   \   00000028   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000002C   0xEDD0 0x0A01      VLDR     S1,[R0, #+4]
   \   00000030   0xEE00 0x0AC1      VMLS.F32 S0,S1,S2
   \   00000034   0xED81 0x0A02      VSTR     S0,[R1, #+8]
    219              output->ZeroSequence =  input->ZeroSequence;
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    220          }
   \   0000003C   0x4770             BX       LR               ;; return
    221          
    222          
    223          
    224          /**
    225           *  @brief      Calculate the Inverse Park Transformation
    226           *
    227           *  @details    Inverse Park Transformation is given by
    228           *          \f[
    229           *              \begin{aligned}
    230           *              & out_{\alpha} = in_d * cos(\theta) - in_q * sin(\theta) \\
    231           *              & out_{\beta} = in_d * sin(\theta) + in_q * cos(\theta) \\
    232           *              & out_0 = in_0
    233           *              \end{aligned}
    234           *          \f]
    235           *  @param[in]  input   = d-q-zero components
    236           *  @param[in]  sincos  = sine and cosine rotating reference
    237           *  @param[out] output  = alpha-beta-zero components
    238           */

   \                                 In section .text, align 2, keep-with-next
    239          void ClrkPark__InverseParkF(DQ_COOR_SYST_F_TYPE *input, ALPHA_BETA_COOR_SYST_F_TYPE *output, SIN_COS_F_TYPE *sincos)
    240          {
    241              output->Alpha = input->D * sincos->Cos - input->Q * sincos->Sin;
   \                     ClrkPark__InverseParkF: (+1)
   \   00000000   0xED90 0x0A01      VLDR     S0,[R0, #+4]
   \   00000004   0xEDD2 0x0A01      VLDR     S1,[R2, #+4]
   \   00000008   0xED92 0x1A00      VLDR     S2,[R2, #0]
   \   0000000C   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000010   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   00000014   0xEE00 0x0AC1      VMLS.F32 S0,S1,S2
   \   00000018   0xED81 0x0A01      VSTR     S0,[R1, #+4]
    242              output->Beta = input->D * sincos->Sin + input->Q * sincos->Cos;
   \   0000001C   0xED90 0x0A01      VLDR     S0,[R0, #+4]
   \   00000020   0xEDD2 0x0A00      VLDR     S1,[R2, #0]
   \   00000024   0xED92 0x1A01      VLDR     S2,[R2, #+4]
   \   00000028   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000002C   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   00000030   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   \   00000034   0xED81 0x0A02      VSTR     S0,[R1, #+8]
    243              output->ZeroSequence =  input->ZeroSequence;
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    244          }
   \   0000003C   0x4770             BX       LR               ;; return
    245          
    246          //=====================================================================================================================
    247          //-------------------------------------- Private Functions ------------------------------------------------------------
    248          //=====================================================================================================================
    249          
C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\Mcl\MicroBlocks\Filters\Filters.c
      1          /**
      2           *  @file
      3           *  @brief      Basic description of file contents
      4           *
      5           *  $Header: $
      6           *
      7           *
      8           *  @copyright  Copyright 2015-$Date$. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
      9           */
     10          
     11          //-------------------------------------- Include Files ----------------------------------------------------------------
     12          #include "Filters.h"
     13          #include "McMathCalc_macros.h"
     14          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     15          
     16          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     17          
     18          
     19          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
     20          
     21          
     22          
     23          //=====================================================================================================================
     24          //-------------------------------------- Public Functions -------------------------------------------------------------
     25          //=====================================================================================================================
     26          
     27          /**
     28           * Calculates the moving average based on the parameters passed to this method.
     29           * @param moving_avg pointer.
     30           * @return the last averaged sample
     31           */

   \                                 In section .text, align 2, keep-with-next
     32          uint16 Filters__MovingAverageShort(MOVING_AVG_TYPE *data, sint16 new_sample)
     33          {
   \                     Filters__MovingAverageShort: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
     34              uint32 sum = 0;
     35              uint16 temp;
     36          
     37              if(data->sample_index < data->nr_samples)
   \   00000002   0x8903             LDRH     R3,[R0, #+8]
   \   00000004   0x8944             LDRH     R4,[R0, #+10]
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x42A3             CMP      R3,R4
   \   0000000A   0xD23A             BCS.N    ??Filters__MovingAverageShort_0
     38              {
     39                  data->mvg_avg_pointer[data->sample_index] = new_sample;
   \   0000000C   0x6844             LDR      R4,[R0, #+4]
   \   0000000E   0xF824 0x1013      STRH     R1,[R4, R3, LSL #+1]
     40          
     41                  data->sample_index++;
   \   00000012   0x8901             LDRH     R1,[R0, #+8]
     42                  if(data->sample_index < data->nr_samples)
   \   00000014   0x8943             LDRH     R3,[R0, #+10]
   \   00000016   0x1C49             ADDS     R1,R1,#+1
   \   00000018   0xB289             UXTH     R1,R1
   \   0000001A   0x4299             CMP      R1,R3
   \   0000001C   0xBF38             IT       CC 
     43                  {
     44                      data->sample_index = 0;
   \   0000001E   0x2100             MOVCC    R1,#+0
   \   00000020   0x8101             STRH     R1,[R0, #+8]
     45                  }
     46          
     47                  for(temp = 0; temp < data->nr_samples; temp++)
   \   00000022   0x2400             MOVS     R4,#+0
   \   00000024   0x0019             MOVS     R1,R3
   \   00000026   0xD027             BEQ.N    ??Filters__MovingAverageShort_1
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0xF013 0x0503      ANDS     R5,R3,#0x3
   \   0000002E   0xD007             BEQ.N    ??Filters__MovingAverageShort_2
     48                  {
     49                      sum += data->mvg_avg_pointer[temp];
   \                     ??Filters__MovingAverageShort_3: (+1)
   \   00000030   0xB2A4             UXTH     R4,R4
   \   00000032   0xF830 0x6014      LDRH     R6,[R0, R4, LSL #+1]
   \   00000036   0x1C64             ADDS     R4,R4,#+1
   \   00000038   0xFA12 0xF286      UXTAH    R2,R2,R6
   \   0000003C   0x1E6D             SUBS     R5,R5,#+1
   \   0000003E   0xD1F7             BNE.N    ??Filters__MovingAverageShort_3
   \                     ??Filters__MovingAverageShort_2: (+1)
   \   00000040   0x089B             LSRS     R3,R3,#+2
   \   00000042   0xD019             BEQ.N    ??Filters__MovingAverageShort_1
   \                     ??Filters__MovingAverageShort_4: (+1)
   \   00000044   0xB2A4             UXTH     R4,R4
   \   00000046   0xF830 0x5014      LDRH     R5,[R0, R4, LSL #+1]
   \   0000004A   0x1C64             ADDS     R4,R4,#+1
   \   0000004C   0xFA12 0xF285      UXTAH    R2,R2,R5
   \   00000050   0xB2A4             UXTH     R4,R4
   \   00000052   0xF830 0x5014      LDRH     R5,[R0, R4, LSL #+1]
   \   00000056   0x1C64             ADDS     R4,R4,#+1
   \   00000058   0xFA12 0xF285      UXTAH    R2,R2,R5
   \   0000005C   0xB2A4             UXTH     R4,R4
   \   0000005E   0xF830 0x5014      LDRH     R5,[R0, R4, LSL #+1]
   \   00000062   0x1C64             ADDS     R4,R4,#+1
   \   00000064   0xFA12 0xF285      UXTAH    R2,R2,R5
   \   00000068   0xB2A4             UXTH     R4,R4
   \   0000006A   0xF830 0x5014      LDRH     R5,[R0, R4, LSL #+1]
     50                  }
   \   0000006E   0x1C64             ADDS     R4,R4,#+1
   \   00000070   0xFA12 0xF285      UXTAH    R2,R2,R5
   \   00000074   0x1E5B             SUBS     R3,R3,#+1
   \   00000076   0xD1E5             BNE.N    ??Filters__MovingAverageShort_4
     51          
     52                  temp = (uint16)(sum / data->nr_samples);
     53              }
     54              else
     55              {
     56                  temp = 0;
     57              }
     58          
     59          
     60              return(temp);
   \                     ??Filters__MovingAverageShort_1: (+1)
   \   00000078   0xBC70             POP      {R4-R6}
   \   0000007A   0xFBB2 0xF0F1      UDIV     R0,R2,R1
   \   0000007E   0xB280             UXTH     R0,R0
   \   00000080   0x4770             BX       LR
   \                     ??Filters__MovingAverageShort_0: (+1)
   \   00000082   0xBC70             POP      {R4-R6}
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xB280             UXTH     R0,R0
   \   00000088   0x4770             BX       LR               ;; return
     61          }
     62          
     63          /**
     64           * Calculates the moving average with unsigned parameters based on the parameters passed to this method.
     65           * @param moving_avg pointer.
     66           * @return the last averaged sample
     67           */

   \                                 In section .text, align 2, keep-with-next
     68          uint16 Filters__MovAvgUShort(USHORT_MOVING_AVG_TYPE *data, uint16 new_sample)
     69          {
   \                     Filters__MovAvgUShort: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
     70              uint32 sum = 0;
     71              uint16 temp;
     72          
     73              if(data->sample_index < data->nr_samples)
   \   00000002   0x8903             LDRH     R3,[R0, #+8]
   \   00000004   0x8944             LDRH     R4,[R0, #+10]
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x42A3             CMP      R3,R4
   \   0000000A   0xD23A             BCS.N    ??Filters__MovAvgUShort_0
     74              {
     75                  data->mvg_avg_pointer[data->sample_index] = new_sample;
   \   0000000C   0x6844             LDR      R4,[R0, #+4]
   \   0000000E   0xF824 0x1013      STRH     R1,[R4, R3, LSL #+1]
     76          
     77                  data->sample_index++;
   \   00000012   0x8901             LDRH     R1,[R0, #+8]
     78                  if(data->sample_index < data->nr_samples)
   \   00000014   0x8943             LDRH     R3,[R0, #+10]
   \   00000016   0x1C49             ADDS     R1,R1,#+1
   \   00000018   0xB289             UXTH     R1,R1
   \   0000001A   0x4299             CMP      R1,R3
   \   0000001C   0xBF38             IT       CC 
     79                  {
     80                      data->sample_index = 0;
   \   0000001E   0x2100             MOVCC    R1,#+0
   \   00000020   0x8101             STRH     R1,[R0, #+8]
     81                  }
     82          
     83                  for(temp = 0; temp < data->nr_samples; temp++)
   \   00000022   0x2400             MOVS     R4,#+0
   \   00000024   0x0019             MOVS     R1,R3
   \   00000026   0xD027             BEQ.N    ??Filters__MovAvgUShort_1
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0xF013 0x0503      ANDS     R5,R3,#0x3
   \   0000002E   0xD007             BEQ.N    ??Filters__MovAvgUShort_2
     84                  {
     85                      sum += data->mvg_avg_pointer[temp];
   \                     ??Filters__MovAvgUShort_3: (+1)
   \   00000030   0xB2A4             UXTH     R4,R4
   \   00000032   0xF830 0x6014      LDRH     R6,[R0, R4, LSL #+1]
   \   00000036   0x1C64             ADDS     R4,R4,#+1
   \   00000038   0xFA12 0xF286      UXTAH    R2,R2,R6
   \   0000003C   0x1E6D             SUBS     R5,R5,#+1
   \   0000003E   0xD1F7             BNE.N    ??Filters__MovAvgUShort_3
   \                     ??Filters__MovAvgUShort_2: (+1)
   \   00000040   0x089B             LSRS     R3,R3,#+2
   \   00000042   0xD019             BEQ.N    ??Filters__MovAvgUShort_1
   \                     ??Filters__MovAvgUShort_4: (+1)
   \   00000044   0xB2A4             UXTH     R4,R4
   \   00000046   0xF830 0x5014      LDRH     R5,[R0, R4, LSL #+1]
   \   0000004A   0x1C64             ADDS     R4,R4,#+1
   \   0000004C   0xFA12 0xF285      UXTAH    R2,R2,R5
   \   00000050   0xB2A4             UXTH     R4,R4
   \   00000052   0xF830 0x5014      LDRH     R5,[R0, R4, LSL #+1]
   \   00000056   0x1C64             ADDS     R4,R4,#+1
   \   00000058   0xFA12 0xF285      UXTAH    R2,R2,R5
   \   0000005C   0xB2A4             UXTH     R4,R4
   \   0000005E   0xF830 0x5014      LDRH     R5,[R0, R4, LSL #+1]
   \   00000062   0x1C64             ADDS     R4,R4,#+1
   \   00000064   0xFA12 0xF285      UXTAH    R2,R2,R5
   \   00000068   0xB2A4             UXTH     R4,R4
   \   0000006A   0xF830 0x5014      LDRH     R5,[R0, R4, LSL #+1]
     86                  }
   \   0000006E   0x1C64             ADDS     R4,R4,#+1
   \   00000070   0xFA12 0xF285      UXTAH    R2,R2,R5
   \   00000074   0x1E5B             SUBS     R3,R3,#+1
   \   00000076   0xD1E5             BNE.N    ??Filters__MovAvgUShort_4
     87          
     88                  temp = (uint16)(sum / data->nr_samples);
     89              }
     90              else
     91              {
     92                  temp = 0;
     93              }
     94          
     95          
     96              return(temp);
   \                     ??Filters__MovAvgUShort_1: (+1)
   \   00000078   0xBC70             POP      {R4-R6}
   \   0000007A   0xFBB2 0xF0F1      UDIV     R0,R2,R1
   \   0000007E   0xB280             UXTH     R0,R0
   \   00000080   0x4770             BX       LR
   \                     ??Filters__MovAvgUShort_0: (+1)
   \   00000082   0xBC70             POP      {R4-R6}
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xB280             UXTH     R0,R0
   \   00000088   0x4770             BX       LR               ;; return
     97          }
     98          
     99          
    100          // From Horacio

   \                                 In section .text, align 2, keep-with-next
    101          mc_sint32 Filters__SimpleLpf(mc_sint32 x, mc_sint32 y, uint16 shift)
    102          {
    103              mc_sint64 sum;
    104              sum = y - MC_DIV_SH(y,shift) + x;
    105              return (sint32)(MC_DIV_SH(sum,shift));
   \                     Filters__SimpleLpf: (+1)
   \   00000000   0xFA41 0xF302      ASR      R3,R1,R2
   \   00000004   0x1AC9             SUBS     R1,R1,R3
   \   00000006   0x1840             ADDS     R0,R0,R1
   \   00000008   0x17C1             ASRS     R1,R0,#+31
   \   0000000A   0x.... 0x....      B.W      __aeabi_lasr
    106          
    107          }
    108          
    109          //---------------------------------------------------------------------------------------------------------------------
    110          /**
    111           *  @brief      FIR Filter
    112           *  @details    The implemented FIR Filter has power of 2 number of taps
    113           *
    114           *
    115           *  @param[in]  buffer  = FIR filter buffer; elements are in Q17.15 notation
    116           *  @return     filtered output in Q17.15 format
    117           */

   \                                 In section .text, align 4, keep-with-next
    118          mc_sint32 Filters__FIRFilter(mc_sint32 *buffer, FIR_TAPS_TYPE *samples)
    119          {
   \                     Filters__FIRFilter: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    120              mc_sint32  accumulator;
    121              uint8   i;
    122              mc_sint32  y;
    123          
    124              accumulator = 0;
    125              // accumulate all the samples
    126              for (i=0; i<samples->Value; i++)
   \   00000002   0x780C             LDRB     R4,[R1, #+0]
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xF05F 0x0300      MOVS.W   R3,#+0
   \   0000000A   0xB1DC             CBZ.N    R4,??Filters__FIRFilter_0
    127              {
    128                  accumulator += buffer[i];
   \                     ??Filters__FIRFilter_1: (+1)
   \   0000000C   0xF850 0x5023      LDR      R5,[R0, R3, LSL #+2]
   \   00000010   0x1C5B             ADDS     R3,R3,#+1
   \   00000012   0x18AA             ADDS     R2,R5,R2
   \   00000014   0xB2DB             UXTB     R3,R3
   \   00000016   0x42A3             CMP      R3,R4
   \   00000018   0xD214             BCS.N    ??Filters__FIRFilter_0
   \   0000001A   0xF850 0x5023      LDR      R5,[R0, R3, LSL #+2]
   \   0000001E   0x1C5B             ADDS     R3,R3,#+1
   \   00000020   0x18AA             ADDS     R2,R5,R2
   \   00000022   0xB2DB             UXTB     R3,R3
   \   00000024   0x42A3             CMP      R3,R4
   \   00000026   0xD20D             BCS.N    ??Filters__FIRFilter_0
   \   00000028   0xF850 0x5023      LDR      R5,[R0, R3, LSL #+2]
   \   0000002C   0x1C5B             ADDS     R3,R3,#+1
   \   0000002E   0x18AA             ADDS     R2,R5,R2
   \   00000030   0xB2DB             UXTB     R3,R3
   \   00000032   0x42A3             CMP      R3,R4
   \   00000034   0xD206             BCS.N    ??Filters__FIRFilter_0
   \   00000036   0xF850 0x5023      LDR      R5,[R0, R3, LSL #+2]
    129              }
   \   0000003A   0x1C5B             ADDS     R3,R3,#+1
   \   0000003C   0x18AA             ADDS     R2,R5,R2
   \   0000003E   0xB2DB             UXTB     R3,R3
   \   00000040   0x42A3             CMP      R3,R4
   \   00000042   0xD3E3             BCC.N    ??Filters__FIRFilter_1
    130          
    131              // divide for the number of taps (>> TapsLog) to get the new filtered samples
    132              y = MC_DIV_SH(accumulator,(samples->Log));
    133          
    134              return(y);
   \                     ??Filters__FIRFilter_0: (+1)
   \   00000044   0xF991 0x0001      LDRSB    R0,[R1, #+1]
   \   00000048   0xBC30             POP      {R4,R5}
   \   0000004A   0xFA42 0xF000      ASR      R0,R2,R0
   \   0000004E   0x4770             BX       LR               ;; return
    135          }
    136          
    137          
    138          //---------------------------------------------------------------------------------------------------------------------
    139          /**
    140           *  @brief      First Order Direct Form 1 IIR Filter
    141           *  @details    The initialization of the buffers of the IIR Filter
    142           *
    143           *
    144           *  @param[in]  params  = IIR filter parameters (coefficients and buffers)
    145           *  @return     void
    146           */

   \                                 In section .text, align 2, keep-with-next
    147          void Filters__IIR1Init(IIR1_TYPE *params)
    148          {
    149              params->x_1 = (mc_sint32)0;
   \                     Filters__IIR1Init: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6101             STR      R1,[R0, #+16]
    150              params->y_1 = (mc_sint32)0;
   \   00000004   0x60C1             STR      R1,[R0, #+12]
    151          }
   \   00000006   0x4770             BX       LR               ;; return
    152          
    153          
    154          //---------------------------------------------------------------------------------------------------------------------
    155          /**
    156           *  @brief      First-Order Direct Form 1 IIR Filter
    157           *  @details    The implementation of the IIR Filter
    158           *   Filter equation:
    159           *   y(n) = b0*x(n) + b1*x(n-1) - a1*y(n-1)
    160           *   overflow may occur in case x or y are large numbers [fractional implementation (b*x) > 2 or (a*y)>2 ]
    161           *  @param[in]  x  = IIR filter input
    162           *  @param[in]  params  = IIR filter parameters (coefficients and buffers)
    163           *  @return     void
    164           */

   \                                 In section .text, align 2, keep-with-next
    165          mc_sint32 Filters__IIR1(mc_sint32 x, IIR1_TYPE *params)
    166          {
    167              mc_sint32 y;
    168          
    169              // calculate the new output
    170              y = (mc_sint64)MC_MULT(params->coeff.b0,x,IQ15,IQ15,IQ30) + (mc_sint64)MC_MULT(params->coeff.b1,params->x_1,IQ15,IQ15,IQ30) \
    171                   - (mc_sint64)MC_MULT(params->coeff.a1,params->y_1,IQ15,IQ15,IQ30);
   \                     Filters__IIR1: (+1)
   \   00000000   0x684B             LDR      R3,[R1, #+4]
   \   00000002   0xF8D1 0xC010      LDR      R12,[R1, #+16]
   \   00000006   0x680A             LDR      R2,[R1, #+0]
   \   00000008   0xFB03 0xF30C      MUL      R3,R3,R12
   \   0000000C   0xFB00 0x3202      MLA      R2,R0,R2,R3
   \   00000010   0x688B             LDR      R3,[R1, #+8]
   \   00000012   0xF8D1 0xC00C      LDR      R12,[R1, #+12]
   \   00000016   0xFB0C 0x2213      MLS      R2,R12,R3,R2
    172          
    173              // saturate if needed
    174              y = MATHCALC__SATURATE(MC_MINUS_ONE_IQ30, y, MC_ONE_IQ30);
   \   0000001A   0xF1B2 0x4F80      CMP      R2,#+1073741824
   \   0000001E   0xBFA8             IT       GE 
   \   00000020   0xF44F 0x4200      MOVGE    R2,#+32768
   \   00000024   0xDA05             BGE.N    ??Filters__IIR1_0
   \   00000026   0xF1B2 0x4F40      CMP      R2,#-1073741824
   \   0000002A   0xBFD4             ITE      LE 
   \   0000002C   0x.... 0x....      LDRLE.W  R2,??DataTable104_6  ;; 0xffff8000
   \   00000030   0x13D2             ASRGT    R2,R2,#+15
    175          
    176              y = MC_SCALE(y,IQ30,IQ15);
    177              // save old input and output
    178              params->x_1 = x;
   \                     ??Filters__IIR1_0: (+1)
   \   00000032   0x6108             STR      R0,[R1, #+16]
    179              params->y_1 = y;
   \   00000034   0x60CA             STR      R2,[R1, #+12]
    180              return(y);
   \   00000036   0x4610             MOV      R0,R2
   \   00000038   0x4770             BX       LR               ;; return
    181          
    182          }
    183          
    184          
    185          //---------------------------------------------------------------------------------------------------------------------
    186          /**
    187           *  @brief      First Order Direct Form 1 IIR Filter
    188           *  @details    The initialization of the buffers of the IIR Filter
    189           *
    190           *
    191           *  @param[in]  params  = IIR filter parameters (coefficients and buffers)
    192           *  @return     void
    193           */

   \                                 In section .text, align 2, keep-with-next
    194          void Filters__IIR1InitF(IIR1_F_TYPE *params)
    195          {
    196              params->x_1 = 0.0f;
   \                     Filters__IIR1InitF: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6101             STR      R1,[R0, #+16]
    197              params->y_1 = 0.0f;
   \   00000004   0x60C1             STR      R1,[R0, #+12]
    198          }
   \   00000006   0x4770             BX       LR               ;; return
    199          
    200          
    201          //---------------------------------------------------------------------------------------------------------------------
    202          /**
    203           *  @brief      First-Order Direct Form 1 IIR Filter
    204           *  @details    The implementation of the IIR Filter
    205           *   Filter equation:
    206           *   y(n) = b0*x(n) + b1*x(n-1) - a1*y(n-1)
    207           *   overflow may occur in case x or y are large numbers [fractional implementation (b*x) > 2 or (a*y)>2 ]
    208           *  @param[in]  x  = IIR filter input
    209           *  @param[in]  params  = IIR filter parameters (coefficients and buffers)
    210           *  @return     void
    211           */

   \                                 In section .text, align 2, keep-with-next
    212          float32 Filters__IIR1F(float32 x, IIR1_F_TYPE *params)
    213          {
    214              float32 y;
    215          
    216              // calculate the new output
    217              y = params->coeff.b0 * x + params->coeff.b1 * params->x_1 - params->coeff.a1 * params->y_1;
   \                     Filters__IIR1F: (+1)
   \   00000000   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000004   0xED90 0x1A01      VLDR     S2,[R0, #+4]
   \   00000008   0xEDD0 0x1A04      VLDR     S3,[R0, #+16]
   \   0000000C   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000010   0xEE41 0x0A21      VMLA.F32 S1,S2,S3
   \   00000014   0xED90 0x1A02      VLDR     S2,[R0, #+8]
   \   00000018   0xEDD0 0x1A03      VLDR     S3,[R0, #+12]
    218          
    219              // save old input and output
    220              params->x_1 = x;
   \   0000001C   0xED80 0x0A04      VSTR     S0,[R0, #+16]
   \   00000020   0xEE41 0x0A61      VMLS.F32 S1,S2,S3
    221              params->y_1 = y;
   \   00000024   0xEDC0 0x0A03      VSTR     S1,[R0, #+12]
    222          
    223              return(y);
   \   00000028   0xEEB0 0x0A60      VMOV.F32 S0,S1
   \   0000002C   0x4770             BX       LR               ;; return
    224          }
    225          
C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\Mcl\MicroBlocks\Math\MathCalc.c
      1          /**
      2           *  @file
      3           *  @brief      MathCalc module performs basic mathematical operations, this is a support module for the MCI.
      4           *
      5           *  @details    Detailed description of the file contents
      6           *
      7           *  $Header: $
      8           *
      9           *  @copyright  Copyright 2015-$Date$. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     10           *
     11           */
     12          
     13          //-------------------------------------- Include Files ----------------------------------------------------------------
     14          #include "MathCalc.h"
     15          #include "C_Extensions.h"
     16          #include "FloatConstants.h"
     17          #include <math.h>
     18          
     19          #if ((__ICCARM__ == 1) && (__CORE__ == __ARM7EM__))  //  ARM IAR Compiler && CortexM4
     20          #include <arm_math.h>
     21          #endif
     22          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     23          
     24          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     25          // Taylor coefficients for sine function (7th order approximation)
     26          //  The coefficients are scaled and divided by two to avoid overflow
     27          #define A1  0xC910      //!< \f$ a_1 = \frac{\pi}{2}         =  1.570796327 \f$ in Q17.15 notation
     28                                  //!< fractional 1st order coefficient for Taylor sin approximation
     29          
     30          #define A3  0xFFFFAD51      //!< \f$ a_3 = \frac{-\pi^3}{3!\cdot2^3} = -0.645964098 \f$ in Q17.15 notation
     31                                  //!< fractional 3rd order coefficient for Taylor sin approximation
     32          
     33          #define A5  0x0A33      //!< \f$ a_5 = \frac{\pi^5}{5!\cdot2^5}  =  0.079692626 \f$ in Q17.15 notation
     34                                  //!< fractional 5th order coefficient for Taylor sin approximation
     35          
     36          #define A7  0xFFFFFF67      //!< \f$ a_7 = \frac{-\pi^7}{7!\cdot2^7} = -0.004681754 \f$ in Q17.15 notation
     37                                  //!< fractional 7th order coefficient for Taylor sin approximation
     38          
     39          
     40          #define PI_2        0x4000     //!< \f$ \frac{\pi}{2} \f$ in Q1.15 notation
     41          #define MINUS_PI_2  0xC000     //!< \f$ \frac{-\pi}{2} \f$ in Q1.15 notation
     42          #define ONE         0x7FFF     //!<  1 in Q17.15 notation
     43          #define MINUS_ONE   0xFFFF8000     //!< -1 in Q17.15 notation
     44          
     45          
     46          #ifndef PI
     47              #define PI 3.1415926535897932384626433832795f
     48          #endif
     49          
     50          
     51          #ifndef RAD_2_DEG
     52              #define RAD_2_DEG 57.295779513082320876798154814105f   //180/pi_greco
     53          #endif
     54          
     55          #define EPSILON_FLOAT32         2.0f * 1.1920928955078125e-7
     56          
     57          
     58          #define ATAN2_ITERATION_NR      8   //!< Sets the number of Atan2 iterations.
     59          #define ATAN2_USE_FOR_LOOP      0   //!< 1 - use "for" loop (memory size); 0 - expands the iterations in sequence (speed)
     60          
     61          
     62          
     63          
     64          
     65          
     66          
     67          // This lookup table was started in Excel spreadsheet, but it some of its entries were changed properly to fit
     68          // the error within +-0.3% range. Each single entry was simulated.

   \                                 In section .text, align 4, keep-with-next
     69          const sint16 SquareRootTable[] = {
   \                     SquareRootTable:
   \   00000000   0x04B0 0x0834      DC16 1200, 2100, 2300, 2700, 6451, 7066, 7633, 8160, 8655, 9123, 9568
   \              0x08FC 0x0A8C
   \              0x1933 0x1B9A
   \              0x1DD1 0x1FE0
   \              0x21CF 0x23A3
   \              0x2560       
   \   00000016   0x270A 0x28A2      DC16 9994, 10402, 10794, 11173, 11540, 11895, 12240, 12575, 12902
   \              0x2A2A 0x2BA5
   \              0x2D14 0x2E77
   \              0x2FD0 0x311F
   \              0x3266       
   \   00000028   0x33A5 0x34DC      DC16 13221, 13532, 13836, 14133, 14425, 14710, 14991, 15266, 15536
   \              0x360C 0x3735
   \              0x3859 0x3976
   \              0x3A8F 0x3BA2
   \              0x3CB0       
   \   0000003A   0x3DBA 0x3EBF      DC16 15802, 16063, 16320, 16573, 16822, 17068, 17310, 17549, 17784
   \              0x3FC0 0x40BD
   \              0x41B6 0x42AC
   \              0x439E 0x448D
   \              0x4578       
   \   0000004C   0x4661 0x4746      DC16 18017, 18246, 18473, 18697, 18918, 19137, 19353, 19567, 19778
   \              0x4829 0x4909
   \              0x49E6 0x4AC1
   \              0x4B99 0x4C6F
   \              0x4D42       
   \   0000005E   0x4E14 0x4EE3      DC16 19988, 20195, 20400, 20603, 20804, 21003, 21200, 21396, 21589
   \              0x4FB0 0x507B
   \              0x5144 0x520B
   \              0x52D0 0x5394
   \              0x5455       
   \   00000070   0x5515 0x55D3      DC16 21781, 21971, 22160, 22347, 22533, 22716, 22899, 23080, 23260
   \              0x5690 0x574B
   \              0x5805 0x58BC
   \              0x5973 0x5A28
   \              0x5ADC       
   \   00000082   0x5B8E 0x5C3F      DC16 23438, 23615, 23790, 23965, 24138, 24309, 24480, 24649, 24818
   \              0x5CEE 0x5D9D
   \              0x5E4A 0x5EF5
   \              0x5FA0 0x6049
   \              0x60F2       
   \   00000094   0x6199 0x623F      DC16 24985, 25151, 25316, 25480, 25642, 25804, 25965, 26125, 26284
   \              0x62E4 0x6388
   \              0x642A 0x64CC
   \              0x656D 0x660D
   \              0x66AC       
   \   000000A6   0x674A 0x67E6      DC16 26442, 26598, 26754, 26910, 27064, 27217, 27370, 27521, 27672
   \              0x6882 0x691E
   \              0x69B8 0x6A51
   \              0x6AEA 0x6B81
   \              0x6C18       
   \   000000B8   0x6CAE 0x6D43      DC16 27822, 27971, 28120, 28267, 28414, 28560, 28705, 28850, 28994
   \              0x6DD8 0x6E6B
   \              0x6EFE 0x6F90
   \              0x7021 0x70B2
   \              0x7142       
   \   000000CA   0x71D1 0x7260      DC16 29137, 29280, 29421, 29563, 29703, 29843, 29982, 30120, 30258
   \              0x72ED 0x737B
   \              0x7407 0x7493
   \              0x751E 0x75A8
   \              0x7632       
   \   000000DC   0x76BC 0x7744      DC16 30396, 30532, 30668, 30804, 30938, 31073, 31206, 31339, 31472
   \              0x77CC 0x7854
   \              0x78DA 0x7961
   \              0x79E6 0x7A6B
   \              0x7AF0       
   \   000000EE   0x7B74 0x7BF7      DC16 31604, 31735, 31866, 31996, 32126, 32255, 32384, 32512, 32640
   \              0x7C7A 0x7CFC
   \              0x7D7E 0x7DFF
   \              0x7E80 0x7F00
   \              0x7F80       
     70                  1200, 2100, 2300, 2700, 6451, 7066, 7633, 8160, 8655, 9123, 9568, 9994, 10402, 10794,
     71                  11173, 11540, 11895, 12240, 12575, 12902, 13221, 13532, 13836, 14133, 14425, 14710,
     72                  14991, 15266, 15536, 15802, 16063, 16320, 16573, 16822, 17068, 17310, 17549, 17784,
     73                  18017, 18246, 18473, 18697, 18918, 19137, 19353, 19567, 19778, 19988, 20195, 20400,
     74                  20603, 20804, 21003, 21200, 21396, 21589, 21781, 21971, 22160, 22347, 22533, 22716,
     75                  22899, 23080, 23260, 23438, 23615, 23790, 23965, 24138, 24309, 24480, 24649, 24818,
     76                  24985, 25151, 25316, 25480, 25642, 25804, 25965, 26125, 26284, 26442, 26598, 26754,
     77                  26910, 27064, 27217, 27370, 27521, 27672, 27822, 27971, 28120, 28267, 28414, 28560,
     78                  28705, 28850, 28994, 29137, 29280, 29421, 29563, 29703, 29843, 29982, 30120, 30258,
     79                  30396, 30532, 30668, 30804, 30938, 31073, 31206, 31339, 31472, 31604, 31735, 31866,
     80                  31996, 32126, 32255, 32384, 32512, 32640
     81          };
     82          
     83          #define SQRTROOT_TABLE_SIZE         (sizeof(SquareRootTable)/2)
     84          #define FACTOR_DIVIDER              ((sint32)32768/SQRTROOT_TABLE_SIZE)
     85          
     86          #define SIN_TABLE_SIZE          256
     87          #define COS_TABLE_OFFSET        64
     88          

   \                                 In section .text, align 4, keep-with-next
     89          static const sint16 sinTable[SIN_TABLE_SIZE] =
   \                     ??sinTable:
   \   00000000   0x0000 0x0324      DC16 0, 804, 1608, 2410, 3212, 4011, 4808, 5602, 6393, 7179, 7962, 8739
   \              0x0648 0x096A
   \              0x0C8C 0x0FAB
   \              0x12C8 0x15E2
   \              0x18F9 0x1C0B
   \              0x1F1A 0x2223
   \   00000018   0x2528 0x2826      DC16 9512, 10278, 11039, 11793, 12539, 13279, 14010, 14732, 15446
   \              0x2B1F 0x2E11
   \              0x30FB 0x33DF
   \              0x36BA 0x398C
   \              0x3C56       
   \   0000002A   0x3F17 0x41CE      DC16 16151, 16846, 17530, 18204, 18868, 19519, 20159, 20787, 21403
   \              0x447A 0x471C
   \              0x49B4 0x4C3F
   \              0x4EBF 0x5133
   \              0x539B       
   \   0000003C   0x55F5 0x5842      DC16 22005, 22594, 23170, 23731, 24279, 24811, 25329, 25832, 26319
   \              0x5A82 0x5CB3
   \              0x5ED7 0x60EB
   \              0x62F1 0x64E8
   \              0x66CF       
   \   0000004E   0x68A6 0x6A6D      DC16 26790, 27245, 27683, 28105, 28510, 28898, 29268, 29621, 29956
   \              0x6C23 0x6DC9
   \              0x6F5E 0x70E2
   \              0x7254 0x73B5
   \              0x7504       
   \   00000060   0x7641 0x776B      DC16 30273, 30571, 30852, 31113, 31356, 31580, 31785, 31971, 32137
   \              0x7884 0x7989
   \              0x7A7C 0x7B5C
   \              0x7C29 0x7CE3
   \              0x7D89       
   \   00000072   0x7E1D 0x7E9C      DC16 32285, 32412, 32521, 32609, 32678, 32728, 32757, 32767, 32757
   \              0x7F09 0x7F61
   \              0x7FA6 0x7FD8
   \              0x7FF5 0x7FFF
   \              0x7FF5       
   \   00000084   0x7FD8 0x7FA6      DC16 32728, 32678, 32609, 32521, 32412, 32285, 32137, 31971, 31785
   \              0x7F61 0x7F09
   \              0x7E9C 0x7E1D
   \              0x7D89 0x7CE3
   \              0x7C29       
   \   00000096   0x7B5C 0x7A7C      DC16 31580, 31356, 31113, 30852, 30571, 30273, 29956, 29621, 29268
   \              0x7989 0x7884
   \              0x776B 0x7641
   \              0x7504 0x73B5
   \              0x7254       
   \   000000A8   0x70E2 0x6F5E      DC16 28898, 28510, 28105, 27683, 27245, 26790, 26319, 25832, 25329
   \              0x6DC9 0x6C23
   \              0x6A6D 0x68A6
   \              0x66CF 0x64E8
   \              0x62F1       
   \   000000BA   0x60EB 0x5ED7      DC16 24811, 24279, 23731, 23170, 22594, 22005, 21403, 20787, 20159
   \              0x5CB3 0x5A82
   \              0x5842 0x55F5
   \              0x539B 0x5133
   \              0x4EBF       
   \   000000CC   0x4C3F 0x49B4      DC16 19519, 18868, 18204, 17530, 16846, 16151, 15446, 14732, 14010
   \              0x471C 0x447A
   \              0x41CE 0x3F17
   \              0x3C56 0x398C
   \              0x36BA       
   \   000000DE   0x33DF 0x30FB      DC16 13279, 12539, 11793, 11039, 10278, 9512, 8739, 7962, 7179, 6393
   \              0x2E11 0x2B1F
   \              0x2826 0x2528
   \              0x2223 0x1F1A
   \              0x1C0B 0x18F9
   \   000000F2   0x15E2 0x12C8      DC16 5602, 4808, 4011, 3212, 2410, 1608, 804, 0, -804, -1608, -2410
   \              0x0FAB 0x0C8C
   \              0x096A 0x0648
   \              0x0324 0x0000
   \              0xFCDC 0xF9B8
   \              0xF696       
   \   00000108   0xF374 0xF055      DC16 -3212, -4011, -4808, -5602, -6393, -7179, -7962, -8739, -9512
   \              0xED38 0xEA1E
   \              0xE707 0xE3F5
   \              0xE0E6 0xDDDD
   \              0xDAD8       
   \   0000011A   0xD7DA 0xD4E1      DC16 -10278, -11039, -11793, -12539, -13279, -14010, -14732, -15446
   \              0xD1EF 0xCF05
   \              0xCC21 0xC946
   \              0xC674 0xC3AA
   \   0000012A   0xC0E9 0xBE32      DC16 -16151, -16846, -17530, -18204, -18868, -19519, -20159, -20787
   \              0xBB86 0xB8E4
   \              0xB64C 0xB3C1
   \              0xB141 0xAECD
   \   0000013A   0xAC65 0xAA0B      DC16 -21403, -22005, -22594, -23170, -23731, -24279, -24811, -25329
   \              0xA7BE 0xA57E
   \              0xA34D 0xA129
   \              0x9F15 0x9D0F
   \   0000014A   0x9B18 0x9931      DC16 -25832, -26319, -26790, -27245, -27683, -28105, -28510, -28898
   \              0x975A 0x9593
   \              0x93DD 0x9237
   \              0x90A2 0x8F1E
   \   0000015A   0x8DAC 0x8C4B      DC16 -29268, -29621, -29956, -30273, -30571, -30852, -31113, -31356
   \              0x8AFC 0x89BF
   \              0x8895 0x877C
   \              0x8677 0x8584
   \   0000016A   0x84A4 0x83D7      DC16 -31580, -31785, -31971, -32137, -32285, -32412, -32521, -32609
   \              0x831D 0x8277
   \              0x81E3 0x8164
   \              0x80F7 0x809F
   \   0000017A   0x805A 0x8028      DC16 -32678, -32728, -32757, -32767, -32757, -32728, -32678, -32609
   \              0x800B 0x8001
   \              0x800B 0x8028
   \              0x805A 0x809F
   \   0000018A   0x80F7 0x8164      DC16 -32521, -32412, -32285, -32137, -31971, -31785, -31580, -31356
   \              0x81E3 0x8277
   \              0x831D 0x83D7
   \              0x84A4 0x8584
   \   0000019A   0x8677 0x877C      DC16 -31113, -30852, -30571, -30273, -29956, -29621, -29268, -28898
   \              0x8895 0x89BF
   \              0x8AFC 0x8C4B
   \              0x8DAC 0x8F1E
   \   000001AA   0x90A2 0x9237      DC16 -28510, -28105, -27683, -27245, -26790, -26319, -25832, -25329
   \              0x93DD 0x9593
   \              0x975A 0x9931
   \              0x9B18 0x9D0F
   \   000001BA   0x9F15 0xA129      DC16 -24811, -24279, -23731, -23170, -22594, -22005, -21403, -20787
   \              0xA34D 0xA57E
   \              0xA7BE 0xAA0B
   \              0xAC65 0xAECD
   \   000001CA   0xB141 0xB3C1      DC16 -20159, -19519, -18868, -18204, -17530, -16846, -16151, -15446
   \              0xB64C 0xB8E4
   \              0xBB86 0xBE32
   \              0xC0E9 0xC3AA
   \   000001DA   0xC674 0xC946      DC16 -14732, -14010, -13279, -12539, -11793, -11039, -10278, -9512
   \              0xCC21 0xCF05
   \              0xD1EF 0xD4E1
   \              0xD7DA 0xDAD8
   \   000001EA   0xDDDD 0xE0E6      DC16 -8739, -7962, -7179, -6393, -5602, -4808, -4011, -3212, -2410
   \              0xE3F5 0xE707
   \              0xEA1E 0xED38
   \              0xF055 0xF374
   \              0xF696       
   \   000001FC   0xF9B8 0xFCDC      DC16 -1608, -804
     90          {
     91              0,804,1608,2410,3212,4011,4808,5602,
     92              6393,7179,7962,8739,9512,10278,11039,11793,
     93              12539,13279,14010,14732,15446,16151,16846,17530,
     94              18204,18868,19519,20159,20787,21403,22005,22594,
     95              23170,23731,24279,24811,25329,25832,26319,26790,
     96              27245,27683,28105,28510,28898,29268,29621,29956,
     97              30273,30571,30852,31113,31356,31580,31785,31971,
     98              32137,32285,32412,32521,32609,32678,32728,32757,
     99              32767,32757,32728,32678,32609,32521,32412,32285,
    100              32137,31971,31785,31580,31356,31113,30852,30571,
    101              30273,29956,29621,29268,28898,28510,28105,27683,
    102              27245,26790,26319,25832,25329,24811,24279,23731,
    103              23170,22594,22005,21403,20787,20159,19519,18868,
    104              18204,17530,16846,16151,15446,14732,14010,13279,
    105              12539,11793,11039,10278,9512,8739,7962,7179,
    106              6393,5602,4808,4011,3212,2410,1608,804,
    107              0,-804,-1608,-2410,-3212,-4011,-4808,-5602,
    108              -6393,-7179,-7962,-8739,-9512,-10278,-11039,-11793,
    109              -12539,-13279,-14010,-14732,-15446,-16151,-16846,-17530,
    110              -18204,-18868,-19519,-20159,-20787,-21403,-22005,-22594,
    111              -23170,-23731,-24279,-24811,-25329,-25832,-26319,-26790,
    112              -27245,-27683,-28105,-28510,-28898,-29268,-29621,-29956,
    113              -30273,-30571,-30852,-31113,-31356,-31580,-31785,-31971,
    114              -32137,-32285,-32412,-32521,-32609,-32678,-32728,-32757,
    115              -32767,-32757,-32728,-32678,-32609,-32521,-32412,-32285,
    116              -32137,-31971,-31785,-31580,-31356,-31113,-30852,-30571,
    117              -30273,-29956,-29621,-29268,-28898,-28510,-28105,-27683,
    118              -27245,-26790,-26319,-25832,-25329,-24811,-24279,-23731,
    119              -23170,-22594,-22005,-21403,-20787,-20159,-19519,-18868,
    120              -18204,-17530,-16846,-16151,-15446,-14732,-14010,-13279,
    121              -12539,-11793,-11039,-10278,-9512,-8739,-7962,-7179,
    122          -6393,-5602,-4808,-4011,-3212,-2410,-1608,-804
    123          };
    124          
    125          static const unsigned short int ATAN2_TABLE[] =
    126          {
    127                  8192,                                       // arctan(1)
    128                  4836,                                       // arctan(0.5)
    129                  2555,                                       // arctan(0.25)
    130                  1297,                                       // arctan(0.125)
    131                  651,                                        // arctan(0.0625)
    132                  326,                                        // arctan(...)
    133                  163,                                        // arctan(...)
    134                  81,                                         // arctan(...)
    135                  41,                                         // arctan(...)
    136                  20,                                         // arctan(...)
    137                  10,                                         // arctan(...)
    138                  5,                                          // arctan(...)
    139                  3,                                          // arctan(...)
    140                  1,                                          // arctan(...)
    141                  1                                           // arctan(...)
    142          };
    143          
    144          
    145          // Added later BEATOA
    146          //keep here not to brake the module
    147          #define THREE_LL            0xC0000000L  //!< \f$ {3} \f$ in Q34.30 notation
    148          #define THREE_DIV_2         0x60000000L  //!< \f$ \frac{3}{2} \f$ in Q2.30 notation
    149          #define INV_SQRT_2          23170       //!< \f$ \frac{1}{\sqrt{3}} \f$ in Q1.15 notation
    150          
    151          #define DEBRUIJN_SEQ 0x077CB531UL   //!< De Bruijn sequence used to index a single 1 in a 32bit word
    152          #define MAX_32BIT_POSITIVE 0x7FFFFFFFL              //1< 2^31-1
    153          #define MAX_32BIT_NEGATIVE 0x80000000L              //1< -2^31
    154          
    155          /** table to convert De Bruijn index to standard index (unsigned version) */

   \                                 In section .rodata, align 4, keep-with-next
    156          const unsigned char debruijn_to_std_unsigned[32] =
   \                     debruijn_to_std_unsigned:
   \   00000000   0x00 0x1F          DC8 0, 31, 4, 30, 3, 18, 8, 29, 2, 10, 12, 17, 7, 15, 28, 24, 1, 5, 19
   \              0x04 0x1E    
   \              0x03 0x12    
   \              0x08 0x1D    
   \              0x02 0x0A    
   \              0x0C 0x11    
   \              0x07 0x0F    
   \              0x1C 0x18    
   \              0x01 0x05    
   \              0x13         
   \   00000013   0x09 0x0B          DC8 9, 11, 13, 16, 25, 6, 20, 14, 26, 21, 27, 22, 23
   \              0x0D 0x10    
   \              0x19 0x06    
   \              0x14 0x0E    
   \              0x1A 0x15    
   \              0x1B 0x16    
   \              0x17         
    157          {
    158              0, 31,  4, 30,  3, 18,  8, 29, 2, 10, 12, 17,  7, 15, 28, 24,
    159              1,  5, 19,  9, 11, 13, 16, 25, 6, 20, 14, 26, 21, 27, 22, 23
    160          };
    161          
    162          /** table to convert De Bruijn index to standard index (signed version- MSB is discarded because it is used for sign) */

   \                                 In section .rodata, align 4, keep-with-next
    163          const unsigned char debruijn_to_std_signed[32] =
   \                     debruijn_to_std_signed:
   \   00000000   0x1F 0x1E          DC8 31, 30, 3, 29, 2, 17, 7, 28, 1, 9, 11, 16, 6, 14, 27, 23, 0, 4, 18
   \              0x03 0x1D    
   \              0x02 0x11    
   \              0x07 0x1C    
   \              0x01 0x09    
   \              0x0B 0x10    
   \              0x06 0x0E    
   \              0x1B 0x17    
   \              0x00 0x04    
   \              0x12         
   \   00000013   0x08 0x0A          DC8 8, 10, 12, 15, 24, 5, 19, 13, 25, 20, 26, 21, 22
   \              0x0C 0x0F    
   \              0x18 0x05    
   \              0x13 0x0D    
   \              0x19 0x14    
   \              0x1A 0x15    
   \              0x16         
    164          {
    165              31, 30,  3, 29,  2, 17,  7, 28, 1,  9, 11, 16,  6, 14, 27, 23,
    166               0,  4, 18,  8, 10, 12, 15, 24, 5, 19, 13, 25, 20, 26, 21, 22
    167          };
    168          
    169          #define INTERPOLATION_STEP_IQ   IQ15
    170          
    171          
    172          
    173          
    174          #define FAST_MATH_TABLE_SIZE    512
    175          

   \                                 In section .text, align 4, keep-with-next
    176          const float32 sinTable_wp_f32[FAST_MATH_TABLE_SIZE + 1] = {
   \                     sinTable_wp_f32:
   \   00000000   0x00000000         DC32 0H, 3C490E92H, 3CC90AB1H, 3D16C32BH, 3D48FB2EH, 3D7B2B75H
   \              0x3C490E92   
   \              0x3CC90AB1   
   \              0x3D16C32B   
   \              0x3D48FB2E   
   \              0x3D7B2B75   
   \   00000018   0x3D96A904         DC32 3D96A904H, 3DAFB680H, 3DC8BD36H, 3DE1BC2FH, 3DFAB273H, 3E09CF87H
   \              0x3DAFB680   
   \              0x3DC8BD36   
   \              0x3DE1BC2F   
   \              0x3DFAB273   
   \              0x3E09CF87   
   \   00000030   0x3E164083         DC32 3E164083H, 3E22ABB5H, 3E2F10A2H, 3E3B6ECFH, 3E47C5C2H, 3E541501H
   \              0x3E22ABB5   
   \              0x3E2F10A2   
   \              0x3E3B6ECF   
   \              0x3E47C5C2   
   \              0x3E541501   
   \   00000048   0x3E605C13         DC32 3E605C13H, 3E6C9A7FH, 3E78CFCCH, 3E827DC0H, 3E888E93H, 3E8E9A22H
   \              0x3E6C9A7F   
   \              0x3E78CFCC   
   \              0x3E827DC0   
   \              0x3E888E93   
   \              0x3E8E9A22   
   \   00000060   0x3E94A032         DC32 3E94A032H, 3E9AA086H, 3EA09AE5H, 3EA68F12H, 3EAC7CD4H, 3EB263EFH
   \              0x3E9AA086   
   \              0x3EA09AE5   
   \              0x3EA68F12   
   \              0x3EAC7CD4   
   \              0x3EB263EF   
   \   00000078   0x3EB8442A         DC32 3EB8442AH, 3EBE1D49H, 3EC3EF15H, 3EC9B953H, 3ECF7BCAH, 3ED53641H
   \              0x3EBE1D49   
   \              0x3EC3EF15   
   \              0x3EC9B953   
   \              0x3ECF7BCA   
   \              0x3ED53641   
   \   00000090   0x3EDAE880         DC32 3EDAE880H, 3EE0924FH, 3EE63375H, 3EEBCBBBH, 3EF15AEAH, 3EF6E0CBH
   \              0x3EE0924F   
   \              0x3EE63375   
   \              0x3EEBCBBB   
   \              0x3EF15AEA   
   \              0x3EF6E0CB   
   \   000000A8   0x3EFC5D27         DC32 3EFC5D27H, 3F00E7E4H, 3F039C3DH, 3F064B82H, 3F08F59BH, 3F0B9A6BH
   \              0x3F00E7E4   
   \              0x3F039C3D   
   \              0x3F064B82   
   \              0x3F08F59B   
   \              0x3F0B9A6B   
   \   000000C0   0x3F0E39DA         DC32 3F0E39DAH, 3F10D3CDH, 3F13682AH, 3F15F6D9H, 3F187FC0H, 3F1B02C6H
   \              0x3F10D3CD   
   \              0x3F13682A   
   \              0x3F15F6D9   
   \              0x3F187FC0   
   \              0x3F1B02C6   
   \   000000D8   0x3F1D7FD1         DC32 3F1D7FD1H, 3F1FF6CBH, 3F226799H, 3F24D225H, 3F273656H, 3F299415H
   \              0x3F1FF6CB   
   \              0x3F226799   
   \              0x3F24D225   
   \              0x3F273656   
   \              0x3F299415   
   \   000000F0   0x3F2BEB4A         DC32 3F2BEB4AH, 3F2E3BDEH, 3F3085BBH, 3F32C8C9H, 3F3504F3H, 3F373A23H
   \              0x3F2E3BDE   
   \              0x3F3085BB   
   \              0x3F32C8C9   
   \              0x3F3504F3   
   \              0x3F373A23   
   \   00000108   0x3F396842         DC32 3F396842H, 3F3B8F3BH, 3F3DAEF9H, 3F3FC767H, 3F41D870H, 3F43E201H
   \              0x3F3B8F3B   
   \              0x3F3DAEF9   
   \              0x3F3FC767   
   \              0x3F41D870   
   \              0x3F43E201   
   \   00000120   0x3F45E403         DC32 3F45E403H, 3F47DE65H, 3F49D112H, 3F4BBBF8H, 3F4D9F02H, 3F4F7A20H
   \              0x3F47DE65   
   \              0x3F49D112   
   \              0x3F4BBBF8   
   \              0x3F4D9F02   
   \              0x3F4F7A20   
   \   00000138   0x3F514D3D         DC32 3F514D3DH, 3F531849H, 3F54DB31H, 3F5695E5H, 3F584853H, 3F59F26AH
   \              0x3F531849   
   \              0x3F54DB31   
   \              0x3F5695E5   
   \              0x3F584853   
   \              0x3F59F26A   
   \   00000150   0x3F5B941A         DC32 3F5B941AH, 3F5D2D53H, 3F5EBE05H, 3F604621H, 3F61C597H, 3F633C5AH
   \              0x3F5D2D53   
   \              0x3F5EBE05   
   \              0x3F604621   
   \              0x3F61C597   
   \              0x3F633C5A   
   \   00000168   0x3F64AA59         DC32 3F64AA59H, 3F660F88H, 3F676BD8H, 3F68BF3CH, 3F6A09A7H, 3F6B4B0CH
   \              0x3F660F88   
   \              0x3F676BD8   
   \              0x3F68BF3C   
   \              0x3F6A09A7   
   \              0x3F6B4B0C   
   \   00000180   0x3F6C835E         DC32 3F6C835EH, 3F6DB293H, 3F6ED89EH, 3F6FF573H, 3F710908H, 3F721352H
   \              0x3F6DB293   
   \              0x3F6ED89E   
   \              0x3F6FF573   
   \              0x3F710908   
   \              0x3F721352   
   \   00000198   0x3F731447         DC32 3F731447H, 3F740BDDH, 3F74FA0BH, 3F75DEC6H, 3F76BA07H, 3F778BC5H
   \              0x3F740BDD   
   \              0x3F74FA0B   
   \              0x3F75DEC6   
   \              0x3F76BA07   
   \              0x3F778BC5   
   \   000001B0   0x3F7853F8         DC32 3F7853F8H, 3F791298H, 3F79C79DH, 3F7A7302H, 3F7B14BEH, 3F7BACCDH
   \              0x3F791298   
   \              0x3F79C79D   
   \              0x3F7A7302   
   \              0x3F7B14BE   
   \              0x3F7BACCD   
   \   000001C8   0x3F7C3B28         DC32 3F7C3B28H, 3F7CBFC9H, 3F7D3AACH, 3F7DABCCH, 3F7E1323H, 3F7E70B0H
   \              0x3F7CBFC9   
   \              0x3F7D3AAC   
   \              0x3F7DABCC   
   \              0x3F7E1323   
   \              0x3F7E70B0   
   \   000001E0   0x3F7EC46D         DC32 3F7EC46DH, 3F7F0E58H, 3F7F4E6DH, 3F7F84ABH, 3F7FB10FH, 3F7FD397H
   \              0x3F7F0E58   
   \              0x3F7F4E6D   
   \              0x3F7F84AB   
   \              0x3F7FB10F   
   \              0x3F7FD397   
   \   000001F8   0x3F7FEC43         DC32 3F7FEC43H, 3F7FFB11H, 3F800000H, 3F7FFB11H, 3F7FEC43H, 3F7FD397H
   \              0x3F7FFB11   
   \              0x3F800000   
   \              0x3F7FFB11   
   \              0x3F7FEC43   
   \              0x3F7FD397   
   \   00000210   0x3F7FB10F         DC32 3F7FB10FH, 3F7F84ABH, 3F7F4E6DH, 3F7F0E58H, 3F7EC46DH, 3F7E70B0H
   \              0x3F7F84AB   
   \              0x3F7F4E6D   
   \              0x3F7F0E58   
   \              0x3F7EC46D   
   \              0x3F7E70B0   
   \   00000228   0x3F7E1323         DC32 3F7E1323H, 3F7DABCCH, 3F7D3AACH, 3F7CBFC9H, 3F7C3B28H, 3F7BACCDH
   \              0x3F7DABCC   
   \              0x3F7D3AAC   
   \              0x3F7CBFC9   
   \              0x3F7C3B28   
   \              0x3F7BACCD   
   \   00000240   0x3F7B14BE         DC32 3F7B14BEH, 3F7A7302H, 3F79C79DH, 3F791298H, 3F7853F8H, 3F778BC5H
   \              0x3F7A7302   
   \              0x3F79C79D   
   \              0x3F791298   
   \              0x3F7853F8   
   \              0x3F778BC5   
   \   00000258   0x3F76BA07         DC32 3F76BA07H, 3F75DEC6H, 3F74FA0BH, 3F740BDDH, 3F731447H, 3F721352H
   \              0x3F75DEC6   
   \              0x3F74FA0B   
   \              0x3F740BDD   
   \              0x3F731447   
   \              0x3F721352   
   \   00000270   0x3F710908         DC32 3F710908H, 3F6FF573H, 3F6ED89EH, 3F6DB293H, 3F6C835EH, 3F6B4B0CH
   \              0x3F6FF573   
   \              0x3F6ED89E   
   \              0x3F6DB293   
   \              0x3F6C835E   
   \              0x3F6B4B0C   
   \   00000288   0x3F6A09A7         DC32 3F6A09A7H, 3F68BF3CH, 3F676BD8H, 3F660F88H, 3F64AA59H, 3F633C5AH
   \              0x3F68BF3C   
   \              0x3F676BD8   
   \              0x3F660F88   
   \              0x3F64AA59   
   \              0x3F633C5A   
   \   000002A0   0x3F61C597         DC32 3F61C597H, 3F604621H, 3F5EBE05H, 3F5D2D53H, 3F5B941AH, 3F59F26AH
   \              0x3F604621   
   \              0x3F5EBE05   
   \              0x3F5D2D53   
   \              0x3F5B941A   
   \              0x3F59F26A   
   \   000002B8   0x3F584853         DC32 3F584853H, 3F5695E5H, 3F54DB31H, 3F531849H, 3F514D3DH, 3F4F7A20H
   \              0x3F5695E5   
   \              0x3F54DB31   
   \              0x3F531849   
   \              0x3F514D3D   
   \              0x3F4F7A20   
   \   000002D0   0x3F4D9F02         DC32 3F4D9F02H, 3F4BBBF8H, 3F49D112H, 3F47DE65H, 3F45E403H, 3F43E201H
   \              0x3F4BBBF8   
   \              0x3F49D112   
   \              0x3F47DE65   
   \              0x3F45E403   
   \              0x3F43E201   
   \   000002E8   0x3F41D870         DC32 3F41D870H, 3F3FC767H, 3F3DAEF9H, 3F3B8F3BH, 3F396842H, 3F373A23H
   \              0x3F3FC767   
   \              0x3F3DAEF9   
   \              0x3F3B8F3B   
   \              0x3F396842   
   \              0x3F373A23   
   \   00000300   0x3F3504F3         DC32 3F3504F3H, 3F32C8C9H, 3F3085BBH, 3F2E3BDEH, 3F2BEB4AH, 3F299415H
   \              0x3F32C8C9   
   \              0x3F3085BB   
   \              0x3F2E3BDE   
   \              0x3F2BEB4A   
   \              0x3F299415   
   \   00000318   0x3F273656         DC32 3F273656H, 3F24D225H, 3F226799H, 3F1FF6CBH, 3F1D7FD1H, 3F1B02C6H
   \              0x3F24D225   
   \              0x3F226799   
   \              0x3F1FF6CB   
   \              0x3F1D7FD1   
   \              0x3F1B02C6   
   \   00000330   0x3F187FC0         DC32 3F187FC0H, 3F15F6D9H, 3F13682AH, 3F10D3CDH, 3F0E39DAH, 3F0B9A6BH
   \              0x3F15F6D9   
   \              0x3F13682A   
   \              0x3F10D3CD   
   \              0x3F0E39DA   
   \              0x3F0B9A6B   
   \   00000348   0x3F08F59B         DC32 3F08F59BH, 3F064B82H, 3F039C3DH, 3F00E7E4H, 3EFC5D27H, 3EF6E0CBH
   \              0x3F064B82   
   \              0x3F039C3D   
   \              0x3F00E7E4   
   \              0x3EFC5D27   
   \              0x3EF6E0CB   
   \   00000360   0x3EF15AEA         DC32 3EF15AEAH, 3EEBCBBBH, 3EE63375H, 3EE0924FH, 3EDAE880H, 3ED53641H
   \              0x3EEBCBBB   
   \              0x3EE63375   
   \              0x3EE0924F   
   \              0x3EDAE880   
   \              0x3ED53641   
   \   00000378   0x3ECF7BCA         DC32 3ECF7BCAH, 3EC9B953H, 3EC3EF15H, 3EBE1D49H, 3EB8442AH, 3EB263EFH
   \              0x3EC9B953   
   \              0x3EC3EF15   
   \              0x3EBE1D49   
   \              0x3EB8442A   
   \              0x3EB263EF   
   \   00000390   0x3EAC7CD4         DC32 3EAC7CD4H, 3EA68F12H, 3EA09AE5H, 3E9AA086H, 3E94A032H, 3E8E9A22H
   \              0x3EA68F12   
   \              0x3EA09AE5   
   \              0x3E9AA086   
   \              0x3E94A032   
   \              0x3E8E9A22   
   \   000003A8   0x3E888E93         DC32 3E888E93H, 3E827DC0H, 3E78CFCCH, 3E6C9A7FH, 3E605C13H, 3E541501H
   \              0x3E827DC0   
   \              0x3E78CFCC   
   \              0x3E6C9A7F   
   \              0x3E605C13   
   \              0x3E541501   
   \   000003C0   0x3E47C5C2         DC32 3E47C5C2H, 3E3B6ECFH, 3E2F10A2H, 3E22ABB5H, 3E164083H, 3E09CF87H
   \              0x3E3B6ECF   
   \              0x3E2F10A2   
   \              0x3E22ABB5   
   \              0x3E164083   
   \              0x3E09CF87   
   \   000003D8   0x3DFAB273         DC32 3DFAB273H, 3DE1BC2FH, 3DC8BD36H, 3DAFB680H, 3D96A904H, 3D7B2B75H
   \              0x3DE1BC2F   
   \              0x3DC8BD36   
   \              0x3DAFB680   
   \              0x3D96A904   
   \              0x3D7B2B75   
   \   000003F0   0x3D48FB2E         DC32 3D48FB2EH, 3D16C32BH, 3CC90AB1H, 3C490E92H, 0H, 0BC490E92H
   \              0x3D16C32B   
   \              0x3CC90AB1   
   \              0x3C490E92   
   \              0x00000000   
   \              0xBC490E92   
   \   00000408   0xBCC90AB1         DC32 0BCC90AB1H, 0BD16C32BH, 0BD48FB2EH, 0BD7B2B75H, 0BD96A904H
   \              0xBD16C32B   
   \              0xBD48FB2E   
   \              0xBD7B2B75   
   \              0xBD96A904   
   \   0000041C   0xBDAFB680         DC32 0BDAFB680H, 0BDC8BD36H, 0BDE1BC2FH, 0BDFAB273H, 0BE09CF87H
   \              0xBDC8BD36   
   \              0xBDE1BC2F   
   \              0xBDFAB273   
   \              0xBE09CF87   
   \   00000430   0xBE164083         DC32 0BE164083H, 0BE22ABB5H, 0BE2F10A2H, 0BE3B6ECFH, 0BE47C5C2H
   \              0xBE22ABB5   
   \              0xBE2F10A2   
   \              0xBE3B6ECF   
   \              0xBE47C5C2   
   \   00000444   0xBE541501         DC32 0BE541501H, 0BE605C13H, 0BE6C9A7FH, 0BE78CFCCH, 0BE827DC0H
   \              0xBE605C13   
   \              0xBE6C9A7F   
   \              0xBE78CFCC   
   \              0xBE827DC0   
   \   00000458   0xBE888E93         DC32 0BE888E93H, 0BE8E9A22H, 0BE94A032H, 0BE9AA086H, 0BEA09AE5H
   \              0xBE8E9A22   
   \              0xBE94A032   
   \              0xBE9AA086   
   \              0xBEA09AE5   
   \   0000046C   0xBEA68F12         DC32 0BEA68F12H, 0BEAC7CD4H, 0BEB263EFH, 0BEB8442AH, 0BEBE1D49H
   \              0xBEAC7CD4   
   \              0xBEB263EF   
   \              0xBEB8442A   
   \              0xBEBE1D49   
   \   00000480   0xBEC3EF15         DC32 0BEC3EF15H, 0BEC9B953H, 0BECF7BCAH, 0BED53641H, 0BEDAE880H
   \              0xBEC9B953   
   \              0xBECF7BCA   
   \              0xBED53641   
   \              0xBEDAE880   
   \   00000494   0xBEE0924F         DC32 0BEE0924FH, 0BEE63375H, 0BEEBCBBBH, 0BEF15AEAH, 0BEF6E0CBH
   \              0xBEE63375   
   \              0xBEEBCBBB   
   \              0xBEF15AEA   
   \              0xBEF6E0CB   
   \   000004A8   0xBEFC5D27         DC32 0BEFC5D27H, 0BF00E7E4H, 0BF039C3DH, 0BF064B82H, 0BF08F59BH
   \              0xBF00E7E4   
   \              0xBF039C3D   
   \              0xBF064B82   
   \              0xBF08F59B   
   \   000004BC   0xBF0B9A6B         DC32 0BF0B9A6BH, 0BF0E39DAH, 0BF10D3CDH, 0BF13682AH, 0BF15F6D9H
   \              0xBF0E39DA   
   \              0xBF10D3CD   
   \              0xBF13682A   
   \              0xBF15F6D9   
   \   000004D0   0xBF187FC0         DC32 0BF187FC0H, 0BF1B02C6H, 0BF1D7FD1H, 0BF1FF6CBH, 0BF226799H
   \              0xBF1B02C6   
   \              0xBF1D7FD1   
   \              0xBF1FF6CB   
   \              0xBF226799   
   \   000004E4   0xBF24D225         DC32 0BF24D225H, 0BF273656H, 0BF299415H, 0BF2BEB4AH, 0BF2E3BDEH
   \              0xBF273656   
   \              0xBF299415   
   \              0xBF2BEB4A   
   \              0xBF2E3BDE   
   \   000004F8   0xBF3085BB         DC32 0BF3085BBH, 0BF32C8C9H, 0BF3504F3H, 0BF373A23H, 0BF396842H
   \              0xBF32C8C9   
   \              0xBF3504F3   
   \              0xBF373A23   
   \              0xBF396842   
   \   0000050C   0xBF3B8F3B         DC32 0BF3B8F3BH, 0BF3DAEF9H, 0BF3FC767H, 0BF41D870H, 0BF43E201H
   \              0xBF3DAEF9   
   \              0xBF3FC767   
   \              0xBF41D870   
   \              0xBF43E201   
   \   00000520   0xBF45E403         DC32 0BF45E403H, 0BF47DE65H, 0BF49D112H, 0BF4BBBF8H, 0BF4D9F02H
   \              0xBF47DE65   
   \              0xBF49D112   
   \              0xBF4BBBF8   
   \              0xBF4D9F02   
   \   00000534   0xBF4F7A20         DC32 0BF4F7A20H, 0BF514D3DH, 0BF531849H, 0BF54DB31H, 0BF5695E5H
   \              0xBF514D3D   
   \              0xBF531849   
   \              0xBF54DB31   
   \              0xBF5695E5   
   \   00000548   0xBF584853         DC32 0BF584853H, 0BF59F26AH, 0BF5B941AH, 0BF5D2D53H, 0BF5EBE05H
   \              0xBF59F26A   
   \              0xBF5B941A   
   \              0xBF5D2D53   
   \              0xBF5EBE05   
   \   0000055C   0xBF604621         DC32 0BF604621H, 0BF61C597H, 0BF633C5AH, 0BF64AA59H, 0BF660F88H
   \              0xBF61C597   
   \              0xBF633C5A   
   \              0xBF64AA59   
   \              0xBF660F88   
   \   00000570   0xBF676BD8         DC32 0BF676BD8H, 0BF68BF3CH, 0BF6A09A7H, 0BF6B4B0CH, 0BF6C835EH
   \              0xBF68BF3C   
   \              0xBF6A09A7   
   \              0xBF6B4B0C   
   \              0xBF6C835E   
   \   00000584   0xBF6DB293         DC32 0BF6DB293H, 0BF6ED89EH, 0BF6FF573H, 0BF710908H, 0BF721352H
   \              0xBF6ED89E   
   \              0xBF6FF573   
   \              0xBF710908   
   \              0xBF721352   
   \   00000598   0xBF731447         DC32 0BF731447H, 0BF740BDDH, 0BF74FA0BH, 0BF75DEC6H, 0BF76BA07H
   \              0xBF740BDD   
   \              0xBF74FA0B   
   \              0xBF75DEC6   
   \              0xBF76BA07   
   \   000005AC   0xBF778BC5         DC32 0BF778BC5H, 0BF7853F8H, 0BF791298H, 0BF79C79DH, 0BF7A7302H
   \              0xBF7853F8   
   \              0xBF791298   
   \              0xBF79C79D   
   \              0xBF7A7302   
   \   000005C0   0xBF7B14BE         DC32 0BF7B14BEH, 0BF7BACCDH, 0BF7C3B28H, 0BF7CBFC9H, 0BF7D3AACH
   \              0xBF7BACCD   
   \              0xBF7C3B28   
   \              0xBF7CBFC9   
   \              0xBF7D3AAC   
   \   000005D4   0xBF7DABCC         DC32 0BF7DABCCH, 0BF7E1323H, 0BF7E70B0H, 0BF7EC46DH, 0BF7F0E58H
   \              0xBF7E1323   
   \              0xBF7E70B0   
   \              0xBF7EC46D   
   \              0xBF7F0E58   
   \   000005E8   0xBF7F4E6D         DC32 0BF7F4E6DH, 0BF7F84ABH, 0BF7FB10FH, 0BF7FD397H, 0BF7FEC43H
   \              0xBF7F84AB   
   \              0xBF7FB10F   
   \              0xBF7FD397   
   \              0xBF7FEC43   
   \   000005FC   0xBF7FFB11         DC32 0BF7FFB11H, 0BF800000H, 0BF7FFB11H, 0BF7FEC43H, 0BF7FD397H
   \              0xBF800000   
   \              0xBF7FFB11   
   \              0xBF7FEC43   
   \              0xBF7FD397   
   \   00000610   0xBF7FB10F         DC32 0BF7FB10FH, 0BF7F84ABH, 0BF7F4E6DH, 0BF7F0E58H, 0BF7EC46DH
   \              0xBF7F84AB   
   \              0xBF7F4E6D   
   \              0xBF7F0E58   
   \              0xBF7EC46D   
   \   00000624   0xBF7E70B0         DC32 0BF7E70B0H, 0BF7E1323H, 0BF7DABCCH, 0BF7D3AACH, 0BF7CBFC9H
   \              0xBF7E1323   
   \              0xBF7DABCC   
   \              0xBF7D3AAC   
   \              0xBF7CBFC9   
   \   00000638   0xBF7C3B28         DC32 0BF7C3B28H, 0BF7BACCDH, 0BF7B14BEH, 0BF7A7302H, 0BF79C79DH
   \              0xBF7BACCD   
   \              0xBF7B14BE   
   \              0xBF7A7302   
   \              0xBF79C79D   
   \   0000064C   0xBF791298         DC32 0BF791298H, 0BF7853F8H, 0BF778BC5H, 0BF76BA07H, 0BF75DEC6H
   \              0xBF7853F8   
   \              0xBF778BC5   
   \              0xBF76BA07   
   \              0xBF75DEC6   
   \   00000660   0xBF74FA0B         DC32 0BF74FA0BH, 0BF740BDDH, 0BF731447H, 0BF721352H, 0BF710908H
   \              0xBF740BDD   
   \              0xBF731447   
   \              0xBF721352   
   \              0xBF710908   
   \   00000674   0xBF6FF573         DC32 0BF6FF573H, 0BF6ED89EH, 0BF6DB293H, 0BF6C835EH, 0BF6B4B0CH
   \              0xBF6ED89E   
   \              0xBF6DB293   
   \              0xBF6C835E   
   \              0xBF6B4B0C   
   \   00000688   0xBF6A09A7         DC32 0BF6A09A7H, 0BF68BF3CH, 0BF676BD8H, 0BF660F88H, 0BF64AA59H
   \              0xBF68BF3C   
   \              0xBF676BD8   
   \              0xBF660F88   
   \              0xBF64AA59   
   \   0000069C   0xBF633C5A         DC32 0BF633C5AH, 0BF61C597H, 0BF604621H, 0BF5EBE05H, 0BF5D2D53H
   \              0xBF61C597   
   \              0xBF604621   
   \              0xBF5EBE05   
   \              0xBF5D2D53   
   \   000006B0   0xBF5B941A         DC32 0BF5B941AH, 0BF59F26AH, 0BF584853H, 0BF5695E5H, 0BF54DB31H
   \              0xBF59F26A   
   \              0xBF584853   
   \              0xBF5695E5   
   \              0xBF54DB31   
   \   000006C4   0xBF531849         DC32 0BF531849H, 0BF514D3DH, 0BF4F7A20H, 0BF4D9F02H, 0BF4BBBF8H
   \              0xBF514D3D   
   \              0xBF4F7A20   
   \              0xBF4D9F02   
   \              0xBF4BBBF8   
   \   000006D8   0xBF49D112         DC32 0BF49D112H, 0BF47DE65H, 0BF45E403H, 0BF43E201H, 0BF41D870H
   \              0xBF47DE65   
   \              0xBF45E403   
   \              0xBF43E201   
   \              0xBF41D870   
   \   000006EC   0xBF3FC767         DC32 0BF3FC767H, 0BF3DAEF9H, 0BF3B8F3BH, 0BF396842H, 0BF373A23H
   \              0xBF3DAEF9   
   \              0xBF3B8F3B   
   \              0xBF396842   
   \              0xBF373A23   
   \   00000700   0xBF3504F3         DC32 0BF3504F3H, 0BF32C8C9H, 0BF3085BBH, 0BF2E3BDEH, 0BF2BEB4AH
   \              0xBF32C8C9   
   \              0xBF3085BB   
   \              0xBF2E3BDE   
   \              0xBF2BEB4A   
   \   00000714   0xBF299415         DC32 0BF299415H, 0BF273656H, 0BF24D225H, 0BF226799H, 0BF1FF6CBH
   \              0xBF273656   
   \              0xBF24D225   
   \              0xBF226799   
   \              0xBF1FF6CB   
   \   00000728   0xBF1D7FD1         DC32 0BF1D7FD1H, 0BF1B02C6H, 0BF187FC0H, 0BF15F6D9H, 0BF13682AH
   \              0xBF1B02C6   
   \              0xBF187FC0   
   \              0xBF15F6D9   
   \              0xBF13682A   
   \   0000073C   0xBF10D3CD         DC32 0BF10D3CDH, 0BF0E39DAH, 0BF0B9A6BH, 0BF08F59BH, 0BF064B82H
   \              0xBF0E39DA   
   \              0xBF0B9A6B   
   \              0xBF08F59B   
   \              0xBF064B82   
   \   00000750   0xBF039C3D         DC32 0BF039C3DH, 0BF00E7E4H, 0BEFC5D27H, 0BEF6E0CBH, 0BEF15AEAH
   \              0xBF00E7E4   
   \              0xBEFC5D27   
   \              0xBEF6E0CB   
   \              0xBEF15AEA   
   \   00000764   0xBEEBCBBB         DC32 0BEEBCBBBH, 0BEE63375H, 0BEE0924FH, 0BEDAE880H, 0BED53641H
   \              0xBEE63375   
   \              0xBEE0924F   
   \              0xBEDAE880   
   \              0xBED53641   
   \   00000778   0xBECF7BCA         DC32 0BECF7BCAH, 0BEC9B953H, 0BEC3EF15H, 0BEBE1D49H, 0BEB8442AH
   \              0xBEC9B953   
   \              0xBEC3EF15   
   \              0xBEBE1D49   
   \              0xBEB8442A   
   \   0000078C   0xBEB263EF         DC32 0BEB263EFH, 0BEAC7CD4H, 0BEA68F12H, 0BEA09AE5H, 0BE9AA086H
   \              0xBEAC7CD4   
   \              0xBEA68F12   
   \              0xBEA09AE5   
   \              0xBE9AA086   
   \   000007A0   0xBE94A032         DC32 0BE94A032H, 0BE8E9A22H, 0BE888E93H, 0BE827DC0H, 0BE78CFCCH
   \              0xBE8E9A22   
   \              0xBE888E93   
   \              0xBE827DC0   
   \              0xBE78CFCC   
   \   000007B4   0xBE6C9A7F         DC32 0BE6C9A7FH, 0BE605C13H, 0BE541501H, 0BE47C5C2H, 0BE3B6ECFH
   \              0xBE605C13   
   \              0xBE541501   
   \              0xBE47C5C2   
   \              0xBE3B6ECF   
   \   000007C8   0xBE2F10A2         DC32 0BE2F10A2H, 0BE22ABB5H, 0BE164083H, 0BE09CF87H, 0BDFAB273H
   \              0xBE22ABB5   
   \              0xBE164083   
   \              0xBE09CF87   
   \              0xBDFAB273   
   \   000007DC   0xBDE1BC2F         DC32 0BDE1BC2FH, 0BDC8BD36H, 0BDAFB680H, 0BD96A904H, 0BD7B2B75H
   \              0xBDC8BD36   
   \              0xBDAFB680   
   \              0xBD96A904   
   \              0xBD7B2B75   
   \   000007F0   0xBD48FB2E         DC32 0BD48FB2EH, 0BD16C32BH, 0BCC90AB1H, 0BC490E92H, 80000000H
   \              0xBD16C32B   
   \              0xBCC90AB1   
   \              0xBC490E92   
   \              0x80000000   
    177             0.00000000f, 0.01227154f, 0.02454123f, 0.03680722f, 0.04906767f, 0.06132074f,
    178             0.07356456f, 0.08579731f, 0.09801714f, 0.11022221f, 0.12241068f, 0.13458071f,
    179             0.14673047f, 0.15885814f, 0.17096189f, 0.18303989f, 0.19509032f, 0.20711138f,
    180             0.21910124f, 0.23105811f, 0.24298018f, 0.25486566f, 0.26671276f, 0.27851969f,
    181             0.29028468f, 0.30200595f, 0.31368174f, 0.32531029f, 0.33688985f, 0.34841868f,
    182             0.35989504f, 0.37131719f, 0.38268343f, 0.39399204f, 0.40524131f, 0.41642956f,
    183             0.42755509f, 0.43861624f, 0.44961133f, 0.46053871f, 0.47139674f, 0.48218377f,
    184             0.49289819f, 0.50353838f, 0.51410274f, 0.52458968f, 0.53499762f, 0.54532499f,
    185             0.55557023f, 0.56573181f, 0.57580819f, 0.58579786f, 0.59569930f, 0.60551104f,
    186             0.61523159f, 0.62485949f, 0.63439328f, 0.64383154f, 0.65317284f, 0.66241578f,
    187             0.67155895f, 0.68060100f, 0.68954054f, 0.69837625f, 0.70710678f, 0.71573083f,
    188             0.72424708f, 0.73265427f, 0.74095113f, 0.74913639f, 0.75720885f, 0.76516727f,
    189             0.77301045f, 0.78073723f, 0.78834643f, 0.79583690f, 0.80320753f, 0.81045720f,
    190             0.81758481f, 0.82458930f, 0.83146961f, 0.83822471f, 0.84485357f, 0.85135519f,
    191             0.85772861f, 0.86397286f, 0.87008699f, 0.87607009f, 0.88192126f, 0.88763962f,
    192             0.89322430f, 0.89867447f, 0.90398929f, 0.90916798f, 0.91420976f, 0.91911385f,
    193             0.92387953f, 0.92850608f, 0.93299280f, 0.93733901f, 0.94154407f, 0.94560733f,
    194             0.94952818f, 0.95330604f, 0.95694034f, 0.96043052f, 0.96377607f, 0.96697647f,
    195             0.97003125f, 0.97293995f, 0.97570213f, 0.97831737f, 0.98078528f, 0.98310549f,
    196             0.98527764f, 0.98730142f, 0.98917651f, 0.99090264f, 0.99247953f, 0.99390697f,
    197             0.99518473f, 0.99631261f, 0.99729046f, 0.99811811f, 0.99879546f, 0.99932238f,
    198             0.99969882f, 0.99992470f, 1.00000000f, 0.99992470f, 0.99969882f, 0.99932238f,
    199             0.99879546f, 0.99811811f, 0.99729046f, 0.99631261f, 0.99518473f, 0.99390697f,
    200             0.99247953f, 0.99090264f, 0.98917651f, 0.98730142f, 0.98527764f, 0.98310549f,
    201             0.98078528f, 0.97831737f, 0.97570213f, 0.97293995f, 0.97003125f, 0.96697647f,
    202             0.96377607f, 0.96043052f, 0.95694034f, 0.95330604f, 0.94952818f, 0.94560733f,
    203             0.94154407f, 0.93733901f, 0.93299280f, 0.92850608f, 0.92387953f, 0.91911385f,
    204             0.91420976f, 0.90916798f, 0.90398929f, 0.89867447f, 0.89322430f, 0.88763962f,
    205             0.88192126f, 0.87607009f, 0.87008699f, 0.86397286f, 0.85772861f, 0.85135519f,
    206             0.84485357f, 0.83822471f, 0.83146961f, 0.82458930f, 0.81758481f, 0.81045720f,
    207             0.80320753f, 0.79583690f, 0.78834643f, 0.78073723f, 0.77301045f, 0.76516727f,
    208             0.75720885f, 0.74913639f, 0.74095113f, 0.73265427f, 0.72424708f, 0.71573083f,
    209             0.70710678f, 0.69837625f, 0.68954054f, 0.68060100f, 0.67155895f, 0.66241578f,
    210             0.65317284f, 0.64383154f, 0.63439328f, 0.62485949f, 0.61523159f, 0.60551104f,
    211             0.59569930f, 0.58579786f, 0.57580819f, 0.56573181f, 0.55557023f, 0.54532499f,
    212             0.53499762f, 0.52458968f, 0.51410274f, 0.50353838f, 0.49289819f, 0.48218377f,
    213             0.47139674f, 0.46053871f, 0.44961133f, 0.43861624f, 0.42755509f, 0.41642956f,
    214             0.40524131f, 0.39399204f, 0.38268343f, 0.37131719f, 0.35989504f, 0.34841868f,
    215             0.33688985f, 0.32531029f, 0.31368174f, 0.30200595f, 0.29028468f, 0.27851969f,
    216             0.26671276f, 0.25486566f, 0.24298018f, 0.23105811f, 0.21910124f, 0.20711138f,
    217             0.19509032f, 0.18303989f, 0.17096189f, 0.15885814f, 0.14673047f, 0.13458071f,
    218             0.12241068f, 0.11022221f, 0.09801714f, 0.08579731f, 0.07356456f, 0.06132074f,
    219             0.04906767f, 0.03680722f, 0.02454123f, 0.01227154f, 0.00000000f, -0.01227154f,
    220             -0.02454123f, -0.03680722f, -0.04906767f, -0.06132074f, -0.07356456f,
    221             -0.08579731f, -0.09801714f, -0.11022221f, -0.12241068f, -0.13458071f,
    222             -0.14673047f, -0.15885814f, -0.17096189f, -0.18303989f, -0.19509032f,
    223             -0.20711138f, -0.21910124f, -0.23105811f, -0.24298018f, -0.25486566f,
    224             -0.26671276f, -0.27851969f, -0.29028468f, -0.30200595f, -0.31368174f,
    225             -0.32531029f, -0.33688985f, -0.34841868f, -0.35989504f, -0.37131719f,
    226             -0.38268343f, -0.39399204f, -0.40524131f, -0.41642956f, -0.42755509f,
    227             -0.43861624f, -0.44961133f, -0.46053871f, -0.47139674f, -0.48218377f,
    228             -0.49289819f, -0.50353838f, -0.51410274f, -0.52458968f, -0.53499762f,
    229             -0.54532499f, -0.55557023f, -0.56573181f, -0.57580819f, -0.58579786f,
    230             -0.59569930f, -0.60551104f, -0.61523159f, -0.62485949f, -0.63439328f,
    231             -0.64383154f, -0.65317284f, -0.66241578f, -0.67155895f, -0.68060100f,
    232             -0.68954054f, -0.69837625f, -0.70710678f, -0.71573083f, -0.72424708f,
    233             -0.73265427f, -0.74095113f, -0.74913639f, -0.75720885f, -0.76516727f,
    234             -0.77301045f, -0.78073723f, -0.78834643f, -0.79583690f, -0.80320753f,
    235             -0.81045720f, -0.81758481f, -0.82458930f, -0.83146961f, -0.83822471f,
    236             -0.84485357f, -0.85135519f, -0.85772861f, -0.86397286f, -0.87008699f,
    237             -0.87607009f, -0.88192126f, -0.88763962f, -0.89322430f, -0.89867447f,
    238             -0.90398929f, -0.90916798f, -0.91420976f, -0.91911385f, -0.92387953f,
    239             -0.92850608f, -0.93299280f, -0.93733901f, -0.94154407f, -0.94560733f,
    240             -0.94952818f, -0.95330604f, -0.95694034f, -0.96043052f, -0.96377607f,
    241             -0.96697647f, -0.97003125f, -0.97293995f, -0.97570213f, -0.97831737f,
    242             -0.98078528f, -0.98310549f, -0.98527764f, -0.98730142f, -0.98917651f,
    243             -0.99090264f, -0.99247953f, -0.99390697f, -0.99518473f, -0.99631261f,
    244             -0.99729046f, -0.99811811f, -0.99879546f, -0.99932238f, -0.99969882f,
    245             -0.99992470f, -1.00000000f, -0.99992470f, -0.99969882f, -0.99932238f,
    246             -0.99879546f, -0.99811811f, -0.99729046f, -0.99631261f, -0.99518473f,
    247             -0.99390697f, -0.99247953f, -0.99090264f, -0.98917651f, -0.98730142f,
    248             -0.98527764f, -0.98310549f, -0.98078528f, -0.97831737f, -0.97570213f,
    249             -0.97293995f, -0.97003125f, -0.96697647f, -0.96377607f, -0.96043052f,
    250             -0.95694034f, -0.95330604f, -0.94952818f, -0.94560733f, -0.94154407f,
    251             -0.93733901f, -0.93299280f, -0.92850608f, -0.92387953f, -0.91911385f,
    252             -0.91420976f, -0.90916798f, -0.90398929f, -0.89867447f, -0.89322430f,
    253             -0.88763962f, -0.88192126f, -0.87607009f, -0.87008699f, -0.86397286f,
    254             -0.85772861f, -0.85135519f, -0.84485357f, -0.83822471f, -0.83146961f,
    255             -0.82458930f, -0.81758481f, -0.81045720f, -0.80320753f, -0.79583690f,
    256             -0.78834643f, -0.78073723f, -0.77301045f, -0.76516727f, -0.75720885f,
    257             -0.74913639f, -0.74095113f, -0.73265427f, -0.72424708f, -0.71573083f,
    258             -0.70710678f, -0.69837625f, -0.68954054f, -0.68060100f, -0.67155895f,
    259             -0.66241578f, -0.65317284f, -0.64383154f, -0.63439328f, -0.62485949f,
    260             -0.61523159f, -0.60551104f, -0.59569930f, -0.58579786f, -0.57580819f,
    261             -0.56573181f, -0.55557023f, -0.54532499f, -0.53499762f, -0.52458968f,
    262             -0.51410274f, -0.50353838f, -0.49289819f, -0.48218377f, -0.47139674f,
    263             -0.46053871f, -0.44961133f, -0.43861624f, -0.42755509f, -0.41642956f,
    264             -0.40524131f, -0.39399204f, -0.38268343f, -0.37131719f, -0.35989504f,
    265             -0.34841868f, -0.33688985f, -0.32531029f, -0.31368174f, -0.30200595f,
    266             -0.29028468f, -0.27851969f, -0.26671276f, -0.25486566f, -0.24298018f,
    267             -0.23105811f, -0.21910124f, -0.20711138f, -0.19509032f, -0.18303989f,
    268             -0.17096189f, -0.15885814f, -0.14673047f, -0.13458071f, -0.12241068f,
    269             -0.11022221f, -0.09801714f, -0.08579731f, -0.07356456f, -0.06132074f,
    270             -0.04906767f, -0.03680722f, -0.02454123f, -0.01227154f, -0.00000000f
    271          };
    272          
    273          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
    274          //---------------------------------------------------------------------------------------------------------------------
    275          
    276          
    277          //=====================================================================================================================
    278          //-------------------------------------- Public Functions -------------------------------------------------------------
    279          //=====================================================================================================================
    280          
    281          
    282          
    283          /**
    284           *  @brief      Calculate \f$ sin(\theta) \f$
    285           *  @details    This function calculates \f$ sin(\theta) \f$ using Taylor 7-th order polynomial.
    286           *
    287           *  \f[
    288           *      \begin{aligned}
    289           *          & \theta=[-\pi; \pi] \\
    290           *          & sin(\theta) = \theta - \frac{\theta^3}{3!} + \frac{\theta^5}{5!} - \frac{\theta^7}{7!}\\
    291           *          & sin(\theta) = \theta \cdot \left (1 - \frac{\theta^2}{6} \cdot \left (1 - \frac{\theta^2}{20} \cdot \left ((1 - \frac{\theta^2}{42}\right )\right )\right)\\
    292           *          & sin(\theta) = \theta(d_1 + \theta^2(d_3 + \theta^2(d_5 + \theta^2\cdot d_7)))
    293           *      \end{aligned}
    294           *  \f]
    295           *
    296           * where:
    297           *
    298           *  \f[
    299           *      \begin{aligned}
    300           *          & d_1 =   1\\
    301           *          & d_3 = -\frac{1}{3!}\\
    302           *          & d_5 =  \frac{1}{5!}\\
    303           *          & d_7 = -\frac{1}{7!}
    304           *      \end{aligned}
    305           *  \f]
    306           *
    307           * In fractional implementation \f$\theta\f$ value is in range [-1; 1) that corresponds to \f$[-\pi; \pi]\f$,
    308           * thus the coefficients 'd' needs to be scaled. Assuming \f$ x = \theta \cdot \pi \f$
    309           *
    310           * \f[
    311           *  \begin{aligned}
    312           *      & sin(x) = x(c_1 + x^2(c_3 + x^2(c_5 + x^2\cdot c_7)))\\ \\
    313           *      & c_1 = d_1 \cdot \pi\\
    314           *      & c_3 = d_3 \cdot \pi^3\\
    315           *      & c_5 = d_5 \cdot \pi^5\\
    316           *      & c_7 = d_7 \cdot \pi^7
    317           * \end{aligned}
    318           * \f]
    319           *
    320           *  The 7-th order polynomial approximation of the sine function
    321           *  has very good accuracy in range [-pi/2; pi/2] of argument, but in wider
    322           *  range the calculation error is quickly growing up. Therefore the sine
    323           *  function is approximated only in range [-pi/2; pi/2] and it is used the
    324           *  symmetry of the sine function [sin(alpha) = sin(pi - alpha)].
    325           *  Therefore the alpha argument is in range [-pi/2; pi/2) that corresponds
    326           *  to x [-0.5; 0.5).
    327           *  To make calculations more precise (because we need to use the value
    328           *  of x^2 rounded to 16-bit fractional number in our calculations),
    329           *  the given argument value x (that is in range [-0.5; 0.5)) is shifted
    330           *  by 1 bit to the left (multiplied by 2), then the calculated x^2 value
    331           *  is in range [-1; 1) instead of [-0.25; 0.25).
    332           *  Then the polynomial coefficients 'c' needs to be scaled:
    333           *
    334           * \f[
    335           *      \begin{aligned}
    336           *          & b_1 = \frac{c_1}{2}\\
    337           *          & b_3 = \frac{c_3}{2^3}\\
    338           *          & b_5 = \frac{c_5}{2^5}\\
    339           *          & b_7 = \frac{c_7}{2^7}
    340           *      \end{aligned}
    341           * \f]
    342           *
    343           * To avoid the saturation error during the polynomial calculation
    344           * the coefficients 'b' are divided by 2. After the polynomial calculation
    345           * the result is multiplied by 2 (shifted by 1 bit to the left)
    346           * to take the right result (in range [-1; 1)).
    347           *
    348           * \f[
    349           * \begin{aligned}
    350           *     & a_1 = \frac{b_1}{2} = \frac{\pi}{2^2}         &&=  0.785398163\\
    351           *     & a_3 = \frac{b_3}{2} = \frac{-\pi}{3!\cdot2^4} &&= -0.322982049\\
    352           *     & a_5 = \frac{b_5}{2} = \frac{\pi}{5!\cdot2^5}  &&=  0.039846313\\
    353           *     & a_7 = \frac{b_7}{2} = \frac{-\pi}{7!\cdot2^7} &&= -0.002340877
    354           * \end{aligned}
    355           * \f]
    356           *
    357           * In Q1.15 fractional representation:
    358           * \f[
    359           * \begin{aligned}
    360           *      & a_1 = 0x6488 \\
    361           *      & a_3 = 0xD6A9\\
    362           *      & a_5 = 0x051A\\
    363           *      & a_7 = 0xFFB3\\ \\
    364           *      & sin(\pi \cdot x) = (x<<1)\cdot(a_1 + (x<<1)^2(a_3 + (x<<1)^2(a_5 + (x<<1)^2\cdot a_7))) << 1
    365           * \end{aligned}
    366           * \f]
    367           *
    368           *  @param[in]    x in Q1.15 notation (fractional representation of \f$\theta\f$, \f$\pi\f$ as base angle)
    369           *  @return       \f$ sin(\pi \cdot x) \f$ in Q1.15 notation
    370           */

   \                                 In section .text, align 2, keep-with-next
    371          sint32 MathCalc__Sin(sint16 x)
    372          {
    373              sint16 x_2;
    374              sint32 sin_x;
    375              sint32 sq_x_2;
    376          
    377              // preliminary check to avoid overflow
    378              if (x ==  (sint16) MINUS_PI_2)
   \                     MathCalc__Sin: (+1)
   \   00000000   0x4601             MOV      R1,R0
   \   00000002   0xF511 0x4F80      CMN      R1,#+16384
   \   00000006   0xD102             BNE.N    ??MathCalc__Sin_0
    379              {
    380                  sin_x = (sint32) MINUS_ONE;  // to avoid overflow when calculating x_2 = 2*x
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable104_6  ;; 0xffff8000
   \   0000000C   0x4770             BX       LR
    381              }
    382              else if (x ==  (sint16) PI_2)
   \                     ??MathCalc__Sin_0: (+1)
   \   0000000E   0xF5B1 0x4F80      CMP      R1,#+16384
   \   00000012   0xD102             BNE.N    ??MathCalc__Sin_1
    383              {
    384                  sin_x =  ONE;  // to avoid overflow when calculating x_2 = 2*x
   \   00000014   0xF647 0x70FF      MOVW     R0,#+32767
   \   00000018   0x4770             BX       LR
    385              }
    386              else
    387              {
    388                  x_2 = x << 1; // 2*theta - calculation with overflow
   \                     ??MathCalc__Sin_1: (+1)
   \   0000001A   0x0440             LSLS     R0,R0,#+17
   \   0000001C   0x1400             ASRS     R0,R0,#+16
    389          
    390                  if ((x_2^x)<0)
   \   0000001E   0x4041             EORS     R1,R1,R0
   \   00000020   0xBF44             ITT      MI 
    391                  {
    392                      x_2 = - x_2;
   \   00000022   0x4240             RSBMI    R0,R0,#+0
   \   00000024   0xB200             SXTHMI   R0,R0
    393                  }
    394          
    395                  sq_x_2 = ((sint32)x_2 * (sint32) x_2)>>IQ15;       // (2*x)^2
   \   00000026   0xFB10 0xF100      SMULBB   R1,R0,R0
   \   0000002A   0x13C9             ASRS     R1,R1,#+15
    396          
    397                  sin_x  = (sint32) A7;
    398                  sin_x  = (sin_x * sq_x_2)>>IQ15;  // (2*x)^2 * a7
    399          
    400                  sin_x  = sin_x + A5;                // a5 + (2*x)^2 * a7
    401                  sin_x  = (sin_x * sq_x_2)>>IQ15;  // (2*x)^2 * (a5 + (2*x)^2 * a7)
    402          
    403                  sin_x  = sin_x + A3;                // a3 + (2*x)^2 * (a5 + (2*x)^2 * a7)
    404                  sin_x  = (sin_x * sq_x_2)>>IQ15;  // (2*x)^2 * (a3 + (2*x)^2 * (a5 + (2*x)^2 * a7))
    405          
    406                  sin_x  = sin_x + A1;                    // a1 + (2*x)^2 * (a3 + (2*x)^2 * (a5 + (2*x)^2 * a7))
    407                  sin_x  = (sin_x * (sint32) x_2)>>IQ15; // (2*x) * (a1 + (2*x)^2 * (a3 + (2*x)^2 * (a5 + (2*x)^2 * a7 )))
   \   0000002C   0xF06F 0x0298      MVN      R2,#+152
   \   00000030   0x434A             MULS     R2,R2,R1
   \   00000032   0x13D2             ASRS     R2,R2,#+15
   \   00000034   0xF602 0x2233      ADDW     R2,R2,#+2611
   \   00000038   0x434A             MULS     R2,R2,R1
   \   0000003A   0x.... 0x....      LDR.W    R3,??DataTable104_7  ;; 0xffffad51
   \   0000003E   0xEB03 0x32E2      ADD      R2,R3,R2, ASR #+15
   \   00000042   0x4351             MULS     R1,R1,R2
   \   00000044   0x13C9             ASRS     R1,R1,#+15
   \   00000046   0xF501 0x4149      ADD      R1,R1,#+51456
   \   0000004A   0x3110             ADDS     R1,R1,#+16
   \   0000004C   0x4348             MULS     R0,R0,R1
   \   0000004E   0x13C0             ASRS     R0,R0,#+15
    408                                                        // IQ15-1 instead of IQ15 to compensate the coefficient scaling
    409              }
    410              return (sin_x);
   \   00000050   0x4770             BX       LR               ;; return
    411          }
    412          
    413          
    414          //---------------------------------------------------------------------------------------------------------------------
    415          /**
    416           *  @brief      Calculate \f$ cos(\theta) \f$
    417           *  @details    \f$ cos(\theta) \f$ is calculated as \f$sin(\theta + \frac{\pi}{2})\f$.
    418           *
    419           *
    420           *  @param[in]    x in Q1.15 notation (fractional representation of \f$\theta\f$, \f$\pi\f$ as base angle)
    421           *  @return       \f$ cos(\pi \cdot x) \f$ in Q1.15 notation
    422           */

   \                                 In section .text, align 2, keep-with-next
    423          sint32 MathCalc__Cos(sint16 x)
    424          {
    425              sint32 cos_x;
    426              x = PI_2 + x;  // x + pi/2
    427              cos_x = MathCalc__Sin(x);
   \                     MathCalc__Cos: (+1)
   \   00000000   0xF500 0x4080      ADD      R0,R0,#+16384
   \   00000004   0xB200             SXTH     R0,R0
   \   00000006   0x4601             MOV      R1,R0
   \   00000008   0xF511 0x4F80      CMN      R1,#+16384
   \   0000000C   0xD102             BNE.N    ??MathCalc__Cos_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable104_6  ;; 0xffff8000
   \   00000012   0x4770             BX       LR
   \                     ??MathCalc__Cos_0: (+1)
   \   00000014   0xF5B1 0x4F80      CMP      R1,#+16384
   \   00000018   0xD102             BNE.N    ??MathCalc__Cos_1
   \   0000001A   0xF647 0x70FF      MOVW     R0,#+32767
   \   0000001E   0x4770             BX       LR
   \                     ??MathCalc__Cos_1: (+1)
   \   00000020   0x0440             LSLS     R0,R0,#+17
   \   00000022   0x1400             ASRS     R0,R0,#+16
   \   00000024   0x4041             EORS     R1,R1,R0
   \   00000026   0xBF44             ITT      MI 
   \   00000028   0x4240             RSBMI    R0,R0,#+0
   \   0000002A   0xB200             SXTHMI   R0,R0
   \   0000002C   0xFB10 0xF100      SMULBB   R1,R0,R0
   \   00000030   0x13C9             ASRS     R1,R1,#+15
   \   00000032   0xF06F 0x0298      MVN      R2,#+152
   \   00000036   0x434A             MULS     R2,R2,R1
   \   00000038   0x13D2             ASRS     R2,R2,#+15
   \   0000003A   0xF602 0x2233      ADDW     R2,R2,#+2611
   \   0000003E   0x434A             MULS     R2,R2,R1
   \   00000040   0x.... 0x....      LDR.W    R3,??DataTable104_7  ;; 0xffffad51
   \   00000044   0xEB03 0x32E2      ADD      R2,R3,R2, ASR #+15
   \   00000048   0x4351             MULS     R1,R1,R2
   \   0000004A   0x13C9             ASRS     R1,R1,#+15
   \   0000004C   0xF501 0x4149      ADD      R1,R1,#+51456
   \   00000050   0x3110             ADDS     R1,R1,#+16
   \   00000052   0x4348             MULS     R0,R0,R1
   \   00000054   0x13C0             ASRS     R0,R0,#+15
    428          
    429              return (cos_x);
   \   00000056   0x4770             BX       LR               ;; return
    430          }
    431          
    432          
    433          
    434          /**
    435           *  @brief      Calculates the sine and cosine based on alpha, beta and modulus components.
    436           *
    437           *  @param      sin, beta and modulus
    438           *  @return     sine and cosine
    439           */

   \                                 In section .text, align 2, keep-with-next
    440          void MathCalc__GetSinCos(MATHCALC_MOD_SIN_COS_TYPE *data)
    441          {
    442              // ************ Sin and Cos calculations **********************
    443              if(data->Beta > 0)
   \                     MathCalc__GetSinCos: (+1)
   \   00000000   0x6841             LDR      R1,[R0, #+4]
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xDB05             BLT.N    ??MathCalc__GetSinCos_0
    444              {
    445                  data->Sin = 32767;
    446                  if(data->Beta < (data->Mod << 15))
   \   00000006   0x6883             LDR      R3,[R0, #+8]
   \   00000008   0xF647 0x72FF      MOVW     R2,#+32767
   \   0000000C   0xEBB1 0x3FC3      CMP      R1,R3, LSL #+15
   \   00000010   0xE008             B.N      ??MathCalc__GetSinCos_1
    447                  {
    448                      if(data->Mod == 0)
    449                      {
    450                          data->Mod = 1;
    451                      }
    452                      data->Sin = data->Beta / (data->Mod);  // Q.30 / Q.15 => Q.15;
    453                  }
    454              }
    455              else if(data->Beta < 0)
   \                     ??MathCalc__GetSinCos_0: (+1)
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD50E             BPL.N    ??MathCalc__GetSinCos_2
    456              {
    457                  data->Sin = -32768;
    458                  if((-data->Beta) < (data->Mod << 15))
   \   00000016   0x6883             LDR      R3,[R0, #+8]
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable104_6  ;; 0xffff8000
   \   0000001C   0xF1C1 0x0C00      RSB      R12,R1,#+0
   \   00000020   0xEBBC 0x3FC3      CMP      R12,R3, LSL #+15
   \                     ??MathCalc__GetSinCos_1: (+1)
   \   00000024   0xDA07             BGE.N    ??MathCalc__GetSinCos_3
    459                  {
    460                      if(data->Mod == 0)
   \   00000026   0xB90B             CBNZ.N   R3,??MathCalc__GetSinCos_4
    461                      {
    462                          data->Mod = 1;
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0x6082             STR      R2,[R0, #+8]
    463                      }
    464                      data->Sin = data->Beta / (data->Mod);  // Q.30 / Q.15 => Q.15;
   \                     ??MathCalc__GetSinCos_4: (+1)
   \   0000002C   0x6882             LDR      R2,[R0, #+8]
   \   0000002E   0xFB91 0xF2F2      SDIV     R2,R1,R2
   \   00000032   0xE000             B.N      ??MathCalc__GetSinCos_3
    465                  }
    466              }
    467              else
    468              {
    469                  data->Sin = 0;
   \                     ??MathCalc__GetSinCos_2: (+1)
   \   00000034   0x2200             MOVS     R2,#+0
   \                     ??MathCalc__GetSinCos_3: (+1)
   \   00000036   0x60C2             STR      R2,[R0, #+12]
    470              }
    471          
    472              if(data->Alpha > 0)
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0x2901             CMP      R1,#+1
   \   0000003C   0xDB05             BLT.N    ??MathCalc__GetSinCos_5
    473              {
    474                  data->Cos = 32767;
    475                  if(data->Alpha < ( data->Mod << 15))
   \   0000003E   0x6883             LDR      R3,[R0, #+8]
   \   00000040   0xF647 0x72FF      MOVW     R2,#+32767
   \   00000044   0xEBB1 0x3FC3      CMP      R1,R3, LSL #+15
   \   00000048   0xE008             B.N      ??MathCalc__GetSinCos_6
    476                  {
    477                      if(data->Mod == 0)
    478                      {
    479                          data->Mod = 1;
    480                      }
    481                      data->Cos = data->Alpha / (data->Mod); // Q.30 / Q.15 => Q.15;
    482                  }
    483              }
    484              else if(data->Alpha < 0)
   \                     ??MathCalc__GetSinCos_5: (+1)
   \   0000004A   0x2900             CMP      R1,#+0
   \   0000004C   0xD50F             BPL.N    ??MathCalc__GetSinCos_7
    485              {
    486                  data->Cos = -32768;
    487                  if((-data->Alpha) < (data->Mod << 15))
   \   0000004E   0x6883             LDR      R3,[R0, #+8]
   \   00000050   0x.... 0x....      LDR.W    R2,??DataTable104_6  ;; 0xffff8000
   \   00000054   0xF1C1 0x0C00      RSB      R12,R1,#+0
   \   00000058   0xEBBC 0x3FC3      CMP      R12,R3, LSL #+15
   \                     ??MathCalc__GetSinCos_6: (+1)
   \   0000005C   0xDA08             BGE.N    ??MathCalc__GetSinCos_8
    488                  {
    489                      if(data->Mod == 0)
   \   0000005E   0xB90B             CBNZ.N   R3,??MathCalc__GetSinCos_9
    490                      {
    491                          data->Mod = 1;
   \   00000060   0x2201             MOVS     R2,#+1
   \   00000062   0x6082             STR      R2,[R0, #+8]
    492                      }
    493                      data->Cos = data->Alpha / (data->Mod); // Q.30 / Q.15 => Q.15;
   \                     ??MathCalc__GetSinCos_9: (+1)
   \   00000064   0x6882             LDR      R2,[R0, #+8]
   \   00000066   0xFB91 0xF2F2      SDIV     R2,R1,R2
   \   0000006A   0x6102             STR      R2,[R0, #+16]
    494                  }
    495              }
    496              else
    497              {
    498                  data->Cos = 0;
    499              }
    500          }
   \   0000006C   0x4770             BX       LR
   \                     ??MathCalc__GetSinCos_7: (+1)
   \   0000006E   0x2200             MOVS     R2,#+0
   \                     ??MathCalc__GetSinCos_8: (+1)
   \   00000070   0x6102             STR      R2,[R0, #+16]
   \   00000072   0x4770             BX       LR               ;; return
    501          
    502          
    503          /**
    504           * It calculates the linear interpolation between two points. The range of x's AND y's variables must to
    505           * be within -1 and +1 in fixed point (Q15 format). No values outside this range is allowed to be used.
    506           * The equation is as follow: deltaY/deltaX*(value - x0) + y0.
    507           * @param y1 is Y coordinate of the point 1
    508           * @param x1 is X coordinate of the point 1
    509           * @param y0 is Y coordinate of the point 0
    510           * @param x0 is X coordinate of the point 0
    511           * @param value is the value to be interpolated within the x1 and x0
    512           * @return
    513           */

   \                                 In section .text, align 2, keep-with-next
    514          sint32 MathCalc__Interpolate(sint32 y1, sint32 x1, sint32 y0, sint32 x0, sint32 value)
    515          
    516          {
   \                     MathCalc__Interpolate: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    517              sint32 ret_val;
    518              sint32 temp;
    519          
    520              temp = (y1 - y0); // Q15 - Q15 = Q15
    521              temp = temp*(value - x0);                               // Q15 * (Q15 - Q15) = Q31
   \   00000002   0x1A80             SUBS     R0,R0,R2
   \   00000004   0xF8DD 0xC004      LDR      R12,[SP, #+4]
   \   00000008   0xEBAC 0x0C03      SUB      R12,R12,R3
   \   0000000C   0xFB00 0xF00C      MUL      R0,R0,R12
    522          
    523              if( (x1 - x0) )
   \   00000010   0x1AC9             SUBS     R1,R1,R3
   \   00000012   0xBF1A             ITTE     NE 
    524              {
    525                  temp = temp/(x1 - x0); // Q31/Q15 = Q15
    526                  temp = temp + y0;          // Q15 + Q15 = Q15
   \   00000014   0xFB90 0xF0F1      SDIVNE   R0,R0,R1
   \   00000018   0x1810             ADDNE    R0,R2,R0
    527              }
    528              else
    529              {
    530                  temp = 0;                                   // To prevent any division by 0.
   \   0000001A   0x2000             MOVEQ    R0,#+0
    531              }
    532          
    533              ret_val = temp;
    534              return(ret_val);
   \   0000001C   0xB001             ADD      SP,SP,#+4
   \   0000001E   0x4770             BX       LR               ;; return
    535          }
    536          
    537          
    538          
    539          
    540          
    541          //---------------------------------------------------------------------------------------------------------------------
    542          /**
    543           *  @brief      Calculates the square root of the argument.
    544           *  @details
    545           *  This function calculates Sqrt(X) using a Newton-Raphson method (10 iteration is the recommended value).
    546           *  The input value is truncated to the 16 most significant bits
    547           *  @param[in]  value   = input value in Q2.30 format
    548           *  @param[out] ret_val = result in Q17.15 notation
    549           */

   \                                 In section .text, align 4, keep-with-next
    550          sint32 MathCalc__SqrtNwtRph(sint32 value)
    551          {
    552              uint8 i;
    553              sint32 ret_val;
    554              sint32 x1;
    555          
    556              ret_val = 0;
   \                     MathCalc__SqrtNwtRph: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    557              //truncating
    558              value = IQMATH__IQXtoIQY(value, IQ30, IQ15);
   \   00000002   0x13C0             ASRS     R0,R0,#+15
    559          
    560              if(value > 0)
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xDB09             BLT.N    ??MathCalc__SqrtNwtRph_0
    561              {
    562                  x1 = value;
    563                  ret_val = ( x1 + 1 )>>1; /* +1 for rounding */
   \   00000008   0x1C41             ADDS     R1,R0,#+1
   \   0000000A   0x1049             ASRS     R1,R1,#+1
    564                  for (i = 10; i > 0; i--)
   \   0000000C   0x220A             MOVS     R2,#+10
   \   0000000E   0x03C0             LSLS     R0,R0,#+15
    565                  {
    566                      ret_val = (ret_val + ((x1<<15) / ret_val))>>1;
   \                     ??MathCalc__SqrtNwtRph_1: (+1)
   \   00000010   0xFB90 0xF3F1      SDIV     R3,R0,R1
   \   00000014   0x1859             ADDS     R1,R3,R1
   \   00000016   0x1049             ASRS     R1,R1,#+1
    567                  }
   \   00000018   0x1E52             SUBS     R2,R2,#+1
   \   0000001A   0xD1F9             BNE.N    ??MathCalc__SqrtNwtRph_1
    568              }
    569              return ret_val;
   \                     ??MathCalc__SqrtNwtRph_0: (+1)
   \   0000001C   0x4608             MOV      R0,R1
   \   0000001E   0x4770             BX       LR               ;; return
    570          }
    571          
    572          
    573          
    574          
    575          
    576          
    577          
    578          /**
    579           *  @brief      Calculates the square root of the argument.
    580           *  @details
    581           *  This function calculates Sqrt(X) using a LookUpTable approach.
    582           *  @param[in]  value   = input value in Q2.30 format
    583           *  @param[out] ret_val = result in Q17.15 notation
    584           */

   \                                 In section .text, align 2, keep-with-next
    585          sint32 MathCalc__SqrtLut(sint32 value)
    586          {
    587              sint32 ret_val;
    588              sint32 value_iq15;
    589          
    590              ret_val = 0;
   \                     MathCalc__SqrtLut: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    591              //truncating
    592              value_iq15 = IQMATH__IQXtoIQY(value, IQ30, IQ15);
   \   00000002   0x13C2             ASRS     R2,R0,#+15
    593          
    594              // saturation (not to exceed the LUT size)
    595              if (value_iq15 > IQMATH__IQMAX(IQ15))
   \   00000004   0xF5B2 0x4F00      CMP      R2,#+32768
   \   00000008   0xBFA8             IT       GE 
    596              {
    597                  value_iq15 = IQMATH__IQMAX(IQ15);
   \   0000000A   0xF647 0x72FF      MOVWGE   R2,#+32767
    598              }
    599          
    600              if(value > 0)
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xDB10             BLT.N    ??MathCalc__SqrtLut_0
    601              {
    602                  ret_val = (sint32)SquareRootTable[value_iq15 / FACTOR_DIVIDER];
   \   00000012   0x.... 0x....      ADR.W    R1,SquareRootTable
   \   00000016   0x0A12             LSRS     R2,R2,#+8
   \   00000018   0xF931 0x1012      LDRSH    R1,[R1, R2, LSL #+1]
    603          
    604                  ret_val = (ret_val + (value / ret_val)) >> 1;
   \   0000001C   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   00000020   0x1851             ADDS     R1,R2,R1
   \   00000022   0x1049             ASRS     R1,R1,#+1
    605                  ret_val = (ret_val + (value / ret_val)) >> 1;
   \   00000024   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   00000028   0x1851             ADDS     R1,R2,R1
   \   0000002A   0x1049             ASRS     R1,R1,#+1
    606                  ret_val = (ret_val + (value / ret_val)) >> 1;
   \   0000002C   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000030   0x1840             ADDS     R0,R0,R1
   \   00000032   0x1041             ASRS     R1,R0,#+1
    607              }
    608          
    609              return(ret_val);
   \                     ??MathCalc__SqrtLut_0: (+1)
   \   00000034   0x4608             MOV      R0,R1
   \   00000036   0x4770             BX       LR               ;; return
    610          }
    611          
    612          
    613          /**
    614           *  @brief      Calculates the square root of the argument.
    615           *  @details
    616           *  This function calculates Sqrt(X) using the floating point square root function in IAR ARM compiler.
    617           *  Cast is needed to adapt the in and out values.
    618           *  @param[in]  value  = input value in Q2.30 format
    619           *  @param[out] ret_val = result in Q17.15 notation
    620           */

   \                                 In section .text, align 2, keep-with-next
    621          sint32 MathCalc__SqrtFloat(sint32 value)
    622          {
   \                     MathCalc__SqrtFloat: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xEE00 0x0A10      VMOV     S0,R0
   \   00000006   0xB081             SUB      SP,SP,#+4
    623              sint32 ret_val;
    624          
    625          #if ((__ICCARM__ == 1) && (__CORE__ == __ARM7EM__))  //  ARM IAR Compiler && CortexM4
    626          
    627              ret_val = (sint32)sqrtf((float)value);
    628          
    629          #else
    630          
    631              ret_val = (sint32)sqrt((float)value);
    632          
    633          #endif
    634          
    635              return ret_val;
   \   00000008   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000000C   0x.... 0x....      BL       sqrtf
   \   00000010   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000014   0xEE10 0x0A10      VMOV     R0,S0
   \   00000018   0xB001             ADD      SP,SP,#+4
   \   0000001A   0xBD00             POP      {PC}             ;; return
    636          }
    637          
    638          
    639          /* Interpolation function usage example
    640           *      - Call example:
    641           *           - MathCalc__GetInterpolation(ctrlParm.TeRef, (MATHCALC_LUT_TYPE *)&Mtpa_Lut, MTPA_LUT_SIZE);
    642           *      - Table example:
    643           *           const MATHCALC_LUT_TYPE Mtpa_Lut[] =
    644           *           {
    645           *                   Input Vector                 Output Vector
    646           *               {TORQUE_TO_IQ(MTPA_TQ_REF_0), FLUX_TO_IQ(MTPA_FLUX_REF_0)},
    647           *               {TORQUE_TO_IQ(MTPA_TQ_REF_1), FLUX_TO_IQ(MTPA_FLUX_REF_1)},
    648           *               {TORQUE_TO_IQ(MTPA_TQ_REF_2), FLUX_TO_IQ(MTPA_FLUX_REF_2)},
    649           *               {TORQUE_TO_IQ(MTPA_TQ_REF_3), FLUX_TO_IQ(MTPA_FLUX_REF_3)},
    650           *               {TORQUE_TO_IQ(MTPA_TQ_REF_4), FLUX_TO_IQ(MTPA_FLUX_REF_4)},
    651           *               {TORQUE_TO_IQ(MTPA_TQ_REF_5), FLUX_TO_IQ(MTPA_FLUX_REF_5)},
    652           *               {TORQUE_TO_IQ(MTPA_TQ_REF_6), FLUX_TO_IQ(MTPA_FLUX_REF_6)},
    653           *               {TORQUE_TO_IQ(MTPA_TQ_REF_7), FLUX_TO_IQ(MTPA_FLUX_REF_7)}
    654           *           };
    655           *     - Size definition example:
    656           *         - #define MTPA_LUT_SIZE           (sizeof(Mtpa_Lut)/8)
    657           */

   \                                 In section .text, align 2, keep-with-next
    658          sint32 MathCalc__GetInterpolation(sint32 value, MATHCALC_LUT_TYPE * lut, unsigned char size)
    659          {
   \                     MathCalc__GetInterpolation: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0xEB01 0x02C2      ADD      R2,R1,R2, LSL #+3
   \   00000006   0xF1A2 0x0310      SUB      R3,R2,#+16
    660              sint32 index;
    661              sint32 tmp1;
    662              sint32 tmp2;
    663              sint32 output;
    664              sint32 lut_x_max;
    665              sint32 lut_x_min;
    666              sint32 lut_x_step;
    667          
    668              lut_x_max  = lut[size-1].input;
    669              lut_x_min  = lut[0].input;
    670              lut_x_step = MATHCALC__ABS(lut[size-1].input - lut[size-2].input);
   \   0000000A   0xF852 0x5C10      LDR      R5,[R2, #-16]
   \   0000000E   0x689C             LDR      R4,[R3, #+8]
   \   00000010   0x680E             LDR      R6,[R1, #+0]
   \   00000012   0x1B62             SUBS     R2,R4,R5
   \   00000014   0xBF48             IT       MI 
   \   00000016   0x1B2A             SUBMI    R2,R5,R4
    671          
    672              if (value >= lut_x_max)
   \   00000018   0x42A0             CMP      R0,R4
   \   0000001A   0xBFA8             IT       GE 
    673              {
    674                  index = size - 1;
    675                  output = lut[index].output;
   \   0000001C   0x68D8             LDRGE    R0,[R3, #+12]
   \   0000001E   0xDA16             BGE.N    ??MathCalc__GetInterpolation_0
    676              }
    677              else if (value <= lut_x_min)
   \   00000020   0x4286             CMP      R6,R0
   \   00000022   0xBFA8             IT       GE 
    678              {
    679                  index = 0;
    680                  output = lut[index].output;
   \   00000024   0x6848             LDRGE    R0,[R1, #+4]
   \   00000026   0xDA12             BGE.N    ??MathCalc__GetInterpolation_0
    681              }
    682              else
    683              {
    684                  index = (sint32)(MATHCALC__ABS(value-lut[0].input)/lut_x_step);
   \   00000028   0x1B83             SUBS     R3,R0,R6
   \   0000002A   0xBF48             IT       MI 
   \   0000002C   0x1A33             SUBMI    R3,R6,R0
   \   0000002E   0xFB93 0xF3F2      SDIV     R3,R3,R2
    685          
    686                  tmp1 = MATHCALC__ABS(value - lut[index].input);
   \   00000032   0xF851 0x4033      LDR      R4,[R1, R3, LSL #+3]
   \   00000036   0x1B05             SUBS     R5,R0,R4
   \   00000038   0xBF48             IT       MI 
   \   0000003A   0x1A25             SUBMI    R5,R4,R0
    687                  tmp2 = lut[index+1].output - lut[index].output;
    688                  output = lut[index].output + (tmp1*tmp2)/lut_x_step;
   \   0000003C   0xEB01 0x00C3      ADD      R0,R1,R3, LSL #+3
   \   00000040   0x6841             LDR      R1,[R0, #+4]
   \   00000042   0x68C0             LDR      R0,[R0, #+12]
   \   00000044   0x1A40             SUBS     R0,R0,R1
   \   00000046   0x4368             MULS     R0,R0,R5
   \   00000048   0xFB90 0xF0F2      SDIV     R0,R0,R2
   \   0000004C   0x1840             ADDS     R0,R0,R1
    689              }
    690          
    691              return(output);
   \                     ??MathCalc__GetInterpolation_0: (+1)
   \   0000004E   0xBC70             POP      {R4-R6}
   \   00000050   0x4770             BX       LR               ;; return
    692          }
    693          

   \                                 In section .text, align 2, keep-with-next
    694          void MathCalc__GetInterpolation2(MATHCALC_LUT2_TYPE * in_out, MATHCALC_LUT2_TYPE * lut, unsigned char size)
    695          {
   \                     MathCalc__GetInterpolation2: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    696              sint32 index;
    697              sint32 tmp1;
    698              sint32 tmp2;
    699              sint32 lut_x_max;
    700              sint32 lut_x_min;
    701              sint32 lut_x_step;
    702          
    703              lut_x_max  = lut[size-1].input;
   \   00000002   0xEB02 0x0342      ADD      R3,R2,R2, LSL #+1
   \   00000006   0xEB01 0x0383      ADD      R3,R1,R3, LSL #+2
   \   0000000A   0xF1A3 0x0418      SUB      R4,R3,#+24
    704              lut_x_min  = lut[0].input;
    705              lut_x_step = MATHCALC__ABS(lut[size-1].input - lut[size-2].input);
   \   0000000E   0xF853 0x7C18      LDR      R7,[R3, #-24]
   \   00000012   0x68E4             LDR      R4,[R4, #+12]
   \   00000014   0x680E             LDR      R6,[R1, #+0]
   \   00000016   0x4625             MOV      R5,R4
   \   00000018   0x1BE3             SUBS     R3,R4,R7
   \   0000001A   0xBF48             IT       MI 
   \   0000001C   0x1B3B             SUBMI    R3,R7,R4
    706          
    707              if (in_out->input >= lut_x_max)
   \   0000001E   0x6804             LDR      R4,[R0, #+0]
   \   00000020   0x42AC             CMP      R4,R5
   \   00000022   0xDB0A             BLT.N    ??MathCalc__GetInterpolation2_0
    708              {
    709                  index = size - 1;
   \   00000024   0x1E52             SUBS     R2,R2,#+1
    710                  in_out->output1 = lut[index].output1;
   \   00000026   0xEB02 0x0342      ADD      R3,R2,R2, LSL #+1
   \   0000002A   0xEB01 0x0183      ADD      R1,R1,R3, LSL #+2
    711                  in_out->output2 = lut[index].output2;
    712              }
    713              else if (in_out->input <= lut_x_min)
    714              {
    715                  index = 0;
    716                  in_out->output1 = lut[index].output1;
   \   0000002E   0x684A             LDR      R2,[R1, #+4]
   \   00000030   0x6042             STR      R2,[R0, #+4]
    717                  in_out->output2 = lut[index].output2;
   \   00000032   0x6889             LDR      R1,[R1, #+8]
   \   00000034   0x6081             STR      R1,[R0, #+8]
    718              }
    719              else
    720              {
    721                  index = (sint32)(MATHCALC__ABS(in_out->input-lut[0].input)/lut_x_step);
    722          
    723                  tmp1 = MATHCALC__ABS(in_out->input - lut[index].input);
    724                  tmp2 = lut[index+1].output1 - lut[index].output1;
    725                  in_out->output1 = lut[index].output1 + (tmp1*tmp2)/lut_x_step;
    726          
    727                  tmp2 = lut[index+1].output2 - lut[index].output2;
    728                  in_out->output2 = lut[index].output2 + (tmp1*tmp2)/lut_x_step;
    729              }
    730          }
   \   00000036   0xBCF0             POP      {R4-R7}
   \   00000038   0x4770             BX       LR
   \                     ??MathCalc__GetInterpolation2_0: (+1)
   \   0000003A   0x42A6             CMP      R6,R4
   \   0000003C   0xDB05             BLT.N    ??MathCalc__GetInterpolation2_1
   \   0000003E   0x684A             LDR      R2,[R1, #+4]
   \   00000040   0x6042             STR      R2,[R0, #+4]
   \   00000042   0x6889             LDR      R1,[R1, #+8]
   \   00000044   0x6081             STR      R1,[R0, #+8]
   \   00000046   0xBCF0             POP      {R4-R7}
   \   00000048   0x4770             BX       LR
   \                     ??MathCalc__GetInterpolation2_1: (+1)
   \   0000004A   0x1BA2             SUBS     R2,R4,R6
   \   0000004C   0xBF48             IT       MI 
   \   0000004E   0x1B32             SUBMI    R2,R6,R4
   \   00000050   0xFB92 0xF2F3      SDIV     R2,R2,R3
   \   00000054   0xEB02 0x0542      ADD      R5,R2,R2, LSL #+1
   \   00000058   0x00AD             LSLS     R5,R5,#+2
   \   0000005A   0x586E             LDR      R6,[R5, R1]
   \   0000005C   0x1BA2             SUBS     R2,R4,R6
   \   0000005E   0xBF48             IT       MI 
   \   00000060   0x1B32             SUBMI    R2,R6,R4
   \   00000062   0x1869             ADDS     R1,R5,R1
   \   00000064   0x684C             LDR      R4,[R1, #+4]
   \   00000066   0x690D             LDR      R5,[R1, #+16]
   \   00000068   0x1B2D             SUBS     R5,R5,R4
   \   0000006A   0x4355             MULS     R5,R5,R2
   \   0000006C   0xFB95 0xF5F3      SDIV     R5,R5,R3
   \   00000070   0x192C             ADDS     R4,R5,R4
   \   00000072   0x6044             STR      R4,[R0, #+4]
   \   00000074   0x688C             LDR      R4,[R1, #+8]
   \   00000076   0x6949             LDR      R1,[R1, #+20]
   \   00000078   0x1B09             SUBS     R1,R1,R4
   \   0000007A   0x4351             MULS     R1,R1,R2
   \   0000007C   0xFB91 0xF1F3      SDIV     R1,R1,R3
   \   00000080   0x1909             ADDS     R1,R1,R4
   \   00000082   0x6081             STR      R1,[R0, #+8]
   \   00000084   0xBCF0             POP      {R4-R7}
   \   00000086   0x4770             BX       LR               ;; return
    731          
    732          
    733          
    734          

   \                                 In section .text, align 2, keep-with-next
    735          sint32 MathCalc__GetInterpolationFast(sint32 value, MATHCALC_LUT_EXT_TYPE *lut_ext)
    736          {
   \                     MathCalc__GetInterpolationFast: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    737              sint32 index;
    738              sint32 tmp1;
    739              sint32 tmp2;
    740              sint32 output;
    741              sint32 lut_x_max;
    742              sint32 lut_x_min;
    743          
    744              sint32 size     = *(lut_ext->sizeof_lut);
   \   00000002   0x688A             LDR      R2,[R1, #+8]
   \   00000004   0x6813             LDR      R3,[R2, #+0]
    745              sint32 step_inv = *(lut_ext->step_inv);
   \   00000006   0x684A             LDR      R2,[R1, #+4]
    746              MATHCALC_LUT_TYPE *lut = lut_ext->ptr_LUT;
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x6812             LDR      R2,[R2, #+0]
    747          
    748              lut_x_max  = lut[size-1].input;
    749              lut_x_min  = lut[0].input;
    750          
    751              if (value >= lut_x_max)
   \   0000000C   0xEB01 0x03C3      ADD      R3,R1,R3, LSL #+3
   \   00000010   0xF853 0x4C08      LDR      R4,[R3, #-8]
   \   00000014   0x42A0             CMP      R0,R4
   \   00000016   0xBFA8             IT       GE 
    752              {
    753                  index = size - 1;
    754                  output = lut[index].output;
   \   00000018   0xF853 0x0C04      LDRGE    R0,[R3, #-4]
   \   0000001C   0xDA13             BGE.N    ??MathCalc__GetInterpolationFast_0
    755              }
    756              else if (value <= lut_x_min)
   \   0000001E   0x680B             LDR      R3,[R1, #+0]
   \   00000020   0x4283             CMP      R3,R0
   \   00000022   0xBFA8             IT       GE 
    757              {
    758                  index = 0;
    759                  output = lut[index].output;
   \   00000024   0x6848             LDRGE    R0,[R1, #+4]
   \   00000026   0xDA0E             BGE.N    ??MathCalc__GetInterpolationFast_0
    760              }
    761              else
    762              {
    763                  // index calculation -- fast algorithm -- no division required
    764                  // step is already in absolute value
    765                  // input must be monotonically increasing -- abs is not required
    766                  // NO OVERFLOW MANAGEMENT--> always check the STEP and VALUES notation
    767                  // max_delta_y * delta_x must be represented in less than 16bit
    768                  // step_inv must be represented in less than 16bit
    769                  index = ((value-lut[0].input)*step_inv) >> INTERPOLATION_STEP_IQ;
   \   00000028   0x1AC3             SUBS     R3,R0,R3
   \   0000002A   0x4353             MULS     R3,R3,R2
   \   0000002C   0x13DB             ASRS     R3,R3,#+15
    770                  tmp1 = (value - lut[index].input)*step_inv;
    771                  tmp2 = lut[index+1].output - lut[index].output;
    772                  output = lut[index].output + ((tmp1*tmp2) >> INTERPOLATION_STEP_IQ);
   \   0000002E   0xEB01 0x04C3      ADD      R4,R1,R3, LSL #+3
   \   00000032   0xF851 0x1033      LDR      R1,[R1, R3, LSL #+3]
   \   00000036   0x6865             LDR      R5,[R4, #+4]
   \   00000038   0x1A40             SUBS     R0,R0,R1
   \   0000003A   0x68E1             LDR      R1,[R4, #+12]
   \   0000003C   0x4350             MULS     R0,R0,R2
   \   0000003E   0x1B49             SUBS     R1,R1,R5
   \   00000040   0x4348             MULS     R0,R0,R1
   \   00000042   0xEB05 0x30E0      ADD      R0,R5,R0, ASR #+15
    773              }
    774          
    775              return(output);
   \                     ??MathCalc__GetInterpolationFast_0: (+1)
   \   00000046   0xBC30             POP      {R4,R5}
   \   00000048   0x4770             BX       LR               ;; return
    776          }
    777          
    778          
    779          
    780          
    781          
    782          
    783          
    784          

   \                                 In section .text, align 2, keep-with-next
    785          void MathCalc__GetInterpolation2Fast(MATHCALC_LUT2_TYPE * in_out, MATHCALC_LUT2_EXT_TYPE *lut_ext)
    786          {
   \                     MathCalc__GetInterpolation2Fast: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    787              sint32 index;
    788              sint32 tmp1;
    789              sint32 tmp2;
    790              sint32 lut_x_max;
    791              sint32 lut_x_min;
    792          
    793              sint32 size     = *(lut_ext->sizeof_lut);
   \   00000002   0x688A             LDR      R2,[R1, #+8]
   \   00000004   0x6814             LDR      R4,[R2, #+0]
    794              sint32 step_inv = *(lut_ext->step_inv);
   \   00000006   0x684A             LDR      R2,[R1, #+4]
    795              MATHCALC_LUT2_TYPE *lut = lut_ext->ptr_LUT;
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x6812             LDR      R2,[R2, #+0]
    796          
    797              lut_x_max  = lut[size-1].input;
    798              lut_x_min  = lut[0].input;
    799          
    800              if (in_out->input >= lut_x_max)
   \   0000000C   0x6803             LDR      R3,[R0, #+0]
   \   0000000E   0xEB04 0x0544      ADD      R5,R4,R4, LSL #+1
   \   00000012   0xEB01 0x0585      ADD      R5,R1,R5, LSL #+2
   \   00000016   0xF855 0x5C0C      LDR      R5,[R5, #-12]
   \   0000001A   0x42AB             CMP      R3,R5
   \   0000001C   0xDB0A             BLT.N    ??MathCalc__GetInterpolation2Fast_0
    801              {
    802                  index = size - 1;
   \   0000001E   0x1E64             SUBS     R4,R4,#+1
    803                  in_out->output1 = lut[index].output1;
   \   00000020   0xEB04 0x0244      ADD      R2,R4,R4, LSL #+1
   \   00000024   0xEB01 0x0182      ADD      R1,R1,R2, LSL #+2
    804                  in_out->output2 = lut[index].output2;
    805              }
    806              else if (in_out->input <= lut_x_min)
    807              {
    808                  index = 0;
    809                  in_out->output1 = lut[index].output1;
   \   00000028   0x684A             LDR      R2,[R1, #+4]
   \   0000002A   0x6042             STR      R2,[R0, #+4]
    810                  in_out->output2 = lut[index].output2;
   \   0000002C   0x6889             LDR      R1,[R1, #+8]
   \   0000002E   0x6081             STR      R1,[R0, #+8]
    811              }
    812              else
    813              {
    814                  // index calculation -- fast algorithm -- no division required
    815                  // step is already in absolute value
    816                  // input must be monotonically increasing -- abs is not required
    817                  // NO OVERFLOW MANAGEMENT--> always check the STEP and VALUES notation
    818                  // max_delta_y * delta_x must be represented in less than 16bit
    819                  // step_inv must be represented in less than 16bit
    820                  index = ((in_out->input-lut[0].input)*step_inv)>> INTERPOLATION_STEP_IQ;
    821          
    822                  tmp1 = (in_out->input - lut[index].input)*step_inv;
    823          
    824                  tmp2 = lut[index+1].output1 - lut[index].output1;
    825                  in_out->output1 = lut[index].output1 + ((tmp1*tmp2) >> INTERPOLATION_STEP_IQ);
    826          
    827                  tmp2 = lut[index+1].output2 - lut[index].output2;
    828                  in_out->output2 = lut[index].output2 + ((tmp1*tmp2) >> INTERPOLATION_STEP_IQ);
    829              }
    830          }
   \   00000030   0xBC30             POP      {R4,R5}
   \   00000032   0x4770             BX       LR
   \                     ??MathCalc__GetInterpolation2Fast_0: (+1)
   \   00000034   0x680C             LDR      R4,[R1, #+0]
   \   00000036   0x429C             CMP      R4,R3
   \   00000038   0xDB05             BLT.N    ??MathCalc__GetInterpolation2Fast_1
   \   0000003A   0x684A             LDR      R2,[R1, #+4]
   \   0000003C   0x6042             STR      R2,[R0, #+4]
   \   0000003E   0x6889             LDR      R1,[R1, #+8]
   \   00000040   0x6081             STR      R1,[R0, #+8]
   \   00000042   0xBC30             POP      {R4,R5}
   \   00000044   0x4770             BX       LR
   \                     ??MathCalc__GetInterpolation2Fast_1: (+1)
   \   00000046   0x1B1C             SUBS     R4,R3,R4
   \   00000048   0x4354             MULS     R4,R4,R2
   \   0000004A   0x13E4             ASRS     R4,R4,#+15
   \   0000004C   0xEB04 0x0544      ADD      R5,R4,R4, LSL #+1
   \   00000050   0x00AC             LSLS     R4,R5,#+2
   \   00000052   0x5865             LDR      R5,[R4, R1]
   \   00000054   0x1B5B             SUBS     R3,R3,R5
   \   00000056   0x1861             ADDS     R1,R4,R1
   \   00000058   0x435A             MULS     R2,R2,R3
   \   0000005A   0x684B             LDR      R3,[R1, #+4]
   \   0000005C   0x690C             LDR      R4,[R1, #+16]
   \   0000005E   0x1AE4             SUBS     R4,R4,R3
   \   00000060   0x4354             MULS     R4,R4,R2
   \   00000062   0xEB03 0x33E4      ADD      R3,R3,R4, ASR #+15
   \   00000066   0x6043             STR      R3,[R0, #+4]
   \   00000068   0x688B             LDR      R3,[R1, #+8]
   \   0000006A   0x6949             LDR      R1,[R1, #+20]
   \   0000006C   0x1AC9             SUBS     R1,R1,R3
   \   0000006E   0x4351             MULS     R1,R1,R2
   \   00000070   0xEB03 0x31E1      ADD      R1,R3,R1, ASR #+15
   \   00000074   0x6081             STR      R1,[R0, #+8]
   \   00000076   0xBC30             POP      {R4,R5}
   \   00000078   0x4770             BX       LR               ;; return
    831          
    832          
    833          
    834          //---------------------------------------------------------------------------------------------------------------------
    835          /**
    836           *  @brief      Calculate sin and cos from angle, update the values in clrkParkGbl (using lookup table and linear interpolation in between).
    837           *
    838           *  @param      motTheta
    839           *  @return     sinTheta, cosTheta
    840           */

   \                                 In section .text, align 2, keep-with-next
    841          void MathCalc__SinCosLut(sint32 motTheta, SIN_COS_TYPE *parmPtr)
    842          {
   \                     MathCalc__SinCosLut: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    843              uint32 tempU32;
    844              uint32 tableIndex;
    845              sint32 remainder;
    846              sint32 y0;
    847              sint32 y1;
    848          
    849              tempU32 = (uint32)(( (uint16)motTheta ) * (uint32)SIN_TABLE_SIZE);
   \   00000002   0x0400             LSLS     R0,R0,#+16
   \   00000004   0x0A02             LSRS     R2,R0,#+8
    850              tableIndex = tempU32 >> 16;
    851              remainder = ( tempU32 & 0xFFFF) >> 1;
    852              if (remainder == 0)
   \   00000006   0x.... 0x....      ADR.W    R3,??sinTable
   \   0000000A   0x0C10             LSRS     R0,R2,#+16
   \   0000000C   0xF933 0x4010      LDRSH    R4,[R3, R0, LSL #+1]
   \   00000010   0xF100 0x0540      ADD      R5,R0,#+64
   \   00000014   0xF3C2 0x024E      UBFX     R2,R2,#+1,#+15
   \   00000018   0xB2ED             UXTB     R5,R5
   \   0000001A   0xB92A             CBNZ.N   R2,??MathCalc__SinCosLut_0
    853              {
    854                  parmPtr->Sin = sinTable[ tableIndex ];
   \   0000001C   0x600C             STR      R4,[R1, #+0]
    855                  parmPtr->Cos = sinTable[ ( tableIndex + COS_TABLE_OFFSET ) & ( SIN_TABLE_SIZE - 1 ) ];
   \   0000001E   0xF933 0x0015      LDRSH    R0,[R3, R5, LSL #+1]
   \   00000022   0x6048             STR      R0,[R1, #+4]
    856              }
    857              else
    858              {
    859                  y0 = sinTable[ tableIndex ];
    860                  y1 = sinTable[ ( tableIndex + 1 ) & ( SIN_TABLE_SIZE - 1 ) ];
    861                  y1 = ( ( y1 - y0 ) * remainder) >> 15;
    862                  parmPtr->Sin = y0 + y1;
    863          
    864                  y0 = sinTable[ ( tableIndex + COS_TABLE_OFFSET ) & ( SIN_TABLE_SIZE - 1 ) ];
    865                  y1 = sinTable[ ( tableIndex + COS_TABLE_OFFSET + 1 ) & ( SIN_TABLE_SIZE - 1 ) ];
    866                  y1 = ( ( y1 - y0 ) * remainder) >> 15;
    867                  parmPtr->Cos = y0 + y1;
    868              }
    869          }
   \   00000024   0xBC70             POP      {R4-R6}
   \   00000026   0x4770             BX       LR
   \                     ??MathCalc__SinCosLut_0: (+1)
   \   00000028   0x1C46             ADDS     R6,R0,#+1
   \   0000002A   0xB2F6             UXTB     R6,R6
   \   0000002C   0xF933 0x6016      LDRSH    R6,[R3, R6, LSL #+1]
   \   00000030   0x1B36             SUBS     R6,R6,R4
   \   00000032   0x4356             MULS     R6,R6,R2
   \   00000034   0xEB04 0x34E6      ADD      R4,R4,R6, ASR #+15
   \   00000038   0x600C             STR      R4,[R1, #+0]
   \   0000003A   0x3041             ADDS     R0,R0,#+65
   \   0000003C   0xB2C0             UXTB     R0,R0
   \   0000003E   0xF933 0x4015      LDRSH    R4,[R3, R5, LSL #+1]
   \   00000042   0xF933 0x0010      LDRSH    R0,[R3, R0, LSL #+1]
   \   00000046   0x1B00             SUBS     R0,R0,R4
   \   00000048   0x4350             MULS     R0,R0,R2
   \   0000004A   0xEB04 0x30E0      ADD      R0,R4,R0, ASR #+15
   \   0000004E   0x6048             STR      R0,[R1, #+4]
   \   00000050   0xBC70             POP      {R4-R6}
   \   00000052   0x4770             BX       LR               ;; return
    870          
    871          /**
    872           *  @brief      Calculate the atan2 function. The used method is the CORDIC method.
    873           *
    874           *  @param      x and y coordinates of the input vector. They are represent in Q15 with 1 as base.
    875           *  @return     angle in Q15 with PI as base.
    876           */

   \                                 In section .text, align 2, keep-with-next
    877          sint32 MathCalc__Arctan2(sint32 x, sint32 y)
    878          {
   \                     MathCalc__Arctan2: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    879          #if(ATAN2_USE_FOR_LOOP == 1)    // Better for program memory size.
    880              register sint32 theta;
    881              register sint32 i;
    882              register sint32 last_x;
    883              register sint32t x_temp;
    884              register sint32 y_temp;
    885          
    886              x_temp = x;
    887              y_temp = y;
    888          
    889              if( (MATHCALC__ABS(x) < 1024) &&
    890                  (MATHCALC__ABS(y) < 1024) )
    891              {
    892                  x_temp = x<<5;
    893                  y_temp = y<<5;
    894              }
    895          
    896              if(x_temp < 0)
    897              {
    898                  theta = 32768L;
    899                  x_temp = -x_temp;
    900                  y_temp = -y_temp;
    901              }
    902              else
    903              {
    904                  theta = 0;
    905              }
    906          
    907              for(i = 0; i < ATAN2_ITERATION_NR; i++)
    908              {
    909                  last_x = x_temp;
    910          
    911                  if(y_temp<0)
    912                  {
    913                      x_temp -= y_temp >> i;
    914                      y_temp += last_x >> i;
    915                      theta -= (sint32)ATAN2_TABLE[i];
    916                  }
    917                  else
    918                  {
    919                      x_temp += y_temp >> i;
    920                      y_temp -= last_x >> i;
    921                      theta += (sint32)ATAN2_TABLE[i];
    922                  }
    923              }
    924          
    925              // The if's below are used to solve some specific non CORDIC convergence,
    926              // they were found through computer numerical analysis and they are solved
    927              // one by one manually in order to reduce the final calculated error.
    928              if(!x)
    929              {
    930                  if(y == 1)  theta = 16384L;
    931                  if(y == 0)  theta = 0;
    932              }
    933          #if(ATAN2_ITERATION_NR <= 7)
    934              else if(x == 1)
    935              {
    936                  if(y == 9)
    937                  {
    938                      theta = 15230L;
    939                  }
    940              }
    941              else if(x == -1)
    942              {
    943                  if(y == -9)
    944                  {
    945                      theta = -17538L;
    946                  }
    947              }
    948              else if(x == 9)
    949              {
    950                  if(y == -1)
    951                  {
    952                      theta = -1154L;
    953                  }
    954              }
    955              else if(x == -9)
    956              {
    957                  if(y == 1)
    958                  {
    959                      theta = 31614L;
    960                  }
    961              }
    962          #endif
    963          
    964             return(theta);
    965          
    966          #elif(ATAN2_USE_FOR_LOOP == 0)  // Better for program speed.
    967              register sint32 theta;
    968              register sint32 last_x;
    969              register sint32 x_temp;
    970              register sint32 y_temp;
    971          
    972              x_temp = x;
   \   00000002   0x4602             MOV      R2,R0
    973              y_temp = y;
   \   00000004   0x460B             MOV      R3,R1
    974          
    975              // This is the magnifying window. The values of 1024 and the 5 left shifts were found by computer
    976              // simulation analysis.
    977              if( (MATHCALC__ABS(x) < 1024) &&
    978                  (MATHCALC__ABS(y) < 1024) )
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0xBF48             IT       MI 
   \   0000000A   0x4264             RSBMI    R4,R4,#+0
   \   0000000C   0xF5B4 0x6F80      CMP      R4,#+1024
   \   00000010   0xDA07             BGE.N    ??MathCalc__Arctan2_0
   \   00000012   0x000C             MOVS     R4,R1
   \   00000014   0xBF48             IT       MI 
   \   00000016   0x4264             RSBMI    R4,R4,#+0
   \   00000018   0xF5B4 0x6F80      CMP      R4,#+1024
   \   0000001C   0xBFBC             ITT      LT 
    979              {
    980                  x_temp = x<<5;
   \   0000001E   0x0142             LSLLT    R2,R0,#+5
    981                  y_temp = y<<5;
   \   00000020   0x014B             LSLLT    R3,R1,#+5
    982              }
    983          
    984              // Sets the initial angle to the cordic calculation.
    985              if(x_temp < 0)
   \                     ??MathCalc__Arctan2_0: (+1)
   \   00000022   0x2A00             CMP      R2,#+0
   \   00000024   0xBF43             ITTTE    MI 
    986              {
    987                  theta = 32768L;
   \   00000026   0xF44F 0x4400      MOVMI    R4,#+32768
    988                  x_temp = -x_temp;
   \   0000002A   0x4252             RSBMI    R2,R2,#+0
    989                  y_temp = -y_temp;
   \   0000002C   0x425B             RSBMI    R3,R3,#+0
    990              }
    991              else
    992              {
    993                  theta = 0;
   \   0000002E   0x2400             MOVPL    R4,#+0
    994              }
    995          
    996          
    997              /// 1st Iteration
    998              /////////////////////////////////////////////
    999              last_x = x_temp;
   1000              if(y_temp < 0)
   \   00000030   0x18D5             ADDS     R5,R2,R3
   \   00000032   0x2B00             CMP      R3,#+0
   \   00000034   0xD503             BPL.N    ??MathCalc__Arctan2_1
   1001              {
   1002                  x_temp -= y_temp;
   \   00000036   0x1AD6             SUBS     R6,R2,R3
   1003                  y_temp += last_x;
   1004                  theta -= (sint32)ATAN2_TABLE[0];
   \   00000038   0xF5A4 0x5200      SUB      R2,R4,#+8192
   \   0000003C   0xE003             B.N      ??MathCalc__Arctan2_2
   1005              }
   1006              else
   1007              {
   1008                  x_temp += y_temp;
   \                     ??MathCalc__Arctan2_1: (+1)
   \   0000003E   0x462E             MOV      R6,R5
   1009                  y_temp -= last_x;
   \   00000040   0x1A9D             SUBS     R5,R3,R2
   1010                  theta += (sint32)ATAN2_TABLE[0];
   \   00000042   0xF504 0x5200      ADD      R2,R4,#+8192
   1011              }
   1012          
   1013              /// 2nd Iteration
   1014              /////////////////////////////////////////////
   1015              last_x = x_temp;
   1016              if(y_temp < 0)
   \                     ??MathCalc__Arctan2_2: (+1)
   \   00000046   0x2D00             CMP      R5,#+0
   \   00000048   0xD507             BPL.N    ??MathCalc__Arctan2_3
   1017              {
   1018                  x_temp -= y_temp >> 1;
   \   0000004A   0xEBB6 0x0465      SUBS     R4,R6,R5, ASR #+1
   1019                  y_temp += last_x >> 1;
   \   0000004E   0xEB05 0x0366      ADD      R3,R5,R6, ASR #+1
   1020                  theta -= (sint32)ATAN2_TABLE[1];
   \   00000052   0x.... 0x....      LDR.W    R5,??DataTable106  ;; 0xffffed1c
   \   00000056   0x18AA             ADDS     R2,R5,R2
   \   00000058   0xE006             B.N      ??MathCalc__Arctan2_4
   1021              }
   1022              else
   1023              {
   1024                  x_temp += y_temp >> 1;
   1025                  y_temp -= last_x >> 1;
   1026                  theta += (sint32)ATAN2_TABLE[1];
   \                     ??MathCalc__Arctan2_3: (+1)
   \   0000005A   0xF502 0x5290      ADD      R2,R2,#+4608
   \   0000005E   0xEB16 0x0465      ADDS     R4,R6,R5, ASR #+1
   \   00000062   0xEBA5 0x0366      SUB      R3,R5,R6, ASR #+1
   \   00000066   0x32E4             ADDS     R2,R2,#+228
   1027              }
   1028          
   1029              /// 3rd Iteration
   1030              /////////////////////////////////////////////
   1031              last_x = x_temp;
   1032              if(y_temp < 0)
   \                     ??MathCalc__Arctan2_4: (+1)
   \   00000068   0x10A5             ASRS     R5,R4,#+2
   \   0000006A   0x2B00             CMP      R3,#+0
   \   0000006C   0xD505             BPL.N    ??MathCalc__Arctan2_5
   1033              {
   1034                  x_temp -= y_temp >> 2;
   \   0000006E   0xEBA4 0x04A3      SUB      R4,R4,R3, ASR #+2
   1035                  y_temp += last_x >> 2;
   \   00000072   0x18EB             ADDS     R3,R5,R3
   1036                  theta -= (sint32)ATAN2_TABLE[2];
   \   00000074   0xF6A2 0x12FB      SUBW     R2,R2,#+2555
   \   00000078   0xE004             B.N      ??MathCalc__Arctan2_6
   1037              }
   1038              else
   1039              {
   1040                  x_temp += y_temp >> 2;
   \                     ??MathCalc__Arctan2_5: (+1)
   \   0000007A   0xEB04 0x04A3      ADD      R4,R4,R3, ASR #+2
   1041                  y_temp -= last_x >> 2;
   \   0000007E   0x1B5B             SUBS     R3,R3,R5
   1042                  theta += (sint32)ATAN2_TABLE[2];
   \   00000080   0xF602 0x12FB      ADDW     R2,R2,#+2555
   1043              }
   1044          
   1045              /// 4th Iteration
   1046              /////////////////////////////////////////////
   1047              last_x = x_temp;
   1048              if(y_temp < 0)
   \                     ??MathCalc__Arctan2_6: (+1)
   \   00000084   0x10E5             ASRS     R5,R4,#+3
   \   00000086   0x2B00             CMP      R3,#+0
   \   00000088   0xD505             BPL.N    ??MathCalc__Arctan2_7
   1049              {
   1050                  x_temp -= y_temp >> 3;
   \   0000008A   0xEBA4 0x04E3      SUB      R4,R4,R3, ASR #+3
   1051                  y_temp += last_x >> 3;
   \   0000008E   0x18EB             ADDS     R3,R5,R3
   1052                  theta -= (sint32)ATAN2_TABLE[3];
   \   00000090   0xF2A2 0x5211      SUBW     R2,R2,#+1297
   \   00000094   0xE004             B.N      ??MathCalc__Arctan2_8
   1053              }
   1054              else
   1055              {
   1056                  x_temp += y_temp >> 3;
   \                     ??MathCalc__Arctan2_7: (+1)
   \   00000096   0xEB04 0x04E3      ADD      R4,R4,R3, ASR #+3
   1057                  y_temp -= last_x >> 3;
   \   0000009A   0x1B5B             SUBS     R3,R3,R5
   1058                  theta += (sint32)ATAN2_TABLE[3];
   \   0000009C   0xF202 0x5211      ADDW     R2,R2,#+1297
   1059              }
   1060          
   1061              /// 5th Iteration
   1062              /////////////////////////////////////////////
   1063              last_x = x_temp;
   1064              if(y_temp < 0)
   \                     ??MathCalc__Arctan2_8: (+1)
   \   000000A0   0x1125             ASRS     R5,R4,#+4
   \   000000A2   0x2B00             CMP      R3,#+0
   \   000000A4   0xD505             BPL.N    ??MathCalc__Arctan2_9
   1065              {
   1066                  x_temp -= y_temp >> 4;
   \   000000A6   0xEBA4 0x1423      SUB      R4,R4,R3, ASR #+4
   1067                  y_temp += last_x >> 4;
   \   000000AA   0x18EB             ADDS     R3,R5,R3
   1068                  theta -= (sint32)ATAN2_TABLE[4];
   \   000000AC   0xF2A2 0x228B      SUBW     R2,R2,#+651
   \   000000B0   0xE004             B.N      ??MathCalc__Arctan2_10
   1069              }
   1070              else
   1071              {
   1072                  x_temp += y_temp >> 4;
   \                     ??MathCalc__Arctan2_9: (+1)
   \   000000B2   0xEB04 0x1423      ADD      R4,R4,R3, ASR #+4
   1073                  y_temp -= last_x >> 4;
   \   000000B6   0x1B5B             SUBS     R3,R3,R5
   1074                  theta += (sint32)ATAN2_TABLE[4];
   \   000000B8   0xF202 0x228B      ADDW     R2,R2,#+651
   1075              }
   1076          
   1077          #if(ATAN2_ITERATION_NR >= 6)
   1078              /// 6th Iteration
   1079              /////////////////////////////////////////////
   1080              last_x = x_temp;
   1081              if(y_temp < 0)
   \                     ??MathCalc__Arctan2_10: (+1)
   \   000000BC   0x1165             ASRS     R5,R4,#+5
   \   000000BE   0x2B00             CMP      R3,#+0
   \   000000C0   0xD505             BPL.N    ??MathCalc__Arctan2_11
   1082              {
   1083                  x_temp -= y_temp >> 5;
   \   000000C2   0xEBA4 0x1463      SUB      R4,R4,R3, ASR #+5
   1084                  y_temp += last_x >> 5;
   \   000000C6   0x18EB             ADDS     R3,R5,R3
   1085                  theta -= (sint32)ATAN2_TABLE[5];
   \   000000C8   0xF5A2 0x72A3      SUB      R2,R2,#+326
   \   000000CC   0xE004             B.N      ??MathCalc__Arctan2_12
   1086              }
   1087              else
   1088              {
   1089                  x_temp += y_temp >> 5;
   \                     ??MathCalc__Arctan2_11: (+1)
   \   000000CE   0xEB04 0x1463      ADD      R4,R4,R3, ASR #+5
   1090                  y_temp -= last_x >> 5;
   \   000000D2   0x1B5B             SUBS     R3,R3,R5
   1091                  theta += (sint32)ATAN2_TABLE[5];
   \   000000D4   0xF502 0x72A3      ADD      R2,R2,#+326
   1092              }
   1093          #endif
   1094          
   1095          #if(ATAN2_ITERATION_NR >= 7)
   1096              /// 7th Iteration
   1097              /////////////////////////////////////////////
   1098              last_x = x_temp;
   1099              if(y_temp < 0)
   \                     ??MathCalc__Arctan2_12: (+1)
   \   000000D8   0x2B00             CMP      R3,#+0
   \   000000DA   0xBF47             ITTEE    MI 
   1100              {
   1101                  x_temp -= y_temp >> 6;
   1102                  y_temp += last_x >> 6;
   \   000000DC   0xEB03 0x13A4      ADDMI    R3,R3,R4, ASR #+6
   1103                  theta -= (sint32)ATAN2_TABLE[6];
   \   000000E0   0x3AA3             SUBMI    R2,R2,#+163
   1104              }
   1105              else
   1106              {
   1107                  x_temp += y_temp >> 6;
   1108                  y_temp -= last_x >> 6;
   \   000000E2   0xEBA3 0x13A4      SUBPL    R3,R3,R4, ASR #+6
   1109                  theta += (sint32)ATAN2_TABLE[6];
   \   000000E6   0x32A3             ADDPL    R2,R2,#+163
   1110              }
   1111          #endif
   1112          
   1113          #if(ATAN2_ITERATION_NR >= 8)
   1114              /// 8th Iteration
   1115              /////////////////////////////////////////////
   1116              last_x = x_temp;
   1117              if(y_temp < 0)
   \   000000E8   0x2B00             CMP      R3,#+0
   \   000000EA   0xBF4C             ITE      MI 
   1118              {
   1119                  x_temp -= y_temp >> 7;
   1120                  y_temp += last_x >> 7;
   1121                  theta -= (sint32)ATAN2_TABLE[7];
   \   000000EC   0x3A51             SUBMI    R2,R2,#+81
   1122              }
   1123              else
   1124              {
   1125                  x_temp += y_temp >> 7;
   1126                  y_temp -= last_x >> 7;
   1127                  theta += (sint32)ATAN2_TABLE[7];
   \   000000EE   0x3251             ADDPL    R2,R2,#+81
   1128              }
   1129          #endif
   1130          
   1131          #if(ATAN2_ITERATION_NR >= 9)
   1132              /// 9th Iteration
   1133              /////////////////////////////////////////////
   1134              last_x = x_temp;
   1135              if(y_temp < 0)
   1136              {
   1137                  x_temp -= y_temp >> 8;
   1138                  y_temp += last_x >> 8;
   1139                  theta -= (sint32)ATAN2_TABLE[8];
   1140              }
   1141              else
   1142              {
   1143                  x_temp += y_temp >> 8;
   1144                  y_temp -= last_x >> 8;
   1145                  theta += (sint32)ATAN2_TABLE[8];
   1146              }
   1147          #endif
   1148          
   1149          #if(ATAN2_ITERATION_NR >= 10)
   1150              /// 10th Iteration
   1151              /////////////////////////////////////////////
   1152              last_x = x_temp;
   1153              if(y_temp < 0)
   1154              {
   1155                  x_temp -= y_temp >> 9;
   1156                  y_temp += last_x >> 9;
   1157                  theta -= (sint32)ATAN2_TABLE[9];
   1158              }
   1159              else
   1160              {
   1161                  x_temp += y_temp >> 9;
   1162                  y_temp -= last_x >> 9;
   1163                  theta += (sint32)ATAN2_TABLE[9];
   1164              }
   1165          #endif
   1166          
   1167          #if(ATAN2_ITERATION_NR >= 11)
   1168              /// 11th Iteration
   1169              /////////////////////////////////////////////
   1170              last_x = x_temp;
   1171              if(y_temp < 0)
   1172              {
   1173                  x_temp -= y_temp >> 10;
   1174                  y_temp += last_x >> 10;
   1175                  theta -= (sint32)ATAN2_TABLE[10];
   1176              }
   1177              else
   1178              {
   1179                  x_temp += y_temp >> 10;
   1180                  y_temp -= last_x >> 10;
   1181                  theta += (sint32)ATAN2_TABLE[10];
   1182              }
   1183          #endif
   1184          
   1185          #if(ATAN2_ITERATION_NR >= 12)
   1186              /// 12th Iteration
   1187              /////////////////////////////////////////////
   1188              last_x = x_temp;
   1189              if(y_temp < 0)
   1190              {
   1191                  x_temp -= y_temp >> 11;
   1192                  y_temp += last_x >> 11;
   1193                  theta -= (sint32)ATAN2_TABLE[11];
   1194              }
   1195              else
   1196              {
   1197                  x_temp += y_temp >> 11;
   1198                  y_temp -= last_x >> 11;
   1199                  theta += (sint32)ATAN2_TABLE[11];
   1200              }
   1201          #endif
   1202          
   1203          #if(ATAN2_ITERATION_NR >= 13)
   1204              /// 13th Iteration
   1205              /////////////////////////////////////////////
   1206              last_x = x_temp;
   1207              if(y_temp < 0)
   1208              {
   1209                  x_temp -= y_temp >> 12;
   1210                  y_temp += last_x >> 12;
   1211                  theta -= (sint32)ATAN2_TABLE[12];
   1212              }
   1213              else
   1214              {
   1215                  x_temp += y_temp >> 12;
   1216                  y_temp -= last_x >> 12;
   1217                  theta += (sint32)ATAN2_TABLE[12];
   1218              }
   1219          #endif
   1220          
   1221          #if(ATAN2_ITERATION_NR >= 14)
   1222              /// 14th Iteration
   1223              /////////////////////////////////////////////
   1224              last_x = x_temp;
   1225              if(y_temp < 0)
   1226              {
   1227                  x_temp -= y_temp >> 13;
   1228                  y_temp += last_x >> 13;
   1229                  theta -= (sint32)ATAN2_TABLE[13];
   1230              }
   1231              else
   1232              {
   1233                  x_temp += y_temp >> 13;
   1234                  y_temp -= last_x >> 13;
   1235                  theta += (sint32t)ATAN2_TABLE[13];
   1236              }
   1237          #endif
   1238          
   1239              // The if's below are used to solve some CORDIC convergence discrete error,
   1240              // they were found through computer numerical analysis and they are solved
   1241              // one by one manually in order to reduce the final calculated error.
   1242              if(!x)
   \   000000F0   0xB930             CBNZ.N   R0,??MathCalc__Arctan2_13
   1243              {
   1244                  if(y == 1)  theta = 16384L;
   \   000000F2   0x2901             CMP      R1,#+1
   \   000000F4   0xBF08             IT       EQ 
   \   000000F6   0xF44F 0x4280      MOVEQ    R2,#+16384
   \   000000FA   0xD001             BEQ.N    ??MathCalc__Arctan2_13
   1245                  if(y == 0)  theta = 0;
   \   000000FC   0xB901             CBNZ.N   R1,??MathCalc__Arctan2_13
   \   000000FE   0x2200             MOVS     R2,#+0
   1246              }
   1247          #if(ATAN2_ITERATION_NR <= 7)
   1248              else if(x == 1)
   1249              {
   1250                  if(y == 9)
   1251                  {
   1252                      theta = 15230L;
   1253                  }
   1254              }
   1255              else if(x == -1)
   1256              {
   1257                  if(y == -9)
   1258                  {
   1259                      theta = -17538L;
   1260                  }
   1261              }
   1262              else if(x == 9)
   1263              {
   1264                  if(y == -1)
   1265                  {
   1266                      theta = -1154L;
   1267                  }
   1268              }
   1269              else if(x == -9)
   1270              {
   1271                  if(y == 1)
   1272                  {
   1273                      theta = 31614L;
   1274                  }
   1275              }
   1276          #endif
   1277          
   1278             return((sint16)theta);
   \                     ??MathCalc__Arctan2_13: (+1)
   \   00000100   0xBC70             POP      {R4-R6}
   \   00000102   0xB210             SXTH     R0,R2
   \   00000104   0x4770             BX       LR               ;; return
   1279          #endif
   1280          }
   1281          
   1282          
   1283          
   1284          //---------------------------------------------------------------------------------------------------------------------
   1285          /**
   1286           *  @brief      Calculate \f$ sin(\theta) \f$ and \f$ cos(\theta) \f$.
   1287           *  @details    Only \f$ sin(\theta) \f$ is implemented.
   1288           *              \f$ cos(\theta) \f$ is calculated as \f$sin(\theta + \frac{\pi}{2})\f$
   1289           *              \f$ sin(\theta) \f$ is calculated using Taylor 7-th order polynomial
   1290           *  @param[in]  theta = input angle in Q1.15 notation
   1291           *  @param[out] sincos = structure containing sin(theta) and cos(theta) values
   1292           */

   \                                 In section .text, align 2, keep-with-next
   1293          void MathCalc__SinCos(sint32 theta,  SIN_COS_TYPE* sincos)
   1294          {
   \                     MathCalc__SinCos: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   1295                  // calculate sin(theta)
   1296                  sincos->Sin = MathCalc__Sin((sint16)theta);
   \   00000002   0xB203             SXTH     R3,R0
   \   00000004   0x461C             MOV      R4,R3
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable106_1  ;; 0xffffc000
   \   0000000A   0x4294             CMP      R4,R2
   \   0000000C   0xBF08             IT       EQ 
   \   0000000E   0x....             LDREQ.N  R3,??DataTable104_6  ;; 0xffff8000
   \   00000010   0xD01F             BEQ.N    ??MathCalc__SinCos_0
   \   00000012   0xF5B4 0x4F80      CMP      R4,#+16384
   \   00000016   0xBF08             IT       EQ 
   \   00000018   0xF647 0x73FF      MOVWEQ   R3,#+32767
   \   0000001C   0xD019             BEQ.N    ??MathCalc__SinCos_0
   \   0000001E   0x045B             LSLS     R3,R3,#+17
   \   00000020   0x141B             ASRS     R3,R3,#+16
   \   00000022   0x405C             EORS     R4,R4,R3
   \   00000024   0xBF44             ITT      MI 
   \   00000026   0x425B             RSBMI    R3,R3,#+0
   \   00000028   0xB21B             SXTHMI   R3,R3
   \   0000002A   0xFB13 0xF403      SMULBB   R4,R3,R3
   \   0000002E   0x13E4             ASRS     R4,R4,#+15
   \   00000030   0xF06F 0x0598      MVN      R5,#+152
   \   00000034   0x4365             MULS     R5,R5,R4
   \   00000036   0x13ED             ASRS     R5,R5,#+15
   \   00000038   0xF605 0x2533      ADDW     R5,R5,#+2611
   \   0000003C   0x4365             MULS     R5,R5,R4
   \   0000003E   0x....             LDR.N    R6,??DataTable104_7  ;; 0xffffad51
   \   00000040   0xEB06 0x35E5      ADD      R5,R6,R5, ASR #+15
   \   00000044   0x436C             MULS     R4,R4,R5
   \   00000046   0x13E4             ASRS     R4,R4,#+15
   \   00000048   0xF504 0x4449      ADD      R4,R4,#+51456
   \   0000004C   0x3410             ADDS     R4,R4,#+16
   \   0000004E   0x4363             MULS     R3,R3,R4
   \   00000050   0x13DB             ASRS     R3,R3,#+15
   \                     ??MathCalc__SinCos_0: (+1)
   \   00000052   0x600B             STR      R3,[R1, #+0]
   1297                  // calculate cos(theta) = sin(theta +pi/2)
   1298                  theta = PI_2 + theta;  // theta + pi/2
   1299                  sincos->Cos = MathCalc__Sin((sint16)theta);
   \   00000054   0xF500 0x4080      ADD      R0,R0,#+16384
   \   00000058   0xB200             SXTH     R0,R0
   \   0000005A   0x4603             MOV      R3,R0
   \   0000005C   0x4293             CMP      R3,R2
   \   0000005E   0xBF08             IT       EQ 
   \   00000060   0x....             LDREQ.N  R0,??DataTable104_6  ;; 0xffff8000
   \   00000062   0xD020             BEQ.N    ??MathCalc__SinCos_1
   \   00000064   0xF5B3 0x4F80      CMP      R3,#+16384
   \   00000068   0xBF08             IT       EQ 
   \   0000006A   0xF647 0x70FF      MOVWEQ   R0,#+32767
   \   0000006E   0xD01A             BEQ.N    ??MathCalc__SinCos_1
   \   00000070   0x0440             LSLS     R0,R0,#+17
   \   00000072   0x1400             ASRS     R0,R0,#+16
   \   00000074   0xEA93 0x0200      EORS     R2,R3,R0
   \   00000078   0xBF44             ITT      MI 
   \   0000007A   0x4240             RSBMI    R0,R0,#+0
   \   0000007C   0xB200             SXTHMI   R0,R0
   \   0000007E   0xFB10 0xF200      SMULBB   R2,R0,R0
   \   00000082   0x13D2             ASRS     R2,R2,#+15
   \   00000084   0xF06F 0x0398      MVN      R3,#+152
   \   00000088   0x4353             MULS     R3,R3,R2
   \   0000008A   0x13DB             ASRS     R3,R3,#+15
   \   0000008C   0xF603 0x2333      ADDW     R3,R3,#+2611
   \   00000090   0x4353             MULS     R3,R3,R2
   \   00000092   0x....             LDR.N    R4,??DataTable104_7  ;; 0xffffad51
   \   00000094   0xEB04 0x33E3      ADD      R3,R4,R3, ASR #+15
   \   00000098   0x435A             MULS     R2,R2,R3
   \   0000009A   0x13D2             ASRS     R2,R2,#+15
   \   0000009C   0xF502 0x4249      ADD      R2,R2,#+51456
   \   000000A0   0x3210             ADDS     R2,R2,#+16
   \   000000A2   0x4350             MULS     R0,R0,R2
   \   000000A4   0x13C0             ASRS     R0,R0,#+15
   \                     ??MathCalc__SinCos_1: (+1)
   \   000000A6   0x6048             STR      R0,[R1, #+4]
   1300          }
   \   000000A8   0xBC70             POP      {R4-R6}
   \   000000AA   0x4770             BX       LR               ;; return
   1301          
   1302          
   1303          
   1304          
   1305          
   1306          
   1307          
   1308          /*************** ADDED LATER  ************* BEATOA */
   1309          #if ((__ICCARM__ == 1) && (__CORE__ == __ARM7EM__))  //  ARM IAR Compiler && CortexM4
   1310          #include <intrinsics.h>
   1311          static inline uint32 AbsSat32(register sint32 val)
   1312          {
   1313                register sint32 temp = 1;
   1314                        asm volatile( "cmp %0, #0 \n"                   /* Compares Val with 0 */
   1315                                        "itt lt \n"                       /* If Val < 0, then executes next two commands */
   1316                                        "mvnlt %0, %0 \n"                 /* Val = ~f32Val */
   1317                                        "qaddlt %0, %0, %1 \n"            /* Val = Val + 1 */
   1318                                        : "+l"(val): "l"(temp));
   1319                return val;
   1320          }
   1321          
   1322          

   \                                 In section .text, align 4, keep-with-next
   1323          uint8 MathCalc__CountLeadingBitsOnSigned(sint32 in)
   1324          {
   1325              return (__CLZ(AbsSat32(in)<<1));
   \                     MathCalc__CountLeadingBitsOnSigned: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x2800             cmp R0, #0 
   \   00000004   0xBFBC             itt lt 
   \   00000006   0x43C0             mvnlt R0, R0 
   \   00000008   0xFA81 0xF080      qaddlt R0, R0, R1 
   \   0000000C   0x0040             LSLS     R0,R0,#+1
   \   0000000E   0xFAB0 0xF080      CLZ      R0,R0
   \   00000012   0x4770             BX       LR               ;; return
   1326          }
   1327          

   \                                 In section .text, align 2, keep-with-next
   1328          uint8 MathCalc__CountLeadingBitsOnUnsigned(uint32 in)
   1329          {
   1330              return (__CLZ(in));
   \                     MathCalc__CountLeadingBitsOnUnsigned: (+1)
   \   00000000   0xFAB0 0xF080      CLZ      R0,R0
   \   00000004   0x4770             BX       LR               ;; return
   1331          }
   1332          
   1333          #else
   1334          // Not on ARM Architecture
   1335          
   1336          
   1337          //---------------------------------------------------------------------------------------------------------------------
   1338          /**
   1339           *  @brief      Count leading bits of a 32 bit signed input (MSB is not considered because it is for sign).
   1340           *  @details    The implemented algorithm uses the de Bruijn sequences and SWAR algorithm.
   1341           *
   1342           *  [Here](http://supertech.csail.mit.edu/papers/debruijn.pdf) and
   1343           *  [here](http://aggregate.org/MAGIC/#Most%20Significant%201%20Bit)
   1344           *  you can find the reference documentation for the overall algorithm.
   1345           *
   1346           *  The steps of the algorithm are the following:
   1347           *
   1348           *          1- check sign: if the input is negative, it is negate (the algorithm requires positive values)
   1349           *
   1350           *          2- build a sint32 value with a single 1 in the MSB position of input value (SWAR algorithm is used)
   1351           *
   1352           *          3- index the single 1 position of step 2
   1353           *
   1354           *          4- translate the index into number of leading bits using a conversion constant array
   1355           *
   1356           *  Respect to the original documentation, the proposed implementation is slightly different because of
   1357           *  the last step of the SWAR algorithm to build a sint32 value with a single 1 in the MSB position
   1358           *  of input value and because of the adopted De Bruijn sequence. This version is taken from this
   1359           *  [link](http://stackoverflow.com/questions/23856596/counting-leading-zeros-in-a-32-bit-unsigned-integer-with-best-algorithm-in-c-pro)
   1360           *
   1361           *  @param[in]  in  = input value
   1362           *  @return     number of leading bits (excluding the MSB because it is used for sign)
   1363           */
   1364          uint8 MathCalc__CountLeadingBitsOnSigned(sint32 in)
   1365          {
   1366              uint8 out;
   1367          
   1368              // check sign
   1369              if (in<0)
   1370              {
   1371                  if (in == MAX_32BIT_NEGATIVE)
   1372                  {
   1373                      in = MAX_32BIT_POSITIVE;
   1374                  }
   1375                  else
   1376                  {
   1377                      in = -in;
   1378                  }
   1379              }
   1380          
   1381          
   1382              // isolate a 1: build a sint32 with a single 1 in the MSB position of in
   1383              // SWAR algorithm is used
   1384              in |= in>>1;
   1385              in |= in>>2;
   1386              in |= in>>4;
   1387              in |= in>>8;
   1388              in |= in>>16;   // all ones from LSB to leftmost 1 position
   1389              in += 1;        // one in the (leftmost 1 position + 1) bit --> the conversion array takes it into account
   1390          
   1391              // Use de Bruijn sequences to efficiently find the position
   1392              in = ((in*DEBRUIJN_SEQ)>>27)&31;
   1393              out = debruijn_to_std_signed[in];
   1394          
   1395              return out;
   1396          }
   1397          
   1398          
   1399          
   1400          /**
   1401           *  @brief      Count leading bits of a 32 bit signed input.
   1402           *  @details    The implemented algorithm uses the de Bruijn sequences and SWAR algorithm.
   1403           *
   1404           *  [Here](http://supertech.csail.mit.edu/papers/debruijn.pdf) and
   1405           *  [here](http://aggregate.org/MAGIC/#Most%20Significant%201%20Bit)
   1406           *  you can find the reference documentation for the overall algorithm.
   1407           *
   1408           *  The steps of the algorithm are the following:
   1409           *
   1410           *          1- check for zero: if the input is zero, the result is directly 32
   1411           *
   1412           *          2- build a sint32 value with a single 1 in the MSB position of input value (SWAR algorithm is used)
   1413           *
   1414           *          3- index the single 1 position of step 2
   1415           *
   1416           *          4- translate the index into number of leading bits using a conversion constant array
   1417           *
   1418           *  Respect to the original documentation, the proposed implementation is slightly different because of
   1419           *  the last step of the SWAR algorithm to build a sint32 value with a single 1 in the MSB position
   1420           *  of input value and because of the adopted De Bruijn sequence. This version is taken from this
   1421           *  [link](http://stackoverflow.com/questions/23856596/counting-leading-zeros-in-a-32-bit-unsigned-integer-with-best-algorithm-in-c-pro)
   1422           *
   1423           *  @param[in]  in  = input value
   1424           *  @return     number of leading bits (excluding the MSB because it is used for sign)
   1425           */
   1426          uint8 MathCalc__CountLeadingBitsOnUnsigned(uint32 in)
   1427          {
   1428              uint8 out;
   1429              // check not zero
   1430              if (in == 0)
   1431              {
   1432                  out = 32;
   1433              }
   1434              else
   1435              {
   1436                  // isolate a 1: build a sint32 with a single 1 in the MSB position of in
   1437                  // SWAR algorithm is used
   1438                  in |= in>>1;
   1439                  in |= in>>2;
   1440                  in |= in>>4;
   1441                  in |= in>>8;
   1442                  in |= in>>16;   // all ones from LSB to leftmost 1 position
   1443                  in += 1;        // one in the (leftmost 1 position + 1) bit --> the conversion array takes it into account
   1444          
   1445                  // Use de Bruijn sequences to efficiently find the position
   1446                  in = ((in*DEBRUIJN_SEQ)>>27)&31;
   1447                  out = debruijn_to_std_unsigned[in];
   1448              }
   1449          
   1450              return out;
   1451          
   1452          }
   1453          
   1454          
   1455          #endif
   1456          
   1457          
   1458          //------------------------------- Floating Point Section ----------------------------------//
   1459          /**
   1460           * It calculates the linear interpolation between two points.
   1461           * The equation is as follow: deltaY/deltaX*(value - x0) + y0.
   1462           * @param y1 is Y coordinate of the point 1
   1463           * @param x1 is X coordinate of the point 1
   1464           * @param y0 is Y coordinate of the point 0
   1465           * @param x0 is X coordinate of the point 0
   1466           * @param value is the value to be interpolated within the x1 and x0
   1467           * @return
   1468           */

   \                                 In section .text, align 4, keep-with-next
   1469          float32 MathCalc__f_Interpolate(float32 y1, float32 x1, float32 y0, float32 x0, float32 value)
   1470          
   1471          {
   1472              float32 temp;
   1473          
   1474              temp = y1 - y0;
   1475              temp = temp*(value - x0);
   1476          
   1477              if( (x1 - x0) )
   \                     MathCalc__f_Interpolate: (+1)
   \   00000000   0xEE70 0x0AE1      VSUB.F32 S1,S1,S3
   \   00000004   0xEE30 0x0A41      VSUB.F32 S0,S0,S2
   \   00000008   0xEE32 0x2A61      VSUB.F32 S4,S4,S3
   \   0000000C   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   00000010   0xEE20 0x0A02      VMUL.F32 S0,S0,S4
   \   00000014   0xEEF1 0xFA10      FMSTAT   
   \   00000018   0xD004             BEQ.N    ??MathCalc__f_Interpolate_0
   1478              {
   1479                  temp = temp/(x1 - x0); // Q31/Q15 = Q15
   1480                  temp = temp + y0;          // Q15 + Q15 = Q15
   \   0000001A   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   0000001E   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \   00000022   0x4770             BX       LR
   1481              }
   1482              else
   1483              {
   1484                  temp = 0;                                   // To prevent any division by 0.
   \                     ??MathCalc__f_Interpolate_0: (+1)
   \   00000024   0xED9F 0x....      VLDR.W   S0,??DataTable104  ;; 0x0
   1485              }
   1486          
   1487              return(temp);
   \   00000028   0x4770             BX       LR               ;; return
   1488          }
   1489          

   \                                 In section .text, align 4, keep-with-next
   1490          void MathCalc__f_SinCos(float32 motTheta, SIN_COS_TYPE *parmPtr)
   1491          {
   \                     MathCalc__f_SinCos: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   1492              parmPtr->Sin = (mc_sint32) sinf(F_PI * motTheta);
   \   00000006   0xEDDF 0x....      VLDR.W   S1,??DataTable104_1  ;; 0x40490fdb
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0xEE20 0x8A20      VMUL.F32 S16,S0,S1
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000016   0x.... 0x....      BL       __iar_FSin
   \   0000001A   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000001E   0xED84 0x0A00      VSTR     S0,[R4, #0]
   1493              parmPtr->Cos = (mc_sint32) cosf(F_PI * motTheta);
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000028   0x.... 0x....      BL       __iar_FSin
   \   0000002C   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000030   0xED84 0x0A01      VSTR     S0,[R4, #+4]
   1494          }
   \   00000034   0xECBD 0x8B02      VPOP     {D8}
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
   1495          
   1496          
   1497          

   \                                 In section .text, align 2, keep-with-next
   1498          float32 MathCalc__GetInterpolationFastF(float32 value, MATHCALC_LUT_EXT_F_TYPE *lut_ext)
   1499          {
   1500              sint32 index;
   1501              float32 tmp1;
   1502              float32 tmp2;
   1503              float32 output;
   1504              // size of lut is the real size of the lut
   1505              sint32 last_available_index  = *(lut_ext->sizeof_lut)-2;
   \                     MathCalc__GetInterpolationFastF: (+1)
   \   00000000   0x6881             LDR      R1,[R0, #+8]
   1506          
   1507              float32 step_inv = *(lut_ext->step_inv);
   \   00000002   0x6842             LDR      R2,[R0, #+4]
   1508              MATHCALC_LUT_F_TYPE *lut = lut_ext->ptr_LUT;
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xED92 0x1A00      VLDR     S2,[R2, #0]
   1509          
   1510          
   1511              // index calculation -- fast algorithm -- no division required
   1512              // step is already in absolute value
   1513              // input must be monotonically increasing -- abs is not required
   1514              index = (sint32)((value-lut[0].input)*step_inv);
   \   0000000A   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0xEE70 0x0A60      VSUB.F32 S1,S0,S1
   \   00000014   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   00000018   0xEEFD 0x0AE0      VCVT.S32.F32 S1,S1
   \   0000001C   0x1E89             SUBS     R1,R1,#+2
   \   0000001E   0xEE10 0x2A90      VMOV     R2,S1
   1515          
   1516              // check index in range
   1517              if (index > last_available_index)
   \   00000022   0x4291             CMP      R1,R2
   \   00000024   0xDA06             BGE.N    ??MathCalc__GetInterpolationFastF_0
   1518              {
   1519                  output = lut[last_available_index+1].output;
   \   00000026   0xEB00 0x00C1      ADD      R0,R0,R1, LSL #+3
   \   0000002A   0xEDD0 0x0A03      VLDR     S1,[R0, #+12]
   1520              }
   1521              else if (index < 0)
   1522              {
   1523                  output = lut[0].output;
   1524              }
   1525              else
   1526              {
   1527                  // index is in the correct range
   1528                  tmp1 = (value - lut[index].input)*step_inv;
   1529                  tmp2 = lut[index+1].output - lut[index].output;
   1530                  output = lut[index].output + (tmp1*tmp2);
   1531              }
   1532          
   1533              return(output);
   \   0000002E   0xEEB0 0x0A60      VMOV.F32 S0,S1
   \   00000032   0x4770             BX       LR
   \                     ??MathCalc__GetInterpolationFastF_0: (+1)
   \   00000034   0x2A00             CMP      R2,#+0
   \   00000036   0xBF48             IT       MI 
   \   00000038   0xEDD0 0x0A01      VLDRMI   S1,[R0, #+4]
   \   0000003C   0xD411             BMI.N    ??MathCalc__GetInterpolationFastF_1
   \   0000003E   0xEB00 0x01C2      ADD      R1,R0,R2, LSL #+3
   \   00000042   0xEB00 0x00C2      ADD      R0,R0,R2, LSL #+3
   \   00000046   0xEDD1 0x0A01      VLDR     S1,[R1, #+4]
   \   0000004A   0xEDD0 0x1A00      VLDR     S3,[R0, #0]
   \   0000004E   0xEE30 0x0A61      VSUB.F32 S0,S0,S3
   \   00000052   0xEE20 0x0A01      VMUL.F32 S0,S0,S2
   \   00000056   0xED91 0x1A03      VLDR     S2,[R1, #+12]
   \   0000005A   0xEE31 0x1A60      VSUB.F32 S2,S2,S1
   \   0000005E   0xEE40 0x0A01      VMLA.F32 S1,S0,S2
   \                     ??MathCalc__GetInterpolationFastF_1: (+1)
   \   00000062   0xEEB0 0x0A60      VMOV.F32 S0,S1
   \   00000066   0x4770             BX       LR               ;; return
   1534          }
   1535          
   1536          
   1537          
   1538          /**
   1539           *  @brief      Calculate \f$ sqrt(x) \f$
   1540           *  @details    This function calculates \f$ sqrt(x) \f$ using c-language math.h library.
   1541           *              These functions return the sqrt of x. The return value is in the range -1 to 1.
   1542           *  @param[in]    x in float
   1543           *  @return       \f$ sqrt(x) \f$ in float
   1544           */

   \                                 In section .text, align 4, keep-with-next
   1545          float32 MathCalc__SqrtF(float32 x)
   1546          {
   1547          
   1548          #if ((__ICCARM__ == 1) && (__CORE__ == __ARM7EM__))  //  ARM IAR Compiler && CortexM4
   1549          
   1550              float32 ret;
   1551          
   1552              arm_sqrt_f32(x,&ret);
   \                     MathCalc__SqrtF: (+1)
   \   00000000   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000004   0xEEF1 0xFA10      FMSTAT   
   \   00000008   0xDB02             BLT.N    ??MathCalc__SqrtF_0
   \   0000000A   0xEEB1 0x0AC0      VSQRT.F32 S0,S0
   \   0000000E   0x4770             BX       LR
   \                     ??MathCalc__SqrtF_0: (+1)
   \   00000010   0xED9F 0x....      VLDR.W   S0,??DataTable104  ;; 0x0
   1553          
   1554              return ret;
   \   00000014   0x4770             BX       LR               ;; return
   1555          
   1556          #else
   1557          
   1558              return (sqrtf(x));
   1559          
   1560          #endif
   1561          
   1562          }
   1563          
   1564          
   1565          
   1566          /**
   1567           *  @brief      This function computes the arc tangent of y/x, but the signs of both arguments are used to determine the
   1568           * quadrant of the result, and x is permitted to be zero. The return value is given in radians and is in the range -pi to
   1569           * pi, inclusive.
   1570           * If x and y are coordinates of a point in the plane, atan2 returns the signed angle between the line from the origin
   1571           * to that point and the x-axis. Thus, atan2 is useful for converting Cartesian coordinates to polar coordinates. (To
   1572           * compute the radial coordinate, use hypot; see Exponents and Logarithms.)
   1573           * If both x and y are zero, atan2 returns zero.
   1574           *
   1575           *  @param      x and y coordinates of the input vector. They are represent in float.
   1576           *  @return     angle in Q15 with PI as base.
   1577           */

   \                                 In section .text, align 2, keep-with-next
   1578          float32 MathCalc__Arctan2F(float32 x, float32 y)
   1579          {
   \                     MathCalc__Arctan2F: (+1)
   \   00000000   0xEEB0 0x1A40      VMOV.F32 S2,S0
   \   00000004   0xEEB0 0x0A60      VMOV.F32 S0,S1
   1580              return atan2f(y,x);
   \   00000008   0xEEF0 0x0A41      VMOV.F32 S1,S2
   \   0000000C   0x.... 0x....      B.W      atan2f
   1581          }
   1582          
   1583          
   1584          
   1585          /**
   1586           *  @brief      Calculate \f$ sin(\theta) \f$
   1587           *  @details    This function calculates \f$ sin(\theta) \f$ using based on CMSIS library.
   1588           *              These functions return the sine of x, where x is given in radiant. The return value is in the range -1 to 1.
   1589           *  @param[in]    x in float - angle in radiant
   1590           *  @return       \f$ sin(\pi \cdot x) \f$ in float32
   1591           */

   \                                 In section .text, align 4, keep-with-next
   1592          float32 MathCalc__SinF(float32 x)
   1593          {
   1594              float32 sinVal, fract, in;                           /* Temporary variables for input, output */
   1595              uint16 index;                                        /* Index variable */
   1596              float32 a, b;                                        /* Two nearest output values */
   1597              sint32 n;
   1598              float32 findex;
   1599          
   1600              /* input x is in radians */
   1601              /* Scale the input to [0 1] range from [0 2*PI] , divide input by 2*pi */
   1602              in = x * 0.159154943092f;
   \                     MathCalc__SinF: (+1)
   \   00000000   0xEDDF 0x....      VLDR.W   S1,??DataTable104_2  ;; 0x3e22f983
   \   00000004   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   1603          
   1604              /* Calculation of floor value of input */
   1605              n = (sint32) in;
   \   00000008   0xEEFD 0x0AC0      VCVT.S32.F32 S1,S0
   \   0000000C   0xEE10 0x0A90      VMOV     R0,S1
   1606          
   1607              /* Make negative values towards -infinity */
   1608              if(in < -EPSILON_FLOAT32)
   \   00000010   0xEDDF 0x....      VLDR.W   S1,??DataTable104_3  ;; 0xb4800000
   \   00000014   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000018   0xEEF1 0xFA10      FMSTAT   
   \   0000001C   0xBF48             IT       MI 
   1609              {
   1610                n--;
   \   0000001E   0x1E40             SUBMI    R0,R0,#+1
   1611              }
   1612          
   1613              /* Map input value to [0 1] */
   1614              in = in - (float32) n;
   1615          
   1616              /* Calculation of index of the table */
   1617              findex = (float32) FAST_MATH_TABLE_SIZE * in;
   \   00000020   0xEE00 0x0A90      VMOV     S1,R0
   \   00000024   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000028   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   0000002C   0xEDDF 0x....      VLDR.W   S1,??DataTable104_4  ;; 0x44000000
   \   00000030   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   1618              if (findex >= 512.0f) {
   \   00000034   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000038   0xEEF1 0xFA10      FMSTAT   
   \   0000003C   0xBFA4             ITT      GE 
   1619                findex -= 512.0f;
   \   0000003E   0xEDDF 0x....      VLDRGE.W S1,??DataTable104_5  ;; 0xc4000000
   \   00000042   0xEE30 0x0A20      VADDGE.F32 S0,S0,S1
   1620              }
   1621          
   1622              index = ((uint16)findex) & 0x1ff;
   \   00000046   0xEEFD 0x0AC0      VCVT.S32.F32 S1,S0
   \   0000004A   0xEE10 0x0A90      VMOV     R0,S1
   \   0000004E   0x05C0             LSLS     R0,R0,#+23
   \   00000050   0x0DC0             LSRS     R0,R0,#+23
   1623          
   1624              /* fractional value calculation */
   1625              fract = findex - (float32) index;
   \   00000052   0x4601             MOV      R1,R0
   \   00000054   0xEE00 0x1A90      VMOV     S1,R1
   \   00000058   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   1626          
   1627              /* Read two nearest values of input value from the sin table */
   1628              a = sinTable_wp_f32[index];
   1629              b = sinTable_wp_f32[index+1];
   1630          
   1631              /* Linear interpolation process */
   1632              sinVal = (1.0f-fract)*a + fract*b;
   1633          
   1634              /* Return the output value */
   1635              return (sinVal);
   \   0000005C   0x.... 0x....      ADR.W    R1,sinTable_wp_f32
   \   00000060   0xEE70 0x0A60      VSUB.F32 S1,S0,S1
   \   00000064   0xEB01 0x0280      ADD      R2,R1,R0, LSL #+2
   \   00000068   0xEEB7 0x0A00      VMOV.F32 S0,#1.0
   \   0000006C   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   00000070   0xED92 0x1A00      VLDR     S2,[R2, #0]
   \   00000074   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000078   0xEE20 0x0A01      VMUL.F32 S0,S0,S2
   \   0000007C   0xED90 0x1A01      VLDR     S2,[R0, #+4]
   \   00000080   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   \   00000084   0x4770             BX       LR               ;; return
   1636          }
   1637          
   1638          
   1639          
   1640          /**
   1641           *  @brief      Calculate \f$ cos(\theta) \f$
   1642           *  @details    This function calculates \f$ cos(\theta) \f$ using c-language based on CMSIS library.
   1643           *              These functions return the cosine of x, where x is given in radiant. The return value is in the range -1 to 1.
   1644           *  @param[in]    x in float - angle in radiant
   1645           *  @return       \f$ sin(\pi \cdot x) \f$ in float
   1646           */

   \                                 In section .text, align 4, keep-with-next
   1647          float32 MathCalc__CosF(float32 x)
   1648          {
   1649              float32 cosVal, fract, in;                   /* Temporary variables for input, output */
   1650              uint16 index;                                /* Index variable */
   1651              float32 a, b;                                /* Two nearest output values */
   1652              sint32 n;
   1653              float32 findex;
   1654          
   1655              /* input x is in radians */
   1656              /* Scale the input to [0 1] range from [0 2*PI] , divide input by 2*pi, add 0.25 (pi/2) to read sine table */
   1657              in = x * 0.159154943092f + 0.25f;
   \                     MathCalc__CosF: (+1)
   \   00000000   0xED9F 0x....      VLDR.W   S2,??DataTable104_2  ;; 0x3e22f983
   \   00000004   0xEEF5 0x0A00      VMOV.F32 S1,#0.25
   \   00000008   0xEE40 0x0A01      VMLA.F32 S1,S0,S2
   1658          
   1659              /* Calculation of floor value of input */
   1660              n = (sint32) in;
   \   0000000C   0xEEBD 0x0AE0      VCVT.S32.F32 S0,S1
   \   00000010   0xEE10 0x0A10      VMOV     R0,S0
   1661          
   1662              /* Make negative values towards -infinity */
   1663              if(in < -EPSILON_FLOAT32)
   \   00000014   0xED9F 0x....      VLDR.W   S0,??DataTable104_3  ;; 0xb4800000
   \   00000018   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   0000001C   0xEEF1 0xFA10      FMSTAT   
   \   00000020   0xBF48             IT       MI 
   1664              {
   1665                n--;
   \   00000022   0x1E40             SUBMI    R0,R0,#+1
   1666              }
   1667          
   1668              /* Map input value to [0 1] */
   1669              in = in - (float32) n;
   1670          
   1671              /* Calculation of index of the table */
   1672              findex = (float32) FAST_MATH_TABLE_SIZE * in;
   \   00000024   0xEE00 0x0A10      VMOV     S0,R0
   \   00000028   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000002C   0xEE30 0x0AC0      VSUB.F32 S0,S1,S0
   \   00000030   0xEDDF 0x....      VLDR.W   S1,??DataTable104_4  ;; 0x44000000
   \   00000034   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   1673              index = ((uint16)findex) & 0x1ff;
   \   00000038   0xEEFD 0x0AC0      VCVT.S32.F32 S1,S0
   \   0000003C   0xEE10 0x0A90      VMOV     R0,S1
   \   00000040   0x05C0             LSLS     R0,R0,#+23
   \   00000042   0x0DC0             LSRS     R0,R0,#+23
   1674          
   1675              /* fractional value calculation */
   1676              fract = findex - (float32) index;
   \   00000044   0x4601             MOV      R1,R0
   \   00000046   0xEE00 0x1A90      VMOV     S1,R1
   \   0000004A   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   1677          
   1678              /* Read two nearest values of input value from the cos table */
   1679              a = sinTable_wp_f32[index];
   1680              b = sinTable_wp_f32[index+1];
   1681          
   1682              /* Linear interpolation process */
   1683              cosVal = (1.0f-fract)*a + fract*b;
   1684          
   1685              /* Return the output value */
   1686              return (cosVal);
   \   0000004E   0x.... 0x....      ADR.W    R1,sinTable_wp_f32
   \   00000052   0xEE70 0x0A60      VSUB.F32 S1,S0,S1
   \   00000056   0xEB01 0x0280      ADD      R2,R1,R0, LSL #+2
   \   0000005A   0xEEB7 0x0A00      VMOV.F32 S0,#1.0
   \   0000005E   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   00000062   0xED92 0x1A00      VLDR     S2,[R2, #0]
   \   00000066   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   0000006A   0xEE20 0x0A01      VMUL.F32 S0,S0,S2
   \   0000006E   0xED90 0x1A01      VLDR     S2,[R0, #+4]
   \   00000072   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   \   00000076   0x4770             BX       LR               ;; return
   1687          }
   1688          
   1689          
   1690          
   1691          /**
   1692           *  @brief      Calculate \f$ sin(\theta) \f$ and \f$ cos(\theta) \f$.
   1693           *  @details    Only \f$ sin(\theta) \f$ is implemented.
   1694           *              \f$ cos(\theta) \f$ is c-language based on CMSIS library.
   1695           *              \f$ sin(\theta) \f$ is c-language based on CMSIS library.
   1696           *  @param[in]  theta = input angle in radiant
   1697           *  @param[out] sincos = structure containing sin(theta) and cos(theta) values
   1698           */

   \                                 In section .text, align 4, keep-with-next
   1699          void MathCalc__SinCosF(float32 theta,  SIN_COS_F_TYPE* sincos)
   1700          {
   1701              float32 fract, in;                             /* Temporary variables for input, output */
   1702              uint16 indexS, indexC;                         /* Index variable */
   1703              float32 f1, f2, d1, d2;                        /* Two nearest output values */
   1704              sint32 n;
   1705              float32 findex;
   1706          
   1707              /* input x is in degrees */
   1708              /* Scale the input, divide input by 2*pi, for cosine add 0.25 (pi/2) to read sine table */
   1709              in = theta * 0.159154943092f;
   \                     MathCalc__SinCosF: (+1)
   \   00000000   0xEDDF 0x....      VLDR.W   S1,??DataTable104_2  ;; 0x3e22f983
   \   00000004   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   1710          
   1711          
   1712              /* Calculation of floor value of input */
   1713              n = (sint32) in;
   \   00000008   0xEEFD 0x0AC0      VCVT.S32.F32 S1,S0
   \   0000000C   0xEE10 0x1A90      VMOV     R1,S1
   1714          
   1715              /* Make negative values towards -infinity */
   1716              if(in < -EPSILON_FLOAT32)
   \   00000010   0xEDDF 0x....      VLDR.W   S1,??DataTable104_3  ;; 0xb4800000
   \   00000014   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000018   0xEEF1 0xFA10      FMSTAT   
   \   0000001C   0xBF48             IT       MI 
   1717              {
   1718                n--;
   \   0000001E   0x1E49             SUBMI    R1,R1,#+1
   1719              }
   1720              /* Map input value to [0 1] */
   1721              in = in - (float32) n;
   1722          
   1723              /* Calculation of index of the table */
   1724              findex = (float32) FAST_MATH_TABLE_SIZE * in;
   \   00000020   0xEE00 0x1A90      VMOV     S1,R1
   \   00000024   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000028   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   0000002C   0xEDDF 0x....      VLDR.W   S1,??DataTable104_4  ;; 0x44000000
   \   00000030   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   1725              indexS = ((uint16)findex) & 0x1ff;
   \   00000034   0xEEFD 0x0AC0      VCVT.S32.F32 S1,S0
   \   00000038   0xEE10 0x1A90      VMOV     R1,S1
   \   0000003C   0x05C9             LSLS     R1,R1,#+23
   \   0000003E   0x0DC9             LSRS     R1,R1,#+23
   1726              indexC = (indexS + (FAST_MATH_TABLE_SIZE / 4)) & 0x1ff;
   1727          
   1728              /* fractional value calculation */
   1729              fract = findex - (float32) indexS;
   \   00000040   0x460B             MOV      R3,R1
   \   00000042   0xEE00 0x3A90      VMOV     S1,R3
   1730          
   1731              /* Read two nearest values of input value from the cos & sin tables */
   1732              f1 = sinTable_wp_f32[indexC];
   1733              f2 = sinTable_wp_f32[indexC+1];
   1734              d1 = sinTable_wp_f32[indexS];
   \   00000046   0x.... 0x....      ADR.W    R3,sinTable_wp_f32
   \   0000004A   0xF853 0xC021      LDR      R12,[R3, R1, LSL #+2]
   \   0000004E   0xF101 0x0280      ADD      R2,R1,#+128
   1735              d2 = sinTable_wp_f32[indexS+1];
   \   00000052   0xEB03 0x0181      ADD      R1,R3,R1, LSL #+2
   \   00000056   0x05D2             LSLS     R2,R2,#+23
   \   00000058   0x0DD2             LSRS     R2,R2,#+23
   \   0000005A   0xED91 0x1A01      VLDR     S2,[R1, #+4]
   \   0000005E   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   1736          
   1737          
   1738              /* Calculation of cosine value */
   1739              sincos->Cos = (1.0f-fract)*f1 + fract*f2;
   \   00000062   0xEB03 0x0182      ADD      R1,R3,R2, LSL #+2
   \   00000066   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   0000006A   0xEEF7 0x1A00      VMOV.F32 S3,#1.0
   \   0000006E   0xEE71 0x1AC0      VSUB.F32 S3,S3,S0
   \   00000072   0xED91 0x2A00      VLDR     S4,[R1, #0]
   \   00000076   0xEDD1 0x2A01      VLDR     S5,[R1, #+4]
   \   0000007A   0xEE00 0xCA90      VMOV     S1,R12
   \   0000007E   0xEE21 0x2A82      VMUL.F32 S4,S3,S4
   \   00000082   0xEE00 0x2A22      VMLA.F32 S4,S0,S5
   1740          
   1741              /* Calculation of sine value */
   1742              sincos->Sin = (1.0f-fract)*d1 + fract*d2;
   \   00000086   0xEE61 0x0AA0      VMUL.F32 S1,S3,S1
   \   0000008A   0xED80 0x2A01      VSTR     S4,[R0, #+4]
   \   0000008E   0xEE40 0x0A01      VMLA.F32 S1,S0,S2
   \   00000092   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
   1743          }
   \   00000096   0x4770             BX       LR               ;; return
   1744          
   1745          
   1746          
   1747          /**
   1748           *  @brief      Calculates the sine and cosine based on alpha, beta and modulus components.
   1749           *
   1750           *  @param      sin, beta and modulus
   1751           *  @return     sine and cosine
   1752           */

   \                                 In section .text, align 4, keep-with-next
   1753          void MathCalc__GetSinCosF(MATHCALC_MOD_SIN_COS_F_TYPE *data)
   1754          {
   1755              // ************ Sin and Cos calculations **********************
   1756              if(data->Beta > 0.0f)
   \                     MathCalc__GetSinCosF: (+1)
   \   00000000   0xED90 0x0A01      VLDR     S0,[R0, #+4]
   \   00000004   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000008   0xEEF1 0xFA10      FMSTAT   
   \   0000000C   0xDD14             BLE.N    ??MathCalc__GetSinCosF_0
   1757              {
   1758                  data->Sin = 1.0f;
   1759                  if(data->Beta < data->Mod)
   \   0000000E   0xED90 0x1A02      VLDR     S2,[R0, #+8]
   \   00000012   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   00000016   0xEEF7 0x0A00      VMOV.F32 S1,#1.0
   \   0000001A   0xEEF1 0xFA10      FMSTAT   
   \   0000001E   0xD52A             BPL.N    ??MathCalc__GetSinCosF_1
   1760                  {
   1761                      if(data->Mod == 0.0f)
   \   00000020   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   00000024   0xEEF1 0xFA10      FMSTAT   
   \   00000028   0xD11E             BNE.N    ??MathCalc__GetSinCosF_2
   1762                      {
   1763                          data->Mod = 1.0f;
   \   0000002A   0xEDC0 0x0A02      VSTR     S1,[R0, #+8]
   1764                      }
   1765                      data->Sin = data->Beta / (data->Mod);
   1766                  }
   1767              }
   1768              else if(data->Beta < 0.0f)
   1769              {
   1770                  data->Sin = -1.0f;
   1771                  if((-data->Beta) < data->Mod)
   1772                  {
   1773                      if(data->Mod == 0.0f)
   1774                      {
   1775                          data->Mod = 1.0f;
   1776                      }
   1777                      data->Sin = data->Beta / (data->Mod);
   \   0000002E   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   00000032   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \   00000036   0xE01E             B.N      ??MathCalc__GetSinCosF_1
   \                     ??MathCalc__GetSinCosF_0: (+1)
   \   00000038   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000003C   0xEEF1 0xFA10      FMSTAT   
   \   00000040   0xD517             BPL.N    ??MathCalc__GetSinCosF_3
   \   00000042   0xED90 0x1A02      VLDR     S2,[R0, #+8]
   \   00000046   0xEEF1 0x1A40      VNEG.F32 S3,S0
   \   0000004A   0xEEF4 0x1A41      VCMP.F32 S3,S2
   \   0000004E   0xEEFF 0x0A00      VMOV.F32 S1,#-1.0
   \   00000052   0xEEF1 0xFA10      FMSTAT   
   \   00000056   0xD50E             BPL.N    ??MathCalc__GetSinCosF_1
   \   00000058   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   0000005C   0xEEF1 0xFA10      FMSTAT   
   \   00000060   0xBF04             ITT      EQ 
   \   00000062   0xF04F 0x517E      MOVEQ    R1,#+1065353216
   \   00000066   0x6081             STREQ    R1,[R0, #+8]
   \                     ??MathCalc__GetSinCosF_2: (+1)
   \   00000068   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   0000006C   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \   00000070   0xE001             B.N      ??MathCalc__GetSinCosF_1
   1778                  }
   1779              }
   1780              else
   1781              {
   1782                  data->Sin = 0.0f;
   \                     ??MathCalc__GetSinCosF_3: (+1)
   \   00000072   0xEDDF 0x....      VLDR.W   S1,??DataTable107  ;; 0x0
   \                     ??MathCalc__GetSinCosF_1: (+1)
   \   00000076   0xEDC0 0x0A03      VSTR     S1,[R0, #+12]
   1783              }
   1784          
   1785              if(data->Alpha > 0.0f)
   \   0000007A   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   0000007E   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000082   0xEEF1 0xFA10      FMSTAT   
   \   00000086   0xDD16             BLE.N    ??MathCalc__GetSinCosF_4
   1786              {
   1787                  data->Cos = 1.0f;
   1788                  if(data->Alpha < data->Mod)
   \   00000088   0xED90 0x1A02      VLDR     S2,[R0, #+8]
   \   0000008C   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   00000090   0xEEF7 0x0A00      VMOV.F32 S1,#1.0
   \   00000094   0xEEF1 0xFA10      FMSTAT   
   \   00000098   0xD52E             BPL.N    ??MathCalc__GetSinCosF_5
   1789                  {
   1790                      if(data->Mod == 0.0f)
   \   0000009A   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   0000009E   0xEEF1 0xFA10      FMSTAT   
   \   000000A2   0xD120             BNE.N    ??MathCalc__GetSinCosF_6
   1791                      {
   1792                          data->Mod = 1.0f;
   \   000000A4   0xEDC0 0x0A02      VSTR     S1,[R0, #+8]
   1793                      }
   1794                      data->Cos = data->Alpha / (data->Mod);
   1795                  }
   1796              }
   1797              else if(data->Alpha < 0.0f)
   1798              {
   1799                  data->Cos = -1.0f;
   1800                  if((-data->Alpha) < data->Mod)
   1801                  {
   1802                      if(data->Mod == 0.0f)
   1803                      {
   1804                          data->Mod = 1.0f;
   1805                      }
   1806                      data->Cos = data->Alpha / (data->Mod);
   \   000000A8   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   000000AC   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \   000000B0   0xEDC0 0x0A04      VSTR     S1,[R0, #+16]
   1807                  }
   1808              }
   1809              else
   1810              {
   1811                  data->Cos = 0.0f;
   1812              }
   1813          }
   \   000000B4   0x4770             BX       LR
   \                     ??MathCalc__GetSinCosF_4: (+1)
   \   000000B6   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000000BA   0xEEF1 0xFA10      FMSTAT   
   \   000000BE   0xD519             BPL.N    ??MathCalc__GetSinCosF_7
   \   000000C0   0xED90 0x1A02      VLDR     S2,[R0, #+8]
   \   000000C4   0xEEF1 0x1A40      VNEG.F32 S3,S0
   \   000000C8   0xEEF4 0x1A41      VCMP.F32 S3,S2
   \   000000CC   0xEEFF 0x0A00      VMOV.F32 S1,#-1.0
   \   000000D0   0xEEF1 0xFA10      FMSTAT   
   \   000000D4   0xD510             BPL.N    ??MathCalc__GetSinCosF_5
   \   000000D6   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   000000DA   0xEEF1 0xFA10      FMSTAT   
   \   000000DE   0xBF04             ITT      EQ 
   \   000000E0   0xF04F 0x517E      MOVEQ    R1,#+1065353216
   \   000000E4   0x6081             STREQ    R1,[R0, #+8]
   \                     ??MathCalc__GetSinCosF_6: (+1)
   \   000000E6   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   000000EA   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \   000000EE   0xEDC0 0x0A04      VSTR     S1,[R0, #+16]
   \   000000F2   0x4770             BX       LR
   \                     ??MathCalc__GetSinCosF_7: (+1)
   \   000000F4   0xEDDF 0x....      VLDR.W   S1,??DataTable107  ;; 0x0
   \                     ??MathCalc__GetSinCosF_5: (+1)
   \   000000F8   0xEDC0 0x0A04      VSTR     S1,[R0, #+16]
   \   000000FC   0x4770             BX       LR               ;; return
   1814          
   1815          //=====================================================================================================================
   1816          //-------------------------------------- Private Functions ------------------------------------------------------------
   1817          //=====================================================================================================================
   1818          
C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\Mcl\MicroBlocks\Pi\Pi.c
      1          /**
      2           *  @file
      3           *  @brief       PI regulator
      4           *  @details     PI regulator with 2 different anti-windup strategies:
      5           *               back-calculation and clamping
      6           *  @author      alessio.beato/luigi.fagnano (only temporary, since it is not integrated in MKS)
      7           *  $Header: $
      8           *
      9           *  @copyright  Copyright 2015-$Date$. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     10          */
     11          
     12          //-------------------------------------- Include Files ----------------------------------------------------------------
     13          #include "Pi.h"
     14          #include "McMathCalc_macros.h"
     15          
     16          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     17          
     18          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     19          
     20          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
     21          
     22          
     23          //=====================================================================================================================
     24          //-------------------------------------- Public Functions -------------------------------------------------------------
     25          //=====================================================================================================================
     26          
     27          //---------------------------------------------------------------------------------------------------------------------
     28          /**
     29           *  @brief      It Initializes the module PI and its variables
     30           *
     31           */

   \                                 In section .text, align 2, keep-with-next
     32          void Pi__Initialize(void)
     33          {
     34                  /* TO DO: initialization of parameters from setting file */
     35          }
   \                     Pi__Initialize: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     36          
     37          //---------------------------------------------------------------------------------------------------------------------
     38          
     39          
     40          //---------------------------------------------------------------------------------------------------------------------
     41          /**
     42           *  @brief      PI Regulator with back-calculation anti-windup strategy
     43           *  @details    PI controller algorithm.
     44           *              Definitions:
     45           *
     46           *              <b>e(t)</b> - input error in continuous time domain.
     47           *
     48           *              <b>u(t)</b> - controller output in continuous time domain.
     49           *
     50           *              <b>e(k)</b> - input error at step k - discrete time domain.
     51           *
     52           *              <b>u(k)</b> - controller output at step k - discrete time domain.
     53           *
     54           *              <b>e_max</b> - max range of e(k).
     55           *
     56           *              <b>u_max</b> - max range of u(k).
     57           *
     58           *            PI controller algorithm in <b>continuous time domain</b>:
     59           *
     60           *          \f[ u(t) = K\left(e(t) +\frac{1}{T_i}\int_0^t \! e(t) \, \mathrm{d}t. \right)\f]
     61           *           where:
     62           *            K :  controller gain
     63           *
     64           *            Ti: integral time constant
     65           *
     66           *           PI controller algorithm in <b>fractional arithmetic</b>:
     67           *
     68           *           \f[
     69           *             \begin{aligned}
     70           *                & u_f(k) = K_{p_{sc}} \cdot e_f(k) + u_f(k - 1) + K_{i_{sc}} \cdot e_f(k) \\
     71           *                & e_f(k) = \frac{e(k)}{e_{max}}\\
     72           *                & u_f(k) = \frac{u(k)}{u_{max}}\\
     73           *                & K_{p_{sc}} =  K \frac{e(k)}{e_{max}}\\
     74           *                & K_{i_{sc}} =  K \frac{T}{T_i}\frac{e(k)}{e_{max}}\\
     75           *             \end{aligned}
     76           *           \f]
     77           *           where:
     78           *           <b>T</b> : sampling time
     79           *
     80           *  The <b>anti-windup</b> technique is implemented as follows:
     81           *  when the output saturates, the integral
     82           *  term in the controller is recomputed so that its new value gives an
     83           *  output at the saturation limit
     84           *
     85           *  @param[in]      pi_params       = PI parameters: gains and limits
     86           *  @param[in]      err             = PI input error in Q17.15 notation
     87           *  @param[in, out] integ_term_k_1  = PI state variable in Q2.30 notation
     88           *  @return         PI output after saturation in Q17.15 notation
     89           */

   \                                 In section .text, align 2, keep-with-next
     90          mc_sint32 Pi__PiRegBackCalc(mc_sint32 err, mc_sint32* integ_term_k_1, CONTROLLER_PI_PARAMS_TYPE* pi_params)
     91          {
   \                     Pi__PiRegBackCalc: (+1)
   \   00000000   0xE92D 0x4EF2      PUSH     {R1,R4-R7,R9-R11,LR}
   \   00000004   0x4614             MOV      R4,R2
     92          
     93              mc_sint64 prop_term;
     94              mc_sint64 integ_term;
     95              mc_sint64 tmp;
     96          
     97              // prop_term calculation in Q34.30 notation
     98              prop_term = MC_MULT_LL_LL(pi_params->KpMant, err, (IQ15 + pi_params->KpExp), IQ15, IQ30);
   \   00000006   0x4607             MOV      R7,R0
   \   00000008   0x6822             LDR      R2,[R4, #+0]
     99          
    100              // prop_term Saturation
    101              if (prop_term > (mc_sint64)pi_params->UpperLimit)
   \   0000000A   0x68A5             LDR      R5,[R4, #+8]
   \   0000000C   0xEA4F 0x7BE0      ASR      R11,R0,#+31
   \   00000010   0x17D3             ASRS     R3,R2,#+31
   \   00000012   0xFBA7 0x0102      UMULL    R0,R1,R7,R2
   \   00000016   0xFB07 0x1103      MLA      R1,R7,R3,R1
   \   0000001A   0xFB0B 0x1102      MLA      R1,R11,R2,R1
   \   0000001E   0xF994 0x2010      LDRSB    R2,[R4, #+16]
   \   00000022   0x.... 0x....      BL       __aeabi_lasr
   \   00000026   0x468A             MOV      R10,R1
   \   00000028   0xEA4F 0x79E5      ASR      R9,R5,#+31
   \   0000002C   0x4606             MOV      R6,R0
   \   0000002E   0x45D1             CMP      R9,R10
   \   00000030   0xDC05             BGT.N    ??Pi__PiRegBackCalc_0
   \   00000032   0xDB01             BLT.N    ??Pi__PiRegBackCalc_1
   \   00000034   0x42B5             CMP      R5,R6
   \   00000036   0xD202             BCS.N    ??Pi__PiRegBackCalc_0
    102              {
    103                  prop_term = (mc_sint64)pi_params->UpperLimit;
   \                     ??Pi__PiRegBackCalc_1: (+1)
   \   00000038   0x462E             MOV      R6,R5
   \   0000003A   0x46CA             MOV      R10,R9
   \   0000003C   0xE009             B.N      ??Pi__PiRegBackCalc_2
    104              }
    105              else if (prop_term < (mc_sint64)pi_params->LowerLimit)
   \                     ??Pi__PiRegBackCalc_0: (+1)
   \   0000003E   0x68E0             LDR      R0,[R4, #+12]
   \   00000040   0xEBBA 0x7FE0      CMP      R10,R0, ASR #+31
   \   00000044   0xDC05             BGT.N    ??Pi__PiRegBackCalc_2
   \   00000046   0xDB01             BLT.N    ??Pi__PiRegBackCalc_3
   \   00000048   0x4286             CMP      R6,R0
   \   0000004A   0xD202             BCS.N    ??Pi__PiRegBackCalc_2
    106              {
    107                  prop_term = (mc_sint64)pi_params->LowerLimit;
   \                     ??Pi__PiRegBackCalc_3: (+1)
   \   0000004C   0x4606             MOV      R6,R0
   \   0000004E   0xEA4F 0x7AE0      ASR      R10,R0,#+31
    108              }
    109          
    110              // integ_term calculation in Q34.30 notation
    111              integ_term = MC_MULT_LL_LL(pi_params->KiMant, err, (IQ15 + pi_params->KiExp), IQ15, IQ30);
    112          
    113              integ_term = integ_term + (mc_sint64)*integ_term_k_1;
   \                     ??Pi__PiRegBackCalc_2: (+1)
   \   00000052   0x6862             LDR      R2,[R4, #+4]
   \   00000054   0x17D3             ASRS     R3,R2,#+31
   \   00000056   0xFBA7 0x0102      UMULL    R0,R1,R7,R2
   \   0000005A   0xFB07 0x1103      MLA      R1,R7,R3,R1
   \   0000005E   0xFB0B 0x1102      MLA      R1,R11,R2,R1
   \   00000062   0xF994 0x2011      LDRSB    R2,[R4, #+17]
   \   00000066   0x.... 0x....      BL       __aeabi_lasr
   \   0000006A   0x9A00             LDR      R2,[SP, #+0]
   \   0000006C   0x6812             LDR      R2,[R2, #+0]
   \   0000006E   0x1887             ADDS     R7,R0,R2
   \   00000070   0xEB41 0x7BE2      ADC      R11,R1,R2, ASR #+31
    114          
    115              // output Saturation & state variable back-calculation anti-windup
    116              tmp = prop_term + integ_term;
   \   00000074   0x19F2             ADDS     R2,R6,R7
   \   00000076   0xEB4A 0x030B      ADC      R3,R10,R11
    117          
    118              if (tmp > (mc_sint64)pi_params->UpperLimit)
   \   0000007A   0x4599             CMP      R9,R3
   \   0000007C   0xDC06             BGT.N    ??Pi__PiRegBackCalc_4
   \   0000007E   0xDB01             BLT.N    ??Pi__PiRegBackCalc_5
   \   00000080   0x4295             CMP      R5,R2
   \   00000082   0xD203             BCS.N    ??Pi__PiRegBackCalc_4
    119              {
    120                  tmp = (mc_sint64)pi_params->UpperLimit;
   \                     ??Pi__PiRegBackCalc_5: (+1)
   \   00000084   0x462A             MOV      R2,R5
   \   00000086   0x464B             MOV      R3,R9
    121                  *integ_term_k_1 = pi_params->UpperLimit - (mc_sint32)prop_term;
   \   00000088   0x1BAF             SUBS     R7,R5,R6
   \   0000008A   0xE009             B.N      ??Pi__PiRegBackCalc_6
    122              }
    123              else if (tmp < pi_params->LowerLimit)
   \                     ??Pi__PiRegBackCalc_4: (+1)
   \   0000008C   0x68E0             LDR      R0,[R4, #+12]
   \   0000008E   0xEBB3 0x7FE0      CMP      R3,R0, ASR #+31
   \   00000092   0xDC05             BGT.N    ??Pi__PiRegBackCalc_6
   \   00000094   0xDB01             BLT.N    ??Pi__PiRegBackCalc_7
   \   00000096   0x4282             CMP      R2,R0
   \   00000098   0xD202             BCS.N    ??Pi__PiRegBackCalc_6
    124              {
    125                  tmp = (mc_sint64)pi_params->LowerLimit;
   \                     ??Pi__PiRegBackCalc_7: (+1)
   \   0000009A   0x4602             MOV      R2,R0
   \   0000009C   0x17C3             ASRS     R3,R0,#+31
    126                  *integ_term_k_1 = pi_params->LowerLimit - (mc_sint32)prop_term;
   \   0000009E   0x1B87             SUBS     R7,R0,R6
    127              }
    128              else
    129              {
    130                  *integ_term_k_1 = (mc_sint64)integ_term;
   \                     ??Pi__PiRegBackCalc_6: (+1)
   \   000000A0   0x9800             LDR      R0,[SP, #+0]
   \   000000A2   0x6007             STR      R7,[R0, #+0]
    131              }
    132          
    133              // output in Q17.15 notation
    134              return ((mc_sint32)(MC_SCALE(tmp,IQ30,IQ15)));
   \   000000A4   0x0BD2             LSRS     R2,R2,#+15
   \   000000A6   0xEA42 0x4043      ORR      R0,R2,R3, LSL #+17
   \   000000AA   0xB001             ADD      SP,SP,#+4
   \   000000AC   0xE8BD 0x8EF0      POP      {R4-R7,R9-R11,PC}  ;; return
    135          }
    136          
    137          
    138          
    139          //---------------------------------------------------------------------------------------------------------------------
    140          /**
    141           *  @brief      PI Regulator with clamping anti-windup
    142           *  @details    PI controller algorithm.
    143           *              Definitions:
    144           *
    145           *              <b>e(t)</b> - input error in continuous time domain.
    146           *
    147           *              <b>u(t)</b> - controller output in continuous time domain.
    148           *
    149           *              <b>e(k)</b> - input error at step k - discrete time domain.
    150           *
    151           *              <b>u(k)</b> - controller output at step k - discrete time domain.
    152           *
    153           *              <b>e_max</b> - max range of e(k).
    154           *
    155           *              <b>u_max</b> - max range of u(k).
    156           *
    157           *            PI controller algorithm in <b>continuous time domain</b>:
    158           *
    159           *          \f[ u(t) = K\left(e(t) +\frac{1}{T_i}\int_0^t \! e(t) \, \mathrm{d}t. \right)\f]
    160           *           where:
    161           *            K :  controller gain
    162           *
    163           *            Ti: integral time constant
    164           *
    165           *           PI controller algorithm in <b>fractional arithmetic</b>:
    166           *
    167           *           \f[
    168           *             \begin{aligned}
    169           *                & u_f(k) = K_{p_{sc}} \cdot e_f(k) + u_f(k - 1) + K_{i_{sc}} \cdot e_f(k) \\
    170           *                & e_f(k) = \frac{e(k)}{e_{max}}\\
    171           *                & u_f(k) = \frac{u(k)}{u_{max}}\\
    172           *                & K_{p_{sc}} =  K \frac{e(k)}{e_{max}}\\
    173           *                & K_{i_{sc}} =  K \frac{T}{T_i}\frac{e(k)}{e_{max}}\\
    174           *             \end{aligned}
    175           *           \f]
    176           *           where:
    177           *           <b>T</b> : sampling time
    178           *
    179           *  The <b>anti-windup</b> technique is implemented as follows.
    180           *
    181           *  It stops integration when the sum of proportional and integral components exceeds the output limits
    182           *  and the two components have the same sign.
    183           *
    184           *  @param[in]      pi_params       = PI parameters: gains and limits
    185           *  @param[in]      err             = PI input error in Q17.15 notation
    186           *  @param[in, out] integ_term_k_1  = PI state variable in Q2.30 notation
    187           *  @return         PI output after saturation in Q17.15 notation
    188           */

   \                                 In section .text, align 2, keep-with-next
    189          mc_sint32 Pi__PiRegClamp(mc_sint32 err, mc_sint32* integ_term_k_1, CONTROLLER_PI_PARAMS_TYPE* pi_params)
    190          {
   \                     Pi__PiRegClamp: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4615             MOV      R5,R2
   \   00000006   0x4604             MOV      R4,R0
    191          
    192              mc_sint64 prop_term;
    193              mc_sint64 integ_term;
    194              mc_sint64 tmp;
    195          
    196          
    197              // prop_term calculation in Q34.30 notation
    198              prop_term = MC_MULT_LL_LL(pi_params->KpMant, err, (IQ15 + pi_params->KpExp), IQ15, IQ30);
   \   00000008   0x682A             LDR      R2,[R5, #+0]
   \   0000000A   0x460F             MOV      R7,R1
   \   0000000C   0x17D3             ASRS     R3,R2,#+31
   \   0000000E   0xFBA4 0x0102      UMULL    R0,R1,R4,R2
   \   00000012   0xEA4F 0x78E4      ASR      R8,R4,#+31
   \   00000016   0xFB04 0x1103      MLA      R1,R4,R3,R1
   \   0000001A   0xFB08 0x1102      MLA      R1,R8,R2,R1
   \   0000001E   0xF995 0x2010      LDRSB    R2,[R5, #+16]
   \   00000022   0x.... 0x....      BL       __aeabi_lasr
    199          
    200              // integ_term calculation in Q34.30 notation
    201              integ_term = MC_MULT_LL_LL(pi_params->KiMant, err, (IQ15 + pi_params->KiExp), IQ15, IQ30);
    202          
    203              integ_term = integ_term + (mc_sint64)*integ_term_k_1;
   \   00000026   0x686A             LDR      R2,[R5, #+4]
   \   00000028   0x4606             MOV      R6,R0
   \   0000002A   0x4689             MOV      R9,R1
   \   0000002C   0x17D3             ASRS     R3,R2,#+31
   \   0000002E   0xFBA4 0x0102      UMULL    R0,R1,R4,R2
   \   00000032   0xFB04 0x1103      MLA      R1,R4,R3,R1
   \   00000036   0xFB08 0x1102      MLA      R1,R8,R2,R1
   \   0000003A   0xF995 0x2011      LDRSB    R2,[R5, #+17]
   \   0000003E   0x.... 0x....      BL       __aeabi_lasr
   \   00000042   0x683A             LDR      R2,[R7, #+0]
   \   00000044   0x17D3             ASRS     R3,R2,#+31
   \   00000046   0x1882             ADDS     R2,R0,R2
   \   00000048   0x414B             ADCS     R3,R1,R3
    204          
    205              integ_term = MATHCALC__SATURATE(MC_MINUS_ONE_IQ30, integ_term, MC_ONE_IQ30);
   \   0000004A   0x2B00             CMP      R3,#+0
   \   0000004C   0xDB07             BLT.N    ??Pi__PiRegClamp_0
   \   0000004E   0xDC02             BGT.N    ??Pi__PiRegClamp_1
   \   00000050   0xF1B2 0x4F80      CMP      R2,#+1073741824
   \   00000054   0xD303             BCC.N    ??Pi__PiRegClamp_0
   \                     ??Pi__PiRegClamp_1: (+1)
   \   00000056   0xF04F 0x4280      MOV      R2,#+1073741824
   \   0000005A   0x2300             MOVS     R3,#+0
   \   0000005C   0xE00B             B.N      ??Pi__PiRegClamp_2
   \                     ??Pi__PiRegClamp_0: (+1)
   \   0000005E   0xF04F 0x31FF      MOV      R1,#-1
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable112  ;; 0xc0000001
   \   00000066   0x428B             CMP      R3,R1
   \   00000068   0xDC05             BGT.N    ??Pi__PiRegClamp_2
   \   0000006A   0xDB01             BLT.N    ??Pi__PiRegClamp_3
   \   0000006C   0x4282             CMP      R2,R0
   \   0000006E   0xD202             BCS.N    ??Pi__PiRegClamp_2
   \                     ??Pi__PiRegClamp_3: (+1)
   \   00000070   0xF04F 0x4240      MOV      R2,#-1073741824
   \   00000074   0x460B             MOV      R3,R1
    206          
    207              tmp = prop_term + integ_term;
   \                     ??Pi__PiRegClamp_2: (+1)
   \   00000076   0x18B0             ADDS     R0,R6,R2
    208          
    209              // output Saturation & state variable clamping anti-windup
    210              if (tmp > (mc_sint64) pi_params->UpperLimit)
   \   00000078   0x68AE             LDR      R6,[R5, #+8]
   \   0000007A   0xEB49 0x0103      ADC      R1,R9,R3
   \   0000007E   0xEA4F 0x79E6      ASR      R9,R6,#+31
   \   00000082   0x4589             CMP      R9,R1
   \   00000084   0xDC12             BGT.N    ??Pi__PiRegClamp_4
   \   00000086   0xDB01             BLT.N    ??Pi__PiRegClamp_5
   \   00000088   0x4286             CMP      R6,R0
   \   0000008A   0xD20F             BCS.N    ??Pi__PiRegClamp_4
    211              {
    212                  tmp = (mc_sint64)pi_params->UpperLimit;
   \                     ??Pi__PiRegClamp_5: (+1)
   \   0000008C   0x4630             MOV      R0,R6
   \   0000008E   0x4649             MOV      R1,R9
    213                  // check components sign to decide if clamping is needed
    214                  if ((MATHCALC__SIGN(err)) != (MATHCALC__SIGN(integ_term)))
   \   00000090   0x2C00             CMP      R4,#+0
   \   00000092   0xBF4C             ITE      MI 
   \   00000094   0xF04F 0x34FF      MOVMI    R4,#-1
   \   00000098   0x2401             MOVPL    R4,#+1
   \   0000009A   0x2B00             CMP      R3,#+0
   \   0000009C   0xBFB4             ITE      LT 
   \   0000009E   0xF04F 0x38FF      MOVLT    R8,#-1
   \   000000A2   0xF04F 0x0801      MOVGE    R8,#+1
   \   000000A6   0x4544             CMP      R4,R8
   \   000000A8   0xD017             BEQ.N    ??Pi__PiRegClamp_6
    215                  {
    216                      *integ_term_k_1 = (mc_sint64)integ_term;
   \   000000AA   0xE015             B.N      ??Pi__PiRegClamp_7
    217                  }
    218              }
    219              else if (tmp < (mc_sint64) pi_params->LowerLimit)
   \                     ??Pi__PiRegClamp_4: (+1)
   \   000000AC   0x68EE             LDR      R6,[R5, #+12]
   \   000000AE   0xEBB1 0x7FE6      CMP      R1,R6, ASR #+31
   \   000000B2   0xDC11             BGT.N    ??Pi__PiRegClamp_7
   \   000000B4   0xDB01             BLT.N    ??Pi__PiRegClamp_8
   \   000000B6   0x42B0             CMP      R0,R6
   \   000000B8   0xD20E             BCS.N    ??Pi__PiRegClamp_7
    220              {
    221                  tmp = (mc_sint64)pi_params->LowerLimit;
   \                     ??Pi__PiRegClamp_8: (+1)
   \   000000BA   0x17F1             ASRS     R1,R6,#+31
   \   000000BC   0x4630             MOV      R0,R6
    222                  // check components sign to decide if clamping is needed
    223                  if ((MATHCALC__SIGN(err)) != (MATHCALC__SIGN(integ_term)))
   \   000000BE   0x2C00             CMP      R4,#+0
   \   000000C0   0xBF4C             ITE      MI 
   \   000000C2   0xF04F 0x34FF      MOVMI    R4,#-1
   \   000000C6   0x2401             MOVPL    R4,#+1
   \   000000C8   0x2B00             CMP      R3,#+0
   \   000000CA   0xBFB4             ITE      LT 
   \   000000CC   0xF04F 0x38FF      MOVLT    R8,#-1
   \   000000D0   0xF04F 0x0801      MOVGE    R8,#+1
   \   000000D4   0x4544             CMP      R4,R8
   \   000000D6   0xD000             BEQ.N    ??Pi__PiRegClamp_6
    224                  {
    225                      *integ_term_k_1 = (mc_sint64)integ_term;
    226                  }
    227              }
    228              else
    229              {
    230                  *integ_term_k_1 = (mc_sint64)integ_term;
   \                     ??Pi__PiRegClamp_7: (+1)
   \   000000D8   0x603A             STR      R2,[R7, #+0]
    231              }
    232          
    233              // output in Q17.15 notation
    234              return ((mc_sint32)MC_SCALE(tmp,IQ30,IQ15));
   \                     ??Pi__PiRegClamp_6: (+1)
   \   000000DA   0x0BC0             LSRS     R0,R0,#+15
   \   000000DC   0xEA40 0x4041      ORR      R0,R0,R1, LSL #+17
   \   000000E0   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    235          }
    236          
    237          
    238          
    239          
    240          
    241          
    242          //---------------------------------------------------------------------------------------------------------------------
    243          /**
    244           *  @brief      PI Regulator without anti-windup
    245           *  @details    PI controller algorithm.
    246           *              Definitions:
    247           *
    248           *              <b>e(t)</b> - input error in continuous time domain.
    249           *
    250           *              <b>u(t)</b> - controller output in continuous time domain.
    251           *
    252           *              <b>e(k)</b> - input error at step k - discrete time domain.
    253           *
    254           *              <b>u(k)</b> - controller output at step k - discrete time domain.
    255           *
    256           *              <b>e_max</b> - max range of e(k).
    257           *
    258           *              <b>u_max</b> - max range of u(k).
    259           *
    260           *            PI controller algorithm in <b>continuous time domain</b>:
    261           *
    262           *          \f[ u(t) = K\left(e(t) +\frac{1}{T_i}\int_0^t \! e(t) \, \mathrm{d}t. \right)\f]
    263           *           where:
    264           *            K :  controller gain
    265           *
    266           *            Ti: integral time constant
    267           *
    268           *           PI controller algorithm in <b>fractional arithmetic</b>:
    269           *
    270           *           \f[
    271           *             \begin{aligned}
    272           *                & u_f(k) = K_{p_{sc}} \cdot e_f(k) + u_f(k - 1) + K_{i_{sc}} \cdot e_f(k) \\
    273           *                & e_f(k) = \frac{e(k)}{e_{max}}\\
    274           *                & u_f(k) = \frac{u(k)}{u_{max}}\\
    275           *                & K_{p_{sc}} =  K \frac{e(k)}{e_{max}}\\
    276           *                & K_{i_{sc}} =  K \frac{T}{T_i}\frac{e(k)}{e_{max}}\\
    277           *             \end{aligned}
    278           *           \f]
    279           *           where:
    280           *           <b>T</b> : sampling time
    281           *
    282           *
    283           *  It stops integration when the sum of proportional and integral components exceeds the output limits
    284           *  and the two components have the same sign.
    285           *
    286           *  @param[in]      pi_params       = PI parameters: gains and limits
    287           *  @param[in]      err             = PI input error in Q17.15 notation
    288           *  @param[in, out] integ_term_k_1  = PI state variable in Q2.30 notation
    289           *  @return         PI output after saturation in Q2.30 notation
    290           */

   \                                 In section .text, align 2, keep-with-next
    291          mc_sint32 Pi__PiRegNoAntiWindup(mc_sint32 err, mc_sint32* integ_term_k_1, CONTROLLER_PI_PARAMS_TYPE* pi_params)
    292          {
   \                     Pi__PiRegNoAntiWindup: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4617             MOV      R7,R2
   \   00000006   0x4689             MOV      R9,R1
    293          
    294              mc_sint64 prop_term;
    295              mc_sint64 integ_term;
    296              mc_sint64 tmp64;
    297          
    298          
    299              // prop_term calculation in Q34.30 notation
    300              prop_term = MC_MULT_LL_LL(pi_params->KpMant, err, (IQ15 + pi_params->KpExp), IQ15, IQ30);
    301          
    302              // integ_term calculation in Q34.30 notation
    303              integ_term = MC_MULT_LL_LL(pi_params->KiMant, err, (IQ15 + pi_params->KiExp), IQ15, IQ30);
    304          
    305              integ_term = integ_term + (mc_sint64)*integ_term_k_1;
   \   00000008   0x687A             LDR      R2,[R7, #+4]
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0x17C5             ASRS     R5,R0,#+31
   \   0000000E   0x17D3             ASRS     R3,R2,#+31
   \   00000010   0xFBA4 0x0102      UMULL    R0,R1,R4,R2
   \   00000014   0xFB04 0x1103      MLA      R1,R4,R3,R1
   \   00000018   0xFB05 0x1102      MLA      R1,R5,R2,R1
   \   0000001C   0xF997 0x2011      LDRSB    R2,[R7, #+17]
   \   00000020   0x.... 0x....      BL       __aeabi_lasr
   \   00000024   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \   00000028   0xEB10 0x0802      ADDS     R8,R0,R2
   \   0000002C   0xEB41 0x76E2      ADC      R6,R1,R2, ASR #+31
    306          
    307              // output Saturation & state variable limitation
    308              tmp64 = prop_term + integ_term;
   \   00000030   0x683A             LDR      R2,[R7, #+0]
   \   00000032   0x17D3             ASRS     R3,R2,#+31
   \   00000034   0xFBA4 0x0102      UMULL    R0,R1,R4,R2
   \   00000038   0xFB04 0x1103      MLA      R1,R4,R3,R1
   \   0000003C   0xFB05 0x1102      MLA      R1,R5,R2,R1
   \   00000040   0xF997 0x2010      LDRSB    R2,[R7, #+16]
    309          
    310              tmp64 = MATHCALC__SATURATE((mc_sint64)pi_params->LowerLimit, tmp64, (mc_sint64)pi_params->UpperLimit);
   \   00000044   0x68BC             LDR      R4,[R7, #+8]
   \   00000046   0x.... 0x....      BL       __aeabi_lasr
   \   0000004A   0xEB10 0x0008      ADDS     R0,R0,R8
   \   0000004E   0x68FA             LDR      R2,[R7, #+12]
   \   00000050   0x4171             ADCS     R1,R1,R6
   \   00000052   0x4294             CMP      R4,R2
   \   00000054   0xDB0D             BLT.N    ??Pi__PiRegNoAntiWindup_0
   \   00000056   0xEBB1 0x7FE4      CMP      R1,R4, ASR #+31
   \   0000005A   0xDB02             BLT.N    ??Pi__PiRegNoAntiWindup_1
   \   0000005C   0xDC17             BGT.N    ??Pi__PiRegNoAntiWindup_2
   \   0000005E   0x42A0             CMP      R0,R4
   \   00000060   0xD215             BCS.N    ??Pi__PiRegNoAntiWindup_2
   \                     ??Pi__PiRegNoAntiWindup_1: (+1)
   \   00000062   0x17D3             ASRS     R3,R2,#+31
   \   00000064   0x428B             CMP      R3,R1
   \   00000066   0xDB13             BLT.N    ??Pi__PiRegNoAntiWindup_3
   \   00000068   0xDC09             BGT.N    ??Pi__PiRegNoAntiWindup_4
   \   0000006A   0x4282             CMP      R2,R0
   \   0000006C   0xD310             BCC.N    ??Pi__PiRegNoAntiWindup_3
   \   0000006E   0x4610             MOV      R0,R2
   \   00000070   0xE00E             B.N      ??Pi__PiRegNoAntiWindup_3
   \                     ??Pi__PiRegNoAntiWindup_0: (+1)
   \   00000072   0xEBB1 0x7FE2      CMP      R1,R2, ASR #+31
   \   00000076   0xDB04             BLT.N    ??Pi__PiRegNoAntiWindup_5
   \   00000078   0xDC01             BGT.N    ??Pi__PiRegNoAntiWindup_4
   \   0000007A   0x4290             CMP      R0,R2
   \   0000007C   0xD301             BCC.N    ??Pi__PiRegNoAntiWindup_5
   \                     ??Pi__PiRegNoAntiWindup_4: (+1)
   \   0000007E   0x4610             MOV      R0,R2
   \   00000080   0xE006             B.N      ??Pi__PiRegNoAntiWindup_3
   \                     ??Pi__PiRegNoAntiWindup_5: (+1)
   \   00000082   0x17E5             ASRS     R5,R4,#+31
   \   00000084   0x428D             CMP      R5,R1
   \   00000086   0xDB03             BLT.N    ??Pi__PiRegNoAntiWindup_3
   \   00000088   0xDC01             BGT.N    ??Pi__PiRegNoAntiWindup_2
   \   0000008A   0x4284             CMP      R4,R0
   \   0000008C   0xD300             BCC.N    ??Pi__PiRegNoAntiWindup_3
   \                     ??Pi__PiRegNoAntiWindup_2: (+1)
   \   0000008E   0x4620             MOV      R0,R4
    311          
    312              integ_term = MATHCALC__SATURATE(MC_MINUS_ONE_IQ30, integ_term, MC_ONE_IQ30);
   \                     ??Pi__PiRegNoAntiWindup_3: (+1)
   \   00000090   0x2E00             CMP      R6,#+0
   \   00000092   0xDB09             BLT.N    ??Pi__PiRegNoAntiWindup_6
   \   00000094   0xDC02             BGT.N    ??Pi__PiRegNoAntiWindup_7
   \   00000096   0xF1B8 0x4F80      CMP      R8,#+1073741824
   \   0000009A   0xD305             BCC.N    ??Pi__PiRegNoAntiWindup_6
   \                     ??Pi__PiRegNoAntiWindup_7: (+1)
   \   0000009C   0xF04F 0x4880      MOV      R8,#+1073741824
    313          
    314              *integ_term_k_1 = (mc_sint32)integ_term;
   \   000000A0   0xF8C9 0x8000      STR      R8,[R9, #+0]
    315          
    316              // output in Q2.30 notation
    317              return ((mc_sint32)tmp64);
   \   000000A4   0xE8BD 0x83F0      POP      {R4-R9,PC}
   \                     ??Pi__PiRegNoAntiWindup_6: (+1)
   \   000000A8   0xF04F 0x33FF      MOV      R3,#-1
   \   000000AC   0x.... 0x....      LDR.W    R2,??DataTable112  ;; 0xc0000001
   \   000000B0   0x429E             CMP      R6,R3
   \   000000B2   0xDC04             BGT.N    ??Pi__PiRegNoAntiWindup_8
   \   000000B4   0xDB01             BLT.N    ??Pi__PiRegNoAntiWindup_9
   \   000000B6   0x4590             CMP      R8,R2
   \   000000B8   0xD201             BCS.N    ??Pi__PiRegNoAntiWindup_8
   \                     ??Pi__PiRegNoAntiWindup_9: (+1)
   \   000000BA   0xF04F 0x4840      MOV      R8,#-1073741824
   \                     ??Pi__PiRegNoAntiWindup_8: (+1)
   \   000000BE   0xF8C9 0x8000      STR      R8,[R9, #+0]
   \   000000C2   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    318          }
    319          
    320          
    321          
    322          //---------------------------------------------------------------------------------------------------------------------
    323          /**
    324           *  @brief      PI Regulator with back-calculation anti-windup strategy
    325           *  @details    PI controller algorithm.
    326           *              Definitions:
    327           *
    328           *              <b>e(t)</b> - input error in continuous time domain.
    329           *
    330           *              <b>u(t)</b> - controller output in continuous time domain.
    331           *
    332           *              <b>e(k)</b> - input error at step k - discrete time domain.
    333           *
    334           *              <b>u(k)</b> - controller output at step k - discrete time domain.
    335           *
    336           *              <b>e_max</b> - max range of e(k).
    337           *
    338           *              <b>u_max</b> - max range of u(k).
    339           *
    340           *            PI controller algorithm in <b>continuous time domain</b>:
    341           *
    342           *          \f[ u(t) = K\left(e(t) +\frac{1}{T_i}\int_0^t \! e(t) \, \mathrm{d}t. \right)\f]
    343           *           where:
    344           *            K :  controller gain
    345           *
    346           *            Ti: integral time constant
    347           *
    348           *           PI controller algorithm in <b>fractional arithmetic</b>:
    349           *
    350           *           \f[
    351           *             \begin{aligned}
    352           *                & u_f(k) = K_{p_{sc}} \cdot e_f(k) + u_f(k - 1) + K_{i_{sc}} \cdot e_f(k) \\
    353           *                & e_f(k) = \frac{e(k)}{e_{max}}\\
    354           *                & u_f(k) = \frac{u(k)}{u_{max}}\\
    355           *                & K_{p_{sc}} =  K \frac{e(k)}{e_{max}}\\
    356           *                & K_{i_{sc}} =  K \frac{T}{T_i}\frac{e(k)}{e_{max}}\\
    357           *             \end{aligned}
    358           *           \f]
    359           *           where:
    360           *           <b>T</b> : sampling time
    361           *
    362           *  The <b>anti-windup</b> technique is implemented as follows:
    363           *  when the output saturates, the integral
    364           *  term in the controller is recomputed so that its new value gives an
    365           *  output at the saturation limit
    366           *
    367           *  @param[in]      pi_params       = PI parameters: gains in floating p.u. and limits in IQ
    368           *  @param[in]      err             = PI input error in Q17.15 notation
    369           *  @param[in, out] integ_term_k_1  = PI state variable in Q2.30 notation
    370           *  @return         PI output after saturation in Q17.15 notation
    371           */

   \                                 In section .text, align 2, keep-with-next
    372          sint32 Pi__PiRegBackCalc_FloatGains(sint32 err, sint32* integ_term_k_1, CONTROLLER_PI_PARAMS_FLOATGAINS_TYPE* pi_params)
    373          {
   \                     Pi__PiRegBackCalc_FloatGains: (+1)
   \   00000000   0xE92D 0x4EF0      PUSH     {R4-R7,R9-R11,LR}
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0xEE00 0x0A10      VMOV     S0,R0
   \   0000000A   0xB402             PUSH     {R1}
   \   0000000C   0xED2D 0x8B02      VPUSH    {D8}
   \   00000010   0x4614             MOV      R4,R2
    374              /* p.u. float gains --> kfloat*(IQ<<15) */
    375              sint64 prop_term;
    376              sint64 integ_term;
    377              sint64 tmp;
    378          
    379              // prop_term calculation in Q34.30 notation
    380              //prop_term = (sint64) (pi_params->Kp * (float)(MC_SCALE(err, IQ15, IQ30)));
    381              prop_term = (sint64) (pi_params->Kp * err);
   \   00000012   0xEEB8 0x8AC0      VCVT.F32.S32 S16,S0
   \   00000016   0xED94 0x0A00      VLDR     S0,[R4, #0]
   \   0000001A   0xEE28 0x0A00      VMUL.F32 S0,S16,S0
   \   0000001E   0xEE10 0x0A10      VMOV     R0,S0
   \   00000022   0x.... 0x....      BL       __aeabi_f2lz
    382          
    383              // prop_term Saturation
    384              if (prop_term > pi_params->UpperLimit)
   \   00000026   0x68A5             LDR      R5,[R4, #+8]
   \   00000028   0x468A             MOV      R10,R1
   \   0000002A   0xEA4F 0x79E5      ASR      R9,R5,#+31
   \   0000002E   0x4606             MOV      R6,R0
   \   00000030   0x45D1             CMP      R9,R10
   \   00000032   0xDC05             BGT.N    ??Pi__PiRegBackCalc_FloatGains_0
   \   00000034   0xDB01             BLT.N    ??Pi__PiRegBackCalc_FloatGains_1
   \   00000036   0x42B5             CMP      R5,R6
   \   00000038   0xD202             BCS.N    ??Pi__PiRegBackCalc_FloatGains_0
    385              {
    386                  prop_term = pi_params->UpperLimit;
   \                     ??Pi__PiRegBackCalc_FloatGains_1: (+1)
   \   0000003A   0x462E             MOV      R6,R5
   \   0000003C   0x46CA             MOV      R10,R9
   \   0000003E   0xE009             B.N      ??Pi__PiRegBackCalc_FloatGains_2
    387              }
    388              else if (prop_term < pi_params->LowerLimit)
   \                     ??Pi__PiRegBackCalc_FloatGains_0: (+1)
   \   00000040   0x68E0             LDR      R0,[R4, #+12]
   \   00000042   0xEBBA 0x7FE0      CMP      R10,R0, ASR #+31
   \   00000046   0xDC05             BGT.N    ??Pi__PiRegBackCalc_FloatGains_2
   \   00000048   0xDB01             BLT.N    ??Pi__PiRegBackCalc_FloatGains_3
   \   0000004A   0x4286             CMP      R6,R0
   \   0000004C   0xD202             BCS.N    ??Pi__PiRegBackCalc_FloatGains_2
    389              {
    390                  prop_term = pi_params->LowerLimit;
   \                     ??Pi__PiRegBackCalc_FloatGains_3: (+1)
   \   0000004E   0x4606             MOV      R6,R0
   \   00000050   0xEA4F 0x7AE0      ASR      R10,R0,#+31
    391              }
    392          
    393              // integ_term calculation in Q34.30 notation
    394              //integ_term = (sint64)(pi_params->Ki * (float)(MC_SCALE(err, IQ15, IQ30)));
    395              integ_term = (sint64)(pi_params->Ki * err);
    396          
    397              integ_term = integ_term + *integ_term_k_1;
   \                     ??Pi__PiRegBackCalc_FloatGains_2: (+1)
   \   00000054   0xED94 0x0A01      VLDR     S0,[R4, #+4]
   \   00000058   0xEE28 0x0A00      VMUL.F32 S0,S16,S0
   \   0000005C   0xEE10 0x0A10      VMOV     R0,S0
   \   00000060   0x.... 0x....      BL       __aeabi_f2lz
   \   00000064   0x9A02             LDR      R2,[SP, #+8]
   \   00000066   0x6812             LDR      R2,[R2, #+0]
   \   00000068   0x1887             ADDS     R7,R0,R2
   \   0000006A   0xEB41 0x7BE2      ADC      R11,R1,R2, ASR #+31
    398          
    399              // output Saturation & state variable back-calculation anti-windup
    400              tmp = prop_term + integ_term;
   \   0000006E   0x19F2             ADDS     R2,R6,R7
   \   00000070   0xEB4A 0x030B      ADC      R3,R10,R11
    401          
    402              if (tmp > pi_params->UpperLimit)
   \   00000074   0x4599             CMP      R9,R3
   \   00000076   0xDC06             BGT.N    ??Pi__PiRegBackCalc_FloatGains_4
   \   00000078   0xDB01             BLT.N    ??Pi__PiRegBackCalc_FloatGains_5
   \   0000007A   0x4295             CMP      R5,R2
   \   0000007C   0xD203             BCS.N    ??Pi__PiRegBackCalc_FloatGains_4
    403              {
    404                  tmp = pi_params->UpperLimit;
   \                     ??Pi__PiRegBackCalc_FloatGains_5: (+1)
   \   0000007E   0x462A             MOV      R2,R5
   \   00000080   0x464B             MOV      R3,R9
    405                  *integ_term_k_1 = pi_params->UpperLimit - prop_term;
   \   00000082   0x1BAF             SUBS     R7,R5,R6
   \   00000084   0xE009             B.N      ??Pi__PiRegBackCalc_FloatGains_6
    406              }
    407              else if (tmp < pi_params->LowerLimit)
   \                     ??Pi__PiRegBackCalc_FloatGains_4: (+1)
   \   00000086   0x68E0             LDR      R0,[R4, #+12]
   \   00000088   0xEBB3 0x7FE0      CMP      R3,R0, ASR #+31
   \   0000008C   0xDC05             BGT.N    ??Pi__PiRegBackCalc_FloatGains_6
   \   0000008E   0xDB01             BLT.N    ??Pi__PiRegBackCalc_FloatGains_7
   \   00000090   0x4282             CMP      R2,R0
   \   00000092   0xD202             BCS.N    ??Pi__PiRegBackCalc_FloatGains_6
    408              {
    409                  tmp = pi_params->LowerLimit;
   \                     ??Pi__PiRegBackCalc_FloatGains_7: (+1)
   \   00000094   0x4602             MOV      R2,R0
   \   00000096   0x17C3             ASRS     R3,R0,#+31
    410                  *integ_term_k_1 = pi_params->LowerLimit - prop_term;
   \   00000098   0x1B87             SUBS     R7,R0,R6
    411              }
    412              else
    413              {
    414                  *integ_term_k_1 = integ_term;
   \                     ??Pi__PiRegBackCalc_FloatGains_6: (+1)
   \   0000009A   0x9802             LDR      R0,[SP, #+8]
   \   0000009C   0x6007             STR      R7,[R0, #+0]
    415              }
    416          
    417              // output in Q17.15 notation
    418              return ((sint32)(MC_SCALE(tmp,IQ30,IQ15)));
   \   0000009E   0x0BD2             LSRS     R2,R2,#+15
   \   000000A0   0xECBD 0x8B02      VPOP     {D8}
   \   000000A4   0xEA42 0x4043      ORR      R0,R2,R3, LSL #+17
   \   000000A8   0xB002             ADD      SP,SP,#+8
   \   000000AA   0xE8BD 0x8EF0      POP      {R4-R7,R9-R11,PC}  ;; return
    419          }
    420          
    421          
    422          //---------------------------------------------------------------------------------------------------------------------
    423          /**
    424           *  @brief     Integral routine: it approximates the integral of an input quantities according to Backward-Euler Method.
    425           *  @details
    426           *  This function approximates the integral of an input signal according to the Backward-Euler Method.
    427           *  The output is eventually saturated to the upper or lower limit if needed.
    428           *
    429           *          Integrator in <b>continuous time domain</b>:
    430           *          \f[ y(t) =  K_i\int_0^t \! x(t) \, \mathrm{d}t. \f]
    431           *           where:
    432           *           Ki : integrator gain
    433           *
    434           *           Integrator in <b>fractional arithmetic</b>, <b>discrete time domain</b>:
    435           *
    436           *           \f[ y_f(k) =  y_f(k - 1) + T_s \cdot K_{i_{f}} \cdot x_f(k) \f]
    437           *           where:
    438           *           Ts : sampling period
    439           *
    440           *  @param[in]      integ_params    = integrator parameters: integrator gain and limits
    441           *  @param[in, out] y_k_1           = integrator output in Q2.30 notation  (input is at k-1 step, output is at k step)
    442           *  @param[in]      x_k             = integrator input in Q17.15 notation
    443           *  @return         integrator output after saturation in Q17.15 notation
    444           *
    445           */

   \                                 In section .text, align 2, keep-with-next
    446          mc_sint32 Pi__IntegBESat(mc_sint32 x_k, mc_sint32* y_k_1, INTEGRATOR_PARAMS_TYPE* integ_params)
    447          {
   \                     Pi__IntegBESat: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x4615             MOV      R5,R2
   \   00000004   0x460C             MOV      R4,R1
    448              mc_sint64 temp64;
    449              temp64 = (mc_sint64) (*y_k_1) + MC_MULT_LL_LL(x_k,integ_params->KiMant, IQ15,(IQ15+integ_params->KiExp),IQ30);
   \   00000006   0xF9B5 0x1000      LDRSH    R1,[R5, #+0]
   \   0000000A   0x89AA             LDRH     R2,[R5, #+12]
   \   0000000C   0x6826             LDR      R6,[R4, #+0]
   \   0000000E   0xFB81 0x0100      SMULL    R0,R1,R1,R0
   \   00000012   0x.... 0x....      BL       __aeabi_lasr
   \   00000016   0x1830             ADDS     R0,R6,R0
   \   00000018   0xEB41 0x71E6      ADC      R1,R1,R6, ASR #+31
    450          
    451              // Saturation
    452              *y_k_1 = (mc_sint32)MATHCALC__SATURATE((mc_sint64)integ_params->LowerLimit, temp64, (mc_sint64)integ_params->UpperLimit);
   \   0000001C   0x68AE             LDR      R6,[R5, #+8]
   \   0000001E   0x686A             LDR      R2,[R5, #+4]
   \   00000020   0x42B2             CMP      R2,R6
   \   00000022   0xDB0C             BLT.N    ??Pi__IntegBESat_0
   \   00000024   0xEBB1 0x7FE2      CMP      R1,R2, ASR #+31
   \   00000028   0xDB02             BLT.N    ??Pi__IntegBESat_1
   \   0000002A   0xDC14             BGT.N    ??Pi__IntegBESat_2
   \   0000002C   0x4290             CMP      R0,R2
   \   0000002E   0xD212             BCS.N    ??Pi__IntegBESat_2
   \                     ??Pi__IntegBESat_1: (+1)
   \   00000030   0x17F7             ASRS     R7,R6,#+31
   \   00000032   0x428F             CMP      R7,R1
   \   00000034   0xDB13             BLT.N    ??Pi__IntegBESat_3
   \   00000036   0xDC13             BGT.N    ??Pi__IntegBESat_4
   \   00000038   0x4286             CMP      R6,R0
   \   0000003A   0xD211             BCS.N    ??Pi__IntegBESat_4
   \   0000003C   0xE00F             B.N      ??Pi__IntegBESat_3
   \                     ??Pi__IntegBESat_0: (+1)
   \   0000003E   0xEBB1 0x7FE6      CMP      R1,R6, ASR #+31
   \   00000042   0xDB02             BLT.N    ??Pi__IntegBESat_5
   \   00000044   0xDC0C             BGT.N    ??Pi__IntegBESat_4
   \   00000046   0x42B0             CMP      R0,R6
   \   00000048   0xD20A             BCS.N    ??Pi__IntegBESat_4
   \                     ??Pi__IntegBESat_5: (+1)
   \   0000004A   0x17D3             ASRS     R3,R2,#+31
   \   0000004C   0x428B             CMP      R3,R1
   \   0000004E   0xDB06             BLT.N    ??Pi__IntegBESat_3
   \   00000050   0xDC01             BGT.N    ??Pi__IntegBESat_2
   \   00000052   0x4282             CMP      R2,R0
   \   00000054   0xD303             BCC.N    ??Pi__IntegBESat_3
   \                     ??Pi__IntegBESat_2: (+1)
   \   00000056   0x4616             MOV      R6,R2
   \   00000058   0x6026             STR      R6,[R4, #+0]
    453          /*
    454              if (temp64 > integ_params->UpperLimit)
    455              {
    456                  *y_k_1 = integ_params->UpperLimit;     //2.30
    457              }
    458              else if (temp64 < integ_params->LowerLimit)
    459              {
    460                  *y_k_1 = integ_params->LowerLimit;     //2.30
    461              }
    462              else
    463              {
    464                  *y_k_1 = (sint32)temp64;
    465              }
    466          */
    467              return (MC_SCALE(*y_k_1, IQ30, IQ15));    //y_k in 17.15 notation
   \   0000005A   0x13F0             ASRS     R0,R6,#+15
   \   0000005C   0xBDF0             POP      {R4-R7,PC}
   \                     ??Pi__IntegBESat_3: (+1)
   \   0000005E   0x4606             MOV      R6,R0
   \                     ??Pi__IntegBESat_4: (+1)
   \   00000060   0x6026             STR      R6,[R4, #+0]
   \   00000062   0x13F0             ASRS     R0,R6,#+15
   \   00000064   0xBDF0             POP      {R4-R7,PC}       ;; return
    468          }
    469          
    470          
    471          //---------------------------------------------------------------------------------------------------------------------
    472          /**
    473           *  @brief     Integral routine: it approximates the integral of an input quantities according to Backward-Euler Method.
    474           *  @details
    475           *  This function approximates the integral of an input signal according to the Backward-Euler Method.
    476           *  The output is not saturated, so overflow may occur.
    477           *
    478           *          Integrator in <b>continuous time domain</b>:
    479           *          \f[ y(t) =  K_i\int_0^t \! x(t) \, \mathrm{d}t. \f]
    480           *           where:
    481           *           Ki : integrator gain
    482           *
    483           *           Integrator in <b>fractional arithmetic</b>, <b>discrete time domain</b>:
    484           *
    485           *           \f[ y_f(k) =  y_f(k - 1) + T_s \cdot K_{i_{f}} \cdot x_f(k) \f]
    486           *           where:
    487           *           Ts : sampling period
    488           *
    489           *  @param[in]      integ_params    = integrator parameters: integrator gain and limits
    490           *  @param[in, out] y_k_1           = integrator output in Q2.30 notation  (input is at k-1 step, output is at k step)
    491           *  @param[in]      x_k             = integrator input in Q17.15 notation
    492           *  @return         integrator output in Q17.15 notation
    493           *
    494           */

   \                                 In section .text, align 2, keep-with-next
    495          mc_sint32 Pi__IntegBE(mc_sint32 x_k, mc_sint32* y_k_1, INTEGRATOR_PARAMS_TYPE* integ_params)
    496          {
    497              mc_sint32 temp;
    498          
    499              temp = MC_MULT_L(x_k, integ_params->KiMant,IQ15, (IQ15+integ_params->KiExp), IQ30);  //2.30 not saturated
    500              *y_k_1 = *y_k_1 + temp;   //y_k in 2.30 notation
   \                     Pi__IntegBE: (+1)
   \   00000000   0xF9B2 0xC000      LDRSH    R12,[R2, #+0]
   \   00000004   0x8992             LDRH     R2,[R2, #+12]
   \   00000006   0x680B             LDR      R3,[R1, #+0]
   \   00000008   0xFB00 0xF00C      MUL      R0,R0,R12
   \   0000000C   0x4110             ASRS     R0,R0,R2
   \   0000000E   0x18C0             ADDS     R0,R0,R3
   \   00000010   0x6008             STR      R0,[R1, #+0]
    501          
    502              return (MC_SCALE(*y_k_1, IQ30, IQ15));    //y_k in 17.15 notation
   \   00000012   0x13C0             ASRS     R0,R0,#+15
   \   00000014   0x4770             BX       LR               ;; return
    503          }
    504          
    505          
    506          
    507          //---------------------------------------------------------------------------------------------------------------------
    508          /**
    509           *  @brief      PI Regulator with back-calculation anti-windup strategy
    510           *  @details    PI controller algorithm.
    511           *              Definitions:
    512           *
    513           *              <b>e(t)</b> - input error in continuous time domain.
    514           *
    515           *              <b>u(t)</b> - controller output in continuous time domain.
    516           *
    517           *              <b>e(k)</b> - input error at step k - discrete time domain.
    518           *
    519           *              <b>u(k)</b> - controller output at step k - discrete time domain.
    520           *
    521           *              <b>e_max</b> - max range of e(k).
    522           *
    523           *              <b>u_max</b> - max range of u(k).
    524           *
    525           *            PI controller algorithm in <b>continuous time domain</b>:
    526           *
    527           *          \f[ u(t) = K\left(e(t) +\frac{1}{T_i}\int_0^t \! e(t) \, \mathrm{d}t. \right)\f]
    528           *           where:
    529           *            K :  controller gain
    530           *
    531           *            Ti: integral time constant
    532           *
    533           *           PI controller algorithm in <b>fractional arithmetic</b>:
    534           *
    535           *           \f[
    536           *             \begin{aligned}
    537           *                & u_f(k) = K_{p_{sc}} \cdot e_f(k) + u_f(k - 1) + K_{i_{sc}} \cdot e_f(k) \\
    538           *                & e_f(k) = \frac{e(k)}{e_{max}}\\
    539           *                & u_f(k) = \frac{u(k)}{u_{max}}\\
    540           *                & K_{p_{sc}} =  K \frac{e(k)}{e_{max}}\\
    541           *                & K_{i_{sc}} =  K \frac{T}{T_i}\frac{e(k)}{e_{max}}\\
    542           *             \end{aligned}
    543           *           \f]
    544           *           where:
    545           *           <b>T</b> : sampling time
    546           *
    547           *  The <b>anti-windup</b> technique is implemented as follows:
    548           *  when the output saturates, the integral
    549           *  term in the controller is recomputed so that its new value gives an
    550           *  output at the saturation limit
    551           *
    552           *  @param[in]      pi_params       = PI parameters: gains and limits
    553           *  @param[in]      err             = PI input error in Q17.15 notation
    554           *  @param[in, out] integ_term_k_1  = PI state variable in Q2.30 notation
    555           *  @return         PI output after saturation in Q17.15 notation
    556           */

   \                                 In section .text, align 2, keep-with-next
    557          mc_sint32 Pi__PiRegBackCalc_FixedGains(mc_sint32 err, mc_sint32* integ_term_k_1, CONTROLLER_PI_PARAMS_FIXEDGAINS_TYPE* pi_params)
    558          {
   \                     Pi__PiRegBackCalc_FixedGains: (+1)
   \   00000000   0xE92D 0x4BF0      PUSH     {R4-R9,R11,LR}
   \   00000004   0x4696             MOV      LR,R2
    559          
    560              mc_sint64 prop_term;
    561              mc_sint64 integ_term;
    562              mc_sint64 tmp;
    563          
    564              // prop_term calculation in Q.39 notation
    565              prop_term = (mc_sint64) pi_params->Kp * (mc_sint64) err;
    566              prop_term = MC_SCALE(prop_term, IQ39, IQ30);
   \   00000006   0x4606             MOV      R6,R0
   \   00000008   0xEA4F 0x78E0      ASR      R8,R0,#+31
   \   0000000C   0xF8DE 0x0000      LDR      R0,[LR, #+0]
    567          
    568              // prop_term Saturation
    569              if (prop_term > (mc_sint64)pi_params->UpperLimit)
   \   00000010   0xF8DE 0x2008      LDR      R2,[LR, #+8]
   \   00000014   0x468B             MOV      R11,R1
   \   00000016   0x17C1             ASRS     R1,R0,#+31
   \   00000018   0xFBA6 0x4500      UMULL    R4,R5,R6,R0
   \   0000001C   0xFB06 0x5501      MLA      R5,R6,R1,R5
   \   00000020   0xFB08 0x5500      MLA      R5,R8,R0,R5
   \   00000024   0x0A64             LSRS     R4,R4,#+9
   \   00000026   0xEA44 0x54C5      ORR      R4,R4,R5, LSL #+23
   \   0000002A   0x126D             ASRS     R5,R5,#+9
   \   0000002C   0x17D3             ASRS     R3,R2,#+31
   \   0000002E   0x42AB             CMP      R3,R5
   \   00000030   0xDC05             BGT.N    ??Pi__PiRegBackCalc_FixedGains_0
   \   00000032   0xDB01             BLT.N    ??Pi__PiRegBackCalc_FixedGains_1
   \   00000034   0x42A2             CMP      R2,R4
   \   00000036   0xD202             BCS.N    ??Pi__PiRegBackCalc_FixedGains_0
    570              {
    571                  prop_term = (mc_sint64)pi_params->UpperLimit;
   \                     ??Pi__PiRegBackCalc_FixedGains_1: (+1)
   \   00000038   0x4614             MOV      R4,R2
   \   0000003A   0x461D             MOV      R5,R3
   \   0000003C   0xE009             B.N      ??Pi__PiRegBackCalc_FixedGains_2
    572              }
    573              else if (prop_term < (mc_sint64)pi_params->LowerLimit)
   \                     ??Pi__PiRegBackCalc_FixedGains_0: (+1)
   \   0000003E   0xF8DE 0x000C      LDR      R0,[LR, #+12]
   \   00000042   0xEBB5 0x7FE0      CMP      R5,R0, ASR #+31
   \   00000046   0xDC04             BGT.N    ??Pi__PiRegBackCalc_FixedGains_2
   \   00000048   0xDB01             BLT.N    ??Pi__PiRegBackCalc_FixedGains_3
   \   0000004A   0x4284             CMP      R4,R0
   \   0000004C   0xD201             BCS.N    ??Pi__PiRegBackCalc_FixedGains_2
    574              {
    575                  prop_term = (mc_sint64)pi_params->LowerLimit;
   \                     ??Pi__PiRegBackCalc_FixedGains_3: (+1)
   \   0000004E   0x4604             MOV      R4,R0
   \   00000050   0x17C5             ASRS     R5,R0,#+31
    576              }
    577          
    578              // integ_term calculation in Q.44 notation
    579              integ_term = (mc_sint64) pi_params->Ki * (mc_sint64) err;
    580              integ_term = MC_SCALE(integ_term, IQ44, IQ30);
    581          
    582              integ_term = integ_term + (mc_sint64)*integ_term_k_1;
   \                     ??Pi__PiRegBackCalc_FixedGains_2: (+1)
   \   00000052   0xF8DE 0x0004      LDR      R0,[LR, #+4]
   \   00000056   0x17C1             ASRS     R1,R0,#+31
   \   00000058   0xFBA6 0x7900      UMULL    R7,R9,R6,R0
   \   0000005C   0xFB06 0x9901      MLA      R9,R6,R1,R9
   \   00000060   0xFB08 0x9900      MLA      R9,R8,R0,R9
   \   00000064   0x0BB8             LSRS     R0,R7,#+14
   \   00000066   0xEA40 0x4789      ORR      R7,R0,R9, LSL #+18
   \   0000006A   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   0000006E   0x17C1             ASRS     R1,R0,#+31
   \   00000070   0x183E             ADDS     R6,R7,R0
   \   00000072   0xEB41 0x38A9      ADC      R8,R1,R9, ASR #+14
    583          
    584              // output Saturation & state variable back-calculation anti-windup
    585              tmp = prop_term + integ_term;
   \   00000076   0x19A7             ADDS     R7,R4,R6
   \   00000078   0xEB45 0x0908      ADC      R9,R5,R8
    586          
    587              if (tmp > (mc_sint64)pi_params->UpperLimit)
   \   0000007C   0x454B             CMP      R3,R9
   \   0000007E   0xDC0C             BGT.N    ??Pi__PiRegBackCalc_FixedGains_4
   \   00000080   0xDB01             BLT.N    ??Pi__PiRegBackCalc_FixedGains_5
   \   00000082   0x42BA             CMP      R2,R7
   \   00000084   0xD209             BCS.N    ??Pi__PiRegBackCalc_FixedGains_4
    588              {
    589                  tmp = (mc_sint64)pi_params->UpperLimit;
   \                     ??Pi__PiRegBackCalc_FixedGains_5: (+1)
   \   00000086   0x4617             MOV      R7,R2
   \   00000088   0x4699             MOV      R9,R3
    590                  *integ_term_k_1 = pi_params->UpperLimit - (mc_sint32)prop_term;
   \   0000008A   0x1B16             SUBS     R6,R2,R4
    591              }
    592              else if (tmp < pi_params->LowerLimit)
    593              {
    594                  tmp = (mc_sint64)pi_params->LowerLimit;
    595                  *integ_term_k_1 = pi_params->LowerLimit - (mc_sint32)prop_term;
    596              }
    597              else
    598              {
    599                  *integ_term_k_1 = (mc_sint64)integ_term;
    600              }
    601          
    602              // output in Q17.15 notation
    603              return ((mc_sint32)(MC_SCALE(tmp,IQ30,IQ15)));
   \   0000008C   0x0BF9             LSRS     R1,R7,#+15
   \   0000008E   0xF8CB 0x6000      STR      R6,[R11, #+0]
   \   00000092   0xEA41 0x4049      ORR      R0,R1,R9, LSL #+17
   \   00000096   0xE8BD 0x8BF0      POP      {R4-R9,R11,PC}
   \                     ??Pi__PiRegBackCalc_FixedGains_4: (+1)
   \   0000009A   0xF8DE 0x000C      LDR      R0,[LR, #+12]
   \   0000009E   0xEBB9 0x7FE0      CMP      R9,R0, ASR #+31
   \   000000A2   0xDC06             BGT.N    ??Pi__PiRegBackCalc_FixedGains_6
   \   000000A4   0xDB01             BLT.N    ??Pi__PiRegBackCalc_FixedGains_7
   \   000000A6   0x4287             CMP      R7,R0
   \   000000A8   0xD203             BCS.N    ??Pi__PiRegBackCalc_FixedGains_6
   \                     ??Pi__PiRegBackCalc_FixedGains_7: (+1)
   \   000000AA   0x4607             MOV      R7,R0
   \   000000AC   0xEA4F 0x79E0      ASR      R9,R0,#+31
   \   000000B0   0x1B06             SUBS     R6,R0,R4
   \                     ??Pi__PiRegBackCalc_FixedGains_6: (+1)
   \   000000B2   0x0BF9             LSRS     R1,R7,#+15
   \   000000B4   0xF8CB 0x6000      STR      R6,[R11, #+0]
   \   000000B8   0xEA41 0x4049      ORR      R0,R1,R9, LSL #+17
   \   000000BC   0xE8BD 0x8BF0      POP      {R4-R9,R11,PC}   ;; return
    604          }
    605          
    606          
    607          //---------------------------------------------------------------------------------------------------------------------
    608          /**
    609           *  @brief      Initialize pi parameters.
    610           *
    611           *  @param      sum, out
    612           *  @return     none
    613           */

   \                                 In section .text, align 2, keep-with-next
    614          void Pi__InitPiQ60( TPiParmQ60 *parmPtr )
    615          {
    616              parmPtr->sum = 0;
   \                     Pi__InitPiQ60: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0xE9C0 0x2200      STRD     R2,R2,[R0, #+0]
    617              parmPtr->out = 0;
   \   00000006   0x6402             STR      R2,[R0, #+64]
    618          }
   \   00000008   0x4770             BX       LR               ;; return
    619          
    620          
    621          
    622          
    623          //---------------------------------------------------------------------------------------------------------------------
    624          /**
    625           *  @brief      Calculate pi control value, internal variable is Q60 format.
    626           *
    627           *  @param      Kp, Ki, outMax, outMin, inRef, inMeas
    628           *  @return     out
    629           */

   \                                 In section .text, align 2, keep-with-next
    630          void Pi__CalcPiQ60(TPiParmQ60 *parmPtr)
    631          {
   \                     Pi__CalcPiQ60: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0xB081             SUB      SP,SP,#+4
    632              signed long long int tempS64;
    633          
    634              parmPtr->err = parmPtr->inRef - parmPtr->inMeas;
   \   00000008   0x6BA8             LDR      R0,[R5, #+56]
   \   0000000A   0x6BE9             LDR      R1,[R5, #+60]
   \   0000000C   0x1A44             SUBS     R4,R0,R1
   \   0000000E   0x62AC             STR      R4,[R5, #+40]
    635          
    636              tempS64 = ((signed long long int)parmPtr->Kp * (signed long long int)parmPtr->err) << (parmPtr->Fmt.PropSum - parmPtr->Fmt.Kp - parmPtr->Fmt.In);
   \   00000010   0x46A0             MOV      R8,R4
   \   00000012   0xF895 0x0044      LDRB     R0,[R5, #+68]
   \   00000016   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000001A   0xEA4F 0x79E4      ASR      R9,R4,#+31
   \   0000001E   0x6A2A             LDR      R2,[R5, #+32]
   \   00000020   0x17D3             ASRS     R3,R2,#+31
   \   00000022   0xFBA8 0x0102      UMULL    R0,R1,R8,R2
   \   00000026   0xFB08 0x1103      MLA      R1,R8,R3,R1
   \   0000002A   0xFB09 0x1102      MLA      R1,R9,R2,R1
   \   0000002E   0xF895 0xA048      LDRB     R10,[R5, #+72]
   \   00000032   0xF895 0x2046      LDRB     R2,[R5, #+70]
   \   00000036   0xF89D 0x3000      LDRB     R3,[SP, #+0]
   \   0000003A   0xEBAA 0x0202      SUB      R2,R10,R2
   \   0000003E   0x1AD2             SUBS     R2,R2,R3
   \   00000040   0x.... 0x....      BL       __aeabi_llsl
   \   00000044   0x4606             MOV      R6,R0
    637          
    638              if (parmPtr->err >= 0)
   \   00000046   0xF895 0x0045      LDRB     R0,[R5, #+69]
   \   0000004A   0x460F             MOV      R7,R1
   \   0000004C   0xEBAA 0x0B00      SUB      R11,R10,R0
   \   00000050   0x2C00             CMP      R4,#+0
   \   00000052   0xD40A             BMI.N    ??Pi__CalcPiQ60_0
    639              {
    640                  if(tempS64 >= ((signed long long int)parmPtr->outMax << (parmPtr->Fmt.PropSum - parmPtr->Fmt.Out)))
   \   00000054   0x6B28             LDR      R0,[R5, #+48]
   \   00000056   0x17C1             ASRS     R1,R0,#+31
   \   00000058   0x465A             MOV      R2,R11
   \   0000005A   0x.... 0x....      BL       __aeabi_llsl
   \   0000005E   0x428F             CMP      R7,R1
   \   00000060   0xDB0D             BLT.N    ??Pi__CalcPiQ60_1
   \   00000062   0xDC0E             BGT.N    ??Pi__CalcPiQ60_2
   \   00000064   0x4286             CMP      R6,R0
   \   00000066   0xD20C             BCS.N    ??Pi__CalcPiQ60_2
    641                  {
    642                      parmPtr->prop = (signed long long int)(parmPtr->outMax) << (parmPtr->Fmt.PropSum - parmPtr->Fmt.Out);
    643                  }
    644                  else
    645                  {
    646                      parmPtr->prop = tempS64;
   \   00000068   0xE009             B.N      ??Pi__CalcPiQ60_1
    647                  }
    648              }
    649              else
    650              {
    651                  if(tempS64 <= ((signed long long int)(parmPtr->outMin) << (parmPtr->Fmt.PropSum - parmPtr->Fmt.Out)) )
   \                     ??Pi__CalcPiQ60_0: (+1)
   \   0000006A   0x6B68             LDR      R0,[R5, #+52]
   \   0000006C   0x17C1             ASRS     R1,R0,#+31
   \   0000006E   0x465A             MOV      R2,R11
   \   00000070   0x.... 0x....      BL       __aeabi_llsl
   \   00000074   0x42B9             CMP      R1,R7
   \   00000076   0xDB02             BLT.N    ??Pi__CalcPiQ60_1
   \   00000078   0xDC03             BGT.N    ??Pi__CalcPiQ60_2
   \   0000007A   0x42B0             CMP      R0,R6
   \   0000007C   0xD201             BCS.N    ??Pi__CalcPiQ60_2
    652                  {
    653                      parmPtr->prop = (signed long long int)parmPtr->outMin << (parmPtr->Fmt.PropSum - parmPtr->Fmt.Out);
    654                  }
    655                  else
    656                  {
    657                      parmPtr->prop = tempS64;
   \                     ??Pi__CalcPiQ60_1: (+1)
   \   0000007E   0x4630             MOV      R0,R6
   \   00000080   0x4639             MOV      R1,R7
   \                     ??Pi__CalcPiQ60_2: (+1)
   \   00000082   0xE9C5 0x0102      STRD     R0,R1,[R5, #+8]
    658                  }
    659              }
    660          
    661              if ( parmPtr->err >= 0)
   \   00000086   0xE9D5 0x6702      LDRD     R6,R7,[R5, #+8]
   \   0000008A   0x2C00             CMP      R4,#+0
   \   0000008C   0xD40A             BMI.N    ??Pi__CalcPiQ60_3
    662              {
    663                  parmPtr->int_uplim = ((signed long long int)parmPtr->outMax << (parmPtr->Fmt.PropSum - parmPtr->Fmt.Out)) - parmPtr->prop;
   \   0000008E   0x6B28             LDR      R0,[R5, #+48]
   \   00000090   0x17C1             ASRS     R1,R0,#+31
   \   00000092   0x465A             MOV      R2,R11
   \   00000094   0x.... 0x....      BL       __aeabi_llsl
   \   00000098   0x1B80             SUBS     R0,R0,R6
   \   0000009A   0x41B9             SBCS     R1,R1,R7
    664                  parmPtr->int_lowlim = -(parmPtr->int_uplim);
   \   0000009C   0x4242             RSBS     R2,R0,#+0
   \   0000009E   0xEB61 0x0341      SBC      R3,R1,R1, LSL #+1
   \   000000A2   0xE00A             B.N      ??Pi__CalcPiQ60_4
    665              }
    666              else
    667              {
    668                  parmPtr->int_lowlim = ((signed long long int)parmPtr->outMin << (parmPtr->Fmt.PropSum - parmPtr->Fmt.Out)) - parmPtr->prop;
   \                     ??Pi__CalcPiQ60_3: (+1)
   \   000000A4   0x6B68             LDR      R0,[R5, #+52]
   \   000000A6   0x17C1             ASRS     R1,R0,#+31
   \   000000A8   0x465A             MOV      R2,R11
   \   000000AA   0x.... 0x....      BL       __aeabi_llsl
   \   000000AE   0x1B82             SUBS     R2,R0,R6
   \   000000B0   0xEB61 0x0307      SBC      R3,R1,R7
    669                  parmPtr->int_uplim = -(parmPtr->int_lowlim);
   \   000000B4   0x4250             RSBS     R0,R2,#+0
   \   000000B6   0xEB63 0x0143      SBC      R1,R3,R3, LSL #+1
   \                     ??Pi__CalcPiQ60_4: (+1)
   \   000000BA   0xE9C5 0x2306      STRD     R2,R3,[R5, #+24]
   \   000000BE   0xE9C5 0x0104      STRD     R0,R1,[R5, #+16]
    670              }
    671          
    672              tempS64 = (((signed long long int)parmPtr->Ki * (signed long long int)parmPtr->err) << (parmPtr->Fmt.PropSum - parmPtr->Fmt.Ki - parmPtr->Fmt.In)) + parmPtr->sum;
   \   000000C2   0x6A68             LDR      R0,[R5, #+36]
   \   000000C4   0x17C1             ASRS     R1,R0,#+31
   \   000000C6   0xFBA8 0x2300      UMULL    R2,R3,R8,R0
   \   000000CA   0xFB08 0x3301      MLA      R3,R8,R1,R3
   \   000000CE   0xFB09 0x3300      MLA      R3,R9,R0,R3
   \   000000D2   0x4610             MOV      R0,R2
   \   000000D4   0x4619             MOV      R1,R3
   \   000000D6   0xF895 0x2047      LDRB     R2,[R5, #+71]
   \   000000DA   0xF89D 0x3000      LDRB     R3,[SP, #+0]
   \   000000DE   0xEBAA 0x0202      SUB      R2,R10,R2
   \   000000E2   0x1AD2             SUBS     R2,R2,R3
   \   000000E4   0x.... 0x....      BL       __aeabi_llsl
   \   000000E8   0xE9D5 0x2300      LDRD     R2,R3,[R5, #+0]
   \   000000EC   0x1880             ADDS     R0,R0,R2
   \   000000EE   0x4159             ADCS     R1,R1,R3
    673          
    674              if (tempS64 >= parmPtr->int_uplim)
   \   000000F0   0xE9D5 0x2304      LDRD     R2,R3,[R5, #+16]
   \   000000F4   0x4299             CMP      R1,R3
   \   000000F6   0xDB02             BLT.N    ??Pi__CalcPiQ60_5
   \   000000F8   0xDC08             BGT.N    ??Pi__CalcPiQ60_6
   \   000000FA   0x4290             CMP      R0,R2
   \   000000FC   0xD206             BCS.N    ??Pi__CalcPiQ60_6
    675              {
    676                  parmPtr->sum = parmPtr->int_uplim;
    677              }
    678              else if (tempS64 <= parmPtr->int_lowlim)
   \                     ??Pi__CalcPiQ60_5: (+1)
   \   000000FE   0xE9D5 0x2306      LDRD     R2,R3,[R5, #+24]
   \   00000102   0x428B             CMP      R3,R1
   \   00000104   0xDB04             BLT.N    ??Pi__CalcPiQ60_7
   \   00000106   0xDC01             BGT.N    ??Pi__CalcPiQ60_6
   \   00000108   0x4282             CMP      R2,R0
   \   0000010A   0xD301             BCC.N    ??Pi__CalcPiQ60_7
    679              {
    680                  parmPtr->sum = parmPtr->int_lowlim;
   \                     ??Pi__CalcPiQ60_6: (+1)
   \   0000010C   0x4610             MOV      R0,R2
   \   0000010E   0x4619             MOV      R1,R3
    681              }
    682              else
    683              {
    684                  parmPtr->sum = tempS64;
   \                     ??Pi__CalcPiQ60_7: (+1)
   \   00000110   0xE9C5 0x0100      STRD     R0,R1,[R5, #+0]
    685              }
    686              parmPtr->out = (signed long int)((parmPtr->sum + parmPtr->prop) >> (parmPtr->Fmt.PropSum - parmPtr->Fmt.Out));
   \   00000114   0x465A             MOV      R2,R11
   \   00000116   0x1980             ADDS     R0,R0,R6
   \   00000118   0x4179             ADCS     R1,R1,R7
   \   0000011A   0x.... 0x....      BL       __aeabi_lasr
   \   0000011E   0x6428             STR      R0,[R5, #+64]
    687          }
   \   00000120   0xB001             ADD      SP,SP,#+4
   \   00000122   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    688          
    689          
    690          
    691          
    692          //---------------------------------------------------------------------------------------------------------------------
    693          /**
    694           *  @brief      Calculate pi control value, internal variable is Q60 format.
    695           *
    696           *  @param      Kp, Ki, outMax, outMin, inRef, inMeas
    697           *  @return     out
    698           */

   \                                 In section .text, align 2, keep-with-next
    699          void Pi__CalcPiQ30(TPiParmQ30 *parmPtr)
    700          {
   \                     Pi__CalcPiQ30: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    701              signed long int tempS32;
    702          
    703              parmPtr->err = parmPtr->inRef - parmPtr->inMeas;
   \   00000002   0x6A81             LDR      R1,[R0, #+40]
   \   00000004   0x6AC2             LDR      R2,[R0, #+44]
   \   00000006   0x1A89             SUBS     R1,R1,R2
   \   00000008   0x6181             STR      R1,[R0, #+24]
    704          
    705          
    706              tempS32 = ((signed long int)parmPtr->Kp * (signed long int)parmPtr->err) << (parmPtr->Fmt.PropSum - parmPtr->Fmt.Kp - parmPtr->Fmt.In);
   \   0000000A   0xF890 0x3038      LDRB     R3,[R0, #+56]
   \   0000000E   0xF890 0x5036      LDRB     R5,[R0, #+54]
   \   00000012   0xF890 0x2034      LDRB     R2,[R0, #+52]
   \   00000016   0x6904             LDR      R4,[R0, #+16]
   \   00000018   0x1B5D             SUBS     R5,R3,R5
   \   0000001A   0x434C             MULS     R4,R4,R1
   \   0000001C   0x1AAD             SUBS     R5,R5,R2
   \   0000001E   0xFA04 0xF505      LSL      R5,R4,R5
    707              //tempS32 is in Q(FmtPropSum) format now
    708          
    709              if (parmPtr->err >= 0)
   \   00000022   0xF890 0x4035      LDRB     R4,[R0, #+53]
   \   00000026   0x1B1C             SUBS     R4,R3,R4
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD403             BMI.N    ??Pi__CalcPiQ30_0
    710              {
    711                  if(tempS32 >= ((signed long int)parmPtr->outMax << (parmPtr->Fmt.PropSum - parmPtr->Fmt.Out)))
   \   0000002C   0x6A06             LDR      R6,[R0, #+32]
   \   0000002E   0x40A6             LSLS     R6,R6,R4
   \   00000030   0x42B5             CMP      R5,R6
   \   00000032   0xE002             B.N      ??Pi__CalcPiQ30_1
    712                  {
    713                      parmPtr->prop = (signed long int)(parmPtr->outMax) << (parmPtr->Fmt.PropSum - parmPtr->Fmt.Out);
    714                  }
    715                  else
    716                  {
    717                      parmPtr->prop = tempS32;
    718                  }
    719              }
    720              else
    721              {
    722                  if(tempS32 <= ((signed long int)(parmPtr->outMin) << (parmPtr->Fmt.PropSum - parmPtr->Fmt.Out)) )
   \                     ??Pi__CalcPiQ30_0: (+1)
   \   00000034   0x6A46             LDR      R6,[R0, #+36]
   \   00000036   0x40A6             LSLS     R6,R6,R4
   \   00000038   0x42AE             CMP      R6,R5
   \                     ??Pi__CalcPiQ30_1: (+1)
   \   0000003A   0xBFA8             IT       GE 
    723                  {
    724                      parmPtr->prop = (signed long int)parmPtr->outMin << (parmPtr->Fmt.PropSum - parmPtr->Fmt.Out);
   \   0000003C   0x4635             MOVGE    R5,R6
    725                  }
    726                  else
    727                  {
    728                      parmPtr->prop = tempS32;
   \   0000003E   0x6045             STR      R5,[R0, #+4]
    729                  }
    730              }
    731          
    732              if ( parmPtr->err >= 0)
   \   00000040   0x2900             CMP      R1,#+0
   \   00000042   0xD404             BMI.N    ??Pi__CalcPiQ30_2
    733              {
    734                  parmPtr->int_uplim = ((signed long int)parmPtr->outMax << (parmPtr->Fmt.PropSum - parmPtr->Fmt.Out)) - parmPtr->prop;
   \   00000044   0x6A06             LDR      R6,[R0, #+32]
   \   00000046   0x40A6             LSLS     R6,R6,R4
   \   00000048   0x1B76             SUBS     R6,R6,R5
    735                  parmPtr->int_lowlim = -(parmPtr->int_uplim);
   \   0000004A   0x4277             RSBS     R7,R6,#+0
   \   0000004C   0xE003             B.N      ??Pi__CalcPiQ30_3
    736              }
    737              else
    738              {
    739                  parmPtr->int_lowlim = ((signed long int)parmPtr->outMin << (parmPtr->Fmt.PropSum - parmPtr->Fmt.Out)) - parmPtr->prop;
   \                     ??Pi__CalcPiQ30_2: (+1)
   \   0000004E   0x6A46             LDR      R6,[R0, #+36]
   \   00000050   0x40A6             LSLS     R6,R6,R4
   \   00000052   0x1B77             SUBS     R7,R6,R5
    740                  parmPtr->int_uplim = -(parmPtr->int_lowlim);
   \   00000054   0x427E             RSBS     R6,R7,#+0
   \                     ??Pi__CalcPiQ30_3: (+1)
   \   00000056   0x60C7             STR      R7,[R0, #+12]
   \   00000058   0x6086             STR      R6,[R0, #+8]
    741              }
    742          
    743              tempS32 = (((signed long int)parmPtr->Ki * (signed long int)parmPtr->err) << (parmPtr->Fmt.PropSum - parmPtr->Fmt.Ki - parmPtr->Fmt.In)) + parmPtr->sum;
   \   0000005A   0x6946             LDR      R6,[R0, #+20]
   \   0000005C   0x4371             MULS     R1,R1,R6
   \   0000005E   0xF890 0x6037      LDRB     R6,[R0, #+55]
   \   00000062   0x1B9B             SUBS     R3,R3,R6
   \   00000064   0x1A9A             SUBS     R2,R3,R2
   \   00000066   0x4091             LSLS     R1,R1,R2
   \   00000068   0x6802             LDR      R2,[R0, #+0]
   \   0000006A   0x1851             ADDS     R1,R2,R1
    744          
    745              if (tempS32 >= parmPtr->int_uplim)
   \   0000006C   0x6882             LDR      R2,[R0, #+8]
   \   0000006E   0x4291             CMP      R1,R2
   \   00000070   0xBFBE             ITTT     LT 
    746              {
    747                  parmPtr->sum = parmPtr->int_uplim;
    748              }
    749              else if (tempS32 <= parmPtr->int_lowlim)
   \   00000072   0x68C2             LDRLT    R2,[R0, #+12]
   \   00000074   0x428A             CMPLT    R2,R1
   \   00000076   0x460A             MOVLT    R2,R1
    750              {
    751                  parmPtr->sum = parmPtr->int_lowlim;
    752              }
    753              else
    754              {
    755                  parmPtr->sum = tempS32;
    756              }
    757              parmPtr->out = (signed long int)((parmPtr->sum + parmPtr->prop) >> (parmPtr->Fmt.PropSum - parmPtr->Fmt.Out));
   \   00000078   0x18A9             ADDS     R1,R5,R2
   \   0000007A   0x6002             STR      R2,[R0, #+0]
   \   0000007C   0x4121             ASRS     R1,R1,R4
   \   0000007E   0x6301             STR      R1,[R0, #+48]
    758          }
   \   00000080   0xBCF0             POP      {R4-R7}
   \   00000082   0x4770             BX       LR               ;; return
    759          
    760          
    761          
    762          

   \                                 In section .text, align 2, keep-with-next
    763          void Pi__InitPiQ30( TPiParmQ30 *parmPtr )
    764          {
    765              parmPtr->sum = 0;
   \                     Pi__InitPiQ30: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    766              parmPtr->out = 0;
   \   00000004   0x6301             STR      R1,[R0, #+48]
    767          }   /* end of InitPi() */
   \   00000006   0x4770             BX       LR               ;; return
    768          
    769          
    770          
    771          //---------------------------------------------------------------------------------------------------------------------
    772          /**
    773           *  @brief      Calculate pi control value, internal variable is Q30 format.
    774           *
    775           *  @param      Kp, Ki, outMax, outMin, inRef, inMeas
    776           *  @return     out
    777           */

   \                                 In section .text, align 2, keep-with-next
    778          void Pi__CalcPiQ30_new(TPiParmQ30 *parmPtr)
    779          {
   \                     Pi__CalcPiQ30_new: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4606             MOV      R6,R0
    780              sint32 tempS32;
    781          
    782              parmPtr->err = parmPtr->inRef - parmPtr->inMeas;
   \   00000006   0x6AB0             LDR      R0,[R6, #+40]
   \   00000008   0x6AF1             LDR      R1,[R6, #+44]
   \   0000000A   0x1A44             SUBS     R4,R0,R1
   \   0000000C   0x61B4             STR      R4,[R6, #+24]
    783          
    784              parmPtr->prop = ((signed long long int)parmPtr->Kp * (signed long long int)parmPtr->err) << (parmPtr->Fmt.PropSum - parmPtr->Fmt.Kp - parmPtr->Fmt.In); // proportional term
   \   0000000E   0xEA4F 0x78E4      ASR      R8,R4,#+31
   \   00000012   0x6932             LDR      R2,[R6, #+16]
   \   00000014   0x17D3             ASRS     R3,R2,#+31
   \   00000016   0xFBA4 0x0102      UMULL    R0,R1,R4,R2
   \   0000001A   0xFB04 0x1103      MLA      R1,R4,R3,R1
   \   0000001E   0xFB08 0x1102      MLA      R1,R8,R2,R1
   \   00000022   0xF896 0x5038      LDRB     R5,[R6, #+56]
   \   00000026   0xF896 0x2036      LDRB     R2,[R6, #+54]
   \   0000002A   0xF896 0x7034      LDRB     R7,[R6, #+52]
   \   0000002E   0x1AAA             SUBS     R2,R5,R2
   \   00000030   0x1BD2             SUBS     R2,R2,R7
   \   00000032   0x.... 0x....      BL       __aeabi_llsl
   \   00000036   0x6070             STR      R0,[R6, #+4]
    785          
    786              tempS32 = ((signed long long int)parmPtr->Ki * (signed long long int)parmPtr->err) << (parmPtr->Fmt.PropSum - parmPtr->Fmt.Ki - parmPtr->Fmt.In); // new integrated error
   \   00000038   0x6972             LDR      R2,[R6, #+20]
   \   0000003A   0x17D3             ASRS     R3,R2,#+31
   \   0000003C   0xFBA4 0x0102      UMULL    R0,R1,R4,R2
   \   00000040   0xFB04 0x1103      MLA      R1,R4,R3,R1
   \   00000044   0xFB08 0x1102      MLA      R1,R8,R2,R1
   \   00000048   0xF896 0x2037      LDRB     R2,[R6, #+55]
   \   0000004C   0x1AAA             SUBS     R2,R5,R2
   \   0000004E   0x1BD2             SUBS     R2,R2,R7
   \   00000050   0x.... 0x....      BL       __aeabi_llsl
    787          
    788              parmPtr->out = (signed long int)((parmPtr->sum + tempS32 + parmPtr->prop) >> (parmPtr->Fmt.PropSum - parmPtr->Fmt.Out));
   \   00000054   0x6831             LDR      R1,[R6, #+0]
   \   00000056   0x6872             LDR      R2,[R6, #+4]
   \   00000058   0x1841             ADDS     R1,R0,R1
   \   0000005A   0x1851             ADDS     R1,R2,R1
   \   0000005C   0xF896 0x2035      LDRB     R2,[R6, #+53]
   \   00000060   0x1AAA             SUBS     R2,R5,R2
   \   00000062   0x4111             ASRS     R1,R1,R2
    789          
    790              if(parmPtr->out >= parmPtr->outMax)   // Saturation on the positive limit
   \   00000064   0x6A32             LDR      R2,[R6, #+32]
   \   00000066   0x4291             CMP      R1,R2
   \   00000068   0xDB03             BLT.N    ??Pi__CalcPiQ30_new_0
    791              {
    792                  parmPtr->out = parmPtr->outMax;         // Limit the output
   \   0000006A   0x4611             MOV      R1,R2
    793                  tempS32 = (tempS32 > 0) ? 0 : tempS32;  // Do not allow increase of the sum (antiwindup)
   \   0000006C   0x2801             CMP      R0,#+1
   \   0000006E   0xDB07             BLT.N    ??Pi__CalcPiQ30_new_1
   \   00000070   0xE005             B.N      ??Pi__CalcPiQ30_new_2
    794              }
    795              else if(parmPtr->out <= parmPtr->outMin)
   \                     ??Pi__CalcPiQ30_new_0: (+1)
   \   00000072   0x6A72             LDR      R2,[R6, #+36]
   \   00000074   0x428A             CMP      R2,R1
   \   00000076   0xDB03             BLT.N    ??Pi__CalcPiQ30_new_1
    796              {
    797                  parmPtr->out = parmPtr->outMin;              // Limit the output
   \   00000078   0x4611             MOV      R1,R2
    798                  tempS32 = (tempS32 < 0) ? 0 : tempS32;  // Do not allow decrease of the sum (antiwindup)
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD500             BPL.N    ??Pi__CalcPiQ30_new_1
   \                     ??Pi__CalcPiQ30_new_2: (+1)
   \   0000007E   0x2000             MOVS     R0,#+0
   \                     ??Pi__CalcPiQ30_new_1: (+1)
   \   00000080   0x6331             STR      R1,[R6, #+48]
    799              }
    800          
    801              parmPtr->sum += tempS32;
   \   00000082   0x6831             LDR      R1,[R6, #+0]
   \   00000084   0x1840             ADDS     R0,R0,R1
   \   00000086   0x6030             STR      R0,[R6, #+0]
    802          }
   \   00000088   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    803          
    804          
    805          //---------------------------------------------------------------------------------------------------------------------
    806          /**
    807           *  @brief      Calculate pi control value, internal variable is Q60 format.
    808           *
    809           *  @param      Kp, Ki, outMax, outMin, inRef, inMeas
    810           *  @return     out
    811           */

   \                                 In section .text, align 2, keep-with-next
    812          void Pi__CalcPiQ60_new(TPiParmQ60 *parmPtr)
    813          {
   \                     Pi__CalcPiQ60_new: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
    814              signed long long int tempS64;
    815          
    816              parmPtr->err = parmPtr->inRef - parmPtr->inMeas;
   \   00000006   0x6BA0             LDR      R0,[R4, #+56]
   \   00000008   0x6BE1             LDR      R1,[R4, #+60]
   \   0000000A   0x1A46             SUBS     R6,R0,R1
   \   0000000C   0x62A6             STR      R6,[R4, #+40]
    817          
    818              parmPtr->prop = ((signed long long int)parmPtr->Kp * (signed long long int)parmPtr->err) << (parmPtr->Fmt.PropSum - parmPtr->Fmt.Kp - parmPtr->Fmt.In); // proportional term
   \   0000000E   0x17F7             ASRS     R7,R6,#+31
   \   00000010   0x6A22             LDR      R2,[R4, #+32]
   \   00000012   0x17D3             ASRS     R3,R2,#+31
   \   00000014   0xFBA6 0x0102      UMULL    R0,R1,R6,R2
   \   00000018   0xFB06 0x1103      MLA      R1,R6,R3,R1
   \   0000001C   0xFB07 0x1102      MLA      R1,R7,R2,R1
   \   00000020   0xF894 0x5048      LDRB     R5,[R4, #+72]
   \   00000024   0xF894 0x2046      LDRB     R2,[R4, #+70]
   \   00000028   0xF894 0xA044      LDRB     R10,[R4, #+68]
   \   0000002C   0x1AAA             SUBS     R2,R5,R2
   \   0000002E   0xEBA2 0x020A      SUB      R2,R2,R10
   \   00000032   0x.... 0x....      BL       __aeabi_llsl
   \   00000036   0x4680             MOV      R8,R0
   \   00000038   0x4689             MOV      R9,R1
   \   0000003A   0xE9C4 0x8902      STRD     R8,R9,[R4, #+8]
    819          
    820              tempS64 = ((signed long long int)parmPtr->Ki * (signed long long int)parmPtr->err) << (parmPtr->Fmt.PropSum - parmPtr->Fmt.Ki - parmPtr->Fmt.In); // new integrated error
   \   0000003E   0x6A62             LDR      R2,[R4, #+36]
   \   00000040   0x17D3             ASRS     R3,R2,#+31
   \   00000042   0xFBA6 0x0102      UMULL    R0,R1,R6,R2
   \   00000046   0xFB06 0x1103      MLA      R1,R6,R3,R1
   \   0000004A   0xFB07 0x1102      MLA      R1,R7,R2,R1
   \   0000004E   0xF894 0x2047      LDRB     R2,[R4, #+71]
   \   00000052   0x1AAA             SUBS     R2,R5,R2
   \   00000054   0xEBA2 0x020A      SUB      R2,R2,R10
   \   00000058   0x.... 0x....      BL       __aeabi_llsl
   \   0000005C   0x4606             MOV      R6,R0
   \   0000005E   0x460F             MOV      R7,R1
    821          
    822              parmPtr->out = (signed long int)((parmPtr->sum + tempS64 + parmPtr->prop) >> (parmPtr->Fmt.PropSum - parmPtr->Fmt.Out));
   \   00000060   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \   00000064   0x1980             ADDS     R0,R0,R6
   \   00000066   0x4179             ADCS     R1,R1,R7
   \   00000068   0xEB10 0x0008      ADDS     R0,R0,R8
   \   0000006C   0xF894 0x2045      LDRB     R2,[R4, #+69]
   \   00000070   0xEB41 0x0109      ADC      R1,R1,R9
   \   00000074   0x1AAA             SUBS     R2,R5,R2
   \   00000076   0x.... 0x....      BL       __aeabi_lasr
    823          
    824              if(parmPtr->out >= parmPtr->outMax)   // Saturation on the positive limit
   \   0000007A   0x6B21             LDR      R1,[R4, #+48]
   \   0000007C   0x4288             CMP      R0,R1
   \   0000007E   0xDB06             BLT.N    ??Pi__CalcPiQ60_new_0
    825              {
    826                  parmPtr->out = parmPtr->outMax;         // Limit the output
   \   00000080   0x4608             MOV      R0,R1
    827                  tempS64 = (tempS64 > 0) ? 0 : tempS64;  // Do not allow increase of the sum (antiwindup)
   \   00000082   0x2F00             CMP      R7,#+0
   \   00000084   0xDB0B             BLT.N    ??Pi__CalcPiQ60_new_1
   \   00000086   0xDC08             BGT.N    ??Pi__CalcPiQ60_new_2
   \   00000088   0x2E01             CMP      R6,#+1
   \   0000008A   0xD308             BCC.N    ??Pi__CalcPiQ60_new_1
   \   0000008C   0xE005             B.N      ??Pi__CalcPiQ60_new_2
    828              }
    829              else if(parmPtr->out <= parmPtr->outMin)
   \                     ??Pi__CalcPiQ60_new_0: (+1)
   \   0000008E   0x6B61             LDR      R1,[R4, #+52]
   \   00000090   0x4281             CMP      R1,R0
   \   00000092   0xDB04             BLT.N    ??Pi__CalcPiQ60_new_1
    830              {
    831                  parmPtr->out = parmPtr->outMin;              // Limit the output
   \   00000094   0x4608             MOV      R0,R1
    832                  tempS64 = (tempS64 < 0) ? 0 : tempS64;  // Do not allow decrease of the sum (antiwindup)
   \   00000096   0x2F00             CMP      R7,#+0
   \   00000098   0xDA01             BGE.N    ??Pi__CalcPiQ60_new_1
   \                     ??Pi__CalcPiQ60_new_2: (+1)
   \   0000009A   0x2600             MOVS     R6,#+0
   \   0000009C   0x2700             MOVS     R7,#+0
   \                     ??Pi__CalcPiQ60_new_1: (+1)
   \   0000009E   0x6420             STR      R0,[R4, #+64]
    833              }
    834          
    835              parmPtr->sum += tempS64;
   \   000000A0   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \   000000A4   0x1980             ADDS     R0,R0,R6
   \   000000A6   0x4179             ADCS     R1,R1,R7
   \   000000A8   0xE9C4 0x0100      STRD     R0,R1,[R4, #+0]
    836          }
   \   000000AC   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    837          
    838          

   \                                 In section .text, align 4, keep-with-next
    839          void Pi__CalcPiF(PI_CONTROLLER_F_TYPE *param)
    840          {
    841              float32 prop_term;
    842              float32 integ_term;
    843              float32 out;
    844          
    845              // calculate proportional term
    846              prop_term = param->Kp * param->Err;
    847          
    848              // calculate integral term step k
    849              integ_term = param->Ki * param->Err;
   \                     Pi__CalcPiF: (+1)
   \   00000000   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000004   0xEDD0 0x0A04      VLDR     S1,[R0, #+16]
    850          
    851              // prepare the output for saturation
    852              out = prop_term + integ_term  + param->Integ_K_1;
   \   00000008   0xED90 0x1A03      VLDR     S2,[R0, #+12]
   \   0000000C   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000010   0xEEF0 0x1A60      VMOV.F32 S3,S1
   \   00000014   0xEE41 0x1A00      VMLA.F32 S3,S2,S0
   \   00000018   0xED90 0x0A01      VLDR     S0,[R0, #+4]
    853          
    854              // saturate and apply anti-windup to the state
    855              if (out > param->Upper_Limit)
   \   0000001C   0xED90 0x1A05      VLDR     S2,[R0, #+20]
   \   00000020   0xEE31 0x0A80      VADD.F32 S0,S3,S0
   \   00000024   0xEEB4 0x1A40      VCMP.F32 S2,S0
   \   00000028   0xEEF1 0xFA10      FMSTAT   
   \   0000002C   0xD507             BPL.N    ??Pi__CalcPiF_0
    856              {
    857                  param->Out = param->Upper_Limit;
    858                  if (integ_term > 0.0f)
   \   0000002E   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   00000032   0xEEB0 0x0A41      VMOV.F32 S0,S2
   \   00000036   0xEEF1 0xFA10      FMSTAT   
   \   0000003A   0xDD10             BLE.N    ??Pi__CalcPiF_1
    859                  {
    860                      integ_term = 0.0f;
   \   0000003C   0xE00D             B.N      ??Pi__CalcPiF_2
    861                  }
    862              }
    863              else if (out < param->Lower_Limit)
   \                     ??Pi__CalcPiF_0: (+1)
   \   0000003E   0xED90 0x1A06      VLDR     S2,[R0, #+24]
   \   00000042   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   00000046   0xEEF1 0xFA10      FMSTAT   
   \   0000004A   0xBF42             ITTT     MI 
    864              {
    865                  param->Out = param->Lower_Limit;
   \   0000004C   0xEEB0 0x0A41      VMOVMI.F32 S0,S2
    866                  if (integ_term<0.0f)
   \   00000050   0xEEF5 0x0A40      VCMPMI.F32 S1,#0.0
   \   00000054   0xEEF1 0xFA10      FMSTATMI 
   \   00000058   0xD501             BPL.N    ??Pi__CalcPiF_1
    867                  {
    868                      integ_term = 0.0f;
   \                     ??Pi__CalcPiF_2: (+1)
   \   0000005A   0xEDDF 0x....      VLDR.W   S1,??DataTable110  ;; 0x0
    869                  }
    870              }
    871              else
    872              {
    873                  param->Out = out;
   \                     ??Pi__CalcPiF_1: (+1)
   \   0000005E   0xED80 0x0A02      VSTR     S0,[R0, #+8]
    874              }
    875          
    876              param->Integ_K_1 += integ_term;
   \   00000062   0xED90 0x0A01      VLDR     S0,[R0, #+4]
   \   00000066   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   0000006A   0xED80 0x0A01      VSTR     S0,[R0, #+4]
    877          }
   \   0000006E   0x4770             BX       LR               ;; return
    878          
    879          

   \                                 In section .text, align 2, keep-with-next
    880          void Pi__CalcPiBackCalcF(PI_CONTROLLER_F_TYPE *param)
    881          {
    882              float32 prop_term;
    883              float32 integ_term;
    884              float32 tmp;
    885          
    886              prop_term = param->Kp * param->Err;
   \                     Pi__CalcPiBackCalcF: (+1)
   \   00000000   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000004   0xEDD0 0x0A03      VLDR     S1,[R0, #+12]
    887              // prop_term Saturation
    888              if (prop_term > param->Upper_Limit)
   \   00000008   0xED90 0x1A05      VLDR     S2,[R0, #+20]
   \   0000000C   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000010   0xEEB4 0x1A60      VCMP.F32 S2,S1
   \   00000014   0xEEF1 0xFA10      FMSTAT   
   \   00000018   0xBF48             IT       MI 
    889              {
    890                 prop_term = param->Upper_Limit;
   \   0000001A   0xEEF0 0x0A41      VMOVMI.F32 S1,S2
   \   0000001E   0xD408             BMI.N    ??Pi__CalcPiBackCalcF_0
    891              }
    892              else if (prop_term < param->Lower_Limit)
   \   00000020   0xEDD0 0x1A06      VLDR     S3,[R0, #+24]
   \   00000024   0xEEF4 0x0A61      VCMP.F32 S1,S3
   \   00000028   0xEEF1 0xFA10      FMSTAT   
   \   0000002C   0xBF48             IT       MI 
    893              {
    894                 prop_term = param->Lower_Limit;
   \   0000002E   0xEEF0 0x0A61      VMOVMI.F32 S1,S3
    895              }
    896          
    897              integ_term = param->Ki * param->Err;
    898              integ_term = integ_term + param->Integ_K_1;
   \                     ??Pi__CalcPiBackCalcF_0: (+1)
   \   00000032   0xEDD0 0x1A04      VLDR     S3,[R0, #+16]
   \   00000036   0xED90 0x2A01      VLDR     S4,[R0, #+4]
   \   0000003A   0xEE01 0x2A80      VMLA.F32 S4,S3,S0
    899              // output Saturation & state variable back-calculation anti-windup
    900              tmp = prop_term + integ_term;
   \   0000003E   0xEE30 0x0A82      VADD.F32 S0,S1,S4
    901          
    902              if (tmp > param->Upper_Limit)
   \   00000042   0xEEB4 0x1A40      VCMP.F32 S2,S0
   \   00000046   0xEEF1 0xFA10      FMSTAT   
   \   0000004A   0xD508             BPL.N    ??Pi__CalcPiBackCalcF_1
    903              {
    904                 tmp = param->Upper_Limit;
    905                 param->Integ_K_1 = param->Upper_Limit - prop_term;
   \   0000004C   0xEE31 0x2A60      VSUB.F32 S4,S2,S1
   \   00000050   0xEEB0 0x0A41      VMOV.F32 S0,S2
    906              }
    907              else if (tmp < param->Lower_Limit)
    908              {
    909                 tmp = param->Lower_Limit;
    910                 param->Integ_K_1 = param->Lower_Limit - prop_term;
    911              }
    912              else
    913              {
    914                  param->Integ_K_1 = integ_term;
   \   00000054   0xED80 0x2A01      VSTR     S4,[R0, #+4]
    915              }
    916          
    917              param->Out = tmp;
   \   00000058   0xED80 0x0A02      VSTR     S0,[R0, #+8]
    918          }
   \   0000005C   0x4770             BX       LR
   \                     ??Pi__CalcPiBackCalcF_1: (+1)
   \   0000005E   0xEDD0 0x1A06      VLDR     S3,[R0, #+24]
   \   00000062   0xEEB4 0x0A61      VCMP.F32 S0,S3
   \   00000066   0xEEF1 0xFA10      FMSTAT   
   \   0000006A   0xBF44             ITT      MI 
   \   0000006C   0xEEB0 0x0A61      VMOVMI.F32 S0,S3
   \   00000070   0xEE31 0x2AE0      VSUBMI.F32 S4,S3,S1
   \   00000074   0xED80 0x2A01      VSTR     S4,[R0, #+4]
   \   00000078   0xED80 0x0A02      VSTR     S0,[R0, #+8]
   \   0000007C   0x4770             BX       LR               ;; return
    919          
    920          

   \                                 In section .text, align 2, keep-with-next
    921          void Pi__PiRegNoAntiWindupF(PI_CONTROLLER_F_TYPE *param)
    922          {
    923              float32 prop_term;
    924              float32 integ_term;
    925              float32 out;
    926          
    927              // calculate proportional term
    928              prop_term = param->Kp * param->Err;
    929          
    930              // calculate integral term step k
    931              integ_term = param->Ki * param->Err + param->Integ_K_1;
   \                     Pi__PiRegNoAntiWindupF: (+1)
   \   00000000   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000004   0xED90 0x1A04      VLDR     S2,[R0, #+16]
   \   00000008   0xEDD0 0x0A01      VLDR     S1,[R0, #+4]
    932          
    933              // prepare the output for saturation
    934              out = prop_term + integ_term ;
   \   0000000C   0xEDD0 0x1A03      VLDR     S3,[R0, #+12]
   \   00000010   0xEE41 0x0A00      VMLA.F32 S1,S2,S0
   \   00000014   0xEEB0 0x1A60      VMOV.F32 S2,S1
   \   00000018   0xEE01 0x1A80      VMLA.F32 S2,S3,S0
    935          
    936              if (out > param->Upper_Limit)
   \   0000001C   0xED90 0x0A05      VLDR     S0,[R0, #+20]
   \   00000020   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   00000024   0xEEF1 0xFA10      FMSTAT   
   \   00000028   0xBF5D             ITTTE    PL 
    937              {
    938                  out = param->Upper_Limit;
    939              }
    940              else if (out < param->Lower_Limit)
   \   0000002A   0xED90 0x0A06      VLDRPL   S0,[R0, #+24]
   \   0000002E   0xEEB4 0x1A40      VCMPPL.F32 S2,S0
   \   00000032   0xEEF1 0xFA10      FMSTATPL 
    941              {
    942                  out = param->Lower_Limit;
   \   00000036   0xEEB0 0x1A40      VMOVMI.F32 S2,S0
    943              }
    944          
    945              param->Integ_K_1 = integ_term;
   \   0000003A   0xEDC0 0x0A01      VSTR     S1,[R0, #+4]
    946              param->Out = out;
   \   0000003E   0xED80 0x1A02      VSTR     S2,[R0, #+8]
    947          }
   \   00000042   0x4770             BX       LR               ;; return
C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\Mcl\MicroBlocks\PwmModulation\PwmModulation.c
      1          /**
      2           *  @file
      3           *  @brief       Space Vector Modulation Routines
      4           *  @details     This module calculates PWM duties to drive the inverter according
      5           *               to the voltage desired
      6           *  @author      alessio.beato/luigi.fagnano  (only temporary, since it is not integrated in MKS)
      7           *  $Header: FOC/PwmModulation.c 1.6 2016/02/02 17:26:49CET Luigi Fagnano (FAGNAL) Exp  $
      8           * @copyright Copyright 2012 - $Date: 2016/02/02 17:26:49CET $. Whirlpool Corporation. All rights reserved  CONFIDENTIAL
      9          */
     10          /*
     11           *
     12           *---------------------------------------------------------------------------------------------------------------------
     13           *---------------------------------------------------------------------------------------------------------------------
     14           */
     15          
     16          //-------------------------------------- Include Files ----------------------------------------------------------------
     17          #include "PwmModulation.h"
     18          #include "McMathCalc_macros.h"
     19          
     20          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     21          
     22          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     23          #ifndef SQRT3
     24              #define SQRT3   1.7320508075688772935274463415059f
     25          #endif
     26          
     27          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
     28          
     29          
     30          
     31          
     32          
     33          //---------------------------------------------------------------------------------------------------------------------
     34           /** @brief  Space vector modulation in rectangular coordinates
     35            *
     36            *
     37            *  @param[in]      v_alphabeta_in    = motor compensated voltage alpha-beta components
     38            *  @param[out]     v_abc_out         = PWM duties in abc components
     39            *  @param[in]      duty_cycle_limit  = duty cycle limitation
     40            *  @return         Sector number
     41            *
     42            */

   \                                 In section .text, align 2, keep-with-next
     43           uint8 PwmModulation__SpaceVectorModulationRectangular(mc_sint32 v_dc, ALPHA_BETA_COOR_SYST_TYPE* v_alphabeta_in, ABC_COOR_SYST_TYPE* v_abc_out)
     44           {
     45               static ALPHA_BETA_COOR_SYST_TYPE vs_alpha_beta_comp;
     46               uint8 sector = 0;
     47               mc_sint32 x;
     48               mc_sint32 y;
     49               mc_sint32 t1_on;
     50               mc_sint32 t2_on;
     51          
     52               // Ripple compensation
     53               vs_alpha_beta_comp.Alpha = MC_DIV(MC_SCALE(v_alphabeta_in->Alpha,IQ15,IQ30),v_dc, IQ30, IQ15, IQ15);
   \                     PwmModulation__SpaceVectorModulationRectangular: (+1)
   \   00000000   0x684B             LDR      R3,[R1, #+4]
   \   00000002   0x.... 0x....      LDR.W    R12,??DataTable119_9
   \   00000006   0x03DB             LSLS     R3,R3,#+15
   \   00000008   0xFB93 0xF3F0      SDIV     R3,R3,R0
   \   0000000C   0xF8CC 0x3004      STR      R3,[R12, #+4]
     54               vs_alpha_beta_comp.Beta  = MC_DIV(MC_SCALE(v_alphabeta_in->Beta ,IQ15,IQ30),v_dc, IQ30, IQ15, IQ15);
   \   00000010   0x6889             LDR      R1,[R1, #+8]
   \   00000012   0x03C9             LSLS     R1,R1,#+15
   \   00000014   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   00000018   0xF8CC 0x0008      STR      R0,[R12, #+8]
     55          
     56               // X and Y calculation
     57               x = MC_DIV_SH(vs_alpha_beta_comp.Beta, 1);
   \   0000001C   0x1041             ASRS     R1,R0,#+1
     58               y = MC_MULT(vs_alpha_beta_comp.Alpha, MC_SQRT3_OVER_TWO, IQ15, IQ15, IQ15);
   \   0000001E   0xF646 0x60DA      MOVW     R0,#+28378
   \   00000022   0x4358             MULS     R0,R0,R3
   \   00000024   0x13C3             ASRS     R3,R0,#+15
     59          
     60               // Sector identification
     61               if (x >= 0)
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD405             BMI.N    ??PwmModulation__SpaceVectorModulationRectangul_0
     62               {
     63                   if ((x + y) >= 0)
   \   0000002A   0xEB13 0x0C01      ADDS     R12,R3,R1
   \   0000002E   0xD40A             BMI.N    ??PwmModulation__SpaceVectorModulationRectangul_1
     64                   {
     65                       // sector I - II
     66                       sector = 1;
   \   00000030   0x2001             MOVS     R0,#+1
     67                       t1_on = x + y;
     68                       t2_on = x * 2;
   \   00000032   0x0049             LSLS     R1,R1,#+1
   \   00000034   0xE00C             B.N      ??PwmModulation__SpaceVectorModulationRectangul_2
     69                   }
     70                   else
     71                   {
     72                       // sector III - IV
     73                       sector = 2;
     74                       t1_on = x - y;
     75                       t2_on = - y - x;
     76                   }
     77               }
     78               else
     79               {
     80                   if (x < y)
   \                     ??PwmModulation__SpaceVectorModulationRectangul_0: (+1)
   \   00000036   0x4299             CMP      R1,R3
   \   00000038   0xDA05             BGE.N    ??PwmModulation__SpaceVectorModulationRectangul_1
     81                   {
     82                       // sector V - VI
     83                       sector = 3;
     84                       t1_on = y - x;
   \   0000003A   0xEBA3 0x0C01      SUB      R12,R3,R1
     85                       t2_on = -x * 2;
   \   0000003E   0x4249             RSBS     R1,R1,#+0
   \   00000040   0x2003             MOVS     R0,#+3
   \   00000042   0x0049             LSLS     R1,R1,#+1
   \   00000044   0xE004             B.N      ??PwmModulation__SpaceVectorModulationRectangul_2
     86                   }
     87                   else
     88                   {
     89                       // sector III - IV
     90                       sector = 2;
     91                       t1_on = x - y;
   \                     ??PwmModulation__SpaceVectorModulationRectangul_1: (+1)
   \   00000046   0xEBA1 0x0C03      SUB      R12,R1,R3
     92                       t2_on = - y - x;
   \   0000004A   0x425B             RSBS     R3,R3,#+0
   \   0000004C   0x2002             MOVS     R0,#+2
   \   0000004E   0x1A59             SUBS     R1,R3,R1
     93                   }
     94               }
     95          
     96               // Over-modulation
     97               if (t1_on > t2_on)
   \                     ??PwmModulation__SpaceVectorModulationRectangul_2: (+1)
   \   00000050   0xF248 0x0301      MOVW     R3,#+32769
   \   00000054   0x4561             CMP      R1,R12
   \   00000056   0xDA0D             BGE.N    ??PwmModulation__SpaceVectorModulationRectangul_3
     98               {
     99                   if (t1_on > OVERMODULATION_THR)
   \   00000058   0x459C             CMP      R12,R3
   \   0000005A   0xDB04             BLT.N    ??PwmModulation__SpaceVectorModulationRectangul_4
    100                   {
    101                        t2_on = MC_SCALE(t2_on, IQ15, IQ30) / (t1_on);
   \   0000005C   0x03C9             LSLS     R1,R1,#+15
   \   0000005E   0xFB91 0xF1FC      SDIV     R1,R1,R12
    102                        t1_on = OVERMODULATION_THR;
   \   00000062   0xF44F 0x4C00      MOV      R12,#+32768
    103                   }
    104          #if (PWM_DUTY_LIMITATION == ENABLED)
    105                   if (t2_on > DUTY_LIMIT_MID)
   \                     ??PwmModulation__SpaceVectorModulationRectangul_4: (+1)
   \   00000066   0xF247 0x53C4      MOVW     R3,#+30148
   \   0000006A   0x4299             CMP      R1,R3
   \   0000006C   0xDB10             BLT.N    ??PwmModulation__SpaceVectorModulationRectangul_5
    106                   {
    107                     t2_on = DUTY_LIMIT_MID;
   \   0000006E   0xF247 0x51C3      MOVW     R1,#+30147
   \   00000072   0xE00D             B.N      ??PwmModulation__SpaceVectorModulationRectangul_5
    108                   }
    109                  #if (PWM_DUTY_BOOTSTRAP_LIMITATION == ENABLED)
    110                   if (t1_on > DUTY_LIMIT_MID)
    111                   {
    112                     t1_on = DUTY_LIMIT_MID;
    113                   }
    114                  #endif
    115          #endif
    116               }
    117               else
    118               {
    119                   if (t2_on > OVERMODULATION_THR)
   \                     ??PwmModulation__SpaceVectorModulationRectangul_3: (+1)
   \   00000074   0x4299             CMP      R1,R3
   \   00000076   0xDB05             BLT.N    ??PwmModulation__SpaceVectorModulationRectangul_6
    120                   {
    121                        t1_on = MC_SCALE(t1_on, IQ15, IQ30) / (t2_on);
   \   00000078   0xEA4F 0x33CC      LSL      R3,R12,#+15
   \   0000007C   0xFB93 0xFCF1      SDIV     R12,R3,R1
    122                        t2_on = OVERMODULATION_THR;
   \   00000080   0xF44F 0x4100      MOV      R1,#+32768
    123                   }
    124          #if (PWM_DUTY_LIMITATION == ENABLED)
    125                   if (t1_on > DUTY_LIMIT_MID)
   \                     ??PwmModulation__SpaceVectorModulationRectangul_6: (+1)
   \   00000084   0xF247 0x53C4      MOVW     R3,#+30148
   \   00000088   0x459C             CMP      R12,R3
   \   0000008A   0xBFA8             IT       GE 
    126                   {
    127                     t1_on = DUTY_LIMIT_MID;
   \   0000008C   0xF247 0x5CC3      MOVWGE   R12,#+30147
    128                   }
    129                   #if (PWM_DUTY_BOOTSTRAP_LIMITATION == ENABLED)
    130                   if (t2_on > DUTY_LIMIT_MID)
    131                   {
    132                     t2_on = DUTY_LIMIT_MID;
    133                   }
    134                  #endif
    135          #endif
    136               }
    137          
    138               switch(sector)
   \                     ??PwmModulation__SpaceVectorModulationRectangul_5: (+1)
   \   00000090   0x2801             CMP      R0,#+1
   \   00000092   0xD004             BEQ.N    ??PwmModulation__SpaceVectorModulationRectangul_7
   \   00000094   0xD319             BCC.N    ??PwmModulation__SpaceVectorModulationRectangul_8
   \   00000096   0x2803             CMP      R0,#+3
   \   00000098   0xD00F             BEQ.N    ??PwmModulation__SpaceVectorModulationRectangul_9
   \   0000009A   0xD308             BCC.N    ??PwmModulation__SpaceVectorModulationRectangul_10
   \   0000009C   0xE015             B.N      ??PwmModulation__SpaceVectorModulationRectangul_8
    139               {
    140                   case 1:
    141                   {
    142                       // Sectors I - II
    143                       v_abc_out->A = t1_on;
   \                     ??PwmModulation__SpaceVectorModulationRectangul_7: (+1)
   \   0000009E   0x4663             MOV      R3,R12
    144                       v_abc_out->B = t2_on;
   \   000000A0   0x468C             MOV      R12,R1
    145                       v_abc_out->C = 0;
   \   000000A2   0x2100             MOVS     R1,#+0
    146                       break;
    147                   }
    148                   case 2:
    149                   {
    150                       // Sectors III - IV
    151                       v_abc_out->A = 0;
    152                       v_abc_out->B = t1_on;
    153                       v_abc_out->C = t2_on;
    154                       break;
    155                   }
    156                   case 3:
    157                   {
    158                       // Sectors V - VI
    159                       v_abc_out->A = t1_on;
    160                       v_abc_out->B = 0;
    161                       v_abc_out->C = t2_on;
    162                       break;
    163                   }
    164                   default:
    165                   {
    166                       v_abc_out->A = 0;
    167                       v_abc_out->B = 0;
    168                       v_abc_out->C = 0;
    169                       break;
   \   000000A4   0x6091             STR      R1,[R2, #+8]
   \   000000A6   0xF8C2 0xC004      STR      R12,[R2, #+4]
   \   000000AA   0x6013             STR      R3,[R2, #+0]
    170                   }
    171               }
    172          
    173               return sector;
   \   000000AC   0x4770             BX       LR
   \                     ??PwmModulation__SpaceVectorModulationRectangul_10: (+1)
   \   000000AE   0x6091             STR      R1,[R2, #+8]
   \   000000B0   0x2300             MOVS     R3,#+0
   \   000000B2   0xF8C2 0xC004      STR      R12,[R2, #+4]
   \   000000B6   0x6013             STR      R3,[R2, #+0]
   \   000000B8   0x4770             BX       LR
   \                     ??PwmModulation__SpaceVectorModulationRectangul_9: (+1)
   \   000000BA   0x4663             MOV      R3,R12
   \   000000BC   0xF04F 0x0C00      MOV      R12,#+0
   \   000000C0   0x6091             STR      R1,[R2, #+8]
   \   000000C2   0xF8C2 0xC004      STR      R12,[R2, #+4]
   \   000000C6   0x6013             STR      R3,[R2, #+0]
   \   000000C8   0x4770             BX       LR
   \                     ??PwmModulation__SpaceVectorModulationRectangul_8: (+1)
   \   000000CA   0x2300             MOVS     R3,#+0
   \   000000CC   0x2100             MOVS     R1,#+0
   \   000000CE   0x469C             MOV      R12,R3
   \   000000D0   0x6091             STR      R1,[R2, #+8]
   \   000000D2   0xF8C2 0xC004      STR      R12,[R2, #+4]
   \   000000D6   0x6013             STR      R3,[R2, #+0]
   \   000000D8   0x4770             BX       LR               ;; return
    174           }

   \                                 In section .bss, align 4
   \                     ??vs_alpha_beta_comp:
   \   00000000                      DS8 12
    175          
    176          
    177          /**
    178           *  @brief      Space vector modulation (improved version, including not saturated ripple compensation and limitations).
    179           *  @details
    180           *
    181           * This function calculates the space vector modulation of the alpha/beta input
    182           * into the a,b,c output. The calculation is the following:
    183           *
    184           *
    185           * Ripple compensation function equations.
    186           *
    187           *  Implemented equations:
    188           *   \f[
    189           *      \begin{aligned}
    190           *         & V_{\alpha-comp}' = \frac{V_{\alpha}'}{V_{dc}'} = \frac{V_{\alpha}}{V_{dc}}\cdot\sqrt{3} \\
    191           *         & V_{\beta-comp}' = \frac{V_{\beta}'}{V_{dc}'} = \frac{V_{\beta}}{V_{dc}}\cdot\sqrt{3} \\
    192           *      \end{aligned}
    193           *    \f]
    194           *
    195           * where
    196           *
    197           * \f$ V_{dc}' \f$: DC bus voltage in Q17.15 notation
    198           *
    199           * \f$ V_{dc} \f$: DC bus voltage [physical value]
    200           *
    201           * \f$ V_{\alpha}' \f$: motor voltage reference on Alpha-axis in Q17.15 notation
    202           *
    203           * \f$ V_{\beta}' \f$: motor voltage reference on Beta-axis in Q17.15 notation
    204           *
    205           * \f$ V_{\alpha} \f$: motor voltage reference on Alpha-axis [physical value]
    206           *
    207           * \f$ V_{\beta} \f$: motor voltage reference on Beta-axis [physical value]
    208           *
    209           * \f$ V_{\alpha-comp}' \f$: motor voltage reference compensated on Alpha-axis in Q17.15 notation
    210           *
    211           * \f$ V_{\beta-comp}' \f$: motor voltage reference compensated on Beta-axis in Q17.15 notation
    212           *
    213           *
    214           * The algorithm is scaled into the fractional arithmetic
    215           * There are two different scaling ranges:
    216           *   - one for DC Bus voltage           ->    BASE_BUS_VOLTAGE
    217           *   - second for motor phase voltage   ->    BASE_VOLTAGE
    218           *
    219           * Relation between two scales mentioned above is the following:
    220           *
    221           * BASE_VOLTAGE = BASE_BUS_VOLTAGE / sqrt(3)
    222           *
    223           *
    224           *  Space Vector Modulation Algorithm
    225           *
    226           *  <b>1 - X, Y, Z calculation:</b>
    227           *
    228           *   Original requirement for X, Y, Z:
    229           *
    230           *   \f[
    231           *      \begin{aligned}
    232           *
    233           *          & X = \sqrt{3} \cdot \frac{V_{\beta}}{V_{dc}}\\
    234           *          & Y = \frac{\sqrt{3}}{2}\cdot\frac{(\sqrt{3} \cdot V_{\alpha} + V_{\beta})}{V_{dc}}\\
    235           *          & Z = \frac{\sqrt{3}}{2}\cdot\frac{(-\sqrt{3} \cdot V_{\alpha} + V_{\beta})}{V_{dc}}\\
    236           *      \end{aligned}
    237           *    \f]
    238           *
    239           *   The Sqrt(3) is not used in the calculation because the compensated voltages are used.
    240           *   So the modified equation used for X, Y, Z are:
    241           *
    242           *   \f[
    243           *      \begin{aligned}
    244           *          & X = V_{\beta-comp}\\
    245           *          & Y = \frac{\sqrt{3}}{2}\cdot V_{\alpha-comp} + \frac{1}{2}\cdot V_{\beta-comp}\\
    246           *          & Z = \frac{-\sqrt{3}}{2}\cdot V_{\alpha-comp} + \frac{1}{2}\cdot V_{\beta-comp}\\
    247           *      \end{aligned}
    248           *    \f]
    249           *  \n
    250           *
    251           *  <b>2 - SECTOR IDENTIFICATION:</b>
    252           *
    253           *   Sector 1: X >= 0 and Y > 0 and Z <= 0 \n
    254           *   Sector 2: X >= 0 and Y > 0 and Z > 0 \n
    255           *   Sector 3: X >= 0 and Y <= 0 and Z > 0 \n
    256           *   Sector 4: X < 0 and Z > 0 \n
    257           *   Sector 5: X < 0 and Y <= 0 and Z <= 0 \n
    258           *   Sector 6: X < 0 and Y > 0 and Z <= 0 \n
    259           *   Sector 7: X >= 0 and Y <=0 and Z <=0 => Sector 6 \n \n
    260           *
    261           *
    262           *  <b>3 - T1, T2 calculation:</b>
    263           *
    264           *   Sector 1: T1 = X, T2 = -Z \n
    265           *   Sector 2: T1 = Y, T2 = Z \n
    266           *   Sector 3: T1 = -Y, T2 = X \n
    267           *   Sector 4: T1 = Z, T2 = -X \n
    268           *   Sector 5: T1 = -Z, T2 = -Y \n
    269           *   Sector 6: T1 = -X, T2 = Y \n \n
    270           *
    271           *
    272           *
    273           *  <b>4 - T1, T2 Limitation:</b>
    274           *
    275           *   \f[
    276           *      \begin{aligned}
    277           *         &if \quad T1 + T2 >= 1  \quad then  \quad T1=\frac{T1}{(T1 + T2)}  \quad and \quad T2=\frac{T2}{(T1 + T2)}
    278           *      \end{aligned}
    279           *    \f]
    280           *
    281           *  <b>5 - Duty cycles T0_on, T1_on and T2_on calculation:</b>
    282           *
    283           *   Original equations are:
    284           *
    285           *   \f[
    286           *      \begin{aligned}
    287           *         &T0_{on} =\frac{1-T1-T2}{2}=\frac{1}{2} -\frac{T1+T2}{2}\\
    288           *         &T1_{on} =T0_{on}+T1 = \frac{1}{2} +\frac{T1-T2}{2}\\
    289           *         &T2_{on} =T1_{on}+T2 = \frac{1}{2} +\frac{T1+T2}{2}\\
    290           *      \end{aligned}
    291           *    \f]
    292           *
    293           *   As As mentioned in (1) the X, Y, Z equations are not multiplied by Sqrt(3) therefore
    294           *   the equations must be modified like this:
    295           *
    296           *   \f[
    297           *      \begin{aligned}
    298           *         &T0_{on} =\frac{1}{2} -\frac{\sqrt{3}}{2}\cdot(T1 + T2)\\
    299           *         &T1_{on} =\frac{1}{2} +\frac{\sqrt{3}}{2}\cdot(T1 - T2)\\
    300           *         &T2_{on} =\frac{1}{2} +\frac{\sqrt{3}}{2}\cdot(T1 + T2)\\
    301           *      \end{aligned}
    302           *    \f]
    303           *
    304           *   \n
    305           *
    306           *  <b>6 - Saturation:</b>
    307           *
    308           *   To avoid extremly small duty cycle (thanks to current measurement) it is necessary
    309           *   to assure the T1_on and T2_on values to be greater than the minimum value.
    310           *
    311           *   if T1_on < MIN_DUTY_CYCLE then T1_on = MIN_DUTY_CYCLE \n
    312           *   if T2_on < MIN_DUTY_CYCLE then T2_on = MIN_DUTY_CYCLE \n
    313           *
    314           *   \n
    315           *
    316           *  <b>7 - a, b, c assignment:</b>
    317           *
    318           *   Sector 1: PhaseA = T2_on, PhaseB = T1_on, PhaseC = T0_on \n
    319           *   Sector 2: PhaseA = T1_on, PhaseB = T2_on, PhaseC = T0_on \n
    320           *   Sector 3: PhaseA = T0_on, PhaseB = T2_on, PhaseC = T1_on \n
    321           *   Sector 4: PhaseA = T0_on, PhaseB = T1_on, PhaseC = T2_on \n
    322           *   Sector 5: PhaseA = T1_on, PhaseB = T0_on, PhaseC = T2_on \n
    323           *   Sector 6: PhaseA = T2_on, PhaseB = T0_on, PhaseC = T1_on \n
    324           *
    325           *   \n
    326           *
    327           *
    328           *  @param[in]      v_dc              = DC bus voltage in Q17.15 notation
    329           *  @param[in]      v_alphabeta_in    = motor compensated voltage alpha-beta components
    330           *  @param[out]     v_abc_out         = PWM duties in abc components
    331           *  @param[in]      duty_cycle_limit  = duty cycle limitation
    332           *  @return         sector_3rd_current = current to be reconstructed
    333           */

   \                                 In section .text, align 4, keep-with-next
    334           uint8 PwmModulation__SpaceVectorModulation_v2(mc_sint32 v_dc, ALPHA_BETA_COOR_SYST_TYPE* v_alphabeta_in, ABC_COOR_SYST_TYPE* v_abc_out)
    335          {
   \                     PwmModulation__SpaceVectorModulation_v2: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    336              uint8   sector = 0;
    337              ALPHA_BETA_COOR_SYST_TYPE     Vs_Alpha_Beta_Comp;
    338          
    339              mc_sint32 x;
    340              mc_sint32 y;
    341              mc_sint32 z;
    342              mc_sint32 t1;
    343              mc_sint32 t2;
    344              mc_sint32 tsum;
    345              mc_sint32 t0_on;
    346              mc_sint32 t1_on;
    347              mc_sint32 t2_on;
    348          
    349              /* Ripple compensation */
    350              Vs_Alpha_Beta_Comp.Alpha = MC_DIV(MC_SCALE(v_alphabeta_in->Alpha,IQ15,IQ30),v_dc, IQ30, IQ15, IQ15);
   \   00000002   0x684B             LDR      R3,[R1, #+4]
    351              Vs_Alpha_Beta_Comp.Beta  = MC_DIV(MC_SCALE(v_alphabeta_in->Beta ,IQ15,IQ30),v_dc, IQ30, IQ15, IQ15);
   \   00000004   0x6889             LDR      R1,[R1, #+8]
   \   00000006   0x03DB             LSLS     R3,R3,#+15
   \   00000008   0x03C9             LSLS     R1,R1,#+15
   \   0000000A   0xFB93 0xF3F0      SDIV     R3,R3,R0
   \   0000000E   0xFB91 0xF1F0      SDIV     R1,R1,R0
    352          
    353          
    354              /* X, Y, Z calculation */
    355              /*
    356                  X =  beta
    357                  Y = (alpha * sqrt(3) / 2 + beta / 2)
    358                  Z = (-alpha * sqrt(3) / 2 + beta / 2)
    359              */
    360              x = Vs_Alpha_Beta_Comp.Beta;
    361          
    362              //y = IQMATH__IQSCALE((Vs_Alpha_Beta_Comp->Alpha * MC_SQRT3_OVER_TWO  + IQMATH__SHR((IQMATH__IQSCALE_UP(Vs_Alpha_Beta_Comp->Beta,IQ15)),1)),IQ15);
    363              y = Vs_Alpha_Beta_Comp.Alpha * MC_SQRT3_OVER_TWO;
    364              y = y + MC_DIV_SH(MC_SCALE(Vs_Alpha_Beta_Comp.Beta,IQ15,IQ30),1);
    365              y = MC_SCALE(y,IQ30,IQ15);
   \   00000012   0x03C8             LSLS     R0,R1,#+15
   \   00000014   0x1040             ASRS     R0,R0,#+1
   \   00000016   0xF646 0x64DA      MOVW     R4,#+28378
   \   0000001A   0xFB04 0x0403      MLA      R4,R4,R3,R0
    366          
    367              //z = IQMATH__IQSCALE((-Vs_Alpha_Beta_Comp->Alpha * MC_SQRT3_OVER_TWO + IQMATH__SHR((IQMATH__IQSCALE_UP(Vs_Alpha_Beta_Comp->Beta, IQ15)),1)),IQ15);
    368              z = -Vs_Alpha_Beta_Comp.Alpha * MC_SQRT3_OVER_TWO;
    369              z = z + MC_DIV_SH(MC_SCALE(Vs_Alpha_Beta_Comp.Beta,IQ15,IQ30),1);
    370              z = MC_SCALE(z,IQ30,IQ15);
   \   0000001E   0x.... 0x....      LDR.W    R5,??DataTable121  ;; 0xffff9126
   \   00000022   0xFB05 0x0003      MLA      R0,R5,R3,R0
   \   00000026   0x13E4             ASRS     R4,R4,#+15
   \   00000028   0x13C3             ASRS     R3,R0,#+15
    371          
    372              // sector identification
    373              if (x>=0)
   \   0000002A   0x2900             CMP      R1,#+0
   \   0000002C   0xD410             BMI.N    ??PwmModulation__SpaceVectorModulation_v2_1
    374              {
    375                  // sector 1,2,3,7
    376                  if (y>0)
   \   0000002E   0x2C01             CMP      R4,#+1
   \   00000030   0xDB09             BLT.N    ??PwmModulation__SpaceVectorModulation_v2_2
    377                  {
    378                      // sector 1,2
    379                      if (z<=0)
   \   00000032   0x2B01             CMP      R3,#+1
   \   00000034   0xDA03             BGE.N    ??PwmModulation__SpaceVectorModulation_v2_3
    380                      {
    381                          // sector 1
    382                          sector = 1;
    383                          t1 = x;
   \   00000036   0x460D             MOV      R5,R1
   \   00000038   0x2001             MOVS     R0,#+1
    384                          t2 = -z;
   \   0000003A   0x4259             RSBS     R1,R3,#+0
   \   0000003C   0xE017             B.N      ??PwmModulation__SpaceVectorModulation_v2_4
    385                      }
    386                      else
    387                      {
    388                          // sector 2
    389                          sector = 2;
   \                     ??PwmModulation__SpaceVectorModulation_v2_3: (+1)
   \   0000003E   0x2002             MOVS     R0,#+2
    390                          t1 = y;
   \   00000040   0x4625             MOV      R5,R4
    391                          t2 = z;
   \   00000042   0x4619             MOV      R1,R3
   \   00000044   0xE013             B.N      ??PwmModulation__SpaceVectorModulation_v2_4
    392                      }
    393                  }
    394                  else
    395                  {
    396                      // sector 3,7
    397                      if (z>0)
   \                     ??PwmModulation__SpaceVectorModulation_v2_2: (+1)
   \   00000046   0x2B01             CMP      R3,#+1
   \   00000048   0xDB0A             BLT.N    ??PwmModulation__SpaceVectorModulation_v2_5
    398                      {
    399                          // sector 3
    400                          sector = 3;
   \   0000004A   0x2003             MOVS     R0,#+3
    401                          t1 = -y;
   \   0000004C   0x4265             RSBS     R5,R4,#+0
    402                          t2 = x;
   \   0000004E   0xE00E             B.N      ??PwmModulation__SpaceVectorModulation_v2_4
    403                      }
    404                      else
    405                      {
    406                          // sector 7 --> 6
    407                          sector = 6;
    408                          t1 = -x;
    409                          t2 = y;
    410                      }
    411                  }
    412              }
    413              else
    414              {
    415                  // sector 4,5,6
    416                  if (z>0)
   \                     ??PwmModulation__SpaceVectorModulation_v2_1: (+1)
   \   00000050   0x2B01             CMP      R3,#+1
   \   00000052   0xDB03             BLT.N    ??PwmModulation__SpaceVectorModulation_v2_6
    417                  {
    418                     // sector 4
    419                     sector = 4;
   \   00000054   0x2004             MOVS     R0,#+4
    420                     t1 = z;
   \   00000056   0x461D             MOV      R5,R3
    421                     t2 = -x;
   \   00000058   0x4249             RSBS     R1,R1,#+0
   \   0000005A   0xE008             B.N      ??PwmModulation__SpaceVectorModulation_v2_4
    422                  }
    423                  else
    424                  {
    425                      if (y>0)
   \                     ??PwmModulation__SpaceVectorModulation_v2_6: (+1)
   \   0000005C   0x2C01             CMP      R4,#+1
   \   0000005E   0xDB03             BLT.N    ??PwmModulation__SpaceVectorModulation_v2_7
    426                      {
    427                          // sector 6
    428                          sector = 6;
    429                          t1 = -x;
   \                     ??PwmModulation__SpaceVectorModulation_v2_5: (+1)
   \   00000060   0x424D             RSBS     R5,R1,#+0
   \   00000062   0x2006             MOVS     R0,#+6
    430                          t2 = y;
   \   00000064   0x4621             MOV      R1,R4
   \   00000066   0xE002             B.N      ??PwmModulation__SpaceVectorModulation_v2_4
    431                      }
    432                      else
    433                      {
    434                          // sector 5
    435                          sector = 5;
   \                     ??PwmModulation__SpaceVectorModulation_v2_7: (+1)
   \   00000068   0x2005             MOVS     R0,#+5
    436                          t1 = -z;
   \   0000006A   0x425D             RSBS     R5,R3,#+0
    437                          t2 = -y;
   \   0000006C   0x4261             RSBS     R1,R4,#+0
    438                      }
    439                  }
    440              }
    441          
    442          
    443              // Over-modulation
    444              tsum = t1+t2;
   \                     ??PwmModulation__SpaceVectorModulation_v2_4: (+1)
   \   0000006E   0x194B             ADDS     R3,R1,R5
    445              if (tsum>OVERMODULATION_THR)
   \   00000070   0xF5B3 0x4F00      CMP      R3,#+32768
   \   00000074   0xDD06             BLE.N    ??PwmModulation__SpaceVectorModulation_v2_8
    446              {
    447                  t1 = MC_SCALE(t1,IQ15,IQ30)/(tsum);
   \   00000076   0x03E9             LSLS     R1,R5,#+15
   \   00000078   0xFB91 0xF5F3      SDIV     R5,R1,R3
    448                  t2 = OVERMODULATION_THR - t1;
   \   0000007C   0xF5C5 0x4100      RSB      R1,R5,#+32768
    449                  // T0_on = 0.5 - 0.5*(T1+T2);
    450                  t0_on = 0;
   \   00000080   0x2300             MOVS     R3,#+0
   \   00000082   0xE002             B.N      ??PwmModulation__SpaceVectorModulation_v2_9
    451              }
    452              else
    453              {
    454                  // T0_on = 0.5 - 0.5*(T1+T2);
    455                  t0_on = MC_ONE_OVER_TWO - MC_DIV_SH(tsum,1);
   \                     ??PwmModulation__SpaceVectorModulation_v2_8: (+1)
   \   00000084   0x105B             ASRS     R3,R3,#+1
   \   00000086   0xF5C3 0x4380      RSB      R3,R3,#+16384
    456              }
    457          
    458              /*
    459              T0_on = 0.5 - 0.5*(T1+T2);
    460              T1_on = T1 + T0_on;
    461              T2_on = T2 + T1_on;
    462              */
    463              t1_on = t1 + t0_on;
   \                     ??PwmModulation__SpaceVectorModulation_v2_9: (+1)
   \   0000008A   0x195C             ADDS     R4,R3,R5
    464              t2_on = t2 + t1_on;
   \   0000008C   0x1861             ADDS     R1,R4,R1
    465          
    466          
    467           /* ****** DUTY LIMITATIONS ***** */
    468          #if (PWM_DUTY_LIMITATION == ENABLED)
    469              if (t1_on>DUTY_LIMIT_MID)
   \   0000008E   0xF247 0x55C4      MOVW     R5,#+30148
   \   00000092   0x42AC             CMP      R4,R5
   \   00000094   0xBFA8             IT       GE 
    470              {
    471                t1_on = DUTY_LIMIT_MID;
   \   00000096   0xF247 0x54C3      MOVWGE   R4,#+30147
    472              }
    473          
    474              #if (PWM_DUTY_BOOTSTRAP_LIMITATION == ENABLED)
    475              if (t2_on>DUTY_LIMIT_MID)
    476              {
    477                t2_on = DUTY_LIMIT_MID;
    478              }
    479          
    480              #elif (PWM_DUTY_ANTI_GLITCH_LIMITATION == ENABLED)
    481              #if (PWM_DUTY_BOOTSTRAP_LIMITATION == DISABLED)
    482              // Higher anti-glitch limitation makes sense only if just t1_on is limited
    483              if (t2_on > DUTY_ANTI_GLITCH_UPPER)
   \   0000009A   0xF647 0x0553      MOVW     R5,#+30803
   \   0000009E   0x42A9             CMP      R1,R5
   \   000000A0   0xBFA8             IT       GE 
    484              {
    485                  t2_on = DUTY_100;
   \   000000A2   0xF44F 0x4100      MOVGE    R1,#+32768
    486              }
    487              #endif
    488          
    489              if (t0_on < DUTY_ANTI_GLITCH_LOWER)
   \   000000A6   0x2B00             CMP      R3,#+0
   \   000000A8   0xBF48             IT       MI 
    490              {
    491                  t0_on = 0;
   \   000000AA   0x2300             MOVMI    R3,#+0
    492              }
    493              #endif
    494          
    495          #endif
    496              /* ****** ********* ***** */
    497          
    498          
    499              // duty calculation
    500              switch (sector)
   \   000000AC   0x1E45             SUBS     R5,R0,#+1
   \   000000AE   0x2D05             CMP      R5,#+5
   \   000000B0   0xD832             BHI.N    ??PwmModulation__SpaceVectorModulation_v2_10
   \   000000B2   0xE8DF 0xF005      TBB      [PC, R5]
   \                     ??PwmModulation__SpaceVectorModulation_v2_0:
   \   000000B6   0x03 0x0A          DC8      0x3,0xA,0x11,0x19
   \              0x11 0x19    
   \   000000BA   0x21 0x29          DC8      0x21,0x29
    501              {
    502               case 1:
    503                   v_abc_out->A = t2_on;
    504                   v_abc_out->B = t1_on;
   \                     ??PwmModulation__SpaceVectorModulation_v2_11: (+1)
   \   000000BC   0x4626             MOV      R6,R4
    505                   v_abc_out->C = t0_on;
    506                   break;
    507          
    508               case 2:
    509                   v_abc_out->A = t1_on;
    510                   v_abc_out->B = t2_on;
    511                   v_abc_out->C = t0_on;
    512                   break;
    513          
    514               case 3:
    515                   v_abc_out->A = t0_on;
    516                   v_abc_out->B = t2_on;
    517                   v_abc_out->C = t1_on;
    518                   break;
    519          
    520               case 4:
    521                   v_abc_out->A = t0_on;
    522                   v_abc_out->B = t1_on;
    523                   v_abc_out->C = t2_on;
    524                   break;
    525          
    526               case 5:
    527                   v_abc_out->A = t1_on;
    528                   v_abc_out->B = t0_on;
    529                   v_abc_out->C = t2_on;
    530                   break;
    531          
    532               case 6:
    533                   v_abc_out->A = t2_on;
    534                   v_abc_out->B = t0_on;
    535                   v_abc_out->C = t1_on;
    536                   break;
    537          
    538               default:
    539                   v_abc_out->A = 0;
    540                   v_abc_out->B = 0;
    541                   v_abc_out->C = 0;
    542                   break;
   \   000000BE   0x6093             STR      R3,[R2, #+8]
   \   000000C0   0x460D             MOV      R5,R1
   \   000000C2   0x6056             STR      R6,[R2, #+4]
   \   000000C4   0x6015             STR      R5,[R2, #+0]
    543              }
    544          
    545              return (sector);
   \   000000C6   0xBC70             POP      {R4-R6}
   \   000000C8   0x4770             BX       LR
   \                     ??PwmModulation__SpaceVectorModulation_v2_12: (+1)
   \   000000CA   0x460E             MOV      R6,R1
   \   000000CC   0x6093             STR      R3,[R2, #+8]
   \   000000CE   0x4625             MOV      R5,R4
   \   000000D0   0x6056             STR      R6,[R2, #+4]
   \   000000D2   0x6015             STR      R5,[R2, #+0]
   \   000000D4   0xBC70             POP      {R4-R6}
   \   000000D6   0x4770             BX       LR
   \                     ??PwmModulation__SpaceVectorModulation_v2_13: (+1)
   \   000000D8   0x461D             MOV      R5,R3
   \   000000DA   0x4623             MOV      R3,R4
   \   000000DC   0x460E             MOV      R6,R1
   \   000000DE   0x6093             STR      R3,[R2, #+8]
   \   000000E0   0x6056             STR      R6,[R2, #+4]
   \   000000E2   0x6015             STR      R5,[R2, #+0]
   \   000000E4   0xBC70             POP      {R4-R6}
   \   000000E6   0x4770             BX       LR
   \                     ??PwmModulation__SpaceVectorModulation_v2_14: (+1)
   \   000000E8   0x461D             MOV      R5,R3
   \   000000EA   0x460B             MOV      R3,R1
   \   000000EC   0x4626             MOV      R6,R4
   \   000000EE   0x6093             STR      R3,[R2, #+8]
   \   000000F0   0x6056             STR      R6,[R2, #+4]
   \   000000F2   0x6015             STR      R5,[R2, #+0]
   \   000000F4   0xBC70             POP      {R4-R6}
   \   000000F6   0x4770             BX       LR
   \                     ??PwmModulation__SpaceVectorModulation_v2_15: (+1)
   \   000000F8   0x461E             MOV      R6,R3
   \   000000FA   0x460B             MOV      R3,R1
   \   000000FC   0x6093             STR      R3,[R2, #+8]
   \   000000FE   0x4625             MOV      R5,R4
   \   00000100   0x6056             STR      R6,[R2, #+4]
   \   00000102   0x6015             STR      R5,[R2, #+0]
   \   00000104   0xBC70             POP      {R4-R6}
   \   00000106   0x4770             BX       LR
   \                     ??PwmModulation__SpaceVectorModulation_v2_16: (+1)
   \   00000108   0x461E             MOV      R6,R3
   \   0000010A   0x4623             MOV      R3,R4
   \   0000010C   0x6093             STR      R3,[R2, #+8]
   \   0000010E   0x460D             MOV      R5,R1
   \   00000110   0x6056             STR      R6,[R2, #+4]
   \   00000112   0x6015             STR      R5,[R2, #+0]
   \   00000114   0xBC70             POP      {R4-R6}
   \   00000116   0x4770             BX       LR
   \                     ??PwmModulation__SpaceVectorModulation_v2_10: (+1)
   \   00000118   0x2500             MOVS     R5,#+0
   \   0000011A   0x462B             MOV      R3,R5
   \   0000011C   0x2600             MOVS     R6,#+0
   \   0000011E   0x6093             STR      R3,[R2, #+8]
   \   00000120   0x6056             STR      R6,[R2, #+4]
   \   00000122   0x6015             STR      R5,[R2, #+0]
   \   00000124   0xBC70             POP      {R4-R6}
   \   00000126   0x4770             BX       LR               ;; return
    546          
    547          }
    548          
    549          

   \                                 In section .text, align 2, keep-with-next
    550          void PwmModulation__InverterLossComp_v2(ABC_COOR_SYST_TYPE *i_abc_in, ABC_COOR_SYST_TYPE *duty, MATHCALC_LUT_EXT_TYPE *inverter_loss_params)
    551          {
   \                     PwmModulation__InverterLossComp_v2: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0xB081             SUB      SP,SP,#+4
    552              sint32 duty_cycle;
    553              // check for 0% or 100% duties
    554              if ((duty->A != 0) && (duty->A != DUTY_100))
   \   00000006   0x682F             LDR      R7,[R5, #+0]
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x2F00             CMP      R7,#+0
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0xF5B7 0x4F00      CMPNE    R7,#+32768
   \   00000014   0xD00E             BEQ.N    ??PwmModulation__InverterLossComp_v2_0
    555              {
    556                  duty_cycle = duty->A;
    557                  duty_cycle += MathCalc__GetInterpolationFast(i_abc_in->A, inverter_loss_params);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x4631             MOV      R1,R6
   \   0000001A   0x.... 0x....      BL       MathCalc__GetInterpolationFast
   \   0000001E   0x19C0             ADDS     R0,R0,R7
    558                  duty->A = MATHCALC__SATURATE_DIRECT(0, duty_cycle, DUTY_100);
   \   00000020   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000024   0xBFA8             IT       GE 
   \   00000026   0xF44F 0x4000      MOVGE    R0,#+32768
   \   0000002A   0xDA02             BGE.N    ??PwmModulation__InverterLossComp_v2_1
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xBFB8             IT       LT 
   \   00000030   0x2000             MOVLT    R0,#+0
   \                     ??PwmModulation__InverterLossComp_v2_1: (+1)
   \   00000032   0x6028             STR      R0,[R5, #+0]
    559              }
    560          
    561              if ((duty->B != 0) && (duty->B != DUTY_100))
   \                     ??PwmModulation__InverterLossComp_v2_0: (+1)
   \   00000034   0x686F             LDR      R7,[R5, #+4]
   \   00000036   0x2F00             CMP      R7,#+0
   \   00000038   0xBF18             IT       NE 
   \   0000003A   0xF5B7 0x4F00      CMPNE    R7,#+32768
   \   0000003E   0xD00E             BEQ.N    ??PwmModulation__InverterLossComp_v2_2
    562              {
    563                  duty_cycle = duty->B;
    564                  duty_cycle += MathCalc__GetInterpolationFast(i_abc_in->B, inverter_loss_params);
   \   00000040   0x6860             LDR      R0,[R4, #+4]
   \   00000042   0x4631             MOV      R1,R6
   \   00000044   0x.... 0x....      BL       MathCalc__GetInterpolationFast
   \   00000048   0x19C0             ADDS     R0,R0,R7
    565                  duty->B = MATHCALC__SATURATE_DIRECT(0, duty_cycle, DUTY_100);
   \   0000004A   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000004E   0xBFA8             IT       GE 
   \   00000050   0xF44F 0x4000      MOVGE    R0,#+32768
   \   00000054   0xDA02             BGE.N    ??PwmModulation__InverterLossComp_v2_3
   \   00000056   0x2801             CMP      R0,#+1
   \   00000058   0xBFB8             IT       LT 
   \   0000005A   0x2000             MOVLT    R0,#+0
   \                     ??PwmModulation__InverterLossComp_v2_3: (+1)
   \   0000005C   0x6068             STR      R0,[R5, #+4]
    566              }
    567          
    568              if ((duty->C != 0) && (duty->C != DUTY_100))
   \                     ??PwmModulation__InverterLossComp_v2_2: (+1)
   \   0000005E   0x68AF             LDR      R7,[R5, #+8]
   \   00000060   0x2F00             CMP      R7,#+0
   \   00000062   0xBF18             IT       NE 
   \   00000064   0xF5B7 0x4F00      CMPNE    R7,#+32768
   \   00000068   0xD00E             BEQ.N    ??PwmModulation__InverterLossComp_v2_4
    569              {
    570                  duty_cycle = duty->C;
    571                  duty_cycle += MathCalc__GetInterpolationFast(i_abc_in->C, inverter_loss_params);
   \   0000006A   0x68A0             LDR      R0,[R4, #+8]
   \   0000006C   0x4631             MOV      R1,R6
   \   0000006E   0x.... 0x....      BL       MathCalc__GetInterpolationFast
   \   00000072   0x19C0             ADDS     R0,R0,R7
    572                  duty->C = MATHCALC__SATURATE_DIRECT(0, duty_cycle, DUTY_100);
   \   00000074   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000078   0xBFA8             IT       GE 
   \   0000007A   0xF44F 0x4000      MOVGE    R0,#+32768
   \   0000007E   0xDA02             BGE.N    ??PwmModulation__InverterLossComp_v2_5
   \   00000080   0x2801             CMP      R0,#+1
   \   00000082   0xBFB8             IT       LT 
   \   00000084   0x2000             MOVLT    R0,#+0
   \                     ??PwmModulation__InverterLossComp_v2_5: (+1)
   \   00000086   0x60A8             STR      R0,[R5, #+8]
    573              }
    574          
    575          }
   \                     ??PwmModulation__InverterLossComp_v2_4: (+1)
   \   00000088   0xB001             ADD      SP,SP,#+4
   \   0000008A   0xBDF0             POP      {R4-R7,PC}       ;; return
    576          
    577          
    578          
    579          /**
    580           *  @brief      Deadtime compensation with linear current gradient (improved version v2).
    581           *  @details
    582           *
    583           *
    584           *  Implemented equations:
    585           *   \f[
    586           *      \begin{aligned}
    587           *         & V_{a-comp} = V_a+ sgn(I_a)\cdot deadtime\\
    588           *         & V_{b-comp} = V_b+ sgn(I_b)\cdot deadtime\\
    589           *         & V_{c-comp} = V_c+ sgn(I_c)\cdot deadtime\\
    590           *      \end{aligned}
    591           *    \f]
    592           *  A smoothing linear equation is used in order to avoid discontinuities when current change sign
    593           *  If the not-compensated duty is 100% or 0%, no correction is applied.
    594           *
    595           *  @param[in]      i_abc_in          = motor phase currents in abc components
    596           *  @param[in-out]  duty 	          = PWM duties
    597           */

   \                                 In section .text, align 2, keep-with-next
    598          void PwmModulation__DeadtimeCompensationGradient_v2(ABC_COOR_SYST_TYPE* i_abc_in, ABC_COOR_SYST_TYPE* duty)
    599          {
    600              mc_sint32 duty_cycle;
    601              mc_sint32 current_sat;
    602          
    603              ////////////// phase A ///////////////////////////
    604              // check for 0% or 100% duties
    605              if ((duty->A != 0) && (duty->A != DUTY_100))
   \                     PwmModulation__DeadtimeCompensationGradient_v2: (+1)
   \   00000000   0x680A             LDR      R2,[R1, #+0]
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xBF18             IT       NE 
   \   00000006   0xF5B2 0x4F00      CMPNE    R2,#+32768
   \   0000000A   0xD01C             BEQ.N    ??PwmModulation__DeadtimeCompensationGradient_v_0
    606              {
    607                  current_sat = MATHCALC__SATURATE_DIRECT(-DT_COMP_I_THR, i_abc_in->A, DT_COMP_I_THR);
   \   0000000C   0x6803             LDR      R3,[R0, #+0]
   \   0000000E   0xF640 0x7C92      MOVW     R12,#+3986
   \   00000012   0x4563             CMP      R3,R12
   \   00000014   0xBFA8             IT       GE 
   \   00000016   0x4663             MOVGE    R3,R12
   \   00000018   0xDA05             BGE.N    ??PwmModulation__DeadtimeCompensationGradient_v_1
   \   0000001A   0xF46F 0x6C79      MVN      R12,#+3984
   \   0000001E   0x4563             CMP      R3,R12
   \   00000020   0xBFB8             IT       LT 
   \   00000022   0x.... 0x....      LDRLT.W  R3,??DataTable127  ;; 0xfffff06e
    608                  duty_cycle = duty->A;
    609                  // calculation of the compensation factor
    610                  duty_cycle += MC_SCALE((DT_COMP_M * current_sat),IQ30,IQ15);
   \                     ??PwmModulation__DeadtimeCompensationGradient_v_1: (+1)
   \   00000026   0xF241 0x0CD5      MOVW     R12,#+4309
   \   0000002A   0xFB03 0xF30C      MUL      R3,R3,R12
   \   0000002E   0xEB02 0x32E3      ADD      R2,R2,R3, ASR #+15
    611          
    612                  // assignment with 0% - 100% saturation
    613                  duty->A = MATHCALC__SATURATE_DIRECT(0, duty_cycle, DUTY_100);
   \   00000032   0xF5B2 0x4F00      CMP      R2,#+32768
   \   00000036   0xBFA8             IT       GE 
   \   00000038   0xF44F 0x4200      MOVGE    R2,#+32768
   \   0000003C   0xDA02             BGE.N    ??PwmModulation__DeadtimeCompensationGradient_v_2
   \   0000003E   0x2A01             CMP      R2,#+1
   \   00000040   0xBFB8             IT       LT 
   \   00000042   0x2200             MOVLT    R2,#+0
   \                     ??PwmModulation__DeadtimeCompensationGradient_v_2: (+1)
   \   00000044   0x600A             STR      R2,[R1, #+0]
    614              }
    615          
    616              ////////////// phase B ///////////////////////////
    617              // check for 0% or 100% duties
    618              if ((duty->B != 0) && (duty->B != DUTY_100))
   \                     ??PwmModulation__DeadtimeCompensationGradient_v_0: (+1)
   \   00000046   0x684A             LDR      R2,[R1, #+4]
   \   00000048   0x2A00             CMP      R2,#+0
   \   0000004A   0xBF18             IT       NE 
   \   0000004C   0xF5B2 0x4F00      CMPNE    R2,#+32768
   \   00000050   0xD01C             BEQ.N    ??PwmModulation__DeadtimeCompensationGradient_v_3
    619              {
    620                  current_sat = MATHCALC__SATURATE_DIRECT(-DT_COMP_I_THR, i_abc_in->B, DT_COMP_I_THR);
   \   00000052   0x6843             LDR      R3,[R0, #+4]
   \   00000054   0xF640 0x7C92      MOVW     R12,#+3986
   \   00000058   0x4563             CMP      R3,R12
   \   0000005A   0xBFA8             IT       GE 
   \   0000005C   0x4663             MOVGE    R3,R12
   \   0000005E   0xDA05             BGE.N    ??PwmModulation__DeadtimeCompensationGradient_v_4
   \   00000060   0xF46F 0x6C79      MVN      R12,#+3984
   \   00000064   0x4563             CMP      R3,R12
   \   00000066   0xBFB8             IT       LT 
   \   00000068   0x.... 0x....      LDRLT.W  R3,??DataTable127  ;; 0xfffff06e
    621                  duty_cycle = duty->B;
    622                  // calculation of the compensation factor
    623                  duty_cycle += MC_SCALE((DT_COMP_M * current_sat),IQ30,IQ15);
   \                     ??PwmModulation__DeadtimeCompensationGradient_v_4: (+1)
   \   0000006C   0xF241 0x0CD5      MOVW     R12,#+4309
   \   00000070   0xFB03 0xF30C      MUL      R3,R3,R12
   \   00000074   0xEB02 0x32E3      ADD      R2,R2,R3, ASR #+15
    624          
    625                  // assignment with 0% - 100% saturation
    626                  duty->B = MATHCALC__SATURATE_DIRECT(0, duty_cycle, DUTY_100);
   \   00000078   0xF5B2 0x4F00      CMP      R2,#+32768
   \   0000007C   0xBFA8             IT       GE 
   \   0000007E   0xF44F 0x4200      MOVGE    R2,#+32768
   \   00000082   0xDA02             BGE.N    ??PwmModulation__DeadtimeCompensationGradient_v_5
   \   00000084   0x2A01             CMP      R2,#+1
   \   00000086   0xBFB8             IT       LT 
   \   00000088   0x2200             MOVLT    R2,#+0
   \                     ??PwmModulation__DeadtimeCompensationGradient_v_5: (+1)
   \   0000008A   0x604A             STR      R2,[R1, #+4]
    627              }
    628          
    629              ////////////// phase C ///////////////////////////
    630              // check for 0% or 100% duties
    631              if ((duty->C != 0) && (duty->C != DUTY_100))
   \                     ??PwmModulation__DeadtimeCompensationGradient_v_3: (+1)
   \   0000008C   0x688A             LDR      R2,[R1, #+8]
   \   0000008E   0x2A00             CMP      R2,#+0
   \   00000090   0xBF18             IT       NE 
   \   00000092   0xF5B2 0x4F00      CMPNE    R2,#+32768
   \   00000096   0xD01B             BEQ.N    ??PwmModulation__DeadtimeCompensationGradient_v_6
    632              {
    633                  current_sat = MATHCALC__SATURATE_DIRECT(-DT_COMP_I_THR, i_abc_in->C, DT_COMP_I_THR);
   \   00000098   0x6883             LDR      R3,[R0, #+8]
   \   0000009A   0xF640 0x7C92      MOVW     R12,#+3986
   \   0000009E   0x4563             CMP      R3,R12
   \   000000A0   0xBFA8             IT       GE 
   \   000000A2   0x4663             MOVGE    R3,R12
   \   000000A4   0xDA05             BGE.N    ??PwmModulation__DeadtimeCompensationGradient_v_7
   \   000000A6   0xF46F 0x6079      MVN      R0,#+3984
   \   000000AA   0x4283             CMP      R3,R0
   \   000000AC   0xBFB8             IT       LT 
   \   000000AE   0x.... 0x....      LDRLT.W  R3,??DataTable127  ;; 0xfffff06e
    634                  duty_cycle = duty->C;
    635                  // calculation of the compensation factor
    636                  duty_cycle += MC_SCALE((DT_COMP_M * current_sat),IQ30,IQ15);
   \                     ??PwmModulation__DeadtimeCompensationGradient_v_7: (+1)
   \   000000B2   0xF241 0x00D5      MOVW     R0,#+4309
   \   000000B6   0x4358             MULS     R0,R0,R3
   \   000000B8   0xEB02 0x32E0      ADD      R2,R2,R0, ASR #+15
    637          
    638                  // assignment with 0% - 100% saturation
    639                  duty->C = MATHCALC__SATURATE_DIRECT(0, duty_cycle, DUTY_100);
   \   000000BC   0xF5B2 0x4F00      CMP      R2,#+32768
   \   000000C0   0xBFA8             IT       GE 
   \   000000C2   0xF44F 0x4200      MOVGE    R2,#+32768
   \   000000C6   0xDA02             BGE.N    ??PwmModulation__DeadtimeCompensationGradient_v_8
   \   000000C8   0x2A01             CMP      R2,#+1
   \   000000CA   0xBFB8             IT       LT 
   \   000000CC   0x2200             MOVLT    R2,#+0
   \                     ??PwmModulation__DeadtimeCompensationGradient_v_8: (+1)
   \   000000CE   0x608A             STR      R2,[R1, #+8]
    640              }
    641          }
   \                     ??PwmModulation__DeadtimeCompensationGradient_v_6: (+1)
   \   000000D0   0x4770             BX       LR               ;; return
    642          
    643          /**
    644           *  @brief      Space vector modulation: Floating Point Implementation
    645           *  @details
    646           *
    647           * This function calculates a,b,c duty cycles that generates the desired reference voltage (alpha/beta input)
    648           * into the a,b,c output. The flow chart is the following:
    649           *
    650           * <b> 1 - Reference voltage normalization (DC Bus Ripple Compensation) </b>
    651           * <b> 2 - X, Y, Z quantities calculation </b>
    652           * <b> 3 - Sector Identification </b>
    653           * <b> 4 - Over-modulation </b>
    654           * <b> 5 - Duty Cycle Limitations (High-Performance approach) </b>
    655           * <b> 6 - a,b,c Duty Cycle assignment </b>
    656           *
    657           *
    658           *  @param[in]      v_dc               = DC bus voltage
    659           *  @param[in]      v_alphabeta_in     = motor reference voltage (alpha-beta components)
    660           *  @param[out]     v_abc_out          = PWM duty-cycles (a,b,c)
    661           *  @param[in]      enable_flat_bottom = boolean flag (TRUE --> implement flat bottom Space Vector Modulation forcing dlow = 0)
    662           *  @return         sector             = sector value
    663           */

   \                                 In section .text, align 4, keep-with-next
    664          uint8 PwmModulation__SpaceVectorModulationF(float32 v_dc, ALPHA_BETA_COOR_SYST_F_TYPE* v_alphabeta_in, ABC_COOR_SYST_F_TYPE* v_abc_out, BOOL_TYPE enable_flat_bottom)
    665          {
    666              uint8   sector = 0;
    667              ALPHA_BETA_COOR_SYST_F_TYPE     Vs_Alpha_Beta_Comp;
    668              float32 x;
    669              float32 y;
    670              float32 z;
    671              float32 d2;
    672              float32 d1;
    673              float32 dsum;
    674              float32 d_low;
    675              float32 d_mid;
    676              float32 d_high;
    677          
    678              x = SQRT3 / v_dc; // just used as temporary variable to optimize division
   \                     PwmModulation__SpaceVectorModulationF: (+1)
   \   00000000   0xEDDF 0x....      VLDR.W   S1,??DataTable113  ;; 0x3fddb3d7
   \   00000004   0xEE80 0x0A80      VDIV.F32 S0,S1,S0
    679          
    680              /* Ripple compensation */
    681              Vs_Alpha_Beta_Comp.Alpha = v_alphabeta_in->Alpha * x;
   \   00000008   0xEDD0 0x0A01      VLDR     S1,[R0, #+4]
    682              Vs_Alpha_Beta_Comp.Beta = v_alphabeta_in->Beta * x;
   \   0000000C   0xED90 0x1A02      VLDR     S2,[R0, #+8]
   \   00000010   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000014   0xEE21 0x0A00      VMUL.F32 S0,S2,S0
    683          
    684              /* X, Y, Z calculation */
    685              x = Vs_Alpha_Beta_Comp.Beta;
    686          
    687              y = Vs_Alpha_Beta_Comp.Alpha * F_SQRT3_OVER_TWO;
    688              y = y + (Vs_Alpha_Beta_Comp.Beta / 2);
   \   00000018   0xEEB6 0x1A00      VMOV.F32 S2,#0.5
   \   0000001C   0xEE20 0x1A01      VMUL.F32 S2,S0,S2
   \   00000020   0xED9F 0x....      VLDR.W   S4,??DataTable113_1  ;; 0x3f5db3d7
   \   00000024   0xEEF0 0x1A41      VMOV.F32 S3,S2
   \   00000028   0xEE40 0x1A82      VMLA.F32 S3,S1,S4
    689          
    690              z = -Vs_Alpha_Beta_Comp.Alpha * F_SQRT3_OVER_TWO;
    691              z = z + (Vs_Alpha_Beta_Comp.Beta / 2);
   \   0000002C   0xED9F 0x....      VLDR.W   S4,??DataTable113_2  ;; 0xbf5db3d7
    692          
    693              // sector identification
    694              if (x>=0)
   \   00000030   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000034   0xEE00 0x1A82      VMLA.F32 S2,S1,S4
   \   00000038   0xEEF1 0xFA10      FMSTAT   
   \   0000003C   0xDB1C             BLT.N    ??PwmModulation__SpaceVectorModulationF_1
    695              {
    696                  // sector 1,2,3,7
    697                  if (y>0)
   \   0000003E   0xEEF5 0x1A40      VCMP.F32 S3,#0.0
   \   00000042   0xEEF1 0xFA10      FMSTAT   
   \   00000046   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   0000004A   0xDD0C             BLE.N    ??PwmModulation__SpaceVectorModulationF_2
    698                  {
    699                      // sector 1,2
    700                      if (z<=0)
   \   0000004C   0xEEF1 0xFA10      FMSTAT   
   \   00000050   0xD803             BHI.N    ??PwmModulation__SpaceVectorModulationF_3
    701                      {
    702                          // sector 1
    703                          sector = 1;
   \   00000052   0x2001             MOVS     R0,#+1
    704                          d1 = -z;
   \   00000054   0xEEF1 0x0A41      VNEG.F32 S1,S2
    705                          d2 = x;
   \   00000058   0xE029             B.N      ??PwmModulation__SpaceVectorModulationF_4
    706                      }
    707                      else
    708                      {
    709                          // sector 2
    710                          sector = 2;
   \                     ??PwmModulation__SpaceVectorModulationF_3: (+1)
   \   0000005A   0x2002             MOVS     R0,#+2
    711                          d1 = z;
   \   0000005C   0xEEF0 0x0A41      VMOV.F32 S1,S2
    712                          d2 = y;
   \   00000060   0xEEB0 0x0A61      VMOV.F32 S0,S3
   \   00000064   0xE023             B.N      ??PwmModulation__SpaceVectorModulationF_4
    713                      }
    714                  }
    715                  else
    716                  {
    717                      // sector 3,7
    718                      if (z>0)
   \                     ??PwmModulation__SpaceVectorModulationF_2: (+1)
   \   00000066   0xEEF1 0xFA10      FMSTAT   
   \   0000006A   0xDD15             BLE.N    ??PwmModulation__SpaceVectorModulationF_5
    719                      {
    720                          // sector 3
    721                          sector = 3;
    722                          d1 = x;
   \   0000006C   0xEEF0 0x0A40      VMOV.F32 S1,S0
   \   00000070   0x2003             MOVS     R0,#+3
    723                          d2 = -y;
   \   00000072   0xEEB1 0x0A61      VNEG.F32 S0,S3
   \   00000076   0xE01A             B.N      ??PwmModulation__SpaceVectorModulationF_4
    724                      }
    725                      else
    726                      {
    727                          // sector 7 --> 6
    728                          sector = 6;
    729                          d1 = y;
    730                          d2 = -x;
    731          
    732                      }
    733                  }
    734              }
    735              else
    736              {
    737                  // sector 4,5,6
    738                  if (z>0)
   \                     ??PwmModulation__SpaceVectorModulationF_1: (+1)
   \   00000078   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   0000007C   0xEEF1 0xFA10      FMSTAT   
   \   00000080   0xDD05             BLE.N    ??PwmModulation__SpaceVectorModulationF_6
    739                  {
    740                     // sector 4
    741                     sector = 4;
    742                     d1 = -x;
   \   00000082   0xEEF1 0x0A40      VNEG.F32 S1,S0
   \   00000086   0x2004             MOVS     R0,#+4
    743                     d2 = z;
   \   00000088   0xEEB0 0x0A41      VMOV.F32 S0,S2
   \   0000008C   0xE00F             B.N      ??PwmModulation__SpaceVectorModulationF_4
    744                  }
    745                  else
    746                  {
    747                      if (y>0)
   \                     ??PwmModulation__SpaceVectorModulationF_6: (+1)
   \   0000008E   0xEEF5 0x1A40      VCMP.F32 S3,#0.0
   \   00000092   0xEEF1 0xFA10      FMSTAT   
   \   00000096   0xDD05             BLE.N    ??PwmModulation__SpaceVectorModulationF_7
    748                      {
    749                          // sector 6
    750                          sector = 6;
   \                     ??PwmModulation__SpaceVectorModulationF_5: (+1)
   \   00000098   0x2006             MOVS     R0,#+6
    751                          d1 = y;
   \   0000009A   0xEEF0 0x0A61      VMOV.F32 S1,S3
    752                          d2 = -x;
   \   0000009E   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   000000A2   0xE004             B.N      ??PwmModulation__SpaceVectorModulationF_4
    753                      }
    754                      else
    755                      {
    756                          // sector 5
    757                          sector = 5;
   \                     ??PwmModulation__SpaceVectorModulationF_7: (+1)
   \   000000A4   0x2005             MOVS     R0,#+5
    758                          d1 = -y;
   \   000000A6   0xEEF1 0x0A61      VNEG.F32 S1,S3
    759                          d2 = -z;
   \   000000AA   0xEEB1 0x0A41      VNEG.F32 S0,S2
    760                      }
    761                  }
    762              }
    763          
    764          
    765          
    766              // Duty cycles calculation:
    767          
    768              /*
    769              Ton Duration Formulas, Ts is Pwm Switching Period:
    770              T_low_on = T0/2 = (Ts-T1-T2)/2;
    771              T_mid_on = T0/2 + T2 = Tlow_on + T2;
    772              T_high_on = T0/2 + T1 + T2 = T_mid_on + T1;
    773          
    774              Duty Cycles - Times relations:
    775              d1 = T1/Ts
    776              d2 = T2/Ts
    777          
    778              d_low = T_low_on/Ts = (d_limit - d1 - d2)/2
    779              d_mid = T_mid_on/Ts = d_low + d2
    780              d_high = T_high_on/Ts = d_mid + d1
    781              */
    782          
    783              // Over-modulation -> it automatically limits the d_high to F_OVERMODULATION_THR
    784              dsum = d2 + d1;
   \                     ??PwmModulation__SpaceVectorModulationF_4: (+1)
   \   000000AE   0xEE30 0x1A20      VADD.F32 S2,S0,S1
    785              if (dsum > F_OVERMODULATION_THR)
   \   000000B2   0xEDDF 0x....      VLDR.W   S3,??DataTable113_3  ;; 0x3f800001
   \   000000B6   0xEEB4 0x1A61      VCMP.F32 S2,S3
   \   000000BA   0xEEF1 0xFA10      FMSTAT   
   \   000000BE   0xDB06             BLT.N    ??PwmModulation__SpaceVectorModulationF_8
    786              {
    787              	//ration between d2 and d1 shall be the same to maintain the same vector direction
    788              	// (d2_new/ (F_OVERMODULATION_THR - d2_new)) = (d2_old/d1_old)
    789              	
    790                  d2 = (d2 * F_OVERMODULATION_THR) / dsum;
   \   000000C0   0xEE80 0x0A01      VDIV.F32 S0,S0,S2
    791                  d1 = F_OVERMODULATION_THR - d2;
   \   000000C4   0xEEF7 0x0A00      VMOV.F32 S1,#1.0
   \   000000C8   0xEE70 0x0AC0      VSUB.F32 S1,S1,S0
    792                  d_low = 0;
   \   000000CC   0xE00F             B.N      ??PwmModulation__SpaceVectorModulationF_9
    793              }
    794              else
    795              {
    796                  //d_low = (T0/2)/Ts = (F_OVERMODULATION_THR-D1-D2)/2; -> F_OVERMODULATION_THR is equal to Duty Cycle Limit
    797                  d_low = (F_OVERMODULATION_THR - dsum) / 2.0f;
   \                     ??PwmModulation__SpaceVectorModulationF_8: (+1)
   \   000000CE   0xEEF7 0x1A00      VMOV.F32 S3,#1.0
   \   000000D2   0xEE31 0x1AC1      VSUB.F32 S2,S3,S2
   \   000000D6   0xEEF6 0x1A00      VMOV.F32 S3,#0.5
   \   000000DA   0xEE21 0x1A21      VMUL.F32 S2,S2,S3
    798          
    799                  if ((d_low < F_DUTY_ANTI_GLITCH_LOWER) || (enable_flat_bottom == TRUE))
   \   000000DE   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   000000E2   0xEEF1 0xFA10      FMSTAT   
   \   000000E6   0xD402             BMI.N    ??PwmModulation__SpaceVectorModulationF_9
   \   000000E8   0xB2D2             UXTB     R2,R2
   \   000000EA   0x2A01             CMP      R2,#+1
   \   000000EC   0xD101             BNE.N    ??PwmModulation__SpaceVectorModulationF_10
    800                  {
    801                      d_low = 0;
   \                     ??PwmModulation__SpaceVectorModulationF_9: (+1)
   \   000000EE   0xED9F 0x....      VLDR.W   S2,??DataTable114  ;; 0x0
    802                  }
    803              }
    804          
    805          
    806              ///////////////// d_mid calculation ///////////////
    807              d_mid = d2 + d_low;
   \                     ??PwmModulation__SpaceVectorModulationF_10: (+1)
   \   000000F2   0xEE30 0x0A01      VADD.F32 S0,S0,S2
    808          
    809              ///////////////////////////////////////////////////
    810          
    811              ///////////////// d_high calculation ///////////////
    812              d_high = d1 + d_mid;
    813          
    814              ///////////////////////////////////////////////////
    815          
    816              ///////////////// limitations on d_mid and d_high ///////////////
    817              if (d_mid > F_DUTY_LIMIT_MID)
   \   000000F6   0xEDDF 0x....      VLDR.W   S3,??DataTable114_1  ;; 0x3f6b8520
   \   000000FA   0xEEB4 0x0A61      VCMP.F32 S0,S3
   \   000000FE   0xEE70 0x0A80      VADD.F32 S1,S1,S0
   \   00000102   0xEEF1 0xFA10      FMSTAT   
   \   00000106   0xBFA8             IT       GE 
    818              {
    819                d_mid = F_DUTY_LIMIT_MID;
   \   00000108   0xED9F 0x....      VLDRGE.W S0,??DataTable114_2  ;; 0x3f6b851f
    820              }
    821          
    822              if (d_high > F_DUTY_ANTI_GLITCH_UPPER)
   \   0000010C   0xEDDF 0x....      VLDR.W   S3,??DataTable114_3  ;; 0x3f70a3d8
   \   00000110   0xEEF4 0x0A61      VCMP.F32 S1,S3
   \   00000114   0xEEF1 0xFA10      FMSTAT   
   \   00000118   0xBFA8             IT       GE 
    823              {
    824                  d_high = F_DUTY_100;
   \   0000011A   0xEEF7 0x0A00      VMOVGE.F32 S1,#1.0
    825              }
    826              ///////////////////////////////////////////////////
    827          
    828          
    829              switch (sector)
   \   0000011E   0x1E42             SUBS     R2,R0,#+1
   \   00000120   0x2A05             CMP      R2,#+5
   \   00000122   0xD84E             BHI.N    ??PwmModulation__SpaceVectorModulationF_11
   \   00000124   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??PwmModulation__SpaceVectorModulationF_0:
   \   00000128   0x03 0x0E          DC8      0x3,0xE,0x19,0x26
   \              0x19 0x26    
   \   0000012C   0x33 0x40          DC8      0x33,0x40
    830              {
    831               case 1:
    832                   v_abc_out->A = d_high;
    833                   v_abc_out->B = d_mid;
   \                     ??PwmModulation__SpaceVectorModulationF_12: (+1)
   \   0000012E   0xEEB0 0x2A40      VMOV.F32 S4,S0
    834                   v_abc_out->C = d_low;
    835                   break;
    836          
    837               case 2:
    838                   v_abc_out->A = d_mid;
    839                   v_abc_out->B = d_high;
    840                   v_abc_out->C = d_low;
    841                   break;
    842          
    843               case 3:
    844                   v_abc_out->A = d_low;
    845                   v_abc_out->B = d_high;
    846                   v_abc_out->C = d_mid;
    847                   break;
    848          
    849               case 4:
    850                   v_abc_out->A = d_low;
    851                   v_abc_out->B = d_mid;
    852                   v_abc_out->C = d_high;
    853                   break;
    854          
    855               case 5:
    856                   v_abc_out->A = d_mid;
    857                   v_abc_out->B = d_low;
    858                   v_abc_out->C = d_high;
    859                   break;
    860          
    861               case 6:
    862                   v_abc_out->A = d_high;
    863                   v_abc_out->B = d_low;
    864                   v_abc_out->C = d_mid;
    865                   break;
    866          
    867               default:
    868                   v_abc_out->A = 0;
    869                   v_abc_out->B = 0;
    870                   v_abc_out->C = 0;
    871                   break;
   \   00000132   0xED81 0x1A02      VSTR     S2,[R1, #+8]
   \   00000136   0xEEF0 0x1A60      VMOV.F32 S3,S1
   \   0000013A   0xED81 0x2A01      VSTR     S4,[R1, #+4]
   \   0000013E   0xEDC1 0x1A00      VSTR     S3,[R1, #0]
    872              }
    873          
    874              return (sector);
   \   00000142   0x4770             BX       LR
   \                     ??PwmModulation__SpaceVectorModulationF_13: (+1)
   \   00000144   0xEEB0 0x2A60      VMOV.F32 S4,S1
   \   00000148   0xED81 0x1A02      VSTR     S2,[R1, #+8]
   \   0000014C   0xEEF0 0x1A40      VMOV.F32 S3,S0
   \   00000150   0xED81 0x2A01      VSTR     S4,[R1, #+4]
   \   00000154   0xEDC1 0x1A00      VSTR     S3,[R1, #0]
   \   00000158   0x4770             BX       LR
   \                     ??PwmModulation__SpaceVectorModulationF_14: (+1)
   \   0000015A   0xEEF0 0x1A41      VMOV.F32 S3,S2
   \   0000015E   0xEEB0 0x1A40      VMOV.F32 S2,S0
   \   00000162   0xEEB0 0x2A60      VMOV.F32 S4,S1
   \   00000166   0xED81 0x1A02      VSTR     S2,[R1, #+8]
   \   0000016A   0xED81 0x2A01      VSTR     S4,[R1, #+4]
   \   0000016E   0xEDC1 0x1A00      VSTR     S3,[R1, #0]
   \   00000172   0x4770             BX       LR
   \                     ??PwmModulation__SpaceVectorModulationF_15: (+1)
   \   00000174   0xEEF0 0x1A41      VMOV.F32 S3,S2
   \   00000178   0xEEB0 0x1A60      VMOV.F32 S2,S1
   \   0000017C   0xEEB0 0x2A40      VMOV.F32 S4,S0
   \   00000180   0xED81 0x1A02      VSTR     S2,[R1, #+8]
   \   00000184   0xED81 0x2A01      VSTR     S4,[R1, #+4]
   \   00000188   0xEDC1 0x1A00      VSTR     S3,[R1, #0]
   \   0000018C   0x4770             BX       LR
   \                     ??PwmModulation__SpaceVectorModulationF_16: (+1)
   \   0000018E   0xEEB0 0x2A41      VMOV.F32 S4,S2
   \   00000192   0xEEB0 0x1A60      VMOV.F32 S2,S1
   \   00000196   0xED81 0x1A02      VSTR     S2,[R1, #+8]
   \   0000019A   0xEEF0 0x1A40      VMOV.F32 S3,S0
   \   0000019E   0xED81 0x2A01      VSTR     S4,[R1, #+4]
   \   000001A2   0xEDC1 0x1A00      VSTR     S3,[R1, #0]
   \   000001A6   0x4770             BX       LR
   \                     ??PwmModulation__SpaceVectorModulationF_17: (+1)
   \   000001A8   0xEEB0 0x2A41      VMOV.F32 S4,S2
   \   000001AC   0xEEB0 0x1A40      VMOV.F32 S2,S0
   \   000001B0   0xED81 0x1A02      VSTR     S2,[R1, #+8]
   \   000001B4   0xEEF0 0x1A60      VMOV.F32 S3,S1
   \   000001B8   0xED81 0x2A01      VSTR     S4,[R1, #+4]
   \   000001BC   0xEDC1 0x1A00      VSTR     S3,[R1, #0]
   \   000001C0   0x4770             BX       LR
   \                     ??PwmModulation__SpaceVectorModulationF_11: (+1)
   \   000001C2   0xED9F 0x....      VLDR.W   S2,??DataTable114  ;; 0x0
   \   000001C6   0xED9F 0x....      VLDR.W   S4,??DataTable114  ;; 0x0
   \   000001CA   0xED81 0x1A02      VSTR     S2,[R1, #+8]
   \   000001CE   0xEDDF 0x....      VLDR.W   S3,??DataTable114  ;; 0x0
   \   000001D2   0xED81 0x2A01      VSTR     S4,[R1, #+4]
   \   000001D6   0xEDC1 0x1A00      VSTR     S3,[R1, #0]
   \   000001DA   0x4770             BX       LR               ;; return
    875          
    876          }
    877          
    878          //---------------------------------------------------------------------------------------------------------------------
    879           /** @brief  Space vector modulation in rectangular coordinates - floating point
    880            *
    881            *
    882            *  @param[in]      v_alphabeta_in    = motor compensated voltage alpha-beta components
    883            *  @param[out]     v_abc_out         = PWM duties in abc components
    884            *  @param[in]      duty_cycle_limit  = duty cycle limitation
    885            *  @return         Sector number
    886            *
    887            */

   \                                 In section .text, align 4, keep-with-next
    888           uint8 PwmModulation__SpaceVectorModulationRectangularF(float32 v_dc, ALPHA_BETA_COOR_SYST_F_TYPE* v_alphabeta_in, ABC_COOR_SYST_F_TYPE* v_abc_out)
    889           {
    890               static ALPHA_BETA_COOR_SYST_F_TYPE vs_alpha_beta_comp;
    891               uint8 sector = 0;
    892               float32 x;
    893               float32 y;
    894               float32 t1_on;
    895               float32 t2_on;
    896          
    897               x = SQRT3 / v_dc; // just used as temporary variable to optimize division
   \                     PwmModulation__SpaceVectorModulationRectangularF: (+1)
   \   00000000   0xEDDF 0x....      VLDR.W   S1,??DataTable113  ;; 0x3fddb3d7
   \   00000004   0xEE80 0x0A80      VDIV.F32 S0,S1,S0
    898          
    899               // Ripple compensation
    900               vs_alpha_beta_comp.Alpha = v_alphabeta_in->Alpha * x;
   \   00000008   0xEDD0 0x0A01      VLDR     S1,[R0, #+4]
   \   0000000C   0x.... 0x....      LDR.W    R2,??DataTable134
   \   00000010   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000014   0xEDC2 0x0A01      VSTR     S1,[R2, #+4]
    901               vs_alpha_beta_comp.Beta = v_alphabeta_in->Beta * x;
   \   00000018   0xED90 0x1A02      VLDR     S2,[R0, #+8]
   \   0000001C   0xEE21 0x0A00      VMUL.F32 S0,S2,S0
   \   00000020   0xED82 0x0A02      VSTR     S0,[R2, #+8]
    902          
    903               // X and Y calculation
    904               x = vs_alpha_beta_comp.Beta / 2.0f;
   \   00000024   0xEEB6 0x1A00      VMOV.F32 S2,#0.5
   \   00000028   0xEE20 0x0A01      VMUL.F32 S0,S0,S2
    905               y = vs_alpha_beta_comp.Alpha * F_SQRT3_OVER_TWO;
   \   0000002C   0xED9F 0x....      VLDR.W   S2,??DataTable113_1  ;; 0x3f5db3d7
    906          
    907               // Sector identification
    908               if (x >= 0)
   \   00000030   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000034   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   00000038   0xEEF1 0xFA10      FMSTAT   
   \   0000003C   0xDB0C             BLT.N    ??PwmModulation__SpaceVectorModulationRectangul_11
    909               {
    910                   if ((x + y) >= 0)
   \   0000003E   0xEE30 0x1A20      VADD.F32 S2,S0,S1
   \   00000042   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   00000046   0xEEF1 0xFA10      FMSTAT   
   \   0000004A   0xDB12             BLT.N    ??PwmModulation__SpaceVectorModulationRectangul_12
    911                   {
    912                       // sector I - II
    913                       sector = 1;
    914                       t1_on = x + y;
    915                       t2_on = x * 2;
   \   0000004C   0xEEF0 0x0A00      VMOV.F32 S1,#2.0
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000056   0xE013             B.N      ??PwmModulation__SpaceVectorModulationRectangul_13
    916                   }
    917                   else
    918                   {
    919                       // sector III - IV
    920                       sector = 2;
    921                       t1_on = x - y;
    922                       t2_on = - y - x;
    923                   }
    924               }
    925               else
    926               {
    927                   if (x < y)
   \                     ??PwmModulation__SpaceVectorModulationRectangul_11: (+1)
   \   00000058   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000005C   0xEEF1 0xFA10      FMSTAT   
   \   00000060   0xD507             BPL.N    ??PwmModulation__SpaceVectorModulationRectangul_12
    928                   {
    929                       // sector V - VI
    930                       sector = 3;
    931                       t1_on = y - x;
   \   00000062   0xEE30 0x1AC0      VSUB.F32 S2,S1,S0
    932                       t2_on = -x * 2;
   \   00000066   0xEEF8 0x0A00      VMOV.F32 S1,#-2.0
   \   0000006A   0x2003             MOVS     R0,#+3
   \   0000006C   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000070   0xE006             B.N      ??PwmModulation__SpaceVectorModulationRectangul_13
    933                   }
    934                   else
    935                   {
    936                       // sector III - IV
    937                       sector = 2;
    938                       t1_on = x - y;
   \                     ??PwmModulation__SpaceVectorModulationRectangul_12: (+1)
   \   00000072   0xEE30 0x1A60      VSUB.F32 S2,S0,S1
    939                       t2_on = - y - x;
   \   00000076   0xEEF1 0x0A60      VNEG.F32 S1,S1
   \   0000007A   0x2002             MOVS     R0,#+2
   \   0000007C   0xEE30 0x0AC0      VSUB.F32 S0,S1,S0
    940                   }
    941               }
    942          
    943               // Over-modulation
    944               if (t1_on > t2_on)
   \                     ??PwmModulation__SpaceVectorModulationRectangul_13: (+1)
   \   00000080   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   00000084   0xEDDF 0x....      VLDR.W   S1,??DataTable113_3  ;; 0x3f800001
   \   00000088   0xEEF1 0xFA10      FMSTAT   
   \   0000008C   0xD512             BPL.N    ??PwmModulation__SpaceVectorModulationRectangul_14
    945               {
    946                   if (t1_on > F_OVERMODULATION_THR)
   \   0000008E   0xEEB4 0x1A60      VCMP.F32 S2,S1
   \   00000092   0xEEF1 0xFA10      FMSTAT   
   \   00000096   0xBFA4             ITT      GE 
    947                   {
    948                        t2_on = t2_on / t1_on;
   \   00000098   0xEE80 0x0A01      VDIVGE.F32 S0,S0,S2
    949                        t1_on = F_OVERMODULATION_THR;
   \   0000009C   0xEEB7 0x1A00      VMOVGE.F32 S2,#1.0
    950                   }
    951          #if (PWM_DUTY_LIMITATION == ENABLED)
    952                   if (t2_on > F_DUTY_LIMIT_MID)
   \   000000A0   0xEDDF 0x....      VLDR.W   S1,??DataTable114_1  ;; 0x3f6b8520
   \   000000A4   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   000000A8   0xEEF1 0xFA10      FMSTAT   
   \   000000AC   0xDB14             BLT.N    ??PwmModulation__SpaceVectorModulationRectangul_15
    953                   {
    954                     t2_on = F_DUTY_LIMIT_MID;
   \   000000AE   0xED9F 0x....      VLDR.W   S0,??DataTable114_2  ;; 0x3f6b851f
   \   000000B2   0xE011             B.N      ??PwmModulation__SpaceVectorModulationRectangul_15
    955                   }
    956                  #if (PWM_DUTY_BOOTSTRAP_LIMITATION == ENABLED)
    957                   if (t1_on > F_DUTY_LIMIT_MID)
    958                   {
    959                     t1_on = F_DUTY_LIMIT_MID;
    960                   }
    961                  #endif
    962          #endif
    963               }
    964               else
    965               {
    966                   if (t2_on > F_OVERMODULATION_THR)
   \                     ??PwmModulation__SpaceVectorModulationRectangul_14: (+1)
   \   000000B4   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   000000B8   0xEEF1 0xFA10      FMSTAT   
   \   000000BC   0xBFA4             ITT      GE 
    967                   {
    968                        t1_on = t1_on / t2_on;
   \   000000BE   0xEE81 0x1A00      VDIVGE.F32 S2,S2,S0
    969                        t2_on = F_OVERMODULATION_THR;
   \   000000C2   0xEEB7 0x0A00      VMOVGE.F32 S0,#1.0
    970                   }
    971          #if (PWM_DUTY_LIMITATION == ENABLED)
    972                   if (t1_on > F_DUTY_LIMIT_MID)
   \   000000C6   0xEDDF 0x....      VLDR.W   S1,??DataTable114_1  ;; 0x3f6b8520
   \   000000CA   0xEEB4 0x1A60      VCMP.F32 S2,S1
   \   000000CE   0xEEF1 0xFA10      FMSTAT   
   \   000000D2   0xBFA8             IT       GE 
    973                   {
    974                     t1_on = F_DUTY_LIMIT_MID;
   \   000000D4   0xED9F 0x....      VLDRGE.W S2,??DataTable114_2  ;; 0x3f6b851f
    975                   }
    976                   #if (PWM_DUTY_BOOTSTRAP_LIMITATION == ENABLED)
    977                   if (t2_on > F_DUTY_LIMIT_MID)
    978                   {
    979                     t2_on = F_DUTY_LIMIT_MID;
    980                   }
    981                  #endif
    982          #endif
    983               }
    984          
    985               switch(sector)
   \                     ??PwmModulation__SpaceVectorModulationRectangul_15: (+1)
   \   000000D8   0x2801             CMP      R0,#+1
   \   000000DA   0xD004             BEQ.N    ??PwmModulation__SpaceVectorModulationRectangul_16
   \   000000DC   0xD31C             BCC.N    ??PwmModulation__SpaceVectorModulationRectangul_17
   \   000000DE   0x2803             CMP      R0,#+3
   \   000000E0   0xD00F             BEQ.N    ??PwmModulation__SpaceVectorModulationRectangul_18
   \   000000E2   0xD305             BCC.N    ??PwmModulation__SpaceVectorModulationRectangul_19
   \   000000E4   0xE018             B.N      ??PwmModulation__SpaceVectorModulationRectangul_17
    986               {
    987                   case 1:
    988                   {
    989                       // Sectors I - II
    990                       v_abc_out->A = t1_on;
   \                     ??PwmModulation__SpaceVectorModulationRectangul_16: (+1)
   \   000000E6   0xEEF0 0x0A41      VMOV.F32 S1,S2
    991                       v_abc_out->B = t2_on;
   \   000000EA   0xEEB0 0x1A40      VMOV.F32 S2,S0
    992                       v_abc_out->C = 0;
   \   000000EE   0xE017             B.N      ??PwmModulation__SpaceVectorModulationRectangul_20
    993                       break;
    994                   }
    995                   case 2:
    996                   {
    997                       // Sectors III - IV
    998                       v_abc_out->A = 0;
    999                       v_abc_out->B = t1_on;
   1000                       v_abc_out->C = t2_on;
   1001                       break;
   1002                   }
   1003                   case 3:
   1004                   {
   1005                       // Sectors V - VI
   1006                       v_abc_out->A = t1_on;
   1007                       v_abc_out->B = 0;
   1008                       v_abc_out->C = t2_on;
   1009                       break;
   1010                   }
   1011                   default:
   1012                   {
   1013                       v_abc_out->A = 0;
   1014                       v_abc_out->B = 0;
   1015                       v_abc_out->C = 0;
   1016                       break;
   \                     ??PwmModulation__SpaceVectorModulationRectangul_19: (+1)
   \   000000F0   0xED81 0x0A02      VSTR     S0,[R1, #+8]
   \   000000F4   0xEDDF 0x....      VLDR.W   S1,??DataTable114  ;; 0x0
   \   000000F8   0xED81 0x1A01      VSTR     S2,[R1, #+4]
   \   000000FC   0xEDC1 0x0A00      VSTR     S1,[R1, #0]
   1017                   }
   1018               }
   1019          
   1020               return sector;
   \   00000100   0x4770             BX       LR
   \                     ??PwmModulation__SpaceVectorModulationRectangul_18: (+1)
   \   00000102   0xEEF0 0x0A41      VMOV.F32 S1,S2
   \   00000106   0xED9F 0x....      VLDR.W   S2,??DataTable114  ;; 0x0
   \   0000010A   0xED81 0x0A02      VSTR     S0,[R1, #+8]
   \   0000010E   0xED81 0x1A01      VSTR     S2,[R1, #+4]
   \   00000112   0xEDC1 0x0A00      VSTR     S1,[R1, #0]
   \   00000116   0x4770             BX       LR
   \                     ??PwmModulation__SpaceVectorModulationRectangul_17: (+1)
   \   00000118   0xEDDF 0x....      VLDR.W   S1,??DataTable114  ;; 0x0
   \   0000011C   0xED9F 0x....      VLDR.W   S2,??DataTable114  ;; 0x0
   \                     ??PwmModulation__SpaceVectorModulationRectangul_20: (+1)
   \   00000120   0xED9F 0x....      VLDR.W   S0,??DataTable114  ;; 0x0
   \   00000124   0xED81 0x0A02      VSTR     S0,[R1, #+8]
   \   00000128   0xED81 0x1A01      VSTR     S2,[R1, #+4]
   \   0000012C   0xEDC1 0x0A00      VSTR     S1,[R1, #0]
   \   00000130   0x4770             BX       LR               ;; return
   1021          }

   \                                 In section .bss, align 4
   \                     ??vs_alpha_beta_comp_1:
   \   00000000                      DS8 12
   1022          
   1023          

   \                                 In section .text, align 4, keep-with-next
   1024          void PwmModulation__InverterLossCompF(ABC_COOR_SYST_F_TYPE *i_abc_in, ABC_COOR_SYST_F_TYPE *duty, MATHCALC_LUT_EXT_F_TYPE *inverter_loss_params)
   1025          {
   \                     PwmModulation__InverterLossCompF: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0xED2D 0x8B02      VPUSH    {D8}
   1026              float32 duty_cycle;
   1027              // check for 0% or 100% duties
   1028              if ((duty->A != 0) && (duty->A != F_DUTY_100))
   \   00000008   0xED95 0x8A00      VLDR     S16,[R5, #0]
   \   0000000C   0xEEB5 0x8A40      VCMP.F32 S16,#0.0
   \   00000010   0x4604             MOV      R4,R0
   \   00000012   0x4616             MOV      R6,R2
   \   00000014   0xEEF1 0xFA10      FMSTAT   
   \   00000018   0xBF1E             ITTT     NE 
   \   0000001A   0xEEB7 0x0A00      VMOVNE.F32 S0,#1.0
   \   0000001E   0xEEB4 0x8A40      VCMPNE.F32 S16,S0
   \   00000022   0xEEF1 0xFA10      FMSTATNE 
   \   00000026   0xD019             BEQ.N    ??PwmModulation__InverterLossCompF_0
   1029              {
   1030                  duty_cycle = duty->A;
   1031                  duty_cycle += MathCalc__GetInterpolationFastF(i_abc_in->A, inverter_loss_params);
   \   00000028   0x4630             MOV      R0,R6
   \   0000002A   0xED94 0x0A00      VLDR     S0,[R4, #0]
   \   0000002E   0x.... 0x....      BL       MathCalc__GetInterpolationFastF
   \   00000032   0xEE38 0x0A00      VADD.F32 S0,S16,S0
   1032                  duty->A = MATHCALC__SATURATE_DIRECT(0, duty_cycle, F_DUTY_100);
   \   00000036   0xEEF7 0x0A00      VMOV.F32 S1,#1.0
   \   0000003A   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000003E   0xEEF1 0xFA10      FMSTAT   
   \   00000042   0xBFA8             IT       GE 
   \   00000044   0xEEB7 0x0A00      VMOVGE.F32 S0,#1.0
   \   00000048   0xDA06             BGE.N    ??PwmModulation__InverterLossCompF_1
   \   0000004A   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000004E   0xEEF1 0xFA10      FMSTAT   
   \   00000052   0xBF98             IT       LS 
   \   00000054   0xED9F 0x....      VLDRLS.W S0,??DataTable114  ;; 0x0
   \                     ??PwmModulation__InverterLossCompF_1: (+1)
   \   00000058   0xED85 0x0A00      VSTR     S0,[R5, #0]
   1033              }
   1034          
   1035              if ((duty->B != 0) && (duty->B != F_DUTY_100))
   \                     ??PwmModulation__InverterLossCompF_0: (+1)
   \   0000005C   0xED95 0x8A01      VLDR     S16,[R5, #+4]
   \   00000060   0xEEB5 0x8A40      VCMP.F32 S16,#0.0
   \   00000064   0xEEF1 0xFA10      FMSTAT   
   \   00000068   0xBF1E             ITTT     NE 
   \   0000006A   0xEEB7 0x0A00      VMOVNE.F32 S0,#1.0
   \   0000006E   0xEEB4 0x8A40      VCMPNE.F32 S16,S0
   \   00000072   0xEEF1 0xFA10      FMSTATNE 
   \   00000076   0xD019             BEQ.N    ??PwmModulation__InverterLossCompF_2
   1036              {
   1037                  duty_cycle = duty->B;
   1038                  duty_cycle += MathCalc__GetInterpolationFastF(i_abc_in->B, inverter_loss_params);
   \   00000078   0x4630             MOV      R0,R6
   \   0000007A   0xED94 0x0A01      VLDR     S0,[R4, #+4]
   \   0000007E   0x.... 0x....      BL       MathCalc__GetInterpolationFastF
   \   00000082   0xEE38 0x0A00      VADD.F32 S0,S16,S0
   1039                  duty->B = MATHCALC__SATURATE_DIRECT(0, duty_cycle, F_DUTY_100);
   \   00000086   0xEEF7 0x0A00      VMOV.F32 S1,#1.0
   \   0000008A   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000008E   0xEEF1 0xFA10      FMSTAT   
   \   00000092   0xBFA8             IT       GE 
   \   00000094   0xEEB7 0x0A00      VMOVGE.F32 S0,#1.0
   \   00000098   0xDA06             BGE.N    ??PwmModulation__InverterLossCompF_3
   \   0000009A   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000009E   0xEEF1 0xFA10      FMSTAT   
   \   000000A2   0xBF98             IT       LS 
   \   000000A4   0xED9F 0x....      VLDRLS.W S0,??DataTable114  ;; 0x0
   \                     ??PwmModulation__InverterLossCompF_3: (+1)
   \   000000A8   0xED85 0x0A01      VSTR     S0,[R5, #+4]
   1040              }
   1041          
   1042              if ((duty->C != 0) && (duty->C != F_DUTY_100))
   \                     ??PwmModulation__InverterLossCompF_2: (+1)
   \   000000AC   0xED95 0x8A02      VLDR     S16,[R5, #+8]
   \   000000B0   0xEEB5 0x8A40      VCMP.F32 S16,#0.0
   \   000000B4   0xEEF1 0xFA10      FMSTAT   
   \   000000B8   0xBF1E             ITTT     NE 
   \   000000BA   0xEEB7 0x0A00      VMOVNE.F32 S0,#1.0
   \   000000BE   0xEEB4 0x8A40      VCMPNE.F32 S16,S0
   \   000000C2   0xEEF1 0xFA10      FMSTATNE 
   \   000000C6   0xD019             BEQ.N    ??PwmModulation__InverterLossCompF_4
   1043              {
   1044                  duty_cycle = duty->C;
   1045                  duty_cycle += MathCalc__GetInterpolationFastF(i_abc_in->C, inverter_loss_params);
   \   000000C8   0x4630             MOV      R0,R6
   \   000000CA   0xED94 0x0A02      VLDR     S0,[R4, #+8]
   \   000000CE   0x.... 0x....      BL       MathCalc__GetInterpolationFastF
   \   000000D2   0xEE38 0x0A00      VADD.F32 S0,S16,S0
   1046                  duty->C = MATHCALC__SATURATE_DIRECT(0, duty_cycle, F_DUTY_100);
   \   000000D6   0xEEF7 0x0A00      VMOV.F32 S1,#1.0
   \   000000DA   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   000000DE   0xEEF1 0xFA10      FMSTAT   
   \   000000E2   0xBFA8             IT       GE 
   \   000000E4   0xEEB7 0x0A00      VMOVGE.F32 S0,#1.0
   \   000000E8   0xDA06             BGE.N    ??PwmModulation__InverterLossCompF_5
   \   000000EA   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000000EE   0xEEF1 0xFA10      FMSTAT   
   \   000000F2   0xBF98             IT       LS 
   \   000000F4   0xED9F 0x....      VLDRLS.W S0,??DataTable114  ;; 0x0
   \                     ??PwmModulation__InverterLossCompF_5: (+1)
   \   000000F8   0xED85 0x0A02      VSTR     S0,[R5, #+8]
   1047              }
   1048          }
   \                     ??PwmModulation__InverterLossCompF_4: (+1)
   \   000000FC   0xECBD 0x8B02      VPOP     {D8}
   \   00000100   0xBD70             POP      {R4-R6,PC}       ;; return
   1049          
   1050          
   1051          /**
   1052           *  @brief      Deadtime compensation with linear current gradient - floating point
   1053           *  @details
   1054           *
   1055           *
   1056           *  Implemented equations:
   1057           *   \f[
   1058           *      \begin{aligned}
   1059           *         & V_{a-comp} = V_a+ sgn(I_a)\cdot deadtime\\
   1060           *         & V_{b-comp} = V_b+ sgn(I_b)\cdot deadtime\\
   1061           *         & V_{c-comp} = V_c+ sgn(I_c)\cdot deadtime\\
   1062           *      \end{aligned}
   1063           *    \f]
   1064           *  A smoothing linear equation is used in order to avoid discontinuities when current change sign
   1065           *  If the not-compensated duty is 100% or 0%, no correction is applied.
   1066           *
   1067           *  @param[in]      i_abc_in          = motor phase currents in abc components
   1068           *  @param[in-out]  duty              = PWM duties
   1069           */

   \                                 In section .text, align 4, keep-with-next
   1070          void PwmModulation__DeadtimeCompensationGradientF(ABC_COOR_SYST_F_TYPE* i_abc_in, ABC_COOR_SYST_F_TYPE* duty)
   1071          {
   1072              float32 duty_cycle;
   1073              float32 current_sat;
   1074          
   1075              ////////////// phase A ///////////////////////////
   1076              // check for 0% or 100% duties
   1077              if ((duty->A != 0) && (duty->A != F_DUTY_100))
   \                     PwmModulation__DeadtimeCompensationGradientF: (+1)
   \   00000000   0xED91 0x0A00      VLDR     S0,[R1, #0]
   \   00000004   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000008   0xEEF1 0xFA10      FMSTAT   
   \   0000000C   0xBF1E             ITTT     NE 
   \   0000000E   0xEEF7 0x0A00      VMOVNE.F32 S1,#1.0
   \   00000012   0xEEB4 0x0A60      VCMPNE.F32 S0,S1
   \   00000016   0xEEF1 0xFA10      FMSTATNE 
   \   0000001A   0xD02B             BEQ.N    ??PwmModulation__DeadtimeCompensationGradientF_0
   1078              {
   1079                  current_sat = MATHCALC__SATURATE_DIRECT(-DT_COMP_I_THR_REAL, i_abc_in->A, DT_COMP_I_THR_REAL);
   \   0000001C   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000020   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \   00000024   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   00000028   0xEEF1 0xFA10      FMSTAT   
   \   0000002C   0xBFA8             IT       GE 
   \   0000002E   0xEEF7 0x0A00      VMOVGE.F32 S1,#1.0
   \   00000032   0xDA08             BGE.N    ??PwmModulation__DeadtimeCompensationGradientF_1
   \   00000034   0xED9F 0x....      VLDR.W   S2,??DataTable115  ;; 0xbf7ffffe
   \   00000038   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   0000003C   0xEEF1 0xFA10      FMSTAT   
   \   00000040   0xBF48             IT       MI 
   \   00000042   0xEEFF 0x0A00      VMOVMI.F32 S1,#-1.0
   1080                  duty_cycle = duty->A;
   1081                  // calculation of the compensation factor
   1082                  duty_cycle += (DT_COMP_M_FLOAT * current_sat);
   \                     ??PwmModulation__DeadtimeCompensationGradientF_1: (+1)
   \   00000046   0xED9F 0x....      VLDR.W   S2,??DataTable115_1  ;; 0x3c83126f
   \   0000004A   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   1083          
   1084                  // assignment with 0% - 100% saturation
   1085                  duty->A = MATHCALC__SATURATE_DIRECT(0, duty_cycle, F_DUTY_100);
   \   0000004E   0xEEF7 0x0A00      VMOV.F32 S1,#1.0
   \   00000052   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000056   0xEEF1 0xFA10      FMSTAT   
   \   0000005A   0xBFA8             IT       GE 
   \   0000005C   0xEEB7 0x0A00      VMOVGE.F32 S0,#1.0
   \   00000060   0xDA06             BGE.N    ??PwmModulation__DeadtimeCompensationGradientF_2
   \   00000062   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000066   0xEEF1 0xFA10      FMSTAT   
   \   0000006A   0xBF98             IT       LS 
   \   0000006C   0xED9F 0x....      VLDRLS.W S0,??DataTable117  ;; 0x0
   \                     ??PwmModulation__DeadtimeCompensationGradientF_2: (+1)
   \   00000070   0xED81 0x0A00      VSTR     S0,[R1, #0]
   1086              }
   1087          
   1088              ////////////// phase B ///////////////////////////
   1089              // check for 0% or 100% duties
   1090              if ((duty->B != 0) && (duty->B != F_DUTY_100))
   \                     ??PwmModulation__DeadtimeCompensationGradientF_0: (+1)
   \   00000074   0xED91 0x0A01      VLDR     S0,[R1, #+4]
   \   00000078   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000007C   0xEEF1 0xFA10      FMSTAT   
   \   00000080   0xBF1E             ITTT     NE 
   \   00000082   0xEEF7 0x0A00      VMOVNE.F32 S1,#1.0
   \   00000086   0xEEB4 0x0A60      VCMPNE.F32 S0,S1
   \   0000008A   0xEEF1 0xFA10      FMSTATNE 
   \   0000008E   0xD02B             BEQ.N    ??PwmModulation__DeadtimeCompensationGradientF_3
   1091              {
   1092                  current_sat = MATHCALC__SATURATE_DIRECT(-DT_COMP_I_THR_REAL, i_abc_in->B, DT_COMP_I_THR_REAL);
   \   00000090   0xEDD0 0x0A01      VLDR     S1,[R0, #+4]
   \   00000094   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \   00000098   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   0000009C   0xEEF1 0xFA10      FMSTAT   
   \   000000A0   0xBFA8             IT       GE 
   \   000000A2   0xEEF7 0x0A00      VMOVGE.F32 S1,#1.0
   \   000000A6   0xDA08             BGE.N    ??PwmModulation__DeadtimeCompensationGradientF_4
   \   000000A8   0xED9F 0x....      VLDR.W   S2,??DataTable115  ;; 0xbf7ffffe
   \   000000AC   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   000000B0   0xEEF1 0xFA10      FMSTAT   
   \   000000B4   0xBF48             IT       MI 
   \   000000B6   0xEEFF 0x0A00      VMOVMI.F32 S1,#-1.0
   1093                  duty_cycle = duty->B;
   1094                  // calculation of the compensation factor
   1095                  duty_cycle += (DT_COMP_M_FLOAT * current_sat);
   \                     ??PwmModulation__DeadtimeCompensationGradientF_4: (+1)
   \   000000BA   0xED9F 0x....      VLDR.W   S2,??DataTable115_1  ;; 0x3c83126f
   \   000000BE   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   1096          
   1097                  // assignment with 0% - 100% saturation
   1098                  duty->B = MATHCALC__SATURATE_DIRECT(0, duty_cycle, F_DUTY_100);
   \   000000C2   0xEEF7 0x0A00      VMOV.F32 S1,#1.0
   \   000000C6   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   000000CA   0xEEF1 0xFA10      FMSTAT   
   \   000000CE   0xBFA8             IT       GE 
   \   000000D0   0xEEB7 0x0A00      VMOVGE.F32 S0,#1.0
   \   000000D4   0xDA06             BGE.N    ??PwmModulation__DeadtimeCompensationGradientF_5
   \   000000D6   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000000DA   0xEEF1 0xFA10      FMSTAT   
   \   000000DE   0xBF98             IT       LS 
   \   000000E0   0xED9F 0x....      VLDRLS.W S0,??DataTable117  ;; 0x0
   \                     ??PwmModulation__DeadtimeCompensationGradientF_5: (+1)
   \   000000E4   0xED81 0x0A01      VSTR     S0,[R1, #+4]
   1099              }
   1100          
   1101              ////////////// phase C ///////////////////////////
   1102              // check for 0% or 100% duties
   1103              if ((duty->C != 0) && (duty->C != F_DUTY_100))
   \                     ??PwmModulation__DeadtimeCompensationGradientF_3: (+1)
   \   000000E8   0xED91 0x0A02      VLDR     S0,[R1, #+8]
   \   000000EC   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000000F0   0xEEF1 0xFA10      FMSTAT   
   \   000000F4   0xBF1E             ITTT     NE 
   \   000000F6   0xEEF7 0x0A00      VMOVNE.F32 S1,#1.0
   \   000000FA   0xEEB4 0x0A60      VCMPNE.F32 S0,S1
   \   000000FE   0xEEF1 0xFA10      FMSTATNE 
   \   00000102   0xD02B             BEQ.N    ??PwmModulation__DeadtimeCompensationGradientF_6
   1104              {
   1105                  current_sat = MATHCALC__SATURATE_DIRECT(-DT_COMP_I_THR_REAL, i_abc_in->C, DT_COMP_I_THR_REAL);
   \   00000104   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   00000108   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \   0000010C   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   00000110   0xEEF1 0xFA10      FMSTAT   
   \   00000114   0xBFA8             IT       GE 
   \   00000116   0xEEF7 0x0A00      VMOVGE.F32 S1,#1.0
   \   0000011A   0xDA08             BGE.N    ??PwmModulation__DeadtimeCompensationGradientF_7
   \   0000011C   0xED9F 0x....      VLDR.W   S2,??DataTable115  ;; 0xbf7ffffe
   \   00000120   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   00000124   0xEEF1 0xFA10      FMSTAT   
   \   00000128   0xBF48             IT       MI 
   \   0000012A   0xEEFF 0x0A00      VMOVMI.F32 S1,#-1.0
   1106                  duty_cycle = duty->C;
   1107                  // calculation of the compensation factor
   1108                  duty_cycle += (DT_COMP_M_FLOAT * current_sat);
   \                     ??PwmModulation__DeadtimeCompensationGradientF_7: (+1)
   \   0000012E   0xED9F 0x....      VLDR.W   S2,??DataTable115_1  ;; 0x3c83126f
   \   00000132   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   1109          
   1110                  // assignment with 0% - 100% saturation
   1111                  duty->C = MATHCALC__SATURATE_DIRECT(0, duty_cycle, F_DUTY_100);
   \   00000136   0xEEF7 0x0A00      VMOV.F32 S1,#1.0
   \   0000013A   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000013E   0xEEF1 0xFA10      FMSTAT   
   \   00000142   0xBFA8             IT       GE 
   \   00000144   0xEEB7 0x0A00      VMOVGE.F32 S0,#1.0
   \   00000148   0xDA06             BGE.N    ??PwmModulation__DeadtimeCompensationGradientF_8
   \   0000014A   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000014E   0xEEF1 0xFA10      FMSTAT   
   \   00000152   0xBF98             IT       LS 
   \   00000154   0xED9F 0x....      VLDRLS.W S0,??DataTable117  ;; 0x0
   \                     ??PwmModulation__DeadtimeCompensationGradientF_8: (+1)
   \   00000158   0xED81 0x0A02      VSTR     S0,[R1, #+8]
   1112              }
   1113          }
   \                     ??PwmModulation__DeadtimeCompensationGradientF_6: (+1)
   \   0000015C   0x4770             BX       LR               ;; return
   1114          
   1115          
   1116          

   \                                 In section .text, align 4, keep-with-next
   1117          uint8 PwmModulation__SpaceVectorModulationSixSteps(float32 v_dc, ALPHA_BETA_COOR_SYST_F_TYPE* v_alphabeta_in, ABC_COOR_SYST_F_TYPE* v_abc_out)
   1118          {
   \                     PwmModulation__SpaceVectorModulationSixSteps: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1119              uint8   sector = 0;
   1120              ALPHA_BETA_COOR_SYST_F_TYPE     Vs_Alpha_Beta_Comp;
   1121              float32 x;
   1122              float32 y;
   1123              float32 z;
   1124              float32 t1;
   1125              float32 t2;
   1126              float32 tsum;
   1127              float32 t0_on;
   1128              float32 t1_on;
   1129              float32 t2_on;
   1130              float32 arg_tmp;
   1131              float32 mindex;
   1132          
   1133              x = SQRT3 / v_dc; // just used as temporary variable to optimize division
   \   00000004   0xEDDF 0x....      VLDR.W   S1,??DataTable119  ;; 0x3fddb3d7
   \   00000008   0xED2D 0x8B04      VPUSH    {D8-D9}
   \   0000000C   0xEE80 0x0A80      VDIV.F32 S0,S1,S0
   1134          
   1135              /* Ripple compensation */
   1136              Vs_Alpha_Beta_Comp.Alpha = v_alphabeta_in->Alpha * x;
   \   00000010   0xEDD0 0x0A01      VLDR     S1,[R0, #+4]
   1137              Vs_Alpha_Beta_Comp.Beta = v_alphabeta_in->Beta * x;
   \   00000014   0xED90 0x1A02      VLDR     S2,[R0, #+8]
   \   00000018   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   0000001C   0xEE21 0x8A00      VMUL.F32 S16,S2,S0
   1138          
   1139              mindex = MC_SQRT_F(Vs_Alpha_Beta_Comp.Alpha* Vs_Alpha_Beta_Comp.Alpha + Vs_Alpha_Beta_Comp.Beta * Vs_Alpha_Beta_Comp.Beta);
   \   00000020   0xEE20 0x0AA0      VMUL.F32 S0,S1,S1
   \   00000024   0xEE08 0x0A08      VMLA.F32 S0,S16,S16
   \   00000028   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000002C   0x460C             MOV      R4,R1
   \   0000002E   0xEEF1 0xFA10      FMSTAT   
   \   00000032   0xDB02             BLT.N    ??PwmModulation__SpaceVectorModulationSixSteps_1
   \   00000034   0xEEF1 0x8AC0      VSQRT.F32 S17,S0
   \   00000038   0xE001             B.N      ??PwmModulation__SpaceVectorModulationSixSteps_2
   \                     ??PwmModulation__SpaceVectorModulationSixSteps_1: (+1)
   \   0000003A   0xEDDF 0x....      VLDR.W   S17,??DataTable117  ;; 0x0
   1140              /* X, Y, Z calculation */
   1141              x = Vs_Alpha_Beta_Comp.Beta;
   1142          
   1143              y = Vs_Alpha_Beta_Comp.Alpha * F_SQRT3_OVER_TWO;
   1144              y = y + (Vs_Alpha_Beta_Comp.Beta / 2);
   \                     ??PwmModulation__SpaceVectorModulationSixSteps_2: (+1)
   \   0000003E   0xEEB6 0x0A00      VMOV.F32 S0,#0.5
   \   00000042   0xEE28 0x0A00      VMUL.F32 S0,S16,S0
   \   00000046   0xEDDF 0x....      VLDR.W   S3,??DataTable119_1  ;; 0x3f5db3d7
   \   0000004A   0xEEB0 0x1A40      VMOV.F32 S2,S0
   \   0000004E   0xEE00 0x1AA1      VMLA.F32 S2,S1,S3
   1145          
   1146              z = -Vs_Alpha_Beta_Comp.Alpha * F_SQRT3_OVER_TWO;
   1147              z = z + (Vs_Alpha_Beta_Comp.Beta / 2);
   \   00000052   0xEDDF 0x....      VLDR.W   S3,??DataTable119_2  ;; 0xbf5db3d7
   1148          
   1149              // sector identification
   1150              if (x>=0)
   \   00000056   0xEEB5 0x8A40      VCMP.F32 S16,#0.0
   \   0000005A   0xEE00 0x0AA1      VMLA.F32 S0,S1,S3
   \   0000005E   0xEEF1 0xFA10      FMSTAT   
   \   00000062   0xDB1C             BLT.N    ??PwmModulation__SpaceVectorModulationSixSteps_3
   1151              {
   1152                  // sector 1,2,3,7
   1153                  if (y>0)
   \   00000064   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   00000068   0xEEF1 0xFA10      FMSTAT   
   \   0000006C   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000070   0xDD0E             BLE.N    ??PwmModulation__SpaceVectorModulationSixSteps_4
   1154                  {
   1155                      // sector 1,2
   1156                      if (z<=0)
   \   00000072   0xEEF1 0xFA10      FMSTAT   
   \   00000076   0xD805             BHI.N    ??PwmModulation__SpaceVectorModulationSixSteps_5
   1157                      {
   1158                          // sector 1
   1159                          sector = 1;
   1160                          t1 = x;
   \   00000078   0xEEB0 0x9A48      VMOV.F32 S18,S16
   \   0000007C   0x2501             MOVS     R5,#+1
   1161                          t2 = -z;
   \   0000007E   0xEEB1 0x8A40      VNEG.F32 S16,S0
   \   00000082   0xE027             B.N      ??PwmModulation__SpaceVectorModulationSixSteps_6
   1162                      }
   1163                      else
   1164                      {
   1165                          // sector 2
   1166                          sector = 2;
   \                     ??PwmModulation__SpaceVectorModulationSixSteps_5: (+1)
   \   00000084   0x2502             MOVS     R5,#+2
   1167                          t1 = y;
   \   00000086   0xEEB0 0x9A41      VMOV.F32 S18,S2
   1168                          t2 = z;
   \   0000008A   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000008E   0xE021             B.N      ??PwmModulation__SpaceVectorModulationSixSteps_6
   1169                      }
   1170                  }
   1171                  else
   1172                  {
   1173                      // sector 3,7
   1174                      if (z>0)
   \                     ??PwmModulation__SpaceVectorModulationSixSteps_4: (+1)
   \   00000090   0xEEF1 0xFA10      FMSTAT   
   \   00000094   0xDD13             BLE.N    ??PwmModulation__SpaceVectorModulationSixSteps_7
   1175                      {
   1176                          // sector 3
   1177                          sector = 3;
   \   00000096   0x2503             MOVS     R5,#+3
   1178                          t1 = -y;
   \   00000098   0xEEB1 0x9A41      VNEG.F32 S18,S2
   1179                          t2 = x;
   \   0000009C   0xE01A             B.N      ??PwmModulation__SpaceVectorModulationSixSteps_6
   1180                      }
   1181                      else
   1182                      {
   1183                          // sector 7 --> 6
   1184                          sector = 6;
   1185                          t1 = -x;
   1186                          t2 = y;
   1187                      }
   1188                  }
   1189              }
   1190              else
   1191              {
   1192                  // sector 4,5,6
   1193                  if (z>0)
   \                     ??PwmModulation__SpaceVectorModulationSixSteps_3: (+1)
   \   0000009E   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000000A2   0xEEF1 0xFA10      FMSTAT   
   \   000000A6   0xDD05             BLE.N    ??PwmModulation__SpaceVectorModulationSixSteps_8
   1194                  {
   1195                     // sector 4
   1196                     sector = 4;
   \   000000A8   0x2504             MOVS     R5,#+4
   1197                     t1 = z;
   \   000000AA   0xEEB0 0x9A40      VMOV.F32 S18,S0
   1198                     t2 = -x;
   \   000000AE   0xEEB1 0x8A48      VNEG.F32 S16,S16
   \   000000B2   0xE00F             B.N      ??PwmModulation__SpaceVectorModulationSixSteps_6
   1199                  }
   1200                  else
   1201                  {
   1202                      if (y>0)
   \                     ??PwmModulation__SpaceVectorModulationSixSteps_8: (+1)
   \   000000B4   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   000000B8   0xEEF1 0xFA10      FMSTAT   
   \   000000BC   0xDD05             BLE.N    ??PwmModulation__SpaceVectorModulationSixSteps_9
   1203                      {
   1204                          // sector 6
   1205                          sector = 6;
   1206                          t1 = -x;
   \                     ??PwmModulation__SpaceVectorModulationSixSteps_7: (+1)
   \   000000BE   0xEEB1 0x9A48      VNEG.F32 S18,S16
   \   000000C2   0x2506             MOVS     R5,#+6
   1207                          t2 = y;
   \   000000C4   0xEEB0 0x8A41      VMOV.F32 S16,S2
   \   000000C8   0xE004             B.N      ??PwmModulation__SpaceVectorModulationSixSteps_6
   1208                      }
   1209                      else
   1210                      {
   1211                          // sector 5
   1212                          sector = 5;
   \                     ??PwmModulation__SpaceVectorModulationSixSteps_9: (+1)
   \   000000CA   0x2505             MOVS     R5,#+5
   1213                          t1 = -z;
   \   000000CC   0xEEB1 0x9A40      VNEG.F32 S18,S0
   1214                          t2 = -y;
   \   000000D0   0xEEB1 0x8A41      VNEG.F32 S16,S2
   1215                      }
   1216                  }
   1217              }
   1218          
   1219          
   1220              // Over-modulation
   1221              tsum = t1 + t2;
   \                     ??PwmModulation__SpaceVectorModulationSixSteps_6: (+1)
   \   000000D4   0xEE39 0x0A08      VADD.F32 S0,S18,S16
   1222              if (tsum > F_OVERMODULATION_THR)
   \   000000D8   0xEDDF 0x....      VLDR.W   S1,??DataTable119_3  ;; 0x3f800001
   \   000000DC   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   000000E0   0xEEF1 0xFA10      FMSTAT   
   \   000000E4   0xDB38             BLT.N    ??PwmModulation__SpaceVectorModulationSixSteps_10
   1223              {
   1224                  if (mindex < 1.1547f)
   \   000000E6   0xED9F 0x....      VLDR.W   S0,??DataTable119_4  ;; 0x3f93cd36
   \   000000EA   0xEEF4 0x8A40      VCMP.F32 S17,S0
   \   000000EE   0xEEF1 0xFA10      FMSTAT   
   \   000000F2   0xEEB7 0x0A00      VMOV.F32 S0,#1.0
   \   000000F6   0xD51F             BPL.N    ??PwmModulation__SpaceVectorModulationSixSteps_11
   1225                  {
   1226                     arg_tmp = asinf(1/mindex) + PI/3.0f;
   \   000000F8   0xEE80 0x0A28      VDIV.F32 S0,S0,S17
   \   000000FC   0x.... 0x....      BL       asinf
   1227                     arg_tmp = mindex * MathCalc__SinF(arg_tmp);
   \   00000100   0xEDDF 0x....      VLDR.W   S1,??DataTable119_5  ;; 0x3f860a92
   \   00000104   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   00000108   0x.... 0x....      BL       MathCalc__SinF
   \   0000010C   0xEE28 0x0A80      VMUL.F32 S0,S17,S0
   1228                     if (t1>t2)
   \   00000110   0xEEF7 0x0A00      VMOV.F32 S1,#1.0
   \   00000114   0xEEB4 0x8A49      VCMP.F32 S16,S18
   \   00000118   0xEE70 0x0AC0      VSUB.F32 S1,S1,S0
   \   0000011C   0xEEF1 0xFA10      FMSTAT   
   \   00000120   0xBF59             ITTEE    PL 
   1229                     {
   1230                         t1 = arg_tmp;
   1231                         t2 = 1 - arg_tmp;
   1232                     }
   1233                     else
   1234                     {
   1235                         t2 = arg_tmp;
   \   00000122   0xEEB0 0x8A40      VMOVPL.F32 S16,S0
   1236                         t1 = 1 - arg_tmp;
   \   00000126   0xEEB0 0x9A60      VMOVPL.F32 S18,S1
   1237                     }
   \   0000012A   0xEEB0 0x9A40      VMOVMI.F32 S18,S0
   \   0000012E   0xEEB0 0x8A60      VMOVMI.F32 S16,S1
   1238                  }
   1239                  else
   1240                  {
   1241                      if (t1>t2)
   1242                      {
   1243                          t1 = 1.0f;
   1244                          t2 = 0;
   1245                      }
   1246                      else
   1247                      {
   1248                          t2 = 1.0f;
   1249                          t1 = 0;
   1250                      }
   1251                  }
   1252                  t0_on = 0;
   \   00000132   0xEDDF 0x....      VLDR.W   S1,??DataTable117  ;; 0x0
   \   00000136   0xE015             B.N      ??PwmModulation__SpaceVectorModulationSixSteps_12
   \                     ??PwmModulation__SpaceVectorModulationSixSteps_11: (+1)
   \   00000138   0xEEB4 0x8A49      VCMP.F32 S16,S18
   \   0000013C   0xEEF1 0xFA10      FMSTAT   
   \   00000140   0xBF47             ITTEE    MI 
   \   00000142   0xEEB0 0x9A40      VMOVMI.F32 S18,S0
   \   00000146   0xED9F 0x....      VLDRMI.W S16,??DataTable117  ;; 0x0
   \   0000014A   0xEEB0 0x8A40      VMOVPL.F32 S16,S0
   \   0000014E   0xED9F 0x....      VLDRPL.W S18,??DataTable117  ;; 0x0
   \   00000152   0xEDDF 0x....      VLDR.W   S1,??DataTable117  ;; 0x0
   \   00000156   0xE005             B.N      ??PwmModulation__SpaceVectorModulationSixSteps_12
   1253              }
   1254              else
   1255              {
   1256                  // T0_on = 0.5 - 0.5*(T1+T2);
   1257                  t0_on = F_ONE_OVER_TWO - (tsum / 2);
   \                     ??PwmModulation__SpaceVectorModulationSixSteps_10: (+1)
   \   00000158   0xEEB6 0x1A00      VMOV.F32 S2,#0.5
   \   0000015C   0xEEF6 0x0A00      VMOV.F32 S1,#0.5
   \   00000160   0xEE40 0x0A41      VMLS.F32 S1,S0,S2
   1258              }
   1259          
   1260              /*
   1261              T0_on = 0.5 - 0.5*(T1+T2);
   1262              T1_on = T1 + T0_on;
   1263              T2_on = T2 + T1_on;
   1264              */
   1265              t1_on = t1 + t0_on;
   \                     ??PwmModulation__SpaceVectorModulationSixSteps_12: (+1)
   \   00000164   0xEE39 0x0A20      VADD.F32 S0,S18,S1
   1266              t2_on = t2 + t1_on;
   1267          
   1268            /* ****** DUTY LIMITATIONS ***** */
   1269          #if (PWM_DUTY_LIMITATION == ENABLED)
   1270              if (t1_on > F_DUTY_LIMIT_MID)
   \   00000168   0xEDDF 0x....      VLDR.W   S3,??DataTable119_6  ;; 0x3f6b8520
   \   0000016C   0xEEB4 0x0A61      VCMP.F32 S0,S3
   \   00000170   0xEE38 0x1A00      VADD.F32 S2,S16,S0
   \   00000174   0xEEF1 0xFA10      FMSTAT   
   \   00000178   0xBFA8             IT       GE 
   1271              {
   1272                t1_on = F_DUTY_LIMIT_MID;
   \   0000017A   0xED9F 0x....      VLDRGE.W S0,??DataTable119_7  ;; 0x3f6b851f
   1273              }
   1274          
   1275              #if (PWM_DUTY_BOOTSTRAP_LIMITATION == ENABLED)
   1276              if (t2_on > F_DUTY_LIMIT_MID)
   1277              {
   1278                t2_on = F_DUTY_LIMIT_MID;
   1279              }
   1280          
   1281              #elif (PWM_DUTY_ANTI_GLITCH_LIMITATION == ENABLED)
   1282              #if (PWM_DUTY_BOOTSTRAP_LIMITATION == DISABLED)
   1283              // Higher anti-glitch limitation makes sense only if just t1_on is limited
   1284              if (t2_on > F_DUTY_ANTI_GLITCH_UPPER)
   \   0000017E   0xEDDF 0x....      VLDR.W   S3,??DataTable119_8  ;; 0x3f70a3d8
   \   00000182   0xEEB4 0x1A61      VCMP.F32 S2,S3
   \   00000186   0xEEF1 0xFA10      FMSTAT   
   \   0000018A   0xBFA8             IT       GE 
   1285              {
   1286                  t2_on = F_DUTY_100;
   \   0000018C   0xEEB7 0x1A00      VMOVGE.F32 S2,#1.0
   1287              }
   1288              #endif
   1289          
   1290              if (t0_on < F_DUTY_ANTI_GLITCH_LOWER)
   \   00000190   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   00000194   0xEEF1 0xFA10      FMSTAT   
   \   00000198   0xBF48             IT       MI 
   1291              {
   1292                  t0_on = 0;
   \   0000019A   0xEDDF 0x....      VLDRMI.W S1,??DataTable117  ;; 0x0
   1293              }
   1294              #endif
   1295          
   1296          #endif
   1297              /* ****** ********* ***** */
   1298          
   1299          
   1300              // duty calculation
   1301              switch (sector)
   \   0000019E   0x1E68             SUBS     R0,R5,#+1
   \   000001A0   0x2805             CMP      R0,#+5
   \   000001A2   0xD82A             BHI.N    ??PwmModulation__SpaceVectorModulationSixSteps_13
   \   000001A4   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??PwmModulation__SpaceVectorModulationSixSteps_0:
   \   000001A8   0x03 0x08          DC8      0x3,0x8,0xD,0x14
   \              0x0D 0x14    
   \   000001AC   0x1B 0x22          DC8      0x1B,0x22
   1302              {
   1303               case 1:
   1304                   v_abc_out->A = t2_on;
   \                     ??PwmModulation__SpaceVectorModulationSixSteps_14: (+1)
   \   000001AE   0xEEF0 0x1A41      VMOV.F32 S3,S2
   1305                   v_abc_out->B = t1_on;
   \   000001B2   0xEEB0 0x2A40      VMOV.F32 S4,S0
   1306                   v_abc_out->C = t0_on;
   1307                   break;
   \   000001B6   0xE026             B.N      ??PwmModulation__SpaceVectorModulationSixSteps_15
   1308          
   1309               case 2:
   1310                   v_abc_out->A = t1_on;
   \                     ??PwmModulation__SpaceVectorModulationSixSteps_16: (+1)
   \   000001B8   0xEEF0 0x1A40      VMOV.F32 S3,S0
   1311                   v_abc_out->B = t2_on;
   \   000001BC   0xEEB0 0x2A41      VMOV.F32 S4,S2
   1312                   v_abc_out->C = t0_on;
   1313                   break;
   \   000001C0   0xE021             B.N      ??PwmModulation__SpaceVectorModulationSixSteps_15
   1314          
   1315               case 3:
   1316                   v_abc_out->A = t0_on;
   \                     ??PwmModulation__SpaceVectorModulationSixSteps_17: (+1)
   \   000001C2   0xEEF0 0x1A60      VMOV.F32 S3,S1
   1317                   v_abc_out->B = t2_on;
   \   000001C6   0xEEB0 0x2A41      VMOV.F32 S4,S2
   1318                   v_abc_out->C = t1_on;
   1319                   break;
   1320          
   1321               case 4:
   1322                   v_abc_out->A = t0_on;
   1323                   v_abc_out->B = t1_on;
   1324                   v_abc_out->C = t2_on;
   1325                   break;
   1326          
   1327               case 5:
   1328                   v_abc_out->A = t1_on;
   1329                   v_abc_out->B = t0_on;
   1330                   v_abc_out->C = t2_on;
   1331                   break;
   1332          
   1333               case 6:
   1334                   v_abc_out->A = t2_on;
   1335                   v_abc_out->B = t0_on;
   1336                   v_abc_out->C = t1_on;
   \   000001CA   0xEEF0 0x0A40      VMOV.F32 S1,S0
   1337                   break;
   \   000001CE   0xE01A             B.N      ??PwmModulation__SpaceVectorModulationSixSteps_15
   \                     ??PwmModulation__SpaceVectorModulationSixSteps_18: (+1)
   \   000001D0   0xEEF0 0x1A60      VMOV.F32 S3,S1
   \   000001D4   0xEEB0 0x2A40      VMOV.F32 S4,S0
   \   000001D8   0xEEF0 0x0A41      VMOV.F32 S1,S2
   \   000001DC   0xE013             B.N      ??PwmModulation__SpaceVectorModulationSixSteps_15
   \                     ??PwmModulation__SpaceVectorModulationSixSteps_19: (+1)
   \   000001DE   0xEEB0 0x2A60      VMOV.F32 S4,S1
   \   000001E2   0xEEF0 0x1A40      VMOV.F32 S3,S0
   \   000001E6   0xEEF0 0x0A41      VMOV.F32 S1,S2
   \   000001EA   0xE00C             B.N      ??PwmModulation__SpaceVectorModulationSixSteps_15
   \                     ??PwmModulation__SpaceVectorModulationSixSteps_20: (+1)
   \   000001EC   0xEEB0 0x2A60      VMOV.F32 S4,S1
   \   000001F0   0xEEF0 0x1A41      VMOV.F32 S3,S2
   \   000001F4   0xEEF0 0x0A40      VMOV.F32 S1,S0
   \   000001F8   0xE005             B.N      ??PwmModulation__SpaceVectorModulationSixSteps_15
   1338          
   1339               default:
   1340                   v_abc_out->A = 0;
   \                     ??PwmModulation__SpaceVectorModulationSixSteps_13: (+1)
   \   000001FA   0xEDDF 0x....      VLDR.W   S3,??DataTable117  ;; 0x0
   1341                   v_abc_out->B = 0;
   \   000001FE   0xED9F 0x....      VLDR.W   S4,??DataTable117  ;; 0x0
   1342                   v_abc_out->C = 0;
   \   00000202   0xEDDF 0x....      VLDR.W   S1,??DataTable117  ;; 0x0
   1343                   break;
   \                     ??PwmModulation__SpaceVectorModulationSixSteps_15: (+1)
   \   00000206   0xEDC4 0x0A02      VSTR     S1,[R4, #+8]
   \   0000020A   0xED84 0x2A01      VSTR     S4,[R4, #+4]
   \   0000020E   0xEDC4 0x1A00      VSTR     S3,[R4, #0]
   1344              }
   1345          
   1346              return (sector);
   \   00000212   0x4628             MOV      R0,R5
   \   00000214   0xECBD 0x8B04      VPOP     {D8-D9}
   \   00000218   0xB001             ADD      SP,SP,#+4
   \   0000021A   0xBD30             POP      {R4,R5,PC}       ;; return
   1347          
   1348          }
C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\Mcl\ResistanceEstimation\ResistanceEstimation.c
      1          /**
      2           *  @file       ResistanceDetection.c
      3           *  @brief      Basic description of file contents
      4           *
      5           *  @details    Detailed description of the file contents
      6           *
      7           *---------------------------------------------------------------------------------------------------------------------
      8           *------------------- Copyright 2016.  Whirlpool Corporation.  All rights reserved - CONFIDENTIAL ---------------------
      9           *---------------------------------------------------------------------------------------------------------------------
     10           */
     11          
     12          //-------------------------------------- Include Files ----------------------------------------------------------------
     13          #include "ResistanceEstimation.h"
     14          #include "MclConfig.h"
     15          #include "MathCalc.h"
     16          #include "Mci.h"
     17          #include "SpeedRefGen.h"
     18          
     19          
     20          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     21          
     22          
     23          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     24          #ifndef RPM_TO_RADS
     25              #define RPM_TO_RADS     0.10471975511965977461542144610932f
     26          #endif
     27          
     28          
     29          typedef enum
     30          {
     31              RES_EST_MEASURE_RESISTANCE_REQ = 0,                     //!< 0 - Request to measure resistance on next start
     32              RES_EST_MEASURE_ERROR          = 1,                     //!< 1 - Error occurs during resistanec estimation procedure
     33          } RES_EST_FLAGS_TYPE;
     34          
     35          /*
     36          typedef enum
     37          {
     38              RES_DETECT_INIT = 0,                            //!< 0
     39              RES_DETECT_RESISTANCE_ESTIMATED,                //!< 1
     40              RES_DETECT_WAIT_FOR_IDLE,                       //!< 2
     41              RES_DETECT_WAIT_PARK_TIME,                      //!< 3
     42              RES_DETECT_1ST_PLATEAU_WAIT,                    //!< 4
     43              RES_DETECT_SECOND_RAMP,                         //!< 5
     44              RES_DETECT_2ND_PLATEAU_WAIT,                    //!< 6
     45              RES_DETECT_THIRD_RAMP,                          //!< 7
     46              RES_DETECT_3RD_PLATEAU_WAIT,                    //!< 8
     47              RES_DETECT_CALCULATE_RESISTANCE                 //!< 9
     48          } RESISTANCE_ESTIMATION_TYPE;
     49          */
     50          
     51          // NEW
     52          typedef enum
     53          {
     54              RES_DETECT_INIT = 0,                            //!< 0
     55              RES_DETECT_WAIT_PARK_TIME,                      //!< 1
     56              RES_DETECT_1ST_PLATEAU_WAIT,                    //!< 2
     57              RES_DETECT_SECOND_RAMP,                         //!< 3
     58              RES_DETECT_2ND_PLATEAU_WAIT,                    //!< 4
     59              RES_DETECT_THIRD_RAMP,                          //!< 5
     60              RES_DETECT_3RD_PLATEAU_WAIT,                    //!< 6
     61              RES_DETECT_RESISTANCE_ESTIMATED,                //!< 7
     62          } RESISTANCE_ESTIMATION_TYPE;
     63          
     64          typedef enum
     65          {
     66                  RE_RATE_PATTERN_INITIALIZING = 0,
     67                  RE_RATE_PATTERN_WAITING_FIRST_START,
     68                  RE_RATE_PATTERN_AFTER_RESET,
     69                  RE_RATE_PATTERN_NORMAL,
     70                  RE_RATE_PATTERN_AFTER_SPIN,
     71          } RESISTANCE_ESTIMATION_FREQUENCY_TYPE;
     72          
     73          
     74          static RESISTANCE_ESTIMATION_FREQUENCY_TYPE Res_Measure_Rate_State;
     75          static RESISTANCE_ESTIMATION_TYPE Res_Est_State;
     76          static uint16 Res_Est_Flags;
     77          static float32 Estimated_Resistance;
     78          static float32 Last_Estimated_Resistance;
     79          static uint16 Speed_Oscillation_Debouncer;
     80          static uint32 Timer_To_Reset_Resistance;
     81          static float32 Voltage_Level;
     82          static uint16 Res_Frequency_Timer;
     83          static uint8 Res_Frequency_Counter;
     84          static uint8 Res_Frequency_Counter_Spin;
     85          
     86          static uint16 This_Timer;
     87          static uint16 This_Timeout;
     88          #if (FAST_RESISTANCE_CALC == ENABLED)
     89          static float32 Current_1st_Averaged;
     90          static float32 Voltage_1st_Averaged;
     91          static float32 Current_2nd_Averaged;
     92          static float32 Voltage_2nd_Averaged;
     93          #endif
     94          static uint8 Time_Prescaler;
     95          static sint16 Sample_Counter;
     96          static float32 Voltage_1st_Sum;
     97          static float32 Current_1st_Sum;
     98          static float32 Voltage_2nd_Sum;
     99          static float32 Current_2nd_Sum;
    100          static float32 Delta_Current_Nominal;
    101          
    102          
    103          #define RE_SET_FLOW(re_flag)                BIT_SET(Res_Est_Flags, (re_flag))
    104          #define RE_CLR_FLOW(re_flag)                BIT_CLR(Res_Est_Flags, (re_flag))
    105          #define RE_TEST_FLOW(re_flag)               BIT_TEST(Res_Est_Flags, (re_flag))
    106          
    107          
    108          //=====================================================================================================================
    109          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
    110          //=====================================================================================================================
    111          static void CalculateResistance(void);
    112          static void TimerDefinition(RES_EST_PARAM_TYPE *param);
    113          static void OscillationCheck(RES_EST_IO_TYPE *io, RES_EST_PARAM_TYPE *param);
    114          static uint8 OscillationCheckPassed(RES_EST_PARAM_TYPE *param);
    115          
    116          //=====================================================================================================================
    117          //-------------------------------------- Public Functions -------------------------------------------------------------
    118          //=====================================================================================================================
    119          
    120          
    121          /**
    122           *
    123              @startuml{Resistance Estimation State Machine.png}
    124          
    125                  title Resistance Estimation - State Machine
    126          
    127                  [*] --> 0_RES_DETECT_INIT
    128          
    129                  0_RES_DETECT_INIT : Waits until Resistance Estimation Start request is issued
    130                  0_RES_DETECT_INIT : Do / Keep voltage level to 0
    131                  0_RES_DETECT_INIT --> 1_RES_DETECT_WAIT_PARK_TIME : [Resistance Estimation Start request]
    132          
    133          
    134                  1_RES_DETECT_WAIT_PARK_TIME : Pump Voltage to generate the first current level
    135                  1_RES_DETECT_WAIT_PARK_TIME : Entry / Set the timer for first step and the timeout (RES_DETECT_WAIT_FOR_IDLE)
    136                  1_RES_DETECT_WAIT_PARK_TIME : Do / Increase the voltage level till reaching the first current level
    137                  1_RES_DETECT_WAIT_PARK_TIME : Exit /
    138                  1_RES_DETECT_WAIT_PARK_TIME --> 2_RES_DETECT_1ST_PLATEAU_WAIT   : [1st step current level reached and time expired]
    139                  1_RES_DETECT_WAIT_PARK_TIME --> MCI_FAILED : [timeout expired - current level not reached]
    140          
    141          
    142                  2_RES_DETECT_1ST_PLATEAU_WAIT : Start measuring (1st current step)
    143                  2_RES_DETECT_1ST_PLATEAU_WAIT : Entry / Reset the sample counter and voltage and current accumulators
    144                  2_RES_DETECT_1ST_PLATEAU_WAIT : Do / Start accumulating voltage and current samples after oscillation check
    145                  2_RES_DETECT_1ST_PLATEAU_WAIT : Exit /
    146                  2_RES_DETECT_1ST_PLATEAU_WAIT --> 3_RES_DETECT_SECOND_RAMP : [minimum number of samples reached]
    147                  2_RES_DETECT_1ST_PLATEAU_WAIT --> 7_RES_DETECT_RESISTANCE_ESTIMATED : [timeout expired - **__Resistance value not updated__**]
    148          
    149                  3_RES_DETECT_SECOND_RAMP : increase\decrease voltage level to reach the current second step
    150                  3_RES_DETECT_SECOND_RAMP : Entry / Calculate the current and voltage average on first step and set the timer for second step
    151                  3_RES_DETECT_SECOND_RAMP : Do / Increase\decrease the voltage level till reaching the second current level
    152                  3_RES_DETECT_SECOND_RAMP : Exit /
    153                  3_RES_DETECT_SECOND_RAMP --> 4_RES_DETECT_2ND_PLATEAU_WAIT   : [time expired and checked 2nd step current level reached]
    154                  3_RES_DETECT_SECOND_RAMP --> 7_RES_DETECT_RESISTANCE_ESTIMATED : [timeout expired - **__Resistance value not updated__**]
    155          
    156          
    157                  4_RES_DETECT_2ND_PLATEAU_WAIT : Start measuring (2nd current step)
    158                  4_RES_DETECT_2ND_PLATEAU_WAIT : Entry / Reset the sample counter and voltage and current accumulators
    159                  4_RES_DETECT_2ND_PLATEAU_WAIT : Do / Start accumulating voltage and current samples after oscillation check
    160                  4_RES_DETECT_2ND_PLATEAU_WAIT : Exit /
    161                  4_RES_DETECT_2ND_PLATEAU_WAIT --> 5_RES_DETECT_THIRD_RAMP : [minimum number of samples reached]
    162                  4_RES_DETECT_2ND_PLATEAU_WAIT --> 7_RES_DETECT_RESISTANCE_ESTIMATED : [timeout expired - **__Resistance value not updated__**]
    163          
    164          
    165                  5_RES_DETECT_THIRD_RAMP : **__Update resistance value on entry__** and decrease voltage level to reach the final current value
    166                  5_RES_DETECT_THIRD_RAMP : Entry / calculate the resistance value estimated by the procedure
    167                  5_RES_DETECT_THIRD_RAMP : Do / Decrease the voltage level till reaching the final current level
    168                  5_RES_DETECT_THIRD_RAMP : Exit /
    169                  5_RES_DETECT_THIRD_RAMP --> 6_RES_DETECT_3RD_PLATEAU_WAIT   : [final current level reached]
    170                  5_RES_DETECT_THIRD_RAMP --> 7_RES_DETECT_RESISTANCE_ESTIMATED : [timeout expired]
    171          
    172          
    173                  6_RES_DETECT_3RD_PLATEAU_WAIT : wait the time for 3rd current step
    174                  6_RES_DETECT_3RD_PLATEAU_WAIT : Entry / Set the timer value for the third step
    175                  6_RES_DETECT_3RD_PLATEAU_WAIT : Do /
    176                  6_RES_DETECT_3RD_PLATEAU_WAIT : Exit /
    177                  6_RES_DETECT_3RD_PLATEAU_WAIT --> 7_RES_DETECT_RESISTANCE_ESTIMATED : [timer expired or timeout expired]
    178          
    179          
    180                  MCI_FAILED : resistance estimation error (probably due to motor not connected)
    181          
    182          
    183          
    184          
    185          
    186              @enduml
    187           */
    188          
    189          
    190          
    191          
    192          
    193          
    194          
    195          //---------------------------------------------------------------------------------------------------------------------
    196          /**
    197           *  @brief      It Initializes the module ResistanceDetection and its variables
    198           *
    199           */

   \                                 In section .text, align 2, keep-with-next
    200          void ResistanceEstimation__Initialize(RES_EST_PARAM_TYPE *param)
    201          {
    202          #if (defined (COMPILE_4_SIMULINK)) && (defined (SKIP_RESISTANCE_ESTIMATION))
    203              Res_Est_State = RES_DETECT_RESISTANCE_ESTIMATED;
    204              Estimated_Resistance = param->nominal_resistance;
    205              Last_Estimated_Resistance = Estimated_Resistance;
    206              RE_CLR_FLOW(RES_EST_MEASURE_RESISTANCE_REQ);
    207              Res_Measure_Rate_State = RE_RATE_PATTERN_NORMAL;
    208              Res_Frequency_Timer = param->time_estimate_resistance_normal;
    209          #else
    210              Res_Est_State = RES_DETECT_INIT;
   \                     ResistanceEstimation__Initialize: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable146
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xF881 0x2367      STRB     R2,[R1, #+871]
    211              Last_Estimated_Resistance = 0.0f;
   \   0000000A   0xF8C1 0x24B0      STR      R2,[R1, #+1200]
    212              Estimated_Resistance = param->nominal_resistance;
   \   0000000E   0x6B02             LDR      R2,[R0, #+48]
   \   00000010   0xF8C1 0x24AC      STR      R2,[R1, #+1196]
    213              RE_SET_FLOW(RES_EST_MEASURE_RESISTANCE_REQ);
    214              Res_Measure_Rate_State = RE_RATE_PATTERN_INITIALIZING;
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xF881 0x2366      STRB     R2,[R1, #+870]
    215              Time_Prescaler = param->timer_prescaler;
   \   0000001A   0x6BC2             LDR      R2,[R0, #+60]
   \   0000001C   0xF881 0x236A      STRB     R2,[R1, #+874]
    216              Sample_Counter = 0;
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0xF8A1 0x2396      STRH     R2,[R1, #+918]
    217              Delta_Current_Nominal = MATHCALC__FABS(param->current_level_1st - param->current_level_2nd) * 0.5f * param->min_number_of_samples;  //50% tolerance
   \   00000026   0xED90 0x0A01      VLDR     S0,[R0, #+4]
   \   0000002A   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
    218              RE_CLR_FLOW(RES_EST_MEASURE_ERROR);
   \   0000002E   0xF8B1 0x238C      LDRH     R2,[R1, #+908]
   \   00000032   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   00000036   0xEEB0 0x0AC0      VABS.F32 S0,S0
   \   0000003A   0xEEF6 0x0A00      VMOV.F32 S1,#0.5
   \   0000003E   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000042   0xEDD0 0x0A0B      VLDR     S1,[R0, #+44]
   \   00000046   0xF201 0x40CC      ADDW     R0,R1,#+1228
   \   0000004A   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000004E   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xF360 0x0201      BFI      R2,R0,#+0,#+2
   \   00000058   0xF8A1 0x238C      STRH     R2,[R1, #+908]
    219          #endif
    220          }
   \   0000005C   0x4770             BX       LR               ;; return
    221          
    222          
    223          
    224          
    225          //---------------------------------------------------------------------------------------------------------------------
    226          /**
    227           *  @brief      Enter brief description of function.
    228           *
    229           *  @param
    230           *  @return
    231           */

   \                                 In section .text, align 2, keep-with-next
    232          void ResistanceEstimation__Start(RES_EST_PARAM_TYPE *param)
    233          {
    234              Voltage_Level = 0.0f;
   \                     ResistanceEstimation__Start: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable146
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xF8C1 0x24B8      STR      R2,[R1, #+1208]
    235              //Res_Est_State = RES_DETECT_WAIT_FOR_IDLE;
    236              Res_Est_State = RES_DETECT_WAIT_PARK_TIME;
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0xF881 0x2367      STRB     R2,[R1, #+871]
    237              This_Timer = param->time_1st_step;
   \   00000010   0x6902             LDR      R2,[R0, #+16]
   \   00000012   0xF8A1 0x2392      STRH     R2,[R1, #+914]
    238              This_Timeout = param->timeout_threshold;
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0xF8A1 0x2394      STRH     R2,[R1, #+916]
    239          
    240          
    241              if(Res_Measure_Rate_State == RE_RATE_PATTERN_WAITING_FIRST_START)
   \   0000001C   0xF891 0x2366      LDRB     R2,[R1, #+870]
   \   00000020   0x2A01             CMP      R2,#+1
   \   00000022   0xD10A             BNE.N    ??ResistanceEstimation__Start_0
    242              {
    243                  Res_Measure_Rate_State = RE_RATE_PATTERN_AFTER_RESET;
   \   00000024   0x2202             MOVS     R2,#+2
   \   00000026   0xF881 0x2366      STRB     R2,[R1, #+870]
    244                  Res_Frequency_Counter++;
   \   0000002A   0xF891 0x2368      LDRB     R2,[R1, #+872]
   \   0000002E   0x1C52             ADDS     R2,R2,#+1
   \   00000030   0xF881 0x2368      STRB     R2,[R1, #+872]
    245                  Res_Frequency_Timer = param->time_estimate_resistance_after_reset;
   \   00000034   0x6C40             LDR      R0,[R0, #+68]
   \   00000036   0xF8A1 0x0390      STRH     R0,[R1, #+912]
    246              }
    247          }
   \                     ??ResistanceEstimation__Start_0: (+1)
   \   0000003A   0x4770             BX       LR               ;; return
    248          
    249          
    250          
    251          
    252          

   \                                 In section .text, align 2, keep-with-next
    253          BOOL_TYPE ResistanceEstimation__Requested(void)
    254          {
    255              BOOL_TYPE ret_val;
    256          
    257              if(RE_TEST_FLOW(RES_EST_MEASURE_RESISTANCE_REQ))
    258              {
    259                  ret_val = TRUE;
    260              }
    261              else
    262              {
    263                  ret_val = FALSE;
    264              }
    265          
    266              return ret_val;
   \                     ResistanceEstimation__Requested: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable146
   \   00000004   0xF890 0x038C      LDRB     R0,[R0, #+908]
   \   00000008   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000000C   0x4770             BX       LR               ;; return
    267          }
    268          
    269          
    270          
    271          
    272          

   \                                 In section .text, align 4, keep-with-next
    273          BOOL_TYPE ResistanceEstimation__Calculate(RES_EST_IO_TYPE *io, RES_EST_PARAM_TYPE *param)
    274          {
   \                     ResistanceEstimation__Calculate: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
    275              BOOL_TYPE calculation_finished;
    276              BOOL_TYPE current_reached;
    277          
    278          
    279              calculation_finished = FALSE;
    280          
    281              if(Time_Prescaler)
   \   00000004   0x.... 0x....      LDR.W    R3,??DataTable146
   \   00000008   0xF8B3 0x4392      LDRH     R4,[R3, #+914]
   \   0000000C   0xF8D3 0x84BC      LDR      R8,[R3, #+1212]
   \   00000010   0xF9B3 0x5396      LDRSH    R5,[R3, #+918]
   \   00000014   0xF893 0x736A      LDRB     R7,[R3, #+874]
   \   00000018   0xEE00 0x8A10      VMOV     S0,R8
   \   0000001C   0xF8D3 0x84C0      LDR      R8,[R3, #+1216]
   \   00000020   0xEE00 0x8A90      VMOV     S1,R8
   \   00000024   0xF8D3 0x84C4      LDR      R8,[R3, #+1220]
   \   00000028   0xEE01 0x8A10      VMOV     S2,R8
   \   0000002C   0xF8D3 0x84C8      LDR      R8,[R3, #+1224]
   \   00000030   0x460A             MOV      R2,R1
   \   00000032   0xEE01 0x8A90      VMOV     S3,R8
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0xF8B3 0x838E      LDRH     R8,[R3, #+910]
   \   0000003C   0x2F00             CMP      R7,#+0
   \   0000003E   0xD003             BEQ.N    ??ResistanceEstimation__Calculate_1
    282              {
    283                  Time_Prescaler--;
   \   00000040   0x1E7A             SUBS     R2,R7,#+1
   \   00000042   0xF883 0x236A      STRB     R2,[R3, #+874]
   \   00000046   0xE13F             B.N      ??ResistanceEstimation__Calculate_2
    284              }
    285              else
    286              {
    287                  Time_Prescaler = param->timer_prescaler;
   \                     ??ResistanceEstimation__Calculate_1: (+1)
   \   00000048   0x6BD7             LDR      R7,[R2, #+60]
   \   0000004A   0xF883 0x736A      STRB     R7,[R3, #+874]
    288          
    289          
    290                  if(This_Timer)
   \   0000004E   0xB104             CBZ.N    R4,??ResistanceEstimation__Calculate_3
    291                  {
    292                      This_Timer--;
   \   00000050   0x1E64             SUBS     R4,R4,#+1
    293                  }
    294          
    295          
    296                  OscillationCheck(io, param);
   \                     ??ResistanceEstimation__Calculate_3: (+1)
   \   00000052   0x6887             LDR      R7,[R0, #+8]
   \   00000054   0xEDD2 0x2A0D      VLDR     S5,[R2, #+52]
   \   00000058   0xF8D7 0xC010      LDR      R12,[R7, #+16]
   \   0000005C   0xED9C 0x2A00      VLDR     S4,[R12, #0]
   \   00000060   0xEEB4 0x2A62      VCMP.F32 S4,S5
   \   00000064   0xEEF1 0xFA10      FMSTAT   
   \   00000068   0xBF4C             ITE      MI 
   \   0000006A   0xF108 0x0801      ADDMI    R8,R8,#+1
   \   0000006E   0x4688             MOVPL    R8,R1
    297          
    298                  switch (Res_Est_State)
   \   00000070   0xF8D3 0xC4B8      LDR      R12,[R3, #+1208]
   \   00000074   0xF893 0x9367      LDRB     R9,[R3, #+871]
   \   00000078   0xF8B3 0xE38C      LDRH     LR,[R3, #+908]
   \   0000007C   0xEE02 0xCA10      VMOV     S4,R12
   \   00000080   0xF1B9 0x0F07      CMP      R9,#+7
   \   00000084   0xF200 0x80EF      BHI.W    ??ResistanceEstimation__Calculate_4
   \   00000088   0xE8DF 0xF009      TBB      [PC, R9]
   \                     ??ResistanceEstimation__Calculate_0:
   \   0000008C   0x04 0x07          DC8      0x4,0x7,0x23,0x45
   \              0x23 0x45    
   \   00000090   0x75 0xCE          DC8      0x75,0xCE,0xE2,0xE8
   \              0xE2 0xE8    
    299                  {
    300                      //////////////////////////////////////////////////////////////////////////////
    301                      //////////////////////////////////////////////////////////////////////////////
    302                      //////////////////////////////////////////////////////////////////////////////
    303                      case RES_DETECT_INIT:
    304          
    305                          Voltage_Level = 0.0f;
   \                     ??ResistanceEstimation__Calculate_5: (+1)
   \   00000094   0xED9F 0x....      VLDR.W   S4,??DataTable123  ;; 0x0
    306          
    307                          break;
   \   00000098   0xE0E5             B.N      ??ResistanceEstimation__Calculate_4
    308          
    309          
    310          
    311          
    312                      //////////////////////////////////////////////////////////////////////////////
    313                      //////////////////////////////////////////////////////////////////////////////
    314                      //////////////////////////////////////////////////////////////////////////////
    315                      case RES_DETECT_WAIT_PARK_TIME:
    316          
    317                          if((*io->Ctrl_Specific->Is_Abs) < (param->current_level_1st))
   \                     ??ResistanceEstimation__Calculate_6: (+1)
   \   0000009A   0x6D3E             LDR      R6,[R7, #+80]
   \   0000009C   0xED92 0x3A01      VLDR     S6,[R2, #+4]
   \   000000A0   0xEDD6 0x2A00      VLDR     S5,[R6, #0]
   \   000000A4   0xEEF4 0x2A43      VCMP.F32 S5,S6
   \   000000A8   0xEEF1 0xFA10      FMSTAT   
   \   000000AC   0xD504             BPL.N    ??ResistanceEstimation__Calculate_7
    318                          {
    319                              Voltage_Level += (param->delta_voltage_to_1st_step);
   \   000000AE   0xEDD2 0x2A07      VLDR     S5,[R2, #+28]
   \   000000B2   0xEE32 0x2A22      VADD.F32 S4,S4,S5
   \   000000B6   0xE0D6             B.N      ??ResistanceEstimation__Calculate_4
    320                          }
    321                          else
    322                          {
    323                              if(!This_Timer)
   \                     ??ResistanceEstimation__Calculate_7: (+1)
   \   000000B8   0xB2A4             UXTH     R4,R4
   \   000000BA   0x2C00             CMP      R4,#+0
   \   000000BC   0xF040 0x80D3      BNE.W    ??ResistanceEstimation__Calculate_4
    324                              {
    325                                  Sample_Counter = 0;
    326                                  Voltage_1st_Sum = 0.0f;
    327                                  Current_1st_Sum = 0.0f;
    328          
    329                                  Res_Est_State = RES_DETECT_1ST_PLATEAU_WAIT;
   \   000000C0   0x2602             MOVS     R6,#+2
   \   000000C2   0x2500             MOVS     R5,#+0
   \   000000C4   0xED9F 0x....      VLDR.W   S0,??DataTable123  ;; 0x0
   \   000000C8   0xEDDF 0x....      VLDR.W   S1,??DataTable123  ;; 0x0
   \   000000CC   0xF883 0x6367      STRB     R6,[R3, #+871]
   \   000000D0   0xE0C9             B.N      ??ResistanceEstimation__Calculate_4
    330                              }
    331                          }
    332          
    333                          break;
    334          
    335          
    336          
    337          
    338                      //////////////////////////////////////////////////////////////////////////////
    339                      //////////////////////////////////////////////////////////////////////////////
    340                      //////////////////////////////////////////////////////////////////////////////
    341                      case RES_DETECT_1ST_PLATEAU_WAIT:
    342          
    343                          if((OscillationCheckPassed(param) == TRUE))
   \                     ??ResistanceEstimation__Calculate_8: (+1)
   \   000000D2   0xFA1F 0xF888      UXTH     R8,R8
   \   000000D6   0x6A96             LDR      R6,[R2, #+40]
   \   000000D8   0x4546             CMP      R6,R8
   \   000000DA   0xDA0A             BGE.N    ??ResistanceEstimation__Calculate_9
    344                          {
    345                              Voltage_1st_Sum += *io->vs_voltage_abs;
   \   000000DC   0x6806             LDR      R6,[R0, #+0]
   \   000000DE   0xEDD6 0x2A00      VLDR     S5,[R6, #0]
    346                              Current_1st_Sum += *io->Ctrl_Specific->Is_Abs;
   \   000000E2   0x6D3E             LDR      R6,[R7, #+80]
   \   000000E4   0xEE30 0x0A22      VADD.F32 S0,S0,S5
   \   000000E8   0xEDD6 0x2A00      VLDR     S5,[R6, #0]
   \   000000EC   0xEE70 0x0AA2      VADD.F32 S1,S1,S5
    347                              Sample_Counter++;
   \   000000F0   0x1C6D             ADDS     R5,R5,#+1
    348                          }
    349          
    350          
    351                          if(Sample_Counter >= param->min_number_of_samples)
   \                     ??ResistanceEstimation__Calculate_9: (+1)
   \   000000F2   0xB22D             SXTH     R5,R5
   \   000000F4   0xEE02 0x5A90      VMOV     S5,R5
   \   000000F8   0xEEF8 0x2AE2      VCVT.F32.S32 S5,S5
   \   000000FC   0xED92 0x3A0B      VLDR     S6,[R2, #+44]
   \   00000100   0xEEF4 0x2A43      VCMP.F32 S5,S6
   \   00000104   0xEEF1 0xFA10      FMSTAT   
   \   00000108   0xF2C0 0x80AD      BLT.W    ??ResistanceEstimation__Calculate_4
    352                          {
    353                              //! First plateau is finished. Go to seconds plateau
    354                              #if (FAST_RESISTANCE_CALC == ENABLED)
    355                              Voltage_1st_Averaged = Voltage_1st_Sum / Sample_Counter;
    356                              Current_1st_Averaged = Current_1st_Sum / Sample_Counter;
    357                              #endif
    358                              This_Timer = param->time_2nd_step;
   \   0000010C   0x6954             LDR      R4,[R2, #+20]
    359                              current_reached = FALSE;
    360                              Res_Est_State = RES_DETECT_SECOND_RAMP;
   \   0000010E   0x2603             MOVS     R6,#+3
   \   00000110   0xF883 0x6367      STRB     R6,[R3, #+871]
   \   00000114   0xE0A7             B.N      ??ResistanceEstimation__Calculate_4
    361          
    362                          }
    363                          break;
    364          
    365          
    366          
    367          
    368                      //////////////////////////////////////////////////////////////////////////////
    369                      //////////////////////////////////////////////////////////////////////////////
    370                      //////////////////////////////////////////////////////////////////////////////
    371                      case RES_DETECT_SECOND_RAMP:
    372                          if((param->current_level_2nd) >= (param->current_level_1st))
   \                     ??ResistanceEstimation__Calculate_10: (+1)
   \   00000116   0x6D3F             LDR      R7,[R7, #+80]
   \   00000118   0xED92 0x3A02      VLDR     S6,[R2, #+8]
   \   0000011C   0xEDD2 0x3A01      VLDR     S7,[R2, #+4]
   \   00000120   0xEDD7 0x2A00      VLDR     S5,[R7, #0]
   \   00000124   0xEEB4 0x3A63      VCMP.F32 S6,S7
   \   00000128   0xEEF1 0xFA10      FMSTAT   
   \   0000012C   0xDB09             BLT.N    ??ResistanceEstimation__Calculate_11
    373                          {
    374                              if((*io->Ctrl_Specific->Is_Abs) < (param->current_level_2nd))
   \   0000012E   0xEEF4 0x2A43      VCMP.F32 S5,S6
   \   00000132   0xEEF1 0xFA10      FMSTAT   
   \   00000136   0xD511             BPL.N    ??ResistanceEstimation__Calculate_12
    375                              {
    376                                  Voltage_Level += (param->delta_voltage_to_2nd_step);
   \   00000138   0xEDD2 0x2A08      VLDR     S5,[R2, #+32]
   \   0000013C   0xEE32 0x2A22      VADD.F32 S4,S4,S5
   \   00000140   0xE008             B.N      ??ResistanceEstimation__Calculate_13
    377                              }
    378                              else
    379                              {
    380                                  current_reached = TRUE;
    381                              }
    382                          }
    383                          else // CURR_DC_LEVEL_1ST > CURR_DC_LEVEL_2ND
    384                          {
    385                              if((*io->Ctrl_Specific->Is_Abs) > (param->current_level_2nd))
   \                     ??ResistanceEstimation__Calculate_11: (+1)
   \   00000142   0xEEB4 0x3A62      VCMP.F32 S6,S5
   \   00000146   0xEEF1 0xFA10      FMSTAT   
   \   0000014A   0xD507             BPL.N    ??ResistanceEstimation__Calculate_12
    386                              {
    387                                  Voltage_Level -= (param->delta_voltage_to_2nd_step);
   \   0000014C   0xEDD2 0x2A08      VLDR     S5,[R2, #+32]
   \   00000150   0xEE32 0x2A62      VSUB.F32 S4,S4,S5
    388                              }
    389                              else
    390                              {
    391                                  current_reached = TRUE;
    392                              }
    393                          }
    394          
    395                          if(current_reached && (!This_Timer))
   \                     ??ResistanceEstimation__Calculate_13: (+1)
   \   00000154   0xB2F6             UXTB     R6,R6
   \   00000156   0x2E00             CMP      R6,#+0
   \   00000158   0xF000 0x8085      BEQ.W    ??ResistanceEstimation__Calculate_4
   \                     ??ResistanceEstimation__Calculate_12: (+1)
   \   0000015C   0xB2A4             UXTH     R4,R4
   \   0000015E   0x2C00             CMP      R4,#+0
   \   00000160   0xF040 0x8081      BNE.W    ??ResistanceEstimation__Calculate_4
    396                          {
    397                              Sample_Counter = 0;
    398                              Voltage_2nd_Sum = 0.0f;
    399                              Current_2nd_Sum = 0.0f;
    400          
    401                              Res_Est_State = RES_DETECT_2ND_PLATEAU_WAIT;
   \   00000164   0x2604             MOVS     R6,#+4
   \   00000166   0x2500             MOVS     R5,#+0
   \   00000168   0xED9F 0x....      VLDR.W   S2,??DataTable123  ;; 0x0
   \   0000016C   0xEDDF 0x....      VLDR.W   S3,??DataTable123  ;; 0x0
   \   00000170   0xF883 0x6367      STRB     R6,[R3, #+871]
   \   00000174   0xE077             B.N      ??ResistanceEstimation__Calculate_4
    402                          }
    403          
    404                          break;
    405          
    406          
    407          
    408          
    409                      //////////////////////////////////////////////////////////////////////////////
    410                      //////////////////////////////////////////////////////////////////////////////
    411                      //////////////////////////////////////////////////////////////////////////////
    412                      case RES_DETECT_2ND_PLATEAU_WAIT:
    413          
    414                          if((OscillationCheckPassed(param) == TRUE))
   \                     ??ResistanceEstimation__Calculate_14: (+1)
   \   00000176   0xFA1F 0xF888      UXTH     R8,R8
   \   0000017A   0x6A96             LDR      R6,[R2, #+40]
   \   0000017C   0x4546             CMP      R6,R8
   \   0000017E   0xDA0A             BGE.N    ??ResistanceEstimation__Calculate_15
    415                          {
    416                              Voltage_2nd_Sum += *io->vs_voltage_abs;
   \   00000180   0x6806             LDR      R6,[R0, #+0]
   \   00000182   0xEDD6 0x2A00      VLDR     S5,[R6, #0]
    417                              Current_2nd_Sum += *io->Ctrl_Specific->Is_Abs;
   \   00000186   0x6D3E             LDR      R6,[R7, #+80]
   \   00000188   0xEE31 0x1A22      VADD.F32 S2,S2,S5
   \   0000018C   0xEDD6 0x2A00      VLDR     S5,[R6, #0]
   \   00000190   0xEE71 0x1AA2      VADD.F32 S3,S3,S5
    418                              Sample_Counter++;
   \   00000194   0x1C6D             ADDS     R5,R5,#+1
    419          
    420                          }
    421          
    422                          if(Sample_Counter >= param->min_number_of_samples)
   \                     ??ResistanceEstimation__Calculate_15: (+1)
   \   00000196   0xB22D             SXTH     R5,R5
   \   00000198   0xEE02 0x5A90      VMOV     S5,R5
   \   0000019C   0xEEF8 0x2AE2      VCVT.F32.S32 S5,S5
   \   000001A0   0xED92 0x3A0B      VLDR     S6,[R2, #+44]
   \   000001A4   0xEEF4 0x2A43      VCMP.F32 S5,S6
   \   000001A8   0xEEF1 0xFA10      FMSTAT   
   \   000001AC   0xDB5B             BLT.N    ??ResistanceEstimation__Calculate_4
    423                          {
    424                              #if (FAST_RESISTANCE_CALC == ENABLED)
    425                              Voltage_2nd_Averaged = Voltage_2nd_Sum / Sample_Counter;
    426                              Current_2nd_Averaged = Current_2nd_Sum / Sample_Counter;
    427                              #endif
    428                              //! Second plateau is finished. Calculate resistance value
    429          
    430                              CalculateResistance();
   \   000001AE   0xF8D3 0x64CC      LDR      R6,[R3, #+1228]
   \   000001B2   0xEE71 0x2AE0      VSUB.F32 S5,S3,S1
   \   000001B6   0xEEF0 0x2AE2      VABS.F32 S5,S5
   \   000001BA   0xEE03 0x6A10      VMOV     S6,R6
   \   000001BE   0xEEF4 0x2A43      VCMP.F32 S5,S6
   \   000001C2   0xEEF1 0xFA10      FMSTAT   
   \   000001C6   0xDB0A             BLT.N    ??ResistanceEstimation__Calculate_16
   \   000001C8   0xEE31 0x3A40      VSUB.F32 S6,S2,S0
   \   000001CC   0xEEC3 0x2A22      VDIV.F32 S5,S6,S5
   \   000001D0   0xF64F 0x76FD      MOVW     R6,#+65533
   \   000001D4   0xEEF0 0x2AE2      VABS.F32 S5,S5
   \   000001D8   0xEA06 0x0E0E      AND      LR,R6,LR
   \   000001DC   0xE005             B.N      ??ResistanceEstimation__Calculate_17
   \                     ??ResistanceEstimation__Calculate_16: (+1)
   \   000001DE   0xF8D3 0x64B0      LDR      R6,[R3, #+1200]
   \   000001E2   0xEE02 0x6A90      VMOV     S5,R6
   \   000001E6   0xF04E 0x0E02      ORR      LR,LR,#0x2
    431          
    432                              // check if 0
    433                              if(!Estimated_Resistance)
   \                     ??ResistanceEstimation__Calculate_17: (+1)
   \   000001EA   0xEEF5 0x2A40      VCMP.F32 S5,#0.0
   \   000001EE   0xEEF1 0xFA10      FMSTAT   
   \   000001F2   0xBF08             IT       EQ 
    434                              {
    435                                  Estimated_Resistance = param->nominal_resistance;
   \   000001F4   0xEDD2 0x2A0C      VLDREQ   S5,[R2, #+48]
   \   000001F8   0xF203 0x46AC      ADDW     R6,R3,#+1196
   \   000001FC   0xEDC6 0x2A00      VSTR     S5,[R6, #0]
    436                              }
    437          
    438                              // Refresh the timer that indicates when the last resistance was measured
    439                              Timer_To_Reset_Resistance = param->timer_to_reset_resistance;
   \   00000200   0x6B96             LDR      R6,[R2, #+56]
   \   00000202   0xF8C3 0x64B4      STR      R6,[R3, #+1204]
    440                              Last_Estimated_Resistance = Estimated_Resistance;
   \   00000206   0xF8D3 0x64AC      LDR      R6,[R3, #+1196]
   \   0000020A   0xF8C3 0x64B0      STR      R6,[R3, #+1200]
    441          
    442                              if(Res_Measure_Rate_State == RE_RATE_PATTERN_AFTER_SPIN)
   \   0000020E   0xF893 0x6366      LDRB     R6,[R3, #+870]
   \   00000212   0x2E04             CMP      R6,#+4
   \   00000214   0xD104             BNE.N    ??ResistanceEstimation__Calculate_18
    443                              {
    444                                  Res_Frequency_Counter_Spin++;
   \   00000216   0xF893 0x6369      LDRB     R6,[R3, #+873]
   \   0000021A   0x1C76             ADDS     R6,R6,#+1
   \   0000021C   0xF883 0x6369      STRB     R6,[R3, #+873]
    445                              }
    446                              Res_Est_State = RES_DETECT_THIRD_RAMP;
   \                     ??ResistanceEstimation__Calculate_18: (+1)
   \   00000220   0x2605             MOVS     R6,#+5
   \   00000222   0xF883 0x6367      STRB     R6,[R3, #+871]
   \   00000226   0xE01E             B.N      ??ResistanceEstimation__Calculate_4
    447                          }
    448                          break;
    449          
    450          
    451          
    452          
    453                      //////////////////////////////////////////////////////////////////////////////
    454                      //////////////////////////////////////////////////////////////////////////////
    455                      //////////////////////////////////////////////////////////////////////////////
    456                      case RES_DETECT_THIRD_RAMP:
    457                          if(*io->Ctrl_Specific->Is_Abs > (param->current_level_3rd))
   \                     ??ResistanceEstimation__Calculate_19: (+1)
   \   00000228   0x6D3E             LDR      R6,[R7, #+80]
   \   0000022A   0xEDD2 0x2A03      VLDR     S5,[R2, #+12]
   \   0000022E   0xED96 0x3A00      VLDR     S6,[R6, #0]
   \   00000232   0xEEF4 0x2A43      VCMP.F32 S5,S6
   \   00000236   0xEEF1 0xFA10      FMSTAT   
   \   0000023A   0xD504             BPL.N    ??ResistanceEstimation__Calculate_20
    458                          {
    459                              Voltage_Level -= (param->delta_voltage_to_3rd_step);
   \   0000023C   0xEDD2 0x2A09      VLDR     S5,[R2, #+36]
   \   00000240   0xEE32 0x2A62      VSUB.F32 S4,S4,S5
   \   00000244   0xE00F             B.N      ??ResistanceEstimation__Calculate_4
    460                          }
    461                          else
    462                          {
    463                              This_Timer = param->time_3rd_step;
   \                     ??ResistanceEstimation__Calculate_20: (+1)
   \   00000246   0x6994             LDR      R4,[R2, #+24]
    464                              Res_Est_State = RES_DETECT_3RD_PLATEAU_WAIT;
   \   00000248   0x2606             MOVS     R6,#+6
   \   0000024A   0xF883 0x6367      STRB     R6,[R3, #+871]
   \   0000024E   0xE00A             B.N      ??ResistanceEstimation__Calculate_4
    465                          }
    466                          break;
    467          
    468          
    469          
    470          
    471                      //////////////////////////////////////////////////////////////////////////////
    472                      //////////////////////////////////////////////////////////////////////////////
    473                      //////////////////////////////////////////////////////////////////////////////
    474                      case RES_DETECT_3RD_PLATEAU_WAIT:
    475                          if(!This_Timer)
   \                     ??ResistanceEstimation__Calculate_21: (+1)
   \   00000250   0xB2A4             UXTH     R4,R4
   \   00000252   0xB944             CBNZ.N   R4,??ResistanceEstimation__Calculate_4
    476                          {
    477                              Res_Est_State = RES_DETECT_RESISTANCE_ESTIMATED;
   \   00000254   0x2607             MOVS     R6,#+7
   \   00000256   0xF883 0x6367      STRB     R6,[R3, #+871]
   \   0000025A   0xE004             B.N      ??ResistanceEstimation__Calculate_4
    478          
    479                          }
    480                          break;
    481          
    482          
    483          
    484          
    485                      //////////////////////////////////////////////////////////////////////////////
    486                      //////////////////////////////////////////////////////////////////////////////
    487                      //////////////////////////////////////////////////////////////////////////////
    488                      case RES_DETECT_RESISTANCE_ESTIMATED:
    489          
    490                          // when finished stay here.
    491                          RE_CLR_FLOW(RES_EST_MEASURE_RESISTANCE_REQ);
   \                     ??ResistanceEstimation__Calculate_22: (+1)
   \   0000025C   0xF64F 0x71FE      MOVW     R1,#+65534
   \   00000260   0xEA01 0x0E0E      AND      LR,R1,LR
    492          
    493                          calculation_finished = TRUE;
   \   00000264   0x2101             MOVS     R1,#+1
    494                          break;
   \                     ??ResistanceEstimation__Calculate_4: (+1)
   \   00000266   0xF203 0x46B8      ADDW     R6,R3,#+1208
   \   0000026A   0xF8A3 0xE38C      STRH     LR,[R3, #+908]
   \   0000026E   0xED86 0x2A00      VSTR     S4,[R6, #0]
    495          
    496          
    497                      //////////////////////////////////////////////////////////////////////////////
    498                      //////////////////////////////////////////////////////////////////////////////
    499                      //////////////////////////////////////////////////////////////////////////////
    500                      default:
    501                          // Left blank intentionally.
    502                          break;
    503                  }
    504          
    505          
    506                  //Time out for resistance estimation.
    507                  if(This_Timeout)
   \   00000272   0xF8B3 0x6394      LDRH     R6,[R3, #+916]
   \   00000276   0xB11E             CBZ.N    R6,??ResistanceEstimation__Calculate_23
    508                  {
    509                      This_Timeout--;
   \   00000278   0x1E72             SUBS     R2,R6,#+1
   \   0000027A   0xF8A3 0x2394      STRH     R2,[R3, #+916]
   \   0000027E   0xE023             B.N      ??ResistanceEstimation__Calculate_2
    510                  }
    511                  else
    512                  {
    513                      Voltage_Level = 0.0f;
   \                     ??ResistanceEstimation__Calculate_23: (+1)
   \   00000280   0xF8C3 0x64B8      STR      R6,[R3, #+1208]
    514          
    515                      //If time expires a limit, assumes the last resistance measured.
    516                      //If it is not available, it assumes the nominal resistance value
    517                      Estimated_Resistance = Last_Estimated_Resistance;
   \   00000284   0xF8D3 0x64B0      LDR      R6,[R3, #+1200]
   \   00000288   0xEE02 0x6A10      VMOV     S4,R6
   \   0000028C   0xF203 0x46AC      ADDW     R6,R3,#+1196
    518                      if(!Estimated_Resistance)
   \   00000290   0xEEB5 0x2A40      VCMP.F32 S4,#0.0
   \   00000294   0xED86 0x2A00      VSTR     S4,[R6, #0]
   \   00000298   0xEEF1 0xFA10      FMSTAT   
   \   0000029C   0xBF04             ITT      EQ 
    519                      {
    520                          Estimated_Resistance = param->nominal_resistance;
   \   0000029E   0x6B12             LDREQ    R2,[R2, #+48]
   \   000002A0   0xF8C3 0x24AC      STREQ    R2,[R3, #+1196]
    521                      }
    522          
    523                      if(Res_Est_State == RES_DETECT_WAIT_PARK_TIME)
   \   000002A4   0xF893 0x2367      LDRB     R2,[R3, #+871]
   \   000002A8   0x2A01             CMP      R2,#+1
   \   000002AA   0xD104             BNE.N    ??ResistanceEstimation__Calculate_24
    524                      {
    525                          // resistance estimation error (probably due to motor not connected)
    526                          io->Ctrl_Specific->flags.bit.resistance_est_error = 1;
   \   000002AC   0x6882             LDR      R2,[R0, #+8]
   \   000002AE   0x6816             LDR      R6,[R2, #+0]
   \   000002B0   0xF046 0x0620      ORR      R6,R6,#0x20
   \   000002B4   0x6016             STR      R6,[R2, #+0]
    527                      }
    528                      Res_Est_State = RES_DETECT_RESISTANCE_ESTIMATED;
   \                     ??ResistanceEstimation__Calculate_24: (+1)
   \   000002B6   0x2207             MOVS     R2,#+7
   \   000002B8   0xF883 0x2367      STRB     R2,[R3, #+871]
    529          			RE_SET_FLOW(RES_EST_MEASURE_ERROR);
   \   000002BC   0xF8B3 0x238C      LDRH     R2,[R3, #+908]
   \   000002C0   0xF042 0x0202      ORR      R2,R2,#0x2
   \   000002C4   0xF8A3 0x238C      STRH     R2,[R3, #+908]
   \                     ??ResistanceEstimation__Calculate_2: (+1)
   \   000002C8   0xF203 0x42C8      ADDW     R2,R3,#+1224
   \   000002CC   0xF8A3 0x838E      STRH     R8,[R3, #+910]
   \   000002D0   0xEDC2 0x1A00      VSTR     S3,[R2, #0]
   \   000002D4   0xF203 0x42C4      ADDW     R2,R3,#+1220
   \   000002D8   0xF8A3 0x5396      STRH     R5,[R3, #+918]
   \   000002DC   0xED82 0x1A00      VSTR     S2,[R2, #0]
   \   000002E0   0xF203 0x42C0      ADDW     R2,R3,#+1216
   \   000002E4   0xF8A3 0x4392      STRH     R4,[R3, #+914]
   \   000002E8   0xEDC2 0x0A00      VSTR     S1,[R2, #0]
   \   000002EC   0xF203 0x42BC      ADDW     R2,R3,#+1212
   \   000002F0   0xED82 0x0A00      VSTR     S0,[R2, #0]
    530                  }
    531              }
    532          
    533              *io->level_injection_out = Voltage_Level;
   \   000002F4   0x6840             LDR      R0,[R0, #+4]
   \   000002F6   0xF8D3 0x24B8      LDR      R2,[R3, #+1208]
   \   000002FA   0x6002             STR      R2,[R0, #+0]
    534          
    535              return calculation_finished;
   \   000002FC   0x4608             MOV      R0,R1
   \   000002FE   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    536          }
    537          
    538          
    539          
    540          
    541          

   \                                 In section .text, align 2, keep-with-next
    542          float32 ResistanceEstimation__GetResistance(void)
    543          {
    544              return Estimated_Resistance;
   \                     ResistanceEstimation__GetResistance: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable156
   \   00000004   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000008   0x4770             BX       LR               ;; return
    545          }
    546          
    547          
    548          
    549          
    550          //---------------------------------------------------------------------------------------------------------------------
    551          /**
    552           *  @brief      Enter brief description of function.
    553           *
    554           *  @param
    555           *  @return
    556           */

   \                                 In section .text, align 2, keep-with-next
    557          void ResistanceEstimation__Handler25ms(RES_EST_PARAM_TYPE *param)
    558          {
    559              if(Timer_To_Reset_Resistance)
   \                     ResistanceEstimation__Handler25ms: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable146
   \   00000004   0xF8D1 0x24B4      LDR      R2,[R1, #+1204]
   \   00000008   0xB112             CBZ.N    R2,??ResistanceEstimation__Handler25ms_0
    560              {
    561                  Timer_To_Reset_Resistance--;
   \   0000000A   0x1E52             SUBS     R2,R2,#+1
   \   0000000C   0xF8C1 0x24B4      STR      R2,[R1, #+1204]
    562              }
    563              else
    564              {
    565          #if RESET_RESISTANCE_MANAGEMENT == ENABLED
    566                  // Force to nominal value when reset timer expires and resistance measurement is not successful
    567                  // (if not defined, the last value is always used till a new good measurement)
    568                  Last_Estimated_Resistance = 0;
    569          #endif
    570              }
    571          
    572              TimerDefinition(param);
   \                     ??ResistanceEstimation__Handler25ms_0: (+1)
   \   00000010   0x....             B.N      ??TimerDefinition
    573          }
    574          
    575          
    576          
    577          /**
    578           *  @brief      Tells if resistance has been measured recently based on a timer (RES_TIMER_40S_BASE_25MS).
    579           *
    580           *  @param      none
    581           *  @return     TRUE (yes) or FALSE (no)
    582           */

   \                                 In section .text, align 2, keep-with-next
    583          BOOL_TYPE ResistanceEstimation__IsResBeenUpdated(void)
    584          {
    585              BOOL_TYPE response;
    586          
    587              if(Timer_To_Reset_Resistance)
   \                     ResistanceEstimation__IsResBeenUpdated: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable146
   \   00000004   0xF8D0 0x04B4      LDR      R0,[R0, #+1204]
   \   00000008   0x1E40             SUBS     R0,R0,#+1
   \   0000000A   0x4180             SBCS     R0,R0,R0
   \   0000000C   0x43C0             MVNS     R0,R0
   \   0000000E   0x0FC0             LSRS     R0,R0,#+31
    588              {
    589                  response = TRUE;
    590              }
    591              else
    592              {
    593                  response = FALSE;
    594              }
    595          
    596              return(response);
   \   00000010   0x4770             BX       LR               ;; return
    597          }
    598          
    599          
    600          //=====================================================================================================================
    601          //-------------------------------------- Private Functions ------------------------------------------------------------
    602          //=====================================================================================================================
    603          
    604          
    605          void CalculateResistance(void)
    606          {
    607          #if(FAST_RESISTANCE_CALC == DISABLED)
    608              // check proper delta current
    609              float32 delta_current;
    610              delta_current = MATHCALC__FABS(Current_2nd_Sum - Current_1st_Sum);
    611              // update estimated value if delta current is correct
    612              if (delta_current >= Delta_Current_Nominal)
    613              {
    614                  Estimated_Resistance = (Voltage_2nd_Sum - Voltage_1st_Sum)/delta_current;
    615                  Estimated_Resistance = MATHCALC__FABS(Estimated_Resistance);
    616                  RE_CLR_FLOW(RES_EST_MEASURE_ERROR);
    617              }
    618              else
    619              {
    620                  Estimated_Resistance = Last_Estimated_Resistance;
    621                  RE_SET_FLOW(RES_EST_MEASURE_ERROR);
    622              }
    623          
    624          #else
    625                  Estimated_Resistance = ((Voltage_1st_Averaged/Current_1st_Averaged) + (Voltage_2nd_Averaged/Current_2nd_Averaged));
    626                  Estimated_Resistance = (Estimated_Resistance/2.0f);
    627                  Estimated_Resistance = MATHCALC__FABS(Estimated_Resistance);
    628                  Estimated_Resistance = (Estimated_Resistance - R_COMP_FACTOR);
    629          #endif
    630          
    631          }
    632          
    633          //---------------------------------------------------------------------------------------------------------------------
    634          /**
    635           *  @brief      Enter brief description of function.
    636           *
    637           *  @param
    638           *  @return
    639           */
    640          void OscillationCheck(RES_EST_IO_TYPE *io, RES_EST_PARAM_TYPE *param)
    641          {
    642              float32 speed_thr_rads;
    643              speed_thr_rads = param->oscillation_speed_threshold;
    644              //The oscillation threshold is considered as 0.005% of the full speed range
    645              if((*io->Ctrl_Specific->Speed_Rotor_Observed_Mech_Abs) < speed_thr_rads)
    646              {
    647                  Speed_Oscillation_Debouncer++;
    648              }
    649              else
    650              {
    651                  Speed_Oscillation_Debouncer = 0;
    652              }
    653          }
    654          
    655          
    656          
    657          
    658          uint8 OscillationCheckPassed(RES_EST_PARAM_TYPE *param)
    659          {
    660              uint8 passed;
    661          
    662              if(Speed_Oscillation_Debouncer > param->oscillation_check_timer)
    663              {
    664                  passed = TRUE;
    665              }
    666              else
    667              {
    668                  passed = FALSE;
    669              }
    670          
    671              return passed;
    672          }
    673          
    674          

   \                                 In section .text, align 4, keep-with-next
    675          void TimerDefinition(RES_EST_PARAM_TYPE *param)
    676          {
    677              float32 speed_ref;
    678              float32 speed_thr_rads;
    679              speed_thr_rads = param->speed_threshold_to_estimate_resistance * RPM_TO_RADS;
    680          
    681              speed_ref = SpeedRefGen__GetSpeedRef();
    682              if(speed_ref > speed_thr_rads)
   \                     ??TimerDefinition: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable146
   \   00000004   0xED90 0x0A10      VLDR     S0,[R0, #+64]
   \   00000008   0xF8D1 0x24DC      LDR      R2,[R1, #+1244]
   \   0000000C   0xEDDF 0x....      VLDR.W   S1,??DataTable133  ;; 0x3dd67750
   \   00000010   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000014   0xEE00 0x2A90      VMOV     S1,R2
   \   00000018   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000001C   0xEEF1 0xFA10      FMSTAT   
   \   00000020   0xD505             BPL.N    ??TimerDefinition_2
    683              {
    684                  Res_Measure_Rate_State = RE_RATE_PATTERN_AFTER_SPIN;
   \   00000022   0x2204             MOVS     R2,#+4
   \   00000024   0xF881 0x2366      STRB     R2,[R1, #+870]
    685                  Res_Frequency_Counter_Spin = 0;
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0xF881 0x2369      STRB     R2,[R1, #+873]
   \                     ??TimerDefinition_2: (+1)
   \   0000002E   0xF891 0x2354      LDRB     R2,[R1, #+852]
   \   00000032   0x2A03             CMP      R2,#+3
   \   00000034   0xDB08             BLT.N    ??TimerDefinition_3
   \   00000036   0xF8D1 0x33E4      LDR      R3,[R1, #+996]
   \   0000003A   0xB12B             CBZ.N    R3,??TimerDefinition_3
    686              }
    687          
    688              if(Mci__GetError(MOTOR0,MCI_ERROR_ANY_ERROR_FOUND))
    689              {
    690                  RE_SET_FLOW(RES_EST_MEASURE_RESISTANCE_REQ);
   \   0000003C   0xF8B1 0x338C      LDRH     R3,[R1, #+908]
   \   00000040   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000044   0xF8A1 0x338C      STRH     R3,[R1, #+908]
    691              }
    692          
    693              switch(Res_Measure_Rate_State)
   \                     ??TimerDefinition_3: (+1)
   \   00000048   0xF891 0x3366      LDRB     R3,[R1, #+870]
   \   0000004C   0x2B04             CMP      R3,#+4
   \   0000004E   0xD859             BHI.N    ??TimerDefinition_4
   \   00000050   0xE8DF 0xF003      TBB      [PC, R3]
   \                     ??TimerDefinition_1:
   \   00000054   0x03 0x5B          DC8      0x3,0x5B,0x12,0x47
   \              0x12 0x47    
   \   00000058   0x32 0x00          DC8      0x32,0x0
    694              {
    695          
    696                  case RE_RATE_PATTERN_INITIALIZING:
    697                      Res_Frequency_Timer        = 0;
   \                     ??TimerDefinition_5: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF8A1 0x0390      STRH     R0,[R1, #+912]
    698                      Res_Frequency_Counter      = 0;
   \   00000060   0xF881 0x0368      STRB     R0,[R1, #+872]
    699                      Res_Frequency_Counter_Spin = 0;
   \   00000064   0xF881 0x0369      STRB     R0,[R1, #+873]
    700          
    701                      if (Mci__GetDigital(MOTOR0, MCI_DI_IDLE))
   \   00000068   0x2A03             CMP      R2,#+3
   \   0000006A   0xDB4E             BLT.N    ??TimerDefinition_6
   \   0000006C   0xF891 0x03EC      LDRB     R0,[R1, #+1004]
   \   00000070   0x0700             LSLS     R0,R0,#+28
   \   00000072   0xD54A             BPL.N    ??TimerDefinition_6
    702                      {
    703                          Res_Measure_Rate_State = RE_RATE_PATTERN_WAITING_FIRST_START;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xE046             B.N      ??TimerDefinition_7
    704                      }
    705                      break;
    706          
    707                  case RE_RATE_PATTERN_WAITING_FIRST_START:
    708                          //Just waiting for first measurement...
    709                      break;
    710          
    711                  case RE_RATE_PATTERN_AFTER_RESET:
    712                      if(!Res_Frequency_Timer)
   \                     ??TimerDefinition_8: (+1)
   \   00000078   0xF8B1 0x2390      LDRH     R2,[R1, #+912]
   \   0000007C   0x2A00             CMP      R2,#+0
   \   0000007E   0xD13D             BNE.N    ??TimerDefinition_9
    713                      {
    714                          Res_Frequency_Timer = param->time_estimate_resistance_after_reset;
   \   00000080   0x6C42             LDR      R2,[R0, #+68]
   \   00000082   0xF8A1 0x2390      STRH     R2,[R1, #+912]
    715                          RE_SET_FLOW(RES_EST_MEASURE_RESISTANCE_REQ);
   \   00000086   0xF8B1 0x238C      LDRH     R2,[R1, #+908]
   \   0000008A   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000008E   0xF8A1 0x238C      STRH     R2,[R1, #+908]
    716                          Res_Frequency_Counter++;
   \   00000092   0xF891 0x2368      LDRB     R2,[R1, #+872]
   \   00000096   0x1C52             ADDS     R2,R2,#+1
   \   00000098   0xF881 0x2368      STRB     R2,[R1, #+872]
    717          
    718                          if(Res_Frequency_Counter > param->number_estimation_after_reset)
   \   0000009C   0xB2D2             UXTB     R2,R2
   \   0000009E   0x6C83             LDR      R3,[R0, #+72]
   \   000000A0   0x4293             CMP      R3,R2
   \   000000A2   0xD232             BCS.N    ??TimerDefinition_6
    719                          {
    720                              Res_Frequency_Counter = 0;
   \   000000A4   0x2200             MOVS     R2,#+0
   \   000000A6   0xF881 0x2368      STRB     R2,[R1, #+872]
    721                              Res_Measure_Rate_State = RE_RATE_PATTERN_NORMAL;
   \   000000AA   0x2203             MOVS     R2,#+3
   \   000000AC   0xF881 0x2366      STRB     R2,[R1, #+870]
    722                              Res_Frequency_Timer = param->time_estimate_resistance_normal;
   \   000000B0   0x6CC0             LDR      R0,[R0, #+76]
   \   000000B2   0xF8A1 0x0390      STRH     R0,[R1, #+912]
   \   000000B6   0x4770             BX       LR
    723                          }
    724                      }
    725                      else
    726                      {
    727                          Res_Frequency_Timer--;
    728                      }
    729                      break;
    730          
    731                  case RE_RATE_PATTERN_AFTER_SPIN:
    732                      RE_SET_FLOW(RES_EST_MEASURE_RESISTANCE_REQ);
   \                     ??TimerDefinition_10: (+1)
   \   000000B8   0xF8B1 0x238C      LDRH     R2,[R1, #+908]
   \   000000BC   0xF042 0x0201      ORR      R2,R2,#0x1
   \   000000C0   0xF8A1 0x238C      STRH     R2,[R1, #+908]
    733          
    734                      if(Res_Frequency_Counter_Spin >= param->number_estimation_after_spin)
   \   000000C4   0x6D03             LDR      R3,[R0, #+80]
   \   000000C6   0xF891 0x2369      LDRB     R2,[R1, #+873]
   \   000000CA   0x429A             CMP      R2,R3
   \   000000CC   0xD31D             BCC.N    ??TimerDefinition_6
    735                      {
    736                          Res_Frequency_Counter_Spin = 0;
   \   000000CE   0x2200             MOVS     R2,#+0
   \   000000D0   0xF881 0x2369      STRB     R2,[R1, #+873]
    737                          Res_Measure_Rate_State = RE_RATE_PATTERN_NORMAL;
   \   000000D4   0x2203             MOVS     R2,#+3
   \   000000D6   0xF881 0x2366      STRB     R2,[R1, #+870]
    738                          Res_Frequency_Timer = param->time_estimate_resistance_normal;
   \   000000DA   0x6CC0             LDR      R0,[R0, #+76]
   \   000000DC   0xF8A1 0x0390      STRH     R0,[R1, #+912]
   \   000000E0   0x4770             BX       LR
    739                      }
    740                      break;
    741          
    742                  case RE_RATE_PATTERN_NORMAL:
    743                      if(!Res_Frequency_Timer)
   \                     ??TimerDefinition_11: (+1)
   \   000000E2   0xF8B1 0x2390      LDRH     R2,[R1, #+912]
   \   000000E6   0xB94A             CBNZ.N   R2,??TimerDefinition_9
    744                      {
    745                          Res_Frequency_Timer = param->time_estimate_resistance_normal;
   \   000000E8   0x6CC0             LDR      R0,[R0, #+76]
   \   000000EA   0xF8A1 0x0390      STRH     R0,[R1, #+912]
    746                          RE_SET_FLOW(RES_EST_MEASURE_RESISTANCE_REQ);
   \   000000EE   0xF8B1 0x038C      LDRH     R0,[R1, #+908]
   \   000000F2   0xF040 0x0001      ORR      R0,R0,#0x1
   \   000000F6   0xF8A1 0x038C      STRH     R0,[R1, #+908]
   \   000000FA   0x4770             BX       LR
    747                      }
    748                      else
    749                      {
    750                          Res_Frequency_Timer--;
   \                     ??TimerDefinition_9: (+1)
   \   000000FC   0x1E50             SUBS     R0,R2,#+1
   \   000000FE   0xF8A1 0x0390      STRH     R0,[R1, #+912]
   \   00000102   0x4770             BX       LR
    751                      }
    752                      break;
    753          
    754                  default:
    755                      // Go back to the beginning..
    756                      Res_Measure_Rate_State = RE_RATE_PATTERN_INITIALIZING;
   \                     ??TimerDefinition_4: (+1)
   \   00000104   0x2000             MOVS     R0,#+0
   \                     ??TimerDefinition_7: (+1)
   \   00000106   0xF881 0x0366      STRB     R0,[R1, #+870]
    757                      break;
    758              }
    759          }
   \                     ??TimerDefinition_6: (+1)
   \   0000010A   0x4770             BX       LR               ;; return
C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\SpeedRefGen\SpeedRefGen.c
      1          /**
      2           *  @file       SpeedRefGen.c
      3           *  @brief      Basic description of file contents
      4           *
      5           *  @details    Detailed description of the file contents
      6           *
      7           *---------------------------------------------------------------------------------------------------------------------
      8           *------------------- Copyright 2012.  Whirlpool Corporation.  All rights reserved - CONFIDENTIAL ---------------------
      9           *---------------------------------------------------------------------------------------------------------------------
     10           */
     11          
     12          //-------------------------------------- Include Files ----------------------------------------------------------------
     13          #include "SpeedRefGen.h"
     14          #include "MclConfig.h"
     15          #include "McMathCalc_macros.h"
     16          #include "Mci_prm.h"
     17          
     18          
     19          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     20          
     21          uint8 Apply_Default_Accel;
     22          float32 Default_Accel;
     23          float32 Increment;
     24          float32 SpeedRef_Target_Speed;
     25          float32 SpeedRef_Reference_Speed;
     26          

   \                                 In section .bss, align 4
     27          float32 Max_Delta_Rpm;
   \                     Max_Delta_Rpm:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     28          float32 Starting_Accel;
   \                     Starting_Accel:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     29          float32 Min_Speed_For_Fixed_Accel;
   \                     Min_Speed_For_Fixed_Accel:
   \   00000000                      DS8 4
     30          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     31          #ifndef RPM_TO_RADS
     32              #define RPM_TO_RADS     0.10471975511965977461542144610932f
     33          #endif
     34          
     35          //! Converts a value into TRUE or FALSE; 0 is FALSE, TRUE otherwise.
     36          #ifndef GET_TRUE_FALSE
     37              #define GET_TRUE_FALSE(value)           (BOOL_TYPE)(((value) == 0) ? (FALSE) : (TRUE))
     38          #endif
     39          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
     40          
     41          //=====================================================================================================================
     42          //-------------------------------------- Public Functions -------------------------------------------------------------
     43          //=====================================================================================================================
     44          
     45          
     46          
     47          //---------------------------------------------------------------------------------------------------------------------
     48          /**
     49           * @brief       Initialize the speed reference generator.
     50           */

   \                                 In section .text, align 2, keep-with-next
     51          void SpeedRefGen__Initialize(void)
     52          {
     53              SpeedRef_Target_Speed = 0.0f;
   \                     SpeedRefGen__Initialize: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable146
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0xF8C0 0x14D8      STR      R1,[R0, #+1240]
     54              SpeedRef_Reference_Speed = 0.0f;
   \   0000000A   0xF8C0 0x14DC      STR      R1,[R0, #+1244]
     55              Default_Accel = SPEEDREF__STARTING_ACCEL;
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable140  ;; 0x3a80adfd
   \   00000012   0xF8C0 0x14D0      STR      R1,[R0, #+1232]
     56              Apply_Default_Accel = FALSE;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xF880 0x136B      STRB     R1,[R0, #+875]
     57          }
   \   0000001C   0x4770             BX       LR               ;; return
     58          
     59          
     60          
     61          
     62          //---------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     63          void SpeedRefGen__SetSpeedParams(float32 default_accel)
     64          {
     65              Default_Accel = default_accel * SPEEDREF__TS * RPM_TO_RADS;
   \                     SpeedRefGen__SetSpeedParams: (+1)
   \   00000000   0xEDDF 0x....      VLDR.W   S1,??DataTable136  ;; 0x3903126f
   \   00000004   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000008   0xEDDF 0x....      VLDR.W   S1,??DataTable133  ;; 0x3dd67750
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable162
   \   00000010   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000014   0xED80 0x0A00      VSTR     S0,[R0, #0]
     66          }
   \   00000018   0x4770             BX       LR               ;; return
     67          
     68          
     69          
     70          
     71          //---------------------------------------------------------------------------------------------------------------------
     72          /**
     73           * @brief       Reset only intermediate variables, speed and accel targets are kept!
     74           *
     75           */

   \                                 In section .text, align 2, keep-with-next
     76          void SpeedRefGen__Reset(void)
     77          {
     78              SpeedRef_Reference_Speed = 0.0f;
   \                     SpeedRefGen__Reset: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable146
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0xF8C0 0x14DC      STR      R1,[R0, #+1244]
     79          }
   \   0000000A   0x4770             BX       LR               ;; return
     80          
     81          
     82          
     83          
     84          //---------------------------------------------------------------------------------------------------------------------
     85          /**
     86           * @brief       Configure the new speed.
     87           *
     88           * @param       target_rpm this is the target in RPM
     89           * @param       accel_rpm_s acceleration in RPM/s
     90           * @return      SPEED_REF_DENIED    [0] either speed or acceleration denied
     91           *              SPEED_REF_ACCEPTED  [1] both speed and acceleration accepted
     92           *              SPEED_REF_NEG_STEP  [2] step on speed reference accepted
     93           *              SPEED_REF_POS_STEP  [3] step on speed reference accepted
     94           */

   \                                 In section .text, align 4, keep-with-next
     95          SPEED_REF_SET_NEW_SPEED_TYPE SpeedRefGen__SetNewSpeed(sint32 target_rpm, sint32 accel_rpm_s)
     96          {
     97              float32 temp_f;
     98              SPEED_REF_SET_NEW_SPEED_TYPE ret_val;
     99              sint32 accel_rpm_s_abs;
    100          
    101              ret_val = SPEED_REF_DENIED;
   \                     SpeedRefGen__SetNewSpeed: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    102          
    103              accel_rpm_s_abs = MATHCALC__ABS(accel_rpm_s);
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xBF48             IT       MI 
   \   00000006   0x4249             RSBMI    R1,R1,#+0
    104          
    105              if(accel_rpm_s_abs == 0)
   \   00000008   0xED9F 0x....      VLDR.W   S0,??DataTable133  ;; 0x3dd67750
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable146
   \   00000010   0xBB41             CBNZ.N   R1,??SpeedRefGen__SetNewSpeed_0
    106              {
    107                  temp_f  = (float32)(MATHCALC__ABS(target_rpm)) * RPM_TO_RADS;
   \   00000012   0x0001             MOVS     R1,R0
   \   00000014   0xBF48             IT       MI 
   \   00000016   0x4249             RSBMI    R1,R1,#+0
   \   00000018   0xEE00 0x1A90      VMOV     S1,R1
    108                  temp_f -= MATHCALC__FABS(SpeedRefGen__GetSpeedRef());
   \   0000001C   0xF8D3 0x14DC      LDR      R1,[R3, #+1244]
   \   00000020   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000024   0xF021 0x4100      BIC      R1,R1,#0x80000000
   \   00000028   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   0000002C   0xEE01 0x1A10      VMOV     S2,R1
   \   00000030   0xEE70 0x0AC1      VSUB.F32 S1,S1,S2
   \   00000034   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   00000038   0xEEF1 0xFA10      FMSTAT   
   \   0000003C   0xD52B             BPL.N    ??SpeedRefGen__SetNewSpeed_1
    109          
    110                  if(temp_f < 0)
    111                  {
    112                      SpeedRef_Reference_Speed = (float32) target_rpm * RPM_TO_RADS;
   \   0000003E   0xEE00 0x0A90      VMOV     S1,R0
   \   00000042   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000046   0xF203 0x40DC      ADDW     R0,R3,#+1244
   \   0000004A   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   0000004E   0xED80 0x0A00      VSTR     S0,[R0, #0]
    113                      SpeedRef_Target_Speed = SpeedRef_Reference_Speed;
   \   00000052   0xF203 0x40D8      ADDW     R0,R3,#+1240
    114                      Increment = 0.0f;
   \   00000056   0xF8C3 0x24D4      STR      R2,[R3, #+1236]
   \   0000005A   0xED80 0x0A00      VSTR     S0,[R0, #0]
    115          
    116                      ret_val = SPEED_REF_NEG_STEP;
   \   0000005E   0x2202             MOVS     R2,#+2
    117                  }
    118              }
    119              else
    120              {
    121                  SpeedRef_Target_Speed = (float32) target_rpm * RPM_TO_RADS;
    122          
    123                  //The speed reference is incremented by means of Gradient * FunctionCallTime which is [Rpm/s] * [s] => [Rpm]
    124                  Increment  = (float32) accel_rpm_s_abs * SPEEDREF__TS * RPM_TO_RADS;
    125          
    126                  ret_val = SPEED_REF_ACCEPTED;
    127              }
    128          
    129              return(ret_val);
   \   00000060   0x4610             MOV      R0,R2
   \   00000062   0x4770             BX       LR
   \                     ??SpeedRefGen__SetNewSpeed_0: (+1)
   \   00000064   0xEE00 0x0A90      VMOV     S1,R0
   \   00000068   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   0000006C   0xF203 0x40D8      ADDW     R0,R3,#+1240
   \   00000070   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000074   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
   \   00000078   0xEE00 0x1A90      VMOV     S1,R1
   \   0000007C   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000080   0xED9F 0x....      VLDR.W   S2,??DataTable136  ;; 0x3903126f
   \   00000084   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   00000088   0xF203 0x40D4      ADDW     R0,R3,#+1236
   \   0000008C   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   00000090   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   00000094   0x2201             MOVS     R2,#+1
   \                     ??SpeedRefGen__SetNewSpeed_1: (+1)
   \   00000096   0x4610             MOV      R0,R2
   \   00000098   0x4770             BX       LR               ;; return
    130          }
    131          
    132          
    133          
    134          
    135          //---------------------------------------------------------------------------------------------------------------------
    136          /**
    137           * @brief       This is the handler to generate the new speed reference
    138           * @return      the new speed reference in rad\s (mechanical)
    139           */

   \                                 In section .text, align 4, keep-with-next
    140          float32 SpeedRefGen__Generator(void)
    141          {
    142          	float32 temp_increment;
    143          
    144          	if(Apply_Default_Accel)
   \                     SpeedRefGen__Generator: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable146
   \   00000004   0xF890 0x136B      LDRB     R1,[R0, #+875]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xBF14             ITE      NE 
    145          	{
    146          		temp_increment = Default_Accel;
   \   0000000C   0xF8D0 0x14D0      LDRNE    R1,[R0, #+1232]
    147          	}
    148          	else
    149          	{
    150          		temp_increment = Increment;
   \   00000010   0xF8D0 0x14D4      LDREQ    R1,[R0, #+1236]
   \   00000014   0xEE00 0x1A90      VMOV     S1,R1
    151          	}
    152          
    153          
    154              if(SpeedRef_Target_Speed > SpeedRef_Reference_Speed)
   \   00000018   0xF8D0 0x14DC      LDR      R1,[R0, #+1244]
   \   0000001C   0xEE01 0x1A10      VMOV     S2,R1
   \   00000020   0xF8D0 0x14D8      LDR      R1,[R0, #+1240]
   \   00000024   0xEE00 0x1A10      VMOV     S0,R1
   \   00000028   0xEEB4 0x1A40      VCMP.F32 S2,S0
   \   0000002C   0xEEF1 0xFA10      FMSTAT   
   \   00000030   0xD51B             BPL.N    ??SpeedRefGen__Generator_0
    155              {
    156              	if ((temp_increment >SPEEDREF__MAX_RPM_PER_SEC_DECEL)&&(SpeedRef_Target_Speed < 0))
   \   00000032   0xEDDF 0x....      VLDR.W   S3,??DataTable139  ;; 0x3d567751
   \   00000036   0xEEF4 0x0A61      VCMP.F32 S1,S3
   \   0000003A   0xEEF1 0xFA10      FMSTAT   
   \   0000003E   0xDB06             BLT.N    ??SpeedRefGen__Generator_1
   \   00000040   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000044   0xEEF1 0xFA10      FMSTAT   
   \   00000048   0xBF48             IT       MI 
    157              	{
    158                  		temp_increment = SPEEDREF__MAX_RPM_PER_SEC_DECEL;
   \   0000004A   0xEDDF 0x....      VLDRMI.W S1,??DataTable139_1  ;; 0x3d567750
    159              	}
    160          		if((MATHCALC__FABS(SpeedRef_Reference_Speed) < SPEEDREF__MIN_SPEED_FOR_FIXED_ACCEL))
   \                     ??SpeedRefGen__Generator_1: (+1)
   \   0000004E   0xEEF0 0x1AC1      VABS.F32 S3,S2
   \   00000052   0xEEF5 0x1A40      VCMP.F32 S3,#0.0
   \   00000056   0xEEF1 0xFA10      FMSTAT   
   \   0000005A   0xBF48             IT       MI 
    161          		{
    162          				temp_increment = SPEEDREF__STARTING_ACCEL;
   \   0000005C   0xEDDF 0x....      VLDRMI.W S1,??DataTable140  ;; 0x3a80adfd
    163          		}
    164                  SpeedRef_Reference_Speed += temp_increment;
   \   00000060   0xEE31 0x1A20      VADD.F32 S2,S2,S1
    165                  if(SpeedRef_Reference_Speed >= SpeedRef_Target_Speed)
   \   00000064   0xEEB4 0x1A40      VCMP.F32 S2,S0
   \   00000068   0xE01F             B.N      ??SpeedRefGen__Generator_2
    166                  {
    167                      SpeedRef_Reference_Speed = SpeedRef_Target_Speed;
    168                  }
    169              }
    170              else if(SpeedRef_Target_Speed < SpeedRef_Reference_Speed)
   \                     ??SpeedRefGen__Generator_0: (+1)
   \   0000006A   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   0000006E   0xEEF1 0xFA10      FMSTAT   
   \   00000072   0xD51F             BPL.N    ??SpeedRefGen__Generator_3
    171              {
    172          
    173              	if ((temp_increment >SPEEDREF__MAX_RPM_PER_SEC_DECEL)&&(SpeedRef_Target_Speed >0))
   \   00000074   0xEDDF 0x....      VLDR.W   S3,??DataTable139  ;; 0x3d567751
   \   00000078   0xEEF4 0x0A61      VCMP.F32 S1,S3
   \   0000007C   0xEEF1 0xFA10      FMSTAT   
   \   00000080   0xDB06             BLT.N    ??SpeedRefGen__Generator_4
   \   00000082   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000086   0xEEF1 0xFA10      FMSTAT   
   \   0000008A   0xBFC8             IT       GT 
    174              	{
    175              			temp_increment = SPEEDREF__MAX_RPM_PER_SEC_DECEL;
   \   0000008C   0xEDDF 0x....      VLDRGT.W S1,??DataTable139_1  ;; 0x3d567750
    176              	}
    177                  if((MATHCALC__FABS(SpeedRef_Reference_Speed) < SPEEDREF__MIN_SPEED_FOR_FIXED_ACCEL))
   \                     ??SpeedRefGen__Generator_4: (+1)
   \   00000090   0xEEF0 0x1AC1      VABS.F32 S3,S2
   \   00000094   0xEEF5 0x1A40      VCMP.F32 S3,#0.0
   \   00000098   0xEEF1 0xFA10      FMSTAT   
   \   0000009C   0xBF48             IT       MI 
    178          		{
    179          					temp_increment = SPEEDREF__STARTING_ACCEL;
   \   0000009E   0xEDDF 0x....      VLDRMI.W S1,??DataTable140  ;; 0x3a80adfd
    180          		}
    181          
    182                  SpeedRef_Reference_Speed -= temp_increment;
   \   000000A2   0xEE31 0x1A60      VSUB.F32 S2,S2,S1
    183                  if(SpeedRef_Target_Speed >= SpeedRef_Reference_Speed)
   \   000000A6   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \                     ??SpeedRefGen__Generator_2: (+1)
   \   000000AA   0xEEF1 0xFA10      FMSTAT   
   \   000000AE   0xBFA8             IT       GE 
    184                  {
    185                      SpeedRef_Reference_Speed = SpeedRef_Target_Speed;
   \   000000B0   0xEEB0 0x1A40      VMOVGE.F32 S2,S0
   \                     ??SpeedRefGen__Generator_3: (+1)
   \   000000B4   0xF200 0x41DC      ADDW     R1,R0,#+1244
   \   000000B8   0xED81 0x1A00      VSTR     S2,[R1, #0]
    186                  }
    187              }
    188          
    189              return(SpeedRef_Reference_Speed);
   \   000000BC   0xF8D0 0x04DC      LDR      R0,[R0, #+1244]
   \   000000C0   0xEE00 0x0A10      VMOV     S0,R0
   \   000000C4   0x4770             BX       LR               ;; return
    190          }
    191          
    192          
    193          
    194          
    195          //---------------------------------------------------------------------------------------------------------------------
    196          /**
    197           * @brief       Get speed reference
    198           * @return      speed reference in rad\s
    199           */

   \                                 In section .text, align 2, keep-with-next
    200          float32 SpeedRefGen__GetSpeedRef(void)
    201          {
    202              float32 ret_val;
    203          
    204              ret_val = SpeedRef_Reference_Speed;
    205          
    206              return(ret_val);
   \                     SpeedRefGen__GetSpeedRef: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable164
   \   00000004   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000008   0x4770             BX       LR               ;; return
    207          }
    208          
    209          
    210          
    211          
    212          //---------------------------------------------------------------------------------------------------------------------
    213          /**
    214           * @brief       Get speed target
    215           * @return      speed target in rad\s
    216           */

   \                                 In section .text, align 2, keep-with-next
    217          float32 SpeedRefGen__GetSpeedTarget(void)
    218          {
    219              float32 ret_val;
    220          
    221              ret_val = SpeedRef_Target_Speed;
    222          
    223              return(ret_val);
   \                     SpeedRefGen__GetSpeedTarget: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable164_1
   \   00000004   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000008   0x4770             BX       LR               ;; return
    224          }
    225          
    226          
    227          
    228          
    229          //---------------------------------------------------------------------------------------------------------------------
    230          /**
    231           * @brief       Get the current status of the speed reference, the return data info is
    232           *              explained in the return data.
    233           * @return      SPEED_REF_ZEROED - the speed reference is at zero
    234           *              SPEED_REF_ACCELERATING - speed reference is increasing
    235           *              SPEED_REF_DECELERATING - speed reference is decreasing
    236           *              SPEED_REF_AT_PLATEAU - the speed reference is at the target
    237           *
    238           *       ***********************  Combinatorial table  *****************************
    239           *       target ... ref     sign target      sign product        status
    240           *       ***************************************************************************
    241           *               <              +                +               decelerating
    242           *               >              +                +               accelerating
    243           *               <              -                +               accelerating
    244           *               >              -                +               decelerating
    245           *               <              +                -               not possible
    246           *               >              +                -               decelerating
    247           *               <              -                -               decelerating
    248           *               >              -                -               not possible
    249           *       ***************************************************************************
    250           */
    251          

   \                                 In section .text, align 2, keep-with-next
    252          SPEED_REF_STATUS_TYPE SpeedRefGen__GetStatus(void)
    253          {
    254              SPEED_REF_STATUS_TYPE status;
    255              float32 target_temp;
    256              float32 reference_temp;
    257              float32 target_ref_product;
    258          
    259              target_temp = MATHCALC__FABS(SpeedRef_Target_Speed);
   \                     SpeedRefGen__GetStatus: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable146
   \   00000004   0xF8D0 0x14D8      LDR      R1,[R0, #+1240]
    260              reference_temp = MATHCALC__FABS(SpeedRef_Reference_Speed);
   \   00000008   0xF8D0 0x04DC      LDR      R0,[R0, #+1244]
   \   0000000C   0xEE00 0x1A10      VMOV     S0,R1
   \   00000010   0xEEF0 0x0AC0      VABS.F32 S1,S0
   \   00000014   0xEE01 0x0A10      VMOV     S2,R0
    261          
    262              target_ref_product = SpeedRef_Target_Speed * SpeedRef_Reference_Speed;
    263          
    264          
    265              if( (!target_temp)  &&
    266                  (!reference_temp)  )
   \   00000018   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   0000001C   0xEEF0 0x1AC1      VABS.F32 S3,S2
   \   00000020   0xEE20 0x2A01      VMUL.F32 S4,S0,S2
   \   00000024   0xEEF1 0xFA10      FMSTAT   
   \   00000028   0xBF04             ITT      EQ 
   \   0000002A   0xEEF5 0x1A40      VCMPEQ.F32 S3,#0.0
   \   0000002E   0xEEF1 0xFA10      FMSTATEQ 
   \   00000032   0xD101             BNE.N    ??SpeedRefGen__GetStatus_0
    267              {
    268                  status = SPEED_REF_ZEROED;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x4770             BX       LR
    269              }
    270              else if(SpeedRef_Target_Speed == SpeedRef_Reference_Speed)
   \                     ??SpeedRefGen__GetStatus_0: (+1)
   \   00000038   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   0000003C   0xEEF1 0xFA10      FMSTAT   
   \   00000040   0xD101             BNE.N    ??SpeedRefGen__GetStatus_1
    271              {
    272                  status = SPEED_REF_AT_PLATEAU;
   \   00000042   0x2003             MOVS     R0,#+3
   \   00000044   0x4770             BX       LR
    273              }
    274              else if(target_ref_product >= 0)
   \                     ??SpeedRefGen__GetStatus_1: (+1)
   \   00000046   0xEEB5 0x2A40      VCMP.F32 S4,#0.0
   \   0000004A   0xEEF1 0xFA10      FMSTAT   
   \   0000004E   0xDB06             BLT.N    ??SpeedRefGen__GetStatus_2
    275              {
    276                  if(target_temp < reference_temp)
   \   00000050   0xEEF4 0x0A61      VCMP.F32 S1,S3
   \   00000054   0xEEF1 0xFA10      FMSTAT   
   \   00000058   0xD401             BMI.N    ??SpeedRefGen__GetStatus_2
    277                  {
    278                      status = SPEED_REF_DECELERATING;
    279                  }
    280                  else //if(target_temp > reference_temp)
    281                  {
    282                      status = SPEED_REF_ACCELERATING;
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x4770             BX       LR
    283                  }
    284              }
    285              else
    286              {
    287                  status = SPEED_REF_DECELERATING;
   \                     ??SpeedRefGen__GetStatus_2: (+1)
   \   0000005E   0x2002             MOVS     R0,#+2
    288              }
    289          
    290              return(status);
   \   00000060   0x4770             BX       LR               ;; return
    291          }
    292          
    293          
    294          
    295          /*
    296           * @brief		Request the speed reference to apply minimum acceleration
    297           * @param[in]	apply_min_accel: 	TRUE - force default acceleration read from Mci
    298           * 									FALSE - use user acceleration from Mci API
    299           */

   \                                 In section .text, align 2, keep-with-next
    300          void SpeedRefGen__ApplyDefaultAccel(uint8 apply_min_accel)
    301          {
    302          	Apply_Default_Accel = GET_TRUE_FALSE(apply_min_accel);
   \                     SpeedRefGen__ApplyDefaultAccel: (+1)
   \   00000000   0x1E41             SUBS     R1,R0,#+1
   \   00000002   0x4189             SBCS     R1,R1,R1
   \   00000004   0x43C9             MVNS     R1,R1
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable146
   \   0000000A   0x0FC9             LSRS     R1,R1,#+31
   \   0000000C   0xF880 0x136B      STRB     R1,[R0, #+875]
    303          }
   \   00000010   0x4770             BX       LR               ;; return
    304          
    305          
    306          
    307          //---------------------------------------------------------------------------------------------------------------------
    308          /**
    309           * @brief       Get speed reference in IQ format
    310           * @params      speed base and IQ format
    311           * @return      speed target in IQ format
    312           */

   \                                 In section .text, align 2, keep-with-next
    313          sint32 SpeedRefGen__GetSpeedRefIQ(float32 speed_base, uint8 iq_format)
    314          {
    315             sint32 ret_val;
    316          
    317             ret_val = (sint32)(SpeedRef_Reference_Speed / speed_base * (float32)(1U<<iq_format));
    318          
    319             return(ret_val);
   \                     SpeedRefGen__GetSpeedRefIQ: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable164
   \   00000004   0xEDD1 0x0A00      VLDR     S1,[R1, #0]
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0xEE80 0x0A80      VDIV.F32 S0,S1,S0
   \   0000000E   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000012   0xEE00 0x0A90      VMOV     S1,R0
   \   00000016   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \   0000001A   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000001E   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000022   0xEE10 0x0A10      VMOV     R0,S0
   \   00000026   0x4770             BX       LR               ;; return
    320          }
    321          
    322          //---------------------------------------------------------------------------------------------------------------------
    323          /**
    324           * @brief       Get speed target in IQ format
    325           * @params      speed base and IQ format
    326           * @return      speed target in IQ format
    327           */

   \                                 In section .text, align 2, keep-with-next
    328          sint32 SpeedRefGen__GetSpeedTargetIQ(float32 speed_base, uint8 iq_format)
    329          {
    330              sint32 ret_val;
    331          
    332              ret_val = (sint32)(SpeedRef_Target_Speed / speed_base * (float32)(1U<<iq_format));
    333          
    334              return(ret_val);
   \                     SpeedRefGen__GetSpeedTargetIQ: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable164_1
   \   00000004   0xEDD1 0x0A00      VLDR     S1,[R1, #0]
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0xEE80 0x0A80      VDIV.F32 S0,S1,S0
   \   0000000E   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000012   0xEE00 0x0A90      VMOV     S1,R0
   \   00000016   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \   0000001A   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000001E   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000022   0xEE10 0x0A10      VMOV     R0,S0
   \   00000026   0x4770             BX       LR               ;; return
    335          }
    336          
    337          
    338          //=====================================================================================================================
    339          //---------------------------------------------- Private Functions ----------------------------------------------------
    340          //=====================================================================================================================
    341          
    342          
    343          
C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\InverterTemp\InverterTemp.c
      1          /**
      2           *  @file       InverterTemp.c
      3           *
      4           *  @brief      Inverter (silicon) NTC temperature
      5           *
      6           *  @details    Reads the analog input connected to an external NTC attached to the inverter silicon.
      7           *              This module reads the analog data, filters it out and scale the analog temperature
      8           *              in to Celsius degree.
      9           *
     10           *  @section    Applicable_Documents
     11           *					List here all the applicable documents if needed. <tr>	
     12           *
     13           *  $Header: InverterTemp.c 1.6 2016/01/13 20:08:12CET Marcelo Silva (SILVAMC) Exp  $
     14           *
     15           *  @copyright  Copyright 2014-$Date: 2016/01/13 20:08:12CET $. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     16           */
     17          //---------------------------------------------------------------------------------------------------------------------
     18          //---------------------------------------------------------------------------------------------------------------------
     19          
     20          
     21          //-------------------------------------- Include Files ----------------------------------------------------------------
     22          #include "C_Extensions.h"
     23          #include "InverterTemp.h"

  #if (INVERTER_TEMP_SETTINGFILE_SUPPORT == ENABLED)
       ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\InverterTemp\InverterTemp.h",25  Remark[Pe193]: 
          zero used for undefined preprocessing identifier
          "INVERTER_TEMP_SETTINGFILE_SUPPORT"

  #if (INVERTER_TEMP_SETTINGFILE_SUPPORT == DISABLED)
       ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\InverterTemp\InverterTemp.h",44  Remark[Pe193]: 
          zero used for undefined preprocessing identifier
          "INVERTER_TEMP_SETTINGFILE_SUPPORT"

  #if (INVERTER_TEMP_SETTINGFILE_SUPPORT == ENABLED)
       ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\InverterTemp\InverterTemp.h",47  Remark[Pe193]: 
          zero used for undefined preprocessing identifier
          "INVERTER_TEMP_SETTINGFILE_SUPPORT"
     24          #include "InverterTemp_prv.h"
     25          #include "Filters.h"
     26          #include "MathCalc.h"
     27          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     28          
     29          
     30          #ifdef MCI_MEASURE_INVERTER_TEMP
     31          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     32          
     33          #ifndef INVERTER_TEMP_SETTINGFILE_SUPPORT
     34              #define INVERTER_TEMP_SETTINGFILE_SUPPORT DISABLED
     35          #endif
     36          
     37          //! History of the filter
     38          static sint32 Temperature_Sum;
     39          
     40          //! Output of the lookup table
     41          static sint32 Temperature_Degrees;
     42          
     43          //! Raw ADC filtered value
     44          static sint32 Temperature_Raw;
     45          
     46          static MATHCALC_LUT_EXT_TYPE Actual_Inverter_Temp_Ext_LUT;
     47          
     48          #if (INVERTER_TEMP_SETTINGFILE_SUPPORT == ENABLED)
     49          static INVERTER_TEMP_PARAMS_DISPL_TYPE* InverterTemp_Params_Displ;
     50          
     51          static BOOL_TYPE Inverter_Temp_Params_Loaded;
     52          #endif // INVERTER_TEMP_SETTINGFILE_SUPPORT
     53          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
     54          
     55          
     56          //=====================================================================================================================
     57          //-------------------------------------- Public Functions -------------------------------------------------------------
     58          //=====================================================================================================================
     59          
     60          
     61          
     62          //---------------------------------------------------------------------------------------------------------------------
     63          /**
     64           *  @brief      It Initializes the module InverterTemp and its variables
     65           *
     66           */
     67          void InverterTemp__Initialize(void)
     68          {
     69              // Initialize the ADC engine
     70              ATOD_INITIALIZE();
     71              // Start the ADC engine
     72              ATOD_START_CONVERSION();
     73          
     74          #if (INVERTER_TEMP_SETTINGFILE_SUPPORT == ENABLED)
     75              Inverter_Temp_Params_Loaded = FALSE;
     76              Temperature_Degrees = 0;
     77              Temperature_Sum = 0;
     78              Temperature_Raw = 0;
     79          #else
     80              // LUT initialization
     81              Actual_Inverter_Temp_Ext_LUT = Inverter_Temp_LUT_Ext_Array[INVERTER_TEMP_DEFAULT_LUT].ext_lut;
     82          
     83              // Initialize the temperatures to the default values
     84              Temperature_Sum = Inverter_Temp_LUT_Ext_Array[INVERTER_TEMP_DEFAULT_LUT].default_temp_adc  << INVERTER_TEMP_LPF_SHIFT;
     85              Temperature_Raw = Inverter_Temp_LUT_Ext_Array[INVERTER_TEMP_DEFAULT_LUT].default_temp_adc;
     86          
     87              Temperature_Degrees = MathCalc__GetInterpolationFast(Temperature_Raw, &Actual_Inverter_Temp_Ext_LUT);
     88          #endif
     89          }
     90          
     91          
     92          //---------------------------------------------------------------------------------------------------------------------
     93          /*
     94           *  @brief      Handle the temperature read from the analog channel. It shall only
     95           *              filter the analog data read.
     96           *              Rate: it can be defined according to the setting the LPF filter shift.
     97           */
     98          void InverterTemp__Handler(void)
     99          {
    100              sint16 temp_adc;
    101          
    102          #if (INVERTER_TEMP_SETTINGFILE_SUPPORT == ENABLED)
    103              if (Inverter_Temp_Params_Loaded)
    104              {
    105          #endif
    106                  // Read the adc inverter temperature channel
    107                  temp_adc = ATOD_GET_TEMPERATURE();
    108          
    109                  // Start the adc convertion to the next read
    110                  ATOD_START_CONVERSION();
    111          
    112                  // Low pass filter the converted adc data
    113                  FILTERS__FILTER_CALC(temp_adc, Temperature_Sum, INVERTER_TEMP_LPF_SHIFT);
    114          
    115                  // Get filtered adc value
    116                  Temperature_Raw = FILTERS__FILTER_GET_FILTERED_VAR(Temperature_Sum, INVERTER_TEMP_LPF_SHIFT);
    117          
    118                  // LUT and interpolation
    119                  Temperature_Degrees = MathCalc__GetInterpolationFast(Temperature_Raw, &Actual_Inverter_Temp_Ext_LUT);
    120          #if (INVERTER_TEMP_SETTINGFILE_SUPPORT == ENABLED)
    121              }
    122          #endif
    123          }
    124          
    125          
    126          
    127          
    128          
    129          //---------------------------------------------------------------------------------------------------------------------
    130          /*
    131           *  @brief      Handle the temperature read from the analog channel. It shall only
    132           *              filter the analog data read.
    133           *              Rate: it can be defined according to the setting the LPF filter shift.
    134           */
    135          void InverterTemp__PwmHandler(void)
    136          {
    137              INVERTER_TEMP_START__MANUAL_CONVERSION();
    138          }
    139          
    140          #if (INVERTER_TEMP_SETTINGFILE_SUPPORT == DISABLED)
    141          //---------------------------------------------------------------------------------------------------------------------
    142          /*
    143           *  @brief      Set the LUT for temperature conversion.
    144           *	
    145           *	@details	This function will set the LUT for temperature conversion according
    146           *				to the specified index. If the index is out of range, the set will be
    147           *				discarded. \n
    148           *				The temperature will also be initialized to the specified value.
    149           *	
    150           *	@param[in]	lut_index The index to the LUT to set, as defined in the prm
    151           */
    152          void InverterTemp__SetLUT(INVERTERTEMP_LUT_INDEX_TYPE lut_index)
    153          {
    154              if (lut_index < sizeof(Inverter_Temp_LUT_Ext_Array)/sizeof(INVERTER_TEMP_LUT))
    155              {
    156                  Actual_Inverter_Temp_Ext_LUT = Inverter_Temp_LUT_Ext_Array[lut_index].ext_lut;
    157                  Temperature_Sum = Inverter_Temp_LUT_Ext_Array[lut_index].default_temp_adc;
    158                  Temperature_Raw = Inverter_Temp_LUT_Ext_Array[lut_index].default_temp_adc;
    159              }
    160          }
    161          #endif // INVERTER_TEMP_SETTINGFILE_SUPPORT
    162          //---------------------------------------------------------------------------------------------------------------------
    163          /*
    164           *  @brief      Get the inverter temperature.
    165           *
    166           *  @return     Inverter temperature [degC x65536 or <<16]
    167           */
    168          sint32 InverterTemp__GetInverterTemp_s16(void)
    169          {
    170              return(Temperature_Degrees << 16);
    171          }
    172          
    173          
    174          
    175          //---------------------------------------------------------------------------------------------------------------------
    176          /**
    177           * @brief       Get the ADC read of the inverter temperature
    178           * @return      ADC result of the temperature sensor [ADC counts]
    179           */
    180          sint16 InverterTemp__GetInverterRawTemp(void)
    181          {
    182              return(Temperature_Raw);
    183          }
    184          
    185          
    186          
    187          //---------------------------------------------------------------------------------------------------------------------
    188          /*
    189           *  @brief  Compare the given temperature to a given threshold. There is no need to
    190           *          calculate the analog temperature.
    191           *  @param  [input] temperature [degC x65536 or <<16]
    192           *  @return [output] TRUE: temperature is equal or higher than the threshold
    193           *  @return [output] FALSE: temperature is lower than the threshold
    194           */
    195          BOOL_TYPE InverterTemp__AboveThreshold_s16(sint32 temp_shift_16)
    196          {
    197              sint32 temp_thr;
    198              BOOL_TYPE ret_val;
    199          
    200              // Scale the given threshold
    201              temp_thr = (temp_shift_16>>16);
    202          
    203              // Check the threshold
    204              if(Temperature_Degrees >= temp_thr)
    205              {
    206                  ret_val = TRUE;
    207              }
    208              else
    209              {
    210                  ret_val = FALSE;
    211              }
    212          
    213              return(ret_val);
    214          }
    215          
    216          #if (INVERTER_TEMP_SETTINGFILE_SUPPORT == ENABLED)
    217          //---------------------------------------------------------------------------------------------------------------------
    218          /**
    219           *  @brief      Write the address of Inverter Temp parameters.
    220           *  @details
    221           *
    222           * @return  TRUE - value accepted
    223           *          FALSE - value denied - default answer.
    224           */
    225          BOOL_TYPE InverterTemp__SetParams(void*  invtemp_params_address)
    226          {
    227              BOOL_TYPE ret_val = FALSE;
    228          
    229              if (invtemp_params_address != NULL)
    230              {
    231                  InverterTemp_Params_Displ = (INVERTER_TEMP_PARAMS_DISPL_TYPE*) invtemp_params_address;
    232          
    233                  Temperature_Raw = InverterTemp_Params_Displ->Default_Temp_Adc;
    234                  Temperature_Sum = InverterTemp_Params_Displ->Default_Temp_Adc << INVERTER_TEMP_LPF_SHIFT;
    235          
    236                  Actual_Inverter_Temp_Ext_LUT.ptr_LUT = InverterTemp_Params_Displ->Inverter_Temp_Lut;
    237                  Actual_Inverter_Temp_Ext_LUT.sizeof_lut = &InverterTemp_Params_Displ->Sizeof_Inverter_Temp_Lut;
    238                  Actual_Inverter_Temp_Ext_LUT.step_inv = &InverterTemp_Params_Displ->Step_Inv_Inverter_Temp;
    239          
    240                  Temperature_Degrees = MathCalc__GetInterpolationFast(Temperature_Raw, &Actual_Inverter_Temp_Ext_LUT);
    241          
    242                  Inverter_Temp_Params_Loaded = TRUE;
    243                  ret_val = TRUE;
    244              }
    245          
    246              return ret_val;
    247          }
    248          
    249          
    250          //---------------------------------------------------------------------------------------------------------------------
    251          /**
    252           *  @brief      Get parameters loaded status.
    253           *  @details
    254           *
    255           * @return  TRUE - parameters are loaded
    256           *          FALSE - parameters not loaded
    257           */
    258          BOOL_TYPE InverterTemp__GetParameterLoaded(void)
    259          {
    260              return Inverter_Temp_Params_Loaded;
    261          }
    262          
    263          #endif // INVERTER_TEMP_SETTINGFILE_SUPPORT
    264          #endif
    265          
    266          //=====================================================================================================================
    267          //-------------------------------------- Private Functions ------------------------------------------------------------
    268          //=====================================================================================================================
    269          
    270          
C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\Mci\SurgeRelay\SurgeRelay.c
      1          /**
      2           *  @file       SurgeRelay.c
      3           *  @brief      Basic description of file contents
      4           *
      5           *  @details    Detailed description of the file contents
      6           *
      7           *---------------------------------------------------------------------------------------------------------------------
      8           *------------------- Copyright 2012.  Whirlpool Corporation.  All rights reserved - CONFIDENTIAL ---------------------
      9           *---------------------------------------------------------------------------------------------------------------------
     10           */
     11          
     12          //-------------------------------------- Include Files ----------------------------------------------------------------
     13          #include "SurgeRelay.h"
     14          #include "C_Extensions.h"
     15          #include "Gpio.h"

  extern const volatile GPIO_DEF * GPIO_PORT_LIST[];
  ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Driver\Gpio\Gpio_macros.h",34  Remark[Pe083]: 
          type qualifier specified more than once

  PACKED typedef struct
         ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Driver\API\Gpio\Gpio.h",41  Remark[Pe082]: 
          storage class is not first
     16          
     17          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     18          #ifndef SRAPI20_CHECK
     19          #define SRAPI20_CHECK() TRUE
     20          #else
     21          SRAPI020_SPEED_MONITOR_RX_BIT_TYPE data_api20_rx;
     22          #endif
     23          
     24          #ifdef SURGE_RELAY_USED
     25              typedef enum
     26              {
     27                  SURGE_INITIALIZATION,
     28                  SURGE_WAITING,
     29                  SURGE_CLOSE,
     30                  SURGE_OPEN,
     31                  SURGE_MANUAL_MODE
     32              } SURGE_STATES_TYPE;
     33          
     34              static SURGE_STATES_TYPE Surge_State;

   \                                 In section .bss, align 2
   \   00000000                      DS8 2
     35              static unsigned short int Bus_Voltage;
     36              static unsigned short int Bus_Voltage_Previous;
     37              static unsigned char Bus_Voltage_Timer;
     38          #endif
     39          
     40          
     41          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     42          #ifdef SURGE_RELAY_USED
     43              #define RELAY_CONFIG()  Gpio__PinConfig(SURGE_RELAY_PORT, SURGE_RELAY_PIN, OUTPUT_PUSHPULL)
     44              #define RELAY_OPEN()    Gpio__PinWrite(SURGE_RELAY_PORT, SURGE_RELAY_PIN, FALSE)
     45              #define RELAY_CLOSE()   Gpio__PinWrite(SURGE_RELAY_PORT, SURGE_RELAY_PIN, TRUE)
     46          
     47              #define BUS_BASE_TIME   (VBUS_HANDLER_CALLRATE_MS/25)
     48              #define VBUS_DV_DT      (VBUS_TOLERANCE_DV_DT / (1000/VBUS_HANDLER_CALLRATE_MS))
     49          #endif
     50          
     51          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
     52          #ifdef SURGE_RELAY_USED
     53              static unsigned char IsdVbusdtStable(void);
     54          #endif
     55          
     56          //=====================================================================================================================
     57          //-------------------------------------- Public Functions -------------------------------------------------------------
     58          //=====================================================================================================================
     59          //---------------------------------------------------------------------------------------------------------------------
     60          /**
     61           *  @brief      It Initializes the module SurgeRelay and its variables
     62           *
     63           */

   \                                 In section .text, align 2, keep-with-next
     64          void SurgeRelay__Initialize(void)
     65          {
   \                     SurgeRelay__Initialize: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
     66          #ifdef SURGE_RELAY_USED
     67              RELAY_CONFIG();
   \   00000004   0x2206             MOVS     R2,#+6
   \   00000006   0x2118             MOVS     R1,#+24
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0x.... 0x....      BL       Gpio__PinConfig
     68              Surge_State = SURGE_WAITING;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable146
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0xF880 0x136C      STRB     R1,[R0, #+876]
     69              Bus_Voltage_Previous = 0;
     70              Bus_Voltage_Timer = 1;                            // Force to execute the handler at first call.
     71              RELAY_OPEN();
   \   00000018   0xB001             ADD      SP,SP,#+4
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0xF8A0 0x1398      STRH     R1,[R0, #+920]
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0xF880 0x136D      STRB     R1,[R0, #+877]
   \   00000028   0x2118             MOVS     R1,#+24
   \   0000002A   0xF85D 0xEB04      POP      {LR}
   \   0000002E   0x2004             MOVS     R0,#+4
   \   00000030   0x.... 0x....      B.W      Gpio__PinWrite
     72          #endif
     73          }
     74          
     75          //---------------------------------------------------------------------------------------------------------------------
     76          /**
     77           *  @brief      Handler the state machine which will control the surge relay. The use of Vbus voltage is required.
     78           *
     79           *  @param      None
     80           *  @return     None
     81           */

   \                                 In section .text, align 2, keep-with-next
     82          void SurgeRelay__25msHandler(void)
     83          {
   \                     SurgeRelay__25msHandler: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
     84          
     85          #ifdef SURGE_RELAY_USED
     86              Bus_Voltage_Timer--;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable146
   \   00000006   0xF894 0x036D      LDRB     R0,[R4, #+877]
   \   0000000A   0x1E40             SUBS     R0,R0,#+1
   \   0000000C   0xF884 0x036D      STRB     R0,[R4, #+877]
   \   00000010   0xB081             SUB      SP,SP,#+4
     87              if(!Bus_Voltage_Timer)
   \   00000012   0xB2C0             UXTB     R0,R0
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD144             BNE.N    ??SurgeRelay__25msHandler_0
     88              {
     89                  Bus_Voltage_Timer = BUS_BASE_TIME;
   \   00000018   0x2008             MOVS     R0,#+8
   \   0000001A   0xF884 0x036D      STRB     R0,[R4, #+877]
     90                  Bus_Voltage = SURGERELAY_READ_DCBUS_VOLTAGE();
   \   0000001E   0x210D             MOVS     R1,#+13
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      BL       Mci__GetAnalog
   \   00000026   0x1405             ASRS     R5,R0,#+16
     91                  switch(Surge_State)
   \   00000028   0xF894 0x036C      LDRB     R0,[R4, #+876]
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD005             BEQ.N    ??SurgeRelay__25msHandler_1
   \   00000030   0xD337             BCC.N    ??SurgeRelay__25msHandler_0
   \   00000032   0x2803             CMP      R0,#+3
   \   00000034   0xD02F             BEQ.N    ??SurgeRelay__25msHandler_2
   \   00000036   0xD31C             BCC.N    ??SurgeRelay__25msHandler_3
     92                  {
     93                      case SURGE_WAITING:
     94                          if( (IsdVbusdtStable())  &&
     95                              (Bus_Voltage >= VBUS_RELAY_MIN_WAIT_VOLTAGE)&&(SRAPI20_CHECK()==TRUE))
     96                          {
     97                              RELAY_CLOSE();
     98                              Surge_State = SURGE_CLOSE;
     99                          }
    100                          break;
    101          
    102                      case SURGE_CLOSE:
    103                          if((Bus_Voltage < VBUS_RELAY_OPEN_VOLTAGE)||(SRAPI20_CHECK()==FALSE))
    104                          {
    105                              RELAY_OPEN();
    106                              Surge_State = SURGE_OPEN;
    107                          }
    108                          else
    109                          {
    110                              RELAY_CLOSE();                      // Do refresh on Surge relay pin.
    111                          }
    112                          break;
    113          
    114                      case SURGE_OPEN:
    115                          if(Bus_Voltage > VBUS_RELAY_CLOSE_VOLTAGE)
    116                          {
    117                              Surge_State = SURGE_WAITING;
    118                          }
    119                          break;
    120          
    121                      default:
    122                          // This was left blank intentionally.
    123                          break;
    124                  }
    125              }
    126          #endif
    127          
    128          
    129          
    130          }
   \   00000038   0xB001             ADD      SP,SP,#+4
   \   0000003A   0xBD30             POP      {R4,R5,PC}
   \                     ??SurgeRelay__25msHandler_1: (+1)
   \   0000003C   0x210D             MOVS     R1,#+13
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      BL       Mci__GetAnalog
   \   00000044   0x1400             ASRS     R0,R0,#+16
   \   00000046   0xF8B4 0x1398      LDRH     R1,[R4, #+920]
   \   0000004A   0xB280             UXTH     R0,R0
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xBFAC             ITE      GE 
   \   00000050   0x1A41             SUBGE    R1,R0,R1
   \   00000052   0x1A09             SUBLT    R1,R1,R0
   \   00000054   0xB289             UXTH     R1,R1
   \   00000056   0xF8A4 0x0398      STRH     R0,[R4, #+920]
   \   0000005A   0x2903             CMP      R1,#+3
   \   0000005C   0xDA21             BGE.N    ??SurgeRelay__25msHandler_0
   \   0000005E   0xB2AD             UXTH     R5,R5
   \   00000060   0x2DDC             CMP      R5,#+220
   \   00000062   0xDB1E             BLT.N    ??SurgeRelay__25msHandler_0
   \   00000064   0x2201             MOVS     R2,#+1
   \   00000066   0x2118             MOVS     R1,#+24
   \   00000068   0x2004             MOVS     R0,#+4
   \   0000006A   0x.... 0x....      BL       Gpio__PinWrite
   \   0000006E   0x2002             MOVS     R0,#+2
   \   00000070   0xE015             B.N      ??SurgeRelay__25msHandler_4
   \                     ??SurgeRelay__25msHandler_3: (+1)
   \   00000072   0xB2AD             UXTH     R5,R5
   \   00000074   0x2D8C             CMP      R5,#+140
   \   00000076   0xDA06             BGE.N    ??SurgeRelay__25msHandler_5
   \   00000078   0x2200             MOVS     R2,#+0
   \   0000007A   0x2118             MOVS     R1,#+24
   \   0000007C   0x2004             MOVS     R0,#+4
   \   0000007E   0x.... 0x....      BL       Gpio__PinWrite
   \   00000082   0x2003             MOVS     R0,#+3
   \   00000084   0xE00B             B.N      ??SurgeRelay__25msHandler_4
   \                     ??SurgeRelay__25msHandler_5: (+1)
   \   00000086   0xB001             ADD      SP,SP,#+4
   \   00000088   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   0000008C   0x2201             MOVS     R2,#+1
   \   0000008E   0x2118             MOVS     R1,#+24
   \   00000090   0x2004             MOVS     R0,#+4
   \   00000092   0x.... 0x....      B.W      Gpio__PinWrite
   \                     ??SurgeRelay__25msHandler_2: (+1)
   \   00000096   0xB2AD             UXTH     R5,R5
   \   00000098   0x2DF1             CMP      R5,#+241
   \   0000009A   0xDB02             BLT.N    ??SurgeRelay__25msHandler_0
   \   0000009C   0x2001             MOVS     R0,#+1
   \                     ??SurgeRelay__25msHandler_4: (+1)
   \   0000009E   0xF884 0x036C      STRB     R0,[R4, #+876]
   \                     ??SurgeRelay__25msHandler_0: (+1)
   \   000000A2   0xB001             ADD      SP,SP,#+4
   \   000000A4   0xBD30             POP      {R4,R5,PC}       ;; return
    131          
    132          //---------------------------------------------------------------------------------------------------------------------
    133          /**
    134           *  @brief      Returns if the DC bus voltage is already stabilized and set to go.
    135           *
    136           *  @param      None
    137           *  @return     TRUE - DC Bus ready
    138           *              FALSE - DC Bus not ready.
    139           */

   \                                 In section .text, align 2, keep-with-next
    140          unsigned char SurgeRelay__IsBusReady(void)
    141          {
    142          #ifdef SURGE_RELAY_USED
    143              unsigned char result;
    144          
    145              result = FALSE;
   \                     SurgeRelay__IsBusReady: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable146
   \   00000004   0xF891 0x136C      LDRB     R1,[R1, #+876]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x2902             CMP      R1,#+2
   \   0000000C   0xBF14             ITE      NE 
    146          
    147              if(Surge_State == SURGE_CLOSE)
    148              {
    149                  result = TRUE;
    150              }
    151              else if(Surge_State == SURGE_MANUAL_MODE)
   \   0000000E   0x2904             CMPNE    R1,#+4
    152              {
    153                  result = TRUE;
   \   00000010   0x2001             MOVEQ    R0,#+1
    154              }
    155          
    156              return(result);
   \   00000012   0x4770             BX       LR               ;; return
    157          #else
    158              return(TRUE);
    159          #endif
    160          }
    161          //---------------------------------------------------------------------------------------------------------------------
    162          /**
    163           *  @brief      Manual operation of surge relay.
    164           *
    165           *  @param      [in] action SURGERELAY_OPEN = force open state
    166           *                          SURGERELAY_CLOSE = force closed state
    167           *                          SURGERELAY_NORMAL = returns to the state machine to control the output
    168           */

   \                                 In section .text, align 2, keep-with-next
    169          void SurgeRelay__Action(SURGERELAY_ACTION_TYPE action)
    170          {
    171          #ifdef SURGE_RELAY_USED
    172              if(action == SURGERELAY_OPEN)
   \                     SurgeRelay__Action: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD107             BNE.N    ??SurgeRelay__Action_0
    173              {
    174                  // Force state change immediately
    175                  Surge_State = SURGE_MANUAL_MODE;
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable146
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0xF881 0x036C      STRB     R0,[R1, #+876]
    176                  RELAY_OPEN();
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x2118             MOVS     R1,#+24
   \   00000012   0xE017             B.N      ??SurgeRelay__Action_1
    177              }
    178              else if(action == SURGERELAY_CLOSE)
   \                     ??SurgeRelay__Action_0: (+1)
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD107             BNE.N    ??SurgeRelay__Action_2
    179              {
    180                  // Force state change immediately
    181                  Surge_State = SURGE_MANUAL_MODE;
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable146
   \   0000001C   0x2004             MOVS     R0,#+4
   \   0000001E   0xF881 0x036C      STRB     R0,[R1, #+876]
    182                  RELAY_CLOSE();
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x2118             MOVS     R1,#+24
   \   00000026   0xE00D             B.N      ??SurgeRelay__Action_1
    183              }
    184              else if(action == SURGERELAY_NORMAL)
   \                     ??SurgeRelay__Action_2: (+1)
   \   00000028   0x2803             CMP      R0,#+3
   \   0000002A   0xBF02             ITTT     EQ 
    185              {
    186                  if(Surge_State == SURGE_MANUAL_MODE)
   \   0000002C   0x.... 0x....      LDREQ.W  R0,??DataTable146
   \   00000030   0xF890 0x136C      LDRBEQ   R1,[R0, #+876]
   \   00000034   0x2904             CMPEQ    R1,#+4
   \   00000036   0xD107             BNE.N    ??SurgeRelay__Action_3
    187                  {
    188                      // Force state change immediately
    189                      Surge_State = SURGE_WAITING;
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0xF880 0x136C      STRB     R1,[R0, #+876]
    190                      RELAY_OPEN();
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x2118             MOVS     R1,#+24
   \   00000042   0x2004             MOVS     R0,#+4
   \                     ??SurgeRelay__Action_1: (+1)
   \   00000044   0x.... 0x....      B.W      Gpio__PinWrite
    191                  }
    192              }
    193          #endif
    194          }
   \                     ??SurgeRelay__Action_3: (+1)
   \   00000048   0x4770             BX       LR               ;; return
    195          
    196          //=====================================================================================================================
    197          //-------------------------------------- Private Functions ------------------------------------------------------------
    198          //=====================================================================================================================
    199          
    200          
    201          //---------------------------------------------------------------------------------------------------------------------
    202          /**
    203           *  @brief      Calculate the dVbus/dt and apply an hysteresis.
    204           *
    205           *  @param      None
    206           *  @return     TRUE - DC Bus voltage is stable
    207           *              FALSE - DC Bus voltage is not stable
    208           */
    209          #ifdef SURGE_RELAY_USED
    210          unsigned char IsdVbusdtStable(void)
    211          {
    212              unsigned short int result;
    213              unsigned short int vbus;
    214          
    215              vbus = SURGERELAY_READ_DCBUS_VOLTAGE();
    216          
    217              if(vbus >= Bus_Voltage_Previous)
    218              {
    219                  result = vbus - Bus_Voltage_Previous;
    220              }
    221              else
    222              {
    223                  result = Bus_Voltage_Previous - vbus;
    224              }
    225          
    226              Bus_Voltage_Previous = vbus;
    227          
    228              if(result <= VBUS_DV_DT)
    229              {
    230                  result = TRUE;
    231              }
    232              else
    233              {
    234                  result = FALSE;
    235              }
    236          
    237              return(result);
    238          }
    239          #endif
    240          
    241          
C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Driver\SRMCAtod\SRMCAtod.c
      1          /**
      2           *  @defgroup   CLASS_B
      3           *  @file       SRMCAtod.c
      4           *  @brief      This module treats analog conversions for motor control
      5           *
      6           *  @details    Analog conversions are triggered by PDB timer event in order minimize ringing noise.
      7           *              Trigger for all 3 currents and DC bus voltage occur at the same time
      8           *
      9           *---------------------------------------------------------------------------------------------------------------------
     10           *------------------- Copyright 2012.  Whirlpool Corporation.  All rights reserved - CONFIDENTIAL ---------------------
     11           *---------------------------------------------------------------------------------------------------------------------
     12           */
     13          
     14          //-------------------------------------- Include Files ----------------------------------------------------------------
     15          #include "SRMCAtod.h"
     16          #include "SRMicro.h"
     17          #include "SRData.h"
     18          #include "SRException.h"
     19          
     20          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     21          
     22          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     23          #if (SRMCATOD_ENABLE_ADDITIONAL_READING == 1)
     24          typedef struct
     25          {
     26              SRMCATOD_CONVERTER_TYPE Engine;
     27              SRMCATOD_CHANNEL_DEF Channel;
     28              BOOL_TYPE Use_Mux;
     29              ADC_BASIC_DEF* Base_Reg;
     30          } SRMCATOD_MANUAL_CONFIG_TYPE;
     31          #endif
     32          //-------------------------------------- Safety Relevant Variables ----------------------------------------------------
     33          static SRMCATOD_DIAG_STATE_TYPE SR_State;
     34          static SRMCATOD_DIAG_ERROR_TYPE SR_Fault_Holder;
     35          static sint16 SR_Threshold;
     36          #if((SRMCATOD_EOC_ISR_HANDLER_PRESCALER == 1)||(SRMCATOD_EOC_ISR_HANDLER_PRESCALER == 2))
     37          static uint16  SR_Eos_Isr_Counter;
     38          #endif
     39          
     40          static SRMCATOD_DIAG_STATE_TYPE NSR_State;
     41          static SRMCATOD_DIAG_ERROR_TYPE NSR_Fault_Holder;
     42          static sint16 NSR_Threshold;
     43          #if((SRMCATOD_EOC_ISR_HANDLER_PRESCALER == 1)||(SRMCATOD_EOC_ISR_HANDLER_PRESCALER == 2))
     44          static uint16 NSR_Eos_Isr_Counter;
     45          #endif
     46          
     47          #if (SRMCATOD_ENABLE_ADDITIONAL_READING == 1)
     48          static sint16 Last_Manual_Sample;
     49          static SRMCATOD_MANUAL_CONFIG_TYPE Manual_Cfg_Hdlr;
     50          #endif
     51          
     52          //! FTM clock counts distance between Counter and Modulo used to check for stuck manual conversion condition [FTM counts]
     53          #define CONVERSION_TIME_THR     10
     54          
     55          //---------------------------------------- Macros -----------------------------------------------------
     56          #ifndef SRMCATOD_MANUAL_CONVERSION_EXCEPTION
     57              #define SRMCATOD_MANUAL_CONVERSION_EXCEPTION()      SRException__Queue(EXCEPTION_ATOD_STUCK, 0 , 0)
     58          #endif
     59          
     60          #if(1)
     61          // CHECK Macro defs
     62          //lint -emacro( 928, SR_MCATOD_CHECK_STATE )
     63          #define SR_MCATOD_CHECK_STATE()                         SRData__CheckByte((uint8 *)&SR_State, (uint8 *)&NSR_State)
     64          //lint -emacro( 928, SR_MCATOD_CHECK_FAULT_HOLDER )
     65          #define SR_MCATOD_CHECK_FAULT_HOLDER()                  SRData__CheckByte((uint8 *)&SR_Fault_Holder, (uint8 *)&NSR_Fault_Holder)
     66          //lint -emacro( 929, SR_MCATOD_CHECK_THRESHOLD )
     67          #define SR_MCATOD_CHECK_THRESHOLD()                     SRData__CheckShort((uint16 *)&SR_Threshold, (uint16 *)&NSR_Threshold)
     68          //lint -emacro( 928, SR_MCATOD_CHECK_EOS_ISR_CNT )
     69          #define SR_MCATOD_CHECK_EOS_ISR_CNT()                   SRData__CheckShort((uint16 *)&SR_Eos_Isr_Counter, (uint16 *)&NSR_Eos_Isr_Counter)
     70          
     71          
     72          // UPDATE Macro defs
     73          //lint -emacro( 928, SR_MCATOD_UPDATE_STATE )
     74          #define SR_MCATOD_UPDATE_STATE(value)                   SRData__UpdateByte((uint8 *)&SR_State, (uint8 *)&NSR_State, (uint8)(value))
     75          //lint -emacro( 928, SR_MCATOD_UPDATE_FAULT_HOLDER )
     76          #define SR_MCATOD_UPDATE_FAULT_HOLDER(value)            SRData__UpdateByte((uint8 *)&SR_Fault_Holder, (uint8 *)&NSR_Fault_Holder, (uint8)(value))
     77          //lint -emacro( 929, SR_MCATOD_UPDATE_THRESHOLD )
     78          #define SR_MCATOD_UPDATE_THRESHOLD(value)               SRData__UpdateShort((uint16 *)&SR_Threshold, (uint16 *)&NSR_Threshold, (uint16)(value))
     79          //lint -emacro( 928, SR_MCATOD_UPDATE_EOS_ISR_CNT )
     80          #define SR_MCATOD_UPDATE_EOS_ISR_CNT(value)             SRData__UpdateShort((uint16 *)&SR_Eos_Isr_Counter, (uint16 *)&NSR_Eos_Isr_Counter, (uint16)(value))
     81          
     82          
     83          #else
     84          // CHECK Macro defs
     85          #define SR_MCATOD_CHECK_STATE()                         SRDATA_OK
     86          #define SR_MCATOD_CHECK_FAULT_HOLDER()                  SRDATA_OK
     87          #define SR_MCATOD_CHECK_THRESHOLD()                     SRDATA_OK
     88          
     89          // UPDATE Macro defs
     90          #define SR_MCATOD_UPDATE_STATE(value)                   SR_State = (value)
     91          #define SR_MCATOD_UPDATE_FAULT_HOLDER(value)            SR_Fault_Holder = (value)
     92          #define SR_MCATOD_UPDATE_THRESHOLD(value)               SR_Threshold = (value)
     93          
     94          #endif
     95          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
     96          static void SRInitializeAD0(void);
     97          static void SRInitializeAD1(void);
     98          static void SRCalibrateAD0(void);
     99          static void SRCalibrateAD1(void);
    100          static void SRInitializePDB0(void);
    101          static void DisableEndOfConversionInteruption(SRMCATOD_CONVERTER_TYPE engine);
    102          static void EnableEndOfConversionInteruption(SRMCATOD_CONVERTER_TYPE engine);
    103          static void SREnableSelfDiagMode(SRMCATOD_CONVERTER_TYPE engine, SRMCATOD_DIAG_CONFIG_TYPE mode);
    104          static SRMCATOD_DIAG_ERROR_TYPE IsConverterSafe(SRMCATOD_CONVERTER_TYPE engine,sint16 thresold, SRMCATOD_DIAG_CONFIG_TYPE mode);
    105          
    106          //=====================================================================================================================
    107          //-------------------------------------- Public Functions -------------------------------------------------------------
    108          //=====================================================================================================================
    109          
    110          //---------------------------------------------------------------------------------------------------------------------
    111          /**
    112           *  @brief      It Initializes the module MCAtod peripheral and its variables
    113           *
    114           *  @details    ADC0, ADC1 and PDB0 peripherals are initialized.
    115           *
    116           *  @remarks    Only the IRQ of ADC1 channel 1 is enabled.
    117           *
    118           */

   \                                 In section .text, align 2, keep-with-next
    119          void SRMCAtod__Initialize(void)
    120          {
   \                     SRMCAtod__Initialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    121          	DISABLE_INTERRUPTS();                           // Disables interruptions while configuring
   \   00000002   0xB672             CPSID    I
    122          
    123          	SRInitializeAD0();                           	// Configures AD0 with PDB0 trigger for 2 channels
   \   00000004   0x.... 0x....      BL       ??SRInitializeAD0
    124          	SRInitializeAD1();								// Configures AD1 with PDB0 trigger for 2 channels
   \   00000008   0x.... 0x....      BL       ??SRInitializeAD1
    125          	SRInitializePDB0();								// Configures PDB0 triggered by FTM0
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable164_2  ;; 0x40048018
   \   00000010   0x6A60             LDR      R0,[R4, #+36]
   \   00000012   0xF440 0x0080      ORR      R0,R0,#0x400000
   \   00000016   0x6260             STR      R0,[R4, #+36]
   \   00000018   0x2034             MOVS     R0,#+52
   \   0000001A   0x.... 0x....      BL       Micro__NVICDisableIRQ
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable164_3  ;; 0x40036000
   \   00000022   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000026   0x6041             STR      R1,[R0, #+4]
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x2114             MOVS     R1,#+20
   \   0000002C   0x6181             STR      R1,[R0, #+24]
   \   0000002E   0x6401             STR      R1,[R0, #+64]
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable164_4  ;; 0x20303
   \   00000034   0x6101             STR      R1,[R0, #+16]
   \   00000036   0x6381             STR      R1,[R0, #+56]
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable164_5  ;; 0xa0880
   \   0000003C   0x6001             STR      R1,[R0, #+0]
   \   0000003E   0x6801             LDR      R1,[R0, #+0]
   \   00000040   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000044   0x6001             STR      R1,[R0, #+0]
   \   00000046   0x2034             MOVS     R0,#+52
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x.... 0x....      BL       Micro__NVICEnableIRQ
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x6020             STR      R0,[R4, #+0]
   \   00000052   0x2200             MOVS     R2,#+0
    126          
    127              // Enable the 1V reference for plausibility checks
    128              PMC.REGSC.BIT.BGEN = 1;
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable164_6  ;; 0x4007d002
   \   00000058   0x.... 0x....      LDR.W    R4,??DataTable146
   \   0000005C   0x7801             LDRB     R1,[R0, #+0]
   \   0000005E   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000062   0x7001             STRB     R1,[R0, #+0]
    129              PMC.REGSC.BIT.BGBE = 1;
   \   00000064   0x7801             LDRB     R1,[R0, #+0]
   \   00000066   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000006A   0x7001             STRB     R1,[R0, #+0]
    130              // Initialize the Safety Relevant variables
    131              SR_MCATOD_UPDATE_STATE(SR_MCATOD_WAITING_TO_CHECK);
   \   0000006C   0xF204 0x306E      ADDW     R0,R4,#+878
   \   00000070   0xF504 0x61B1      ADD      R1,R4,#+1416
   \   00000074   0x.... 0x....      BL       SRData__UpdateByte
    132              SR_MCATOD_UPDATE_THRESHOLD(0);
   \   00000078   0x2200             MOVS     R2,#+0
   \   0000007A   0xF204 0x518E      ADDW     R1,R4,#+1422
   \   0000007E   0xF204 0x309A      ADDW     R0,R4,#+922
   \   00000082   0x.... 0x....      BL       SRData__UpdateShort
    133              SR_MCATOD_UPDATE_FAULT_HOLDER(SR_MCATOD_ERROR_TEST_NOT_PERFORMED);
   \   00000086   0x2200             MOVS     R2,#+0
   \   00000088   0xF204 0x5189      ADDW     R1,R4,#+1417
   \   0000008C   0xF204 0x306F      ADDW     R0,R4,#+879
   \   00000090   0x.... 0x....      BL       SRData__UpdateByte
    134          
    135          #if((SRMCATOD_EOC_ISR_HANDLER_PRESCALER == 1)||(SRMCATOD_EOC_ISR_HANDLER_PRESCALER == 2))
    136              SR_MCATOD_UPDATE_EOS_ISR_CNT(0);
    137          #endif
    138          #if (SRMCATOD_ENABLE_ADDITIONAL_READING == 1)
    139              Manual_Cfg_Hdlr.Engine = (SRMCATOD_CONVERTER_TYPE) SRMCATOD_ADDITIONAL_READING_ADC_ENGINE;
    140              Manual_Cfg_Hdlr.Channel = (SRMCATOD_CHANNEL_DEF) SRMCATOD_ADDITIONAL_READING_CHANNEL;
    141              Manual_Cfg_Hdlr.Use_Mux = (BOOL_TYPE) SRMCATOD_ADDITIONAL_READING_MUX_SELECT;
    142          
    143              if (Manual_Cfg_Hdlr.Engine == SR_AD_ENGINE_1)
    144              {
    145                  Manual_Cfg_Hdlr.Base_Reg = &ADC1;
    146              }
    147              else
    148              {
    149                  // default choice if no valid engine is provided
    150                  Manual_Cfg_Hdlr.Base_Reg = &ADC0;
    151              }
    152          
    153              Last_Manual_Sample = SRMCATOD_ADDITIONAL_READING_INITIAL_VALUE;
    154          #endif
    155              ENABLE_INTERRUPTS();                            // Enables back interruptions
   \   00000094   0xB662             CPSIE    I
    156          }
   \   00000096   0xBD10             POP      {R4,PC}          ;; return
    157          
    158          //---------------------------------------------------------------------------------------------------------------------
    159          /**
    160           *  @brief      End of engine 0 conversion.
    161           *
    162           *  @details    This is supposed to be simultaneous to the end of engine 1, since they are triggered together.
    163           *
    164           */

   \                                 In section .text, align 2, keep-with-next
    165          INTERRUPT_DIRECTIVE void SRMCAtod__ISR(void)
    166          {
    167              #if((SRMCATOD_EOC_ISR_HANDLER_PRESCALER == 1)||(SRMCATOD_EOC_ISR_HANDLER_PRESCALER == 2))
    168          	uint16 temp;
    169          	SR_MCATOD_CHECK_EOS_ISR_CNT();
    170          	temp = SR_Eos_Isr_Counter;
    171              temp++;
    172              SR_MCATOD_UPDATE_EOS_ISR_CNT(temp);
    173              #endif
    174          
    175          	if((ADC0.ADC_SC1[0] & ADC_SC1_COCO_MASK) == ADC_SC1_COCO_MASK)
   \                     SRMCAtod__ISR: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable165  ;; 0x4003b000
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x0609             LSLS     R1,R1,#+24
   \   00000008   0xD503             BPL.N    ??SRMCAtod__ISR_0
    176          	{
    177          		ADC0.ADC_SC1[0] &= ~ADC_SC1_COCO_MASK;
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0xF021 0x0180      BIC      R1,R1,#0x80
   \   00000010   0x6001             STR      R1,[R0, #+0]
    178          	}
    179          	if((ADC0.ADC_SC1[1] & ADC_SC1_COCO_MASK) == ADC_SC1_COCO_MASK)
   \                     ??SRMCAtod__ISR_0: (+1)
   \   00000012   0x6841             LDR      R1,[R0, #+4]
   \   00000014   0x0609             LSLS     R1,R1,#+24
   \   00000016   0xD503             BPL.N    ??SRMCAtod__ISR_1
    180          	{
    181          		ADC0.ADC_SC1[1] &= ~ADC_SC1_COCO_MASK;
   \   00000018   0x6841             LDR      R1,[R0, #+4]
   \   0000001A   0xF021 0x0180      BIC      R1,R1,#0x80
   \   0000001E   0x6041             STR      R1,[R0, #+4]
    182          	}
    183          	if((ADC1.ADC_SC1[0] & ADC_SC1_COCO_MASK) == ADC_SC1_COCO_MASK)
   \                     ??SRMCAtod__ISR_1: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable166  ;; 0x40027000
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x0609             LSLS     R1,R1,#+24
   \   00000028   0xD503             BPL.N    ??SRMCAtod__ISR_2
    184          	{
    185          		ADC1.ADC_SC1[0] &= ~ADC_SC1_COCO_MASK;
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   \   0000002C   0xF021 0x0180      BIC      R1,R1,#0x80
   \   00000030   0x6001             STR      R1,[R0, #+0]
    186          	}
    187          	if((ADC1.ADC_SC1[1] & ADC_SC1_COCO_MASK) == ADC_SC1_COCO_MASK)
   \                     ??SRMCAtod__ISR_2: (+1)
   \   00000032   0x6841             LDR      R1,[R0, #+4]
   \   00000034   0x0609             LSLS     R1,R1,#+24
   \   00000036   0xD505             BPL.N    ??SRMCAtod__ISR_3
    188          	{
    189          		ADC1.ADC_SC1[1] &= ~ADC_SC1_COCO_MASK;
   \   00000038   0x6841             LDR      R1,[R0, #+4]
   \   0000003A   0xF021 0x0180      BIC      R1,R1,#0x80
   \   0000003E   0x6041             STR      R1,[R0, #+4]
    190          		
    191                  #if(SRMCATOD_EOC_ISR_HANDLER_PRESCALER == 1)
    192          		if (temp & 1)//
    193                  #elif(SRMCATOD_EOC_ISR_HANDLER_PRESCALER == 2)
    194          		if (temp - ((temp >> 2) << 2) == 0) // (Counter % 4) == 0
    195                  #endif
    196          		{
    197          			SRMCATOD_EOC_ISR_HANDLER();
   \   00000040   0x.... 0x....      B.W      SRMotorSafetyMgr__MCPwmHandler
    198          	 	}
    199          	}
    200          }
   \                     ??SRMCAtod__ISR_3: (+1)
   \   00000044   0x4770             BX       LR               ;; return
    201          
    202          //---------------------------------------------------------------------------------------------------------------------
    203          /**
    204           *  @brief      PDB interrupt service routine
    205           *
    206           */

   \                                 In section .text, align 2, keep-with-next
    207          INTERRUPT_DIRECTIVE void SRMCPDB__ISR(void)
    208          {
    209              PDB.SC &= ~PDB_SC_PDBIF_MASK ;  				// clear interrupt mask
   \                     SRMCPDB__ISR: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable164_3  ;; 0x40036000
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    210          
    211              PDB.SC |= PDB_SC_LDOK_MASK;                 	// LDOK needed for update of delay values
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000012   0x6001             STR      R1,[R0, #+0]
    212          
    213          	if ((PDB.CH[0].S & PDB_S_ERR_MASK) ||
    214          		(PDB.CH[1].S & PDB_S_ERR_MASK))
   \   00000014   0x6941             LDR      R1,[R0, #+20]
   \   00000016   0x0609             LSLS     R1,R1,#+24
   \   00000018   0xD102             BNE.N    ??SRMCPDB__ISR_0
   \   0000001A   0x6BC1             LDR      R1,[R0, #+60]
   \   0000001C   0x0609             LSLS     R1,R1,#+24
   \   0000001E   0xD017             BEQ.N    ??SRMCPDB__ISR_1
    215          	{
    216          		PDB.SC &= ~PDB_SC_PDBEN_MASK;  				// disable PDB
   \                     ??SRMCPDB__ISR_0: (+1)
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0xF021 0x0180      BIC      R1,R1,#0x80
   \   00000026   0x6001             STR      R1,[R0, #+0]
    217          		PDB.CH[0].S &= ~PDB_S_CF_MASK;
   \   00000028   0x6941             LDR      R1,[R0, #+20]
   \   0000002A   0xF421 0x017F      BIC      R1,R1,#0xFF0000
   \   0000002E   0x6141             STR      R1,[R0, #+20]
    218          		PDB.CH[0].S &= ~PDB_S_ERR_MASK;   			// reset error CH0
   \   00000030   0x6941             LDR      R1,[R0, #+20]
   \   00000032   0x0A09             LSRS     R1,R1,#+8
   \   00000034   0x0209             LSLS     R1,R1,#+8
   \   00000036   0x6141             STR      R1,[R0, #+20]
    219          		PDB.CH[1].S &= ~PDB_S_CF_MASK;
   \   00000038   0x6BC1             LDR      R1,[R0, #+60]
   \   0000003A   0xF421 0x017F      BIC      R1,R1,#0xFF0000
   \   0000003E   0x63C1             STR      R1,[R0, #+60]
    220          		PDB.CH[1].S &= ~PDB_S_ERR_MASK;  			// reset error CH1
   \   00000040   0x6BC1             LDR      R1,[R0, #+60]
   \   00000042   0x0A09             LSRS     R1,R1,#+8
   \   00000044   0x0209             LSLS     R1,R1,#+8
   \   00000046   0x63C1             STR      R1,[R0, #+60]
    221          		PDB.SC |= PDB_SC_PDBEN_MASK;  				// Enable PDB
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF041 0x0180      ORR      R1,R1,#0x80
   \   0000004E   0x6001             STR      R1,[R0, #+0]
    222          	}
    223          }
   \                     ??SRMCPDB__ISR_1: (+1)
   \   00000050   0x4770             BX       LR               ;; return
    224          
    225          //---------------------------------------------------------------------------------------------------------------------
    226          /**
    227           *  @brief      ADC Diagnostic handler
    228           *
    229           *  @details    This function is a handler used to check 12 bits AD registers and converters status.
    230           *              May be used to test stuck at register failure and conversion errors. Checks all converters with all possible fixed values.
    231           *              This handler has no time dependency, may be used on handlers at 16KHz, 250us, 1ms 5ms or 25ms.
    232           *              Use functions to start tests and get feedbacks.
    233           *
    234           */

   \                                 In section .text, align 4, keep-with-next
    235          void SRMCAtod__DiagnosticHandler(void)
    236          {
   \                     SRMCAtod__DiagnosticHandler: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    237              uint8 temp;
    238              
    239              SR_MCATOD_CHECK_STATE();
   \   00000002   0x....             LDR.N    R4,??DataTable146
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0xF504 0x61B1      ADD      R1,R4,#+1416
   \   0000000A   0xF204 0x306E      ADDW     R0,R4,#+878
   \   0000000E   0x.... 0x....      BL       SRData__CheckByte
    240              SR_MCATOD_CHECK_FAULT_HOLDER();
   \   00000012   0xF204 0x5189      ADDW     R1,R4,#+1417
   \   00000016   0xF204 0x306F      ADDW     R0,R4,#+879
   \   0000001A   0x.... 0x....      BL       SRData__CheckByte
    241              SR_MCATOD_CHECK_THRESHOLD();
   \   0000001E   0xF204 0x518E      ADDW     R1,R4,#+1422
   \   00000022   0xF204 0x309A      ADDW     R0,R4,#+922
   \   00000026   0x.... 0x....      BL       SRData__CheckShort
    242          
    243          	switch (SR_State)							    // State machine triggered externally
   \   0000002A   0xF894 0x036E      LDRB     R0,[R4, #+878]
   \   0000002E   0x2805             CMP      R0,#+5
   \   00000030   0xF200 0x80E2      BHI.W    ??SRMCAtod__DiagnosticHandler_1
   \   00000034   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??SRMCAtod__DiagnosticHandler_0:
   \   00000038   0xF6 0x03          DC8      0xF6,0x3,0x16,0x56
   \              0x16 0x56    
   \   0000003C   0x9A 0xF6          DC8      0x9A,0xF6
    244          	{
    245          		case SR_MCATOD_WAITING_TO_CHECK:					// Waits until a verification is requested
    246          
    247          			break;
    248          
    249          		case SR_MCATOD_START_EVAL:							// Configures peripheral converters to test in respect to internal voltage reference
    250          
    251                      SREnableSelfDiagMode(SR_AD_ENGINE_0,SR_MCATOD_SELF_TEST_VREFH0_SCALE_0);
   \                     ??SRMCAtod__DiagnosticHandler_2: (+1)
   \   0000003E   0x.... 0x....      LDR.W    R6,??DataTable165  ;; 0x4003b000
   \   00000042   0x.... 0x....      LDR.W    R5,??DataTable166  ;; 0x40027000
   \   00000046   0x201E             MOVS     R0,#+30
   \   00000048   0x6030             STR      R0,[R6, #+0]
   \   0000004A   0x6070             STR      R0,[R6, #+4]
    252                      SREnableSelfDiagMode(SR_AD_ENGINE_1,SR_MCATOD_SELF_TEST_VREFH0_SCALE_0);
   \   0000004C   0x6028             STR      R0,[R5, #+0]
   \   0000004E   0x2200             MOVS     R2,#+0
   \   00000050   0x205E             MOVS     R0,#+94
   \   00000052   0x6068             STR      R0,[R5, #+4]
    253          
    254                      SR_MCATOD_UPDATE_FAULT_HOLDER(SR_MCATOD_ERROR_TEST_NOT_PERFORMED);
   \   00000054   0xF204 0x5189      ADDW     R1,R4,#+1417
   \   00000058   0xF204 0x306F      ADDW     R0,R4,#+879
   \   0000005C   0x.... 0x....      BL       SRData__UpdateByte
    255                                                              // Initializes feedback to update test is not finished
    256                      SR_MCATOD_UPDATE_STATE(SR_MCATOD_CHECK_STUCK_AT_1);
   \   00000060   0x2202             MOVS     R2,#+2
   \   00000062   0xE0D6             B.N      ??SRMCAtod__DiagnosticHandler_3
    257                                                          // Gets to next state to get feedbacks from this test
    258          			break;
    259          
    260          		case SR_MCATOD_CHECK_STUCK_AT_1:					// Checks if all bits are null above certain threshold
    261          
    262          			SREnableSelfDiagMode(SR_AD_ENGINE_0,SR_MCATOD_SELF_TEST_DISABLED);
   \                     ??SRMCAtod__DiagnosticHandler_4: (+1)
   \   00000064   0x.... 0x....      LDR.W    R6,??DataTable165  ;; 0x4003b000
   \   00000068   0x.... 0x....      LDR.W    R5,??DataTable166  ;; 0x40027000
   \   0000006C   0x200C             MOVS     R0,#+12
   \   0000006E   0x6030             STR      R0,[R6, #+0]
   \   00000070   0x2203             MOVS     R2,#+3
   \   00000072   0x2004             MOVS     R0,#+4
   \   00000074   0x6070             STR      R0,[R6, #+4]
    263          			SREnableSelfDiagMode(SR_AD_ENGINE_1,SR_MCATOD_SELF_TEST_DISABLED);
   \   00000076   0x2008             MOVS     R0,#+8
   \   00000078   0x6028             STR      R0,[R5, #+0]
   \   0000007A   0x2049             MOVS     R0,#+73
   \   0000007C   0x6068             STR      R0,[R5, #+4]
    264          													// Disables self diagnostic
    265          			temp = (uint8) IsConverterSafe(SR_AD_ENGINE_0,SR_Threshold, SR_MCATOD_SELF_TEST_VREFH0_SCALE_0);
   \   0000007E   0x6930             LDR      R0,[R6, #+16]
   \   00000080   0x6971             LDR      R1,[R6, #+20]
   \   00000082   0xF9B4 0x339A      LDRSH    R3,[R4, #+922]
   \   00000086   0x4308             ORRS     R0,R1,R0
   \   00000088   0xB200             SXTH     R0,R0
   \   0000008A   0x4283             CMP      R3,R0
   \   0000008C   0xBFA8             IT       GE 
   \   0000008E   0x2206             MOVGE    R2,#+6
    266          			SR_MCATOD_UPDATE_FAULT_HOLDER(temp);    // Gets converter status
   \   00000090   0xF204 0x5189      ADDW     R1,R4,#+1417
   \   00000094   0xF204 0x306F      ADDW     R0,R4,#+879
   \   00000098   0x.... 0x....      BL       SRData__UpdateByte
    267          
    268          			if (SR_Fault_Holder == SR_MCATOD_ERROR_PERIPHERAL_SAFE)	// If previous converter feedback is SAFE, checks next converter
   \   0000009C   0xF894 0x036F      LDRB     R0,[R4, #+879]
   \   000000A0   0x2806             CMP      R0,#+6
   \   000000A2   0xD11D             BNE.N    ??SRMCAtod__DiagnosticHandler_5
    269          			{
    270          			    temp = (uint8) IsConverterSafe(SR_AD_ENGINE_1,SR_Threshold, SR_MCATOD_SELF_TEST_VREFH0_SCALE_0);
   \   000000A4   0x6928             LDR      R0,[R5, #+16]
   \   000000A6   0x6969             LDR      R1,[R5, #+20]
   \   000000A8   0xF9B4 0x339A      LDRSH    R3,[R4, #+922]
   \   000000AC   0x4308             ORRS     R0,R1,R0
   \   000000AE   0x2203             MOVS     R2,#+3
   \   000000B0   0xB200             SXTH     R0,R0
   \   000000B2   0x4283             CMP      R3,R0
   \   000000B4   0xBFA8             IT       GE 
   \   000000B6   0x2206             MOVGE    R2,#+6
    271          			    SR_MCATOD_UPDATE_FAULT_HOLDER(temp);    // Gets converter status
   \   000000B8   0xF204 0x5189      ADDW     R1,R4,#+1417
   \   000000BC   0xF204 0x306F      ADDW     R0,R4,#+879
   \   000000C0   0x.... 0x....      BL       SRData__UpdateByte
    272          
    273          			    if(SR_Fault_Holder == SR_MCATOD_ERROR_PERIPHERAL_SAFE)
   \   000000C4   0xF894 0x036F      LDRB     R0,[R4, #+879]
   \   000000C8   0x2806             CMP      R0,#+6
   \   000000CA   0xD107             BNE.N    ??SRMCAtod__DiagnosticHandler_6
    274          				{									// If this feedback is also safe, checks in respect to next internal voltage level
    275                              SREnableSelfDiagMode(SR_AD_ENGINE_0,SR_MCATOD_SELF_TEST_VREFH0_SCALE_1);
   \   000000CC   0x201D             MOVS     R0,#+29
   \   000000CE   0x6030             STR      R0,[R6, #+0]
   \   000000D0   0x6070             STR      R0,[R6, #+4]
    276                              SREnableSelfDiagMode(SR_AD_ENGINE_1,SR_MCATOD_SELF_TEST_VREFH0_SCALE_1);
   \   000000D2   0x6028             STR      R0,[R5, #+0]
   \   000000D4   0x2203             MOVS     R2,#+3
   \   000000D6   0x205D             MOVS     R0,#+93
   \   000000D8   0x6068             STR      R0,[R5, #+4]
    277                                                              // Configures peripheral converters to test in respect to internal voltage reference
    278                              SR_MCATOD_UPDATE_STATE(SR_MCATOD_CHECK_STUCK_AT_0);
   \   000000DA   0xE09A             B.N      ??SRMCAtod__DiagnosticHandler_3
    279                                                              // Gets to next test state since this was successfully tested
    280          				}
    281          				else								// Any type of error moves directly to feedback update to publish status
    282          				{
    283                              SR_MCATOD_UPDATE_STATE(SR_MCATOD_FEEDBACK_UPDATED);
   \                     ??SRMCAtod__DiagnosticHandler_6: (+1)
   \   000000DC   0x2205             MOVS     R2,#+5
   \   000000DE   0xE098             B.N      ??SRMCAtod__DiagnosticHandler_3
    284          				}
    285          			}
    286          			else									// Any type of error moves directly to feedback update to publish status
    287          			{
    288                          SR_MCATOD_UPDATE_STATE(SR_MCATOD_FEEDBACK_UPDATED);
   \                     ??SRMCAtod__DiagnosticHandler_5: (+1)
   \   000000E0   0x2205             MOVS     R2,#+5
   \   000000E2   0xE096             B.N      ??SRMCAtod__DiagnosticHandler_3
    289          			}
    290          			break;
    291          
    292          		case SR_MCATOD_CHECK_STUCK_AT_0:					// Checks if all bits are set under certain threshold
    293          
    294          			SREnableSelfDiagMode(SR_AD_ENGINE_0,SR_MCATOD_SELF_TEST_DISABLED);
   \                     ??SRMCAtod__DiagnosticHandler_7: (+1)
   \   000000E4   0x200C             MOVS     R0,#+12
   \   000000E6   0x.... 0x....      LDR.W    R6,??DataTable165  ;; 0x4003b000
   \   000000EA   0x.... 0x....      LDR.W    R5,??DataTable166  ;; 0x40027000
   \   000000EE   0x6030             STR      R0,[R6, #+0]
   \   000000F0   0xF640 0x77FF      MOVW     R7,#+4095
   \   000000F4   0x2004             MOVS     R0,#+4
   \   000000F6   0x6070             STR      R0,[R6, #+4]
   \   000000F8   0x2202             MOVS     R2,#+2
    295          			SREnableSelfDiagMode(SR_AD_ENGINE_1,SR_MCATOD_SELF_TEST_DISABLED);
   \   000000FA   0x2008             MOVS     R0,#+8
   \   000000FC   0x6028             STR      R0,[R5, #+0]
   \   000000FE   0x2049             MOVS     R0,#+73
   \   00000100   0x6068             STR      R0,[R5, #+4]
    296          													// Disables self diagnostic
    297          			temp = (uint8) IsConverterSafe(SR_AD_ENGINE_0,SR_Threshold, SR_MCATOD_SELF_TEST_VREFH0_SCALE_1);
   \   00000102   0x6930             LDR      R0,[R6, #+16]
   \   00000104   0x6971             LDR      R1,[R6, #+20]
   \   00000106   0x4008             ANDS     R0,R1,R0
   \   00000108   0xF9B4 0x139A      LDRSH    R1,[R4, #+922]
   \   0000010C   0xB200             SXTH     R0,R0
   \   0000010E   0x1A79             SUBS     R1,R7,R1
   \   00000110   0x4288             CMP      R0,R1
   \   00000112   0xBFA8             IT       GE 
   \   00000114   0x2206             MOVGE    R2,#+6
    298          			SR_MCATOD_UPDATE_FAULT_HOLDER(temp);    // Gets converter status
   \   00000116   0xF204 0x5189      ADDW     R1,R4,#+1417
   \   0000011A   0xF204 0x306F      ADDW     R0,R4,#+879
   \   0000011E   0x.... 0x....      BL       SRData__UpdateByte
    299          
    300          			if (SR_Fault_Holder == SR_MCATOD_ERROR_PERIPHERAL_SAFE)	// If previous converter feedback is SAFE, checks next converter
   \   00000122   0xF894 0x036F      LDRB     R0,[R4, #+879]
   \   00000126   0x2806             CMP      R0,#+6
   \   00000128   0xD11E             BNE.N    ??SRMCAtod__DiagnosticHandler_8
    301          			{
    302          			    temp = (uint8) IsConverterSafe(SR_AD_ENGINE_1,SR_Threshold, SR_MCATOD_SELF_TEST_VREFH0_SCALE_1);
   \   0000012A   0x6928             LDR      R0,[R5, #+16]
   \   0000012C   0x6969             LDR      R1,[R5, #+20]
   \   0000012E   0x4008             ANDS     R0,R1,R0
   \   00000130   0xF9B4 0x139A      LDRSH    R1,[R4, #+922]
   \   00000134   0x2202             MOVS     R2,#+2
   \   00000136   0xB200             SXTH     R0,R0
   \   00000138   0x1A79             SUBS     R1,R7,R1
   \   0000013A   0x4288             CMP      R0,R1
   \   0000013C   0xBFA8             IT       GE 
   \   0000013E   0x2206             MOVGE    R2,#+6
    303          			    SR_MCATOD_UPDATE_FAULT_HOLDER(temp);    // Gets converter status
   \   00000140   0xF204 0x5189      ADDW     R1,R4,#+1417
   \   00000144   0xF204 0x306F      ADDW     R0,R4,#+879
   \   00000148   0x.... 0x....      BL       SRData__UpdateByte
    304          
    305          			    if(SR_Fault_Holder == SR_MCATOD_ERROR_PERIPHERAL_SAFE)
   \   0000014C   0xF894 0x036F      LDRB     R0,[R4, #+879]
   \   00000150   0x2806             CMP      R0,#+6
   \   00000152   0xD107             BNE.N    ??SRMCAtod__DiagnosticHandler_9
    306          				{									// If this feedback is also safe, checks in respect to next internal voltage level
    307                              SREnableSelfDiagMode(SR_AD_ENGINE_0,SR_MCATOD_SELF_TEST_VREFH0_SCALE_0_5);
   \   00000154   0x201B             MOVS     R0,#+27
   \   00000156   0x6030             STR      R0,[R6, #+0]
   \   00000158   0x6070             STR      R0,[R6, #+4]
    308                              SREnableSelfDiagMode(SR_AD_ENGINE_1,SR_MCATOD_SELF_TEST_VREFH0_SCALE_0_5);
   \   0000015A   0x6028             STR      R0,[R5, #+0]
   \   0000015C   0x2204             MOVS     R2,#+4
   \   0000015E   0x205B             MOVS     R0,#+91
   \   00000160   0x6068             STR      R0,[R5, #+4]
    309                                                              // Configures peripheral converters to test in respect to internal voltage reference
    310                              SR_MCATOD_UPDATE_STATE(SR_MCATOD_CHECK_CONVERTER_ERROR);
   \   00000162   0xE056             B.N      ??SRMCAtod__DiagnosticHandler_3
    311          				}									// Gets to next test state since this was successfully tested
    312          				else								// Any type of error moves directly to feedback update to publish status
    313          				{
    314                              SR_MCATOD_UPDATE_STATE(SR_MCATOD_FEEDBACK_UPDATED);
   \                     ??SRMCAtod__DiagnosticHandler_9: (+1)
   \   00000164   0x2205             MOVS     R2,#+5
   \   00000166   0xE054             B.N      ??SRMCAtod__DiagnosticHandler_3
    315          				}
    316          			}
    317          			else									// Any type of error moves directly to feedback update to publish status
    318          			{
    319                          SR_MCATOD_UPDATE_STATE(SR_MCATOD_FEEDBACK_UPDATED);
   \                     ??SRMCAtod__DiagnosticHandler_8: (+1)
   \   00000168   0x2205             MOVS     R2,#+5
   \   0000016A   0xE052             B.N      ??SRMCAtod__DiagnosticHandler_3
    320          			}
    321          			break;
    322          
    323          		case SR_MCATOD_CHECK_CONVERTER_ERROR:				// Checks if converter values are good under certain threshold
    324          
    325          			SREnableSelfDiagMode(SR_AD_ENGINE_0,SR_MCATOD_SELF_TEST_DISABLED);
   \                     ??SRMCAtod__DiagnosticHandler_10: (+1)
   \   0000016C   0x200C             MOVS     R0,#+12
   \   0000016E   0x.... 0x....      LDR.W    R6,??DataTable165  ;; 0x4003b000
   \   00000172   0x.... 0x....      LDR.W    R5,??DataTable166  ;; 0x40027000
   \   00000176   0x6030             STR      R0,[R6, #+0]
   \   00000178   0x2204             MOVS     R2,#+4
   \   0000017A   0x2004             MOVS     R0,#+4
   \   0000017C   0x6070             STR      R0,[R6, #+4]
    326          			SREnableSelfDiagMode(SR_AD_ENGINE_1,SR_MCATOD_SELF_TEST_DISABLED);
   \   0000017E   0x2008             MOVS     R0,#+8
   \   00000180   0x6028             STR      R0,[R5, #+0]
   \   00000182   0x2049             MOVS     R0,#+73
   \   00000184   0x6068             STR      R0,[R5, #+4]
    327          													// Disables self diagnostic
    328          			temp = (uint8) IsConverterSafe(SR_AD_ENGINE_0,SR_Threshold, SR_MCATOD_SELF_TEST_VREFH0_SCALE_0_5);
   \   00000186   0xF9B4 0x039A      LDRSH    R0,[R4, #+922]
   \   0000018A   0x6931             LDR      R1,[R6, #+16]
   \   0000018C   0x6973             LDR      R3,[R6, #+20]
   \   0000018E   0xB21B             SXTH     R3,R3
   \   00000190   0xFA03 0xF181      SXTAH    R1,R3,R1
   \   00000194   0x03C9             LSLS     R1,R1,#+15
   \   00000196   0xF240 0x531E      MOVW     R3,#+1310
   \   0000019A   0x1409             ASRS     R1,R1,#+16
   \   0000019C   0x1A1B             SUBS     R3,R3,R0
   \   0000019E   0x4299             CMP      R1,R3
   \   000001A0   0xBFA2             ITTT     GE 
   \   000001A2   0xF200 0x501E      ADDWGE   R0,R0,#+1310
   \   000001A6   0x4288             CMPGE    R0,R1
   \   000001A8   0x2206             MOVGE    R2,#+6
    329          			SR_MCATOD_UPDATE_FAULT_HOLDER(temp);    // Gets converter status
   \   000001AA   0xF204 0x5189      ADDW     R1,R4,#+1417
   \   000001AE   0xF204 0x306F      ADDW     R0,R4,#+879
   \   000001B2   0x.... 0x....      BL       SRData__UpdateByte
    330          
    331          			if (SR_Fault_Holder == SR_MCATOD_ERROR_PERIPHERAL_SAFE)	// If previous converter feedback is SAFE, checks next converter
   \   000001B6   0xF894 0x036F      LDRB     R0,[R4, #+879]
   \   000001BA   0x2806             CMP      R0,#+6
   \   000001BC   0xD11A             BNE.N    ??SRMCAtod__DiagnosticHandler_11
    332          			{
    333                          temp = (uint8) IsConverterSafe(SR_AD_ENGINE_1,SR_Threshold, SR_MCATOD_SELF_TEST_VREFH0_SCALE_0_5);
   \   000001BE   0xF9B4 0x039A      LDRSH    R0,[R4, #+922]
   \   000001C2   0x6929             LDR      R1,[R5, #+16]
   \   000001C4   0x696B             LDR      R3,[R5, #+20]
   \   000001C6   0xB21B             SXTH     R3,R3
   \   000001C8   0xFA03 0xF181      SXTAH    R1,R3,R1
   \   000001CC   0x03C9             LSLS     R1,R1,#+15
   \   000001CE   0xF240 0x531E      MOVW     R3,#+1310
   \   000001D2   0x2204             MOVS     R2,#+4
   \   000001D4   0x1409             ASRS     R1,R1,#+16
   \   000001D6   0x1A1B             SUBS     R3,R3,R0
   \   000001D8   0x4299             CMP      R1,R3
   \   000001DA   0xBFA2             ITTT     GE 
   \   000001DC   0xF200 0x501E      ADDWGE   R0,R0,#+1310
   \   000001E0   0x4288             CMPGE    R0,R1
   \   000001E2   0x2206             MOVGE    R2,#+6
    334                          SR_MCATOD_UPDATE_FAULT_HOLDER(temp);    // Gets converter status
   \   000001E4   0xF204 0x5189      ADDW     R1,R4,#+1417
   \   000001E8   0xF204 0x306F      ADDW     R0,R4,#+879
   \   000001EC   0x.... 0x....      BL       SRData__UpdateByte
    335                          SR_MCATOD_UPDATE_STATE(SR_MCATOD_FEEDBACK_UPDATED);
   \   000001F0   0x2205             MOVS     R2,#+5
   \   000001F2   0xE00E             B.N      ??SRMCAtod__DiagnosticHandler_3
    336                                                              // Gets converter feedback and update for publishing
    337          			}
    338          			else									// Any type of error moves directly to feedback update to publish status
    339          			{
    340                          SR_MCATOD_UPDATE_STATE(SR_MCATOD_FEEDBACK_UPDATED);
   \                     ??SRMCAtod__DiagnosticHandler_11: (+1)
   \   000001F4   0x2205             MOVS     R2,#+5
   \   000001F6   0xE00C             B.N      ??SRMCAtod__DiagnosticHandler_3
    341          			}
    342          			break;
    343          
    344          		case SR_MCATOD_FEEDBACK_UPDATED:					// Stays here until upper level application gets feedback
    345          
    346          			break;
    347          
    348          		default:									// default state returns to wait command to check
    349          			SREnableSelfDiagMode(SR_AD_ENGINE_0,SR_MCATOD_SELF_TEST_DISABLED);
   \                     ??SRMCAtod__DiagnosticHandler_1: (+1)
   \   000001F8   0x.... 0x....      LDR.W    R6,??DataTable165  ;; 0x4003b000
   \   000001FC   0x.... 0x....      LDR.W    R5,??DataTable166  ;; 0x40027000
   \   00000200   0x200C             MOVS     R0,#+12
   \   00000202   0x6030             STR      R0,[R6, #+0]
   \   00000204   0x2200             MOVS     R2,#+0
   \   00000206   0x2004             MOVS     R0,#+4
   \   00000208   0x6070             STR      R0,[R6, #+4]
    350          			SREnableSelfDiagMode(SR_AD_ENGINE_1,SR_MCATOD_SELF_TEST_DISABLED);
   \   0000020A   0x2008             MOVS     R0,#+8
   \   0000020C   0x6028             STR      R0,[R5, #+0]
   \   0000020E   0x2049             MOVS     R0,#+73
   \   00000210   0x6068             STR      R0,[R5, #+4]
   \                     ??SRMCAtod__DiagnosticHandler_3: (+1)
   \   00000212   0xF504 0x61B1      ADD      R1,R4,#+1416
   \   00000216   0xF204 0x306E      ADDW     R0,R4,#+878
   \   0000021A   0xB001             ADD      SP,SP,#+4
   \   0000021C   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   00000220   0x.... 0x....      B.W      SRData__UpdateByte
    351          													// Disables self diagnostic
    352          			SR_MCATOD_UPDATE_STATE(SR_MCATOD_WAITING_TO_CHECK);
    353          			break;
    354          	}
    355          }
   \                     ??SRMCAtod__DiagnosticHandler_12: (+1)
   \   00000224   0xB001             ADD      SP,SP,#+4
   \   00000226   0xBDF0             POP      {R4-R7,PC}       ;; return
    356          
    357          //---------------------------------------------------------------------------------------------------------------------
    358          /**
    359           *  @brief      Enable AtoD Diagnostic features.
    360           *
    361           *  @details    This function is a handler used to start checking 12 bits AD registers and converters status.
    362           *              Only restarts if feedback was updated or it's waiting for a check request.
    363           *
    364           *  @param      commanded_threshold Threshold used for the correct level detection
    365           *
    366           */

   \                                 In section .text, align 2, keep-with-next
    367          void SRMCAtod__EnableDiagnostic(sint16 commanded_threshold)
    368          {
   \                     SRMCAtod__EnableDiagnostic: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    369          
    370              SR_MCATOD_CHECK_STATE();
   \   00000004   0x....             LDR.N    R5,??DataTable146
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0xF505 0x61B1      ADD      R1,R5,#+1416
   \   0000000C   0xF205 0x306E      ADDW     R0,R5,#+878
   \   00000010   0x.... 0x....      BL       SRData__CheckByte
    371              SR_MCATOD_CHECK_THRESHOLD();
   \   00000014   0xF205 0x518E      ADDW     R1,R5,#+1422
   \   00000018   0xF205 0x309A      ADDW     R0,R5,#+922
   \   0000001C   0x.... 0x....      BL       SRData__CheckShort
    372          
    373          	if ((SR_State == SR_MCATOD_WAITING_TO_CHECK)||(SR_State == SR_MCATOD_FEEDBACK_UPDATED))
   \   00000020   0xF895 0x036E      LDRB     R0,[R5, #+878]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xBF18             IT       NE 
   \   00000028   0x2805             CMPNE    R0,#+5
   \   0000002A   0xD110             BNE.N    ??SRMCAtod__EnableDiagnostic_0
    374          	{
    375          		SR_MCATOD_UPDATE_THRESHOLD(commanded_threshold);
   \   0000002C   0xB2A2             UXTH     R2,R4
   \   0000002E   0xF205 0x518E      ADDW     R1,R5,#+1422
   \   00000032   0xF205 0x309A      ADDW     R0,R5,#+922
   \   00000036   0x.... 0x....      BL       SRData__UpdateShort
    376          	    SR_MCATOD_UPDATE_STATE(SR_MCATOD_START_EVAL);						// Gets to next state to get feedbacks from this test
   \   0000003A   0xF505 0x61B1      ADD      R1,R5,#+1416
   \   0000003E   0xF205 0x306E      ADDW     R0,R5,#+878
   \   00000042   0xB001             ADD      SP,SP,#+4
   \   00000044   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   00000048   0x2201             MOVS     R2,#+1
   \   0000004A   0x.... 0x....      B.W      SRData__UpdateByte
    377          	}												// Defines new threshold for this verification
    378          }
   \                     ??SRMCAtod__EnableDiagnostic_0: (+1)
   \   0000004E   0xB001             ADD      SP,SP,#+4
   \   00000050   0xBD30             POP      {R4,R5,PC}       ;; return
    379          
    380          //---------------------------------------------------------------------------------------------------------------------
    381          /**
    382           *  @brief      Get diagnostic status.
    383           *
    384           *  @details    This function gets converters status.
    385           *
    386           *  @return     Returns if all converters tests result: TEST_NOT_PERFORMED, TEST_NOT_INITIALIZED, REGISTER_BIT_STUCK_AT_0,
    387           *              REGISTER_BIT_STUCK_AT_1, CONVERTER_ERROR or PERIPHERAL_SAFE
    388           */

   \                                 In section .text, align 2, keep-with-next
    389          SRMCATOD_DIAG_ERROR_TYPE SRMCAtod__GetDiagnosticFeedback(void)
    390          {
   \                     SRMCAtod__GetDiagnosticFeedback: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    391          	SRMCATOD_DIAG_ERROR_TYPE current_status;
    392              uint32 temp;
    393          
    394          	SR_MCATOD_CHECK_STATE();
   \   00000002   0x....             LDR.N    R4,??DataTable146
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0xF504 0x61B1      ADD      R1,R4,#+1416
   \   0000000A   0xF204 0x306E      ADDW     R0,R4,#+878
   \   0000000E   0x.... 0x....      BL       SRData__CheckByte
    395          	SR_MCATOD_CHECK_FAULT_HOLDER();
   \   00000012   0xF204 0x5189      ADDW     R1,R4,#+1417
   \   00000016   0xF204 0x306F      ADDW     R0,R4,#+879
   \   0000001A   0x.... 0x....      BL       SRData__CheckByte
    396          
    397          	if (SR_State == SR_MCATOD_FEEDBACK_UPDATED)				// Checks if test is concluded
   \   0000001E   0xF894 0x036E      LDRB     R0,[R4, #+878]
   \   00000022   0x2805             CMP      R0,#+5
   \   00000024   0xD111             BNE.N    ??SRMCAtod__GetDiagnosticFeedback_0
    398          	{
    399          	    temp  = SR_Fault_Holder;
   \   00000026   0xF894 0x536F      LDRB     R5,[R4, #+879]
    400          
    401                  if((temp == SR_MCATOD_ERROR_REGISTER_BIT_STUCK_AT_0) ||
    402                     (temp == SR_MCATOD_ERROR_REGISTER_BIT_STUCK_AT_1) ||
    403                     (temp == SR_MCATOD_ERROR_CONVERTER_ERROR) )
   \   0000002A   0x2D02             CMP      R5,#+2
   \   0000002C   0xBF1C             ITT      NE 
   \   0000002E   0x2D03             CMPNE    R5,#+3
   \   00000030   0x2D04             CMPNE    R5,#+4
   \   00000032   0xD100             BNE.N    ??SRMCAtod__GetDiagnosticFeedback_1
    404                  {
    405                      current_status = SR_MCATOD_ERROR_PERIPHERAL_NOT_SAFE;
   \   00000034   0x2505             MOVS     R5,#+5
    406                  }
    407                  else
    408                  {
    409                      current_status = SR_Fault_Holder;
    410                  }
    411          
    412          		SR_MCATOD_UPDATE_FAULT_HOLDER(SR_MCATOD_ERROR_TEST_NOT_INITIALIZED);
   \                     ??SRMCAtod__GetDiagnosticFeedback_1: (+1)
   \   00000036   0x2201             MOVS     R2,#+1
   \   00000038   0xF204 0x5189      ADDW     R1,R4,#+1417
   \   0000003C   0xF204 0x306F      ADDW     R0,R4,#+879
   \   00000040   0x.... 0x....      BL       SRData__UpdateByte
    413          		                                                // Returns test feedback and reinitializes for next test waiting to be initialized
    414          	}
    415          	else if (SR_State == SR_MCATOD_WAITING_TO_CHECK)			// In case test was never performed
    416          	{
    417          		current_status = SR_MCATOD_ERROR_TEST_NOT_INITIALIZED;	// Returns it's waiting to be initialized
    418          	}
    419          	else											// In case test is still on going
    420          	{
    421          		current_status = SR_MCATOD_ERROR_TEST_NOT_PERFORMED;		// Returns test not performed yet
    422          	}
    423          	return (current_status);						// Returns status
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0xB001             ADD      SP,SP,#+4
   \   00000048   0xBD30             POP      {R4,R5,PC}
   \                     ??SRMCAtod__GetDiagnosticFeedback_0: (+1)
   \   0000004A   0x1E45             SUBS     R5,R0,#+1
   \   0000004C   0x41AD             SBCS     R5,R5,R5
   \   0000004E   0x0FED             LSRS     R5,R5,#+31
   \   00000050   0x4628             MOV      R0,R5
   \   00000052   0xB001             ADD      SP,SP,#+4
   \   00000054   0xBD30             POP      {R4,R5,PC}       ;; return
    424          }
    425          
    426          #if (SRMCATOD_ENABLE_ADDITIONAL_READING == 1)
    427          //---------------------------------------------------------------------------------------------------------------------
    428          /**
    429           *  @brief      Convert a sample value with a manual request.
    430           *
    431           *  @details    This function starts a new conversion using a SW trigger and returns when the conversion has finished.
    432           *
    433           *  @remark     The engine and channel to use need to be configured in the prm file and / or calling the
    434           *              SRMCAtod__ConfigureManualReading function
    435           *
    436           *  @remark     Call this function with caution!
    437           *              This function stops the Motor Control framework until the requested value is converted.
    438           *              If not called properly, this may cause the application to malfunction or even damage the board!
    439           *
    440           */
    441          void SRMCAtod__ConvertManualSample(void)
    442          {
    443              uint8 prev_mux_bit;
    444              uint8 prev_channel;
    445          
    446              // store the configuration
    447              prev_mux_bit = (Manual_Cfg_Hdlr.Base_Reg->ADC_CFG2 & ADC_CFG2_MUXSEL_MASK) >> ADC_CFG2_MUXSEL_SHIFT;
    448              prev_channel = (Manual_Cfg_Hdlr.Base_Reg->ADC_SC1[0] & ADC_SC1_ADCH_MASK);
    449          
    450              // Disable ADC EOS interrupt
    451              ADC1.ADC_SC1[1] &= ~ADC_SC1_AIEN_MASK;
    452              // Disable PDB module
    453              PDB.SC &= ~PDB_SC_PDBEN_MASK;
    454              // hardware trigger disabled
    455              Manual_Cfg_Hdlr.Base_Reg->ADC_SC2 &= ~ADC_SC2_ADTRG_MASK;
    456          
    457              // configure to the new channel & start the conversion
    458              if (Manual_Cfg_Hdlr.Use_Mux)
    459              {
    460                  Manual_Cfg_Hdlr.Base_Reg->ADC_CFG2 |= ADC_CFG2_MUXSEL_MASK;
    461              }
    462              else
    463              {
    464                  Manual_Cfg_Hdlr.Base_Reg->ADC_CFG2 &= ~ADC_CFG2_MUXSEL_MASK;
    465              }
    466              Manual_Cfg_Hdlr.Base_Reg->ADC_SC1[0] = (Manual_Cfg_Hdlr.Base_Reg->ADC_SC1[0] & 0x60) | Manual_Cfg_Hdlr.Channel;
    467          
    468              // wait for the conversion complete
    469              while ((Manual_Cfg_Hdlr.Base_Reg->ADC_SC1[0] & ADC_SC1_COCO_MASK) != ADC_SC1_COCO_MASK)
    470              {
    471                  // If too close to the reload event
    472                  if ((FTM0.MOD - FTM0.CNT) < CONVERSION_TIME_THR)
    473                  {
    474                      // Conversion is taking too much time
    475                      SRMCATOD_MANUAL_CONVERSION_EXCEPTION();
    476                  }
    477              }
    478              // read the result
    479              Last_Manual_Sample = (signed short int)(Manual_Cfg_Hdlr.Base_Reg->ADC_R[0]);
    480          
    481              // restore previous configuration
    482              // enable HW trigger
    483              Manual_Cfg_Hdlr.Base_Reg->ADC_SC2 |= ADC_SC2_ADTRG_MASK;
    484              // reconfigure the channel to default value
    485              Manual_Cfg_Hdlr.Base_Reg->ADC_CFG2 |= (prev_mux_bit << ADC_CFG2_MUXSEL_SHIFT);
    486              Manual_Cfg_Hdlr.Base_Reg->ADC_SC1[0] = (Manual_Cfg_Hdlr.Base_Reg->ADC_SC1[0] & 0x60) | prev_channel;
    487          
    488              // Enable PDB module
    489              PDB.SC |= PDB_SC_PDBEN_MASK;
    490              // Enable ADC EOS interrupt
    491              ADC1.ADC_SC1[1] |= ADC_SC1_AIEN_MASK;
    492          }
    493          
    494          //---------------------------------------------------------------------------------------------------------------------
    495          /**
    496           *  @brief      Get the last manually converted value.
    497           *
    498           *  @remark     Call the SRMCAtod__ConvertManualSample function first to ensure an updated value
    499           *
    500           *  @return     The converted value, in AD Counts.
    501           */
    502          sint16 SRMCAtod__GetLastManualSample(void)
    503          {
    504              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    505              sint16 ret = 0;
    506          
    507              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
    508              ret = Last_Manual_Sample;
    509              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
    510          
    511              return ret;
    512          }
    513          
    514          //---------------------------------------------------------------------------------------------------------------------
    515          /**
    516           *  @brief      Configure the manual reading operation
    517           *
    518           *  @param      engine      ADC engine to use for the manual reading
    519           *              channel     The channel number, according to the SRMCATOD_CHANNEL_DEF type
    520           *              use_mux     MUX select setting for the selected additional channel
    521           *
    522           *  @return
    523           */
    524          void SRMCAtod__ConfigureManualReading(SRMCATOD_CONVERTER_TYPE engine, SRMCATOD_CHANNEL_DEF channel, BOOL_TYPE use_mux)
    525          {
    526              Manual_Cfg_Hdlr.Engine = engine;
    527              Manual_Cfg_Hdlr.Channel = channel;
    528              Manual_Cfg_Hdlr.Use_Mux = use_mux;
    529          
    530              if (engine == SR_AD_ENGINE_0)
    531              {
    532                  Manual_Cfg_Hdlr.Base_Reg = &ADC0;
    533              }
    534              else if (engine == SR_AD_ENGINE_1)
    535              {
    536                  Manual_Cfg_Hdlr.Base_Reg = &ADC1;
    537              }
    538              else
    539              {
    540                  // intentionally left blank
    541              }
    542          }
    543          #endif
    544          //=====================================================================================================================
    545          //-------------------------------------- Private Functions ------------------------------------------------------------
    546          //=====================================================================================================================
    547          
    548          /**
    549           *  @brief      Initialization of ADC0
    550           *
    551           *  @details    This function configures ADC0 to sample 2 channels triggered by PDB0 delay in respect to FTM0 event.
    552           *
    553           */

   \                                 In section .text, align 2, keep-with-next
    554          static void SRInitializeAD0(void)
    555          {
   \                     ??SRInitializeAD0: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    556              //------------------------------  AD0 Configuration ------------------------------
    557          	DisableEndOfConversionInteruption(SR_AD_ENGINE_0);
   \   00000004   0x2027             MOVS     R0,#+39
   \   00000006   0x.... 0x....      BL       Micro__NVICDisableIRQ
    558          	// System clock enabling
    559          	SIM.SCGC6 |= SIM_SCGC6_ADC0_MASK;				// Enables ADC0 clock
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable166_1  ;; 0x4004803c
    560          	// ADC0 Self calibration
    561          	SRCalibrateAD0();
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable165  ;; 0x4003b000
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x.... 0x....      LDR.W    R6,??DataTable166_2  ;; 0x4005200c
   \   00000018   0xF041 0x6100      ORR      R1,R1,#0x8000000
   \   0000001C   0x6001             STR      R1,[R0, #+0]
   \   0000001E   0x2074             MOVS     R0,#+116
   \   00000020   0x60A0             STR      R0,[R4, #+8]
   \   00000022   0xF24B 0x4580      MOVW     R5,#+46208
   \   00000026   0x2004             MOVS     R0,#+4
   \   00000028   0x60E0             STR      R0,[R4, #+12]
   \   0000002A   0xF24A 0x6702      MOVW     R7,#+42498
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x6220             STR      R0,[R4, #+32]
   \   00000032   0x2007             MOVS     R0,#+7
   \   00000034   0x6260             STR      R0,[R4, #+36]
   \   00000036   0x6A60             LDR      R0,[R4, #+36]
   \   00000038   0xF040 0x0080      ORR      R0,R0,#0x80
   \   0000003C   0x6260             STR      R0,[R4, #+36]
   \                     ??SRInitializeAD0_1: (+1)
   \   0000003E   0x6A60             LDR      R0,[R4, #+36]
   \   00000040   0x0640             LSLS     R0,R0,#+25
   \   00000042   0xBF48             IT       MI 
   \   00000044   0x.... 0x....      BLMI     Micro__Trap
   \   00000048   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   0000004C   0xB672             CPSID    I
   \   0000004E   0x8037             STRH     R7,[R6, #+0]
   \   00000050   0x8035             STRH     R5,[R6, #+0]
   \   00000052   0xF380 0x8810      MSR      PRIMASK,R0
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x0600             LSLS     R0,R0,#+24
   \   0000005A   0xD5F0             BPL.N    ??SRInitializeAD0_1
   \   0000005C   0x6CE0             LDR      R0,[R4, #+76]
   \   0000005E   0x6CA0             LDR      R0,[R4, #+72]
   \   00000060   0x6C60             LDR      R0,[R4, #+68]
   \   00000062   0x6C20             LDR      R0,[R4, #+64]
   \   00000064   0x6BE0             LDR      R0,[R4, #+60]
   \   00000066   0x6BA0             LDR      R0,[R4, #+56]
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable166_3  ;; 0x4004d040
   \   0000006C   0x0400             LSLS     R0,R0,#+16
   \   0000006E   0x0C40             LSRS     R0,R0,#+17
   \   00000070   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000074   0x62E0             STR      R0,[R4, #+44]
   \   00000076   0x6EE0             LDR      R0,[R4, #+108]
   \   00000078   0x6EA0             LDR      R0,[R4, #+104]
   \   0000007A   0x6E60             LDR      R0,[R4, #+100]
   \   0000007C   0x6E20             LDR      R0,[R4, #+96]
   \   0000007E   0x6DE0             LDR      R0,[R4, #+92]
   \   00000080   0x6DA0             LDR      R0,[R4, #+88]
   \   00000082   0x0400             LSLS     R0,R0,#+16
   \   00000084   0x0C40             LSRS     R0,R0,#+17
   \   00000086   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   0000008A   0x6320             STR      R0,[R4, #+48]
    562          	// setting prescaler to get ADCK = bus clock, 12 bits resolution, short sample time and normal operation mode
    563          	ADC0.ADC_CFG1 = ADC_CFG1_ADIV(SRMCATOD_ADC0_CLOCK_DIVIDE_SEL)
    564          					| ADC_CFG1_ADICLK(SRMCATOD_ADC0_CLK_INPUT)
    565          					| ADC_CFG1_MODE(SRMCATOD_ADC0_RES_MODE);
   \   0000008C   0x2024             MOVS     R0,#+36
   \   0000008E   0x60A0             STR      R0,[R4, #+8]
    566          
    567          	ADC0.ADC_CFG2 = ADC_CFG2_ADHSC_MASK;			// High speed configuration
   \   00000090   0x2004             MOVS     R0,#+4
   \   00000092   0x60E0             STR      R0,[R4, #+12]
    568          	// Configure ports as analog input
    569          	// First and Second samples
    570              #if(SRMCATOD_ADC0_MUX_SET == 1)
    571                  #if(SRMCATOD_ADC0_FIRST_SAMPLE_CHN == 4)
    572                      PCIPORTC.PCR[SRMCATOD_ADC0_FIRST_SAMPLE_CHN - 2] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    573                  #elif(SRMCATOD_ADC0_FIRST_SAMPLE_CHN == 5)
    574                      PCIPORTD.PCR[SRMCATOD_ADC0_FIRST_SAMPLE_CHN - 4] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    575                  #elif((SRMCATOD_ADC0_FIRST_SAMPLE_CHN == 6) || (SRMCATOD_ADC0_FIRST_SAMPLE_CHN == 7))
    576                      PCIPORTD.PCR[SRMCATOD_ADC0_FIRST_SAMPLE_CHN - 1] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    577                  #endif
    578          
    579                  #if(SRMCATOD_ADC0_SECOND_SAMPLE_CHN == 4)
    580                      PCIPORTC.PCR[SRMCATOD_ADC0_SECOND_SAMPLE_CHN - 2] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    581                  #elif(SRMCATOD_ADC0_SECOND_SAMPLE_CHN == 5)
    582                      PCIPORTD.PCR[SRMCATOD_ADC0_SECOND_SAMPLE_CHN - 4] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    583                  #elif((SRMCATOD_ADC0_SECOND_SAMPLE_CHN == 6) || (SRMCATOD_ADC0_SECOND_SAMPLE_CHN == 7))
    584                      PCIPORTD.PCR[SRMCATOD_ADC0_SECOND_SAMPLE_CHN - 1] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    585                  #endif
    586              #else
    587                  #if ((SRMCATOD_ADC0_FIRST_SAMPLE_CHN >= 4) && (SRMCATOD_ADC0_FIRST_SAMPLE_CHN < 8))
    588                      PCIPORTE.PCR[SRMCATOD_ADC0_FIRST_SAMPLE_CHN + 12] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    589                  #endif
    590                  #if ((SRMCATOD_ADC0_SECOND_SAMPLE_CHN >= 4) && (SRMCATOD_ADC0_SECOND_SAMPLE_CHN < 8))
    591                      PCIPORTE.PCR[SRMCATOD_ADC0_SECOND_SAMPLE_CHN + 12] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x6008             STR      R0,[R1, #+0]
    592                  #endif
    593              #endif
    594              #if((SRMCATOD_ADC0_FIRST_SAMPLE_CHN == 8) || (SRMCATOD_ADC0_FIRST_SAMPLE_CHN == 9))
    595                  PCIPORTB.PCR[SRMCATOD_ADC0_FIRST_SAMPLE_CHN - 8] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    596              #elif((SRMCATOD_ADC0_FIRST_SAMPLE_CHN == 12) || (SRMCATOD_ADC0_FIRST_SAMPLE_CHN == 13))
    597                  PCIPORTB.PCR[SRMCATOD_ADC0_FIRST_SAMPLE_CHN - 10] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable167  ;; 0x4004a008
   \   0000009C   0x6008             STR      R0,[R1, #+0]
    598              #elif((SRMCATOD_ADC0_FIRST_SAMPLE_CHN == 14) || (SRMCATOD_ADC0_FIRST_SAMPLE_CHN == 15))
    599                  PCIPORTC.PCR[SRMCATOD_ADC0_FIRST_SAMPLE_CHN - 14] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    600              #elif((SRMCATOD_ADC0_FIRST_SAMPLE_CHN == 17) || (SRMCATOD_ADC0_FIRST_SAMPLE_CHN == 18))
    601                  PCIPORTE.PCR[SRMCATOD_ADC0_FIRST_SAMPLE_CHN + 7] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    602              #endif
    603              #if((SRMCATOD_ADC0_SECOND_SAMPLE_CHN == 8) || (SRMCATOD_ADC0_SECOND_SAMPLE_CHN == 9))
    604                  PCIPORTB.PCR[SRMCATOD_ADC0_SECOND_SAMPLE_CHN - 8] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    605              #elif((SRMCATOD_ADC0_SECOND_SAMPLE_CHN == 12) || (SRMCATOD_ADC0_SECOND_SAMPLE_CHN == 13))
    606                  PCIPORTB.PCR[SRMCATOD_ADC0_SECOND_SAMPLE_CHN - 10] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    607              #elif((SRMCATOD_ADC0_SECOND_SAMPLE_CHN == 14) || (SRMCATOD_ADC0_SECOND_SAMPLE_CHN == 15))
    608                  PCIPORTC.PCR[SRMCATOD_ADC0_SECOND_SAMPLE_CHN - 14] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    609              #elif((SRMCATOD_ADC0_SECOND_SAMPLE_CHN == 17) || (SRMCATOD_ADC0_SECOND_SAMPLE_CHN == 18))
    610                  PCIPORTE.PCR[SRMCATOD_ADC0_SECOND_SAMPLE_CHN + 7] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    611              #endif
    612              // Additional sample
    613              #if(SRMCATOD_ENABLE_ADDITIONAL_READING == 1)
    614                  #if(SRMCATOD_ADDITIONAL_READING_ADC_ENGINE == 0)
    615                      #if(SRMCATOD_ADDITIONAL_READING_MUX_SELECT == 1)
    616                          #if(SRMCATOD_ADDITIONAL_READING_CHANNEL == 4)
    617                              PCIPORTC.PCR[SRMCATOD_ADDITIONAL_READING_CHANNEL - 2] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    618                          #elif(SRMCATOD_ADDITIONAL_READING_CHANNEL == 5)
    619                              PCIPORTD.PCR[SRMCATOD_ADDITIONAL_READING_CHANNEL - 4] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    620                          #elif((SRMCATOD_ADDITIONAL_READING_CHANNEL == 6) || (SRMCATOD_ADDITIONAL_READING_CHANNEL == 7))
    621                              PCIPORTD.PCR[SRMCATOD_ADDITIONAL_READING_CHANNEL - 1] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    622                          #endif
    623                      #else
    624                          #if ((SRMCATOD_ADDITIONAL_READING_CHANNEL >= 4) && (SRMCATOD_ADDITIONAL_READING_CHANNEL < 8))
    625                              PCIPORTE.PCR[SRMCATOD_ADDITIONAL_READING_CHANNEL + 12] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    626                          #endif
    627                          #if ((SRMCATOD_ADDITIONAL_READING_CHANNEL >= 4) && (SRMCATOD_ADDITIONAL_READING_CHANNEL < 8))
    628                              PCIPORTE.PCR[SRMCATOD_ADDITIONAL_READING_CHANNEL + 12] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    629                          #endif
    630                      #endif
    631                      #if((SRMCATOD_ADDITIONAL_READING_CHANNEL == 8) || (SRMCATOD_ADDITIONAL_READING_CHANNEL == 9))
    632                          PCIPORTB.PCR[SRMCATOD_ADDITIONAL_READING_CHANNEL - 8] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    633                      #elif((SRMCATOD_ADDITIONAL_READING_CHANNEL == 12) || (SRMCATOD_ADDITIONAL_READING_CHANNEL == 13))
    634                          PCIPORTB.PCR[SRMCATOD_ADDITIONAL_READING_CHANNEL - 10] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    635                      #elif((SRMCATOD_ADDITIONAL_READING_CHANNEL == 14) || (SRMCATOD_ADDITIONAL_READING_CHANNEL == 15))
    636                          PCIPORTC.PCR[SRMCATOD_ADDITIONAL_READING_CHANNEL - 14] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    637                      #elif((SRMCATOD_ADDITIONAL_READING_CHANNEL == 17) || (SRMCATOD_ADDITIONAL_READING_CHANNEL == 18))
    638                          PCIPORTE.PCR[SRMCATOD_ADDITIONAL_READING_CHANNEL + 7] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    639                      #endif
    640                  #endif
    641              #endif
    642              // Channel MUX configuration
    643              #if (SRMCATOD_ADC0_MUX_SET == 1)
    644              ADC0.ADC_CFG2 |= ADC_CFG2_MUXSEL_MASK;
    645              #endif
    646          	// hardware trigger enabled
    647          	ADC0.ADC_SC2 |= ADC_SC2_ADTRG_MASK;
   \   0000009E   0x6A20             LDR      R0,[R4, #+32]
   \   000000A0   0xF040 0x0040      ORR      R0,R0,#0x40
   \   000000A4   0x6220             STR      R0,[R4, #+32]
    648          	// hardware averaging disabled and calibration bit cleared (allows next calibration to be called next reset)
    649          	ADC0.ADC_SC3 = 0;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x6260             STR      R0,[R4, #+36]
    650          
    651          	// start conversion of channels and in this application, disables ADC0 interrupts
    652          	// ADC0 end of scan interrupt is disabled. Only ADC1 Interrupt is used
    653          	ADC0.ADC_SC1[0] = ADC_SC1_ADCH(SRMCATOD_ADC0_FIRST_SAMPLE_CHN);
   \   000000AA   0x200C             MOVS     R0,#+12
   \   000000AC   0x6020             STR      R0,[R4, #+0]
    654          	ADC0.ADC_SC1[1] = ADC_SC1_ADCH(SRMCATOD_ADC0_SECOND_SAMPLE_CHN);
   \   000000AE   0x2004             MOVS     R0,#+4
   \   000000B0   0x6060             STR      R0,[R4, #+4]
    655          }
   \   000000B2   0xB001             ADD      SP,SP,#+4
   \   000000B4   0xBDF0             POP      {R4-R7,PC}       ;; return
    656          
    657          /**
    658           *  @brief      ADC self calibration procedure start
    659           *
    660           *  @details    Recommended on AN3949 to operate with ADC clock between 2MHz and 4MHz, in high speed mode and 32 samples averaged.
    661           *              Calibration should be run with both VDDA and VREFH at or above 3V.
    662           *              The input channel, conversion mode setting, compare function values, resolution, and differential and single-ended
    663           *              settings have no effect on the calibration result.
    664           *              Software trigger selected: ADCx_SC2 bit ADTRG must be cleared before calibration.
    665           *              Disable interruptions during calibration.
    666           *              Calibration must be performed at least every reset.
    667           *              For single ended calibrations, minus side gain register can be skipped.
    668           *              Calibration may take as long as 15,000 ADCK cycles + 100 bus cycles
    669           *
    670           */
    671          static void SRCalibrateAD0(void)
    672          {
    673              uint16 calib;
    674          	// setting the clock to 7 MHz (ADIV and ADICLK bits), long sample time and single-ended 12-bit conversion (MODE bits);
    675          	ADC0.ADC_CFG1 = ADC_CFG1_ADIV(SRMCATOD_ADC0_CAL_CLOCK_DIVIDE_SEL)
    676          					| ADC_CFG1_MODE(SRMCATOD_ADC0_RES_MODE)
    677          					| ADC_CFG1_ADICLK(SRMCATOD_ADC0_CLK_INPUT)
    678          					| ADC_CFG1_ADLSMP_MASK;
    679          
    680          	ADC0.ADC_CFG2 = ADC_CFG2_ADHSC_MASK;			// High speed configuration with longest sampling time(20 extra ADCK cycles, 24 total)
    681          
    682          	ADC0.ADC_SC2 = 0;								// Software trigger selected
    683          
    684          	// HW averaging enabled, 32 samples averaged, one shot conversion mode
    685          	ADC0.ADC_SC3 = ADC_SC3_AVGE_MASK
    686          					| ADC_SC3_AVGS(SRMCATOD_ADC1_CAL_HW_AVG_SEL);
    687          
    688          	// starting the calibration of ADC0
    689          	ADC0.ADC_SC3 |= ADC_SC3_CAL_MASK;
    690          	do
    691          	{
    692          		// waits until the calibration completes
    693          		if(( ADC0.ADC_SC3 & ADC_SC3_CALF_MASK ) == ADC_SC3_CALF_MASK)
    694          		{
    695          			Micro__Trap();						    // traps in here in case calibration failed, waiting for the watchdog (must be enabled before calling this configuration)
    696          		}
    697          		SERVICE_WATCHDOG();
    698          		
    699          	} while (((ADC0.ADC_SC1[0] & ADC_SC1_COCO_MASK) != ADC_SC1_COCO_MASK));
    700          
    701          	calib = 0;										//16 bit RAM initialized
    702          	calib = ADC0.ADC_CLP0;
    703          	calib =+ ADC0.ADC_CLP1;
    704          	calib =+ ADC0.ADC_CLP2;
    705          	calib =+ ADC0.ADC_CLP3;
    706          	calib =+ ADC0.ADC_CLP4;
    707          	calib =+ ADC0.ADC_CLPS;							// Calibration results added
    708          	calib = calib >> 1;								// Divided by 2
    709          	calib = calib | 0x8000; 						// set the MSB (2's complement)
    710          	ADC0.ADC_PG = calib; 							// Plus side gain register updated
    711          	// Minus side gain register updated (not required for single ended calibrations)
    712          	calib = 0;										//16 bit RAM initialized again, just in case
    713          	calib = ADC0.ADC_CLM0;
    714          	calib =+ ADC0.ADC_CLM1;
    715          	calib =+ ADC0.ADC_CLM2;
    716          	calib =+ ADC0.ADC_CLM3;
    717          	calib =+ ADC0.ADC_CLM4;
    718          	calib =+ ADC0.ADC_CLMS;                         // Calibration results added
    719          	calib = calib >> 1;                             // Divided by 2
    720          	calib = calib | 0x8000;                         // set the MSB (2's complement)
    721          	ADC0.ADC_MG = calib;                            // Minus side gain register updated
    722          }
    723          
    724          /**
    725           *  @brief      Initialization of ADC1
    726           *
    727           *  @details    This function configures ADC1 to sample 2 channels triggered by PDB0 delay in respect to FTM0 event.
    728           *
    729           */

   \                                 In section .text, align 2, keep-with-next
    730          static void SRInitializeAD1(void)
    731          {
   \                     ??SRInitializeAD1: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    732          	Micro__NVICDisableIRQ(ADC1_IRQ_CHANNEL);		// Disables ADC1 interruption during configuration
   \   00000004   0x2049             MOVS     R0,#+73
   \   00000006   0x.... 0x....      BL       Micro__NVICDisableIRQ
    733          	// System clock enabling
    734          	SIM.SCGC6 |= SIM_SCGC6_ADC1_MASK;				// Enables ADC1 clock
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable166_1  ;; 0x4004803c
    735          	SRCalibrateAD1();
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable166  ;; 0x40027000
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x.... 0x....      LDR.W    R6,??DataTable166_2  ;; 0x4005200c
   \   00000018   0xF041 0x0180      ORR      R1,R1,#0x80
   \   0000001C   0x6001             STR      R1,[R0, #+0]
   \   0000001E   0x2074             MOVS     R0,#+116
   \   00000020   0x60A0             STR      R0,[R4, #+8]
   \   00000022   0xF24B 0x4580      MOVW     R5,#+46208
   \   00000026   0x2004             MOVS     R0,#+4
   \   00000028   0x60E0             STR      R0,[R4, #+12]
   \   0000002A   0xF24A 0x6702      MOVW     R7,#+42498
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x6220             STR      R0,[R4, #+32]
   \   00000032   0x2007             MOVS     R0,#+7
   \   00000034   0x6260             STR      R0,[R4, #+36]
   \   00000036   0x6A60             LDR      R0,[R4, #+36]
   \   00000038   0xF040 0x0080      ORR      R0,R0,#0x80
   \   0000003C   0x6260             STR      R0,[R4, #+36]
   \                     ??SRInitializeAD1_1: (+1)
   \   0000003E   0x6A60             LDR      R0,[R4, #+36]
   \   00000040   0x0640             LSLS     R0,R0,#+25
   \   00000042   0xBF48             IT       MI 
   \   00000044   0x.... 0x....      BLMI     Micro__Trap
   \   00000048   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   0000004C   0xB672             CPSID    I
   \   0000004E   0x8037             STRH     R7,[R6, #+0]
   \   00000050   0x8035             STRH     R5,[R6, #+0]
   \   00000052   0xF380 0x8810      MSR      PRIMASK,R0
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x0600             LSLS     R0,R0,#+24
   \   0000005A   0xD5F0             BPL.N    ??SRInitializeAD1_1
   \   0000005C   0x2200             MOVS     R2,#+0
   \   0000005E   0x6CE0             LDR      R0,[R4, #+76]
   \   00000060   0x6CA0             LDR      R0,[R4, #+72]
   \   00000062   0x6C60             LDR      R0,[R4, #+68]
   \   00000064   0x6C20             LDR      R0,[R4, #+64]
   \   00000066   0x6BE0             LDR      R0,[R4, #+60]
   \   00000068   0x6BA0             LDR      R0,[R4, #+56]
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable167_1  ;; 0x4004a004
   \   0000006E   0x0400             LSLS     R0,R0,#+16
   \   00000070   0x0C40             LSRS     R0,R0,#+17
   \   00000072   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000076   0x62E0             STR      R0,[R4, #+44]
   \   00000078   0x6EE0             LDR      R0,[R4, #+108]
   \   0000007A   0x6EA0             LDR      R0,[R4, #+104]
   \   0000007C   0x6E60             LDR      R0,[R4, #+100]
   \   0000007E   0x6E20             LDR      R0,[R4, #+96]
   \   00000080   0x6DE0             LDR      R0,[R4, #+92]
   \   00000082   0x6DA0             LDR      R0,[R4, #+88]
   \   00000084   0x0400             LSLS     R0,R0,#+16
   \   00000086   0x0C40             LSRS     R0,R0,#+17
   \   00000088   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   0000008C   0x6320             STR      R0,[R4, #+48]
    736          
    737          	ADC1.ADC_CFG2 = ADC_CFG2_ADHSC_MASK;			// High speed configuration
   \   0000008E   0x2004             MOVS     R0,#+4
   \   00000090   0x60E0             STR      R0,[R4, #+12]
    738          	// Configure ports as analog input
    739          	// First and Second samples
    740              #if(SRMCATOD_ADC1_MUX_SET == 1)
    741                  #if((SRMCATOD_ADC1_FIRST_SAMPLE_CHN >= 4) && (SRMCATOD_ADC1_FIRST_SAMPLE_CHN < 8))
    742                      PCIPORTC.PCR[SRMCATOD_ADC1_FIRST_SAMPLE_CHN + 4] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    743                  #endif
    744          
    745                  #if((SRMCATOD_ADC1_SECOND_SAMPLE_CHN >= 4) && (SRMCATOD_ADC1_SECOND_SAMPLE_CHN < 8))
    746                      PCIPORTC.PCR[SRMCATOD_ADC1_SECOND_SAMPLE_CHN + 4] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    747                  #endif
    748              #else
    749                  #if ((SRMCATOD_ADC1_FIRST_SAMPLE_CHN >= 4) && (SRMCATOD_ADC1_FIRST_SAMPLE_CHN < 8))
    750                      PCIPORTE.PCR[SRMCATOD_ADC1_FIRST_SAMPLE_CHN -4] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    751                  #endif
    752                  #if ((SRMCATOD_ADC1_SECOND_SAMPLE_CHN >= 4) && (SRMCATOD_ADC1_SECOND_SAMPLE_CHN < 8))
    753                      PCIPORTE.PCR[SRMCATOD_ADC1_SECOND_SAMPLE_CHN -4] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    754                  #endif
    755              #endif
    756              #if((SRMCATOD_ADC1_FIRST_SAMPLE_CHN == 14) || (SRMCATOD_ADC1_FIRST_SAMPLE_CHN == 15))
    757                  PCIPORTB.PCR[SRMCATOD_ADC1_FIRST_SAMPLE_CHN - 4] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    758              #elif(SRMCATOD_ADC1_FIRST_SAMPLE_CHN == 17)
    759                  PCIPORTA.PCR[SRMCATOD_ADC1_FIRST_SAMPLE_CHN] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    760              #endif
    761              #if((SRMCATOD_ADC1_SECOND_SAMPLE_CHN == 8) || (SRMCATOD_ADC1_SECOND_SAMPLE_CHN == 9))
    762                  PCIPORTB.PCR[SRMCATOD_ADC1_SECOND_SAMPLE_CHN - 8] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x6008             STR      R0,[R1, #+0]
   \   00000096   0x2100             MOVS     R1,#+0
    763              #elif((SRMCATOD_ADC1_SECOND_SAMPLE_CHN == 14) || (SRMCATOD_ADC1_SECOND_SAMPLE_CHN == 15))
    764                  PCIPORTB.PCR[SRMCATOD_ADC1_FIRST_SAMPLE_CHN - 4] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    765              #elif(SRMCATOD_ADC1_SECOND_SAMPLE_CHN == 17)
    766                  PCIPORTA.PCR[SRMCATOD_ADC1_SECOND_SAMPLE_CHN] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    767              #endif
    768              // Additional sample
    769              #if(SRMCATOD_ENABLE_ADDITIONAL_READING == 1)
    770                  #if(SRMCATOD_ADDITIONAL_READING_ADC_ENGINE == 1)
    771                      #if(SRMCATOD_ADDITIONAL_READING_MUX_SELECT == 1)
    772                          #if((SRMCATOD_ADDITIONAL_READING_CHANNEL >= 4) && (SRMCATOD_ADDITIONAL_READING_CHANNEL < 8))
    773                              PCIPORTC.PCR[SRMCATOD_ADDITIONAL_READING_CHANNEL + 4] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    774                          #endif
    775                      #else
    776                          #if ((SRMCATOD_ADDITIONAL_READING_CHANNEL >= 4) && (SRMCATOD_ADDITIONAL_READING_CHANNEL < 8))
    777                              PCIPORTE.PCR[SRMCATOD_ADDITIONAL_READING_CHANNEL -4] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    778                          #endif
    779                      #endif
    780                      #if((SRMCATOD_ADDITIONAL_READING_CHANNEL == 14) || (SRMCATOD_ADDITIONAL_READING_CHANNEL == 15))
    781                          PCIPORTB.PCR[SRMCATOD_ADDITIONAL_READING_CHANNEL - 4] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    782                      #elif(SRMCATOD_ADDITIONAL_READING_CHANNEL == 17)
    783                          PCIPORTA.PCR[SRMCATOD_ADDITIONAL_READING_CHANNEL] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    784                      #elif((SRMCATOD_ADDITIONAL_READING_CHANNEL == 8) || (SRMCATOD_ADDITIONAL_READING_CHANNEL == 9))
    785                          PCIPORTB.PCR[SRMCATOD_ADDITIONAL_READING_CHANNEL - 8] = PORT_PCR_MUX(SRMCATOD_ANALOG_INPUT_CONFIG);
    786                      #endif
    787                  #endif
    788              #endif
    789              // Channel MUX configuration
    790          #if (SRMCATOD_ADC1_MUX_SET == 1)
    791              ADC1.ADC_CFG2 |= ADC_CFG2_MUXSEL_MASK;
    792          #endif
    793              // setting prescaler to get ADCK = bus clock, 12 bits resolution, short sample time and normal operation mode
    794              ADC1.ADC_CFG1 = ADC_CFG1_ADIV(SRMCATOD_ADC1_CLOCK_DIVIDE_SEL)
    795              				| ADC_CFG1_ADICLK(SRMCATOD_ADC1_CLK_INPUT)
    796          					| ADC_CFG1_MODE(SRMCATOD_ADC1_RES_MODE);
   \   00000098   0x2024             MOVS     R0,#+36
   \   0000009A   0x60A0             STR      R0,[R4, #+8]
    797          
    798              // hardware trigger enabled
    799          	ADC1.ADC_SC2 |= ADC_SC2_ADTRG_MASK;
   \   0000009C   0x6A20             LDR      R0,[R4, #+32]
   \   0000009E   0xF040 0x0040      ORR      R0,R0,#0x40
   \   000000A2   0x6220             STR      R0,[R4, #+32]
    800              // hardware averaging disabled and calibration bit cleared (allows next calibration to be called next reset)
    801              ADC1.ADC_SC3 = 0;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x6260             STR      R0,[R4, #+36]
    802          
    803              // start conversion of channels and in this application, disables ADC interrupts
    804              ADC1.ADC_SC1[0] = ADC_SC1_ADCH(SRMCATOD_ADC1_FIRST_SAMPLE_CHN);
   \   000000A8   0x2008             MOVS     R0,#+8
   \   000000AA   0x6020             STR      R0,[R4, #+0]
    805              ADC1.ADC_SC1[1] = ADC_SC1_ADCH(SRMCATOD_ADC1_SECOND_SAMPLE_CHN)|ADC_SC1_AIEN_MASK;
   \   000000AC   0x2049             MOVS     R0,#+73
   \   000000AE   0x6060             STR      R0,[R4, #+4]
    806          	EnableEndOfConversionInteruption(SR_AD_ENGINE_1);
   \   000000B0   0xB001             ADD      SP,SP,#+4
   \   000000B2   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   000000B6   0x.... 0x....      B.W      Micro__NVICEnableIRQ
    807          }
    808          
    809          /**
    810           *  @brief      ADC self calibration procedure start
    811           *
    812           *  @details    Recommended on AN3949 to operate with ADC clock between 2MHz and 4MHz, in high speed mode and 32 samples averaged.
    813           *              Calibration should be run with both VDDA and VREFH at or above 3V.
    814           *              The input channel, conversion mode setting, compare function values, resolution, and differential and single-ended
    815           *              settings have no effect on the calibration result.
    816           *              Software trigger selected: ADCx_SC2 bit ADTRG must be cleared before calibration.
    817           *              Disable interruptions during calibration.
    818           *              Calibration must be performed at least every reset.
    819           *              For single ended calibrations, minus side gain register can be skipped.
    820           *              Calibration may take as long as 15,000 ADCK cycles + 100 bus cycles
    821           *
    822           */
    823          static void SRCalibrateAD1(void)
    824          {
    825              uint16 calib;
    826          	// setting the clock to 7 MHz (ADIV and ADICLK bits), long sample time and single-ended 12-bit conversion (MODE bits);
    827          	ADC1.ADC_CFG1 = ADC_CFG1_ADIV(SRMCATOD_ADC1_CAL_CLOCK_DIVIDE_SEL)
    828          					| ADC_CFG1_MODE(SRMCATOD_ADC1_RES_MODE)
    829          					| ADC_CFG1_ADICLK(SRMCATOD_ADC1_CLK_INPUT)
    830          					| ADC_CFG1_ADLSMP_MASK;
    831          
    832          	ADC1.ADC_CFG2 = ADC_CFG2_ADHSC_MASK;            // High speed configuration with longest sampling time(20 extra ADCK cycles, 24 total)
    833          
    834          	ADC1.ADC_SC2 = 0;                               // Software trigger selected
    835          
    836          	// HW averaging enabled, 32 samples averaged, one shot conversion mode
    837          	ADC1.ADC_SC3 = ADC_SC3_AVGE_MASK | ADC_SC3_AVGS(SRMCATOD_ADC1_CAL_HW_AVG_SEL);// | ADC_SC3_ADCO_MASK;
    838          
    839          	// starting the calibration of ADC1
    840          	ADC1.ADC_SC3 |= ADC_SC3_CAL_MASK;
    841          
    842          	do
    843          	{
    844          		// waits until the calibration completes
    845          		if ((ADC1.ADC_SC3 & ADC_SC3_CALF_MASK ) == ADC_SC3_CALF_MASK)
    846          		{
    847          			Micro__Trap();								// traps in here in case calibration failed, waiting for the watchdog (must be enabled before calling this configuration)
    848          		}
    849          		SERVICE_WATCHDOG();
    850          		
    851          	} while (((ADC1.ADC_SC1[0] & ADC_SC1_COCO_MASK) != ADC_SC1_COCO_MASK));
    852          
    853          	calib = 0;										//16 bit RAM initialized
    854          	calib = ADC1.ADC_CLP0;
    855          	calib =+ ADC1.ADC_CLP1;
    856          	calib =+ ADC1.ADC_CLP2;
    857          	calib =+ ADC1.ADC_CLP3;
    858          	calib =+ ADC1.ADC_CLP4;
    859          	calib =+ ADC1.ADC_CLPS;							// Calibration results added
    860          	calib = calib >> 1;								// Divided by 2
    861          	calib = calib | 0x8000; 						// set the MSB (2's complement)
    862          	ADC1.ADC_PG = calib; 							// Plus side gain register updated
    863          	// Minus side gain register updated (not required for single ended calibrations)
    864          	calib = 0;										//16 bit RAM initialized again, just in case
    865          	calib = ADC1.ADC_CLM0;
    866          	calib =+ ADC1.ADC_CLM1;
    867          	calib =+ ADC1.ADC_CLM2;
    868          	calib =+ ADC1.ADC_CLM3;
    869          	calib =+ ADC1.ADC_CLM4;
    870          	calib =+ ADC1.ADC_CLMS;                         // Calibration results added
    871          	calib = calib >> 1;                             // Divided by 2
    872          	calib = calib | 0x8000;                         // set the MSB (2's complement)
    873          	ADC1.ADC_MG = calib;                            // Minus side gain register updated
    874          }
    875          
    876          /**
    877           *  @brief      PDB0 peripheral initialization
    878           *
    879           */
    880          static void SRInitializePDB0(void)
    881          {
    882              // PDB configuration
    883          	SIM.SCGC6 |= SIM_SCGC6_PDB_MASK;				// Enables PDB clock
    884          
    885          	Micro__NVICDisableIRQ(PDB_IRQ_CHANNEL);
    886          
    887          	PDB.MOD = SRMCATOD_PDB_MODULUS_RELOAD & 0xFFFF;			// Specifies counter duration. When the counter reaches this value, it will be reset back to zero (16 bits  read/write).
    888          
    889          	PDB.CH[0].DLY[0] = SRMCATOD_PDB_DELAY_FIRST_CONVERSION;	// Defines a delay to avoid ringing noise in respect to center aligned PWM reload trigger event
    890          	PDB.CH[1].DLY[0] = SRMCATOD_PDB_DELAY_FIRST_CONVERSION; // Defines a delay to avoid ringing noise in respect to center aligned PWM reload trigger event
    891          
    892          
    893          	PDB.CH[0].C1 = PDB_C1_BB(SRMCATOD_PDB_PRE_TRIGGER_CHN_1) // back-to-back mode enabled
    894          			| PDB_C1_TOS(SRMCATOD_PDB_PRE_TRIGGER_CHN_0)
    895          			| PDB_C1_EN(SRMCATOD_PDB_PRE_TRIGGER_CHN_0)
    896          			| PDB_C1_TOS(SRMCATOD_PDB_PRE_TRIGGER_CHN_1)
    897          			| PDB_C1_EN(SRMCATOD_PDB_PRE_TRIGGER_CHN_1);
    898          
    899          	PDB.CH[1].C1 = PDB_C1_BB(SRMCATOD_PDB_PRE_TRIGGER_CHN_1) // back-to-back mode enabled
    900          			| PDB_C1_TOS(SRMCATOD_PDB_PRE_TRIGGER_CHN_0)
    901          			| PDB_C1_EN(SRMCATOD_PDB_PRE_TRIGGER_CHN_0)
    902          			| PDB_C1_TOS(SRMCATOD_PDB_PRE_TRIGGER_CHN_1)
    903          			| PDB_C1_EN(SRMCATOD_PDB_PRE_TRIGGER_CHN_1);
    904          
    905          	PDB.SC = 		PDB_SC_LDMOD(SRMCATOD_PDB_LD_MOD_SETTING)	// Configures PDB to load after trigger event and LDOK set
    906          			| PDB_SC_PRESCALER(SRMCATOD_PDB_PRESCALER_SETTING)
    907          			| PDB_SC_TRGSEL(SRMCATOD_PDB_TRIGGER_SEL)
    908          			| PDB_SC_MULT(SRMCATOD_PDB_MULT_PRESCALER)
    909          			| PDB_SC_PDBEIE_MASK					// Enables interruption error
    910          			| PDB_SC_PDBEN_MASK;       				// PDB enabled
    911          
    912          	PDB.SC |= PDB_SC_LDOK_MASK;						// PDB load OK
    913          
    914          	Micro__NVICEnableIRQ(PDB_IRQ_CHANNEL, SRMCATOD_INTERRUPT_PDB0_PREEMPTION_PRIORITY,SRMCATOD_PDB0_INTERRUPT_SUB_PRIORITY);
    915          	/* switch the trigger of the ADC to PDB */
    916          	SIM.SOPT7 = 0;
    917          }
    918          
    919          
    920          /**
    921           *  @brief      This function enables conversion interruption for selected engine.
    922           *
    923           *  @param[in]  engine Selected engine may be AD_ENGINE_0 or AD_ENGINE_1
    924           *
    925           */
    926          static void EnableEndOfConversionInteruption(SRMCATOD_CONVERTER_TYPE engine)
    927          {
    928              if (engine == SR_AD_ENGINE_0)
    929              {
    930              	Micro__NVICEnableIRQ(ADC0_IRQ_CHANNEL, SRMCATOD_INTERRUPT_ADC_PREEMPTION_PRIORITY,SRMCATOD_ADC_INTERRUPT_SUB_PRIORITY);
    931              }
    932              else if (engine == SR_AD_ENGINE_1)
    933              {
    934              	Micro__NVICEnableIRQ(ADC1_IRQ_CHANNEL, SRMCATOD_INTERRUPT_ADC_PREEMPTION_PRIORITY,SRMCATOD_ADC_INTERRUPT_SUB_PRIORITY);
    935              }
    936          }
    937          
    938          /**
    939           *  @brief      This function disables conversion interruption for selected engine.
    940           *
    941           *  @param      engine Selected engine may be AD_ENGINE_0 or AD_ENGINE_1
    942           *
    943           */
    944          static void DisableEndOfConversionInteruption(SRMCATOD_CONVERTER_TYPE engine)
    945          {
    946              if (engine == SR_AD_ENGINE_0)
    947              {
    948              	Micro__NVICDisableIRQ(ADC0_IRQ_CHANNEL);			// Disables ADC0 interruption during configuration
    949              }
    950              else if (engine == SR_AD_ENGINE_1)
    951              {
    952              	Micro__NVICDisableIRQ(ADC1_IRQ_CHANNEL);			// Disables ADC0 interruption during configuration
    953              }
    954          }
    955          
    956          
    957          /**
    958           *  @brief      Enable self diagnostic mode
    959           *
    960           *  @details    This function is used to enable/disable self check hardware for converter and register integrity.
    961           *              Drives to VREFH0, (VREFH0 x 1/2) and (VREFH0 x 0)
    962           *
    963           *  @param[in]  engine Defines which converter will be configured: AD_ENGINE_0 or AD_ENGINE_1
    964           *  @param[in]  mode Defines configuration mode:
    965           *              SELF_TEST_DISABLED,SELF_TEST_VREFH0_SCALE_0,SELF_TEST_VREFH0_SCALE_0_5,SELF_TEST_VREFH0_SCALE_1, AUTOMATED_SELF_TEST
    966           *
    967           */
    968          static void SREnableSelfDiagMode(SRMCATOD_CONVERTER_TYPE engine, SRMCATOD_DIAG_CONFIG_TYPE mode)
    969          {
    970          	if (engine == SR_AD_ENGINE_0)                  	// Configuration for S12AD0
    971          	{
    972          		switch (mode)                            	// Mode for self check
    973          		{
    974          			case SR_MCATOD_SELF_TEST_DISABLED:
    975          
    976          				ADC0.ADC_SC1[0] = ADC_SC1_ADCH(SRMCATOD_ADC0_FIRST_SAMPLE_CHN);
    977          				ADC0.ADC_SC1[1] = ADC_SC1_ADCH(SRMCATOD_ADC0_SECOND_SAMPLE_CHN);
    978          				break;
    979          
    980          			case SR_MCATOD_SELF_TEST_VREFH0_SCALE_0:
    981          				ADC0.ADC_SC1[0] = ADC_SC1_ADCH(SRMCATOD_ADC_VREF_LOW);
    982          				ADC0.ADC_SC1[1] = ADC_SC1_ADCH(SRMCATOD_ADC_VREF_LOW);
    983          
    984          				break;
    985          
    986          			case SR_MCATOD_SELF_TEST_VREFH0_SCALE_0_5:
    987          
    988          				ADC0.ADC_SC1[0] = ADC_SC1_ADCH(SRMCATOD_ADC0_VREF_INTERMEDIATE);
    989          				ADC0.ADC_SC1[1] = ADC_SC1_ADCH(SRMCATOD_ADC0_VREF_INTERMEDIATE);
    990          				break;
    991          
    992          			case SR_MCATOD_SELF_TEST_VREFH0_SCALE_1:
    993          
    994          				ADC0.ADC_SC1[0] = ADC_SC1_ADCH(SRMCATOD_ADC_VREF_HIGH);
    995          				ADC0.ADC_SC1[1] = ADC_SC1_ADCH(SRMCATOD_ADC_VREF_HIGH);
    996          				break;
    997          
    998          			case SR_MCATOD_AUTOMATED_SELF_TEST:
    999          
   1000          				SRInitializeAD0();					// Performs self calibration routine and initializes converter configuration
   1001          				break;
   1002          
   1003          			default:                                // In case it's not properly defined
   1004          
   1005          				SRInitializeAD0();					// Initializes converter configuration
   1006          				break;
   1007          		}
   1008          	}                                               // Uploads mirror data
   1009          	else if (engine == SR_AD_ENGINE_1)             	// Configuration for S12AD0
   1010          	{
   1011          		switch (mode)                               // Mode for self check
   1012          		{
   1013          			case SR_MCATOD_SELF_TEST_DISABLED:
   1014          
   1015          			    ADC1.ADC_SC1[0] = ADC_SC1_ADCH(SRMCATOD_ADC1_FIRST_SAMPLE_CHN);
   1016          			    ADC1.ADC_SC1[1] = ADC_SC1_ADCH(SRMCATOD_ADC1_SECOND_SAMPLE_CHN) | ADC_SC1_AIEN_MASK;
   1017          				break;
   1018          
   1019          			case SR_MCATOD_SELF_TEST_VREFH0_SCALE_0:
   1020          
   1021          				ADC1.ADC_SC1[0] = ADC_SC1_ADCH(SRMCATOD_ADC_VREF_LOW);
   1022          				ADC1.ADC_SC1[1] = ADC_SC1_ADCH(SRMCATOD_ADC_VREF_LOW) | ADC_SC1_AIEN_MASK;
   1023          				break;
   1024          
   1025          			case SR_MCATOD_SELF_TEST_VREFH0_SCALE_0_5:
   1026          
   1027          				ADC1.ADC_SC1[0] = ADC_SC1_ADCH(SRMCATOD_ADC1_VREF_INTERMEDIATE);
   1028          				ADC1.ADC_SC1[1] = ADC_SC1_ADCH(SRMCATOD_ADC1_VREF_INTERMEDIATE) | ADC_SC1_AIEN_MASK;
   1029          				break;
   1030          
   1031          			case SR_MCATOD_SELF_TEST_VREFH0_SCALE_1:
   1032          
   1033          				ADC1.ADC_SC1[0] = ADC_SC1_ADCH(SRMCATOD_ADC_VREF_HIGH);
   1034          				ADC1.ADC_SC1[1] = ADC_SC1_ADCH(SRMCATOD_ADC_VREF_HIGH) | ADC_SC1_AIEN_MASK;
   1035          				break;
   1036          
   1037          			case SR_MCATOD_AUTOMATED_SELF_TEST:
   1038          
   1039          				SRInitializeAD1();					// Performs self calibration routine and initializes converter configuration
   1040          				break;
   1041          
   1042          			default:                                // In case it's not properly defined
   1043          
   1044          				SRInitializeAD1();					// Performs self calibration routine and initializes converter configuration
   1045          				break;
   1046          		}
   1047              }
   1048          }
   1049          
   1050          /**
   1051           *  @brief      Detect if the peripheral is in safe status
   1052           *
   1053           *  @details    This function is used to check register and converter status.
   1054           *              May be used to test stuck at register failure and conversion errors.
   1055           *
   1056           *  @param[in]  engine defines which engine will be tested
   1057           *  @param[in]  threshold allows adjustable error for 1/2 VREFH0 conversion
   1058           *  @param[in]  mode The test mode that we need to check:
   1059           *              SELF_TEST_DISABLED,SELF_TEST_VREFH0_SCALE_0,SELF_TEST_VREFH0_SCALE_0_5,SELF_TEST_VREFH0_SCALE_1, AUTOMATED_SELF_TEST
   1060           *
   1061           *  @return     returns if peripheral test result TEST_NOT_PERFORMED, REGISTER_BIT_STUCK_AT_0,
   1062           *              REGISTER_BIT_STUCK_AT_1, CONVERTER_ERROR or PERIPHERAL_SAFE
   1063           */
   1064          static SRMCATOD_DIAG_ERROR_TYPE IsConverterSafe(SRMCATOD_CONVERTER_TYPE engine,sint16 local_threshold, SRMCATOD_DIAG_CONFIG_TYPE mode)
   1065          {
   1066              SRMCATOD_DIAG_ERROR_TYPE status;                // returns test result
   1067              sint16 temp;                        	// Gets converted result for check
   1068              sint16 temp_a;                        // Gets converted result for check
   1069              sint16 temp_b;                        // Gets converted result for check
   1070          
   1071              temp_a = 0;
   1072              temp_b = 0;
   1073          
   1074              if (engine == SR_AD_ENGINE_0)                   // Configuration for testing ADC0
   1075              {
   1076                  // Get data
   1077              	temp_a = SRMCATOD__ADC0_RA();
   1078              	temp_b = SRMCATOD__ADC0_RB();
   1079              }
   1080              else if (engine == SR_AD_ENGINE_1)              // Configuration for testing ADC1
   1081              {
   1082                  // Get data
   1083              	temp_a = SRMCATOD__ADC1_RA();
   1084              	temp_b = SRMCATOD__ADC1_RB();
   1085              }
   1086              switch (mode)                                   // Now it's all set for checking data according to test mode
   1087              {
   1088                  case SR_MCATOD_SELF_TEST_DISABLED:                 // If it wasn't tested
   1089                      status = SR_MCATOD_ERROR_TEST_NOT_PERFORMED;         // It's not possible to return peripheral is safe
   1090                      break;
   1091          
   1092                  case SR_MCATOD_SELF_TEST_VREFH0_SCALE_0:           // If connected to minimum reference
   1093                      status = SR_MCATOD_ERROR_REGISTER_BIT_STUCK_AT_1;    // Possible fault is bit stuck at 1
   1094                      temp = temp_a | temp_b;
   1095          
   1096                      if (temp <= ((sint16)(SR_MCATOD_MINIMUM_12BITS_AD_VALUE) + local_threshold))
   1097                      {                                       // Expected data on register is found
   1098                          status = SR_MCATOD_ERROR_PERIPHERAL_SAFE;        // Peripheral doesn't show this failure mode
   1099                      }
   1100                      break;
   1101          
   1102                  case SR_MCATOD_SELF_TEST_VREFH0_SCALE_0_5:         // If connected to half maximum value
   1103                      status = SR_MCATOD_ERROR_CONVERTER_ERROR;            // Possible fault is erroneous conversion
   1104                      temp = (temp_a + temp_b) >> 1;
   1105          
   1106                      if ((temp >= ((sint16)(SR_MCATOD_HALF_RANGE_12BITS_AD_VALUE) - local_threshold)) &&
   1107                          (temp <= ((sint16)(SR_MCATOD_HALF_RANGE_12BITS_AD_VALUE) + local_threshold)))
   1108                      {                                       // Expected data on register is found
   1109                          status = SR_MCATOD_ERROR_PERIPHERAL_SAFE;        // Peripheral doesn't show this failure mode
   1110                      }
   1111                      break;
   1112          
   1113                  case SR_MCATOD_SELF_TEST_VREFH0_SCALE_1:           // If connected to maximum value
   1114                      status = SR_MCATOD_ERROR_REGISTER_BIT_STUCK_AT_0;    // Possible fault is bit stuck at 0
   1115                      temp = temp_a & temp_b;
   1116          
   1117                      if (temp >= ((sint16)(SR_MCATOD_MAXIMUM_12BITS_AD_VALUE) - local_threshold))
   1118                      {                                       // Expected data on register is found
   1119                          status = SR_MCATOD_ERROR_PERIPHERAL_SAFE;        // Peripheral doesn't show this failure mode
   1120                      }
   1121                      break;
   1122          
   1123                  default:
   1124                      status = SR_MCATOD_ERROR_TEST_NOT_PERFORMED;         // It's not possible to return peripheral is safe
   1125                      break;
   1126              }
   1127          
   1128              return (status);                                // Returns status
   1129          }
C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Driver\SRMCPwm\SRMCPwm.c
      1          /**
      2           *  @defgroup   CLASS_B
      3           *  @file       SRMCPwm.c
      4           *  @brief      Motor Control PWM driver
      5           *
      6           *  @details    Motor control PWM initializer, control functions, and ISR
      7           *
      8           *---------------------------------------------------------------------------------------------------------------------
      9           *------------------- Copyright 2012.  Whirlpool Corporation.  All rights reserved - CONFIDENTIAL ---------------------
     10           *---------------------------------------------------------------------------------------------------------------------
     11          */
     12          
     13          //-------------------------------------- Include Files ----------------------------------------------------------------
     14          #include "SRMCPwm.h"
     15          #include "SRMicro.h"
     16          #include "SRData.h"
     17          #include "SRException.h"
     18          #include "Comparator.h"
     19          
     20          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     21          
     22          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     23          
     24          #ifndef SR_PWM_ENABLE_IRQ
     25              #define SR_PWM_ENABLE_IRQ                         0
     26          #endif
     27          
     28          #ifndef SR_PWM_DELAY_ENABLE
     29              #define SR_PWM_DELAY_ENABLE                       0
     30          #endif
     31          
     32          // Configuration constants
     33          #define MILLION         1000000.0f
     34          #define BILLION         1000000000.0f
     35          
     36          typedef enum
     37          {
     38              PWM_MOTOR_DRIVER_IDLE,
     39              PWM_MOTOR_DRIVER_STARTED,
     40              PWM_MOTOR_DRIVER_DEVICES_OFF,
     41              PWM_MOTOR_DRIVER_ACTIVE,
     42              PWM_MOTOR_DRIVER_LOWERS_ON,
     43              PWM_MOTOR_DRIVER_UPPERS_ON
     44          } PWM_DRIVE_STATE_TYPE;
     45          
     46          static uint16 MaxPwm;
     47          static uint16 PwmFrequency;
     48          static uint16 DeadTimeNanosec;
     49          
     50          
     51          //-------------------------------------- Safety Relevant Variables ------------------------------------------------
     52          
     53          // All variables declared in this module are considered critical (SR) and have one negated copy shadow (NSR).
     54          // All variables are also declared as static, since its visibility must be blocked at compiling time.
     55          
     56          static SRMCPWM_DIAG_STATE_TYPE SR_MCPwm_Diag_State;     //!< Contains the current state where the state machine is located and running specific tasks.
     57          static uint32 SR_MCPwm_Zero_Timeout;             //!< Contains time to wait when the overcurrent comparator is configured with the low threshold (SR_PWM_FAULT_0_CMP_LEV_TEST). Once the time is over, the peripheral fault state is read, and the active polarity is expected.
     58          static uint32 SR_MCPwm_One_Timeout;              //!< Contains time to wait when the overcurrent comparator is configured with the high, normal threshold (SR_PWM_FAULT_0_CMP_LEV). Once the time is over, the peripheral fault state is read, and the default polarity is expected.
     59          static SRMCPWM_DIAG_ERROR_TYPE SR_MCPwm_Errors;              //!< At each state of the handler, the state machine searches for a failure in the hardware, once the fault is found, then a bit is set in this variable. The error are listed in bitwise method. The bit description is listed in the SRMCPWM_DIAG_ERROR_TYPE definition.
     60          static uint32 SR_MCPwm_Pulse_Active_Level;   //!< Contains the longest pulse measurement, when the shut down pin is read as active. This variable is used in the 250us polling.
     61          static uint32 SR_MCPwm_Pulse_Default_Level;  //!< Contains the time that the shut down pin is considered inactive while running the SRMCPwm diagnostic state machine handler. This variable is used in the PWM period polling.
     62          
     63          
     64          static SRMCPWM_DIAG_STATE_TYPE NSR_MCPwm_Diag_State;
     65          static uint32 NSR_MCPwm_Zero_Timeout;
     66          static uint32 NSR_MCPwm_One_Timeout;
     67          static SRMCPWM_DIAG_ERROR_TYPE NSR_MCPwm_Errors;
     68          static uint32 NSR_MCPwm_Pulse_Active_Level;
     69          static uint32 NSR_MCPwm_Pulse_Default_Level;
     70          
     71          
     72          #if(SR_PWM_DELAY_ENABLE == 1)
     73          static uint16 SR_Pwm_A_1;
     74          static uint16 SR_Pwm_B_1;
     75          static uint16 SR_Pwm_C_1;
     76          
     77          static uint16 NSR_Pwm_A_1;
     78          static uint16 NSR_Pwm_B_1;
     79          static uint16 NSR_Pwm_C_1;
     80          #endif
     81          
     82          
     83          //-------------------------------------- Definitions ------------------------------------------------
     84          
     85          #define PWM_OUTPUT_OFF()			{FTM0.OUTMASK |= (FTM_OUTMASK_CH5OM_MASK | FTM_OUTMASK_CH4OM_MASK |FTM_OUTMASK_CH3OM_MASK | FTM_OUTMASK_CH2OM_MASK |FTM_OUTMASK_CH1OM_MASK | FTM_OUTMASK_CH0OM_MASK);}	// all outputs disabled (at inactive level)
     86          #define PWM_OUTPUT_ON()				{FTM0.OUTMASK &= ~(FTM_OUTMASK_CH5OM_MASK | FTM_OUTMASK_CH4OM_MASK |FTM_OUTMASK_CH3OM_MASK | FTM_OUTMASK_CH2OM_MASK |FTM_OUTMASK_CH1OM_MASK | FTM_OUTMASK_CH0OM_MASK);}	// all outputs enable (at active level)
     87          #define PWM_TIMER_START()			{FTM0.MODE |= FTM_MODE_WPDIS_MASK; FTM0.SC |= FTM_SC_CLKS(1);FTM0.FMS |= FTM_FMS_WPEN_MASK;} //Not functional
     88          #define PWM_TIMER_STOP()			{FTM0.MODE |= FTM_MODE_WPDIS_MASK; FTM0.SC |= FTM_SC_CLKS(0);FTM0.FMS |= FTM_FMS_WPEN_MASK;} //Not functional
     89          
     90          //---------------------------------------- Macros -----------------------------------------------------
     91          
     92          #if(1)
     93          // CHECK Macro defs
     94          //lint -emacro( 928, SR_MCPWM_CHECK_DIAG_STATE )
     95          #define SR_MCPWM_CHECK_DIAG_STATE()                         SRData__CheckByte((uint8 *)&SR_MCPwm_Diag_State, (uint8 *)&NSR_MCPwm_Diag_State)
     96          //lint -emacro( 929, SR_MCPWM_CHECK_ZERO_TIMEOUT )
     97          #define SR_MCPWM_CHECK_ZERO_TIMEOUT()                       SRData__CheckLong((uint32 *)&SR_MCPwm_Zero_Timeout, (uint32 *)&NSR_MCPwm_Zero_Timeout)
     98          //lint -emacro( 929, SR_MCPWM_CHECK_ONE_TIMEOUT )
     99          #define SR_MCPWM_CHECK_ONE_TIMEOUT()                        SRData__CheckLong((uint32 *)&SR_MCPwm_One_Timeout, (uint32 *)&NSR_MCPwm_One_Timeout)
    100          //lint -emacro( 928, SR_MCPWM_CHECK_ERRORS )
    101          #define SR_MCPWM_CHECK_ERRORS()                             SRData__CheckByte((uint8 *)&SR_MCPwm_Errors, (uint8 *)&NSR_MCPwm_Errors)
    102          //lint -emacro( 929, SR_MCPWM_CHECK_MAX_PULSE_DURATION )
    103          #define SR_MCPWM_CHECK_MAX_PULSE_DURATION()                 SRData__CheckShort((uint16 *)&SR_MCPwm_Max_Pulse_Duration, (uint16 *)&NSR_MCPwm_Max_Pulse_Duration)
    104          //lint -emacro( 929, SR_MCPWM_CHECK_TMP_PULSE_DURATION )
    105          #define SR_MCPWM_CHECK_TMP_PULSE_DURATION()                 SRData__CheckLong((uint32 *)&SR_MCPwm_Tmp_Pulse_Duration, (uint32 *)&NSR_MCPwm_Tmp_Pulse_Duration)
    106          //lint -emacro( 929, SR_MCPWM_CHECK_ACTIVE_PULSE_DURATION )
    107          #define SR_MCPWM_CHECK_ACTIVE_PULSE_DURATION()              SRData__CheckLong((uint32 *)&SR_MCPwm_Pulse_Active_Level, (uint32 *)&NSR_MCPwm_Pulse_Active_Level)
    108          //lint -emacro( 929, SR_MCPWM_CHECK_DEFAULT_PULSE_DURATION )
    109          #define SR_MCPWM_CHECK_DEFAULT_PULSE_DURATION()             SRData__CheckLong((uint32 *)&SR_MCPwm_Pulse_Default_Level, (uint32 *)&NSR_MCPwm_Pulse_Default_Level)
    110          
    111          #if(SR_PWM_DELAY_ENABLE == 1)
    112          //lint -emacro( 929, SR_MCPWM_CHECK_DUTY_A_DELAYED )
    113          #define SR_MCPWM_CHECK_DUTY_A_DELAYED()                     SRData__CheckShort((uint16 *)&SR_Pwm_A_1, (uint16 *)&NSR_Pwm_A_1)
    114          //lint -emacro( 929, SR_MCPWM_CHECK_DUTY_B_DELAYED )
    115          #define SR_MCPWM_CHECK_DUTY_B_DELAYED()                     SRData__CheckShort((uint16 *)&SR_Pwm_B_1, (uint16 *)&NSR_Pwm_B_1)
    116          //lint -emacro( 929, SR_MCPWM_CHECK_DUTY_C_DELAYED )
    117          #define SR_MCPWM_CHECK_DUTY_C_DELAYED()                     SRData__CheckShort((uint16 *)&SR_Pwm_C_1, (uint16 *)&NSR_Pwm_C_1)
    118          #endif
    119          
    120          // UPDATE Macro defs
    121          //lint -emacro( 928, SR_MCPWM_UPDATE_DIAG_STATE )
    122          #define SR_MCPWM_UPDATE_DIAG_STATE(value)                   SRData__UpdateByte((uint8 *)&SR_MCPwm_Diag_State, (uint8 *)&NSR_MCPwm_Diag_State, (uint8)(value))
    123          //lint -emacro( 929, SR_MCPWM_UPDATE_ZERO_TIMEOUT )
    124          #define SR_MCPWM_UPDATE_ZERO_TIMEOUT(value)                 SRData__UpdateLong((uint32 *)&SR_MCPwm_Zero_Timeout, (uint32 *)&NSR_MCPwm_Zero_Timeout, (uint32)(value))
    125          //lint -emacro( 929, SR_MCPWM_UPDATE_ONE_TIMEOUT )
    126          #define SR_MCPWM_UPDATE_ONE_TIMEOUT(value)                  SRData__UpdateLong((uint32 *)&SR_MCPwm_One_Timeout, (uint32 *)&NSR_MCPwm_One_Timeout, (uint32)(value))
    127          //lint -emacro( 928, SR_MCPWM_UPDATE_ERRORS )
    128          #define SR_MCPWM_UPDATE_ERRORS(value)                       SRData__UpdateByte((uint8 *)&SR_MCPwm_Errors, (uint8 *)&NSR_MCPwm_Errors, (uint8)(value))
    129          //lint -emacro( 929, SR_MCPWM_UPDATE_ACTIVE_PULSE_DURATION )
    130          #define SR_MCPWM_UPDATE_ACTIVE_PULSE_DURATION(value)        SRData__UpdateLong((uint32 *)&SR_MCPwm_Pulse_Active_Level, (uint32 *)&NSR_MCPwm_Pulse_Active_Level, (uint32)(value))
    131          //lint -emacro( 929, SR_MCPWM_UPDATE_DEFAULT_PULSE_DURATION )
    132          #define SR_MCPWM_UPDATE_DEFAULT_PULSE_DURATION(value)       SRData__UpdateLong((uint32 *)&SR_MCPwm_Pulse_Default_Level, (uint32 *)&NSR_MCPwm_Pulse_Default_Level, (uint32)(value))
    133          
    134          #if(SR_PWM_DELAY_ENABLE == 1)
    135          //lint -emacro( 929, SR_MCPWM_UPDATE_DUTY_A_DELAYED )
    136          #define SR_MCPWM_UPDATE_DUTY_A_DELAYED(value)               SRData__UpdateShort((uint16 *)&SR_Pwm_A_1, (uint16 *)&NSR_Pwm_A_1, (uint16)(value))
    137          //lint -emacro( 929, SR_MCPWM_UPDATE_DUTY_B_DELAYED )
    138          #define SR_MCPWM_UPDATE_DUTY_B_DELAYED(value)               SRData__UpdateShort((uint16 *)&SR_Pwm_B_1, (uint16 *)&NSR_Pwm_B_1, (uint16)(value))
    139          //lint -emacro( 929, SR_MCPWM_UPDATE_DUTY_C_DELAYED )
    140          #define SR_MCPWM_UPDATE_DUTY_C_DELAYED(value)               SRData__UpdateShort((uint16 *)&SR_Pwm_C_1, (uint16 *)&NSR_Pwm_C_1, (uint16)(value))
    141          #endif
    142          
    143          #else
    144          // CHECK Macro defs
    145          #define SR_MCPWM_CHECK_DIAG_STATE()                         SRDATA_OK // SR_MCPwm_Diag_State
    146          #define SR_MCPWM_CHECK_ZERO_TIMEOUT()                       SRDATA_OK // SR_MCPwm_Zero_Timeout
    147          #define SR_MCPWM_CHECK_ONE_TIMEOUT()                        SRDATA_OK // SR_MCPwm_One_Timeout
    148          #define SR_MCPWM_CHECK_ERRORS()                             SRDATA_OK // SR_MCPwm_Errors
    149          #define SR_MCPWM_CHECK_MAX_PULSE_DURATION()                 SRDATA_OK // SR_MCPwm_Max_Pulse_Duration
    150          #define SR_MCPWM_CHECK_TMP_PULSE_DURATION()                 SRDATA_OK // SR_MCPwm_Tmp_Pulse_Duration
    151          #define SR_MCPWM_CHECK_ACTIVE_PULSE_DURATION()              SRDATA_OK // SR_MCPwm_Pulse_Active_Level
    152          #define SR_MCPWM_CHECK_DEFAULT_PULSE_DURATION()             SRDATA_OK // SR_MCPwm_Pulse_Active_Level
    153          
    154          // UPDATE Macro defs
    155          #define SR_MCPWM_UPDATE_DIAG_STATE(value)                   SR_MCPwm_Diag_State = (value)
    156          #define SR_MCPWM_UPDATE_ZERO_TIMEOUT(value)                 SR_MCPwm_Zero_Timeout = (value)
    157          #define SR_MCPWM_UPDATE_ONE_TIMEOUT(value)                  SR_MCPwm_One_Timeout = (value)
    158          #define SR_MCPWM_UPDATE_ERRORS(value)                       SR_MCPwm_Errors = (value)
    159          #define SR_MCPWM_UPDATE_MAX_PULSE_DURATION(value)           SR_MCPwm_Max_Pulse_Duration = (value)
    160          #define SR_MCPWM_UPDATE_TMP_PULSE_DURATION(value)           SR_MCPwm_Tmp_Pulse_Duration = (value)
    161          #define SR_MCPWM_UPDATE_ACTIVE_PULSE_DURATION(value)        SR_MCPwm_Pulse_Active_Level = (value)
    162          #define SR_MCPWM_UPDATE_DEFAULT_PULSE_DURATION(value)       SR_MCPwm_Pulse_Default_Level = (value)
    163          
    164          #endif
    165          
    166          //-------------------------------------- PRIVATE Function Prototypes ------------------------------------------------
    167          static BOOL_TYPE GetFaultState(void);
    168          static BOOL_TYPE GetFaultFlagState(void);
    169          static void ClearFaultFlag(void);
    170          //=====================================================================================================================
    171          //-------------------------------------- Public Functions -------------------------------------------------------------
    172          //=====================================================================================================================
    173          
    174          
    175          /*
    176           * @brief       Initialize the inverter outputs before booting the class B - enable all lowers switches
    177           * @details     According to the memory size, the microcontroller may take long time to power up, in the case of
    178           *              a reset and according to the physics of the motor, some side effects shall happen to the
    179           *              system. E.g., very high DC bus voltage and breaks the electronic. Therefore, it requires
    180           *              to disconnect motor from the dc bus capacitors by enabled lowers switches.
    181           */

   \                                 In section .text, align 2, keep-with-next
    182          void SRMCPwm__Initialize_Before_Boot(void)
    183          {
    184              SIM.SCGC5 |= (SIM_SCGC5_PORTA_MASK |            // Connect the GPIOA device to the Core bus
    185                           SIM_SCGC5_PORTB_MASK  |            // Connect the GPIOB device to the Core bus
    186                           SIM_SCGC5_PORTC_MASK  |            // Connect the GPIOC device to the Core bus
    187                           SIM_SCGC5_PORTD_MASK  |            // Connect the GPIOD device to the Core bus
    188                           SIM_SCGC5_PORTE_MASK);             // Connect the GPIOE device to the Core bus
   \                     SRMCPwm__Initialize_Before_Boot: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable167_2  ;; 0x40048038
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF441 0x5178      ORR      R1,R1,#0x3E00
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    189          
    190          
    191          
    192          
    193              // Initialize the output state
    194          #if SR_PWM_HIGH_CHANNELS_ACTIVE_LEVEL == 1 // High level activated
    195          
    196              #if (SR_PWM__REMAP == 0)
    197          
    198                  // Zero all upper switches
    199                  GPIOC.PCOR = (1<<0);
    200                  GPIOC.PCOR = (1<<2);
    201                  GPIOC.PCOR = (1<<4);
    202          
    203              #elif(SR_PWM__REMAP == 1)
    204          
    205                  // Zero all upper switches
    206                  GPIOD.PCOR = (1<<0);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable167_3  ;; 0x400ff0c4
   \   00000012   0x6041             STR      R1,[R0, #+4]
   \   00000014   0xF44F 0x7280      MOV      R2,#+256
    207                  GPIOD.PCOR = (1<<2);
   \   00000018   0x2104             MOVS     R1,#+4
   \   0000001A   0x6041             STR      R1,[R0, #+4]
    208                  GPIOD.PCOR = (1<<4);
   \   0000001C   0x2110             MOVS     R1,#+16
   \   0000001E   0x6041             STR      R1,[R0, #+4]
    209          
    210              #endif
    211          
    212          #elif SR_PWM_HIGH_CHANNELS_ACTIVE_LEVEL == 0 // Low level activated
    213          
    214              #if (SR_PWM__REMAP == 0)
    215          
    216                  // One all upper switches
    217                  GPIOC.PSOR = (1<<0);
    218                  GPIOC.PSOR = (1<<2);
    219                  GPIOC.PSOR = (1<<4);
    220          
    221              #elif(SR_PWM__REMAP == 1)
    222          
    223                  // One all upper switches
    224                  GPIOD.PSOR = (1<<0);
    225                  GPIOD.PSOR = (1<<2);
    226                  GPIOD.PSOR = (1<<4);
    227          
    228              #endif
    229          
    230          #else
    231          
    232              #error High power switch driver polarity not defined
    233          
    234          #endif
    235          
    236          
    237          #if SR_PWM_LOW_CHANNELS_ACTIVE_LEVEL == 1 // High level activated
    238          
    239              #if(SR_PWM__REMAP == 0)
    240          
    241                  GPIOC.PSOR = (1<<1);
    242                  GPIOC.PSOR = (1<<3);
    243                  GPIOC.PSOR = (1<<5);
    244          
    245              #elif(SR_PWM__REMAP == 1)
    246          
    247                  GPIOD.PSOR = (1<<1);
   \   00000020   0x2102             MOVS     R1,#+2
   \   00000022   0x6001             STR      R1,[R0, #+0]
    248                  GPIOD.PSOR = (1<<3);
   \   00000024   0x2108             MOVS     R1,#+8
   \   00000026   0x6001             STR      R1,[R0, #+0]
    249                  GPIOD.PSOR = (1<<5);
   \   00000028   0x2120             MOVS     R1,#+32
   \   0000002A   0x6001             STR      R1,[R0, #+0]
    250          
    251              #endif
    252          
    253          #elif SR_PWM_LOW_CHANNELS_ACTIVE_LEVEL == 0 // Low level activated
    254          
    255              #if(SR_PWM__REMAP == 0)
    256          
    257                  GPIOC.PCOR = (1<<1);
    258                  GPIOC.PCOR = (1<<3);
    259                  GPIOC.PCOR = (1<<5);
    260          
    261              #elif(SR_PWM__REMAP == 1)
    262          
    263                  GPIOD.PCOR = (1<<1);
    264                  GPIOD.PCOR = (1<<3);
    265                  GPIOD.PCOR = (1<<5);
    266          
    267              #endif
    268          
    269          #else
    270          
    271              #error High power switch driver polarity not defined
    272          
    273          #endif
    274          
    275          
    276          
    277          
    278              // Initilize the gpio as output push pull
    279          #if(SR_PWM__REMAP == 0)
    280          
    281              GPIOC.PDDR |= (1 << 0);
    282              PCIPORTC.PCR[0] = (PORT_PCR_MUX(1));
    283          
    284              GPIOC.PDDR |= (1 << 1);
    285              PCIPORTC.PCR[1] = (PORT_PCR_MUX(1));
    286          
    287              GPIOC.PDDR |= (1 << 2);
    288              PCIPORTC.PCR[2] = (PORT_PCR_MUX(1));
    289          
    290              GPIOC.PDDR |= (1 << 3);
    291              PCIPORTC.PCR[3] = (PORT_PCR_MUX(1));
    292          
    293              GPIOC.PDDR |= (1 << 4);
    294              PCIPORTC.PCR[4] = (PORT_PCR_MUX(1));
    295          
    296              GPIOC.PDDR |= (1 << 5);
    297              PCIPORTC.PCR[5] = (PORT_PCR_MUX(1));
    298          
    299          #elif(SR_PWM__REMAP == 1)
    300          
    301              GPIOD.PDDR |= (1 << 0);
   \   0000002C   0x6901             LDR      R1,[R0, #+16]
   \   0000002E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000032   0x6101             STR      R1,[R0, #+16]
    302              PCIPORTD.PCR[0] = (PORT_PCR_MUX(1));
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable167_4  ;; 0x4004c000
   \   00000038   0x600A             STR      R2,[R1, #+0]
    303          
    304              GPIOD.PDDR |= (1 << 1);
   \   0000003A   0x6903             LDR      R3,[R0, #+16]
   \   0000003C   0xF043 0x0302      ORR      R3,R3,#0x2
   \   00000040   0x6103             STR      R3,[R0, #+16]
    305              PCIPORTD.PCR[1] = (PORT_PCR_MUX(1));
   \   00000042   0x604A             STR      R2,[R1, #+4]
    306          
    307              GPIOD.PDDR |= (1 << 2);
   \   00000044   0x6903             LDR      R3,[R0, #+16]
   \   00000046   0xF043 0x0304      ORR      R3,R3,#0x4
   \   0000004A   0x6103             STR      R3,[R0, #+16]
    308              PCIPORTD.PCR[2] = (PORT_PCR_MUX(1));
   \   0000004C   0x608A             STR      R2,[R1, #+8]
    309          
    310              GPIOD.PDDR |= (1 << 3);
   \   0000004E   0x6903             LDR      R3,[R0, #+16]
   \   00000050   0xF043 0x0308      ORR      R3,R3,#0x8
   \   00000054   0x6103             STR      R3,[R0, #+16]
    311              PCIPORTD.PCR[3] = (PORT_PCR_MUX(1));
   \   00000056   0x60CA             STR      R2,[R1, #+12]
    312          
    313              GPIOD.PDDR |= (1 << 4);
   \   00000058   0x6903             LDR      R3,[R0, #+16]
   \   0000005A   0xF043 0x0310      ORR      R3,R3,#0x10
   \   0000005E   0x6103             STR      R3,[R0, #+16]
    314              PCIPORTD.PCR[4] = (PORT_PCR_MUX(1));
   \   00000060   0x610A             STR      R2,[R1, #+16]
    315          
    316              GPIOD.PDDR |= (1 << 5);
   \   00000062   0x6903             LDR      R3,[R0, #+16]
   \   00000064   0xF043 0x0320      ORR      R3,R3,#0x20
   \   00000068   0x6103             STR      R3,[R0, #+16]
    317              PCIPORTD.PCR[5] = (PORT_PCR_MUX(1));
   \   0000006A   0x614A             STR      R2,[R1, #+20]
    318          
    319          #endif
    320          
    321          
    322          
    323          
    324              // Refresh the initialized output state
    325          #if SR_PWM_HIGH_CHANNELS_ACTIVE_LEVEL == 1 // High level activated
    326          
    327              #if (SR_PWM__REMAP == 0)
    328          
    329                  // Zero all upper switches
    330                  GPIOC.PCOR = (1<<0);
    331                  GPIOC.PCOR = (1<<2);
    332                  GPIOC.PCOR = (1<<4);
    333          
    334              #elif(SR_PWM__REMAP == 1)
    335          
    336                  // Zero all upper switches
    337                  GPIOD.PCOR = (1<<0);
   \   0000006C   0x2101             MOVS     R1,#+1
   \   0000006E   0x6041             STR      R1,[R0, #+4]
    338                  GPIOD.PCOR = (1<<2);
   \   00000070   0x2104             MOVS     R1,#+4
   \   00000072   0x6041             STR      R1,[R0, #+4]
    339                  GPIOD.PCOR = (1<<4);
   \   00000074   0x2110             MOVS     R1,#+16
   \   00000076   0x6041             STR      R1,[R0, #+4]
    340          
    341              #endif
    342          
    343          #elif SR_PWM_HIGH_CHANNELS_ACTIVE_LEVEL == 0 // Low level activated
    344          
    345              #if (SR_PWM__REMAP == 0)
    346          
    347                  // One all upper switches
    348                  GPIOC.PSOR = (1<<0);
    349                  GPIOC.PSOR = (1<<2);
    350                  GPIOC.PSOR = (1<<4);
    351          
    352              #elif(SR_PWM__REMAP == 1)
    353          
    354                  // One all upper switches
    355                  GPIOD.PSOR = (1<<0);
    356                  GPIOD.PSOR = (1<<2);
    357                  GPIOD.PSOR = (1<<4);
    358          
    359              #endif
    360          
    361          #else
    362          
    363              #error High power switch driver polarity not defined
    364          
    365          #endif
    366          
    367          
    368          #if SR_PWM_LOW_CHANNELS_ACTIVE_LEVEL == 1 // High level activated
    369          
    370              #if(SR_PWM__REMAP == 0)
    371          
    372                  GPIOC.PSOR = (1<<1);
    373                  GPIOC.PSOR = (1<<3);
    374                  GPIOC.PSOR = (1<<5);
    375          
    376              #elif(SR_PWM__REMAP == 1)
    377          
    378                  GPIOD.PSOR = (1<<1);
   \   00000078   0x2102             MOVS     R1,#+2
   \   0000007A   0x6001             STR      R1,[R0, #+0]
    379                  GPIOD.PSOR = (1<<3);
   \   0000007C   0x2108             MOVS     R1,#+8
   \   0000007E   0x6001             STR      R1,[R0, #+0]
    380                  GPIOD.PSOR = (1<<5);
   \   00000080   0x2120             MOVS     R1,#+32
   \   00000082   0x6001             STR      R1,[R0, #+0]
    381          
    382              #endif
    383          
    384          #elif SR_PWM_LOW_CHANNELS_ACTIVE_LEVEL == 0 // Low level activated
    385          
    386              #if(SR_PWM__REMAP == 0)
    387          
    388                  GPIOC.PCOR = (1<<1);
    389                  GPIOC.PCOR = (1<<3);
    390                  GPIOC.PCOR = (1<<5);
    391          
    392              #elif(SR_PWM__REMAP == 1)
    393          
    394                  GPIOD.PCOR = (1<<1);
    395                  GPIOD.PCOR = (1<<3);
    396                  GPIOD.PCOR = (1<<5);
    397          
    398              #endif
    399          
    400          #else
    401          
    402              #error High power switch driver polarity not defined
    403          
    404          #endif
    405          }
   \   00000084   0x4770             BX       LR               ;; return
    406          
    407          
    408          
    409          
    410          /**
    411           *  @brief       It Initializes the module MCPwm and its variables.
    412           *               FTM0 is selected for PWM outputs
    413           *
    414           *  @param[in]   pwm_frequency defines the PWM frequency in Hz.
    415           *  @param[in]   dead_time_ns defines the dead time inserted between complementary channels. This is defined in nanoseconds.
    416           */

   \                                 In section .text, align 4, keep-with-next
    417          void SRMCPwm__Initialize(uint16 pwm_frequency, uint16 dead_time_ns)
    418          {
   \                     SRMCPwm__Initialize: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB081             SUB      SP,SP,#+4
    419              uint16 deadtime;
    420          	uint16 deadtime_prescaler;
    421              uint16 pwm_period;                               // Local variable for calculation
    422              uint16 fault_enable_mask = 0;
    423           
    424          
    425              SIM.SCGC6 |= SIM_SCGC6_FTM0_MASK;	// Enables the clock for FTM0
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable167_7  ;; 0x4004800c
   \   0000000A   0xED2D 0x8B02      VPUSH    {D8}
   \   0000000E   0xB082             SUB      SP,SP,#+8
   \   00000010   0x4680             MOV      R8,R0
   \   00000012   0x6B20             LDR      R0,[R4, #+48]
   \   00000014   0xF040 0x7080      ORR      R0,R0,#0x1000000
   \   00000018   0x460E             MOV      R6,R1
   \   0000001A   0x6320             STR      R0,[R4, #+48]
    426          
    427          //------------------  Pwm Period & Deadtime Calculation --------------------------
    428              pwm_period = (uint16)(Micro__GetClock()->BUSCLK_Frequency / pwm_frequency);// PWM period in clock events
   \   0000001C   0x.... 0x....      BL       Micro__GetClock
   \   00000020   0x6880             LDR      R0,[R0, #+8]
   \   00000022   0xFBB0 0xF7F8      UDIV     R7,R0,R8
   \   00000026   0xB2BF             UXTH     R7,R7
    429          
    430              //FTM0 deadtime counter it's only 5 bits long, there is a 2-bit pre-scaler that can be set:
    431              //Calculating the pre-scaler value:
    432              deadtime_prescaler = (uint16)(((dead_time_ns*(Micro__GetClock()->BUSCLK_Frequency/MILLION))/63.0f)/(uint32)1000.0f);
   \   00000028   0x.... 0x....      BL       Micro__GetClock
   \   0000002C   0xEE00 0x6A10      VMOV     S0,R6
   \   00000030   0xEEB8 0x8A40      VCVT.F32.U32 S16,S0
   \   00000034   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   00000038   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   0000003C   0xEDDF 0x....      VLDR.W   S1,??DataTable158  ;; 0x49742400
   \   00000040   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000044   0xEE28 0x0A00      VMUL.F32 S0,S16,S0
   \   00000048   0xEDDF 0x....      VLDR.W   S1,??DataTable158_1  ;; 0x427c0000
   \   0000004C   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000050   0xEDDF 0x....      VLDR.W   S1,??DataTable159  ;; 0x447a0000
   \   00000054   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000058   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000005C   0xEE10 0x5A10      VMOV     R5,S0
   \   00000060   0xB2AD             UXTH     R5,R5
    433              //The pre-scaler is found by getting the Count of leading zeros in a 16 bit integer, IAR supports __clz(x) if needed
    434              //FTM0 does not have a divided per 2 pre-scaler, so if we need 1, 3 divides the clock by 16
    435              if (deadtime_prescaler < 4 && deadtime_prescaler > 0)
   \   00000062   0x2D04             CMP      R5,#+4
   \   00000064   0xDA02             BGE.N    ??SRMCPwm__Initialize_0
   \   00000066   0xB115             CBZ.N    R5,??SRMCPwm__Initialize_1
    436              {
    437                  deadtime_prescaler = 2;
   \   00000068   0x2502             MOVS     R5,#+2
   \   0000006A   0xE000             B.N      ??SRMCPwm__Initialize_1
    438              }
    439              else if (deadtime_prescaler >= 4)
    440              {
    441                  deadtime_prescaler = 4;
   \                     ??SRMCPwm__Initialize_0: (+1)
   \   0000006C   0x2504             MOVS     R5,#+4
    442              }
    443              else
    444              {
    445                  deadtime_prescaler = 0;
    446              }
    447          
    448          
    449              deadtime = ((uint16)((dead_time_ns*(Micro__GetClock()->BUSCLK_Frequency/MILLION))/1000.0f)/(1<<deadtime_prescaler));//1<<deadtime_prescaler);
   \                     ??SRMCPwm__Initialize_1: (+1)
   \   0000006E   0x.... 0x....      BL       Micro__GetClock
   \   00000072   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   00000076   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   0000007A   0xEDDF 0x....      VLDR.W   S1,??DataTable158  ;; 0x49742400
   \   0000007E   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000082   0xEE28 0x0A00      VMUL.F32 S0,S16,S0
   \   00000086   0xEDDF 0x....      VLDR.W   S1,??DataTable159  ;; 0x447a0000
   \   0000008A   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   0000008E   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000092   0xEE10 0x0A10      VMOV     R0,S0
   \   00000096   0x2101             MOVS     R1,#+1
   \   00000098   0xB280             UXTH     R0,R0
   \   0000009A   0x40A9             LSLS     R1,R1,R5
   \   0000009C   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000A0   0xB280             UXTH     R0,R0
    450          
    451              if (deadtime > ((1<<6)-1))
   \   000000A2   0x2840             CMP      R0,#+64
   \   000000A4   0xBFA8             IT       GE 
    452              {
    453                  deadtime = ((1<<6)-1);
   \   000000A6   0x203F             MOVGE    R0,#+63
    454              }
    455          
    456              if (deadtime_prescaler < 4)
   \   000000A8   0x2D04             CMP      R5,#+4
   \   000000AA   0xBFBA             ITTE     LT 
    457              {
    458                  deadtime |= (deadtime_prescaler<<6);
   \   000000AC   0xEA40 0x1085      ORRLT    R0,R0,R5, LSL #+6
   \   000000B0   0xB285             UXTHLT   R5,R0
    459              }
    460              else //The pre-scalar value of 3 is a 16 divider on the clock
    461              {
    462                  deadtime |= (3<<6);
   \   000000B2   0xF040 0x05C0      ORRGE    R5,R0,#0xC0
    463              }
    464          
    465              PwmFrequency = pwm_frequency;
   \   000000B6   0x.... 0x....      LDR.W    R9,??DataTable167_8
   \   000000BA   0xF8A9 0x839E      STRH     R8,[R9, #+926]
    466              DeadTimeNanosec = dead_time_ns;
    467              MaxPwm = pwm_period>>1;
   \   000000BE   0x0878             LSRS     R0,R7,#+1
   \   000000C0   0xF8A9 0x63A0      STRH     R6,[R9, #+928]
   \   000000C4   0xF8A9 0x039C      STRH     R0,[R9, #+924]
    468          
    469          
    470          
    471          
    472          //------------------------- Port configuration to force lowers on in case of break ---------------------
    473              //Config_MCPwm_Gpio();
    474          
    475          //------------------  FTM0 Initialization --------------------------
    476          
    477          	MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();	//
    478          	MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();		// Disables interruptions while configuring
   \   000000C8   0xF3EF 0x8810      MRS      R8,PRIMASK
   \   000000CC   0xB672             CPSID    I
    479          	
    480          	// Disable all channels outputs using the OUTPUT MASK feature.
    481          	// However, the output pins are still driven as GPIO since the
    482          	// channel mode is set to FTM channel disabled after RESET
    483          	PWM_OUTPUT_OFF();
   \   000000CE   0x.... 0x....      LDR.W    R6,??DataTable167_9  ;; 0x40038000
   \   000000D2   0x6E31             LDR      R1,[R6, #+96]
   \   000000D4   0xF041 0x013F      ORR      R1,R1,#0x3F
   \   000000D8   0x6631             STR      R1,[R6, #+96]
    484          	
    485          	FTM0.MODE |= FTM_MODE_WPDIS_MASK; 			// Disable write protection for certain registers
    486              FTM0.MODE |= FTM_MODE_FTMEN_MASK; 			// Enables the counter
    487              //FTM0.MODE |= FTM_MODE_FAULTM_MASK;			// Fault control is enabled for all channels, and the selected mode is the automatic fault clearing.
    488              FTM0.MODE |= FTM_MODE_FAULTM(2);          // Fault control is enabled for all channels, and the selected mode is the manual fault clearing.
    489          
    490          //------------------  FTM0 Counter configuration --------------------------
    491          //Set the counter, edge aligned PWM, center-aligned is forced by the way the Duty cycles are set
    492          
    493          	FTM0.MOD = (uint16)((pwm_period>>1)-1);		// Set Modulo register
   \   000000DA   0x1E40             SUBS     R0,R0,#+1
   \   000000DC   0x6D71             LDR      R1,[R6, #+84]
   \   000000DE   0xF041 0x0104      ORR      R1,R1,#0x4
   \   000000E2   0x6571             STR      R1,[R6, #+84]
   \   000000E4   0xB280             UXTH     R0,R0
   \   000000E6   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000EA   0x6571             STR      R1,[R6, #+84]
   \   000000EC   0x60B0             STR      R0,[R6, #+8]
   \   000000EE   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000F2   0x6571             STR      R1,[R6, #+84]
   \   000000F4   0x2301             MOVS     R3,#+1
    494              FTM0.CNTIN = (uint32) (-(sint32)FTM0.MOD-1); 					// Set initial counting value
   \   000000F6   0xF04F 0x31FF      MOV      R1,#-1
   \   000000FA   0x1A08             SUBS     R0,R1,R0
   \   000000FC   0x64F0             STR      R0,[R6, #+76]
   \   000000FE   0x2200             MOVS     R2,#+0
    495          
    496              if (SR_TRANSMIT_AT_CREST)
    497              {
    498                  FTM0.SYNC = FTM_SYNC_CNTMAX_MASK;  	// Pwm loading when FTM counter reaches its maximum value (MOD register).
   \   00000100   0x2002             MOVS     R0,#+2
   \   00000102   0x65B0             STR      R0,[R6, #+88]
   \   00000104   0x2107             MOVS     R1,#+7
    499              }
    500              else
    501              {
    502                  FTM0.SYNC = FTM_SYNC_CNTMIN_MASK; 	// Pwm loading when FTM counter reaches its minimum value (CNTIN register).
    503              }
    504          
    505          
    506              // for center aligned PWM using combine mode:
    507          	//	COMBINE = 1 - combine mode set
    508          	//	COMP = 1 - complementary PWM set
    509          	//	DTEN = 1 - deadtime enabled
    510          	//	SYNCEN = 1 - PWM update synchronization enabled
    511          	//	FAULTEN = 1 - fault control enabled
    512          
    513              FTM0.COMBINE =  FTM_COMBINE_FAULTEN0_MASK | FTM_COMBINE_SYNCEN0_MASK | FTM_COMBINE_DTEN0_MASK
    514                          | FTM_COMBINE_COMP0_MASK    | FTM_COMBINE_COMBINE0_MASK
    515                          | FTM_COMBINE_FAULTEN1_MASK | FTM_COMBINE_SYNCEN1_MASK | FTM_COMBINE_DTEN1_MASK
    516                          | FTM_COMBINE_COMP1_MASK    | FTM_COMBINE_COMBINE1_MASK
    517                          | FTM_COMBINE_FAULTEN2_MASK | FTM_COMBINE_SYNCEN2_MASK | FTM_COMBINE_DTEN2_MASK
    518                          | FTM_COMBINE_COMP2_MASK    | FTM_COMBINE_COMBINE2_MASK;
   \   00000106   0x.... 0x....      LDR.W    R0,??DataTable167_12  ;; 0x737373
   \   0000010A   0x6670             STR      R0,[R6, #+100]
    519          
    520          
    521          
    522          //------------------------- Fault Input configuration ------------------------
    523          #if (SR_PWM_FAULT_0 == ENABLED)
    524              fault_enable_mask |= FTM_FLTCTRL_FAULT0EN_MASK;
    525          
    526          	#if (SR_PWM_FAULT_0_SRC == CMP)
    527          	SIM.SOPT4 |= SIM_SOPT4_FTM0FLT0_MASK;	// Configures the source of FTM0 fault 0 to comparator CMP0 output
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000112   0x6020             STR      R0,[R4, #+0]
    528          	Comparator__Config(SR_COMPARATOR_CHANNEL, SR_COMPARATOR_INVERTED_INPUT, SR_COMPARATOR_NONINVERTED_INPUT, SR_COMPARATOR_MODE, SR_PWM_FAULT_0_CMP_LEV);	 // Conifigures the comparator 0
   \   00000114   0x2023             MOVS     R0,#+35
   \   00000116   0x9000             STR      R0,[SP, #+0]
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0x.... 0x....      BL       Comparator__Config
    529          	#else
    530          	SIM.SOPT4 &= ~SIM_SOPT4_FTM0FLT0_MASK;
    531          	#endif
    532          #endif
    533          
    534          #if (SR_PWM_FAULT_1 == ENABLED)
    535          	fault_enable_mask |= FTM_FLTCTRL_FAULT1EN_MASK;
    536          
    537          	#if (SR_PWM_FAULT_1_SRC == CMP)
    538          	SIM.SOPT4 |= SIM_SOPT4_FTM0FLT1_MASK;  	// Configures the source of FTM0 fault 1 to comparator CMP0 output
    539          	Comparator__Config(SR_COMPARATOR_CHANNEL, SR_COMPARATOR_INVERTED_INPUT, SR_COMPARATOR_NONINVERTED_INPUT, SR_COMPARATOR_MODE, SR_PWM_FAULT_0_CMP_LEV);  // Conifigures the comparator 1
    540          	#else
    541          	SIM.SOPT4 &= ~SIM_SOPT4_FTM0FLT1_MASK;
    542          	#endif
    543          #endif
    544          
    545          #if (SR_PWM_FAULT_2 == ENABLED)
    546          	fault_enable_mask |= FTM_FLTCTRL_FAULT2EN_MASK;
    547          #endif
    548          
    549          #if (SR_PWM_FAULT_3 == ENABLED)
    550          	fault_enable_mask |= FTM_FLTCTRL_FAULT3EN_MASK;
    551          #endif
    552          
    553          	FTM0.FLTCTRL |= fault_enable_mask; 		// Enables the fault inputs
   \   0000011E   0x6FF0             LDR      R0,[R6, #+124]
   \   00000120   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000124   0x67F0             STR      R0,[R6, #+124]
    554          
    555          
    556          
    557          //------------------------- FMT0 Output Polarity configuration ------------------------
    558          	//POL Register set the level of the channel in case of Fault
    559          	//This is considering channel 0,2 and 4 as the high channels
    560          	FTM0.CONTROLS[0].CnSC |= FTM_CnSC_ELSB_MASK ;
    561          	FTM0.CONTROLS[1].CnSC |= FTM_CnSC_ELSB_MASK ;
    562          	FTM0.CONTROLS[2].CnSC |= FTM_CnSC_ELSB_MASK ;
    563          	FTM0.CONTROLS[3].CnSC |= FTM_CnSC_ELSB_MASK ;
    564          	FTM0.CONTROLS[4].CnSC |= FTM_CnSC_ELSB_MASK ;
    565          	FTM0.CONTROLS[5].CnSC |= FTM_CnSC_ELSB_MASK ;
    566          
    567          #if (SR_PWM_HIGH_CHANNELS_ACTIVE_LEVEL == SR_PWM_LOW_CHANNELS_ACTIVE_LEVEL)
    568           #if (SR_PWM_HIGH_CHANNELS_ACTIVE_LEVEL == 1)
    569              FTM0.POL |= 0;									// The channel polarity is active high.
    570           #else
    571              FTM0.POL |= FTM_POL_POL0_MASK | FTM_POL_POL2_MASK | FTM_POL_POL4_MASK | FTM_POL_POL1_MASK | FTM_POL_POL3_MASK | FTM_POL_POL5_MASK;
    572           #endif
    573          #else
    574           #if (SR_PWM_HIGH_CHANNELS_ACTIVE_LEVEL == 1)
    575              FTM0.POL |= FTM_POL_POL1_MASK | FTM_POL_POL3_MASK | FTM_POL_POL5_MASK;
    576           #else
    577              FTM0.POL |= FTM_POL_POL0_MASK | FTM_POL_POL2_MASK | FTM_POL_POL4_MASK;
    578           #endif
    579          #endif
    580          
    581          	FTM0.DEADTIME = deadtime;	 					// Configures the deadtime prescaler factor and deadtime value
    582          
    583          	SRMCPWM__LOADALLPWMVALUES(SRMCPWM__GET_LOWERS_ON_PWM(),SRMCPWM__GET_LOWERS_ON_PWM(),SRMCPWM__GET_LOWERS_ON_PWM()); // Initial setting of value registers to 0 % of duty cycle
    584          
    585          	FTM0.EXTTRIG |= FTM_EXTTRIG_INITTRIGEN_MASK;	// Enables the generation of the trigger when the FTM counter is equal to the CNTIN register, used for starting of the PDB counter
    586          	FTM0.MODE |= FTM_MODE_INIT_MASK;				// Initializes the channels
    587          	FTM0.SC |= FTM_SC_CLKS(1);						// Set system clock as source for FTM0 (CLKS[1:0] = 01)
    588          
    589          
    590          //------------------------- Port for FTM0 configuration ---------------------
    591          // Note: Clock for Port C anc D enabled in sysinit.c already
    592          #if (SR_PWM__REMAP == 0)
    593          	PCIPORTC.PCR[1] = PORT_PCR_MUX(4); 				// FTM0 CH0,PTC1
    594          	PCIPORTC.PCR[2] = PORT_PCR_MUX(4); 				// FTM0 CH1,PTC2
    595          	PCIPORTC.PCR[5] = PORT_PCR_MUX(7); 				// FTM0 CH2,PTC5
    596          	PCIPORTC.PCR[4] = PORT_PCR_MUX(4); 				// FTM0 CH3,PTC4
    597          	PCIPORTD.PCR[4] = PORT_PCR_MUX(4); 				// FTM0 CH4,PTD4
    598          	PCIPORTD.PCR[5] = PORT_PCR_MUX(4); 				// FTM0 CH5,PTD5
    599          
    600          	PCIPORTA.PCR[19] = PORT_PCR_MUX(2); 			// Fault input FTM0_FLT0
    601          #elif(SR_PWM__REMAP == 1)
    602          	PCIPORTD.PCR[0]  = PORT_PCR_MUX(4); 			// FTM0 CH0  GWHGD
   \   00000126   0xF44F 0x6180      MOV      R1,#+1024
   \   0000012A   0x68F0             LDR      R0,[R6, #+12]
   \   0000012C   0xF040 0x0008      ORR      R0,R0,#0x8
   \   00000130   0x60F0             STR      R0,[R6, #+12]
   \   00000132   0x6970             LDR      R0,[R6, #+20]
   \   00000134   0xF040 0x0008      ORR      R0,R0,#0x8
   \   00000138   0x6170             STR      R0,[R6, #+20]
   \   0000013A   0x69F0             LDR      R0,[R6, #+28]
   \   0000013C   0xF040 0x0008      ORR      R0,R0,#0x8
   \   00000140   0x61F0             STR      R0,[R6, #+28]
   \   00000142   0x6A70             LDR      R0,[R6, #+36]
   \   00000144   0xF040 0x0008      ORR      R0,R0,#0x8
   \   00000148   0x6270             STR      R0,[R6, #+36]
   \   0000014A   0x6AF0             LDR      R0,[R6, #+44]
   \   0000014C   0xF040 0x0008      ORR      R0,R0,#0x8
   \   00000150   0x62F0             STR      R0,[R6, #+44]
   \   00000152   0x6B70             LDR      R0,[R6, #+52]
   \   00000154   0xF040 0x0008      ORR      R0,R0,#0x8
   \   00000158   0x6370             STR      R0,[R6, #+52]
   \   0000015A   0x6F30             LDR      R0,[R6, #+112]
   \   0000015C   0x6730             STR      R0,[R6, #+112]
   \   0000015E   0x66B5             STR      R5,[R6, #+104]
   \   00000160   0x2000             MOVS     R0,#+0
   \   00000162   0x63B0             STR      R0,[R6, #+56]
   \   00000164   0x6330             STR      R0,[R6, #+48]
   \   00000166   0x62B0             STR      R0,[R6, #+40]
   \   00000168   0x6230             STR      R0,[R6, #+32]
   \   0000016A   0x61B0             STR      R0,[R6, #+24]
   \   0000016C   0x6130             STR      R0,[R6, #+16]
   \   0000016E   0xF44F 0x7000      MOV      R0,#+512
   \   00000172   0xF8C6 0x0098      STR      R0,[R6, #+152]
   \   00000176   0x6EF0             LDR      R0,[R6, #+108]
   \   00000178   0xF040 0x0040      ORR      R0,R0,#0x40
   \   0000017C   0x66F0             STR      R0,[R6, #+108]
   \   0000017E   0x6D70             LDR      R0,[R6, #+84]
   \   00000180   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000184   0x6570             STR      R0,[R6, #+84]
   \   00000186   0x6830             LDR      R0,[R6, #+0]
   \   00000188   0xF040 0x0008      ORR      R0,R0,#0x8
   \   0000018C   0x6030             STR      R0,[R6, #+0]
   \   0000018E   0x.... 0x....      LDR.W    R0,??DataTable167_4  ;; 0x4004c000
   \   00000192   0x6001             STR      R1,[R0, #+0]
    603          	PCIPORTD.PCR[1]  = PORT_PCR_MUX(4);             // FTM0 CH1  GWLGD
   \   00000194   0x6041             STR      R1,[R0, #+4]
    604          	PCIPORTD.PCR[2]  = PORT_PCR_MUX(4);             // FTM0 CH2  GVHGD
   \   00000196   0x6081             STR      R1,[R0, #+8]
    605          	PCIPORTD.PCR[3]  = PORT_PCR_MUX(4);             // FTM0 CH3  GVLGD
   \   00000198   0x60C1             STR      R1,[R0, #+12]
    606          	PCIPORTD.PCR[4]  = PORT_PCR_MUX(4);             // FTM0 CH4  GUHGD
   \   0000019A   0x6101             STR      R1,[R0, #+16]
    607          	PCIPORTD.PCR[5]  = PORT_PCR_MUX(4);             // FTM0 CH5  GULGD
   \   0000019C   0x6141             STR      R1,[R0, #+20]
    608          #endif
    609          
    610          
    611          
    612          //------------------------------ Enables Output ------------------------------
    613          #if (SR_PWM_ENABLE_IRQ == 1)
    614          	FTM0.SC |= FTM_SC_TOIE_MASK;					// Enables Counter Overflow interrupt
    615          	Micro__NVICEnableIRQ(FTM0_IRQ_CHANNEL,0,0);	   	// Enables FTM0 Interrupt
    616          #endif
    617          	FTM0.FMS |= FTM_FMS_WPEN_MASK;				   	// Protect the Registers - Write Protection Enabled
   \   0000019E   0x6F70             LDR      R0,[R6, #+116]
   \   000001A0   0xF040 0x0040      ORR      R0,R0,#0x40
   \   000001A4   0x6770             STR      R0,[R6, #+116]
    618          
    619          #if(SR_PWM_INIT_STATE == ENABLED)
    620          	PWM_OUTPUT_ON();                                // Enables PWM output
   \   000001A6   0x6E30             LDR      R0,[R6, #+96]
   \   000001A8   0x0980             LSRS     R0,R0,#+6
   \   000001AA   0x0180             LSLS     R0,R0,#+6
   \   000001AC   0x6630             STR      R0,[R6, #+96]
    621          #endif
    622          
    623          	MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();		// Enables back interruptions
   \   000001AE   0xF388 0x8810      MSR      PRIMASK,R8
    624          
    625          
    626          //------------------------ Initialize the Class B variables ---------------------------
    627              SR_MCPWM_UPDATE_ZERO_TIMEOUT(0);
   \   000001B2   0x2200             MOVS     R2,#+0
   \   000001B4   0xF509 0x61F5      ADD      R1,R9,#+1960
   \   000001B8   0xF509 0x609C      ADD      R0,R9,#+1248
   \   000001BC   0x.... 0x....      BL       SRData__UpdateLong
    628          
    629              SR_MCPWM_UPDATE_ONE_TIMEOUT(0);
   \   000001C0   0x2200             MOVS     R2,#+0
   \   000001C2   0xF209 0x71AC      ADDW     R1,R9,#+1964
   \   000001C6   0xF209 0x40E4      ADDW     R0,R9,#+1252
   \   000001CA   0x.... 0x....      BL       SRData__UpdateLong
    630          
    631              SR_MCPWM_UPDATE_ACTIVE_PULSE_DURATION(0);
   \   000001CE   0x2200             MOVS     R2,#+0
   \   000001D0   0xF509 0x61F6      ADD      R1,R9,#+1968
   \   000001D4   0xF509 0x609D      ADD      R0,R9,#+1256
   \   000001D8   0x.... 0x....      BL       SRData__UpdateLong
    632              SR_MCPWM_UPDATE_DEFAULT_PULSE_DURATION(0);
   \   000001DC   0x2200             MOVS     R2,#+0
   \   000001DE   0xF209 0x71B4      ADDW     R1,R9,#+1972
   \   000001E2   0xF209 0x40EC      ADDW     R0,R9,#+1260
   \   000001E6   0x.... 0x....      BL       SRData__UpdateLong
    633          
    634              SR_MCPWM_UPDATE_ERRORS(SR_MCPWM_ERROR_PERIPHERAL_NOT_SAFE);
   \   000001EA   0x2204             MOVS     R2,#+4
   \   000001EC   0xF209 0x518B      ADDW     R1,R9,#+1419
   \   000001F0   0xF209 0x3071      ADDW     R0,R9,#+881
   \   000001F4   0x.... 0x....      BL       SRData__UpdateByte
    635          
    636              SR_MCPWM_UPDATE_DIAG_STATE(SR_MCPWM_WAITING_TO_CHECK);
   \   000001F8   0xB002             ADD      SP,SP,#+8
   \   000001FA   0xF209 0x518A      ADDW     R1,R9,#+1418
   \   000001FE   0xECBD 0x8B02      VPOP     {D8}
   \   00000202   0xF509 0x705C      ADD      R0,R9,#+880
   \   00000206   0xB001             ADD      SP,SP,#+4
   \   00000208   0xE8BD 0x43F0      POP      {R4-R9,LR}
   \   0000020C   0x2200             MOVS     R2,#+0
   \   0000020E   0x.... 0x....      B.W      SRData__UpdateByte
    637          }
    638          
    639          //---------------------------------------------------------------------------------------------------------------------
    640          /**
    641           * @brief       Get the max PWM counts configured in the peripheral.
    642           *
    643           * @remark      This method uses a shadowed variable, which was set during the initialization of this module.
    644           *
    645           * @return      Max PWM in timer counts.
    646           */

   \                                 In section .text, align 2, keep-with-next
    647          uint16 SRMCPwm__GetMaxPwm(void)
    648          {
    649              return(MaxPwm);
   \                     SRMCPwm__GetMaxPwm: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable167_8
   \   00000004   0xF8B0 0x039C      LDRH     R0,[R0, #+924]
   \   00000008   0x4770             BX       LR               ;; return
    650          }
    651          
    652          //---------------------------------------------------------------------------------------------------------------------
    653          /**
    654           * @brief       ISR for the PWM.
    655           *
    656           * @detail      This is configured to happen at the end of each PWM period.
    657           */

   \                                 In section .text, align 2, keep-with-next
    658          INTERRUPT_DIRECTIVE void SRMCPwm__PwmISR(void)
    659          {
    660          #if(SR_PWM_DELAY_ENABLE == 1)
    661              uint32 temp;
    662          
    663              temp = SR_MCPWM_CHECK_DUTY_A_DELAYED();    // Checks state data
    664              temp += SR_MCPWM_CHECK_DUTY_B_DELAYED();   // Checks variable data
    665              temp += SR_MCPWM_CHECK_DUTY_C_DELAYED();   // Checks variable data
    666          
    667              if(temp == SRDATA_OK)                          // If data is not corrupted
    668              {
    669                  // phase U
    670                  FTM0.CONTROLS[SR_PWM_U_HIGH].CnV    = (sint16)SR_Pwm_A_1;
    671                  FTM0.CONTROLS[SR_PWM_U_LOW].CnV     = -(sint16)SR_Pwm_A_1;
    672          
    673                  // phase V
    674                  FTM0.CONTROLS[SR_PWM_V_HIGH].CnV    = (sint16)SR_Pwm_B_1;
    675                  FTM0.CONTROLS[SR_PWM_V_LOW].CnV     = -(sint16)SR_Pwm_B_1;
    676          
    677                  // phase V
    678                  FTM0.CONTROLS[SR_PWM_W_HIGH].CnV    = (sint16)SR_Pwm_C_1;
    679                  FTM0.CONTROLS[SR_PWM_W_LOW].CnV     = -(sint16)SR_Pwm_C_1;
    680          
    681                  FTM0.PWMLOAD = FTM_PWMLOAD_LDOK_MASK;
    682          
    683          
    684                  FTM0.SC &= ~FTM_SC_TOF_MASK; //Clear the interrupt flag
    685              }
    686          #endif
    687          
    688          }
   \                     SRMCPwm__PwmISR: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    689          
    690          //---------------------------------------------------------------------------------------------------------------------
    691          /**
    692           * @brief       Turn ON ALL LOW GATES.
    693           *
    694           * @remark      This is related to the driver input and NOT to the PWM output.
    695           */

   \                                 In section .text, align 2, keep-with-next
    696          void SRMCPwm__TurnOnLowSideGates(void)
    697          {
    698          	SRMCPWM__LOADALLPWMVALUES(0, 0, 0);
   \                     SRMCPwm__TurnOnLowSideGates: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable167_13  ;; 0x40038010
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6281             STR      R1,[R0, #+40]
   \   00000008   0x6201             STR      R1,[R0, #+32]
   \   0000000A   0x6181             STR      R1,[R0, #+24]
   \   0000000C   0x6101             STR      R1,[R0, #+16]
   \   0000000E   0x6081             STR      R1,[R0, #+8]
   \   00000010   0x6001             STR      R1,[R0, #+0]
   \   00000012   0xF44F 0x7100      MOV      R1,#+512
   \   00000016   0xF8C0 0x1088      STR      R1,[R0, #+136]
    699              PWM_OUTPUT_ON();
   \   0000001A   0x6D01             LDR      R1,[R0, #+80]
   \   0000001C   0x0989             LSRS     R1,R1,#+6
   \   0000001E   0x0189             LSLS     R1,R1,#+6
   \   00000020   0x6501             STR      R1,[R0, #+80]
    700          }
   \   00000022   0x4770             BX       LR               ;; return
    701          
    702          //---------------------------------------------------------------------------------------------------------------------
    703          /**
    704           * @brief       Turn OFF ALL LOW GATES.
    705           *
    706           * @remark      This is related to the driver input and NOT to the PWM output.
    707           */

   \                                 In section .text, align 2, keep-with-next
    708          void SRMCPwm__TurnOffLowSideGates(void)
    709          {
    710          	SRMCPwm__DisablePwmOutput(SR_MCPWM_GATE_ALL_LO);
   \                     SRMCPwm__TurnOffLowSideGates: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable167_14  ;; 0x40038060
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF041 0x012A      ORR      R1,R1,#0x2A
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    711          }
   \   0000000C   0x4770             BX       LR               ;; return
    712          
    713          //---------------------------------------------------------------------------------------------------------------------
    714          /**
    715           * @brief       Turn ON ALL HIGH GATES.
    716           *
    717           * @remark      This is related to the driver input and NOT to the PWM output.
    718           */

   \                                 In section .text, align 2, keep-with-next
    719          void SRMCPwm__TurnOnHighSideGates(void)
    720          {
    721          	SRMCPWM__LOADALLPWMVALUES(SRMCPWM__GETMAXPWM() , SRMCPWM__GETMAXPWM() , SRMCPWM__GETMAXPWM());
   \                     SRMCPwm__TurnOnHighSideGates: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable167_15  ;; 0x40038008
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0x1C42             ADDS     R2,R0,#+1
   \   00000008   0xB212             SXTH     R2,R2
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0x4240             RSBS     R0,R0,#+0
   \   0000000E   0x6288             STR      R0,[R1, #+40]
   \   00000010   0x6188             STR      R0,[R1, #+24]
   \   00000012   0x6088             STR      R0,[R1, #+8]
   \   00000014   0x630A             STR      R2,[R1, #+48]
   \   00000016   0xF44F 0x7000      MOV      R0,#+512
   \   0000001A   0xF8C1 0x0090      STR      R0,[R1, #+144]
   \   0000001E   0x620A             STR      R2,[R1, #+32]
   \   00000020   0x610A             STR      R2,[R1, #+16]
    722          
    723          	PWM_OUTPUT_ON();
   \   00000022   0x6D88             LDR      R0,[R1, #+88]
   \   00000024   0x0980             LSRS     R0,R0,#+6
   \   00000026   0x0180             LSLS     R0,R0,#+6
   \   00000028   0x6588             STR      R0,[R1, #+88]
    724          }
   \   0000002A   0x4770             BX       LR               ;; return
    725          
    726          //---------------------------------------------------------------------------------------------------------------------
    727          /**
    728           * @brief        Turn OFF ALL HIGH GATES.
    729           *
    730           * @details      This is related to the driver input and NOT to the PWM output.
    731           *
    732           */

   \                                 In section .text, align 2, keep-with-next
    733          void SRMCPwm__TurnOffHighSideGates(void)
    734          {
    735          	SRMCPwm__DisablePwmOutput(SR_MCPWM_GATE_ALL_HI);
   \                     SRMCPwm__TurnOffHighSideGates: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable167_14  ;; 0x40038060
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF041 0x0115      ORR      R1,R1,#0x15
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    736          }
   \   0000000C   0x4770             BX       LR               ;; return
    737          
    738          //---------------------------------------------------------------------------------------------------------------------
    739          /**
    740           * @brief       Turn OFF all the gates.
    741           *
    742           * @details     This method is created and reconfigure on fly the Gpio output, because
    743           *              the LOCK bits can be used and the OCx/OCxN will not be able to be
    744           *              reconfigured on fly.
    745           */

   \                                 In section .text, align 2, keep-with-next
    746          void SRMCPwm__TurnOffAllGates(void)
    747          {
    748          	PWM_OUTPUT_OFF();
   \                     SRMCPwm__TurnOffAllGates: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable167_14  ;; 0x40038060
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF041 0x013F      ORR      R1,R1,#0x3F
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    749          
    750              if (GetFaultFlagState() != 0)
   \   0000000C   0x6941             LDR      R1,[R0, #+20]
   \   0000000E   0x060A             LSLS     R2,R1,#+24
   \   00000010   0x0FD2             LSRS     R2,R2,#+31
   \   00000012   0xBF1C             ITT      NE 
    751              {
    752                  ClearFaultFlag();
   \   00000014   0xF021 0x018F      BICNE    R1,R1,#0x8F
   \   00000018   0x6141             STRNE    R1,[R0, #+20]
    753              }
    754          }
   \   0000001A   0x4770             BX       LR               ;; return
    755          
    756          //---------------------------------------------------------------------------------------------------------------------
    757          /**
    758           * @brief       Load the user PWM duty to the respective registers.
    759           *
    760           * @details     All parameters are given in PWM counts.
    761           *
    762           * @param[in] pwm_a
    763           * @param[in] pwm_b
    764           * @param[in] pwm_c
    765           */

   \                                 In section .text, align 2, keep-with-next
    766          void SRMCPwm__LoadAllPwmValues(uint16 pwm_a, uint16 pwm_b, uint16 pwm_c)
    767          {
    768          
    769          #if(SR_PWM_DELAY_ENABLE == 0)
    770              // phase U
    771              FTM0.CONTROLS[SR_PWM_U_HIGH].CnV 	= (sint16)pwm_a;
   \                     SRMCPwm__LoadAllPwmValues: (+1)
   \   00000000   0x.... 0x....      LDR.W    R3,??DataTable167_13  ;; 0x40038010
   \   00000004   0xB200             SXTH     R0,R0
   \   00000006   0x6298             STR      R0,[R3, #+40]
    772              FTM0.CONTROLS[SR_PWM_U_LOW].CnV 	= -(sint16)pwm_a;
    773          
    774              // phase V
    775          	FTM0.CONTROLS[SR_PWM_V_HIGH].CnV 	= (sint16)pwm_b;
   \   00000008   0xB209             SXTH     R1,R1
   \   0000000A   0x4240             RSBS     R0,R0,#+0
   \   0000000C   0x6218             STR      R0,[R3, #+32]
    776          	FTM0.CONTROLS[SR_PWM_V_LOW].CnV 	= -(sint16)pwm_b;
    777          
    778          	// phase V
    779              FTM0.CONTROLS[SR_PWM_W_HIGH].CnV 	= (sint16)pwm_c;
   \   0000000E   0xB212             SXTH     R2,R2
   \   00000010   0x4248             RSBS     R0,R1,#+0
   \   00000012   0x6118             STR      R0,[R3, #+16]
   \   00000014   0x6199             STR      R1,[R3, #+24]
    780              FTM0.CONTROLS[SR_PWM_W_LOW].CnV 	= -(sint16)pwm_c;
   \   00000016   0x4250             RSBS     R0,R2,#+0
   \   00000018   0x6018             STR      R0,[R3, #+0]
   \   0000001A   0x609A             STR      R2,[R3, #+8]
    781          
    782          	FTM0.PWMLOAD = FTM_PWMLOAD_LDOK_MASK;
   \   0000001C   0xF44F 0x7000      MOV      R0,#+512
   \   00000020   0xF8C3 0x0088      STR      R0,[R3, #+136]
    783          #else
    784          
    785          	SR_MCPWM_UPDATE_DUTY_A_DELAYED(pwm_a);
    786          	SR_MCPWM_UPDATE_DUTY_B_DELAYED(pwm_b);
    787          	SR_MCPWM_UPDATE_DUTY_C_DELAYED(pwm_c);
    788          #endif
    789          }
   \   00000024   0x4770             BX       LR               ;; return
    790          
    791          //---------------------------------------------------------------------------------------------------------------------
    792          /**
    793           * @brief       Start the PWM timer counter.
    794           *
    795           */

   \                                 In section .text, align 2, keep-with-next
    796          void SRMCPwm__StartCounter(void)
    797          {
    798          	PWM_TIMER_START();
   \                     SRMCPwm__StartCounter: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable167_9  ;; 0x40038000
   \   00000004   0x6D41             LDR      R1,[R0, #+84]
   \   00000006   0xF041 0x0104      ORR      R1,R1,#0x4
   \   0000000A   0x6541             STR      R1,[R0, #+84]
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000012   0x6001             STR      R1,[R0, #+0]
   \   00000014   0x6F41             LDR      R1,[R0, #+116]
   \   00000016   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000001A   0x6741             STR      R1,[R0, #+116]
    799          }
   \   0000001C   0x4770             BX       LR               ;; return
    800          
    801          //---------------------------------------------------------------------------------------------------------------------
    802          /**
    803           * @brief       Stop the timer counter.
    804           *
    805           * @remark      This method also turns off the PWM ISR because the timer will be stopped.
    806           */

   \                                 In section .text, align 2, keep-with-next
    807          void SRMCPwm__StopCounter(void)
    808          {
    809          	PWM_TIMER_STOP();
   \                     SRMCPwm__StopCounter: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable167_9  ;; 0x40038000
   \   00000004   0x6D41             LDR      R1,[R0, #+84]
   \   00000006   0xF041 0x0104      ORR      R1,R1,#0x4
   \   0000000A   0x6541             STR      R1,[R0, #+84]
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0x6001             STR      R1,[R0, #+0]
   \   00000010   0x6F41             LDR      R1,[R0, #+116]
   \   00000012   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000016   0x6741             STR      R1,[R0, #+116]
    810          }
   \   00000018   0x4770             BX       LR               ;; return
    811          
    812          //---------------------------------------------------------------------------------------------------------------------
    813          /**
    814           * @brief       Enable the PWM output according the parameter gate_name.
    815           *              It connects the PWM output to the internal PWM peripheral.
    816           *
    817           * @param[in]   gate_name Selects the gate to be connected.
    818           */

   \                                 In section .text, align 4, keep-with-next
    819          void SRMCPwm__EnablePwmOutput(SRMCPWM_GATE_NAME_TYPE gate_name)
    820          {
    821          	switch(gate_name)
   \                     SRMCPwm__EnablePwmOutput: (+1)
   \   00000000   0x2808             CMP      R0,#+8
   \   00000002   0xD83C             BHI.N    ??SRMCPwm__EnablePwmOutput_1
   \   00000004   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??SRMCPwm__EnablePwmOutput_0:
   \   00000008   0x05 0x1D          DC8      0x5,0x1D,0xB,0x23
   \              0x0B 0x23    
   \   0000000C   0x11 0x29          DC8      0x11,0x29,0x17,0x2F
   \              0x17 0x2F    
   \   00000010   0x35 0x00          DC8      0x35,0x0
    822          	{
    823          	    case SR_MCPWM_GATE_A_HI:
    824          	    	FTM0.OUTMASK &= ~(FTM_OUTMASK_CH4OM_MASK);
   \                     ??SRMCPwm__EnablePwmOutput_2: (+1)
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable167_14  ;; 0x40038060
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0xF021 0x0110      BIC      R1,R1,#0x10
   \   0000001C   0xE02E             B.N      ??SRMCPwm__EnablePwmOutput_3
    825          	        break;
    826          	    case SR_MCPWM_GATE_B_HI:
    827          	    	FTM0.OUTMASK &= ~(FTM_OUTMASK_CH2OM_MASK);
   \                     ??SRMCPwm__EnablePwmOutput_4: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable167_14  ;; 0x40038060
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0xF021 0x0104      BIC      R1,R1,#0x4
   \   00000028   0xE028             B.N      ??SRMCPwm__EnablePwmOutput_3
    828          	        break;
    829          	    case SR_MCPWM_GATE_C_HI:
    830          	    	FTM0.OUTMASK &= ~(FTM_OUTMASK_CH0OM_MASK);
   \                     ??SRMCPwm__EnablePwmOutput_5: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable167_14  ;; 0x40038060
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0x0849             LSRS     R1,R1,#+1
   \   00000032   0x0049             LSLS     R1,R1,#+1
   \   00000034   0xE022             B.N      ??SRMCPwm__EnablePwmOutput_3
    831          	        break;
    832          	    case SR_MCPWM_GATE_ALL_HI:
    833          	    	FTM0.OUTMASK &= ~(FTM_OUTMASK_CH0OM_MASK | FTM_OUTMASK_CH2OM_MASK |FTM_OUTMASK_CH4OM_MASK);
   \                     ??SRMCPwm__EnablePwmOutput_6: (+1)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable167_14  ;; 0x40038060
   \   0000003A   0x6801             LDR      R1,[R0, #+0]
   \   0000003C   0xF021 0x0115      BIC      R1,R1,#0x15
   \   00000040   0xE01C             B.N      ??SRMCPwm__EnablePwmOutput_3
    834          	        break;
    835          	    case SR_MCPWM_GATE_A_LO:
    836          	    	FTM0.OUTMASK &= ~(FTM_OUTMASK_CH5OM_MASK);
   \                     ??SRMCPwm__EnablePwmOutput_7: (+1)
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable167_14  ;; 0x40038060
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0xF021 0x0120      BIC      R1,R1,#0x20
   \   0000004C   0xE016             B.N      ??SRMCPwm__EnablePwmOutput_3
    837          	        break;
    838          	    case SR_MCPWM_GATE_B_LO:
    839          	    	FTM0.OUTMASK &= ~(FTM_OUTMASK_CH3OM_MASK);
   \                     ??SRMCPwm__EnablePwmOutput_8: (+1)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable167_14  ;; 0x40038060
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0xF021 0x0108      BIC      R1,R1,#0x8
   \   00000058   0xE010             B.N      ??SRMCPwm__EnablePwmOutput_3
    840          	        break;
    841          	    case SR_MCPWM_GATE_C_LO:
    842          	    	FTM0.OUTMASK &= ~(FTM_OUTMASK_CH1OM_MASK);
   \                     ??SRMCPwm__EnablePwmOutput_9: (+1)
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable167_14  ;; 0x40038060
   \   0000005E   0x6801             LDR      R1,[R0, #+0]
   \   00000060   0xF021 0x0102      BIC      R1,R1,#0x2
   \   00000064   0xE00A             B.N      ??SRMCPwm__EnablePwmOutput_3
    843          	        break;
    844          	    case SR_MCPWM_GATE_ALL_LO:
    845          	    	FTM0.OUTMASK &= ~(FTM_OUTMASK_CH1OM_MASK | FTM_OUTMASK_CH3OM_MASK |FTM_OUTMASK_CH5OM_MASK);
   \                     ??SRMCPwm__EnablePwmOutput_10: (+1)
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable167_14  ;; 0x40038060
   \   0000006A   0x6801             LDR      R1,[R0, #+0]
   \   0000006C   0xF021 0x012A      BIC      R1,R1,#0x2A
   \   00000070   0xE004             B.N      ??SRMCPwm__EnablePwmOutput_3
    846          	        break;
    847          	    case SR_MCPWM_GATE_ALL_6GATES:
    848          	    	PWM_OUTPUT_ON()
   \                     ??SRMCPwm__EnablePwmOutput_11: (+1)
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable167_14  ;; 0x40038060
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0x0989             LSRS     R1,R1,#+6
   \   0000007A   0x0189             LSLS     R1,R1,#+6
   \                     ??SRMCPwm__EnablePwmOutput_3: (+1)
   \   0000007C   0x6001             STR      R1,[R0, #+0]
    849          			break;
    850          	    default:
    851          	        break;
    852          	}
    853          }
   \                     ??SRMCPwm__EnablePwmOutput_1: (+1)
   \   0000007E   0x4770             BX       LR               ;; return
    854          
    855          
    856          //---------------------------------------------------------------------------------------------------------------------
    857          /**
    858           * @brief       Disables PWM output according the parameter gate_name.
    859           *              It disconnects the PWM output to the internal PWM peripheral.
    860           *
    861           * @param[in]   gate_name Selects the gate to be disconnected.
    862           */

   \                                 In section .text, align 4, keep-with-next
    863          void SRMCPwm__DisablePwmOutput(SRMCPWM_GATE_NAME_TYPE gate_name)
    864          {
    865          	switch(gate_name)
   \                     SRMCPwm__DisablePwmOutput: (+1)
   \   00000000   0x2808             CMP      R0,#+8
   \   00000002   0xD83C             BHI.N    ??SRMCPwm__DisablePwmOutput_1
   \   00000004   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??SRMCPwm__DisablePwmOutput_0:
   \   00000008   0x05 0x1D          DC8      0x5,0x1D,0xB,0x23
   \              0x0B 0x23    
   \   0000000C   0x11 0x29          DC8      0x11,0x29,0x17,0x2F
   \              0x17 0x2F    
   \   00000010   0x35 0x00          DC8      0x35,0x0
    866          	{
    867          	    case SR_MCPWM_GATE_A_HI:
    868          	    	FTM0.OUTMASK |= (FTM_OUTMASK_CH4OM_MASK);;
   \                     ??SRMCPwm__DisablePwmOutput_2: (+1)
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable167_14  ;; 0x40038060
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0xF041 0x0110      ORR      R1,R1,#0x10
   \   0000001C   0xE02E             B.N      ??SRMCPwm__DisablePwmOutput_3
    869          	        break;
    870          	    case SR_MCPWM_GATE_B_HI:
    871          	    	FTM0.OUTMASK |= (FTM_OUTMASK_CH2OM_MASK);
   \                     ??SRMCPwm__DisablePwmOutput_4: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable167_14  ;; 0x40038060
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000028   0xE028             B.N      ??SRMCPwm__DisablePwmOutput_3
    872          	        break;
    873          	    case SR_MCPWM_GATE_C_HI:
    874          	    	FTM0.OUTMASK |= (FTM_OUTMASK_CH0OM_MASK);
   \                     ??SRMCPwm__DisablePwmOutput_5: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable167_14  ;; 0x40038060
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000034   0xE022             B.N      ??SRMCPwm__DisablePwmOutput_3
    875          	        break;
    876          	    case SR_MCPWM_GATE_ALL_HI:
    877          	    	FTM0.OUTMASK |= (FTM_OUTMASK_CH0OM_MASK | FTM_OUTMASK_CH2OM_MASK |FTM_OUTMASK_CH4OM_MASK);
   \                     ??SRMCPwm__DisablePwmOutput_6: (+1)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable167_14  ;; 0x40038060
   \   0000003A   0x6801             LDR      R1,[R0, #+0]
   \   0000003C   0xF041 0x0115      ORR      R1,R1,#0x15
   \   00000040   0xE01C             B.N      ??SRMCPwm__DisablePwmOutput_3
    878          	        break;
    879          	    case SR_MCPWM_GATE_A_LO:
    880          	    	FTM0.OUTMASK |= (FTM_OUTMASK_CH5OM_MASK);
   \                     ??SRMCPwm__DisablePwmOutput_7: (+1)
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable167_14  ;; 0x40038060
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000004C   0xE016             B.N      ??SRMCPwm__DisablePwmOutput_3
    881          	        break;
    882          	    case SR_MCPWM_GATE_B_LO:
    883          	    	FTM0.OUTMASK |= (FTM_OUTMASK_CH3OM_MASK);
   \                     ??SRMCPwm__DisablePwmOutput_8: (+1)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable167_14  ;; 0x40038060
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000058   0xE010             B.N      ??SRMCPwm__DisablePwmOutput_3
    884          	        break;
    885          	    case SR_MCPWM_GATE_C_LO:
    886          	    	FTM0.OUTMASK |= (FTM_OUTMASK_CH1OM_MASK);
   \                     ??SRMCPwm__DisablePwmOutput_9: (+1)
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable167_14  ;; 0x40038060
   \   0000005E   0x6801             LDR      R1,[R0, #+0]
   \   00000060   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000064   0xE00A             B.N      ??SRMCPwm__DisablePwmOutput_3
    887          	        break;
    888          	    case SR_MCPWM_GATE_ALL_LO:
    889          	    	FTM0.OUTMASK |= (FTM_OUTMASK_CH1OM_MASK | FTM_OUTMASK_CH3OM_MASK |FTM_OUTMASK_CH5OM_MASK);
   \                     ??SRMCPwm__DisablePwmOutput_10: (+1)
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable167_14  ;; 0x40038060
   \   0000006A   0x6801             LDR      R1,[R0, #+0]
   \   0000006C   0xF041 0x012A      ORR      R1,R1,#0x2A
   \   00000070   0xE004             B.N      ??SRMCPwm__DisablePwmOutput_3
    890          	        break;
    891          	    case SR_MCPWM_GATE_ALL_6GATES:
    892          	    	PWM_OUTPUT_OFF();
   \                     ??SRMCPwm__DisablePwmOutput_11: (+1)
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable167_14  ;; 0x40038060
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0xF041 0x013F      ORR      R1,R1,#0x3F
   \                     ??SRMCPwm__DisablePwmOutput_3: (+1)
   \   0000007C   0x6001             STR      R1,[R0, #+0]
    893          			break;
    894          	    default:
    895          	        break;
    896          	}
    897          }
   \                     ??SRMCPwm__DisablePwmOutput_1: (+1)
   \   0000007E   0x4770             BX       LR               ;; return
    898          
    899          
    900          //---------------------------------------------------------------------------------------------------------------------
    901          /**
    902           * @brief       Get the specified PWM frequency.
    903           *
    904           * @return      Frequency in Hertz, decimal and no fractional number.
    905           */

   \                                 In section .text, align 2, keep-with-next
    906          uint16 SRMCPwm__GetPwmFrequencyHz(void)
    907          {
    908          	return (PwmFrequency);
   \                     SRMCPwm__GetPwmFrequencyHz: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable167_8
   \   00000004   0xF8B0 0x039E      LDRH     R0,[R0, #+926]
   \   00000008   0x4770             BX       LR               ;; return
    909          }
    910          
    911          //---------------------------------------------------------------------------------------------------------------------
    912          /**
    913           * @brief       Get the configured dead time in the PWM peripheral.
    914           *
    915           * @return      Dead time in nanoseconds, decimal and no fractional number.
    916           */

   \                                 In section .text, align 2, keep-with-next
    917          uint16 SRMCPwm__GetDeadtimeNanosec(void)
    918          {
    919          	return (DeadTimeNanosec);
   \                     SRMCPwm__GetDeadtimeNanosec: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable167_8
   \   00000004   0xF8B0 0x03A0      LDRH     R0,[R0, #+928]
   \   00000008   0x4770             BX       LR               ;; return
    920          }
    921          
    922          //---------------------------------------------------------------------------------------------------------------------
    923          /**
    924           * @brief       Get the Fault Status of the peripheral.
    925           *
    926           * @details     This function returns over current or over temperature error from driver module.
    927           *
    928           * @return
    929           */

   \                                 In section .text, align 2, keep-with-next
    930          uint8 SRMCPwm__GetHwFaultStatus(void)
    931          {
   \                     SRMCPwm__GetHwFaultStatus: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    932              uint8 temp = FALSE;                     // Starts with no fault reported
    933              uint32 temp1;
    934          
    935              temp1 = SR_MCPWM_CHECK_DIAG_STATE();            // Checks state data
    936          
    937              if(temp1 == SRDATA_OK)                          // If data is not corrupted
   \   00000002   0x.... 0x....      LDR.W    R5,??DataTable167_8
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0xF205 0x518A      ADDW     R1,R5,#+1418
   \   0000000E   0xF505 0x705C      ADD      R0,R5,#+880
   \   00000012   0x.... 0x....      BL       SRData__CheckByte
   \   00000016   0xB960             CBNZ.N   R0,??SRMCPwm__GetHwFaultStatus_0
    938              {
    939                  temp1 = SR_MCPwm_Diag_State;
   \   00000018   0xF895 0x0370      LDRB     R0,[R5, #+880]
    940          
    941                  if( (temp1 == SR_MCPWM_FEEDBACK_UPDATED) ||
    942                      (temp1 == SR_MCPWM_WAITING_TO_CHECK) )  // Checks if it already finished a check or not started
   \   0000001C   0x2804             CMP      R0,#+4
   \   0000001E   0xBF18             IT       NE 
   \   00000020   0x2800             CMPNE    R0,#+0
   \   00000022   0xD106             BNE.N    ??SRMCPwm__GetHwFaultStatus_0
    943                  {
    944                    
    945                      if(GetFaultFlagState() != 0)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable168  ;; 0x40038074
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x0600             LSLS     R0,R0,#+24
   \   0000002C   0x0FC0             LSRS     R0,R0,#+31
   \   0000002E   0xBF18             IT       NE 
    946                      {
    947                          temp = TRUE;                        // Failure detected
   \   00000030   0x2401             MOVNE    R4,#+1
    948          
    949                      }
    950                  }
    951              }
    952              return(temp);                                   // Returns status
   \                     ??SRMCPwm__GetHwFaultStatus_0: (+1)
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0xB001             ADD      SP,SP,#+4
   \   00000036   0xBD30             POP      {R4,R5,PC}       ;; return
    953          }
    954          
    955          //---------------------------------------------------------------------------------------------------------------------
    956          /**
    957           * @brief
    958           *
    959           */

   \                                 In section .text, align 2, keep-with-next
    960          void SRMCPwm__Handler250us(void)
    961          {
    962          
    963          
    964          
    965          }
   \                     SRMCPwm__Handler250us: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    966          
    967          //---------------------------------------------------------------------------------------------------------------------
    968          /**
    969           * @brief       Triggers the handler to start, if the handler is available.
    970           *
    971           * @param[in]   timeout_to_zero Counts the time that the micro will force the signal to zero logic
    972           * @param[in]   timeout_to_one Counts the time that the micro will force the signal to one logic
    973           */

   \                                 In section .text, align 2, keep-with-next
    974          void SRMCPwm__EnableDiagnostic(uint32 timeout_to_zero, uint32 timeout_to_one)
    975          {
   \                     SRMCPwm__EnableDiagnostic: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    976              uint32 temp;
    977          
    978              temp = SR_MCPWM_CHECK_ZERO_TIMEOUT();
   \   00000008   0x.... 0x....      LDR.W    R6,??DataTable167_8
   \   0000000C   0xF506 0x61F5      ADD      R1,R6,#+1960
   \   00000010   0xF506 0x609C      ADD      R0,R6,#+1248
   \   00000014   0x.... 0x....      BL       SRData__CheckLong
   \   00000018   0x4607             MOV      R7,R0
    979              temp += SR_MCPWM_CHECK_ONE_TIMEOUT();
   \   0000001A   0xF206 0x71AC      ADDW     R1,R6,#+1964
   \   0000001E   0xF206 0x40E4      ADDW     R0,R6,#+1252
   \   00000022   0x.... 0x....      BL       SRData__CheckLong
   \   00000026   0x4680             MOV      R8,R0
    980              temp += SR_MCPWM_CHECK_DIAG_STATE();
   \   00000028   0xF206 0x518A      ADDW     R1,R6,#+1418
   \   0000002C   0xF506 0x705C      ADD      R0,R6,#+880
   \   00000030   0x.... 0x....      BL       SRData__CheckByte
    981              temp += SR_MCPWM_CHECK_ERRORS();
    982          
    983              if(temp == SRDATA_OK)
   \   00000034   0xFA58 0xF187      UXTAB    R1,R8,R7
   \   00000038   0xFA51 0xF780      UXTAB    R7,R1,R0
   \   0000003C   0xF206 0x518B      ADDW     R1,R6,#+1419
   \   00000040   0xF206 0x3071      ADDW     R0,R6,#+881
   \   00000044   0x.... 0x....      BL       SRData__CheckByte
   \   00000048   0xFA57 0xF080      UXTAB    R0,R7,R0
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xBF04             ITT      EQ 
    984              {
    985                  temp = SR_MCPwm_Diag_State;
    986          
    987                  if(temp == SR_MCPWM_WAITING_TO_CHECK)
   \   00000050   0xF896 0x0370      LDRBEQ   R0,[R6, #+880]
   \   00000054   0x2800             CMPEQ    R0,#+0
   \   00000056   0xD116             BNE.N    ??SRMCPwm__EnableDiagnostic_0
    988                  {
    989                      SR_MCPWM_UPDATE_ZERO_TIMEOUT(timeout_to_zero);
   \   00000058   0x4622             MOV      R2,R4
   \   0000005A   0xF506 0x61F5      ADD      R1,R6,#+1960
   \   0000005E   0xF506 0x609C      ADD      R0,R6,#+1248
   \   00000062   0x.... 0x....      BL       SRData__UpdateLong
    990                      SR_MCPWM_UPDATE_ONE_TIMEOUT(timeout_to_one);
   \   00000066   0x462A             MOV      R2,R5
   \   00000068   0xF206 0x71AC      ADDW     R1,R6,#+1964
   \   0000006C   0xF206 0x40E4      ADDW     R0,R6,#+1252
   \   00000070   0x.... 0x....      BL       SRData__UpdateLong
    991                      SR_MCPWM_UPDATE_DIAG_STATE(SR_MCPWM_CHECK_SIGNAL_POL);
   \   00000074   0xF206 0x518A      ADDW     R1,R6,#+1418
   \   00000078   0xF506 0x705C      ADD      R0,R6,#+880
   \   0000007C   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000080   0x2201             MOVS     R2,#+1
   \   00000082   0x.... 0x....      B.W      SRData__UpdateByte
    992                  }
    993              }
    994          }
   \                     ??SRMCPwm__EnableDiagnostic_0: (+1)
   \   00000086   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    995          
    996          //---------------------------------------------------------------------------------------------------------------------
    997          /**
    998           * @brief       Peripheral Diagnostic handler
    999           *
   1000           * @details     Manipulates the shut down input in order to perform
   1001           *              the plausibility checks.
   1002           */

   \                                 In section .text, align 2, keep-with-next
   1003          void SRMCPwm__DiagnosticHandler(void)
   1004          {
   \                     SRMCPwm__DiagnosticHandler: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   1005              uint32 temp;
   1006              uint32 temp1;
   1007              uint32 temp2;
   1008          
   1009              temp = SR_MCPWM_CHECK_DIAG_STATE();             // Checks state integrity state
   1010              if(temp == SRDATA_OK)                           // Continues check if OK, in case of corruption a reset will be forced
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable167_8
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0xF204 0x518A      ADDW     R1,R4,#+1418
   \   0000000C   0xF504 0x705C      ADD      R0,R4,#+880
   \   00000010   0x.... 0x....      BL       SRData__CheckByte
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xF040 0x816A      BNE.W    ??SRMCPwm__DiagnosticHandler_0
   1011              {
   1012                  temp = SR_MCPwm_Diag_State;                 // Saves state into temp
   \   0000001A   0xF894 0x0370      LDRB     R0,[R4, #+880]
   1013          
   1014                  if(temp == SR_MCPWM_WAITING_TO_CHECK)       // Keeps here waiting for an update, but is always checking state
   \   0000001E   0xB9F0             CBNZ.N   R0,??SRMCPwm__DiagnosticHandler_1
   1015                  {
   1016                      temp  = SR_MCPWM_CHECK_ACTIVE_PULSE_DURATION();
   \   00000020   0xF504 0x61F6      ADD      R1,R4,#+1968
   \   00000024   0xF504 0x609D      ADD      R0,R4,#+1256
   \   00000028   0x.... 0x....      BL       SRData__CheckLong
   \   0000002C   0x4605             MOV      R5,R0
   1017                      temp += SR_MCPWM_CHECK_DEFAULT_PULSE_DURATION();
   1018                      
   1019                      if(temp == SRDATA_OK)                           // Continues check if OK, in case of corruption a reset will be forced
   \   0000002E   0xF204 0x71B4      ADDW     R1,R4,#+1972
   \   00000032   0xF204 0x40EC      ADDW     R0,R4,#+1260
   \   00000036   0x.... 0x....      BL       SRData__CheckLong
   \   0000003A   0xFA50 0xF085      UXTAB    R0,R0,R5
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xF040 0x8155      BNE.W    ??SRMCPwm__DiagnosticHandler_0
   1020                      {
   1021                          SR_MCPWM_UPDATE_ACTIVE_PULSE_DURATION(0);
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0xF504 0x61F6      ADD      R1,R4,#+1968
   \   0000004A   0xF504 0x609D      ADD      R0,R4,#+1256
   \   0000004E   0x.... 0x....      BL       SRData__UpdateLong
   1022                          SR_MCPWM_UPDATE_DEFAULT_PULSE_DURATION(0);
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0xF204 0x71B4      ADDW     R1,R4,#+1972
   \   00000058   0xF204 0x40EC      ADDW     R0,R4,#+1260
   \   0000005C   0xE0F7             B.N      ??SRMCPwm__DiagnosticHandler_2
   1023                      }
   1024                  }
   1025          
   1026                  // Check if the shut down is INACTIVE.
   1027                  else if(temp == SR_MCPWM_CHECK_SIGNAL_POL)  // If was commanded to check SD pin, starts by reading signals
   \                     ??SRMCPwm__DiagnosticHandler_1: (+1)
   \   0000005E   0x2801             CMP      R0,#+1
   \   00000060   0xD15C             BNE.N    ??SRMCPwm__DiagnosticHandler_3
   1028                  {
   1029                      temp = SR_MCPWM_CHECK_ERRORS();
   \   00000062   0xF204 0x518B      ADDW     R1,R4,#+1419
   \   00000066   0xF204 0x3071      ADDW     R0,R4,#+881
   \   0000006A   0x.... 0x....      BL       SRData__CheckByte
   \   0000006E   0x4605             MOV      R5,R0
   1030                      temp += SR_MCPWM_CHECK_ACTIVE_PULSE_DURATION();
   \   00000070   0xF504 0x61F6      ADD      R1,R4,#+1968
   \   00000074   0xF504 0x609D      ADD      R0,R4,#+1256
   \   00000078   0x.... 0x....      BL       SRData__CheckLong
   1031                      temp += SR_MCPWM_CHECK_DEFAULT_PULSE_DURATION();
   1032                      
   1033                      if(temp == SRDATA_OK)                   // Checks data integrity
   \   0000007C   0xFA50 0xF585      UXTAB    R5,R0,R5
   \   00000080   0xF204 0x71B4      ADDW     R1,R4,#+1972
   \   00000084   0xF204 0x40EC      ADDW     R0,R4,#+1260
   \   00000088   0x.... 0x....      BL       SRData__CheckLong
   \   0000008C   0xFA55 0xF080      UXTAB    R0,R5,R0
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xF040 0x812C      BNE.W    ??SRMCPwm__DiagnosticHandler_0
   1034                      {
   1035          //                Gpio__PinConfig(PORT7,0, INPUT_PULLUP);
   1036                      	Comparator__SetThr(SR_COMPARATOR_CHANNEL, SR_PWM_FAULT_0_CMP_LEV);
   \   00000096   0x2123             MOVS     R1,#+35
   \   00000098   0x.... 0x....      BL       Comparator__SetThr
   1037          
   1038                          temp1 = SR_MCPwm_Pulse_Active_Level;
   1039                          temp2 = SR_MCPwm_Pulse_Default_Level;
   1040          //                temp = Gpio__PinRead(PORT7,0);
   1041                          temp = GetFaultState();
   1042          
   1043                          if(temp == SR_MCPWM_SHUTDOWN_ACTIVE_POLARITY)
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable168  ;; 0x40038074
   \   000000A0   0xF8D4 0x54E8      LDR      R5,[R4, #+1256]
   \   000000A4   0x7800             LDRB     R0,[R0, #+0]
   \   000000A6   0xF8D4 0x64EC      LDR      R6,[R4, #+1260]
   \   000000AA   0x0680             LSLS     R0,R0,#+26
   \   000000AC   0xD506             BPL.N    ??SRMCPwm__DiagnosticHandler_4
   1044                          {
   1045                              temp1 = SR_MCPwm_Pulse_Active_Level;
   1046                              temp1++;
   \   000000AE   0x1C6D             ADDS     R5,R5,#+1
   1047                              SR_MCPWM_UPDATE_ACTIVE_PULSE_DURATION(temp1);
   \   000000B0   0x462A             MOV      R2,R5
   \   000000B2   0xF504 0x61F6      ADD      R1,R4,#+1968
   \   000000B6   0xF504 0x609D      ADD      R0,R4,#+1256
   \   000000BA   0xE005             B.N      ??SRMCPwm__DiagnosticHandler_5
   1048                          }
   1049                          else
   1050                          {
   1051                              temp2 = SR_MCPwm_Pulse_Default_Level;
   1052                              temp2++;
   \                     ??SRMCPwm__DiagnosticHandler_4: (+1)
   \   000000BC   0x1C76             ADDS     R6,R6,#+1
   1053                              SR_MCPWM_UPDATE_DEFAULT_PULSE_DURATION(temp2);
   \   000000BE   0x4632             MOV      R2,R6
   \   000000C0   0xF204 0x71B4      ADDW     R1,R4,#+1972
   \   000000C4   0xF204 0x40EC      ADDW     R0,R4,#+1260
   \                     ??SRMCPwm__DiagnosticHandler_5: (+1)
   \   000000C8   0x.... 0x....      BL       SRData__UpdateLong
   1054                          }
   1055          #ifdef FORCE_SHUTDOWN_FAILURE_ALREADY_ACTIVE
   1056                          temp1 = SR_MCPWM_DIAG_SAMPLES_4_DECISION;
   1057          #endif
   1058          
   1059                          if((temp1 + temp2) >= SR_MCPWM_DIAG_TOTAL_SAMPLES_NR)
   \   000000CC   0x1970             ADDS     R0,R6,R5
   \   000000CE   0x2819             CMP      R0,#+25
   \   000000D0   0xF0C0 0x810D      BCC.W    ??SRMCPwm__DiagnosticHandler_0
   1060                          {                                   // after 2.5ms sampling
   1061                              if (temp1 >= SR_MCPWM_DIAG_SAMPLES_4_DECISION)
   \   000000D4   0xF894 0x0371      LDRB     R0,[R4, #+881]
   \   000000D8   0x2D0F             CMP      R5,#+15
   \   000000DA   0xBF28             IT       CS 
   1062                              {                               // 60% samples showing SD active
   1063                                  // The shut down circuit is already activated!
   1064                                  temp = SR_MCPwm_Errors;     // Read errors
   1065                                  BIT_SET(temp, SR_MCPWM_ERROR_SHUTDOWN_ALREADY_ON);
   1066                                  SR_MCPWM_UPDATE_ERRORS((SRMCPWM_DIAG_ERROR_TYPE)temp);
   \   000000DC   0xF040 0x0201      ORRCS    R2,R0,#0x1
   \   000000E0   0xF080 0x80F5      BCS.W    ??SRMCPwm__DiagnosticHandler_6
   1067                                  SR_MCPWM_UPDATE_DIAG_STATE(SR_MCPWM_FEEDBACK_UPDATED);
   1068                              }
   1069                              else                            // SD pin is not active
   1070                              {
   1071                                  // The shut down circuit is already deactivated!
   1072                                  temp = SR_MCPwm_Errors;     // We are reading and clearing an error which was not set (really needed???)
   1073                                  BIT_CLR(temp, SR_MCPWM_ERROR_SHUTDOWN_ALREADY_ON);
   1074                                  SR_MCPWM_UPDATE_ERRORS((SRMCPWM_DIAG_ERROR_TYPE)temp);
   \   000000E4   0xF000 0x02FE      AND      R2,R0,#0xFE
   \   000000E8   0xF204 0x518B      ADDW     R1,R4,#+1419
   \   000000EC   0xF204 0x3071      ADDW     R0,R4,#+881
   \   000000F0   0x.... 0x....      BL       SRData__UpdateByte
   1075                                  // There are specific feedacks for errors, but we don't report them to application, is it also needed
   1076            //                      Gpio__PinConfig(PORT7,0, OUTPUT_OPEN_DRAIN);
   1077            //                      Gpio__PinWrite(PORT7,0, SR_MCPWM_SHUTDOWN_ACTIVE_POLARITY);
   1078                                  Comparator__SetThr(SR_COMPARATOR_CHANNEL, SR_PWM_FAULT_0_CMP_LEV_TEST);
   \   000000F4   0x2108             MOVS     R1,#+8
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0x.... 0x....      BL       Comparator__SetThr
   1079          
   1080                                  temp1 = 0;
   1081                                  temp2 = 0;
   1082                                  SR_MCPWM_UPDATE_ACTIVE_PULSE_DURATION(temp1);
   \   000000FC   0x2200             MOVS     R2,#+0
   \   000000FE   0xF504 0x61F6      ADD      R1,R4,#+1968
   \   00000102   0xF504 0x609D      ADD      R0,R4,#+1256
   \   00000106   0x.... 0x....      BL       SRData__UpdateLong
   1083                                  SR_MCPWM_UPDATE_DEFAULT_PULSE_DURATION(temp2);
   \   0000010A   0x2200             MOVS     R2,#+0
   \   0000010C   0xF204 0x71B4      ADDW     R1,R4,#+1972
   \   00000110   0xF204 0x40EC      ADDW     R0,R4,#+1260
   \   00000114   0x.... 0x....      BL       SRData__UpdateLong
   1084                                  // Commands output to force disabling SD pin
   1085          
   1086                                  SR_MCPWM_UPDATE_DIAG_STATE(SR_MCPWM_CHECK_STUCK_AT_1);
   \   00000118   0x2202             MOVS     R2,#+2
   \   0000011A   0xE0DF             B.N      ??SRMCPwm__DiagnosticHandler_7
   1087                                                          // Gets to the state to detect if it's stuck at 1
   1088                              }                               
   1089          
   1090                          }                               // Gets final state
   1091                      }
   1092                  }
   1093                  else if(temp == SR_MCPWM_CHECK_STUCK_AT_1)
   \                     ??SRMCPwm__DiagnosticHandler_3: (+1)
   \   0000011C   0x2802             CMP      R0,#+2
   \   0000011E   0xD16A             BNE.N    ??SRMCPwm__DiagnosticHandler_8
   1094                  {
   1095                      temp  = SR_MCPWM_CHECK_ZERO_TIMEOUT();
   \   00000120   0xF504 0x61F5      ADD      R1,R4,#+1960
   \   00000124   0xF504 0x609C      ADD      R0,R4,#+1248
   \   00000128   0x.... 0x....      BL       SRData__CheckLong
   \   0000012C   0x4605             MOV      R5,R0
   1096                      temp += SR_MCPWM_CHECK_ERRORS();        // Checks timers, error flags and flow flags
   \   0000012E   0xF204 0x518B      ADDW     R1,R4,#+1419
   \   00000132   0xF204 0x3071      ADDW     R0,R4,#+881
   \   00000136   0x.... 0x....      BL       SRData__CheckByte
   \   0000013A   0x4606             MOV      R6,R0
   1097                      temp += SR_MCPWM_CHECK_ACTIVE_PULSE_DURATION();
   \   0000013C   0xF504 0x61F6      ADD      R1,R4,#+1968
   \   00000140   0xF504 0x609D      ADD      R0,R4,#+1256
   \   00000144   0x.... 0x....      BL       SRData__CheckLong
   1098                      temp += SR_MCPWM_CHECK_DEFAULT_PULSE_DURATION();
   1099                      
   1100                      if(temp == SRDATA_OK)                   // In case data wasn't corrupted
   \   00000148   0xFA56 0xF185      UXTAB    R1,R6,R5
   \   0000014C   0xFA51 0xF580      UXTAB    R5,R1,R0
   \   00000150   0xF204 0x71B4      ADDW     R1,R4,#+1972
   \   00000154   0xF204 0x40EC      ADDW     R0,R4,#+1260
   \   00000158   0x.... 0x....      BL       SRData__CheckLong
   \   0000015C   0xFA55 0xF080      UXTAB    R0,R5,R0
   \   00000160   0x2800             CMP      R0,#+0
   \   00000162   0xF040 0x80C4      BNE.W    ??SRMCPwm__DiagnosticHandler_0
   1101                      {
   1102                          temp = SR_MCPwm_Zero_Timeout;
   \   00000166   0xF8D4 0x04E0      LDR      R0,[R4, #+1248]
   1103                          if(temp)
   \   0000016A   0xB128             CBZ.N    R0,??SRMCPwm__DiagnosticHandler_9
   1104                          {
   1105                              temp--;                         // Decrements and updates timer
   1106                              SR_MCPWM_UPDATE_ZERO_TIMEOUT(temp);
   \   0000016C   0x1E42             SUBS     R2,R0,#+1
   \   0000016E   0xF504 0x61F5      ADD      R1,R4,#+1960
   \   00000172   0xF504 0x609C      ADD      R0,R4,#+1248
   \   00000176   0xE06A             B.N      ??SRMCPwm__DiagnosticHandler_2
   1107                          }
   1108                          else                                // After a while (2.5ms forcing null)
   1109                          {
   1110           //                   Gpio__PinConfig(PORT7,0, INPUT_PULLUP);
   1111           //               	Comparator__SetThr(SR_COMPARATOR_CHANNEL, SR_PWM_FAULT_0_CMP_LEV);
   1112          
   1113                              temp1 = SR_MCPwm_Pulse_Active_Level;
   1114                              temp2 = SR_MCPwm_Pulse_Default_Level;
   1115          
   1116            //                  temp = Gpio__PinRead(PORT7,0);
   1117                              temp = GetFaultState();
   1118          
   1119                              if(temp == SR_MCPWM_SHUTDOWN_ACTIVE_POLARITY)
   \                     ??SRMCPwm__DiagnosticHandler_9: (+1)
   \   00000178   0x.... 0x....      LDR.W    R0,??DataTable168  ;; 0x40038074
   \   0000017C   0xF8D4 0x54E8      LDR      R5,[R4, #+1256]
   \   00000180   0x7800             LDRB     R0,[R0, #+0]
   \   00000182   0xF8D4 0x64EC      LDR      R6,[R4, #+1260]
   \   00000186   0x0680             LSLS     R0,R0,#+26
   \   00000188   0xD506             BPL.N    ??SRMCPwm__DiagnosticHandler_10
   1120                              {
   1121                                  temp1 = SR_MCPwm_Pulse_Active_Level;
   1122                                  temp1++;
   \   0000018A   0x1C6D             ADDS     R5,R5,#+1
   1123                                  SR_MCPWM_UPDATE_ACTIVE_PULSE_DURATION(temp1);
   \   0000018C   0x462A             MOV      R2,R5
   \   0000018E   0xF504 0x61F6      ADD      R1,R4,#+1968
   \   00000192   0xF504 0x609D      ADD      R0,R4,#+1256
   \   00000196   0xE005             B.N      ??SRMCPwm__DiagnosticHandler_11
   1124                              }
   1125                              else
   1126                              {
   1127                                  temp2 = SR_MCPwm_Pulse_Default_Level;
   1128                                  temp2++;
   \                     ??SRMCPwm__DiagnosticHandler_10: (+1)
   \   00000198   0x1C76             ADDS     R6,R6,#+1
   1129                                  SR_MCPWM_UPDATE_DEFAULT_PULSE_DURATION(temp2);
   \   0000019A   0x4632             MOV      R2,R6
   \   0000019C   0xF204 0x71B4      ADDW     R1,R4,#+1972
   \   000001A0   0xF204 0x40EC      ADDW     R0,R4,#+1260
   \                     ??SRMCPwm__DiagnosticHandler_11: (+1)
   \   000001A4   0x.... 0x....      BL       SRData__UpdateLong
   1130                              }
   1131          #ifdef FORCE_SHUTDOWN_FAILURE_STUCK_AT_1
   1132                              temp1 = 0;
   1133          #endif
   1134                              if((temp1 + temp2) >= SR_MCPWM_DIAG_TOTAL_SAMPLES_NR)
   \   000001A8   0x1970             ADDS     R0,R6,R5
   \   000001AA   0x2819             CMP      R0,#+25
   \   000001AC   0xF0C0 0x809F      BCC.W    ??SRMCPwm__DiagnosticHandler_0
   1135                              {                                   // after 2.5ms sampling
   1136                                  if (temp1 >= SR_MCPWM_DIAG_SAMPLES_4_DECISION)
   \   000001B0   0xF894 0x0371      LDRB     R0,[R4, #+881]
   \   000001B4   0x2D0F             CMP      R5,#+15
   \   000001B6   0xD31B             BCC.N    ??SRMCPwm__DiagnosticHandler_12
   1137                                  {                               // 60% samples showing SD active
   1138                                      // The register is NOT stuck at 1!
   1139                                      temp = SR_MCPwm_Errors;
   1140                                      BIT_CLR(temp, SR_MCPWM_ERROR_REGISTER_STUCK_AT_1);
   1141                                      SR_MCPWM_UPDATE_ERRORS((SRMCPWM_DIAG_ERROR_TYPE)temp);
   \   000001B8   0xF000 0x02FD      AND      R2,R0,#0xFD
   \   000001BC   0xF204 0x518B      ADDW     R1,R4,#+1419
   \   000001C0   0xF204 0x3071      ADDW     R0,R4,#+881
   \   000001C4   0x.... 0x....      BL       SRData__UpdateByte
   1142                                      Comparator__SetThr(SR_COMPARATOR_CHANNEL, SR_PWM_FAULT_0_CMP_LEV);
   \   000001C8   0x2123             MOVS     R1,#+35
   \   000001CA   0x2000             MOVS     R0,#+0
   \   000001CC   0x.... 0x....      BL       Comparator__SetThr
   1143                                      temp1 = 0;
   1144                                      temp2 = 0;
   1145                                      SR_MCPWM_UPDATE_ACTIVE_PULSE_DURATION(temp1);
   \   000001D0   0x2200             MOVS     R2,#+0
   \   000001D2   0xF504 0x61F6      ADD      R1,R4,#+1968
   \   000001D6   0xF504 0x609D      ADD      R0,R4,#+1256
   \   000001DA   0x.... 0x....      BL       SRData__UpdateLong
   1146                                      SR_MCPWM_UPDATE_DEFAULT_PULSE_DURATION(temp2);
   \   000001DE   0x2200             MOVS     R2,#+0
   \   000001E0   0xF204 0x71B4      ADDW     R1,R4,#+1972
   \   000001E4   0xF204 0x40EC      ADDW     R0,R4,#+1260
   \   000001E8   0x.... 0x....      BL       SRData__UpdateLong
   1147          
   1148                                      SR_MCPWM_UPDATE_DIAG_STATE(SR_MCPWM_CHECK_STUCK_AT_0);
   \   000001EC   0x2203             MOVS     R2,#+3
   \   000001EE   0xE075             B.N      ??SRMCPwm__DiagnosticHandler_7
   1149                                                                 // Changes state to check if it's stuck at zero (I don't know if it is redundant, since first check was checking if not zero)
   1150                                  }                               
   1151                                  else
   1152                                  {
   1153                                      // The register IS stuck at 1!
   1154                                      temp = SR_MCPwm_Errors;
   1155                                      BIT_SET(temp, SR_MCPWM_ERROR_REGISTER_STUCK_AT_1);
   1156                                      SR_MCPWM_UPDATE_ERRORS((SRMCPWM_DIAG_ERROR_TYPE)temp);
   \                     ??SRMCPwm__DiagnosticHandler_12: (+1)
   \   000001F0   0xF040 0x0202      ORR      R2,R0,#0x2
   \   000001F4   0xE06B             B.N      ??SRMCPwm__DiagnosticHandler_6
   1157                                                                  // Updates error
   1158          
   1159                                      SR_MCPWM_UPDATE_DIAG_STATE(SR_MCPWM_FEEDBACK_UPDATED);
   1160                                  }                               // Ends check since error was detected
   1161                              }
   1162                          }
   1163                      }
   1164                  }
   1165                  else if(temp == SR_MCPWM_CHECK_STUCK_AT_0)  // Checks if not stuck at zero
   \                     ??SRMCPwm__DiagnosticHandler_8: (+1)
   \   000001F6   0x2803             CMP      R0,#+3
   \   000001F8   0xD179             BNE.N    ??SRMCPwm__DiagnosticHandler_0
   1166                  {
   1167                      temp  = SR_MCPWM_CHECK_ONE_TIMEOUT();
   \   000001FA   0xF204 0x71AC      ADDW     R1,R4,#+1964
   \   000001FE   0xF204 0x40E4      ADDW     R0,R4,#+1252
   \   00000202   0x.... 0x....      BL       SRData__CheckLong
   \   00000206   0x4605             MOV      R5,R0
   1168                      temp += SR_MCPWM_CHECK_ERRORS();
   \   00000208   0xF204 0x518B      ADDW     R1,R4,#+1419
   \   0000020C   0xF204 0x3071      ADDW     R0,R4,#+881
   \   00000210   0x.... 0x....      BL       SRData__CheckByte
   \   00000214   0x4606             MOV      R6,R0
   1169                      temp += SR_MCPWM_CHECK_ACTIVE_PULSE_DURATION();
   \   00000216   0xF504 0x61F6      ADD      R1,R4,#+1968
   \   0000021A   0xF504 0x609D      ADD      R0,R4,#+1256
   \   0000021E   0x.... 0x....      BL       SRData__CheckLong
   1170                      temp += SR_MCPWM_CHECK_DEFAULT_PULSE_DURATION();
   1171          
   1172                      if(temp == SRDATA_OK)                   // Since data is not corrupted (I don't know if all these tests are really needed, in case of corruption it will force reset
   \   00000222   0xFA56 0xF185      UXTAB    R1,R6,R5
   \   00000226   0xFA51 0xF580      UXTAB    R5,R1,R0
   \   0000022A   0xF204 0x71B4      ADDW     R1,R4,#+1972
   \   0000022E   0xF204 0x40EC      ADDW     R0,R4,#+1260
   \   00000232   0x.... 0x....      BL       SRData__CheckLong
   \   00000236   0xFA55 0xF080      UXTAB    R0,R5,R0
   \   0000023A   0x2800             CMP      R0,#+0
   \   0000023C   0xD157             BNE.N    ??SRMCPwm__DiagnosticHandler_0
   1173                      {
   1174                          temp = SR_MCPwm_One_Timeout;
   \   0000023E   0xF8D4 0x04E4      LDR      R0,[R4, #+1252]
   1175                          if(temp)
   \   00000242   0xB148             CBZ.N    R0,??SRMCPwm__DiagnosticHandler_13
   1176                          {
   1177                              temp--;
   1178                              SR_MCPWM_UPDATE_ONE_TIMEOUT(temp);
   \   00000244   0x1E42             SUBS     R2,R0,#+1
   \   00000246   0xF204 0x71AC      ADDW     R1,R4,#+1964
   \   0000024A   0xF204 0x40E4      ADDW     R0,R4,#+1252
   \                     ??SRMCPwm__DiagnosticHandler_2: (+1)
   \   0000024E   0xB001             ADD      SP,SP,#+4
   \   00000250   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   00000254   0x.... 0x....      B.W      SRData__UpdateLong
   1179                          }                                   // Waits 20ms to release condition
   1180                          else
   1181                          {
   1182                              temp1 = SR_MCPwm_Pulse_Active_Level;
   1183                              temp2 = SR_MCPwm_Pulse_Default_Level;
   1184          //                    temp = Gpio__PinRead(PORT7,0);
   1185                              temp = GetFaultState();
   1186          
   1187                              if(temp == SR_MCPWM_SHUTDOWN_ACTIVE_POLARITY)
   \                     ??SRMCPwm__DiagnosticHandler_13: (+1)
   \   00000258   0x.... 0x....      LDR.W    R7,??DataTable168  ;; 0x40038074
   \   0000025C   0xF8D4 0x54E8      LDR      R5,[R4, #+1256]
   \   00000260   0x7838             LDRB     R0,[R7, #+0]
   \   00000262   0xF8D4 0x64EC      LDR      R6,[R4, #+1260]
   \   00000266   0x0680             LSLS     R0,R0,#+26
   \   00000268   0xD506             BPL.N    ??SRMCPwm__DiagnosticHandler_14
   1188                              {
   1189                                  temp1 = SR_MCPwm_Pulse_Active_Level;
   1190                                  temp1++;
   \   0000026A   0x1C6D             ADDS     R5,R5,#+1
   1191                                  SR_MCPWM_UPDATE_ACTIVE_PULSE_DURATION(temp1);
   \   0000026C   0x462A             MOV      R2,R5
   \   0000026E   0xF504 0x61F6      ADD      R1,R4,#+1968
   \   00000272   0xF504 0x609D      ADD      R0,R4,#+1256
   \   00000276   0xE005             B.N      ??SRMCPwm__DiagnosticHandler_15
   1192                              }
   1193                              else
   1194                              {
   1195                                  temp2 = SR_MCPwm_Pulse_Default_Level;
   1196                                  temp2++;
   \                     ??SRMCPwm__DiagnosticHandler_14: (+1)
   \   00000278   0x1C76             ADDS     R6,R6,#+1
   1197                                  SR_MCPWM_UPDATE_DEFAULT_PULSE_DURATION(temp2);
   \   0000027A   0x4632             MOV      R2,R6
   \   0000027C   0xF204 0x71B4      ADDW     R1,R4,#+1972
   \   00000280   0xF204 0x40EC      ADDW     R0,R4,#+1260
   \                     ??SRMCPwm__DiagnosticHandler_15: (+1)
   \   00000284   0x.... 0x....      BL       SRData__UpdateLong
   1198                              }
   1199          
   1200          #ifdef FORCE_SHUTDOWN_FAILURE_STUCK_AT_0
   1201                              temp2 = 0;
   1202          #endif
   1203                              if((temp1 + temp2) >= SR_MCPWM_DIAG_TOTAL_SAMPLES_NR)
   \   00000288   0x1970             ADDS     R0,R6,R5
   \   0000028A   0x2819             CMP      R0,#+25
   \   0000028C   0xD32F             BCC.N    ??SRMCPwm__DiagnosticHandler_0
   1204                              {                                   // after 2.5ms sampling
   1205                                  if (temp2 >= SR_MCPWM_DIAG_SAMPLES_4_DECISION)
   \   0000028E   0xF894 0x0371      LDRB     R0,[R4, #+881]
   \   00000292   0x2E0F             CMP      R6,#+15
   \   00000294   0xD319             BCC.N    ??SRMCPwm__DiagnosticHandler_16
   1206                                  {                               // 60% samples showing SD active
   1207                                      // The register is NOT stuck at 0!
   1208                                      temp = SR_MCPwm_Errors; // It's not checking to read here
   1209                                      BIT_CLR(temp, SR_MCPWM_ERROR_REGISTER_STUCK_AT_0);
   1210                                      BIT_SET(temp, SR_MCPWM_ERROR_PERIPHERAL_SAFE);
   1211                                      SR_MCPWM_UPDATE_ERRORS((SRMCPWM_DIAG_ERROR_TYPE)temp);
   \   00000296   0xF000 0x00FB      AND      R0,R0,#0xFB
   \   0000029A   0xF040 0x0220      ORR      R2,R0,#0x20
   \   0000029E   0xF204 0x518B      ADDW     R1,R4,#+1419
   \   000002A2   0xF204 0x3071      ADDW     R0,R4,#+881
   \   000002A6   0x.... 0x....      BL       SRData__UpdateByte
   1212          
   1213                                      SR_MCPWM_UPDATE_DIAG_STATE(SR_MCPWM_FEEDBACK_UPDATED);
   \   000002AA   0x2204             MOVS     R2,#+4
   \   000002AC   0xF204 0x518A      ADDW     R1,R4,#+1418
   \   000002B0   0xF504 0x705C      ADD      R0,R4,#+880
   \   000002B4   0x.... 0x....      BL       SRData__UpdateByte
   1214                                      // Updates state machine
   1215                                      if (GetFaultFlagState() != 0)
   \   000002B8   0x6838             LDR      R0,[R7, #+0]
   \   000002BA   0x0601             LSLS     R1,R0,#+24
   \   000002BC   0x0FC9             LSRS     R1,R1,#+31
   \   000002BE   0xD016             BEQ.N    ??SRMCPwm__DiagnosticHandler_0
   1216                                      {
   1217                                          ClearFaultFlag();
   \   000002C0   0xF020 0x008F      BIC      R0,R0,#0x8F
   \   000002C4   0x6038             STR      R0,[R7, #+0]
   1218                                      }
   1219                                  }
   1220                                  else                        // In case of failure
   1221                                  {
   1222                                      // The register IS stuck at 1!
   1223                                      temp = SR_MCPwm_Errors;
   1224                                      BIT_SET(temp, SR_MCPWM_ERROR_REGISTER_STUCK_AT_0);
   1225                                      SR_MCPWM_UPDATE_ERRORS((SRMCPWM_DIAG_ERROR_TYPE)temp);
   1226                                      // Reports the error
   1227                                      SR_MCPWM_UPDATE_DIAG_STATE(SR_MCPWM_FEEDBACK_UPDATED);
   1228                                  }
   1229                              }
   1230                          }
   1231                      }
   1232                  }
   1233                  else if(temp == SR_MCPWM_FEEDBACK_UPDATED)
   1234                  {
   1235                      // Stay here until the feedback is read by the caller.
   1236                  }
   1237                  else
   1238                  {
   1239                      // Should never reach this region.
   1240                      // Just in case, should force to a safe condition here
   1241                  }
   1242              }
   1243          }
   \   000002C6   0xB001             ADD      SP,SP,#+4
   \   000002C8   0xBDF0             POP      {R4-R7,PC}
   \                     ??SRMCPwm__DiagnosticHandler_16: (+1)
   \   000002CA   0xF040 0x0204      ORR      R2,R0,#0x4
   \                     ??SRMCPwm__DiagnosticHandler_6: (+1)
   \   000002CE   0xF204 0x518B      ADDW     R1,R4,#+1419
   \   000002D2   0xF204 0x3071      ADDW     R0,R4,#+881
   \   000002D6   0x.... 0x....      BL       SRData__UpdateByte
   \   000002DA   0x2204             MOVS     R2,#+4
   \                     ??SRMCPwm__DiagnosticHandler_7: (+1)
   \   000002DC   0xF204 0x518A      ADDW     R1,R4,#+1418
   \   000002E0   0xF504 0x705C      ADD      R0,R4,#+880
   \   000002E4   0xB001             ADD      SP,SP,#+4
   \   000002E6   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   000002EA   0x.... 0x....      B.W      SRData__UpdateByte
   \                     ??SRMCPwm__DiagnosticHandler_0: (+1)
   \   000002EE   0xB001             ADD      SP,SP,#+4
   \   000002F0   0xBDF0             POP      {R4-R7,PC}       ;; return
   1244          
   1245          //---------------------------------------------------------------------------------------------------------------------
   1246          /**
   1247           * @brief       Get the feedback of the plausibility check
   1248           *
   1249           * @details     Gets the plausibility check result, when the state machine is fully executed.
   1250           *              As soon as the state machine reaches its final state, it will update the feedback
   1251           *              which will be read by this method, once the state machine has reached its final state,
   1252           *              and once this method is called, then it will trigger the state machine to go back to
   1253           *              its very state and reset the integrity feedback of the circuit.
   1254           *              This action prevents two reading in sequence of a safe hardware, i.e., once it gets
   1255           *              the feedback, the state machine must be ran again to update the status.
   1256           *
   1257           * @return      The plausibility check result.
   1258           */

   \                                 In section .text, align 2, keep-with-next
   1259          SRMCPWM_DIAG_ERROR_TYPE SRMCPwm__GetDiagnosticFeedback(void)
   1260          {
   \                     SRMCPwm__GetDiagnosticFeedback: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1261              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
   1262              uint32 temp;
   1263              uint32 temp1;
   1264              SRMCPWM_DIAG_ERROR_TYPE current_status;
   1265          
   1266              SR_MCPWM_CHECK_DIAG_STATE();
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable169
   \   00000006   0xF204 0x518A      ADDW     R1,R4,#+1418
   \   0000000A   0xF504 0x705C      ADD      R0,R4,#+880
   \   0000000E   0x.... 0x....      BL       SRData__CheckByte
   1267              SR_MCPWM_CHECK_ERRORS();
   \   00000012   0xF204 0x518B      ADDW     R1,R4,#+1419
   \   00000016   0xF204 0x3071      ADDW     R0,R4,#+881
   \   0000001A   0x.... 0x....      BL       SRData__CheckByte
   1268          
   1269              temp = SR_MCPwm_Diag_State;
   \   0000001E   0xF894 0x0370      LDRB     R0,[R4, #+880]
   1270          
   1271              if(temp == SR_MCPWM_FEEDBACK_UPDATED)
   \   00000022   0x2804             CMP      R0,#+4
   \   00000024   0xD117             BNE.N    ??SRMCPwm__GetDiagnosticFeedback_0
   1272              {
   1273                 MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   00000026   0xF3EF 0x8510      MRS      R5,PRIMASK
   \   0000002A   0xB672             CPSID    I
   1274                 current_status = SR_MCPWM_ERROR_PERIPHERAL_NOT_SAFE;
   1275          
   1276                 temp  = SR_MCPwm_Errors;
   \   0000002C   0xF894 0x0371      LDRB     R0,[R4, #+881]
   \   00000030   0x2604             MOVS     R6,#+4
   1277                 temp1  = BIT_TEST(temp, SR_MCPWM_ERROR_SHUTDOWN_ALREADY_ON);
   1278                 temp1 += BIT_TEST(temp, SR_MCPWM_ERROR_REGISTER_STUCK_AT_1);
   1279                 temp1 += BIT_TEST(temp, SR_MCPWM_ERROR_REGISTER_STUCK_AT_0);
   1280          
   1281                 if(!temp1)
   \   00000032   0x07C1             LSLS     R1,R0,#+31
   \   00000034   0xD404             BMI.N    ??SRMCPwm__GetDiagnosticFeedback_1
   \   00000036   0x0781             LSLS     R1,R0,#+30
   \   00000038   0xD402             BMI.N    ??SRMCPwm__GetDiagnosticFeedback_1
   \   0000003A   0x0740             LSLS     R0,R0,#+29
   \   0000003C   0xBF58             IT       PL 
   1282                 {
   1283                     current_status = SR_MCPWM_ERROR_PERIPHERAL_SAFE;
   \   0000003E   0x2605             MOVPL    R6,#+5
   1284                 }
   1285          
   1286                 SR_MCPWM_UPDATE_DIAG_STATE(SR_MCPWM_WAITING_TO_CHECK);
   \                     ??SRMCPwm__GetDiagnosticFeedback_1: (+1)
   \   00000040   0x2200             MOVS     R2,#+0
   \   00000042   0xF204 0x518A      ADDW     R1,R4,#+1418
   \   00000046   0xF504 0x705C      ADD      R0,R4,#+880
   \   0000004A   0x.... 0x....      BL       SRData__UpdateByte
   1287                 MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \   0000004E   0xF385 0x8810      MSR      PRIMASK,R5
   1288              }
   1289              else if(temp == SR_MCPWM_WAITING_TO_CHECK)
   1290              {
   1291                  current_status = SR_MCPWM_ERROR_WAITING_START_TRIGGER;
   1292              }
   1293              else
   1294              {
   1295                  current_status = SR_MCPWM_ERROR_CHECKING;
   1296              }
   1297          
   1298          
   1299              return(current_status);                                 // Returns status
   \   00000052   0x4630             MOV      R0,R6
   \   00000054   0xBD70             POP      {R4-R6,PC}
   \                     ??SRMCPwm__GetDiagnosticFeedback_0: (+1)
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xBF0C             ITE      EQ 
   \   0000005A   0x2603             MOVEQ    R6,#+3
   \   0000005C   0x2606             MOVNE    R6,#+6
   \   0000005E   0x4630             MOV      R0,R6
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
   1300          }
   1301          
   1302          //=====================================================================================================================
   1303          //-------------------------------------- Private Functions -------------------------------------------------------------
   1304          //=====================================================================================================================
   1305          
   1306          /**
   1307           * @brief       Get the fault state
   1308           *
   1309           * @return      TRUE, if there is a fault, FALSE otherwise
   1310           *
   1311           */
   1312          static BOOL_TYPE GetFaultState(void)
   1313          {
   1314          	BOOL_TYPE response;
   1315          	uint16 temp;
   1316          
   1317          	temp = FTM0.FMS&FTM_FMS_FAULTIN_MASK;
   1318          
   1319          	if(temp != 0)
   1320          	{
   1321          		response = TRUE;
   1322          	}
   1323          	else
   1324          	{
   1325          		response = FALSE;
   1326          	}
   1327          
   1328          	return (response);
   1329          }
   1330          
   1331          /**
   1332           * @brief       Get the fault flag state
   1333           *
   1334           * @return      TRUE, if there is a fault, FALSE otherwise
   1335           *
   1336           */
   1337          static BOOL_TYPE GetFaultFlagState(void)
   1338          {
   1339          	BOOL_TYPE response;
   1340          	uint16 temp;
   1341          
   1342          	temp = FTM0.FMS&FTM_FMS_FAULTF_MASK;
   1343          
   1344          	if(temp != 0)
   1345          	{
   1346          		response = TRUE;
   1347          	}
   1348          	else
   1349          	{
   1350          		response = FALSE;
   1351          	}
   1352          
   1353          	return (response);
   1354          }
   1355          
   1356          /**
   1357           * @brief       Clear the fault flag.
   1358           *
   1359           *
   1360           */
   1361          static void ClearFaultFlag(void)
   1362          {
   1363          
   1364          	FTM0.FMS &= ~(FTM_FMS_FAULTF_MASK|FTM_FMS_FAULTF3_MASK|FTM_FMS_FAULTF2_MASK|FTM_FMS_FAULTF1_MASK|FTM_FMS_FAULTF0_MASK);
   1365          }
   1366          
   1367          
C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Hbl\SRMotorSafetyMgr\SRMotorSafetyMgr.c
      1          /**
      2           *  @file       SRMotorSafetyMgr.c
      3           *  @defgroup   CLASS_B
      4           *  @brief      Basic description of file contents
      5           *
      6           *  @details    Detailed description of the file contents
      7           *
      8           *---------------------------------------------------------------------------------------------------------------------
      9           *------------------- Copyright 2012.  Whirlpool Corporation.  All rights reserved - CONFIDENTIAL ---------------------
     10           *---------------------------------------------------------------------------------------------------------------------
     11           */
     12          
     13          //-------------------------------------- Include Files ----------------------------------------------------------------
     14          #include "SRMotorSafetyMgr.h"
     15          #include "SRMotorSafetyMgr_prv.h"
     16          
     17          // Standard Safety Relevant Class B libraries
     18          #include "SRMicro.h"
     19          #include "SRData.h"
     20          #include "SRMCAtod.h"
     21          #include "SRMCPwm.h"
     22          #ifdef SR_CIM_MOTOR
     23          #include "SRMCInputCapture.h"
     24          #endif
     25          
     26          #include "Crc16.h"
     27          
     28          
     29          #ifndef SRDATA_CORRUPTION_EXCEPTION
     30              #define SRDATA_CORRUPTION_EXCEPTION(address)
     31          #endif
     32          
     33          //! Maximum value used for period counter 
     34          #define SR_MOTOR_SAFETY_MNGR_MAX_PERIOD_COUNTER		1073741824L
     35          
     36          #define OH_INIT_DEFAULT     35.0f
     37          
     38          //! Macros to update safety relevant data
     39          //! Update SR variable and its negate
     40          #define SR_MCU_MOTOR_UPDATE_VAR(var, value)   (var) = (value); (N##var) = ~((sint32)value)
     41          
     42          #define SR_MCU_MOTOR_UPDATE_N_VAR(var)        (N##var) = ~((sint32)var)
     43          
     44          
     45          
     46          //! Macros to check safety relevant data
     47          //! Check SR byte
     48          #define SR_MCU_MOTOR_CHECK_BYTE(check,var)    {auto uint8 temp_u8;  temp_u8 = (uint8)(var); check += (temp_u8 !=  (uint8)(~(sint32)(N##var)));}
     49          //! Check SR short
     50          #define SR_MCU_MOTOR_CHECK_SHORT(check,var)   {auto uint16 temp_u16;  temp_u16 = (uint16)(var); check += (temp_u16 != (uint16)(~(sint32)(N##var)));}
     51          //! Check SR long
     52          #define SR_MCU_MOTOR_CHECK_LONG(check,var)    {auto uint32 temp_u32;  temp_u32 = (uint32)(var); check += (temp_u32 != (uint32)(~(sint32)(N##var)));}
     53          
     54          // Check MACRO definitions
     55          #define SR_DATA_MCU_CHECK_BYTE(var)            SRData__CheckByte((uint8 *)&var, (uint8 *)&(N##var))
     56          #define SR_DATA_MCU_CHECK_SHORT(var)           SRData__CheckShort((uint16 *)&var, (uint16 *)&(N##var))
     57          #define SR_DATA_MCU_CHECK_LONG(var)            SRData__CheckLong((uint32 *)&var, (uint32 *)&(N##var))
     58          #define SR_DATA_MCU_CHECK_FLOAT(var)           SRData__CheckFloat((float *)&var, (float *)&(N##var))
     59          
     60          #define SR_DATA_MCU_UPDATE_BYTE(var,value)     SRData__UpdateByte((uint8 *)&var, (uint8 *)&(N##var), (uint8)(value))
     61          #define SR_DATA_MCU_UPDATE_SHORT(var,value)    SRData__UpdateShort((uint16 *)&var, (uint16 *)&(N##var), (uint16)(value))
     62          #define SR_DATA_MCU_UPDATE_LONG(var,value)     SRData__UpdateLong((uint32 *)&var, (uint32 *)&(N##var), (uint32)(value))
     63          #define SR_DATA_MCU_UPDATE_FLOAT(var,value)    SRData__UpdateFloat((float *)&var, (float *)&(N##var), (float)(value))
     64          
     65          
     66          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     67          
     68          
     69          
     70          ///////////////////////////////////////////////////////////////////////////////////////////////
     71          // UNLOCK DOOR SPEED - define routine parameters based on the user parameters
     72          #define SR_UNLOCKDOORSPEED_CURR_THRES_FIXP          (sint32)(SR_UNLOCKDOORSPEED_MIN_CURR_READ)
     73          #define SR_UNLOCKDOORSPEED_DEBOUNCING_COUNTER       (uint32)(200.0f*SR_UNLOCKDOORSPEED_DEBOUNCING_TIME)
     74          #define SR_UNLOCKDOORSPEED_FAIL_TIMER_COUNTER       (uint32)(200.0f*SR_UNLOCKDOORSPEED_FAIL_DETECTION_TIME)
     75          // CIM Motor Handler defines
     76          #define SR_UNLOCKDOORSPEED_TARGET_NOT_REACHED_TIMEOUT   (51200) // 256 seconds @ 200 Hz
     77          ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
     78          // COUNTER THRESHOLD FOR CIM MOTOR MOVING HANDLER
     79          // The Input Capture counter will be compared to this threshold in order to understand if the motor shall be considered
     80          // moving or not.
     81          #define SR_UNLOCKDOORSPEED_LOW_COUNTER_THR         (4428)  // 1270 rpm_M
     82          
     83          
     84          ///////////////////////////////////////////////////////////////////////////////////////////////
     85          // POWER UP - define routine parameters for power up routine
     86          #define SR_POWER_UP_DELAY_TIMER                     (sint16)(SR_POWER_UP_DELAY_TIME*1000.0/5.0)
     87          
     88          ///////////////////////////////////////////////////////////////////////////////////////////////
     89          // SHUT DOWN PLAUSIBILITY - define routine parameters for checking the Shut Down Pin circuitry
     90          #define SD_PIN_ZERO_TIME       (uint32)(SD_PIN_ZERO_TIME_MS/1000.0f*16000.0f)
     91          #define SD_PIN_ONE_TIME        (uint32)(SD_PIN_ONE_TIME_MS/1000.f*16000.0f)
     92          
     93          ///////////////////////////////////////////////////////////////////////////////////////////////
     94          #define SR_MAX_LONG_VARIABLE        4294967294L
     95          
     96          #define ONE_THIRD                   0.33333333333f
     97          ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
     98          // RMS INTEGRATION TIMING - define the samples amount to meet the required time for rms calculation
     99          #ifdef RMS_SAMPLING_TIME_MS
    100              #define RMS_SAMPLER_FREQUENCY           4000.0f //! rms current sampler (1/RMS_SAMPLER_FREQUENCY = 250 us)
    101              #define RMS_COUNTER_SAMPLES_AT_TS       (sint32)(((RMS_SAMPLING_TIME_MS * RMS_SAMPLER_FREQUENCY)/1000.0f)+1.0f) //
    102          #endif
    103          
    104          
    105          //! Define the states for the state machine handler
    106          typedef enum
    107          {
    108              SAFETY_MNGR_NOT_DEFINED         = 0,            //! Reserved 0 index - shall not be used
    109              SAFETY_MNGR_INITIALIZE          = 1,            //! Initialization for the state machine
    110              SAFETY_MNGR_IDLE                = 2,            //! The state machine is able to accept requests to run the pre run tests
    111              SAFETY_MNGR_PRERUN_TESTS        = 3,            //! All tests before running the motor has to be performed within this state
    112              SAFETY_MNGR_POSTRUN_TESTS       = 4,            //! Performs tests after running and before setting the unlock door speed flag
    113              SAFETY_MNGR_RUNNING             = 5,            //! This state is used when the motor is running
    114              SAFETY_MNGR_ERROR_FOUND         = 6,            //! If an error is found, the state machine shall stay in this ERROR state
    115              SAFETY_MNGR_UNLOCK_DOOR_CHECK   = 7,            //! Perform the plausibility check only once after IDLING for some time
    116          } SAFETY_MNGR_TYPE;
    117          
    118          //! Define for current offset verification
    119          typedef enum
    120          {
    121              MOTOR_ANALOG_CHECK_CURR_FAIL = 0,
    122              MOTOR_ANALOG_CHECK_VBUS_FAIL,
    123              MOTOR_ANALOG_CHECK_CORRECT,
    124              MOTOR_ANALOG_CHECK_SIZE
    125          } MOTOR_ANALOG_CHECK_TYPE;
    126          
    127          
    128          MOTOR_SAFETY_PARAMS_TYPE* SR_MotorSafety_Params;
    129          
    130          static volatile SAFETY_MNGR_TYPE SR_SafetyMngr_State;
    131          
    132          // For these variables, use the SR_MOTOR_FAULT_LIST_TYPE for the bit definition
    133          static volatile uint16 SR_Motor_Fault;
    134          static volatile uint16 SR_Motor_Fault_Holder;
    135          
    136          // For these variables, use the SR_MOTOR_FLAGS_LIST_TYPE for the bit definition
    137          static volatile uint16 SR_Motor_Flags;
    138          
    139          static volatile sint16 SR_CurrentA;
    140          static sint16 SR_CurrentOffsetA;
    141          static volatile sint32 SR_CurrentOffsetHistA;
    142          
    143          static volatile sint16 SR_CurrentB;
    144          static sint16 SR_CurrentOffsetB;
    145          static volatile sint32 SR_CurrentOffsetHistB;
    146          
    147          static volatile sint16 SR_CurrentC;
    148          static sint16 SR_CurrentOffsetC;
    149          static volatile sint32 SR_CurrentOffsetHistC;
    150          
    151          static sint16 SR_Raw_CurrentA;
    152          static sint16 SR_Raw_CurrentB;
    153          static sint16 SR_Raw_CurrentC;
    154          
    155          static volatile uint16 SR_Sector;
    156          
    157          static sint16 SR_DCBus;
    158          static volatile sint16 SR_PowerUpTimer;
    159          
    160          static volatile uint32 SR_ZeroSpeedDebouncer;
    161          static volatile uint32 SR_ZeroSpeedWithCurrTimer;
    162          static volatile sint32 SR_SquaredCurrentsSum;
    163          static volatile uint32 SR_CalibrationCntr;
    164          
    165          #ifdef SR_CIM_MOTOR
    166              // Motor Moving Handler CIM variables
    167              static volatile uint32 SR_VerifyTargetCounter;
    168          #endif
    169          
    170          static volatile sint32 SR_SquaredCurrentRmsA;
    171          static volatile sint32 SR_SquaredCurrentRmsB;
    172          static volatile sint32 SR_SquaredCurrentRmsC;
    173          static volatile sint32 SR_SquaredCurrentSumA;
    174          static volatile sint32 SR_SquaredCurrentSumB;
    175          static volatile sint32 SR_SquaredCurrentSumC;
    176          static volatile sint32 SR_Curr_Rms_Counter;
    177          
    178          
    179          static volatile uint16 SR_Phase_Lost_Counter;
    180          static volatile uint32 SR_Timeout_Failure_Retry;
    181          
    182          
    183          static volatile uint16 SR_Overheating_Counter;
    184          static volatile float SR_Overheating_Temp;
    185          
    186          static float SR_Voltage_Frequency;                  //! [rpm] motor speed - use for class A - there is no RAM check
    187          static float SR_Squared_Current;                    //! [A] squared current sum of all 3 currents - use for class A - there is no RAM check
    188          
    189          
    190          //////////////////////////////////////////////////////////
    191          //////////////////////////////////////////////////////////
    192          
    193          static volatile SAFETY_MNGR_TYPE NSR_SafetyMngr_State;
    194          static volatile uint16 NSR_Motor_Fault;
    195          static volatile uint16 NSR_Motor_Fault_Holder;
    196          
    197          static volatile uint16 NSR_Motor_Flags;
    198          
    199          static volatile sint16 NSR_CurrentA;
    200          static volatile sint16 NSR_CurrentOffsetA;
    201          static volatile sint32 NSR_CurrentOffsetHistA;
    202          
    203          static volatile sint16 NSR_CurrentB;
    204          static volatile sint16 NSR_CurrentOffsetB;
    205          static volatile sint32 NSR_CurrentOffsetHistB;
    206          
    207          static volatile sint16 NSR_CurrentC;
    208          static volatile sint16 NSR_CurrentOffsetC;
    209          static volatile sint32 NSR_CurrentOffsetHistC;
    210          
    211          static volatile sint16 NSR_Raw_CurrentA;
    212          static volatile sint16 NSR_Raw_CurrentB;
    213          static volatile sint16 NSR_Raw_CurrentC;
    214          
    215          static volatile uint16 NSR_Sector;
    216          static volatile sint16 NSR_DCBus;
    217          static volatile sint16 NSR_PowerUpTimer;
    218          
    219          static volatile uint32 NSR_ZeroSpeedDebouncer;
    220          static volatile uint32 NSR_ZeroSpeedWithCurrTimer;
    221          static volatile sint32 NSR_SquaredCurrentsSum;
    222          static volatile uint32 NSR_CalibrationCntr;
    223          
    224          #ifdef SR_CIM_MOTOR
    225              // Motor Moving Handler CIM variables
    226              static volatile uint32 NSR_VerifyTargetCounter;
    227          #endif
    228          
    229          static volatile sint32 NSR_SquaredCurrentRmsA;
    230          static volatile sint32 NSR_SquaredCurrentRmsB;
    231          static volatile sint32 NSR_SquaredCurrentRmsC;
    232          static volatile sint32 NSR_SquaredCurrentSumA;
    233          static volatile sint32 NSR_SquaredCurrentSumB;
    234          static volatile sint32 NSR_SquaredCurrentSumC;
    235          static volatile sint32 NSR_Curr_Rms_Counter;
    236          
    237          
    238          static volatile uint16 NSR_Phase_Lost_Counter;
    239          static volatile uint32 NSR_Timeout_Failure_Retry;
    240          
    241          static volatile uint16 NSR_Overheating_Counter;
    242          static volatile float NSR_Overheating_Temp;
    243          
    244          static float NSR_Squared_Current;
    245          static float NSR_Voltage_Frequency;
    246          
    247          #ifdef SR_BPM_MOTOR
    248          

   \                                 In section .rodata, align 4, keep-with-next
    249              const uint32 CHECK_UNLOCK_DOOR_SPEED_TIMEOUT_COUNTER    = (uint32)((CHECK_UNLOCK_DOOR_SPEED_TIMEOUT_TIME/1000.0f)/0.005f);
   \                     CHECK_UNLOCK_DOOR_SPEED_TIMEOUT_COUNTER:
   \   00000000   0x00000190         DC32 400

   \                                 In section .rodata, align 4, keep-with-next
    250              const uint32 CHECK_UNLOCK_DOOR_SPEED_IDLING_BEFORE_CHECK_COUNT = (uint32)((CHECK_UNLOCK_DOOR_SPEED_IDLING_BEFORE_CHECK_TIME/1000.0f)/0.005f);
   \                     CHECK_UNLOCK_DOOR_SPEED_IDLING_BEFORE_CHECK_COUNT:
   \   00000000   0x000003E8         DC32 1000

   \                                 In section .rodata, align 4, keep-with-next
    251              const sint32 CHECK_UNLOCK_DOOR_MAX_VOLTAGE_COUNTS = (sint32)CHECK_UNLOCK_DOOR_MAX_VOLTAGE_DUTY;
   \                     CHECK_UNLOCK_DOOR_MAX_VOLTAGE_COUNTS:
   \   00000000   0x000003E8         DC32 1000

   \                                 In section .rodata, align 4, keep-with-next
    252              const sint32 CHECK_UNLOCK_DOOR_MAX_VOLTAGE_DUTY_STEP_COUNTS = (sint32)CHECK_UNLOCK_DOOR_MAX_VOLTAGE_DUTY_STEP;
   \                     CHECK_UNLOCK_DOOR_MAX_VOLTAGE_DUTY_STEP_COUNTS:
   \   00000000   0x00000032         DC32 50

   \                                 In section .rodata, align 2, keep-with-next
    253              const sint16 CHECK_UNLOCK_DOOR_CURRENT_THRESHOLDS_COUNTS = (sint32)CHECK_UNLOCK_DOOR_CURRENT_THRESHOLDS;
   \                     CHECK_UNLOCK_DOOR_CURRENT_THRESHOLDS_COUNTS:
   \   00000000   0x0019             DC16 25
    254          
    255              static sint32 SR_Avg_Fund_Period_High_Threshold;            //!<PARAMETER Average frequency HIGH threshold hysteresis
    256              static sint32 SR_Avg_Fund_Period_Low_Threshold;             //!<PARAMETER Average frequency LOW threshold hysteresis
    257              static uint8 SR_Avg_Fund_Period_Cycle_Total;                //!< PARAMETER Total cycles to calculate the average
    258          
    259              static sint32 SR_Avg_Threshold;                             //!< Instantaneous hysteresis
    260              static uint8 SR_Avg_Cross_Event;                            //!< Auxiliary variable to generate the cycles counter event
    261              static uint32 SR_Avg_Fund_Period_Time_Counter;              //!< Elapsed (accumulated) time
    262              static uint32 SR_Avg_Fund_Period_Cycle_Counter;             //!< Cycle counter
    263              static sint32 SR_Applied_Duty_A_Sum;                        //!< Applied duty cycle
    264              static sint32 SR_Applied_Duty_A_Sum_High;                   //!< Applied duty cycle
    265              static uint32 SR_Avg_Fund_Period;                           //!< Averaged speed from the fundamental output voltage
    266          
    267              static uint32 SR_Check_Unlock_Door_Speed_Timer;             //!< Timer to perform the unlock door speed check after idling for some time
    268              static sint32 SR_Check_Unlock_Door_Speed_Delta_Voltage;     //!< Delta voltage in pwm counts to control the output voltage of unlock speed check
    269              static uint8 SR_Avg_Fund_Ignored_First;                     //!< Variable used to ignore first startup cycle of average frequency calculation
    270          
    271              static sint32 NSR_Avg_Fund_Period_High_Threshold;           //!<PARAMETER Average frequency HIGH threshold hysteresis
    272              static sint32 NSR_Avg_Fund_Period_Low_Threshold;            //!<PARAMETER Average frequency LOW threshold hysteresis
    273              static uint8 NSR_Avg_Fund_Period_Cycle_Total;               //!< PARAMETER Total cycles to calculate the average
    274          
    275              static sint32 NSR_Avg_Threshold;                            //!< Instantaneous hysteresis
    276              static uint8 NSR_Avg_Cross_Event;                           //!< Auxiliary variable to generate the cycles counter event
    277              static uint32 NSR_Avg_Fund_Period_Time_Counter;             //!< Elapsed (accumulated) time
    278              static uint32 NSR_Avg_Fund_Period_Cycle_Counter;            //!< Cycle counter
    279              static sint32 NSR_Applied_Duty_A_Sum;                       //!< Applied duty cycle
    280              static sint32 NSR_Applied_Duty_A_Sum_High;                  //!< Applied duty cycle
    281              static uint32 NSR_Avg_Fund_Period;                          //!< Averaged speed from the fundamental output voltage
    282              static sint32 NSR_Check_Unlock_Door_Speed_Delta_Voltage;    //!< Delta voltage in pwm counts to control the output voltage of unlock speed check
    283          
    284              static uint32 NSR_Check_Unlock_Door_Speed_Timer;            //!< Timer to perform the unlock door speed check after idling for some time
    285          
    286              static uint8 NSR_Avg_Fund_Ignored_First;                    //!< Variable used to ignore first startup cycle of average frequency calculation
    287          #endif
    288          
    289          
    290          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
    291          
    292          
    293          
    294          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
    295          uint8 CheckSafetyParameters(void);
    296          static void CheckAnalogVariables4Failure(void);
    297          static void CheckVariables4Failure_Pwm(void);
    298          static void CheckVariables4Failure_250us(void);
    299          static void CheckVariables4Failure_5ms(void);
    300          static void CheckVariables4Failure_25ms(void);
    301          static void AverageSensorsOffset(void);
    302          static void CalculateRawAnalogData_250us(void);
    303          static void CalculateRmsAnalogData(void);
    304          static void PhaseLostHandler(void);
    305          static void RcThermalUpdate(void);
    306          static void InitOverHeatingProtection(void);
    307          static void OverHeatingProtection(void);
    308          static void PeripheralDiagnostic(void);
    309          static void ClassAPwmAccess(void);
    310          static void PowerUpSensors(void);
    311          static MOTOR_ANALOG_CHECK_TYPE MotorAnalogCircuitCheck(void);
    312          static uint8 CheckHwFaultStatus(void);
    313          static void OverVoltageCheck(void);
    314          static void OverVoltageProtection(void);
    315          static void CheckCurrentsPlausibility(void);
    316          static void Init_Avg_Frequency(void);
    317          static void Calc_Avg_Frequency(void);
    318          static void Check_Avg_Frequency(void);
    319          static void SetFault(uint16 fault);
    320          static void ClearFault(uint16 fault);
    321          
    322          #ifdef SR_THIRD_CURRENT_RECONSTRUCTION
    323          static void UpdateAdcConfig(void);
    324          #endif
    325          
    326          
    327          #ifdef SR_CIM_MOTOR
    328          
    329              static void InitMotorMovingHandlerCim(void);
    330              static void MotorMovingHandlerCim(void);
    331              static void InputCapturePlausibilityHandler(void);
    332          
    333              #define SR_MOTORSAFETY_MGR_POWERUP_ACTION()             SRMCPwm__TurnOffAllGates()
    334              #define SR_MOTORSAFETY_MGR_ERROR_REACTION()             SRMCPwm__TurnOffAllGates()
    335              #define SR_MOTORSAFETY_MGR_POSTRUN_ACTION()             SRMCPwm__TurnOffAllGates()
    336              #define SR_INITMOTORMOVINGHANDLER()                     InitMotorMovingHandlerCim()
    337              #define SR_MOTORMOVINGHANDLER()                         MotorMovingHandlerCim()
    338              #define SR_INPUTCAPTUREPLAUSIBILITYHANDLER()            InputCapturePlausibilityHandler()
    339          
    340          #endif
    341          
    342          #ifdef SR_BPM_MOTOR
    343          
    344              static void UpdatePwm(sint32 duty_a, sint32 duty_b, sint32 duty_c);
    345              static void InitMotorMovingHandlerBpm(void);
    346              static void MotorMovingHandlerBpm(void);
    347          
    348              #define SR_INITMOTORMOVINGHANDLER()                     InitMotorMovingHandlerBpm()
    349              #define SR_MOTORMOVINGHANDLER()                         MotorMovingHandlerBpm()
    350              #define SR_INPUTCAPTUREPLAUSIBILITYHANDLER()
    351          
    352          #endif
    353          
    354          #ifndef SR_MOTORSAFETY_MGR_POWERUP_ACTION
    355              #define SR_MOTORSAFETY_MGR_POWERUP_ACTION()             SRMCPwm__TurnOnLowSideGates()
    356          #endif
    357          #ifndef SR_MOTORSAFETY_MGR_ERROR_REACTION
    358              #define SR_MOTORSAFETY_MGR_ERROR_REACTION()             SRMCPwm__TurnOnLowSideGates()
    359          #endif
    360          #ifndef SR_MOTORSAFETY_MGR_POSTRUN_ACTION
    361              #define SR_MOTORSAFETY_MGR_POSTRUN_ACTION()             SRMCPwm__TurnOnLowSideGates()
    362          #endif
    363          
    364          #ifndef SRMOTOR_RUNNING_PWM
    365              #define SRMOTOR_RUNNING_PWM()
    366          #endif
    367          
    368          #ifndef SR_MODULATION_LIMIT
    369              #define SR_MODULATION_LIMIT  1.0f
    370          #endif
    371          
    372          
    373          //=====================================================================================================================
    374          //-------------------------------------- Public Functions -------------------------------------------------------------
    375          //=====================================================================================================================
    376          
    377          //---------------------------------------------------------------------------------------------------------------------
    378          /**
    379           *  @brief      Initialize all protection submodule. This shall be a part of the whole class B protection.
    380           *              This shall be called once, when the processor is powering up or recovering from a reset.
    381           *
    382           *
    383           */

   \                                 In section .text, align 4, keep-with-next
    384          void SRMotorSafetyMgr__Initialize(void)
    385          {
   \                     SRMotorSafetyMgr__Initialize: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    386              uint16 temp;
    387          
    388              SRMOTORSAFETYMGR_FLOW_INITIALIZE_BEGIN();
   \   00000004   0x2003             MOVS     R0,#+3
   \   00000006   0x.... 0x....      BL       SRFlow__InitLogEvent
    389          
    390          
    391              SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Fault,0);
   \   0000000A   0x.... 0x....      LDR.W    R4,??DataTable167_8
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0xF504 0x7171      ADD      R1,R4,#+964
   \   00000014   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   00000018   0x.... 0x....      BL       SRData__UpdateShort
    392              SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Fault_Holder,0);
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0xF504 0x61B2      ADD      R1,R4,#+1424
   \   00000022   0xF504 0x7069      ADD      R0,R4,#+932
   \   00000026   0x.... 0x....      BL       SRData__UpdateShort
    393          
    394              SR_Motor_Flags = 0;                             // Due to warm reset possibility, this variable needs to be manually zeroed.
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xF8A4 0x03A6      STRH     R0,[R4, #+934]
   \   00000030   0xF64F 0x11FD      MOVW     R1,#+63997
    395              temp = SR_Motor_Flags;
   \   00000034   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
    396              BIT_CLR(temp, SR_FLAG_CLASS_A_PWM_ACCESS);      // Deny the access to the pwm peripheral
    397              BIT_SET(temp, SR_FLAG_MICRO_POWERING_UP);       // Warn the protection handler that the micro is powering up...
    398              BIT_CLR(temp, SR_FLAG_UNLOCK_DOOR_SPEED_CHECK_REQUESTED); // Request to check unlock door speed after IDLE
    399              BIT_CLR(temp, SR_FLAG_MC_PARAMETERS_LOADED);    // Reset the motor control parameters loaded flag
    400              SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,temp);
   \   00000038   0x4008             ANDS     R0,R1,R0
   \   0000003A   0xF040 0x0220      ORR      R2,R0,#0x20
   \   0000003E   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000042   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000046   0x.... 0x....      BL       SRData__UpdateShort
    401          
    402              SR_DATA_MCU_UPDATE_BYTE(SR_SafetyMngr_State,SAFETY_MNGR_INITIALIZE);   // Send the motor safety state machine to the initialize state
   \   0000004A   0x2201             MOVS     R2,#+1
   \   0000004C   0xF204 0x3173      ADDW     R1,R4,#+883
   \   00000050   0xF204 0x3072      ADDW     R0,R4,#+882
   \   00000054   0x.... 0x....      BL       SRData__UpdateByte
    403              SR_INITMOTORMOVINGHANDLER();                    // Initialize the zero speed handler
   \   00000058   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   0000005C   0xF64F 0x71FE      MOVW     R1,#+65534
   \   00000060   0xEA01 0x0200      AND      R2,R1,R0
   \   00000064   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000068   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   0000006C   0x.... 0x....      BL       SRData__UpdateShort
   \   00000070   0x2200             MOVS     R2,#+0
   \   00000072   0xF504 0x61F9      ADD      R1,R4,#+1992
   \   00000076   0xF204 0x5004      ADDW     R0,R4,#+1284
   \   0000007A   0x.... 0x....      BL       SRData__UpdateLong
   \   0000007E   0x2200             MOVS     R2,#+0
   \   00000080   0xF204 0x71C4      ADDW     R1,R4,#+1988
   \   00000084   0xF504 0x60A0      ADD      R0,R4,#+1280
   \   00000088   0x.... 0x....      BL       SRData__UpdateLong
    404          
    405          
    406              // Initialize the over current (locked rotor and running overloaded) sub module
    407              SR_DATA_MCU_UPDATE_LONG(SR_SquaredCurrentsSum,2*SR_POWERING_UP_CURRENTS_THRESHOLD); // Initialize to a higher value than the comparison threshold,
   \   0000008C   0x2214             MOVS     R2,#+20
   \   0000008E   0xF204 0x71CC      ADDW     R1,R4,#+1996
   \   00000092   0xF504 0x60A1      ADD      R0,R4,#+1288
   \   00000096   0x.... 0x....      BL       SRData__UpdateLong
    408              // to prevent any wrong decision before finishing the powering up
    409          
    410              SR_DATA_MCU_UPDATE_SHORT(SR_Raw_CurrentA,0);            // Consider the raw phase current as zero
   \   0000009A   0x2200             MOVS     R2,#+0
   \   0000009C   0xF504 0x7175      ADD      R1,R4,#+980
   \   000000A0   0xF504 0x706D      ADD      R0,R4,#+948
   \   000000A4   0x.... 0x....      BL       SRData__UpdateShort
    411              SR_DATA_MCU_UPDATE_SHORT(SR_Raw_CurrentB,0);            // Consider the raw phase current as zero
   \   000000A8   0x2200             MOVS     R2,#+0
   \   000000AA   0xF204 0x31D6      ADDW     R1,R4,#+982
   \   000000AE   0xF204 0x30B6      ADDW     R0,R4,#+950
   \   000000B2   0x.... 0x....      BL       SRData__UpdateShort
    412              SR_DATA_MCU_UPDATE_SHORT(SR_Raw_CurrentC,0);            // Consider the raw phase current as zero
   \   000000B6   0x2200             MOVS     R2,#+0
   \   000000B8   0xF504 0x7176      ADD      R1,R4,#+984
   \   000000BC   0xF504 0x706E      ADD      R0,R4,#+952
   \   000000C0   0x.... 0x....      BL       SRData__UpdateShort
    413              SR_DATA_MCU_UPDATE_SHORT(SR_CurrentA,0);                // Consider the phase current as zero
   \   000000C4   0x2200             MOVS     R2,#+0
   \   000000C6   0xF504 0x7172      ADD      R1,R4,#+968
   \   000000CA   0xF504 0x706A      ADD      R0,R4,#+936
   \   000000CE   0x.... 0x....      BL       SRData__UpdateShort
    414              SR_DATA_MCU_UPDATE_SHORT(SR_CurrentB,0);                // Consider the phase current as zero
   \   000000D2   0x2200             MOVS     R2,#+0
   \   000000D4   0xF504 0x7173      ADD      R1,R4,#+972
   \   000000D8   0xF504 0x706B      ADD      R0,R4,#+940
   \   000000DC   0x.... 0x....      BL       SRData__UpdateShort
    415              SR_DATA_MCU_UPDATE_SHORT(SR_CurrentC,0);                // Consider the phase current as zero
   \   000000E0   0x2200             MOVS     R2,#+0
   \   000000E2   0xF504 0x7174      ADD      R1,R4,#+976
   \   000000E6   0xF504 0x706C      ADD      R0,R4,#+944
   \   000000EA   0x.... 0x....      BL       SRData__UpdateShort
    416              SR_DATA_MCU_UPDATE_SHORT(SR_CurrentOffsetA,0);          // Reset the offset information
   \   000000EE   0x2200             MOVS     R2,#+0
   \   000000F0   0xF204 0x31CA      ADDW     R1,R4,#+970
   \   000000F4   0xF204 0x30AA      ADDW     R0,R4,#+938
   \   000000F8   0x.... 0x....      BL       SRData__UpdateShort
    417              SR_DATA_MCU_UPDATE_SHORT(SR_CurrentOffsetB,0);          // Reset the offset information
   \   000000FC   0x2200             MOVS     R2,#+0
   \   000000FE   0xF204 0x31CE      ADDW     R1,R4,#+974
   \   00000102   0xF204 0x30AE      ADDW     R0,R4,#+942
   \   00000106   0x.... 0x....      BL       SRData__UpdateShort
    418              SR_DATA_MCU_UPDATE_SHORT(SR_CurrentOffsetC,0);          // Reset the offset information
   \   0000010A   0x2200             MOVS     R2,#+0
   \   0000010C   0xF204 0x31D2      ADDW     R1,R4,#+978
   \   00000110   0xF204 0x30B2      ADDW     R0,R4,#+946
   \   00000114   0x.... 0x....      BL       SRData__UpdateShort
    419              SR_DATA_MCU_UPDATE_SHORT(SR_Sector,0);
   \   00000118   0x2200             MOVS     R2,#+0
   \   0000011A   0xF204 0x31DA      ADDW     R1,R4,#+986
   \   0000011E   0xF204 0x30BA      ADDW     R0,R4,#+954
   \   00000122   0x.... 0x....      BL       SRData__UpdateShort
    420              SR_DATA_MCU_UPDATE_LONG(SR_CurrentOffsetHistA,0);       // Reset the offset history (filter) information
   \   00000126   0x2200             MOVS     R2,#+0
   \   00000128   0xF504 0x61F7      ADD      R1,R4,#+1976
   \   0000012C   0xF204 0x40F4      ADDW     R0,R4,#+1268
   \   00000130   0x.... 0x....      BL       SRData__UpdateLong
    421              SR_DATA_MCU_UPDATE_LONG(SR_CurrentOffsetHistB,0);       // Reset the offset history (filter) information
   \   00000134   0x2200             MOVS     R2,#+0
   \   00000136   0xF204 0x71BC      ADDW     R1,R4,#+1980
   \   0000013A   0xF504 0x609F      ADD      R0,R4,#+1272
   \   0000013E   0x.... 0x....      BL       SRData__UpdateLong
    422              SR_DATA_MCU_UPDATE_LONG(SR_CurrentOffsetHistC,0);       // Reset the offset history (filter) information
   \   00000142   0x2200             MOVS     R2,#+0
   \   00000144   0xF504 0x61F8      ADD      R1,R4,#+1984
   \   00000148   0xF204 0x40FC      ADDW     R0,R4,#+1276
   \   0000014C   0x.... 0x....      BL       SRData__UpdateLong
    423              SR_DATA_MCU_UPDATE_SHORT(SR_DCBus,0);                   // Consider as the DC voltage as zero
   \   00000150   0x2200             MOVS     R2,#+0
   \   00000152   0xF504 0x7177      ADD      R1,R4,#+988
   \   00000156   0xF504 0x706F      ADD      R0,R4,#+956
   \   0000015A   0x.... 0x....      BL       SRData__UpdateShort
    424              SR_DATA_MCU_UPDATE_SHORT(SR_PowerUpTimer,0);            // Zero the power up timer
   \   0000015E   0x2200             MOVS     R2,#+0
   \   00000160   0xF204 0x5192      ADDW     R1,R4,#+1426
   \   00000164   0xF204 0x30BE      ADDW     R0,R4,#+958
   \   00000168   0x.... 0x....      BL       SRData__UpdateShort
    425              SR_DATA_MCU_UPDATE_LONG(SR_CalibrationCntr,0);
   \   0000016C   0x2200             MOVS     R2,#+0
   \   0000016E   0xF504 0x61FA      ADD      R1,R4,#+2000
   \   00000172   0xF204 0x500C      ADDW     R0,R4,#+1292
   \   00000176   0x.... 0x....      BL       SRData__UpdateLong
    426              SR_DATA_MCU_UPDATE_LONG(SR_SquaredCurrentRmsA,0);       // Reset the current A rms calculated value
   \   0000017A   0x2200             MOVS     R2,#+0
   \   0000017C   0xF204 0x71D4      ADDW     R1,R4,#+2004
   \   00000180   0xF504 0x60A2      ADD      R0,R4,#+1296
   \   00000184   0x.... 0x....      BL       SRData__UpdateLong
    427              SR_DATA_MCU_UPDATE_LONG(SR_SquaredCurrentRmsB,0);       // Reset the current B rms calculated value
   \   00000188   0x2200             MOVS     R2,#+0
   \   0000018A   0xF504 0x61FB      ADD      R1,R4,#+2008
   \   0000018E   0xF204 0x5014      ADDW     R0,R4,#+1300
   \   00000192   0x.... 0x....      BL       SRData__UpdateLong
    428              SR_DATA_MCU_UPDATE_LONG(SR_SquaredCurrentRmsC,0);       // Reset the current C rms calculated value
   \   00000196   0x2200             MOVS     R2,#+0
   \   00000198   0xF204 0x71DC      ADDW     R1,R4,#+2012
   \   0000019C   0xF504 0x60A3      ADD      R0,R4,#+1304
   \   000001A0   0x.... 0x....      BL       SRData__UpdateLong
    429              SR_DATA_MCU_UPDATE_LONG(SR_SquaredCurrentSumA,0);       // Reset the current A rms accumulator
   \   000001A4   0x2200             MOVS     R2,#+0
   \   000001A6   0xF504 0x61FC      ADD      R1,R4,#+2016
   \   000001AA   0xF204 0x501C      ADDW     R0,R4,#+1308
   \   000001AE   0x.... 0x....      BL       SRData__UpdateLong
    430              SR_DATA_MCU_UPDATE_LONG(SR_SquaredCurrentSumB,0);       // Reset the current B rms accumulator
   \   000001B2   0x2200             MOVS     R2,#+0
   \   000001B4   0xF204 0x71E4      ADDW     R1,R4,#+2020
   \   000001B8   0xF504 0x60A4      ADD      R0,R4,#+1312
   \   000001BC   0x.... 0x....      BL       SRData__UpdateLong
    431              SR_DATA_MCU_UPDATE_LONG(SR_SquaredCurrentSumC,0);       // Reset the current C rms accumulator
   \   000001C0   0x2200             MOVS     R2,#+0
   \   000001C2   0xF504 0x61FD      ADD      R1,R4,#+2024
   \   000001C6   0xF204 0x5024      ADDW     R0,R4,#+1316
   \   000001CA   0x.... 0x....      BL       SRData__UpdateLong
    432              SR_DATA_MCU_UPDATE_LONG(SR_Curr_Rms_Counter,0);
   \   000001CE   0x2200             MOVS     R2,#+0
   \   000001D0   0xF204 0x71EC      ADDW     R1,R4,#+2028
   \   000001D4   0xF504 0x60A5      ADD      R0,R4,#+1320
   \   000001D8   0x.... 0x....      BL       SRData__UpdateLong
    433              SR_DATA_MCU_UPDATE_SHORT(SR_Phase_Lost_Counter,0);
   \   000001DC   0x2200             MOVS     R2,#+0
   \   000001DE   0xF204 0x5194      ADDW     R1,R4,#+1428
   \   000001E2   0xF504 0x7070      ADD      R0,R4,#+960
   \   000001E6   0x.... 0x....      BL       SRData__UpdateShort
    434              SR_DATA_MCU_UPDATE_LONG(SR_Timeout_Failure_Retry,0);    // Update the time out to zero
   \   000001EA   0x2200             MOVS     R2,#+0
   \   000001EC   0xF504 0x61FE      ADD      R1,R4,#+2032
   \   000001F0   0xF204 0x502C      ADDW     R0,R4,#+1324
   \   000001F4   0x.... 0x....      BL       SRData__UpdateLong
    435          
    436          
    437          #ifdef SR_BPM_MOTOR
    438          
    439              SR_MCU_MOTOR_UPDATE_VAR(SR_Check_Unlock_Door_Speed_Timer, 0);
                     ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \   000001F8   0x2000             MOVS     R0,#+0
   \   000001FA   0xF8C4 0x055C      STR      R0,[R4, #+1372]
    440              SR_MCU_MOTOR_UPDATE_VAR(SR_Check_Unlock_Door_Speed_Delta_Voltage, 0);
   \   000001FE   0x2100             MOVS     R1,#+0
   \   00000200   0xF04F 0x30FF      MOV      R0,#-1
   \   00000204   0xF8C4 0x0584      STR      R0,[R4, #+1412]
   \   00000208   0xF8C4 0x0580      STR      R0,[R4, #+1408]
    441              SR_MCU_MOTOR_UPDATE_VAR(SR_Avg_Fund_Period_Time_Counter, 0);
                     ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \   0000020C   0xF8C4 0x0570      STR      R0,[R4, #+1392]
    442              SR_MCU_MOTOR_UPDATE_VAR(SR_Avg_Fund_Period_Cycle_Counter, 0);
                     ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \   00000210   0xF8C4 0x0574      STR      R0,[R4, #+1396]
    443              SR_MCU_MOTOR_UPDATE_VAR(SR_Applied_Duty_A_Sum, 0);
   \   00000214   0xF8C4 0x0578      STR      R0,[R4, #+1400]
    444              SR_MCU_MOTOR_UPDATE_VAR(SR_Avg_Threshold, 0);
   \   00000218   0xF8C4 0x056C      STR      R0,[R4, #+1388]
    445              SR_MCU_MOTOR_UPDATE_VAR(SR_Avg_Fund_Period_Low_Threshold, 0);
   \   0000021C   0xF8C4 0x0568      STR      R0,[R4, #+1384]
    446              SR_MCU_MOTOR_UPDATE_VAR(SR_Avg_Fund_Period_High_Threshold, 0);
   \   00000220   0xF8C4 0x0564      STR      R0,[R4, #+1380]
   \   00000224   0xF8C4 0x1560      STR      R1,[R4, #+1376]
    447              SR_MCU_MOTOR_UPDATE_VAR(SR_Avg_Cross_Event, 0);
                     ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \   00000228   0x20FF             MOVS     R0,#+255
   \   0000022A   0xF884 0x0378      STRB     R0,[R4, #+888]
   \   0000022E   0xF8C4 0x1548      STR      R1,[R4, #+1352]
    448              SR_MCU_MOTOR_UPDATE_VAR(SR_Avg_Fund_Period_Cycle_Total, AVG_FREQUENCY_TOTAL_CYCLES);
                     ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \   00000232   0x2014             MOVS     R0,#+20
   \   00000234   0xF884 0x0374      STRB     R0,[R4, #+884]
   \   00000238   0xF8C4 0x154C      STR      R1,[R4, #+1356]
   \   0000023C   0x20EB             MOVS     R0,#+235
   \   0000023E   0xF884 0x0377      STRB     R0,[R4, #+887]
   \   00000242   0xF8C4 0x1550      STR      R1,[R4, #+1360]
    449              SR_MCU_MOTOR_UPDATE_VAR(SR_Avg_Fund_Period, SR_MOTOR_SAFETY_MNGR_MAX_PERIOD_COUNTER);
                     ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \   00000246   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000024A   0xF8C4 0x0558      STR      R0,[R4, #+1368]
   \   0000024E   0xF8C4 0x1544      STR      R1,[R4, #+1348]
   \   00000252   0xF06F 0x4080      MVN      R0,#+1073741824
   \   00000256   0xF8C4 0x1540      STR      R1,[R4, #+1344]
   \   0000025A   0xF8C4 0x153C      STR      R1,[R4, #+1340]
   \   0000025E   0xF884 0x1375      STRB     R1,[R4, #+885]
   \   00000262   0xF8C4 0x057C      STR      R0,[R4, #+1404]
    450          
    451              SR_DATA_MCU_UPDATE_BYTE(SR_Avg_Fund_Ignored_First, FALSE);
   \   00000266   0x2200             MOVS     R2,#+0
   \   00000268   0xF204 0x518C      ADDW     R1,R4,#+1420
   \   0000026C   0xF204 0x3076      ADDW     R0,R4,#+886
   \   00000270   0x.... 0x....      BL       SRData__UpdateByte
    452          
    453              SR_DATA_MCU_UPDATE_FLOAT(SR_Voltage_Frequency, 0.0f);
   \   00000274   0xED9F 0x....      VLDR.W   S0,??DataTable167_5  ;; 0x0
   \   00000278   0xF204 0x71FC      ADDW     R1,R4,#+2044
   \   0000027C   0xF204 0x5034      ADDW     R0,R4,#+1332
   \   00000280   0x.... 0x....      BL       SRData__UpdateFloat
    454              SR_DATA_MCU_UPDATE_FLOAT(SR_Overheating_Temp,OH_INIT_DEFAULT); // Init the overheating temperature [default value]
   \   00000284   0xED9F 0x....      VLDR.W   S0,??DataTable167_6  ;; 0x420c0000
   \   00000288   0xF204 0x71F4      ADDW     R1,R4,#+2036
   \   0000028C   0xF504 0x60A6      ADD      R0,R4,#+1328
   \   00000290   0x.... 0x....      BL       SRData__UpdateFloat
    455              SR_DATA_MCU_UPDATE_FLOAT(SR_Squared_Current, 0.0f);
   \   00000294   0xED9F 0x....      VLDR.W   S0,??DataTable167_5  ;; 0x0
   \   00000298   0xF504 0x61FF      ADD      R1,R4,#+2040
   \   0000029C   0xF504 0x60A7      ADD      R0,R4,#+1336
   \   000002A0   0x.... 0x....      BL       SRData__UpdateFloat
    456          
    457          #endif
    458          
    459          
    460              SR_MOTORSAFETY_MGR_SERVICE_WATCHDOG_STARTUP();
    461              // Initialize Class A module before framework start up
    462              INVOKE_CLASS_A_INIT_HANDLER();
   \   000002A4   0x.... 0x....      BL       Mci__Initialize
    463              // Initialize the SR Class B MCAtod module - required to initialize the MC Atod before MC Pwm.
    464              SRMCAtod__Initialize();
   \   000002A8   0x.... 0x....      BL       SRMCAtod__Initialize
    465          
    466              // Initialize the SR Class B Pwm module
    467              SRMCPwm__Initialize(SR_PWM_FREQUENCY_HZ, SR_PWM_DEADTIME_NS);
   \   000002AC   0xF44F 0x717A      MOV      R1,#+1000
   \   000002B0   0xF44F 0x507A      MOV      R0,#+16000
   \   000002B4   0x.... 0x....      BL       SRMCPwm__Initialize
    468              SR_MOTORSAFETY_MGR_POWERUP_ACTION();
   \   000002B8   0x....             LDR.N    R5,??DataTable167_9  ;; 0x40038000
   \   000002BA   0x2000             MOVS     R0,#+0
   \   000002BC   0x63A8             STR      R0,[R5, #+56]
   \   000002BE   0x6328             STR      R0,[R5, #+48]
   \   000002C0   0x62A8             STR      R0,[R5, #+40]
   \   000002C2   0x6228             STR      R0,[R5, #+32]
   \   000002C4   0x61A8             STR      R0,[R5, #+24]
   \   000002C6   0x6128             STR      R0,[R5, #+16]
    469              SRMCPwm__StartCounter();
    470          
    471          
    472          #ifdef SR_BPM_MOTOR
    473          
    474              Init_Avg_Frequency();
   \   000002C8   0xF504 0x715E      ADD      R1,R4,#+888
   \   000002CC   0xF44F 0x7000      MOV      R0,#+512
   \   000002D0   0xF8C5 0x0098      STR      R0,[R5, #+152]
   \   000002D4   0x6E28             LDR      R0,[R5, #+96]
   \   000002D6   0x0980             LSRS     R0,R0,#+6
   \   000002D8   0x0180             LSLS     R0,R0,#+6
   \   000002DA   0x6628             STR      R0,[R5, #+96]
   \   000002DC   0x6D68             LDR      R0,[R5, #+84]
   \   000002DE   0xF040 0x0004      ORR      R0,R0,#0x4
   \   000002E2   0x6568             STR      R0,[R5, #+84]
   \   000002E4   0x6828             LDR      R0,[R5, #+0]
   \   000002E6   0xF040 0x0008      ORR      R0,R0,#0x8
   \   000002EA   0x6028             STR      R0,[R5, #+0]
   \   000002EC   0x6F68             LDR      R0,[R5, #+116]
   \   000002EE   0xF040 0x0040      ORR      R0,R0,#0x40
   \   000002F2   0x6768             STR      R0,[R5, #+116]
   \   000002F4   0xF204 0x3075      ADDW     R0,R4,#+885
   \   000002F8   0x.... 0x....      BL       SRData__CheckByte
   \   000002FC   0xF204 0x5164      ADDW     R1,R4,#+1380
   \   00000300   0xF204 0x503C      ADDW     R0,R4,#+1340
   \   00000304   0x.... 0x....      BL       SRData__CheckLong
   \   00000308   0xF504 0x61AD      ADD      R1,R4,#+1384
   \   0000030C   0xF504 0x60A8      ADD      R0,R4,#+1344
   \   00000310   0x.... 0x....      BL       SRData__CheckLong
   \   00000314   0xF204 0x516C      ADDW     R1,R4,#+1388
   \   00000318   0xF204 0x5044      ADDW     R0,R4,#+1348
   \   0000031C   0x.... 0x....      BL       SRData__CheckLong
   \   00000320   0xF504 0x61AE      ADD      R1,R4,#+1392
   \   00000324   0xF504 0x60A9      ADD      R0,R4,#+1352
   \   00000328   0x.... 0x....      BL       SRData__CheckLong
   \   0000032C   0xF204 0x5174      ADDW     R1,R4,#+1396
   \   00000330   0xF204 0x504C      ADDW     R0,R4,#+1356
   \   00000334   0x.... 0x....      BL       SRData__CheckLong
   \   00000338   0xF204 0x517C      ADDW     R1,R4,#+1404
   \   0000033C   0xF504 0x60AB      ADD      R0,R4,#+1368
   \   00000340   0x.... 0x....      BL       SRData__CheckLong
   \   00000344   0xF504 0x61AF      ADD      R1,R4,#+1400
   \   00000348   0xF504 0x60AA      ADD      R0,R4,#+1360
   \   0000034C   0x.... 0x....      BL       SRData__CheckLong
   \   00000350   0xF204 0x518C      ADDW     R1,R4,#+1420
   \   00000354   0xF204 0x3076      ADDW     R0,R4,#+886
   \   00000358   0x.... 0x....      BL       SRData__CheckByte
   \   0000035C   0x68A8             LDR      R0,[R5, #+8]
   \   0000035E   0x1C40             ADDS     R0,R0,#+1
   \   00000360   0xEE00 0x0A10      VMOV     S0,R0
   \   00000364   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000368   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000036C   0xEE10 0x0A10      VMOV     R0,S0
   \   00000370   0x1040             ASRS     R0,R0,#+1
   \   00000372   0xEE00 0x0A10      VMOV     S0,R0
   \   00000376   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000037A   0xEDDF 0x....      VLDR.W   S1,??DataTable167_10  ;; 0x3f866666
   \   0000037E   0xEE60 0x0A20      VMUL.F32 S1,S0,S1
   \   00000382   0xF204 0x503C      ADDW     R0,R4,#+1340
   \   00000386   0xEEFD 0x0AE0      VCVT.S32.F32 S1,S1
   \   0000038A   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
   \   0000038E   0xED9F 0x....      VLDR.W   S2,??DataTable167_11  ;; 0x3f733333
   \   00000392   0xEE20 0x0A01      VMUL.F32 S0,S0,S2
   \   00000396   0xF204 0x5040      ADDW     R0,R4,#+1344
   \   0000039A   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000039E   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   000003A2   0xEE10 0x2A90      VMOV     R2,S1
   \   000003A6   0xF204 0x5164      ADDW     R1,R4,#+1380
   \   000003AA   0xF204 0x503C      ADDW     R0,R4,#+1340
   \   000003AE   0x.... 0x....      BL       SRData__UpdateLong
   \   000003B2   0xF8D4 0x2540      LDR      R2,[R4, #+1344]
   \   000003B6   0xF504 0x61AD      ADD      R1,R4,#+1384
   \   000003BA   0xF504 0x60A8      ADD      R0,R4,#+1344
   \   000003BE   0x.... 0x....      BL       SRData__UpdateLong
   \   000003C2   0xF8D4 0x2540      LDR      R2,[R4, #+1344]
   \   000003C6   0xF204 0x516C      ADDW     R1,R4,#+1388
   \   000003CA   0xF204 0x5044      ADDW     R0,R4,#+1348
   \   000003CE   0x.... 0x....      BL       SRData__UpdateLong
   \   000003D2   0x2200             MOVS     R2,#+0
   \   000003D4   0xF504 0x715E      ADD      R1,R4,#+888
   \   000003D8   0xF204 0x3075      ADDW     R0,R4,#+885
   \   000003DC   0x.... 0x....      BL       SRData__UpdateByte
   \   000003E0   0x2200             MOVS     R2,#+0
   \   000003E2   0xF504 0x61AE      ADD      R1,R4,#+1392
   \   000003E6   0xF504 0x60A9      ADD      R0,R4,#+1352
   \   000003EA   0x.... 0x....      BL       SRData__UpdateLong
   \   000003EE   0xF04F 0x4280      MOV      R2,#+1073741824
   \   000003F2   0xF204 0x5174      ADDW     R1,R4,#+1396
   \   000003F6   0xF204 0x504C      ADDW     R0,R4,#+1356
   \   000003FA   0x.... 0x....      BL       SRData__UpdateLong
   \   000003FE   0xF04F 0x4280      MOV      R2,#+1073741824
   \   00000402   0xF204 0x517C      ADDW     R1,R4,#+1404
   \   00000406   0xF504 0x60AB      ADD      R0,R4,#+1368
   \   0000040A   0x.... 0x....      BL       SRData__UpdateLong
   \   0000040E   0x2200             MOVS     R2,#+0
   \   00000410   0xF504 0x61AF      ADD      R1,R4,#+1400
   \   00000414   0xF504 0x60AA      ADD      R0,R4,#+1360
   \   00000418   0x.... 0x....      BL       SRData__UpdateLong
   \   0000041C   0x2200             MOVS     R2,#+0
   \   0000041E   0xF504 0x6100      ADD      R1,R4,#+2048
   \   00000422   0xF204 0x5054      ADDW     R0,R4,#+1364
   \   00000426   0x.... 0x....      BL       SRData__UpdateLong
   \   0000042A   0x2200             MOVS     R2,#+0
   \   0000042C   0xF204 0x518C      ADDW     R1,R4,#+1420
   \   00000430   0xF204 0x3076      ADDW     R0,R4,#+886
   \   00000434   0x.... 0x....      BL       SRData__UpdateByte
    475          
    476          #endif
    477          
    478              // Initialize the SR Flow control module
    479              SRMOTORSAFETYMGR_FLOW_INITIALIZE_END();
   \   00000438   0xB001             ADD      SP,SP,#+4
   \   0000043A   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   0000043E   0x2004             MOVS     R0,#+4
   \   00000440   0x.... 0x....      B.W      SRFlow__InitLogEvent
    480          }
    481          
    482          
    483          
    484          //---------------------------------------------------------------------------------------------------------------------
    485          /**
    486           *  @brief      Class B MCPwm Handler (same rate as the MCPwm period)
    487           *
    488           */

   \                                 In section .text, align 2, keep-with-next
    489          void SRMotorSafetyMgr__MCPwmHandler(void)
    490          {
   \                     SRMotorSafetyMgr__MCPwmHandler: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
    491          #if (defined SRMOTOR_RUNNING_2ND_PWM)
    492              static unsigned char pwm_post_scaler = 0;
    493          #endif
    494          
    495              register sint16 current_ia;
    496              register sint16 current_ib;
    497              register sint16 current_ic;
    498              register sint16 dc_bus;
    499          
    500              SRMOTORSAFETYMGR_ISRMONITOR_MCPWM_HANDLER_BEGIN();
   \   00000004   0x.... 0x....      BL       SRIsrMonitor__EnterIsr
    501          
    502              // Safety variables check
    503              CheckVariables4Failure_Pwm();
   \   00000008   0x.... 0x....      LDR.W    R8,??DataTable169
   \   0000000C   0xF898 0x1372      LDRB     R1,[R8, #+882]
   \   00000010   0xF898 0x2373      LDRB     R2,[R8, #+883]
   \   00000014   0x43D2             MVNS     R2,R2
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xB2D2             UXTB     R2,R2
   \   0000001A   0x4291             CMP      R1,R2
   \   0000001C   0xBF18             IT       NE 
   \   0000001E   0x2001             MOVNE    R0,#+1
   \   00000020   0xF8B8 0x13A6      LDRH     R1,[R8, #+934]
   \   00000024   0xF8B8 0x23C6      LDRH     R2,[R8, #+966]
   \   00000028   0x43D2             MVNS     R2,R2
   \   0000002A   0xB292             UXTH     R2,R2
   \   0000002C   0x4291             CMP      R1,R2
   \   0000002E   0xBF18             IT       NE 
   \   00000030   0x1C40             ADDNE    R0,R0,#+1
   \   00000032   0xF8B8 0x13A2      LDRH     R1,[R8, #+930]
   \   00000036   0xF8B8 0x23C4      LDRH     R2,[R8, #+964]
   \   0000003A   0x43D2             MVNS     R2,R2
   \   0000003C   0xB292             UXTH     R2,R2
   \   0000003E   0x4291             CMP      R1,R2
   \   00000040   0xBF18             IT       NE 
   \   00000042   0x1C40             ADDNE    R0,R0,#+1
   \   00000044   0xF9B8 0x13B4      LDRSH    R1,[R8, #+948]
   \   00000048   0xF9B8 0x23D4      LDRSH    R2,[R8, #+980]
   \   0000004C   0x43D2             MVNS     R2,R2
   \   0000004E   0xB289             UXTH     R1,R1
   \   00000050   0xB292             UXTH     R2,R2
   \   00000052   0x4291             CMP      R1,R2
   \   00000054   0xBF18             IT       NE 
   \   00000056   0x1C40             ADDNE    R0,R0,#+1
   \   00000058   0xF9B8 0x13B6      LDRSH    R1,[R8, #+950]
   \   0000005C   0xF9B8 0x23D6      LDRSH    R2,[R8, #+982]
   \   00000060   0x43D2             MVNS     R2,R2
   \   00000062   0xB289             UXTH     R1,R1
   \   00000064   0xB292             UXTH     R2,R2
   \   00000066   0x4291             CMP      R1,R2
   \   00000068   0xBF18             IT       NE 
   \   0000006A   0x1C40             ADDNE    R0,R0,#+1
   \   0000006C   0xF9B8 0x13B8      LDRSH    R1,[R8, #+952]
   \   00000070   0xF9B8 0x23D8      LDRSH    R2,[R8, #+984]
   \   00000074   0x43D2             MVNS     R2,R2
   \   00000076   0xB289             UXTH     R1,R1
   \   00000078   0xB292             UXTH     R2,R2
   \   0000007A   0x4291             CMP      R1,R2
   \   0000007C   0xBF18             IT       NE 
   \   0000007E   0x1C40             ADDNE    R0,R0,#+1
   \   00000080   0xF9B8 0x13BC      LDRSH    R1,[R8, #+956]
   \   00000084   0xF9B8 0x23DC      LDRSH    R2,[R8, #+988]
   \   00000088   0x43D2             MVNS     R2,R2
   \   0000008A   0xB289             UXTH     R1,R1
   \   0000008C   0xB292             UXTH     R2,R2
   \   0000008E   0x4291             CMP      R1,R2
   \   00000090   0xBF18             IT       NE 
   \   00000092   0x1C40             ADDNE    R0,R0,#+1
   \   00000094   0xF8B8 0x13BA      LDRH     R1,[R8, #+954]
   \   00000098   0xF8B8 0x23DA      LDRH     R2,[R8, #+986]
   \   0000009C   0x43D2             MVNS     R2,R2
   \   0000009E   0xB292             UXTH     R2,R2
   \   000000A0   0x4291             CMP      R1,R2
   \   000000A2   0xBF18             IT       NE 
   \   000000A4   0x1C40             ADDNE    R0,R0,#+1
   \   000000A6   0xF898 0x1372      LDRB     R1,[R8, #+882]
   \   000000AA   0xF898 0x2373      LDRB     R2,[R8, #+883]
   \   000000AE   0x43D2             MVNS     R2,R2
   \   000000B0   0xB2D2             UXTB     R2,R2
   \   000000B2   0x4291             CMP      R1,R2
   \   000000B4   0xBF18             IT       NE 
   \   000000B6   0x1C40             ADDNE    R0,R0,#+1
   \   000000B8   0xB120             CBZ.N    R0,??SRMotorSafetyMgr__MCPwmHandler_0
   \   000000BA   0x2200             MOVS     R2,#+0
   \   000000BC   0x2100             MOVS     R1,#+0
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x.... 0x....      BL       SRException__Queue
    504          
    505          #ifdef SR_CIM_MOTOR
    506              // InputCapture PWM Handler
    507              SRMCInputCapture__PwmHandler();
    508          #endif
    509          
    510          #ifdef SR_THIRD_CURRENT_RECONSTRUCTION
    511              switch (SR_Sector)
   \                     ??SRMotorSafetyMgr__MCPwmHandler_0: (+1)
   \   000000C4   0xF8B8 0x03BA      LDRH     R0,[R8, #+954]
   \   000000C8   0x.... 0x....      LDR.W    R5,??DataTable169_1  ;; 0x4003b000
   \   000000CC   0x2801             CMP      R0,#+1
   \   000000CE   0xD004             BEQ.N    ??SRMotorSafetyMgr__MCPwmHandler_1
   \   000000D0   0xD34D             BCC.N    ??SRMotorSafetyMgr__MCPwmHandler_2
   \   000000D2   0x2803             CMP      R0,#+3
   \   000000D4   0xD031             BEQ.N    ??SRMotorSafetyMgr__MCPwmHandler_3
   \   000000D6   0xD318             BCC.N    ??SRMotorSafetyMgr__MCPwmHandler_4
   \   000000D8   0xE049             B.N      ??SRMotorSafetyMgr__MCPwmHandler_2
    512              {
    513          		case 1:
    514          			SR_Raw_CurrentB = SRMCATOD__GETADC2_REC1();
   \                     ??SRMotorSafetyMgr__MCPwmHandler_1: (+1)
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable169_2  ;; 0x40027000
   \   000000DE   0x6900             LDR      R0,[R0, #+16]
    515          			current_ib 		= SR_Raw_CurrentB - SR_CurrentOffsetB;   // Subtract zero offset
   \   000000E0   0xF8B8 0x13AE      LDRH     R1,[R8, #+942]
   \   000000E4   0xF8A8 0x03B6      STRH     R0,[R8, #+950]
   \   000000E8   0xF8B8 0x03B6      LDRH     R0,[R8, #+950]
   \   000000EC   0x1A46             SUBS     R6,R0,R1
    516          
    517          			SR_Raw_CurrentC = SRMCATOD__GETADC3_REC1();
   \   000000EE   0x6928             LDR      R0,[R5, #+16]
    518          			current_ic 		= SR_Raw_CurrentC - SR_CurrentOffsetC;   // Subtract zero offset
   \   000000F0   0xF8B8 0x13B2      LDRH     R1,[R8, #+946]
   \   000000F4   0xB236             SXTH     R6,R6
   \   000000F6   0x1A47             SUBS     R7,R0,R1
   \   000000F8   0xB23F             SXTH     R7,R7
    519          
    520          			// Reconstruct phase A
    521          			current_ia 		= -current_ib - current_ic;
   \   000000FA   0x4271             RSBS     R1,R6,#+0
   \   000000FC   0x1BCC             SUBS     R4,R1,R7
    522          			SR_Raw_CurrentA = current_ia + SR_CurrentOffsetA;
   \   000000FE   0xF8B8 0x13AA      LDRH     R1,[R8, #+938]
   \   00000102   0x1909             ADDS     R1,R1,R4
   \   00000104   0xF8A8 0x13B4      STRH     R1,[R8, #+948]
    523          			break;
   \   00000108   0xE048             B.N      ??SRMotorSafetyMgr__MCPwmHandler_5
    524          
    525          		case 2:
    526          			SR_Raw_CurrentA = SRMCATOD__GETADC1_REC2();
   \                     ??SRMotorSafetyMgr__MCPwmHandler_4: (+1)
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable169_2  ;; 0x40027000
   \   0000010E   0x6900             LDR      R0,[R0, #+16]
    527          			current_ia 		= SR_Raw_CurrentA - SR_CurrentOffsetA;   // Subtract zero offset
   \   00000110   0xF8B8 0x13AA      LDRH     R1,[R8, #+938]
   \   00000114   0xF8A8 0x03B4      STRH     R0,[R8, #+948]
   \   00000118   0xF8B8 0x03B4      LDRH     R0,[R8, #+948]
   \   0000011C   0x1A40             SUBS     R0,R0,R1
   \   0000011E   0xB204             SXTH     R4,R0
    528          
    529          			SR_Raw_CurrentC = SRMCATOD__GETADC3_REC2();
   \   00000120   0x6928             LDR      R0,[R5, #+16]
    530          			current_ic 		= SR_Raw_CurrentC - SR_CurrentOffsetC;   // Subtract zero offset
   \   00000122   0xF8B8 0x13B2      LDRH     R1,[R8, #+946]
   \   00000126   0x1A47             SUBS     R7,R0,R1
   \   00000128   0xB23F             SXTH     R7,R7
    531          
    532          			// Reconstruct phase B
    533          			current_ib 		= -current_ia - current_ic;
   \   0000012A   0x4261             RSBS     R1,R4,#+0
   \   0000012C   0x1BCE             SUBS     R6,R1,R7
    534          			SR_Raw_CurrentB = current_ib + SR_CurrentOffsetB;
   \   0000012E   0xF8B8 0x13AE      LDRH     R1,[R8, #+942]
   \   00000132   0x1989             ADDS     R1,R1,R6
   \   00000134   0xF8A8 0x13B6      STRH     R1,[R8, #+950]
    535          			break;
   \   00000138   0xE030             B.N      ??SRMotorSafetyMgr__MCPwmHandler_5
    536          
    537          		case 3:
    538          			SR_Raw_CurrentA = SRMCATOD__GETADC1_REC3();
   \                     ??SRMotorSafetyMgr__MCPwmHandler_3: (+1)
   \   0000013A   0x.... 0x....      LDR.W    R0,??DataTable169_2  ;; 0x40027000
   \   0000013E   0x6900             LDR      R0,[R0, #+16]
    539          			current_ia 		= SR_Raw_CurrentA - SR_CurrentOffsetA;   // Subtract zero offset
   \   00000140   0xF8B8 0x13AA      LDRH     R1,[R8, #+938]
   \   00000144   0xF8A8 0x03B4      STRH     R0,[R8, #+948]
   \   00000148   0xF8B8 0x03B4      LDRH     R0,[R8, #+948]
   \   0000014C   0x1A40             SUBS     R0,R0,R1
   \   0000014E   0xB204             SXTH     R4,R0
    540          
    541          			SR_Raw_CurrentB = SRMCATOD__GETADC2_REC3();
   \   00000150   0x6928             LDR      R0,[R5, #+16]
    542          			current_ib 		= SR_Raw_CurrentB - SR_CurrentOffsetB;   // Subtract zero offset
   \   00000152   0xF8B8 0x13AE      LDRH     R1,[R8, #+942]
   \   00000156   0xF8A8 0x03B6      STRH     R0,[R8, #+950]
   \   0000015A   0xF8B8 0x03B6      LDRH     R0,[R8, #+950]
   \   0000015E   0x1A46             SUBS     R6,R0,R1
   \   00000160   0xB236             SXTH     R6,R6
    543          
    544          			// Reconstruct phase C
    545          			current_ic 		= -current_ia - current_ib;
   \   00000162   0x4260             RSBS     R0,R4,#+0
   \   00000164   0x1B87             SUBS     R7,R0,R6
    546          			SR_Raw_CurrentC = current_ic + SR_CurrentOffsetC;
   \   00000166   0xF8B8 0x03B2      LDRH     R0,[R8, #+946]
   \   0000016A   0x19C0             ADDS     R0,R0,R7
    547          			break;
   \   0000016C   0xE016             B.N      ??SRMotorSafetyMgr__MCPwmHandler_5
    548          
    549          		default:
    550          		    // Adc calculations - no reconstruction
    551          		    SR_Raw_CurrentA = SRMCATOD__GETADC1();              // Read the converted values...
   \                     ??SRMotorSafetyMgr__MCPwmHandler_2: (+1)
   \   0000016E   0x.... 0x....      LDR.W    R0,??DataTable169_2  ;; 0x40027000
   \   00000172   0x6901             LDR      R1,[R0, #+16]
    552          		    current_ia = SR_Raw_CurrentA - SR_CurrentOffsetA;   // Subtract zero offset
   \   00000174   0xF9B8 0x23AA      LDRSH    R2,[R8, #+938]
   \   00000178   0xF8A8 0x13B4      STRH     R1,[R8, #+948]
   \   0000017C   0xF9B8 0x13B4      LDRSH    R1,[R8, #+948]
    553          
    554          
    555          		    SR_Raw_CurrentB = SRMCATOD__GETADC2();              // Read the converted values...
   \   00000180   0x6940             LDR      R0,[R0, #+20]
   \   00000182   0xF8A8 0x03B6      STRH     R0,[R8, #+950]
   \   00000186   0x1A8C             SUBS     R4,R1,R2
    556          		    current_ib = SR_Raw_CurrentB - SR_CurrentOffsetB;   // Subtract zero offset
   \   00000188   0xF9B8 0x03B6      LDRSH    R0,[R8, #+950]
   \   0000018C   0xF9B8 0x13AE      LDRSH    R1,[R8, #+942]
   \   00000190   0x1A46             SUBS     R6,R0,R1
    557          
    558          		    SR_Raw_CurrentC = SRMCATOD__GETADC3();              // Read the converted values...
   \   00000192   0x6928             LDR      R0,[R5, #+16]
    559          		    current_ic = SR_Raw_CurrentC - SR_CurrentOffsetC;   // Subtract zero offset
   \   00000194   0xF9B8 0x13B2      LDRSH    R1,[R8, #+946]
   \   00000198   0xB200             SXTH     R0,R0
   \   0000019A   0x1A47             SUBS     R7,R0,R1
    560          			break;
   \                     ??SRMotorSafetyMgr__MCPwmHandler_5: (+1)
   \   0000019C   0xF8A8 0x03B8      STRH     R0,[R8, #+952]
    561              }
    562          
    563              SR_MCU_MOTOR_UPDATE_N_VAR(SR_Raw_CurrentA);
   \   000001A0   0xF9B8 0x03B4      LDRSH    R0,[R8, #+948]
   \   000001A4   0x43C0             MVNS     R0,R0
   \   000001A6   0xF8A8 0x03D4      STRH     R0,[R8, #+980]
    564              SR_MCU_MOTOR_UPDATE_N_VAR(SR_Raw_CurrentB);
   \   000001AA   0xF9B8 0x03B6      LDRSH    R0,[R8, #+950]
   \   000001AE   0x43C0             MVNS     R0,R0
   \   000001B0   0xF8A8 0x03D6      STRH     R0,[R8, #+982]
    565              SR_MCU_MOTOR_UPDATE_N_VAR(SR_Raw_CurrentC);
   \   000001B4   0xF9B8 0x03B8      LDRSH    R0,[R8, #+952]
   \   000001B8   0x43C0             MVNS     R0,R0
   \   000001BA   0xF8A8 0x03D8      STRH     R0,[R8, #+984]
    566          
    567          
    568          
    569          #else
    570              // Adc calculations
    571              SR_Raw_CurrentA = SRMCATOD__GETADC1();              // Read the converted values...
    572              current_ia = SR_Raw_CurrentA - SR_CurrentOffsetA;   // Subtract zero offset
    573              SR_MCU_MOTOR_UPDATE_N_VAR(SR_Raw_CurrentA);
    574          
    575              SR_Raw_CurrentB = SRMCATOD__GETADC2();              // Read the converted values...
    576              current_ib = SR_Raw_CurrentB - SR_CurrentOffsetB;   // Subtract zero offset
    577              SR_MCU_MOTOR_UPDATE_N_VAR(SR_Raw_CurrentB);
    578          
    579              SR_Raw_CurrentC = SRMCATOD__GETADC3();              // Read the converted values...
    580              current_ic = SR_Raw_CurrentC - SR_CurrentOffsetC;   // Subtract zero offset
    581              SR_MCU_MOTOR_UPDATE_N_VAR(SR_Raw_CurrentC);
    582          #endif
    583          
    584              SR_DCBus = SRMCATOD__GETDCBUSVOLTAGE();             // Read the converted values...
   \   000001BE   0x6968             LDR      R0,[R5, #+20]
   \   000001C0   0xF8A8 0x03BC      STRH     R0,[R8, #+956]
    585              dc_bus = SR_DCBus;
   \   000001C4   0xF9B8 0x03BC      LDRSH    R0,[R8, #+956]
   \   000001C8   0x4681             MOV      R9,R0
    586              SR_MCU_MOTOR_UPDATE_N_VAR(SR_DCBus);
   \   000001CA   0x43C0             MVNS     R0,R0
   \   000001CC   0xF8A8 0x03DC      STRH     R0,[R8, #+988]
    587          
    588          
    589              // Motor control peripheral diagnostic handler
    590              PeripheralDiagnostic();
   \   000001D0   0xF898 0x0372      LDRB     R0,[R8, #+882]
   \   000001D4   0x2803             CMP      R0,#+3
   \   000001D6   0xF040 0x80B5      BNE.W    ??SRMotorSafetyMgr__MCPwmHandler_6
   \   000001DA   0x.... 0x....      BL       SRMCPwm__DiagnosticHandler
   \   000001DE   0x.... 0x....      BL       SRMCAtod__DiagnosticHandler
   \   000001E2   0xF8B8 0xA3A6      LDRH     R10,[R8, #+934]
   \   000001E6   0x.... 0x....      BL       SRMCAtod__GetDiagnosticFeedback
   \   000001EA   0x2806             CMP      R0,#+6
   \   000001EC   0xBF08             IT       EQ 
   \   000001EE   0xF04A 0x0A40      ORREQ    R10,R10,#0x40
   \   000001F2   0xD01C             BEQ.N    ??SRMotorSafetyMgr__MCPwmHandler_7
   \   000001F4   0x2805             CMP      R0,#+5
   \   000001F6   0xD11A             BNE.N    ??SRMotorSafetyMgr__MCPwmHandler_7
   \   000001F8   0xF8B8 0x03A2      LDRH     R0,[R8, #+930]
   \   000001FC   0xF040 0x0201      ORR      R2,R0,#0x1
   \   00000200   0xF508 0x7171      ADD      R1,R8,#+964
   \   00000204   0xF208 0x30A2      ADDW     R0,R8,#+930
   \   00000208   0x.... 0x....      BL       SRData__UpdateShort
   \   0000020C   0xF8B8 0x03A4      LDRH     R0,[R8, #+932]
   \   00000210   0xF040 0x0201      ORR      R2,R0,#0x1
   \   00000214   0xF508 0x61B2      ADD      R1,R8,#+1424
   \   00000218   0xF508 0x7069      ADD      R0,R8,#+932
   \   0000021C   0x.... 0x....      BL       SRData__UpdateShort
   \   00000220   0x2278             MOVS     R2,#+120
   \   00000222   0xF508 0x61FE      ADD      R1,R8,#+2032
   \   00000226   0xF208 0x502C      ADDW     R0,R8,#+1324
   \   0000022A   0x.... 0x....      BL       SRData__UpdateLong
   \                     ??SRMotorSafetyMgr__MCPwmHandler_7: (+1)
   \   0000022E   0x.... 0x....      BL       SRMCPwm__GetDiagnosticFeedback
   \   00000232   0x2805             CMP      R0,#+5
   \   00000234   0xBF08             IT       EQ 
   \   00000236   0xF04A 0x0A80      ORREQ    R10,R10,#0x80
   \   0000023A   0xD01C             BEQ.N    ??SRMotorSafetyMgr__MCPwmHandler_8
   \   0000023C   0x2804             CMP      R0,#+4
   \   0000023E   0xD11A             BNE.N    ??SRMotorSafetyMgr__MCPwmHandler_8
   \   00000240   0xF8B8 0x03A2      LDRH     R0,[R8, #+930]
   \   00000244   0xF040 0x0204      ORR      R2,R0,#0x4
   \   00000248   0xF508 0x7171      ADD      R1,R8,#+964
   \   0000024C   0xF208 0x30A2      ADDW     R0,R8,#+930
   \   00000250   0x.... 0x....      BL       SRData__UpdateShort
   \   00000254   0xF8B8 0x03A4      LDRH     R0,[R8, #+932]
   \   00000258   0xF040 0x0204      ORR      R2,R0,#0x4
   \   0000025C   0xF508 0x61B2      ADD      R1,R8,#+1424
   \   00000260   0xF508 0x7069      ADD      R0,R8,#+932
   \   00000264   0x.... 0x....      BL       SRData__UpdateShort
   \   00000268   0x2278             MOVS     R2,#+120
   \   0000026A   0xF508 0x61FE      ADD      R1,R8,#+2032
   \   0000026E   0xF208 0x502C      ADDW     R0,R8,#+1324
   \   00000272   0x.... 0x....      BL       SRData__UpdateLong
   \                     ??SRMotorSafetyMgr__MCPwmHandler_8: (+1)
   \   00000276   0xEA5F 0x604A      LSLS     R0,R10,#+25
   \   0000027A   0xBF48             IT       MI 
   \   0000027C   0xEA5F 0x600A      LSLSMI   R0,R10,#+24
   \   00000280   0xD558             BPL.N    ??SRMotorSafetyMgr__MCPwmHandler_9
   \   00000282   0xF8B8 0x03AA      LDRH     R0,[R8, #+938]
   \   00000286   0xF5A0 0x6000      SUB      R0,R0,#+2048
   \   0000028A   0xB200             SXTH     R0,R0
   \   0000028C   0x2800             CMP      R0,#+0
   \   0000028E   0xBF48             IT       MI 
   \   00000290   0x4240             RSBMI    R0,R0,#+0
   \   00000292   0xF8B8 0x13AE      LDRH     R1,[R8, #+942]
   \   00000296   0xF5A1 0x6100      SUB      R1,R1,#+2048
   \   0000029A   0xB209             SXTH     R1,R1
   \   0000029C   0x2900             CMP      R1,#+0
   \   0000029E   0xBF48             IT       MI 
   \   000002A0   0x4249             RSBMI    R1,R1,#+0
   \   000002A2   0xF8B8 0x23B2      LDRH     R2,[R8, #+946]
   \   000002A6   0xF5A2 0x6200      SUB      R2,R2,#+2048
   \   000002AA   0xB212             SXTH     R2,R2
   \   000002AC   0x2A00             CMP      R2,#+0
   \   000002AE   0xBF48             IT       MI 
   \   000002B0   0x4252             RSBMI    R2,R2,#+0
   \   000002B2   0xF9B8 0x33BC      LDRSH    R3,[R8, #+956]
   \   000002B6   0xB200             SXTH     R0,R0
   \   000002B8   0x2865             CMP      R0,#+101
   \   000002BA   0xBFBF             ITTTT    LT 
   \   000002BC   0xB209             SXTHLT   R1,R1
   \   000002BE   0x2965             CMPLT    R1,#+101
   \   000002C0   0xB212             SXTHLT   R2,R2
   \   000002C2   0x2A65             CMPLT    R2,#+101
   \   000002C4   0xDA17             BGE.N    ??SRMotorSafetyMgr__MCPwmHandler_10
   \   000002C6   0xF1A3 0x0032      SUB      R0,R3,#+50
   \   000002CA   0xF640 0x719C      MOVW     R1,#+3996
   \   000002CE   0x4288             CMP      R0,R1
   \   000002D0   0xD30E             BCC.N    ??SRMotorSafetyMgr__MCPwmHandler_11
   \   000002D2   0xF8B8 0x03A2      LDRH     R0,[R8, #+930]
   \   000002D6   0xF040 0x0202      ORR      R2,R0,#0x2
   \   000002DA   0xF508 0x7171      ADD      R1,R8,#+964
   \   000002DE   0xF208 0x30A2      ADDW     R0,R8,#+930
   \   000002E2   0x.... 0x....      BL       SRData__UpdateShort
   \   000002E6   0xF8B8 0x03A4      LDRH     R0,[R8, #+932]
   \   000002EA   0xF040 0x0202      ORR      R2,R0,#0x2
   \   000002EE   0xE010             B.N      ??SRMotorSafetyMgr__MCPwmHandler_12
   \                     ??SRMotorSafetyMgr__MCPwmHandler_11: (+1)
   \   000002F0   0xF04A 0x0A10      ORR      R10,R10,#0x10
   \   000002F4   0xE01A             B.N      ??SRMotorSafetyMgr__MCPwmHandler_13
   \                     ??SRMotorSafetyMgr__MCPwmHandler_10: (+1)
   \   000002F6   0xF8B8 0x03A2      LDRH     R0,[R8, #+930]
   \   000002FA   0xF040 0x0201      ORR      R2,R0,#0x1
   \   000002FE   0xF508 0x7171      ADD      R1,R8,#+964
   \   00000302   0xF208 0x30A2      ADDW     R0,R8,#+930
   \   00000306   0x.... 0x....      BL       SRData__UpdateShort
   \   0000030A   0xF8B8 0x03A4      LDRH     R0,[R8, #+932]
   \   0000030E   0xF040 0x0201      ORR      R2,R0,#0x1
   \                     ??SRMotorSafetyMgr__MCPwmHandler_12: (+1)
   \   00000312   0xF508 0x61B2      ADD      R1,R8,#+1424
   \   00000316   0xF508 0x7069      ADD      R0,R8,#+932
   \   0000031A   0x.... 0x....      BL       SRData__UpdateShort
   \   0000031E   0x2278             MOVS     R2,#+120
   \   00000320   0xF508 0x61FE      ADD      R1,R8,#+2032
   \   00000324   0xF208 0x502C      ADDW     R0,R8,#+1324
   \   00000328   0x.... 0x....      BL       SRData__UpdateLong
   \                     ??SRMotorSafetyMgr__MCPwmHandler_13: (+1)
   \   0000032C   0xF64F 0x703F      MOVW     R0,#+65343
   \   00000330   0xEA00 0x0A0A      AND      R10,R0,R10
   \                     ??SRMotorSafetyMgr__MCPwmHandler_9: (+1)
   \   00000334   0x4652             MOV      R2,R10
   \   00000336   0xF208 0x31C6      ADDW     R1,R8,#+966
   \   0000033A   0xF208 0x30A6      ADDW     R0,R8,#+934
   \   0000033E   0x.... 0x....      BL       SRData__UpdateShort
   \   00000342   0xE005             B.N      ??SRMotorSafetyMgr__MCPwmHandler_14
   \                     ??SRMotorSafetyMgr__MCPwmHandler_6: (+1)
   \   00000344   0xF898 0x0372      LDRB     R0,[R8, #+882]
   \   00000348   0x2804             CMP      R0,#+4
   \   0000034A   0xBF08             IT       EQ 
   \   0000034C   0x.... 0x....      BLEQ     SRMCPwm__DiagnosticHandler
    591              
    592              // Class A Pwm Access Management
    593          	ClassAPwmAccess();
   \                     ??SRMotorSafetyMgr__MCPwmHandler_14: (+1)
   \   00000350   0xF898 0x0372      LDRB     R0,[R8, #+882]
   \   00000354   0x2805             CMP      R0,#+5
   \   00000356   0xD129             BNE.N    ??SRMotorSafetyMgr__MCPwmHandler_15
   \   00000358   0xF8B8 0x03A2      LDRH     R0,[R8, #+930]
   \   0000035C   0xB940             CBNZ.N   R0,??SRMotorSafetyMgr__MCPwmHandler_16
   \   0000035E   0xF8B8 0x03A6      LDRH     R0,[R8, #+934]
   \   00000362   0x0700             LSLS     R0,R0,#+28
   \   00000364   0xD404             BMI.N    ??SRMotorSafetyMgr__MCPwmHandler_16
   \   00000366   0xF8B8 0x03A6      LDRH     R0,[R8, #+934]
   \   0000036A   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000036E   0xE022             B.N      ??SRMotorSafetyMgr__MCPwmHandler_17
   \                     ??SRMotorSafetyMgr__MCPwmHandler_16: (+1)
   \   00000370   0xF8B8 0x03A6      LDRH     R0,[R8, #+934]
   \   00000374   0xF64F 0x71FD      MOVW     R1,#+65533
   \   00000378   0x4008             ANDS     R0,R1,R0
   \   0000037A   0xF8A8 0x03A6      STRH     R0,[R8, #+934]
   \   0000037E   0x2100             MOVS     R1,#+0
   \   00000380   0xF8B8 0x03A6      LDRH     R0,[R8, #+934]
   \   00000384   0x43C0             MVNS     R0,R0
   \   00000386   0xF8A8 0x03C6      STRH     R0,[R8, #+966]
   \   0000038A   0x.... 0x....      LDR.W    R0,??DataTable169_3  ;; 0x40038010
   \   0000038E   0x6281             STR      R1,[R0, #+40]
   \   00000390   0x6201             STR      R1,[R0, #+32]
   \   00000392   0x6181             STR      R1,[R0, #+24]
   \   00000394   0x6101             STR      R1,[R0, #+16]
   \   00000396   0x6081             STR      R1,[R0, #+8]
   \   00000398   0x6001             STR      R1,[R0, #+0]
   \   0000039A   0xF44F 0x7100      MOV      R1,#+512
   \   0000039E   0xF8C0 0x1088      STR      R1,[R0, #+136]
   \   000003A2   0x6D01             LDR      R1,[R0, #+80]
   \   000003A4   0x0989             LSRS     R1,R1,#+6
   \   000003A6   0x0189             LSLS     R1,R1,#+6
   \   000003A8   0x6501             STR      R1,[R0, #+80]
   \   000003AA   0xE00B             B.N      ??SRMotorSafetyMgr__MCPwmHandler_18
   \                     ??SRMotorSafetyMgr__MCPwmHandler_15: (+1)
   \   000003AC   0xF64F 0x71FD      MOVW     R1,#+65533
   \   000003B0   0xF8B8 0x03A6      LDRH     R0,[R8, #+934]
   \   000003B4   0x4008             ANDS     R0,R1,R0
   \                     ??SRMotorSafetyMgr__MCPwmHandler_17: (+1)
   \   000003B6   0xF8A8 0x03A6      STRH     R0,[R8, #+934]
   \   000003BA   0xF8B8 0x03A6      LDRH     R0,[R8, #+934]
   \   000003BE   0x43C0             MVNS     R0,R0
   \   000003C0   0xF8A8 0x03C6      STRH     R0,[R8, #+966]
    594          
    595          
    596              if(SR_SafetyMngr_State == SAFETY_MNGR_PRERUN_TESTS) // Ensure the data is valid during prerun checks
   \                     ??SRMotorSafetyMgr__MCPwmHandler_18: (+1)
   \   000003C4   0xF898 0x0372      LDRB     R0,[R8, #+882]
   \   000003C8   0x2803             CMP      R0,#+3
   \   000003CA   0xD104             BNE.N    ??SRMotorSafetyMgr__MCPwmHandler_19
    597              {
    598                  // Update Class A with this analog data
    599                  current_ia = 0;
    600                  current_ib = 0;
   \   000003CC   0x2600             MOVS     R6,#+0
   \   000003CE   0x2400             MOVS     R4,#+0
    601                  current_ic = 0;
   \   000003D0   0x4637             MOV      R7,R6
    602                  dc_bus = VBUS_SR_NOMINAL_AD_COUNTS;
   \   000003D2   0xF640 0x392F      MOVW     R9,#+2863
    603          	}
    604          
    605              INVOKE_CLASS_A_MCPWM_HANDLER(current_ia, current_ib, current_ic, dc_bus);
   \                     ??SRMotorSafetyMgr__MCPwmHandler_19: (+1)
   \   000003D6   0x464B             MOV      R3,R9
   \   000003D8   0xB23A             SXTH     R2,R7
   \   000003DA   0xB231             SXTH     R1,R6
   \   000003DC   0xB220             SXTH     R0,R4
   \   000003DE   0x.... 0x....      BL       Mci__PwmHandler
    606          
    607          
    608          #if (defined SRMOTOR_RUNNING_2ND_PWM)
    609              pwm_post_scaler++;
   \   000003E2   0xF898 0x0379      LDRB     R0,[R8, #+889]
   \   000003E6   0x1C40             ADDS     R0,R0,#+1
   \   000003E8   0xF888 0x0379      STRB     R0,[R8, #+889]
    610              if(pwm_post_scaler & 0x01)
   \   000003EC   0x07C0             LSLS     R0,R0,#+31
   \   000003EE   0xD449             BMI.N    ??SRMotorSafetyMgr__MCPwmHandler_20
    611              {
    612                  SRMOTOR_RUNNING_PWM();
    613          
    614              }
    615              else
    616              {
    617                  SRMOTOR_RUNNING_2ND_PWM();
   \   000003F0   0xF898 0x0372      LDRB     R0,[R8, #+882]
   \   000003F4   0x2803             CMP      R0,#+3
   \   000003F6   0xD045             BEQ.N    ??SRMotorSafetyMgr__MCPwmHandler_20
   \   000003F8   0xF898 0x0372      LDRB     R0,[R8, #+882]
   \   000003FC   0x2805             CMP      R0,#+5
   \   000003FE   0xBF18             IT       NE 
   \   00000400   0x2000             MOVNE    R0,#+0
   \   00000402   0xD10C             BNE.N    ??SRMotorSafetyMgr__MCPwmHandler_21
   \   00000404   0x.... 0x....      LDR.W    R0,??DataTable169_3  ;; 0x40038010
   \   00000408   0x6981             LDR      R1,[R0, #+24]
   \   0000040A   0x6882             LDR      R2,[R0, #+8]
   \   0000040C   0x6A83             LDR      R3,[R0, #+40]
   \   0000040E   0x2001             MOVS     R0,#+1
   \   00000410   0x428B             CMP      R3,R1
   \   00000412   0xBFBC             ITT      LT 
   \   00000414   0x460B             MOVLT    R3,R1
   \   00000416   0x2002             MOVLT    R0,#+2
   \   00000418   0x4293             CMP      R3,R2
   \   0000041A   0xBFB8             IT       LT 
   \   0000041C   0x2003             MOVLT    R0,#+3
   \                     ??SRMotorSafetyMgr__MCPwmHandler_21: (+1)
   \   0000041E   0xF8A8 0x03BA      STRH     R0,[R8, #+954]
   \   00000422   0xF8B8 0x03BA      LDRH     R0,[R8, #+954]
   \   00000426   0x43C0             MVNS     R0,R0
   \   00000428   0xF8A8 0x03DA      STRH     R0,[R8, #+986]
   \   0000042C   0xF8B8 0x03BA      LDRH     R0,[R8, #+954]
   \   00000430   0x2801             CMP      R0,#+1
   \   00000432   0xD010             BEQ.N    ??SRMotorSafetyMgr__MCPwmHandler_22
   \   00000434   0xD318             BCC.N    ??SRMotorSafetyMgr__MCPwmHandler_23
   \   00000436   0x2803             CMP      R0,#+3
   \   00000438   0xD116             BNE.N    ??SRMotorSafetyMgr__MCPwmHandler_23
   \   0000043A   0x.... 0x....      LDR.W    R0,??DataTable169_2  ;; 0x40027000
   \   0000043E   0x6802             LDR      R2,[R0, #+0]
   \   00000440   0xF64F 0x71E0      MOVW     R1,#+65504
   \   00000444   0x400A             ANDS     R2,R1,R2
   \   00000446   0xF042 0x0208      ORR      R2,R2,#0x8
   \   0000044A   0x6002             STR      R2,[R0, #+0]
   \   0000044C   0x6828             LDR      R0,[R5, #+0]
   \   0000044E   0x4008             ANDS     R0,R1,R0
   \   00000450   0xF040 0x0009      ORR      R0,R0,#0x9
   \   00000454   0xE015             B.N      ??SRMotorSafetyMgr__MCPwmHandler_24
   \                     ??SRMotorSafetyMgr__MCPwmHandler_22: (+1)
   \   00000456   0x.... 0x....      LDR.W    R0,??DataTable169_2  ;; 0x40027000
   \   0000045A   0x6802             LDR      R2,[R0, #+0]
   \   0000045C   0xF64F 0x71E0      MOVW     R1,#+65504
   \   00000460   0x400A             ANDS     R2,R1,R2
   \   00000462   0xF042 0x0209      ORR      R2,R2,#0x9
   \   00000466   0xE007             B.N      ??SRMotorSafetyMgr__MCPwmHandler_25
   \                     ??SRMotorSafetyMgr__MCPwmHandler_23: (+1)
   \   00000468   0x.... 0x....      LDR.W    R0,??DataTable169_2  ;; 0x40027000
   \   0000046C   0x6802             LDR      R2,[R0, #+0]
   \   0000046E   0xF64F 0x71E0      MOVW     R1,#+65504
   \   00000472   0x400A             ANDS     R2,R1,R2
   \   00000474   0xF042 0x0208      ORR      R2,R2,#0x8
   \                     ??SRMotorSafetyMgr__MCPwmHandler_25: (+1)
   \   00000478   0x6002             STR      R2,[R0, #+0]
   \   0000047A   0x6828             LDR      R0,[R5, #+0]
   \   0000047C   0x4008             ANDS     R0,R1,R0
   \   0000047E   0xF040 0x000C      ORR      R0,R0,#0xC
   \                     ??SRMotorSafetyMgr__MCPwmHandler_24: (+1)
   \   00000482   0x6028             STR      R0,[R5, #+0]
    618              }
    619          
    620          #else
    621              SRMOTOR_RUNNING_PWM();
    622          #endif
    623          
    624          
    625              SRMOTORSAFETYMGR_ISRMONITOR_MCPWM_HANDLER_END();
   \                     ??SRMotorSafetyMgr__MCPwmHandler_20: (+1)
   \   00000484   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   00000488   0x.... 0x....      B.W      SRIsrMonitor__ExitIsr
    626          }

   \                                 In section .data, align 4
   \                     Mcl_Quantities:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000010   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000020   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000030   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000040   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000050   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000060   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000070   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000080   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000090   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000A0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000B0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000C0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000D0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     Mcl_Cs:
   \   000000E4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000F4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000104   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000114   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000124   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000134   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     Mcl_IO:
   \   00000144   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000154   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000164   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000174   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000184   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000194   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     MclObserver_Params:
   \   0000019C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000001AC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000001BC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     Mcl_DQ_Ctrl_IO:
   \   000001D0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000001E0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000001F0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     Mcl_Observer_IO:
   \   000001FC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000020C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     MclFvt_Data_Test_Dc_Current:
   \   00000220   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000230   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     Mcl_Input_Proc_IO:
   \   00000244   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000254   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     Mcl_DQ_Ref_IO:
   \   00000264   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000274   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     Flux_Controller:
   \   00000280   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000290   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     Torque_Controller:
   \   0000029C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000002AC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     Speed_Controller:
   \   000002B8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000002C8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     Load_Angle_Limiter:
   \   000002D4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000002E4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     Mcl_Pwm_IO:
   \   000002F0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000300   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     Mcl_Speed_Ctrl_IO:
   \   00000308   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     MclSpeedCtrl_Params:
   \   00000318   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     MclDqRef_Params:
   \   00000328   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     MclPwm_Params:
   \   00000338   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     Res_Est_IO:
   \   00000348   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     Mci_Control_State:
   \   00000354   0x00               DC8 0
   \   00000355   0x00               DC8 0
   \   00000356   0x00               DC8 0
   \                     Mcl_Starting_State:
   \   00000357   0x00               DC8 0
   \                     Mcl_Flow_Manager:
   \   00000358   0x00               DC8 0
   \                     switching_angle:
   \   00000359   0x00               DC8 0
   \                     My_WbLim_Flag:
   \   0000035A   0x00               DC8 0
   \                     My_Mflux_Flag:
   \   0000035B   0x00               DC8 0
   \   0000035C   0x50               DC8 80
   \                     Inverter_Compensation_Selector:
   \   0000035D   0x00               DC8 0
   \                     Pwm_Sector:
   \   0000035E   0x00               DC8 0
   \                     Forced_Gain_Selector:
   \   0000035F   0x00               DC8 0
   \                     My_TqLim_Flag:
   \   00000360   0x00               DC8 0
   \                     MclFvt_Step:
   \   00000361   0x00               DC8 0
   \                     MclFvt_State:
   \   00000362   0x00               DC8 0
   \                     MclFvt_Status:
   \   00000363   0x00               DC8 0
   \                     MclFvt_Error_List:
   \   00000364   0x00               DC8 0
   \                     fvt_debug_averaging:
   \   00000365   0x00               DC8 0
   \   00000366   0x00               DC8 0
   \   00000367   0x00               DC8 0
   \   00000368   0x00               DC8 0
   \   00000369   0x00               DC8 0
   \   0000036A   0x00               DC8 0
   \                     Apply_Default_Accel:
   \   0000036B   0x00               DC8 0
   \   0000036C   0x00               DC8 0
   \   0000036D   0x00               DC8 0
   \   0000036E   0x00               DC8 0
   \   0000036F   0x00               DC8 0
   \   00000370   0x00               DC8 0
   \   00000371   0x00               DC8 0
   \   00000372   0x00               DC8 0
   \   00000373   0x00               DC8 0
   \   00000374   0x00               DC8 0
   \   00000375   0x00               DC8 0
   \   00000376   0x00               DC8 0
   \   00000377   0x00               DC8 0
   \   00000378   0x00               DC8 0
   \   00000379   0x00               DC8 0
   \                     Mci_GP_Timer:
   \   0000037A   0x00 0x00          DC8 0, 0
   \                     N_Samples:
   \   0000037C   0x00 0x00          DC8 0, 0
   \                     Over_Torque_Time_Counter:
   \   0000037E   0x00 0x00          DC8 0, 0
   \   00000380   0x00 0x00          DC8 0, 0
   \   00000382   0x00 0x00          DC8 0, 0
   \                     Forced_Gain_Timer:
   \   00000384   0x00 0x00          DC8 0, 0
   \                     Delta_Speed_Timer:
   \   00000386   0x00 0x00          DC8 0, 0
   \   00000388   0x00 0x00          DC8 0, 0
   \                     MclFvt_Generic_Timer:
   \   0000038A   0x00 0x00          DC8 0, 0
   \   0000038C   0x00 0x00          DC8 0, 0
   \   0000038E   0x00 0x00          DC8 0, 0
   \   00000390   0x00 0x00          DC8 0, 0
   \   00000392   0x00 0x00          DC8 0, 0
   \   00000394   0x00 0x00          DC8 0, 0
   \   00000396   0x00 0x00          DC8 0, 0
   \   00000398   0x00 0x00          DC8 0, 0
   \   0000039A   0x00 0x00          DC8 0, 0
   \   0000039C   0x00 0x00          DC8 0, 0
   \   0000039E   0x00 0x00          DC8 0, 0
   \   000003A0   0x00 0x00          DC8 0, 0
   \   000003A2   0x00 0x00          DC8 0, 0
   \   000003A4   0x00 0x00          DC8 0, 0
   \   000003A6   0x00 0x00          DC8 0, 0
   \   000003A8   0x00 0x00          DC8 0, 0
   \   000003AA   0x00 0x00          DC8 0, 0
   \   000003AC   0x00 0x00          DC8 0, 0
   \   000003AE   0x00 0x00          DC8 0, 0
   \   000003B0   0x00 0x00          DC8 0, 0
   \   000003B2   0x00 0x00          DC8 0, 0
   \   000003B4   0x00 0x00          DC8 0, 0
   \   000003B6   0x00 0x00          DC8 0, 0
   \   000003B8   0x00 0x00          DC8 0, 0
   \   000003BA   0x00 0x00          DC8 0, 0
   \   000003BC   0x00 0x00          DC8 0, 0
   \   000003BE   0x00 0x00          DC8 0, 0
   \   000003C0   0x00 0x00          DC8 0, 0
   \   000003C2   0x00 0x00          DC8 0, 0
   \   000003C4   0x00 0x00          DC8 0, 0
   \   000003C6   0x00 0x00          DC8 0, 0
   \   000003C8   0x00 0x00          DC8 0, 0
   \   000003CA   0x00 0x00          DC8 0, 0
   \   000003CC   0x00 0x00          DC8 0, 0
   \   000003CE   0x00 0x00          DC8 0, 0
   \   000003D0   0x00 0x00          DC8 0, 0
   \   000003D2   0x00 0x00          DC8 0, 0
   \   000003D4   0x00 0x00          DC8 0, 0
   \   000003D6   0x00 0x00          DC8 0, 0
   \   000003D8   0x00 0x00          DC8 0, 0
   \   000003DA   0x00 0x00          DC8 0, 0
   \   000003DC   0x00 0x00          DC8 0, 0
   \   000003DE   0x00 0x00          DC8 0, 0
   \                     Mci_Error:
   \   000003E0   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Mci_Error_Holder:
   \   000003E4   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Mci_Flow_Control:
   \   000003E8   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Mci_Status_Control:
   \   000003EC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     My_Measured_Temp:
   \   000003F0   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Mcl_Params_Displ1:
   \   000003F4   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Mcl_Params_Displ3:
   \   000003F8   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Mcl_Params_Displ4:
   \   000003FC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Mcl_Params_Displ9:
   \   00000400   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Mcl_Params_Displ10:
   \   00000404   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Mcl_Params_Displ11:
   \   00000408   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Manual_Inject_Level:
   \   0000040C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Manual_Inject_Param:
   \   00000410   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Manual_Pos_Reference:
   \   00000414   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     I1_Rms_Sum:
   \   00000418   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     I2_Rms_Sum:
   \   0000041C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     I3_Rms_Sum:
   \   00000420   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Mean_Speed_Sum:
   \   00000424   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     N_Samples_inv:
   \   00000428   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000042C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000430   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000434   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000438   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000043C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     My_Max_Braking_Current:
   \   00000440   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     My_Max_Braking_Torque:
   \   00000444   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     My_Is_Abs:
   \   00000448   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000044C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000450   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Over_Flux_Ratio:
   \   00000454   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Id_Braking:
   \   00000458   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Flux_Min:
   \   0000045C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     My_Flux_Gain:
   \   00000460   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000464   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000468   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Speed_Threshold_High:
   \   0000046C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Speed_Threshold_Low:
   \   00000470   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Speed_Threshold:
   \   00000474   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     My_Max_Torque:
   \   00000478   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000047C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Delta_Speed_Rot_Ref:
   \   00000480   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000484   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000488   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000048C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     My_Torque_Gain:
   \   00000490   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000494   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000498   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     MclFvt_Injection_Inst_Level:
   \   0000049C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     MclFvt_Injection_Level:
   \   000004A0   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     MclFvt_Injection_Level_Rate:
   \   000004A4   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     MclFvt_Injection_Position:
   \   000004A8   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000004AC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000004B0   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000004B4   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000004B8   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000004BC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000004C0   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000004C4   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000004C8   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000004CC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Default_Accel:
   \   000004D0   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Increment:
   \   000004D4   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     SpeedRef_Target_Speed:
   \   000004D8   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     SpeedRef_Reference_Speed:
   \   000004DC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000004E0   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000004E4   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000004E8   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000004EC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     SR_MotorSafety_Params:
   \   000004F0   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000004F4   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000004F8   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000004FC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000500   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000504   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000508   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000050C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000510   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000514   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000518   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000051C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000520   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000524   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000528   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000052C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000530   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000534   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000538   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000053C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000540   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000544   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000548   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000054C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000550   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000554   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000558   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000055C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000560   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000564   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000568   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000056C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000570   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000574   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000578   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000057C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000580   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000584   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000588   0x00               DC8 0
   \   00000589   0x00               DC8 0
   \   0000058A   0x00               DC8 0
   \   0000058B   0x00               DC8 0
   \   0000058C   0x00               DC8 0
   \   0000058D   0x00               DC8 0
   \   0000058E   0x00 0x00          DC8 0, 0
   \   00000590   0x00 0x00          DC8 0, 0
   \   00000592   0x00 0x00          DC8 0, 0
   \   00000594   0x00 0x00          DC8 0, 0
   \   00000596   0x00 0x00          DC8 0, 0
   \   __absolute struct <unnamed> Dutycycle_By_Current_LUT[65]
   \                     Dutycycle_By_Current_LUT:
   \   00000598   0xC0800000         DC32 0C0800000H, 0BCBE36D0H, 0C0780000H, 0BCBE5287H, 0C0700000H
   \              0xBCBE36D0   
   \              0xC0780000   
   \              0xBCBE5287   
   \              0xC0700000   
   \   000005AC   0xBCBDEB95         DC32 0BCBDEB95H, 0C0680000H, 0BCBD3F35H, 0C0600000H, 0BCBC78F8H
   \              0xC0680000   
   \              0xBCBD3F35   
   \              0xC0600000   
   \              0xBCBC78F8   
   \   000005C0   0xC0580000         DC32 0C0580000H, 0BCBBB477H, 0C0500000H, 0BCBAFF00H, 0C0480000H
   \              0xBCBBB477   
   \              0xC0500000   
   \              0xBCBAFF00   
   \              0xC0480000   
   \   000005D4   0xBCBA5945         DC32 0BCBA5945H, 0C0400000H, 0BCB9B909H, 0C0380000H, 0BCB90ACFH
   \              0xC0400000   
   \              0xBCB9B909   
   \              0xC0380000   
   \              0xBCB90ACF   
   \   000005E8   0xC0300000         DC32 0C0300000H, 0BCB8338CH, 0C0280000H, 0BCB7124DH, 0C0200000H
   \              0xBCB8338C   
   \              0xC0280000   
   \              0xBCB7124D   
   \              0xC0200000   
   \   000005FC   0xBCB581EF         DC32 0BCB581EFH, 0C0180000H, 0BCB35AC7H, 0C0100000H, 0BCB07452H
   \              0xC0180000   
   \              0xBCB35AC7   
   \              0xC0100000   
   \              0xBCB07452   
   \   00000610   0xC0080000         DC32 0C0080000H, 0BCACA6E4H, 0C0000000H, 0BCA7CD56H, 0BFF00000H
   \              0xBCACA6E4   
   \              0xC0000000   
   \              0xBCA7CD56   
   \              0xBFF00000   
   \   00000624   0xBCA1C6B6         DC32 0BCA1C6B6H, 0BFE00000H, 0BC9A77F2H, 0BFD00000H, 0BC953D29H
   \              0xBFE00000   
   \              0xBC9A77F2   
   \              0xBFD00000   
   \              0xBC953D29   
   \   00000638   0xBFC00000         DC32 0BFC00000H, 0BC8F68F3H, 0BFB00000H, 0BC8AADAEH, 0BFA00000H
   \              0xBC8F68F3   
   \              0xBFB00000   
   \              0xBC8AADAE   
   \              0xBFA00000   
   \   0000064C   0xBC863EEF         DC32 0BC863EEFH, 0BF900000H, 0BC81504DH, 0BF800000H, 0BC762ABBH
   \              0xBF900000   
   \              0xBC81504D   
   \              0xBF800000   
   \              0xBC762ABB   
   \   00000660   0xBF600000         DC32 0BF600000H, 0BC65F77CH, 0BF400000H, 0BC60B913H, 0BF200000H
   \              0xBC65F77C   
   \              0xBF400000   
   \              0xBC60B913   
   \              0xBF200000   
   \   00000674   0xBC5D2F1B         DC32 0BC5D2F1BH, 0BF000000H, 0BC59A522H, 0BEC00000H, 0BC54562EH
   \              0xBF000000   
   \              0xBC59A522   
   \              0xBEC00000   
   \              0xBC54562E   
   \   00000688   0xBE800000         DC32 0BE800000H, 0BC42A455H, 0BE000000H, 0BC30F27CH, 0H, 0H, 3E000000H
   \              0xBC42A455   
   \              0xBE000000   
   \              0xBC30F27C   
   \              0x00000000   
   \              0x00000000   
   \              0x3E000000   
   \   000006A4   0x3C30F27C         DC32 3C30F27CH, 3E800000H, 3C42A455H, 3EC00000H, 3C54562EH, 3F000000H
   \              0x3E800000   
   \              0x3C42A455   
   \              0x3EC00000   
   \              0x3C54562E   
   \              0x3F000000   
   \   000006BC   0x3C5B6A1F         DC32 3C5B6A1FH, 3F200000H, 3C5EF417H, 3F400000H, 3C775EF5H, 3F600000H
   \              0x3F200000   
   \              0x3C5EF417   
   \              0x3F400000   
   \              0x3C775EF5   
   \              0x3F600000   
   \   000006D4   0x3C850830         DC32 3C850830H, 3F800000H, 3C89B37CH, 3F900000H, 3C8F0A1AH, 3FA00000H
   \              0x3F800000   
   \              0x3C89B37C   
   \              0x3F900000   
   \              0x3C8F0A1A   
   \              0x3FA00000   
   \   000006EC   0x3C9583AE         DC32 3C9583AEH, 3FB00000H, 3C9CB423H, 3FC00000H, 3CA42F64H, 3FD00000H
   \              0x3FB00000   
   \              0x3C9CB423   
   \              0x3FC00000   
   \              0x3CA42F64   
   \              0x3FD00000   
   \   00000704   0x3CAB895F         DC32 3CAB895FH, 3FE00000H, 3CABDAF2H, 3FF00000H, 3CB3F2B5H, 40000000H
   \              0x3FE00000   
   \              0x3CABDAF2   
   \              0x3FF00000   
   \              0x3CB3F2B5   
   \              0x40000000   
   \   0000071C   0x3CB8CFF5         DC32 3CB8CFF5H, 40080000H, 3CBB8F62H, 40100000H, 3CBD0BA5H, 40180000H
   \              0x40080000   
   \              0x3CBB8F62   
   \              0x40100000   
   \              0x3CBD0BA5   
   \              0x40180000   
   \   00000734   0x3CBDE533         DC32 3CBDE533H, 40200000H, 3CBE8A1DH, 40280000H, 3CBF3DE1H, 40300000H
   \              0x40200000   
   \              0x3CBE8A1D   
   \              0x40280000   
   \              0x3CBF3DE1   
   \              0x40300000   
   \   0000074C   0x3CC02142         DC32 3CC02142H, 40380000H, 3CC13A11H, 40400000H, 3CC27B05H, 40480000H
   \              0x40380000   
   \              0x3CC13A11   
   \              0x40400000   
   \              0x3CC27B05   
   \              0x40480000   
   \   00000764   0x3CC3CB8A         DC32 3CC3CB8AH, 40500000H, 3CC50F95H, 40580000H, 3CC62F73H, 40600000H
   \              0x40500000   
   \              0x3CC50F95   
   \              0x40580000   
   \              0x3CC62F73   
   \              0x40600000   
   \   0000077C   0x3CC71F9D         DC32 3CC71F9DH, 40680000H, 3CC7E888H, 40700000H, 3CC8AE78H, 40780000H
   \              0x40680000   
   \              0x3CC7E888   
   \              0x40700000   
   \              0x3CC8AE78   
   \              0x40780000   
   \   00000794   0x3CC9B954         DC32 3CC9B954H, 40800000H, 3CCB7C71H
   \              0x40800000   
   \              0x3CCB7C71   
   \   __absolute float step_inv_pwm_comp
   \                     step_inv_pwm_comp:
   \   000007A0   0x41000000         DC32 41000000H
   \   __absolute sint32 sizeof_inv_comp_lut
   \                     sizeof_inv_comp_lut:
   \   000007A4   0x00000041         DC32 65
   \   000007A8   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000007AC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000007B0   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000007B4   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000007B8   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000007BC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000007C0   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000007C4   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000007C8   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000007CC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000007D0   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000007D4   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000007D8   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000007DC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000007E0   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000007E4   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000007E8   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000007EC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000007F0   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000007F4   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000007F8   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   000007FC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000800   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .data, align 4
   \   __absolute struct <unnamed> Inverter_Temp_LUT_ST[151]
   \                     Inverter_Temp_LUT_ST:
   \   00000000   0x00000046         DC32 70, 3, 90, 6, 110, 8, 130, 11, 150, 13, 170, 16, 190, 18, 210, 20
   \              0x00000003   
   \              0x0000005A   
   \              0x00000006   
   \              0x0000006E   
   \              0x00000008   
   \              0x00000082   
   \              0x0000000B   
   \              0x00000096   
   \              0x0000000D   
   \              0x000000AA   
   \              0x00000010   
   \              0x000000BE   
   \              0x00000012   
   \              0x000000D2   
   \              0x00000014   
   \   00000040   0x000000E6         DC32 230, 22, 250, 24, 270, 26, 290, 28, 310, 30, 330, 32, 350, 33, 370
   \              0x00000016   
   \              0x000000FA   
   \              0x00000018   
   \              0x0000010E   
   \              0x0000001A   
   \              0x00000122   
   \              0x0000001C   
   \              0x00000136   
   \              0x0000001E   
   \              0x0000014A   
   \              0x00000020   
   \              0x0000015E   
   \              0x00000021   
   \              0x00000172   
   \   0000007C   0x00000023         DC32 35, 390, 37, 410, 38, 430, 39, 450, 41, 470, 42, 490, 44, 510, 45
   \              0x00000186   
   \              0x00000025   
   \              0x0000019A   
   \              0x00000026   
   \              0x000001AE   
   \              0x00000027   
   \              0x000001C2   
   \              0x00000029   
   \              0x000001D6   
   \              0x0000002A   
   \              0x000001EA   
   \              0x0000002C   
   \              0x000001FE   
   \              0x0000002D   
   \   000000B8   0x00000212         DC32 530, 46, 550, 47, 570, 48, 590, 49, 610, 50, 630, 51, 650, 52, 670
   \              0x0000002E   
   \              0x00000226   
   \              0x0000002F   
   \              0x0000023A   
   \              0x00000030   
   \              0x0000024E   
   \              0x00000031   
   \              0x00000262   
   \              0x00000032   
   \              0x00000276   
   \              0x00000033   
   \              0x0000028A   
   \              0x00000034   
   \              0x0000029E   
   \   000000F4   0x00000035         DC32 53, 690, 54, 710, 55, 730, 56, 750, 57, 770, 58, 790, 59, 810, 60
   \              0x000002B2   
   \              0x00000036   
   \              0x000002C6   
   \              0x00000037   
   \              0x000002DA   
   \              0x00000038   
   \              0x000002EE   
   \              0x00000039   
   \              0x00000302   
   \              0x0000003A   
   \              0x00000316   
   \              0x0000003B   
   \              0x0000032A   
   \              0x0000003C   
   \   00000130   0x0000033E         DC32 830, 60, 850, 61, 870, 62, 890, 63, 910, 64, 930, 64, 950, 65, 970
   \              0x0000003C   
   \              0x00000352   
   \              0x0000003D   
   \              0x00000366   
   \              0x0000003E   
   \              0x0000037A   
   \              0x0000003F   
   \              0x0000038E   
   \              0x00000040   
   \              0x000003A2   
   \              0x00000040   
   \              0x000003B6   
   \              0x00000041   
   \              0x000003CA   
   \   0000016C   0x00000042         DC32 66, 990, 66, 1010, 67, 1030, 68, 1050, 69, 1070, 69, 1090, 70
   \              0x000003DE   
   \              0x00000042   
   \              0x000003F2   
   \              0x00000043   
   \              0x00000406   
   \              0x00000044   
   \              0x0000041A   
   \              0x00000045   
   \              0x0000042E   
   \              0x00000045   
   \              0x00000442   
   \              0x00000046   
   \   000001A0   0x00000456         DC32 1110, 71, 1130, 71, 1150, 72, 1170, 73, 1190, 73, 1210, 74, 1230
   \              0x00000047   
   \              0x0000046A   
   \              0x00000047   
   \              0x0000047E   
   \              0x00000048   
   \              0x00000492   
   \              0x00000049   
   \              0x000004A6   
   \              0x00000049   
   \              0x000004BA   
   \              0x0000004A   
   \              0x000004CE   
   \   000001D4   0x0000004B         DC32 75, 1250, 75, 1270, 76, 1290, 77, 1310, 77, 1330, 78, 1350, 79
   \              0x000004E2   
   \              0x0000004B   
   \              0x000004F6   
   \              0x0000004C   
   \              0x0000050A   
   \              0x0000004D   
   \              0x0000051E   
   \              0x0000004D   
   \              0x00000532   
   \              0x0000004E   
   \              0x00000546   
   \              0x0000004F   
   \   00000208   0x0000055A         DC32 1370, 79, 1390, 80, 1410, 80, 1430, 81, 1450, 82, 1470, 82, 1490
   \              0x0000004F   
   \              0x0000056E   
   \              0x00000050   
   \              0x00000582   
   \              0x00000050   
   \              0x00000596   
   \              0x00000051   
   \              0x000005AA   
   \              0x00000052   
   \              0x000005BE   
   \              0x00000052   
   \              0x000005D2   
   \   0000023C   0x00000053         DC32 83, 1510, 84, 1530, 84, 1550, 85, 1570, 86, 1590, 86, 1610, 87
   \              0x000005E6   
   \              0x00000054   
   \              0x000005FA   
   \              0x00000054   
   \              0x0000060E   
   \              0x00000055   
   \              0x00000622   
   \              0x00000056   
   \              0x00000636   
   \              0x00000056   
   \              0x0000064A   
   \              0x00000057   
   \   00000270   0x0000065E         DC32 1630, 88, 1650, 88, 1670, 89, 1690, 90, 1710, 90, 1730, 91, 1750
   \              0x00000058   
   \              0x00000672   
   \              0x00000058   
   \              0x00000686   
   \              0x00000059   
   \              0x0000069A   
   \              0x0000005A   
   \              0x000006AE   
   \              0x0000005A   
   \              0x000006C2   
   \              0x0000005B   
   \              0x000006D6   
   \   000002A4   0x0000005B         DC32 91, 1770, 92, 1790, 93, 1810, 93, 1830, 94, 1850, 95, 1870, 95
   \              0x000006EA   
   \              0x0000005C   
   \              0x000006FE   
   \              0x0000005D   
   \              0x00000712   
   \              0x0000005D   
   \              0x00000726   
   \              0x0000005E   
   \              0x0000073A   
   \              0x0000005F   
   \              0x0000074E   
   \              0x0000005F   
   \   000002D8   0x00000762         DC32 1890, 96, 1910, 97, 1930, 97, 1950, 98, 1970, 98, 1990, 99, 2010
   \              0x00000060   
   \              0x00000776   
   \              0x00000061   
   \              0x0000078A   
   \              0x00000061   
   \              0x0000079E   
   \              0x00000062   
   \              0x000007B2   
   \              0x00000062   
   \              0x000007C6   
   \              0x00000063   
   \              0x000007DA   
   \   0000030C   0x00000064         DC32 100, 2030, 100, 2050, 101, 2070, 102, 2090, 102, 2110, 103, 2130
   \              0x000007EE   
   \              0x00000064   
   \              0x00000802   
   \              0x00000065   
   \              0x00000816   
   \              0x00000066   
   \              0x0000082A   
   \              0x00000066   
   \              0x0000083E   
   \              0x00000067   
   \              0x00000852   
   \   0000033C   0x00000068         DC32 104, 2150, 104, 2170, 105, 2190, 105, 2210, 106, 2230, 107, 2250
   \              0x00000866   
   \              0x00000068   
   \              0x0000087A   
   \              0x00000069   
   \              0x0000088E   
   \              0x00000069   
   \              0x000008A2   
   \              0x0000006A   
   \              0x000008B6   
   \              0x0000006B   
   \              0x000008CA   
   \   0000036C   0x0000006B         DC32 107, 2270, 108, 2290, 109, 2310, 109, 2330, 110, 2350, 111, 2370
   \              0x000008DE   
   \              0x0000006C   
   \              0x000008F2   
   \              0x0000006D   
   \              0x00000906   
   \              0x0000006D   
   \              0x0000091A   
   \              0x0000006E   
   \              0x0000092E   
   \              0x0000006F   
   \              0x00000942   
   \   0000039C   0x00000070         DC32 112, 2390, 112, 2410, 113, 2430, 114, 2450, 114, 2470, 115, 2490
   \              0x00000956   
   \              0x00000070   
   \              0x0000096A   
   \              0x00000071   
   \              0x0000097E   
   \              0x00000072   
   \              0x00000992   
   \              0x00000072   
   \              0x000009A6   
   \              0x00000073   
   \              0x000009BA   
   \   000003CC   0x00000074         DC32 116, 2510, 117, 2530, 117, 2550, 118, 2570, 119, 2590, 120, 2610
   \              0x000009CE   
   \              0x00000075   
   \              0x000009E2   
   \              0x00000075   
   \              0x000009F6   
   \              0x00000076   
   \              0x00000A0A   
   \              0x00000077   
   \              0x00000A1E   
   \              0x00000078   
   \              0x00000A32   
   \   000003FC   0x00000079         DC32 121, 2630, 122, 2650, 123, 2670, 124, 2690, 125, 2710, 126, 2730
   \              0x00000A46   
   \              0x0000007A   
   \              0x00000A5A   
   \              0x0000007B   
   \              0x00000A6E   
   \              0x0000007C   
   \              0x00000A82   
   \              0x0000007D   
   \              0x00000A96   
   \              0x0000007E   
   \              0x00000AAA   
   \   0000042C   0x0000007F         DC32 127, 2750, 128, 2770, 129, 2790, 130, 2810, 131, 2830, 132, 2850
   \              0x00000ABE   
   \              0x00000080   
   \              0x00000AD2   
   \              0x00000081   
   \              0x00000AE6   
   \              0x00000082   
   \              0x00000AFA   
   \              0x00000083   
   \              0x00000B0E   
   \              0x00000084   
   \              0x00000B22   
   \   0000045C   0x00000085         DC32 133, 2870, 135, 2890, 136, 2910, 138, 2930, 139, 2950, 140, 2970
   \              0x00000B36   
   \              0x00000087   
   \              0x00000B4A   
   \              0x00000088   
   \              0x00000B5E   
   \              0x0000008A   
   \              0x00000B72   
   \              0x0000008B   
   \              0x00000B86   
   \              0x0000008C   
   \              0x00000B9A   
   \   0000048C   0x0000008E         DC32 142, 2990, 144, 3010, 145, 3030, 147, 3050, 149, 3070, 151
   \              0x00000BAE   
   \              0x00000090   
   \              0x00000BC2   
   \              0x00000091   
   \              0x00000BD6   
   \              0x00000093   
   \              0x00000BEA   
   \              0x00000095   
   \              0x00000BFE   
   \              0x00000097   

   \                                 In section .data, align 4
   \   __absolute sint32 Inv_Temp_LUT_X_Inv_Step_ST
   \                     Inv_Temp_LUT_X_Inv_Step_ST:
   \   00000000   0x00000666         DC32 1638

   \                                 In section .data, align 4
   \   __absolute sint32 SizeOf_Inv_Temp_LUT_ST
   \                     SizeOf_Inv_Temp_LUT_ST:
   \   00000000   0x00000097         DC32 151

   \                                 In section .data, align 4
   \   __absolute struct <unnamed> Inverter_Temp_LUT_Mitsubishi[3]
   \                     Inverter_Temp_LUT_Mitsubishi:
   \   00000000   0x0000024A         DC32 586, 0, 2327, 55, 4068, 110
   \              0x00000000   
   \              0x00000917   
   \              0x00000037   
   \              0x00000FE4   
   \              0x0000006E   

   \                                 In section .data, align 4
   \   __absolute sint32 Inv_Temp_LUT_X_Inv_Step_Mitsubishi
   \                     Inv_Temp_LUT_X_Inv_Step_Mitsubishi:
   \   00000000   0x00000012         DC32 18

   \                                 In section .data, align 4
   \   __absolute sint32 SizeOf_Inv_Temp_LUT_Mitsubishi
   \                     SizeOf_Inv_Temp_LUT_Mitsubishi:
   \   00000000   0x00000003         DC32 3

   \                                 In section .data, align 4
   \   __absolute struct <unnamed> Inverter_Temp_LUT_Ext_Array[2]
   \                     Inverter_Temp_LUT_Ext_Array:
   \   00000000   0x........         DC32 Inverter_Temp_LUT_ST, Inv_Temp_LUT_X_Inv_Step_ST
   \              0x........   
   \   00000008   0x........         DC32 SizeOf_Inv_Temp_LUT_ST
   \   0000000C   0x023A             DC16 570
   \   0000000E   0x00 0x00          DC8 0, 0
   \   00000010   0x........         DC32 Inverter_Temp_LUT_Mitsubishi, Inv_Temp_LUT_X_Inv_Step_Mitsubishi
   \              0x........   
   \   00000018   0x........         DC32 SizeOf_Inv_Temp_LUT_Mitsubishi
   \   0000001C   0x0561             DC16 1377
   \   0000001E   0x00 0x00          DC8 0, 0
    627          
    628          
    629          
    630          //---------------------------------------------------------------------------------------------------------------------
    631          /**
    632           *  @brief      Perform the 250us (4kHz) handler.
    633           */

   \                                 In section .text, align 2, keep-with-next
    634          void SRMotorSafetyMgr__Handler250us(void)
    635          {
   \                     SRMotorSafetyMgr__Handler250us: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    636              SRMOTORSAFETYMGR_250US_FLOW_HANDLER_BEGIN();
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       SRFlow__ISRLogEvent
    637          
    638              // Check for variables integrity
    639              CheckVariables4Failure_250us();
   \   0000000A   0x.... 0x....      LDR.W    R4,??DataTable169
   \   0000000E   0xF204 0x3173      ADDW     R1,R4,#+883
   \   00000012   0xF204 0x3072      ADDW     R0,R4,#+882
   \   00000016   0x.... 0x....      BL       SRData__CheckByte
   \   0000001A   0xF504 0x7171      ADD      R1,R4,#+964
   \   0000001E   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   00000022   0x.... 0x....      BL       SRData__CheckShort
   \   00000026   0xF504 0x61B2      ADD      R1,R4,#+1424
   \   0000002A   0xF504 0x7069      ADD      R0,R4,#+932
   \   0000002E   0x.... 0x....      BL       SRData__CheckShort
   \   00000032   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000036   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   0000003A   0x.... 0x....      BL       SRData__CheckShort
   \   0000003E   0xF504 0x7172      ADD      R1,R4,#+968
   \   00000042   0xF504 0x706A      ADD      R0,R4,#+936
   \   00000046   0x.... 0x....      BL       SRData__CheckShort
   \   0000004A   0xF504 0x7173      ADD      R1,R4,#+972
   \   0000004E   0xF504 0x706B      ADD      R0,R4,#+940
   \   00000052   0x.... 0x....      BL       SRData__CheckShort
   \   00000056   0xF504 0x7174      ADD      R1,R4,#+976
   \   0000005A   0xF504 0x706C      ADD      R0,R4,#+944
   \   0000005E   0x.... 0x....      BL       SRData__CheckShort
   \   00000062   0xF204 0x31CA      ADDW     R1,R4,#+970
   \   00000066   0xF204 0x30AA      ADDW     R0,R4,#+938
   \   0000006A   0x.... 0x....      BL       SRData__CheckShort
   \   0000006E   0xF204 0x31CE      ADDW     R1,R4,#+974
   \   00000072   0xF204 0x30AE      ADDW     R0,R4,#+942
   \   00000076   0x.... 0x....      BL       SRData__CheckShort
   \   0000007A   0xF204 0x31D2      ADDW     R1,R4,#+978
   \   0000007E   0xF204 0x30B2      ADDW     R0,R4,#+946
   \   00000082   0x.... 0x....      BL       SRData__CheckShort
   \   00000086   0xF504 0x7177      ADD      R1,R4,#+988
   \   0000008A   0xF504 0x706F      ADD      R0,R4,#+956
   \   0000008E   0x.... 0x....      BL       SRData__CheckShort
   \   00000092   0xF504 0x7175      ADD      R1,R4,#+980
   \   00000096   0xF504 0x706D      ADD      R0,R4,#+948
   \   0000009A   0x.... 0x....      BL       SRData__CheckShort
   \   0000009E   0xF204 0x31D6      ADDW     R1,R4,#+982
   \   000000A2   0xF204 0x30B6      ADDW     R0,R4,#+950
   \   000000A6   0x.... 0x....      BL       SRData__CheckShort
   \   000000AA   0xF504 0x7176      ADD      R1,R4,#+984
   \   000000AE   0xF504 0x706E      ADD      R0,R4,#+952
   \   000000B2   0x.... 0x....      BL       SRData__CheckShort
   \   000000B6   0xF204 0x71D4      ADDW     R1,R4,#+2004
   \   000000BA   0xF504 0x60A2      ADD      R0,R4,#+1296
   \   000000BE   0x.... 0x....      BL       SRData__CheckLong
   \   000000C2   0xF504 0x61FB      ADD      R1,R4,#+2008
   \   000000C6   0xF204 0x5014      ADDW     R0,R4,#+1300
   \   000000CA   0x.... 0x....      BL       SRData__CheckLong
   \   000000CE   0xF204 0x71DC      ADDW     R1,R4,#+2012
   \   000000D2   0xF504 0x60A3      ADD      R0,R4,#+1304
   \   000000D6   0x.... 0x....      BL       SRData__CheckLong
   \   000000DA   0xF504 0x61FC      ADD      R1,R4,#+2016
   \   000000DE   0xF204 0x501C      ADDW     R0,R4,#+1308
   \   000000E2   0x.... 0x....      BL       SRData__CheckLong
   \   000000E6   0xF204 0x71E4      ADDW     R1,R4,#+2020
   \   000000EA   0xF504 0x60A4      ADD      R0,R4,#+1312
   \   000000EE   0x.... 0x....      BL       SRData__CheckLong
   \   000000F2   0xF504 0x61FD      ADD      R1,R4,#+2024
   \   000000F6   0xF204 0x5024      ADDW     R0,R4,#+1316
   \   000000FA   0x.... 0x....      BL       SRData__CheckLong
   \   000000FE   0xF204 0x71EC      ADDW     R1,R4,#+2028
   \   00000102   0xF504 0x60A5      ADD      R0,R4,#+1320
   \   00000106   0x.... 0x....      BL       SRData__CheckLong
    640          
    641              // Check for currents plausibility
    642              CheckCurrentsPlausibility();
   \   0000010A   0xF894 0x0372      LDRB     R0,[R4, #+882]
   \   0000010E   0x2805             CMP      R0,#+5
   \   00000110   0xD161             BNE.N    ??SRMotorSafetyMgr__Handler250us_0
   \   00000112   0xF9B4 0x03B4      LDRSH    R0,[R4, #+948]
   \   00000116   0xF640 0x75F6      MOVW     R5,#+4086
   \   0000011A   0x1F40             SUBS     R0,R0,#+5
   \   0000011C   0x42A8             CMP      R0,R5
   \   0000011E   0xD31A             BCC.N    ??SRMotorSafetyMgr__Handler250us_1
   \   00000120   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   00000124   0xF040 0x0201      ORR      R2,R0,#0x1
   \   00000128   0xF504 0x7171      ADD      R1,R4,#+964
   \   0000012C   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   00000130   0x.... 0x....      BL       SRData__UpdateShort
   \   00000134   0xF8B4 0x03A4      LDRH     R0,[R4, #+932]
   \   00000138   0xF040 0x0201      ORR      R2,R0,#0x1
   \   0000013C   0xF504 0x61B2      ADD      R1,R4,#+1424
   \   00000140   0xF504 0x7069      ADD      R0,R4,#+932
   \   00000144   0x.... 0x....      BL       SRData__UpdateShort
   \   00000148   0x2278             MOVS     R2,#+120
   \   0000014A   0xF504 0x61FE      ADD      R1,R4,#+2032
   \   0000014E   0xF204 0x502C      ADDW     R0,R4,#+1324
   \   00000152   0x.... 0x....      BL       SRData__UpdateLong
   \                     ??SRMotorSafetyMgr__Handler250us_1: (+1)
   \   00000156   0xF9B4 0x03B6      LDRSH    R0,[R4, #+950]
   \   0000015A   0x1F40             SUBS     R0,R0,#+5
   \   0000015C   0x42A8             CMP      R0,R5
   \   0000015E   0xD31A             BCC.N    ??SRMotorSafetyMgr__Handler250us_2
   \   00000160   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   00000164   0xF040 0x0201      ORR      R2,R0,#0x1
   \   00000168   0xF504 0x7171      ADD      R1,R4,#+964
   \   0000016C   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   00000170   0x.... 0x....      BL       SRData__UpdateShort
   \   00000174   0xF8B4 0x03A4      LDRH     R0,[R4, #+932]
   \   00000178   0xF040 0x0201      ORR      R2,R0,#0x1
   \   0000017C   0xF504 0x61B2      ADD      R1,R4,#+1424
   \   00000180   0xF504 0x7069      ADD      R0,R4,#+932
   \   00000184   0x.... 0x....      BL       SRData__UpdateShort
   \   00000188   0x2278             MOVS     R2,#+120
   \   0000018A   0xF504 0x61FE      ADD      R1,R4,#+2032
   \   0000018E   0xF204 0x502C      ADDW     R0,R4,#+1324
   \   00000192   0x.... 0x....      BL       SRData__UpdateLong
   \                     ??SRMotorSafetyMgr__Handler250us_2: (+1)
   \   00000196   0xF9B4 0x03B8      LDRSH    R0,[R4, #+952]
   \   0000019A   0x1F40             SUBS     R0,R0,#+5
   \   0000019C   0x42A8             CMP      R0,R5
   \   0000019E   0xD31A             BCC.N    ??SRMotorSafetyMgr__Handler250us_0
   \   000001A0   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   000001A4   0xF040 0x0201      ORR      R2,R0,#0x1
   \   000001A8   0xF504 0x7171      ADD      R1,R4,#+964
   \   000001AC   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   000001B0   0x.... 0x....      BL       SRData__UpdateShort
   \   000001B4   0xF8B4 0x03A4      LDRH     R0,[R4, #+932]
   \   000001B8   0xF040 0x0201      ORR      R2,R0,#0x1
   \   000001BC   0xF504 0x61B2      ADD      R1,R4,#+1424
   \   000001C0   0xF504 0x7069      ADD      R0,R4,#+932
   \   000001C4   0x.... 0x....      BL       SRData__UpdateShort
   \   000001C8   0x2278             MOVS     R2,#+120
   \   000001CA   0xF504 0x61FE      ADD      R1,R4,#+2032
   \   000001CE   0xF204 0x502C      ADDW     R0,R4,#+1324
   \   000001D2   0x.... 0x....      BL       SRData__UpdateLong
    643          
    644              // Calculate the raw data
    645              CalculateRawAnalogData_250us();
   \                     ??SRMotorSafetyMgr__Handler250us_0: (+1)
   \   000001D6   0xF9B4 0x03B4      LDRSH    R0,[R4, #+948]
   \   000001DA   0xF9B4 0x13AA      LDRSH    R1,[R4, #+938]
   \   000001DE   0x1A42             SUBS     R2,R0,R1
   \   000001E0   0xB292             UXTH     R2,R2
   \   000001E2   0xF504 0x7172      ADD      R1,R4,#+968
   \   000001E6   0xF504 0x706A      ADD      R0,R4,#+936
   \   000001EA   0x.... 0x....      BL       SRData__UpdateShort
   \   000001EE   0xF9B4 0x03B6      LDRSH    R0,[R4, #+950]
   \   000001F2   0xF9B4 0x13AE      LDRSH    R1,[R4, #+942]
   \   000001F6   0x1A42             SUBS     R2,R0,R1
   \   000001F8   0xB292             UXTH     R2,R2
   \   000001FA   0xF504 0x7173      ADD      R1,R4,#+972
   \   000001FE   0xF504 0x706B      ADD      R0,R4,#+940
   \   00000202   0x.... 0x....      BL       SRData__UpdateShort
   \   00000206   0xF9B4 0x03B8      LDRSH    R0,[R4, #+952]
   \   0000020A   0xF9B4 0x13B2      LDRSH    R1,[R4, #+946]
   \   0000020E   0x1A42             SUBS     R2,R0,R1
   \   00000210   0xB292             UXTH     R2,R2
   \   00000212   0xF504 0x7174      ADD      R1,R4,#+976
   \   00000216   0xF504 0x706C      ADD      R0,R4,#+944
   \   0000021A   0x.... 0x....      BL       SRData__UpdateShort
    646          
    647              // Calculate the rms current used by class B thermal model
    648              CalculateRmsAnalogData();
   \   0000021E   0xF9B4 0x03A8      LDRSH    R0,[R4, #+936]
   \   00000222   0xF8D4 0x151C      LDR      R1,[R4, #+1308]
   \   00000226   0xFB10 0xF000      SMULBB   R0,R0,R0
   \   0000022A   0xEB01 0x12E0      ADD      R2,R1,R0, ASR #+7
   \   0000022E   0xF9B4 0x03AC      LDRSH    R0,[R4, #+940]
   \   00000232   0xF8D4 0x1520      LDR      R1,[R4, #+1312]
   \   00000236   0xFB10 0xF000      SMULBB   R0,R0,R0
   \   0000023A   0xEB01 0x15E0      ADD      R5,R1,R0, ASR #+7
   \   0000023E   0xF9B4 0x03B0      LDRSH    R0,[R4, #+944]
   \   00000242   0xF8D4 0x1524      LDR      R1,[R4, #+1316]
   \   00000246   0xFB10 0xF000      SMULBB   R0,R0,R0
   \   0000024A   0xEB01 0x16E0      ADD      R6,R1,R0, ASR #+7
   \   0000024E   0xF8D4 0x0528      LDR      R0,[R4, #+1320]
   \   00000252   0x1C47             ADDS     R7,R0,#+1
   \   00000254   0xF640 0x70A2      MOVW     R0,#+4002
   \   00000258   0x4287             CMP      R7,R0
   \   0000025A   0xDB1B             BLT.N    ??SRMotorSafetyMgr__Handler250us_3
   \   0000025C   0xFB92 0xF2F7      SDIV     R2,R2,R7
   \   00000260   0xF204 0x71D4      ADDW     R1,R4,#+2004
   \   00000264   0xF504 0x60A2      ADD      R0,R4,#+1296
   \   00000268   0x.... 0x....      BL       SRData__UpdateLong
   \   0000026C   0xFB95 0xF2F7      SDIV     R2,R5,R7
   \   00000270   0xF504 0x61FB      ADD      R1,R4,#+2008
   \   00000274   0xF204 0x5014      ADDW     R0,R4,#+1300
   \   00000278   0x.... 0x....      BL       SRData__UpdateLong
   \   0000027C   0xFB96 0xF2F7      SDIV     R2,R6,R7
   \   00000280   0xF204 0x71DC      ADDW     R1,R4,#+2012
   \   00000284   0xF504 0x60A3      ADD      R0,R4,#+1304
   \   00000288   0x.... 0x....      BL       SRData__UpdateLong
   \   0000028C   0x2200             MOVS     R2,#+0
   \   0000028E   0x2700             MOVS     R7,#+0
   \   00000290   0x4615             MOV      R5,R2
   \   00000292   0x4616             MOV      R6,R2
   \                     ??SRMotorSafetyMgr__Handler250us_3: (+1)
   \   00000294   0xF504 0x61FC      ADD      R1,R4,#+2016
   \   00000298   0xF204 0x501C      ADDW     R0,R4,#+1308
   \   0000029C   0x.... 0x....      BL       SRData__UpdateLong
   \   000002A0   0x462A             MOV      R2,R5
   \   000002A2   0xF204 0x71E4      ADDW     R1,R4,#+2020
   \   000002A6   0xF504 0x60A4      ADD      R0,R4,#+1312
   \   000002AA   0x.... 0x....      BL       SRData__UpdateLong
   \   000002AE   0x4632             MOV      R2,R6
   \   000002B0   0xF504 0x61FD      ADD      R1,R4,#+2024
   \   000002B4   0xF204 0x5024      ADDW     R0,R4,#+1316
   \   000002B8   0x.... 0x....      BL       SRData__UpdateLong
   \   000002BC   0x463A             MOV      R2,R7
   \   000002BE   0xF204 0x71EC      ADDW     R1,R4,#+2028
   \   000002C2   0xF504 0x60A5      ADD      R0,R4,#+1320
   \   000002C6   0x.... 0x....      BL       SRData__UpdateLong
    649          
    650              // Calculate the fundamental output frequency
    651              Calc_Avg_Frequency();
   \   000002CA   0xF504 0x61AE      ADD      R1,R4,#+1392
   \   000002CE   0xF504 0x60A9      ADD      R0,R4,#+1352
   \   000002D2   0x.... 0x....      BL       SRData__CheckLong
   \   000002D6   0xF204 0x5174      ADDW     R1,R4,#+1396
   \   000002DA   0xF204 0x504C      ADDW     R0,R4,#+1356
   \   000002DE   0x.... 0x....      BL       SRData__CheckLong
   \   000002E2   0xF504 0x61AF      ADD      R1,R4,#+1400
   \   000002E6   0xF504 0x60AA      ADD      R0,R4,#+1360
   \   000002EA   0x.... 0x....      BL       SRData__CheckLong
   \   000002EE   0xF504 0x6100      ADD      R1,R4,#+2048
   \   000002F2   0xF204 0x5054      ADDW     R0,R4,#+1364
   \   000002F6   0x.... 0x....      BL       SRData__CheckLong
   \   000002FA   0xF204 0x516C      ADDW     R1,R4,#+1388
   \   000002FE   0xF204 0x5044      ADDW     R0,R4,#+1348
   \   00000302   0x.... 0x....      BL       SRData__CheckLong
   \   00000306   0xF504 0x61AD      ADD      R1,R4,#+1384
   \   0000030A   0xF504 0x60A8      ADD      R0,R4,#+1344
   \   0000030E   0x.... 0x....      BL       SRData__CheckLong
   \   00000312   0xF204 0x5164      ADDW     R1,R4,#+1380
   \   00000316   0xF204 0x503C      ADDW     R0,R4,#+1340
   \   0000031A   0x.... 0x....      BL       SRData__CheckLong
   \   0000031E   0xF504 0x715E      ADD      R1,R4,#+888
   \   00000322   0xF204 0x3075      ADDW     R0,R4,#+885
   \   00000326   0x.... 0x....      BL       SRData__CheckByte
   \   0000032A   0xF204 0x3177      ADDW     R1,R4,#+887
   \   0000032E   0xF504 0x705D      ADD      R0,R4,#+884
   \   00000332   0x.... 0x....      BL       SRData__CheckByte
   \   00000336   0xF204 0x518C      ADDW     R1,R4,#+1420
   \   0000033A   0xF204 0x3076      ADDW     R0,R4,#+886
   \   0000033E   0x.... 0x....      BL       SRData__CheckByte
   \   00000342   0xF8D4 0x0548      LDR      R0,[R4, #+1352]
   \   00000346   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   0000034A   0xD206             BCS.N    ??SRMotorSafetyMgr__Handler250us_4
   \   0000034C   0x1C42             ADDS     R2,R0,#+1
   \   0000034E   0xF504 0x61AE      ADD      R1,R4,#+1392
   \   00000352   0xF504 0x60A9      ADD      R0,R4,#+1352
   \   00000356   0x.... 0x....      BL       SRData__UpdateLong
   \                     ??SRMotorSafetyMgr__Handler250us_4: (+1)
   \   0000035A   0x....             LDR.N    R0,??DataTable169_4  ;; 0x40038038
   \   0000035C   0x6805             LDR      R5,[R0, #+0]
   \   0000035E   0xF8D4 0x0550      LDR      R0,[R4, #+1360]
   \   00000362   0x4241             RSBS     R1,R0,#+0
   \   00000364   0xEB05 0x01E1      ADD      R1,R5,R1, ASR #+3
   \   00000368   0x180E             ADDS     R6,R1,R0
   \   0000036A   0x4632             MOV      R2,R6
   \   0000036C   0xF504 0x61AF      ADD      R1,R4,#+1400
   \   00000370   0xF504 0x60AA      ADD      R0,R4,#+1360
   \   00000374   0x.... 0x....      BL       SRData__UpdateLong
   \   00000378   0xF8D4 0x0554      LDR      R0,[R4, #+1364]
   \   0000037C   0x4241             RSBS     R1,R0,#+0
   \   0000037E   0xEB05 0x0161      ADD      R1,R5,R1, ASR #+1
   \   00000382   0x180D             ADDS     R5,R1,R0
   \   00000384   0x10F6             ASRS     R6,R6,#+3
   \   00000386   0x462A             MOV      R2,R5
   \   00000388   0xF504 0x6100      ADD      R1,R4,#+2048
   \   0000038C   0xF204 0x5054      ADDW     R0,R4,#+1364
   \   00000390   0x.... 0x....      BL       SRData__UpdateLong
   \   00000394   0xF8D4 0x0558      LDR      R0,[R4, #+1368]
   \   00000398   0x28F0             CMP      R0,#+240
   \   0000039A   0xBFB8             IT       LT 
   \   0000039C   0x106E             ASRLT    R6,R5,#+1
   \   0000039E   0xF8D4 0x0544      LDR      R0,[R4, #+1348]
   \   000003A2   0x42B0             CMP      R0,R6
   \   000003A4   0xDA44             BGE.N    ??SRMotorSafetyMgr__Handler250us_5
   \   000003A6   0xF8D4 0x2540      LDR      R2,[R4, #+1344]
   \   000003AA   0xF204 0x516C      ADDW     R1,R4,#+1388
   \   000003AE   0xF204 0x5044      ADDW     R0,R4,#+1348
   \   000003B2   0x.... 0x....      BL       SRData__UpdateLong
   \   000003B6   0xF894 0x0375      LDRB     R0,[R4, #+885]
   \   000003BA   0x2801             CMP      R0,#+1
   \   000003BC   0xD149             BNE.N    ??SRMotorSafetyMgr__Handler250us_6
   \   000003BE   0x2200             MOVS     R2,#+0
   \   000003C0   0xF504 0x715E      ADD      R1,R4,#+888
   \   000003C4   0xF204 0x3075      ADDW     R0,R4,#+885
   \   000003C8   0x.... 0x....      BL       SRData__UpdateByte
   \   000003CC   0xF8D4 0x054C      LDR      R0,[R4, #+1356]
   \   000003D0   0x1C42             ADDS     R2,R0,#+1
   \   000003D2   0xF204 0x5174      ADDW     R1,R4,#+1396
   \   000003D6   0xF204 0x504C      ADDW     R0,R4,#+1356
   \   000003DA   0x.... 0x....      BL       SRData__UpdateLong
   \   000003DE   0xF8D4 0x054C      LDR      R0,[R4, #+1356]
   \   000003E2   0xF894 0x1374      LDRB     R1,[R4, #+884]
   \   000003E6   0x4288             CMP      R0,R1
   \   000003E8   0xD333             BCC.N    ??SRMotorSafetyMgr__Handler250us_6
   \   000003EA   0xF894 0x0376      LDRB     R0,[R4, #+886]
   \   000003EE   0x2801             CMP      R0,#+1
   \   000003F0   0xD108             BNE.N    ??SRMotorSafetyMgr__Handler250us_7
   \   000003F2   0xF8D4 0x2548      LDR      R2,[R4, #+1352]
   \   000003F6   0xF204 0x517C      ADDW     R1,R4,#+1404
   \   000003FA   0xF504 0x60AB      ADD      R0,R4,#+1368
   \   000003FE   0x.... 0x....      BL       SRData__UpdateLong
   \   00000402   0xE006             B.N      ??SRMotorSafetyMgr__Handler250us_8
   \                     ??SRMotorSafetyMgr__Handler250us_7: (+1)
   \   00000404   0x2201             MOVS     R2,#+1
   \   00000406   0xF204 0x518C      ADDW     R1,R4,#+1420
   \   0000040A   0xF204 0x3076      ADDW     R0,R4,#+886
   \   0000040E   0x.... 0x....      BL       SRData__UpdateByte
   \                     ??SRMotorSafetyMgr__Handler250us_8: (+1)
   \   00000412   0x2200             MOVS     R2,#+0
   \   00000414   0xF204 0x5174      ADDW     R1,R4,#+1396
   \   00000418   0xF204 0x504C      ADDW     R0,R4,#+1356
   \   0000041C   0x.... 0x....      BL       SRData__UpdateLong
   \   00000420   0x2200             MOVS     R2,#+0
   \   00000422   0xF504 0x61AE      ADD      R1,R4,#+1392
   \   00000426   0xF504 0x60A9      ADD      R0,R4,#+1352
   \   0000042A   0x.... 0x....      BL       SRData__UpdateLong
   \   0000042E   0xE010             B.N      ??SRMotorSafetyMgr__Handler250us_6
   \                     ??SRMotorSafetyMgr__Handler250us_5: (+1)
   \   00000430   0x4286             CMP      R6,R0
   \   00000432   0xDA0E             BGE.N    ??SRMotorSafetyMgr__Handler250us_6
   \   00000434   0xF8D4 0x253C      LDR      R2,[R4, #+1340]
   \   00000438   0xF204 0x516C      ADDW     R1,R4,#+1388
   \   0000043C   0xF204 0x5044      ADDW     R0,R4,#+1348
   \   00000440   0x.... 0x....      BL       SRData__UpdateLong
   \   00000444   0x2201             MOVS     R2,#+1
   \   00000446   0xF504 0x715E      ADD      R1,R4,#+888
   \   0000044A   0xF204 0x3075      ADDW     R0,R4,#+885
   \   0000044E   0x.... 0x....      BL       SRData__UpdateByte
    652          
    653              // Invoke the pwm driver 250 handler
    654              SRMCPwm__Handler250us();
    655          
    656              SRMOTORSAFETYMGR_250US_FLOW_HANDLER_END();
   \                     ??SRMotorSafetyMgr__Handler250us_6: (+1)
   \   00000452   0xB001             ADD      SP,SP,#+4
   \   00000454   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   00000458   0x2001             MOVS     R0,#+1
   \   0000045A   0x.... 0x....      B.W      SRFlow__ISRLogEvent
    657          }
    658          
    659          
    660          
    661          //---------------------------------------------------------------------------------------------------------------------
    662          /**
    663           *  @brief      General slot for call rate of 1ms.
    664           */

   \                                 In section .text, align 2, keep-with-next
    665          void SRMotorSafetyMgr__Handler1ms(void)
    666          {
   \                     SRMotorSafetyMgr__Handler1ms: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    667              SRMOTORSAFETYMGR_1MS_FLOW_HANDLER_BEGIN();
   \   00000004   0x2003             MOVS     R0,#+3
   \   00000006   0x.... 0x....      BL       SRFlow__ISRLogEvent
    668          
    669          
    670              SRMOTORSAFETYMGR_1MS_FLOW_HANDLER_END();
   \   0000000A   0xB001             ADD      SP,SP,#+4
   \   0000000C   0xF85D 0xEB04      POP      {LR}
   \   00000010   0x2004             MOVS     R0,#+4
   \   00000012   0x.... 0x....      B.W      SRFlow__ISRLogEvent
    671          }
    672          
    673          
    674          
    675          //---------------------------------------------------------------------------------------------------------------------
    676          /**
    677           *  @brief      Perform the protection/plausibility check when required. The outcome of
    678           *              this method shall control the multiplexer which will allow/deny access
    679           *              to the PWM driver.
    680           */

   \                                 In section .text, align 4, keep-with-next
    681          void SRMotorSafetyMgr__Handler5ms(void)
    682          {
   \                     SRMotorSafetyMgr__Handler5ms: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    683              sint32 temp;
    684              sint32 temp1;
    685              uint32 temp2;
    686          #ifdef SR_BPM_MOTOR
    687              // Stacked variables to be used in the current reading
    688              sint32 temp_current_a;
    689              sint32 temp_current_b;
    690              sint32 temp_current_c;
    691          #endif
    692          
    693              SRMOTORSAFETYMGR_5MS_FLOW_HANDLER_BEGIN();
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       SRFlow__MainLogEvent
    694          
    695              CheckVariables4Failure_5ms();
   \   00000008   0xF8DF 0x4D88      LDR.W    R4,??SRMotorSafetyMgr__Handler5ms_0+0x8
   \   0000000C   0xF204 0x3173      ADDW     R1,R4,#+883
   \   00000010   0xF204 0x3072      ADDW     R0,R4,#+882
   \   00000014   0x.... 0x....      BL       SRData__CheckByte
   \   00000018   0xF504 0x7171      ADD      R1,R4,#+964
   \   0000001C   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   00000020   0x.... 0x....      BL       SRData__CheckShort
   \   00000024   0xF504 0x61B2      ADD      R1,R4,#+1424
   \   00000028   0xF504 0x7069      ADD      R0,R4,#+932
   \   0000002C   0x.... 0x....      BL       SRData__CheckShort
   \   00000030   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000034   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000038   0x.... 0x....      BL       SRData__CheckShort
   \   0000003C   0xF204 0x71D4      ADDW     R1,R4,#+2004
   \   00000040   0xF504 0x60A2      ADD      R0,R4,#+1296
   \   00000044   0x.... 0x....      BL       SRData__CheckLong
   \   00000048   0xF504 0x61FB      ADD      R1,R4,#+2008
   \   0000004C   0xF204 0x5014      ADDW     R0,R4,#+1300
   \   00000050   0x.... 0x....      BL       SRData__CheckLong
   \   00000054   0xF204 0x71DC      ADDW     R1,R4,#+2012
   \   00000058   0xF504 0x60A3      ADD      R0,R4,#+1304
   \   0000005C   0x.... 0x....      BL       SRData__CheckLong
   \   00000060   0xF204 0x71CC      ADDW     R1,R4,#+1996
   \   00000064   0xF504 0x60A1      ADD      R0,R4,#+1288
   \   00000068   0x.... 0x....      BL       SRData__CheckLong
   \   0000006C   0xF504 0x7172      ADD      R1,R4,#+968
   \   00000070   0xF504 0x706A      ADD      R0,R4,#+936
   \   00000074   0x.... 0x....      BL       SRData__CheckShort
   \   00000078   0xF504 0x7173      ADD      R1,R4,#+972
   \   0000007C   0xF504 0x706B      ADD      R0,R4,#+940
   \   00000080   0x.... 0x....      BL       SRData__CheckShort
   \   00000084   0xF504 0x7174      ADD      R1,R4,#+976
   \   00000088   0xF504 0x706C      ADD      R0,R4,#+944
   \   0000008C   0x.... 0x....      BL       SRData__CheckShort
   \   00000090   0xF204 0x5194      ADDW     R1,R4,#+1428
   \   00000094   0xF504 0x7070      ADD      R0,R4,#+960
   \   00000098   0x.... 0x....      BL       SRData__CheckShort
   \   0000009C   0xF504 0x61FA      ADD      R1,R4,#+2000
   \   000000A0   0xF204 0x500C      ADDW     R0,R4,#+1292
   \   000000A4   0x.... 0x....      BL       SRData__CheckLong
   \   000000A8   0xF504 0x61FE      ADD      R1,R4,#+2032
   \   000000AC   0xF204 0x502C      ADDW     R0,R4,#+1324
   \   000000B0   0x.... 0x....      BL       SRData__CheckLong
   \   000000B4   0xF204 0x71C4      ADDW     R1,R4,#+1988
   \   000000B8   0xF504 0x60A0      ADD      R0,R4,#+1280
   \   000000BC   0x.... 0x....      BL       SRData__CheckLong
   \   000000C0   0xF504 0x61F9      ADD      R1,R4,#+1992
   \   000000C4   0xF204 0x5004      ADDW     R0,R4,#+1284
   \   000000C8   0x.... 0x....      BL       SRData__CheckLong
   \   000000CC   0xF204 0x5184      ADDW     R1,R4,#+1412
   \   000000D0   0xF204 0x505C      ADDW     R0,R4,#+1372
   \   000000D4   0x.... 0x....      BL       SRData__CheckLong
   \   000000D8   0xF504 0x61B0      ADD      R1,R4,#+1408
   \   000000DC   0xF504 0x60AC      ADD      R0,R4,#+1376
   \   000000E0   0x.... 0x....      BL       SRData__CheckLong
    696          
    697              OverVoltageCheck();
   \   000000E4   0xF894 0x0372      LDRB     R0,[R4, #+882]
   \   000000E8   0x2803             CMP      R0,#+3
   \   000000EA   0xD03A             BEQ.N    ??SRMotorSafetyMgr__Handler5ms_1
   \   000000EC   0xF504 0x7177      ADD      R1,R4,#+988
   \   000000F0   0xF504 0x706F      ADD      R0,R4,#+956
   \   000000F4   0x.... 0x....      BL       SRData__CheckShort
   \   000000F8   0xF9B4 0x03BC      LDRSH    R0,[R4, #+956]
   \   000000FC   0xF2A0 0x500D      SUBW     R0,R0,#+1293
   \   00000100   0xF640 0x2178      MOVW     R1,#+2680
   \   00000104   0x4288             CMP      R0,R1
   \   00000106   0xD32C             BCC.N    ??SRMotorSafetyMgr__Handler5ms_1
   \   00000108   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   0000010C   0xF440 0x7200      ORR      R2,R0,#0x200
   \   00000110   0xF504 0x7171      ADD      R1,R4,#+964
   \   00000114   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   00000118   0x.... 0x....      BL       SRData__UpdateShort
   \   0000011C   0xF8B4 0x03A4      LDRH     R0,[R4, #+932]
   \   00000120   0xF440 0x7200      ORR      R2,R0,#0x200
   \   00000124   0xF504 0x61B2      ADD      R1,R4,#+1424
   \   00000128   0xF504 0x7069      ADD      R0,R4,#+932
   \   0000012C   0x.... 0x....      BL       SRData__UpdateShort
   \   00000130   0xF8DF 0x5E1C      LDR.W    R5,??SRMotorSafetyMgr__Handler5ms_2  ;; 0x40038008
   \   00000134   0x2000             MOVS     R0,#+0
   \   00000136   0x6328             STR      R0,[R5, #+48]
   \   00000138   0x62A8             STR      R0,[R5, #+40]
   \   0000013A   0x6228             STR      R0,[R5, #+32]
   \   0000013C   0x61A8             STR      R0,[R5, #+24]
   \   0000013E   0x6128             STR      R0,[R5, #+16]
   \   00000140   0x60A8             STR      R0,[R5, #+8]
   \   00000142   0xF44F 0x62FA      MOV      R2,#+2000
   \   00000146   0xF44F 0x7000      MOV      R0,#+512
   \   0000014A   0xF8C5 0x0090      STR      R0,[R5, #+144]
   \   0000014E   0xF504 0x61FE      ADD      R1,R4,#+2032
   \   00000152   0x6DA8             LDR      R0,[R5, #+88]
   \   00000154   0x0980             LSRS     R0,R0,#+6
   \   00000156   0x0180             LSLS     R0,R0,#+6
   \   00000158   0x65A8             STR      R0,[R5, #+88]
   \   0000015A   0xF204 0x502C      ADDW     R0,R4,#+1324
   \   0000015E   0x.... 0x....      BL       SRData__UpdateLong
    698          
    699              /////////////////////////////////////
    700              // This block will square each phase current and then add all of them.
    701              temp = (sint32)SR_CurrentA;
   \                     ??SRMotorSafetyMgr__Handler5ms_1: (+1)
   \   00000162   0xF9B4 0x03A8      LDRSH    R0,[R4, #+936]
    702              temp2  = (uint32)temp*temp;
    703          
    704              temp = (sint32)SR_CurrentB;
   \   00000166   0xF9B4 0x13AC      LDRSH    R1,[R4, #+940]
   \   0000016A   0xFB10 0xF000      SMULBB   R0,R0,R0
    705              temp2 += (uint32)temp*temp;
   \   0000016E   0xFB11 0x0001      SMLABB   R0,R1,R1,R0
    706          
    707              temp = (sint32)SR_CurrentC;
   \   00000172   0xF9B4 0x13B0      LDRSH    R1,[R4, #+944]
    708              temp2 += (uint32)temp*temp;
    709          
    710              SR_DATA_MCU_UPDATE_LONG(SR_SquaredCurrentsSum,temp2);
   \   00000176   0xFB11 0x0201      SMLABB   R2,R1,R1,R0
   \   0000017A   0xF204 0x71CC      ADDW     R1,R4,#+1996
   \   0000017E   0xF504 0x60A1      ADD      R0,R4,#+1288
   \   00000182   0x.... 0x....      BL       SRData__UpdateLong
    711          
    712          
    713              ////////////////////////////////////////////////////////////////////////////////////////////////
    714              ////////////////////////////////////////////////////////////////////////////////////////////////
    715              // Safety Fault Check
    716              temp = (sint32)SR_Motor_Fault;
    717              if(temp != 0)
   \   00000186   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   0000018A   0xB150             CBZ.N    R0,??SRMotorSafetyMgr__Handler5ms_3
    718              {
    719                  // Fault detected -> Move the state machine in error
    720                  // if it is not under initialization
    721                  temp1 = (sint32)SR_SafetyMngr_State;
    722                  if(temp1 > SAFETY_MNGR_INITIALIZE)
   \   0000018C   0xF894 0x0372      LDRB     R0,[R4, #+882]
   \   00000190   0x2802             CMP      R0,#+2
   \   00000192   0xDB06             BLT.N    ??SRMotorSafetyMgr__Handler5ms_3
    723                  {
    724                      SR_DATA_MCU_UPDATE_BYTE(SR_SafetyMngr_State,SAFETY_MNGR_ERROR_FOUND);    // Wait for zero speed flag...
   \   00000194   0x2206             MOVS     R2,#+6
   \   00000196   0xF204 0x3173      ADDW     R1,R4,#+883
   \   0000019A   0xF204 0x3072      ADDW     R0,R4,#+882
   \   0000019E   0x.... 0x....      BL       SRData__UpdateByte
    725                  }
    726              }
    727          
    728          
    729          
    730              temp = (sint32)SR_SafetyMngr_State;
   \                     ??SRMotorSafetyMgr__Handler5ms_3: (+1)
   \   000001A2   0xF894 0x0372      LDRB     R0,[R4, #+882]
    731              ////////////////////////////////////////////////////////////////////////////////////////////////
    732              ////////////////////////////////////////////////////////////////////////////////////////////////
    733              // This state is used when the motor is running
    734              if(temp == SAFETY_MNGR_RUNNING)
   \   000001A6   0x2805             CMP      R0,#+5
   \   000001A8   0xF040 0x80BC      BNE.W    ??SRMotorSafetyMgr__Handler5ms_4
    735              {
    736                  PhaseLostHandler();
   \   000001AC   0xF8D4 0x0514      LDR      R0,[R4, #+1300]
   \   000001B0   0x282B             CMP      R0,#+43
   \   000001B2   0xDA0E             BGE.N    ??SRMotorSafetyMgr__Handler5ms_5
   \   000001B4   0xF8D4 0x1518      LDR      R1,[R4, #+1304]
   \   000001B8   0xF240 0x10E5      MOVW     R0,#+485
   \   000001BC   0x4281             CMP      R1,R0
   \   000001BE   0xBFA4             ITT      GE 
   \   000001C0   0xF8D4 0x1510      LDRGE    R1,[R4, #+1296]
   \   000001C4   0x4281             CMPGE    R1,R0
   \   000001C6   0xDB36             BLT.N    ??SRMotorSafetyMgr__Handler5ms_6
   \   000001C8   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   000001CC   0xF440 0x7280      ORR      R2,R0,#0x100
   \   000001D0   0xE02B             B.N      ??SRMotorSafetyMgr__Handler5ms_7
   \                     ??SRMotorSafetyMgr__Handler5ms_5: (+1)
   \   000001D2   0xF8D4 0x0518      LDR      R0,[R4, #+1304]
   \   000001D6   0x282B             CMP      R0,#+43
   \   000001D8   0xDA0E             BGE.N    ??SRMotorSafetyMgr__Handler5ms_8
   \   000001DA   0xF8D4 0x1514      LDR      R1,[R4, #+1300]
   \   000001DE   0xF240 0x10E5      MOVW     R0,#+485
   \   000001E2   0x4281             CMP      R1,R0
   \   000001E4   0xBFA4             ITT      GE 
   \   000001E6   0xF8D4 0x1510      LDRGE    R1,[R4, #+1296]
   \   000001EA   0x4281             CMPGE    R1,R0
   \   000001EC   0xDB23             BLT.N    ??SRMotorSafetyMgr__Handler5ms_6
   \   000001EE   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   000001F2   0xF440 0x7280      ORR      R2,R0,#0x100
   \   000001F6   0xE018             B.N      ??SRMotorSafetyMgr__Handler5ms_7
   \                     ??SRMotorSafetyMgr__Handler5ms_8: (+1)
   \   000001F8   0xF8D4 0x0510      LDR      R0,[R4, #+1296]
   \   000001FC   0x282B             CMP      R0,#+43
   \   000001FE   0xDA0E             BGE.N    ??SRMotorSafetyMgr__Handler5ms_9
   \   00000200   0xF8D4 0x1518      LDR      R1,[R4, #+1304]
   \   00000204   0xF240 0x10E5      MOVW     R0,#+485
   \   00000208   0x4281             CMP      R1,R0
   \   0000020A   0xBFA4             ITT      GE 
   \   0000020C   0xF8D4 0x1514      LDRGE    R1,[R4, #+1300]
   \   00000210   0x4281             CMPGE    R1,R0
   \   00000212   0xDB10             BLT.N    ??SRMotorSafetyMgr__Handler5ms_6
   \   00000214   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   00000218   0xF440 0x7280      ORR      R2,R0,#0x100
   \   0000021C   0xE005             B.N      ??SRMotorSafetyMgr__Handler5ms_7
   \                     ??SRMotorSafetyMgr__Handler5ms_9: (+1)
   \   0000021E   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   00000222   0xF64F 0x61FF      MOVW     R1,#+65279
   \   00000226   0xEA01 0x0200      AND      R2,R1,R0
   \                     ??SRMotorSafetyMgr__Handler5ms_7: (+1)
   \   0000022A   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   0000022E   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000232   0x.... 0x....      BL       SRData__UpdateShort
   \                     ??SRMotorSafetyMgr__Handler5ms_6: (+1)
   \   00000236   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   0000023A   0xF3C0 0x2000      UBFX     R0,R0,#+8,#+1
   \   0000023E   0x2800             CMP      R0,#+0
   \   00000240   0xF8B4 0x03C0      LDRH     R0,[R4, #+960]
   \   00000244   0xD027             BEQ.N    ??SRMotorSafetyMgr__Handler5ms_10
   \   00000246   0x1C40             ADDS     R0,R0,#+1
   \   00000248   0xF8A4 0x03C0      STRH     R0,[R4, #+960]
   \   0000024C   0xF8B4 0x03C0      LDRH     R0,[R4, #+960]
   \   00000250   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   00000254   0xDD25             BLE.N    ??SRMotorSafetyMgr__Handler5ms_11
   \   00000256   0xF44F 0x707A      MOV      R0,#+1000
   \   0000025A   0xF8A4 0x03C0      STRH     R0,[R4, #+960]
   \   0000025E   0xF504 0x7171      ADD      R1,R4,#+964
   \   00000262   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   00000266   0xF040 0x0280      ORR      R2,R0,#0x80
   \   0000026A   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   0000026E   0x.... 0x....      BL       SRData__UpdateShort
   \   00000272   0xF8B4 0x03A4      LDRH     R0,[R4, #+932]
   \   00000276   0xF040 0x0280      ORR      R2,R0,#0x80
   \   0000027A   0xF504 0x61B2      ADD      R1,R4,#+1424
   \   0000027E   0xF504 0x7069      ADD      R0,R4,#+932
   \   00000282   0x.... 0x....      BL       SRData__UpdateShort
   \   00000286   0x22C8             MOVS     R2,#+200
   \   00000288   0xF504 0x61FE      ADD      R1,R4,#+2032
   \   0000028C   0xF204 0x502C      ADDW     R0,R4,#+1324
   \   00000290   0x.... 0x....      BL       SRData__UpdateLong
   \   00000294   0xE005             B.N      ??SRMotorSafetyMgr__Handler5ms_11
   \                     ??SRMotorSafetyMgr__Handler5ms_10: (+1)
   \   00000296   0xB120             CBZ.N    R0,??SRMotorSafetyMgr__Handler5ms_11
   \   00000298   0xF8B4 0x03C0      LDRH     R0,[R4, #+960]
   \   0000029C   0x1E40             SUBS     R0,R0,#+1
   \   0000029E   0xF8A4 0x03C0      STRH     R0,[R4, #+960]
   \                     ??SRMotorSafetyMgr__Handler5ms_11: (+1)
   \   000002A2   0xF204 0x5194      ADDW     R1,R4,#+1428
   \   000002A6   0xF8B4 0x23C0      LDRH     R2,[R4, #+960]
   \   000002AA   0xF504 0x7070      ADD      R0,R4,#+960
   \   000002AE   0x.... 0x....      BL       SRData__UpdateShort
    737          
    738                  SR_INPUTCAPTUREPLAUSIBILITYHANDLER();
    739          
    740                  Check_Avg_Frequency();
   \   000002B2   0xF204 0x517C      ADDW     R1,R4,#+1404
   \   000002B6   0xF504 0x60AB      ADD      R0,R4,#+1368
   \   000002BA   0x.... 0x....      BL       SRData__CheckLong
   \   000002BE   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
    741          
    742                  // If the arrival here comes from the state where a fault in the sensor
    743                  // was detected, then go to post run state.
    744                  temp1 = CheckHwFaultStatus();
   \   000002C2   0xF204 0x518A      ADDW     R1,R4,#+1418
   \   000002C6   0xF504 0x705C      ADD      R0,R4,#+880
   \   000002CA   0x.... 0x....      BL       SRData__CheckByte
   \   000002CE   0xBB10             CBNZ.N   R0,??SRMotorSafetyMgr__Handler5ms_12
   \   000002D0   0xF894 0x0370      LDRB     R0,[R4, #+880]
   \   000002D4   0x2804             CMP      R0,#+4
   \   000002D6   0xBF18             IT       NE 
   \   000002D8   0x2800             CMPNE    R0,#+0
   \   000002DA   0xD11C             BNE.N    ??SRMotorSafetyMgr__Handler5ms_12
   \   000002DC   0xF8DF 0x0C70      LDR.W    R0,??SRMotorSafetyMgr__Handler5ms_2  ;; 0x40038008
   \   000002E0   0x6EC0             LDR      R0,[R0, #+108]
   \   000002E2   0x0600             LSLS     R0,R0,#+24
   \   000002E4   0x0FC0             LSRS     R0,R0,#+31
   \   000002E6   0xD016             BEQ.N    ??SRMotorSafetyMgr__Handler5ms_12
   \   000002E8   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   000002EC   0xF040 0x0240      ORR      R2,R0,#0x40
   \   000002F0   0xF504 0x7171      ADD      R1,R4,#+964
   \   000002F4   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   000002F8   0x.... 0x....      BL       SRData__UpdateShort
   \   000002FC   0xF8B4 0x03A4      LDRH     R0,[R4, #+932]
   \   00000300   0xF040 0x0240      ORR      R2,R0,#0x40
   \   00000304   0xF504 0x61B2      ADD      R1,R4,#+1424
   \   00000308   0xF504 0x7069      ADD      R0,R4,#+932
   \   0000030C   0x.... 0x....      BL       SRData__UpdateShort
    745          
    746                  if(temp1) // If any error has been found, then go to post run - the motor will not start!
    747                  {
    748                      SR_DATA_MCU_UPDATE_LONG(SR_Timeout_Failure_Retry,ELECTRONIC_FAIL_TIMEOUT); //Load time out
   \   00000310   0x2278             MOVS     R2,#+120
   \   00000312   0xF000 0xBEBD      B.W      ??SRMotorSafetyMgr__Handler5ms_13
    749                  }
    750                  else
    751                  {
    752                      temp = (sint32)SR_Motor_Flags;
    753                      temp = BIT_TEST(temp, SR_FLAG_REQUESTED_TO_STOP);
    754                      if(temp)
   \                     ??SRMotorSafetyMgr__Handler5ms_12: (+1)
   \   00000316   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   0000031A   0x0700             LSLS     R0,R0,#+28
   \   0000031C   0xF140 0x86BE      BPL.W    ??SRMotorSafetyMgr__Handler5ms_14
    755                      {
    756                          SR_DATA_MCU_UPDATE_BYTE(SR_SafetyMngr_State,SAFETY_MNGR_POSTRUN_TESTS);
   \   00000320   0xF000 0xBEAD      B.W      ??SRMotorSafetyMgr__Handler5ms_15
    757                      }
    758                  }
    759              }
    760          
    761          
    762          
    763              ////////////////////////////////////////////////////////////////////////////////////////////////
    764              ////////////////////////////////////////////////////////////////////////////////////////////////
    765              /// The state performs tests after running and before setting the unlock door speed flag,    ///
    766              /// the goal is check the harness and hardware before setting the unlock door speed flag     ///
    767              /// The motor in state is still considered as running, this state machine might go back to   ///
    768              /// the running state on a new Prepare2Start motor. The goal is to prevent a dead lock when  ///
    769              /// verifying any condition after running the motor.
    770              else if(temp == SAFETY_MNGR_POSTRUN_TESTS)
   \                     ??SRMotorSafetyMgr__Handler5ms_4: (+1)
   \   00000324   0x2804             CMP      R0,#+4
   \   00000326   0xF040 0x80DF      BNE.W    ??SRMotorSafetyMgr__Handler5ms_16
    771              {
    772          
    773                  SR_MOTORSAFETY_MGR_POSTRUN_ACTION();
   \   0000032A   0xF8DF 0x5C24      LDR.W    R5,??SRMotorSafetyMgr__Handler5ms_2  ;; 0x40038008
   \   0000032E   0x2000             MOVS     R0,#+0
   \   00000330   0x6328             STR      R0,[R5, #+48]
   \   00000332   0x62A8             STR      R0,[R5, #+40]
   \   00000334   0x6228             STR      R0,[R5, #+32]
   \   00000336   0x61A8             STR      R0,[R5, #+24]
   \   00000338   0x6128             STR      R0,[R5, #+16]
   \   0000033A   0x60A8             STR      R0,[R5, #+8]
   \   0000033C   0xF44F 0x7000      MOV      R0,#+512
   \   00000340   0xF8C5 0x0090      STR      R0,[R5, #+144]
   \   00000344   0x6DA8             LDR      R0,[R5, #+88]
   \   00000346   0x0980             LSRS     R0,R0,#+6
   \   00000348   0x0180             LSLS     R0,R0,#+6
   \   0000034A   0x65A8             STR      R0,[R5, #+88]
    774          
    775                  SR_MOTORMOVINGHANDLER();                    // Invoke the Unlock Door Speed handler
   \   0000034C   0x.... 0x....      BL       ??MotorMovingHandlerBpm
    776          
    777                  // if the sensors could not be checked, send
    778                  // the machine to the waiting state, and keep 
    779                  // seeing for a while if there is no current 
    780                  // flowing through the shunt resistors.
    781          #ifdef SR_BPM_MOTOR
    782          
    783                  temp = (sint32)SR_Motor_Flags;
   \   00000350   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
    784                  temp = BIT_TEST(temp, SR_FLAG_UNLOCK_DOOR_SPEED_CHECK_REQUESTED);
    785          
    786          #endif
    787          
    788          #ifdef SR_CIM_MOTOR
    789          
    790                  temp = (sint32)SR_Motor_Flags;
    791                  temp = BIT_TEST(temp, SR_FLAG_UNLOCK_DOOR_SPEED);
    792          #endif
    793          
    794                  temp1 = (sint32)SR_Motor_Fault;
    795                  temp1 = BIT_TEST(temp1, SR_FAULT_UNLOCK_DOOR_SPEED_FAILED);
    796          
    797          
    798                  if(temp1)
   \   00000354   0xF8B4 0x13A2      LDRH     R1,[R4, #+930]
   \   00000358   0x0709             LSLS     R1,R1,#+28
   \   0000035A   0xBF48             IT       MI 
    799                  {
    800                      // Unlock door speed failed
    801                      SR_DATA_MCU_UPDATE_LONG(SR_Timeout_Failure_Retry,TACHO_TIMEOUT); //Load time out
   \   0000035C   0x2278             MOVMI    R2,#+120
   \   0000035E   0xF100 0x8697      BMI.W    ??SRMotorSafetyMgr__Handler5ms_13
    802                  }
    803                  else if(temp)
   \   00000362   0x0540             LSLS     R0,R0,#+21
   \   00000364   0xF140 0x869A      BPL.W    ??SRMotorSafetyMgr__Handler5ms_14
    804                  {
    805                      // Unlock door speed found
    806                      temp = (sint32)SR_Motor_Flags;
   \   00000368   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
    807                      BIT_CLR(temp, SR_FLAG_REQUESTED_TO_START);
    808                      SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,temp);
   \   0000036C   0xF64F 0x71FB      MOVW     R1,#+65531
   \   00000370   0xEA01 0x0200      AND      R2,R1,R0
   \   00000374   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000378   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   0000037C   0x.... 0x....      BL       SRData__UpdateShort
    809          
    810          #ifdef SR_BPM_MOTOR
    811                      // Idle for this amount of time before checking hardware integrity
    812                      temp = (sint32)SR_Motor_Flags;
    813                      temp = BIT_TEST(temp, SR_FLAG_FORCE_TO_STOP);
    814                      if(temp)
   \   00000380   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   00000384   0x0500             LSLS     R0,R0,#+20
   \   00000386   0xBF4C             ITE      MI 
    815                      {
    816                          // a force to stop was requested --> immediately check hardware integrity
    817                          SR_DATA_MCU_UPDATE_LONG(SR_Check_Unlock_Door_Speed_Timer, 0);
   \   00000388   0x2200             MOVMI    R2,#+0
    818                      }
    819                      else
    820                      {   // standard stop request --> wait some time before checking hardware integrity
    821                          SR_DATA_MCU_UPDATE_LONG(SR_Check_Unlock_Door_Speed_Timer, CHECK_UNLOCK_DOOR_SPEED_IDLING_BEFORE_CHECK_COUNT);
   \   0000038A   0xF44F 0x727A      MOVPL    R2,#+1000
   \   0000038E   0xF204 0x5184      ADDW     R1,R4,#+1412
   \   00000392   0xF204 0x505C      ADDW     R0,R4,#+1372
   \   00000396   0x.... 0x....      BL       SRData__UpdateLong
    822                      }
    823          #endif
    824          
    825                      Init_Avg_Frequency();
   \   0000039A   0xF504 0x715E      ADD      R1,R4,#+888
   \   0000039E   0xF204 0x3075      ADDW     R0,R4,#+885
   \   000003A2   0x.... 0x....      BL       SRData__CheckByte
   \   000003A6   0xF204 0x5164      ADDW     R1,R4,#+1380
   \   000003AA   0xF204 0x503C      ADDW     R0,R4,#+1340
   \   000003AE   0x.... 0x....      BL       SRData__CheckLong
   \   000003B2   0xF504 0x61AD      ADD      R1,R4,#+1384
   \   000003B6   0xF504 0x60A8      ADD      R0,R4,#+1344
   \   000003BA   0x.... 0x....      BL       SRData__CheckLong
   \   000003BE   0xF204 0x516C      ADDW     R1,R4,#+1388
   \   000003C2   0xF204 0x5044      ADDW     R0,R4,#+1348
   \   000003C6   0x.... 0x....      BL       SRData__CheckLong
   \   000003CA   0xF504 0x61AE      ADD      R1,R4,#+1392
   \   000003CE   0xF504 0x60A9      ADD      R0,R4,#+1352
   \   000003D2   0x.... 0x....      BL       SRData__CheckLong
   \   000003D6   0xF204 0x5174      ADDW     R1,R4,#+1396
   \   000003DA   0xF204 0x504C      ADDW     R0,R4,#+1356
   \   000003DE   0x.... 0x....      BL       SRData__CheckLong
   \   000003E2   0xF204 0x517C      ADDW     R1,R4,#+1404
   \   000003E6   0xF504 0x60AB      ADD      R0,R4,#+1368
   \   000003EA   0x.... 0x....      BL       SRData__CheckLong
   \   000003EE   0xF504 0x61AF      ADD      R1,R4,#+1400
   \   000003F2   0xF504 0x60AA      ADD      R0,R4,#+1360
   \   000003F6   0x.... 0x....      BL       SRData__CheckLong
   \   000003FA   0xF204 0x518C      ADDW     R1,R4,#+1420
   \   000003FE   0xF204 0x3076      ADDW     R0,R4,#+886
   \   00000402   0x.... 0x....      BL       SRData__CheckByte
   \   00000406   0x6828             LDR      R0,[R5, #+0]
   \   00000408   0x1C40             ADDS     R0,R0,#+1
   \   0000040A   0xEE00 0x0A10      VMOV     S0,R0
   \   0000040E   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000412   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000416   0xEE10 0x0A10      VMOV     R0,S0
   \   0000041A   0x1040             ASRS     R0,R0,#+1
   \   0000041C   0xEE00 0x0A10      VMOV     S0,R0
   \   00000420   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000424   0xEDDF 0x0AD8      VLDR.W   S1,??SRMotorSafetyMgr__Handler5ms_17  ;; 0x3f866666
   \   00000428   0xEE60 0x0A20      VMUL.F32 S1,S0,S1
   \   0000042C   0xF204 0x503C      ADDW     R0,R4,#+1340
   \   00000430   0xEEFD 0x0AE0      VCVT.S32.F32 S1,S1
   \   00000434   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
   \   00000438   0xED9F 0x1AD4      VLDR.W   S2,??SRMotorSafetyMgr__Handler5ms_17+0x4  ;; 0x3f733333
   \   0000043C   0xEE20 0x0A01      VMUL.F32 S0,S0,S2
   \   00000440   0xF204 0x5040      ADDW     R0,R4,#+1344
   \   00000444   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000448   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   0000044C   0xEE10 0x2A90      VMOV     R2,S1
   \   00000450   0xF204 0x5164      ADDW     R1,R4,#+1380
   \   00000454   0xF204 0x503C      ADDW     R0,R4,#+1340
   \   00000458   0x.... 0x....      BL       SRData__UpdateLong
   \   0000045C   0xF8D4 0x2540      LDR      R2,[R4, #+1344]
   \   00000460   0xF504 0x61AD      ADD      R1,R4,#+1384
   \   00000464   0xF504 0x60A8      ADD      R0,R4,#+1344
   \   00000468   0x.... 0x....      BL       SRData__UpdateLong
   \   0000046C   0xF8D4 0x2540      LDR      R2,[R4, #+1344]
   \   00000470   0xF204 0x516C      ADDW     R1,R4,#+1388
   \   00000474   0xF204 0x5044      ADDW     R0,R4,#+1348
   \   00000478   0x.... 0x....      BL       SRData__UpdateLong
   \   0000047C   0x2200             MOVS     R2,#+0
   \   0000047E   0xF504 0x715E      ADD      R1,R4,#+888
   \   00000482   0xF204 0x3075      ADDW     R0,R4,#+885
   \   00000486   0x.... 0x....      BL       SRData__UpdateByte
   \   0000048A   0x2200             MOVS     R2,#+0
   \   0000048C   0xF504 0x61AE      ADD      R1,R4,#+1392
   \   00000490   0xF504 0x60A9      ADD      R0,R4,#+1352
   \   00000494   0x.... 0x....      BL       SRData__UpdateLong
   \   00000498   0xF04F 0x4280      MOV      R2,#+1073741824
   \   0000049C   0xF204 0x5174      ADDW     R1,R4,#+1396
   \   000004A0   0xF204 0x504C      ADDW     R0,R4,#+1356
   \   000004A4   0x.... 0x....      BL       SRData__UpdateLong
   \   000004A8   0xF04F 0x4280      MOV      R2,#+1073741824
   \   000004AC   0xF204 0x517C      ADDW     R1,R4,#+1404
   \   000004B0   0xF504 0x60AB      ADD      R0,R4,#+1368
   \   000004B4   0x.... 0x....      BL       SRData__UpdateLong
   \   000004B8   0x2200             MOVS     R2,#+0
   \   000004BA   0xF504 0x61AF      ADD      R1,R4,#+1400
   \   000004BE   0xF504 0x60AA      ADD      R0,R4,#+1360
   \   000004C2   0x.... 0x....      BL       SRData__UpdateLong
   \   000004C6   0x2200             MOVS     R2,#+0
   \   000004C8   0xF504 0x6100      ADD      R1,R4,#+2048
   \   000004CC   0xF204 0x5054      ADDW     R0,R4,#+1364
   \   000004D0   0x.... 0x....      BL       SRData__UpdateLong
   \   000004D4   0x2200             MOVS     R2,#+0
   \   000004D6   0xF204 0x518C      ADDW     R1,R4,#+1420
   \   000004DA   0xF204 0x3076      ADDW     R0,R4,#+886
   \   000004DE   0x.... 0x....      BL       SRData__UpdateByte
    826          
    827                      // Go idle
    828                      SR_DATA_MCU_UPDATE_BYTE(SR_SafetyMngr_State,SAFETY_MNGR_IDLE);
   \   000004E2   0x2202             MOVS     R2,#+2
   \   000004E4   0xF000 0xBDCC      B.W      ??SRMotorSafetyMgr__Handler5ms_18
    829                  }
    830          
    831              }
    832          
    833          
    834              ////////////////////////////////////////////////////////////////////////////////////////////////
    835              ////////////////////////////////////////////////////////////////////////////////////////////////
    836              // All tests before running the motor has to be performed within this state
    837              else if(temp == SAFETY_MNGR_PRERUN_TESTS)
   \                     ??SRMotorSafetyMgr__Handler5ms_16: (+1)
   \   000004E8   0x2803             CMP      R0,#+3
   \   000004EA   0xF040 0x8151      BNE.W    ??SRMotorSafetyMgr__Handler5ms_19
    838              {
    839                  SRMCPwm__TurnOnLowSideGates();          // As in the idle state, the IGBTs are switched off
   \   000004EE   0xF8DF 0x5A60      LDR.W    R5,??SRMotorSafetyMgr__Handler5ms_2  ;; 0x40038008
   \   000004F2   0x2000             MOVS     R0,#+0
   \   000004F4   0x6328             STR      R0,[R5, #+48]
   \   000004F6   0x62A8             STR      R0,[R5, #+40]
   \   000004F8   0x6228             STR      R0,[R5, #+32]
   \   000004FA   0x61A8             STR      R0,[R5, #+24]
   \   000004FC   0x6128             STR      R0,[R5, #+16]
   \   000004FE   0x60A8             STR      R0,[R5, #+8]
   \   00000500   0xF44F 0x7000      MOV      R0,#+512
   \   00000504   0xF8C5 0x0090      STR      R0,[R5, #+144]
   \   00000508   0x6DA8             LDR      R0,[R5, #+88]
   \   0000050A   0x0980             LSRS     R0,R0,#+6
   \   0000050C   0x0180             LSLS     R0,R0,#+6
   \   0000050E   0x65A8             STR      R0,[R5, #+88]
    840                  // then the inverter bootstrap capacitors need to be
    841                  // charged. The time is provided by the longest
    842                  // peripheral integrity check, in this case, the
    843                  // SRMCPwm Diagnostic handler.
    844          
    845                  temp = (sint32)SR_Motor_Flags;
    846                  temp = BIT_TEST(temp, SR_FLAG_REQUESTED_TO_START);
    847                  if(temp)
   \   00000510   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   00000514   0x0740             LSLS     R0,R0,#+29
   \   00000516   0xD53C             BPL.N    ??SRMotorSafetyMgr__Handler5ms_20
    848                  {
    849                      // Clear the request to start bit.
    850                      temp = (sint32)SR_Motor_Flags;
   \   00000518   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
    851                      BIT_CLR(temp, SR_FLAG_REQUESTED_TO_START);
    852                      SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,temp);
   \   0000051C   0xF64F 0x71FB      MOVW     R1,#+65531
   \   00000520   0xEA01 0x0200      AND      R2,R1,R0
   \   00000524   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000528   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   0000052C   0x.... 0x....      BL       SRData__UpdateShort
    853          
    854                      // Clear the "prerun tests finished" bit.
    855                      // This bit shall be set by finishing the plausibility check
    856                      // of the hardware. The plausibility check tests are
    857                      // implemented in the SRMotorSafetyMgr__MCPwmHandler()
    858                      temp = (sint32)SR_Motor_Flags;
   \   00000530   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
    859                      BIT_CLR(temp, SR_FLAG_PRERUN_TESTS_FINISHED);
    860                      SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,temp);
   \   00000534   0xF64F 0x71EF      MOVW     R1,#+65519
   \   00000538   0xEA01 0x0200      AND      R2,R1,R0
   \   0000053C   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000540   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000544   0x.... 0x....      BL       SRData__UpdateShort
    861          
    862          
    863          #ifdef SR_CIM_MOTOR
    864                      // If the InputCapture is disabled, enable it
    865                      if (SRMCInputCapture__GetStatus() != ENABLED)
    866                      {
    867                          SRMCInputCapture__EnableCapture();
    868                      }
    869          
    870                      SRMCInputCapture__InitDiagnostic();
    871          #endif
    872          
    873                      SRMCAtod__EnableDiagnostic(SR_MCATOD_PLAUSIBILITY_CHECK_THRESHOLD);
   \   00000548   0xF504 0x61B1      ADD      R1,R4,#+1416
   \   0000054C   0xF204 0x306E      ADDW     R0,R4,#+878
   \   00000550   0x.... 0x....      BL       SRData__CheckByte
   \   00000554   0xF204 0x518E      ADDW     R1,R4,#+1422
   \   00000558   0xF204 0x309A      ADDW     R0,R4,#+922
   \   0000055C   0x.... 0x....      BL       SRData__CheckShort
   \   00000560   0xF894 0x036E      LDRB     R0,[R4, #+878]
   \   00000564   0x2800             CMP      R0,#+0
   \   00000566   0xBF18             IT       NE 
   \   00000568   0x2805             CMPNE    R0,#+5
   \   0000056A   0xD10D             BNE.N    ??SRMotorSafetyMgr__Handler5ms_21
   \   0000056C   0x227D             MOVS     R2,#+125
   \   0000056E   0xF204 0x518E      ADDW     R1,R4,#+1422
   \   00000572   0xF204 0x309A      ADDW     R0,R4,#+922
   \   00000576   0x.... 0x....      BL       SRData__UpdateShort
   \   0000057A   0x2201             MOVS     R2,#+1
   \   0000057C   0xF504 0x61B1      ADD      R1,R4,#+1416
   \   00000580   0xF204 0x306E      ADDW     R0,R4,#+878
   \   00000584   0x.... 0x....      BL       SRData__UpdateByte
    874                      SRMCPwm__EnableDiagnostic(SD_PIN_ZERO_TIME, SD_PIN_ONE_TIME);
   \                     ??SRMotorSafetyMgr__Handler5ms_21: (+1)
   \   00000588   0xF44F 0x71A0      MOV      R1,#+320
   \   0000058C   0x2028             MOVS     R0,#+40
   \   0000058E   0x.... 0x....      BL       SRMCPwm__EnableDiagnostic
    875                  }
    876          
    877                  // Check if the plausibility chech has been already performed
    878                  temp = (sint32)SR_Motor_Flags;
    879                  temp = BIT_TEST(temp, SR_FLAG_PRERUN_TESTS_FINISHED);
    880                  if(temp)
   \                     ??SRMotorSafetyMgr__Handler5ms_20: (+1)
   \   00000592   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   00000596   0x06C0             LSLS     R0,R0,#+27
   \   00000598   0xF140 0x80CA      BPL.W    ??SRMotorSafetyMgr__Handler5ms_22
    881                  {
    882          
    883                      SR_INITMOTORMOVINGHANDLER();       // Initialize the zero speed handler
   \   0000059C   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   000005A0   0xF64F 0x71FE      MOVW     R1,#+65534
   \   000005A4   0xEA01 0x0200      AND      R2,R1,R0
   \   000005A8   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   000005AC   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   000005B0   0x.... 0x....      BL       SRData__UpdateShort
   \   000005B4   0x2200             MOVS     R2,#+0
   \   000005B6   0xF504 0x61F9      ADD      R1,R4,#+1992
   \   000005BA   0xF204 0x5004      ADDW     R0,R4,#+1284
   \   000005BE   0x.... 0x....      BL       SRData__UpdateLong
   \   000005C2   0x2200             MOVS     R2,#+0
   \   000005C4   0xF204 0x71C4      ADDW     R1,R4,#+1988
   \   000005C8   0xF504 0x60A0      ADD      R0,R4,#+1280
   \   000005CC   0x.... 0x....      BL       SRData__UpdateLong
    884          
    885                      Init_Avg_Frequency();
   \   000005D0   0xF504 0x715E      ADD      R1,R4,#+888
   \   000005D4   0xF204 0x3075      ADDW     R0,R4,#+885
   \   000005D8   0x.... 0x....      BL       SRData__CheckByte
   \   000005DC   0xF204 0x5164      ADDW     R1,R4,#+1380
   \   000005E0   0xF204 0x503C      ADDW     R0,R4,#+1340
   \   000005E4   0x.... 0x....      BL       SRData__CheckLong
   \   000005E8   0xF504 0x61AD      ADD      R1,R4,#+1384
   \   000005EC   0xF504 0x60A8      ADD      R0,R4,#+1344
   \   000005F0   0x.... 0x....      BL       SRData__CheckLong
   \   000005F4   0xF204 0x516C      ADDW     R1,R4,#+1388
   \   000005F8   0xF204 0x5044      ADDW     R0,R4,#+1348
   \   000005FC   0x.... 0x....      BL       SRData__CheckLong
   \   00000600   0xF504 0x61AE      ADD      R1,R4,#+1392
   \   00000604   0xF504 0x60A9      ADD      R0,R4,#+1352
   \   00000608   0x.... 0x....      BL       SRData__CheckLong
   \   0000060C   0xF204 0x5174      ADDW     R1,R4,#+1396
   \   00000610   0xF204 0x504C      ADDW     R0,R4,#+1356
   \   00000614   0x.... 0x....      BL       SRData__CheckLong
   \   00000618   0xF204 0x517C      ADDW     R1,R4,#+1404
   \   0000061C   0xF504 0x60AB      ADD      R0,R4,#+1368
   \   00000620   0x.... 0x....      BL       SRData__CheckLong
   \   00000624   0xF504 0x61AF      ADD      R1,R4,#+1400
   \   00000628   0xF504 0x60AA      ADD      R0,R4,#+1360
   \   0000062C   0x.... 0x....      BL       SRData__CheckLong
   \   00000630   0xF204 0x518C      ADDW     R1,R4,#+1420
   \   00000634   0xF204 0x3076      ADDW     R0,R4,#+886
   \   00000638   0x.... 0x....      BL       SRData__CheckByte
   \   0000063C   0x6828             LDR      R0,[R5, #+0]
   \   0000063E   0x1C40             ADDS     R0,R0,#+1
   \   00000640   0xEE00 0x0A10      VMOV     S0,R0
   \   00000644   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000648   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000064C   0xEE10 0x0A10      VMOV     R0,S0
   \   00000650   0x1040             ASRS     R0,R0,#+1
   \   00000652   0xEE00 0x0A10      VMOV     S0,R0
   \   00000656   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000065A   0xEDDF 0x0A4B      VLDR.W   S1,??SRMotorSafetyMgr__Handler5ms_17  ;; 0x3f866666
   \   0000065E   0xEE60 0x0A20      VMUL.F32 S1,S0,S1
   \   00000662   0xF204 0x503C      ADDW     R0,R4,#+1340
   \   00000666   0xEEFD 0x0AE0      VCVT.S32.F32 S1,S1
   \   0000066A   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
   \   0000066E   0xED9F 0x1A47      VLDR.W   S2,??SRMotorSafetyMgr__Handler5ms_17+0x4  ;; 0x3f733333
   \   00000672   0xEE20 0x0A01      VMUL.F32 S0,S0,S2
   \   00000676   0xF204 0x5040      ADDW     R0,R4,#+1344
   \   0000067A   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000067E   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   00000682   0xEE10 0x2A90      VMOV     R2,S1
   \   00000686   0xF204 0x5164      ADDW     R1,R4,#+1380
   \   0000068A   0xF204 0x503C      ADDW     R0,R4,#+1340
   \   0000068E   0x.... 0x....      BL       SRData__UpdateLong
   \   00000692   0xF8D4 0x2540      LDR      R2,[R4, #+1344]
   \   00000696   0xF504 0x61AD      ADD      R1,R4,#+1384
   \   0000069A   0xF504 0x60A8      ADD      R0,R4,#+1344
   \   0000069E   0x.... 0x....      BL       SRData__UpdateLong
   \   000006A2   0xF8D4 0x2540      LDR      R2,[R4, #+1344]
   \   000006A6   0xF204 0x516C      ADDW     R1,R4,#+1388
   \   000006AA   0xF204 0x5044      ADDW     R0,R4,#+1348
   \   000006AE   0x.... 0x....      BL       SRData__UpdateLong
   \   000006B2   0x2200             MOVS     R2,#+0
   \   000006B4   0xF504 0x715E      ADD      R1,R4,#+888
   \   000006B8   0xF204 0x3075      ADDW     R0,R4,#+885
   \   000006BC   0x.... 0x....      BL       SRData__UpdateByte
   \   000006C0   0x2200             MOVS     R2,#+0
   \   000006C2   0xF504 0x61AE      ADD      R1,R4,#+1392
   \   000006C6   0xF504 0x60A9      ADD      R0,R4,#+1352
   \   000006CA   0x.... 0x....      BL       SRData__UpdateLong
   \   000006CE   0xF04F 0x4280      MOV      R2,#+1073741824
   \   000006D2   0xF204 0x5174      ADDW     R1,R4,#+1396
   \   000006D6   0xF204 0x504C      ADDW     R0,R4,#+1356
   \   000006DA   0x.... 0x....      BL       SRData__UpdateLong
   \   000006DE   0xF04F 0x4280      MOV      R2,#+1073741824
   \   000006E2   0xF204 0x517C      ADDW     R1,R4,#+1404
   \   000006E6   0xF504 0x60AB      ADD      R0,R4,#+1368
   \   000006EA   0x.... 0x....      BL       SRData__UpdateLong
   \   000006EE   0x2200             MOVS     R2,#+0
   \   000006F0   0xF504 0x61AF      ADD      R1,R4,#+1400
   \   000006F4   0xF504 0x60AA      ADD      R0,R4,#+1360
   \   000006F8   0x.... 0x....      BL       SRData__UpdateLong
   \   000006FC   0x2200             MOVS     R2,#+0
   \   000006FE   0xF504 0x6100      ADD      R1,R4,#+2048
   \   00000702   0xF204 0x5054      ADDW     R0,R4,#+1364
   \   00000706   0x.... 0x....      BL       SRData__UpdateLong
   \   0000070A   0x2200             MOVS     R2,#+0
   \   0000070C   0xF204 0x518C      ADDW     R1,R4,#+1420
   \   00000710   0xF204 0x3076      ADDW     R0,R4,#+886
   \   00000714   0x.... 0x....      BL       SRData__UpdateByte
    886          
    887                      // Check if a request to stop has arrived when performing the pre run tests.
    888                      // There are handler in conditional states, these flags prevents leaving
    889                      // pre run state without accomplishing those tests.
    890                      temp = (sint32)SR_Motor_Flags;
    891                      temp = BIT_TEST(temp, SR_FLAG_REQUESTED_TO_STOP);
    892                      if(temp)
   \   00000718   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   0000071C   0x0700             LSLS     R0,R0,#+28
   \   0000071E   0xBF4C             ITE      MI 
    893                      {
    894                          SR_DATA_MCU_UPDATE_BYTE(SR_SafetyMngr_State,SAFETY_MNGR_POSTRUN_TESTS);
   \   00000720   0x2204             MOVMI    R2,#+4
    895                      }
    896                      else
    897                      {
    898                          // Go to running state and allow the pwm access for the class A software.
    899                          SR_DATA_MCU_UPDATE_BYTE(SR_SafetyMngr_State,SAFETY_MNGR_RUNNING);
   \   00000722   0x2205             MOVPL    R2,#+5
   \   00000724   0xF204 0x3173      ADDW     R1,R4,#+883
   \   00000728   0xF204 0x3072      ADDW     R0,R4,#+882
   \   0000072C   0x.... 0x....      BL       SRData__UpdateByte
    900                      }
    901          
    902                  }
    903          
    904                  // If the arrival here comes from the state where a fault in the sensor
    905                  // was detected, then go to error state.
    906                  temp1 = CheckHwFaultStatus();
   \                     ??SRMotorSafetyMgr__Handler5ms_22: (+1)
   \   00000730   0xF204 0x518A      ADDW     R1,R4,#+1418
   \   00000734   0xF504 0x705C      ADD      R0,R4,#+880
   \   00000738   0x.... 0x....      BL       SRData__CheckByte
   \   0000073C   0x2800             CMP      R0,#+0
   \   0000073E   0xF040 0x84AD      BNE.W    ??SRMotorSafetyMgr__Handler5ms_14
   \   00000742   0xF894 0x0370      LDRB     R0,[R4, #+880]
   \   00000746   0x2804             CMP      R0,#+4
   \   00000748   0xBF18             IT       NE 
   \   0000074A   0x2800             CMPNE    R0,#+0
   \   0000074C   0xF040 0x84A6      BNE.W    ??SRMotorSafetyMgr__Handler5ms_14
   \   00000750   0x6EE8             LDR      R0,[R5, #+108]
   \   00000752   0x0600             LSLS     R0,R0,#+24
   \   00000754   0x0FC0             LSRS     R0,R0,#+31
   \   00000756   0xF000 0x84A1      BEQ.W    ??SRMotorSafetyMgr__Handler5ms_14
   \   0000075A   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   0000075E   0xF040 0x0240      ORR      R2,R0,#0x40
   \   00000762   0xF504 0x7171      ADD      R1,R4,#+964
   \   00000766   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   0000076A   0x.... 0x....      BL       SRData__UpdateShort
   \   0000076E   0xF8B4 0x03A4      LDRH     R0,[R4, #+932]
   \   00000772   0xF040 0x0240      ORR      R2,R0,#0x40
   \   00000776   0xF504 0x61B2      ADD      R1,R4,#+1424
   \   0000077A   0xF504 0x7069      ADD      R0,R4,#+932
   \   0000077E   0x.... 0x....      BL       SRData__UpdateShort
    907          
    908                  if(temp1) // If any error has been found, then go to error - the motor will not start!
    909                  {
    910                      SR_DATA_MCU_UPDATE_LONG(SR_Timeout_Failure_Retry,ELECTRONIC_FAIL_TIMEOUT); //Load time out
   \   00000782   0x2278             MOVS     R2,#+120
   \   00000784   0xF000 0xBC84      B.W      ??SRMotorSafetyMgr__Handler5ms_13
   \                     ??SRMotorSafetyMgr__Handler5ms_17:
   \   00000788   0x3F866666         DC32     0x3f866666
   \   0000078C   0x3F733333         DC32     0x3f733333
    911                  }
    912              }
    913          
    914          
    915              ////////////////////////////////////////////////////////////////////////////////////////////////
    916              ////////////////////////////////////////////////////////////////////////////////////////////////
    917              // When the state machine is able to accept requests to run the pre run tests,
    918              // shall stay in this IDLE state
    919              else if(temp == SAFETY_MNGR_IDLE)
   \                     ??SRMotorSafetyMgr__Handler5ms_19: (+1)
   \   00000790   0x2802             CMP      R0,#+2
   \   00000792   0xF040 0x812E      BNE.W    ??SRMotorSafetyMgr__Handler5ms_23
    920              {
    921                  //! Turning both low and high side igbt off does not cause bee noise when motor stopped
    922                  SRMCPwm__TurnOffAllGates();
   \   00000796   0xF8DF 0x57B8      LDR.W    R5,??SRMotorSafetyMgr__Handler5ms_2  ;; 0x40038008
   \   0000079A   0x6DA8             LDR      R0,[R5, #+88]
   \   0000079C   0xF040 0x003F      ORR      R0,R0,#0x3F
   \   000007A0   0x65A8             STR      R0,[R5, #+88]
   \   000007A2   0x6EE8             LDR      R0,[R5, #+108]
   \   000007A4   0x0601             LSLS     R1,R0,#+24
   \   000007A6   0x0FC9             LSRS     R1,R1,#+31
   \   000007A8   0xBF1C             ITT      NE 
   \   000007AA   0xF020 0x008F      BICNE    R0,R0,#0x8F
   \   000007AE   0x66E8             STRNE    R0,[R5, #+108]
    923          
    924                  AverageSensorsOffset();                 // Average the offsets and update the analog data
   \   000007B0   0x2000             MOVS     R0,#+0
   \   000007B2   0xF3EF 0x8610      MRS      R6,PRIMASK
   \   000007B6   0xB672             CPSID    I
   \   000007B8   0xF9B4 0x13A8      LDRSH    R1,[R4, #+936]
   \   000007BC   0xF9B4 0x23C8      LDRSH    R2,[R4, #+968]
   \   000007C0   0x43D2             MVNS     R2,R2
   \   000007C2   0xB289             UXTH     R1,R1
   \   000007C4   0xB292             UXTH     R2,R2
   \   000007C6   0x4291             CMP      R1,R2
   \   000007C8   0xBF18             IT       NE 
   \   000007CA   0x2001             MOVNE    R0,#+1
   \   000007CC   0xF9B4 0x13AC      LDRSH    R1,[R4, #+940]
   \   000007D0   0xF9B4 0x23CC      LDRSH    R2,[R4, #+972]
   \   000007D4   0x43D2             MVNS     R2,R2
   \   000007D6   0xB289             UXTH     R1,R1
   \   000007D8   0xB292             UXTH     R2,R2
   \   000007DA   0x4291             CMP      R1,R2
   \   000007DC   0xBF18             IT       NE 
   \   000007DE   0x1C40             ADDNE    R0,R0,#+1
   \   000007E0   0xF9B4 0x13B0      LDRSH    R1,[R4, #+944]
   \   000007E4   0xF9B4 0x23D0      LDRSH    R2,[R4, #+976]
   \   000007E8   0x43D2             MVNS     R2,R2
   \   000007EA   0xB289             UXTH     R1,R1
   \   000007EC   0xB292             UXTH     R2,R2
   \   000007EE   0x4291             CMP      R1,R2
   \   000007F0   0xBF18             IT       NE 
   \   000007F2   0x1C40             ADDNE    R0,R0,#+1
   \   000007F4   0xF9B4 0x13AA      LDRSH    R1,[R4, #+938]
   \   000007F8   0xF9B4 0x23CA      LDRSH    R2,[R4, #+970]
   \   000007FC   0x43D2             MVNS     R2,R2
   \   000007FE   0xB289             UXTH     R1,R1
   \   00000800   0xB292             UXTH     R2,R2
   \   00000802   0x4291             CMP      R1,R2
   \   00000804   0xBF18             IT       NE 
   \   00000806   0x1C40             ADDNE    R0,R0,#+1
   \   00000808   0xF9B4 0x13AE      LDRSH    R1,[R4, #+942]
   \   0000080C   0xF9B4 0x23CE      LDRSH    R2,[R4, #+974]
   \   00000810   0x43D2             MVNS     R2,R2
   \   00000812   0xB289             UXTH     R1,R1
   \   00000814   0xB292             UXTH     R2,R2
   \   00000816   0x4291             CMP      R1,R2
   \   00000818   0xBF18             IT       NE 
   \   0000081A   0x1C40             ADDNE    R0,R0,#+1
   \   0000081C   0xF9B4 0x13B2      LDRSH    R1,[R4, #+946]
   \   00000820   0xF9B4 0x23D2      LDRSH    R2,[R4, #+978]
   \   00000824   0x43D2             MVNS     R2,R2
   \   00000826   0xB289             UXTH     R1,R1
   \   00000828   0xB292             UXTH     R2,R2
   \   0000082A   0x4291             CMP      R1,R2
   \   0000082C   0xBF18             IT       NE 
   \   0000082E   0x1C40             ADDNE    R0,R0,#+1
   \   00000830   0xF9B4 0x13BC      LDRSH    R1,[R4, #+956]
   \   00000834   0xF9B4 0x23DC      LDRSH    R2,[R4, #+988]
   \   00000838   0x43D2             MVNS     R2,R2
   \   0000083A   0xB289             UXTH     R1,R1
   \   0000083C   0xB292             UXTH     R2,R2
   \   0000083E   0x4291             CMP      R1,R2
   \   00000840   0xBF18             IT       NE 
   \   00000842   0x1C40             ADDNE    R0,R0,#+1
   \   00000844   0xB120             CBZ.N    R0,??SRMotorSafetyMgr__Handler5ms_24
   \   00000846   0x2200             MOVS     R2,#+0
   \   00000848   0x2100             MOVS     R1,#+0
   \   0000084A   0x2001             MOVS     R0,#+1
   \   0000084C   0x.... 0x....      BL       SRException__Queue
   \                     ??SRMotorSafetyMgr__Handler5ms_24: (+1)
   \   00000850   0xF386 0x8810      MSR      PRIMASK,R6
   \   00000854   0xF504 0x61F7      ADD      R1,R4,#+1976
   \   00000858   0xF204 0x40F4      ADDW     R0,R4,#+1268
   \   0000085C   0x.... 0x....      BL       SRData__CheckLong
   \   00000860   0xF204 0x71BC      ADDW     R1,R4,#+1980
   \   00000864   0xF504 0x609F      ADD      R0,R4,#+1272
   \   00000868   0x.... 0x....      BL       SRData__CheckLong
   \   0000086C   0xF504 0x61F8      ADD      R1,R4,#+1984
   \   00000870   0xF204 0x40FC      ADDW     R0,R4,#+1276
   \   00000874   0x.... 0x....      BL       SRData__CheckLong
   \   00000878   0xF8D4 0x04F4      LDR      R0,[R4, #+1268]
   \   0000087C   0xF9B4 0x13A8      LDRSH    R1,[R4, #+936]
   \   00000880   0xF9B4 0x23AA      LDRSH    R2,[R4, #+938]
   \   00000884   0x1851             ADDS     R1,R2,R1
   \   00000886   0xEBA1 0x4120      SUB      R1,R1,R0, ASR #+16
   \   0000088A   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   0000088E   0xEB00 0x16C2      ADD      R6,R0,R2, LSL #+7
   \   00000892   0x4632             MOV      R2,R6
   \   00000894   0xF504 0x61F7      ADD      R1,R4,#+1976
   \   00000898   0xF204 0x40F4      ADDW     R0,R4,#+1268
   \   0000089C   0x.... 0x....      BL       SRData__UpdateLong
   \   000008A0   0x1432             ASRS     R2,R6,#+16
   \   000008A2   0xB292             UXTH     R2,R2
   \   000008A4   0xF204 0x31CA      ADDW     R1,R4,#+970
   \   000008A8   0xF204 0x30AA      ADDW     R0,R4,#+938
   \   000008AC   0x.... 0x....      BL       SRData__UpdateShort
   \   000008B0   0xF8D4 0x04F8      LDR      R0,[R4, #+1272]
   \   000008B4   0xF9B4 0x13AC      LDRSH    R1,[R4, #+940]
   \   000008B8   0xF9B4 0x23AE      LDRSH    R2,[R4, #+942]
   \   000008BC   0x1851             ADDS     R1,R2,R1
   \   000008BE   0xEBA1 0x4120      SUB      R1,R1,R0, ASR #+16
   \   000008C2   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   000008C6   0xEB00 0x16C2      ADD      R6,R0,R2, LSL #+7
   \   000008CA   0x4632             MOV      R2,R6
   \   000008CC   0xF204 0x71BC      ADDW     R1,R4,#+1980
   \   000008D0   0xF504 0x609F      ADD      R0,R4,#+1272
   \   000008D4   0x.... 0x....      BL       SRData__UpdateLong
   \   000008D8   0x1432             ASRS     R2,R6,#+16
   \   000008DA   0xB292             UXTH     R2,R2
   \   000008DC   0xF204 0x31CE      ADDW     R1,R4,#+974
   \   000008E0   0xF204 0x30AE      ADDW     R0,R4,#+942
   \   000008E4   0x.... 0x....      BL       SRData__UpdateShort
   \   000008E8   0xF8D4 0x04FC      LDR      R0,[R4, #+1276]
   \   000008EC   0xF9B4 0x13B0      LDRSH    R1,[R4, #+944]
   \   000008F0   0xF9B4 0x23B2      LDRSH    R2,[R4, #+946]
   \   000008F4   0x1851             ADDS     R1,R2,R1
   \   000008F6   0xEBA1 0x4120      SUB      R1,R1,R0, ASR #+16
   \   000008FA   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   000008FE   0xEB00 0x16C2      ADD      R6,R0,R2, LSL #+7
   \   00000902   0x4632             MOV      R2,R6
   \   00000904   0xF504 0x61F8      ADD      R1,R4,#+1984
   \   00000908   0xF204 0x40FC      ADDW     R0,R4,#+1276
   \   0000090C   0x.... 0x....      BL       SRData__UpdateLong
   \   00000910   0x1432             ASRS     R2,R6,#+16
   \   00000912   0xB292             UXTH     R2,R2
   \   00000914   0xF204 0x31D2      ADDW     R1,R4,#+978
   \   00000918   0xF204 0x30B2      ADDW     R0,R4,#+946
   \   0000091C   0x.... 0x....      BL       SRData__UpdateShort
    925          
    926                  temp = (sint32)SR_Motor_Flags;
    927                  temp = BIT_TEST(temp, SR_FLAG_REQUESTED_TO_START);
    928                  if(temp)
   \   00000920   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   00000924   0x0740             LSLS     R0,R0,#+29
   \   00000926   0xD525             BPL.N    ??SRMotorSafetyMgr__Handler5ms_25
    929                  {
    930                      // Clear the request to force stop
    931                      temp = SR_Motor_Flags;
   \   00000928   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
    932                      BIT_CLR(temp, SR_FLAG_FORCE_TO_STOP);
    933                      SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,temp);
   \   0000092C   0xF24F 0x71FF      MOVW     R1,#+63487
   \   00000930   0xEA01 0x0200      AND      R2,R1,R0
   \   00000934   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000938   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   0000093C   0x.... 0x....      BL       SRData__UpdateShort
    934          
    935                      // Cancel the request to check the flags
    936                      temp = (uint32)SR_Motor_Flags;
   \   00000940   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
    937                      BIT_CLR(temp, SR_FLAG_UNLOCK_DOOR_SPEED_CHECK_REQUESTED);
    938                      SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,temp);
   \   00000944   0xF64F 0x31FF      MOVW     R1,#+64511
   \   00000948   0xEA01 0x0200      AND      R2,R1,R0
   \   0000094C   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000950   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000954   0x.... 0x....      BL       SRData__UpdateShort
    939          
    940                      SR_DATA_MCU_UPDATE_BYTE(SR_SafetyMngr_State,SAFETY_MNGR_PRERUN_TESTS);
   \   00000958   0x2203             MOVS     R2,#+3
   \   0000095A   0xF204 0x3173      ADDW     R1,R4,#+883
   \   0000095E   0xF204 0x3072      ADDW     R0,R4,#+882
   \   00000962   0x.... 0x....      BL       SRData__UpdateByte
    941          
    942                      SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Fault_Holder,0);
   \   00000966   0x2200             MOVS     R2,#+0
   \   00000968   0xF504 0x61B2      ADD      R1,R4,#+1424
   \   0000096C   0xF504 0x7069      ADD      R0,R4,#+932
   \   00000970   0x.... 0x....      BL       SRData__UpdateShort
    943                  }
    944          
    945          #ifdef SR_BPM_MOTOR
    946          
    947                  SR_MOTOR_SAFETY_MGR__AVG_FREQUENCY_BELOW_THREHOLD();
    948          
    949                  temp = (sint32)SR_Motor_Flags;
   \                     ??SRMotorSafetyMgr__Handler5ms_25: (+1)
   \   00000974   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
    950                  temp = BIT_TEST(temp, SR_FLAG_UNLOCK_DOOR_SPEED_CHECK_REQUESTED);
    951          
    952                  temp1 = (sint32)SR_Motor_Flags;
   \   00000978   0xF8B4 0x13A6      LDRH     R1,[R4, #+934]
    953                  temp1 = BIT_TEST(temp1, SR_FLAG_UNLOCK_DOOR_SPEED);
    954          
    955                  if( (temp)    &&                            // if requested to check hardware integrity AND
    956                      (!temp1) )                              // if unlock door speed was not yet checked...
   \   0000097C   0x0540             LSLS     R0,R0,#+21
   \   0000097E   0xF140 0x838D      BPL.W    ??SRMotorSafetyMgr__Handler5ms_14
   \   00000982   0x07C8             LSLS     R0,R1,#+31
   \   00000984   0xF100 0x838A      BMI.W    ??SRMotorSafetyMgr__Handler5ms_14
    957                  {
    958                      // SR_Check_Unlock_Door_Speed_Timer is used to count the requested amount of idling time
    959                      temp2 = SR_Check_Unlock_Door_Speed_Timer;
   \   00000988   0xF8D4 0x055C      LDR      R0,[R4, #+1372]
    960                      if(temp2)
   \   0000098C   0xB128             CBZ.N    R0,??SRMotorSafetyMgr__Handler5ms_26
    961                      {
    962                          temp2--;
    963                          SR_DATA_MCU_UPDATE_LONG(SR_Check_Unlock_Door_Speed_Timer, temp2);
   \   0000098E   0x1E42             SUBS     R2,R0,#+1
   \   00000990   0xF204 0x5184      ADDW     R1,R4,#+1412
   \   00000994   0xF204 0x505C      ADDW     R0,R4,#+1372
   \   00000998   0xE37E             B.N      ??SRMotorSafetyMgr__Handler5ms_27
    964                      }
    965                      else
    966                      {
    967                          // Cancel the request to check the flags
    968                          temp = (uint32)SR_Motor_Flags;
   \                     ??SRMotorSafetyMgr__Handler5ms_26: (+1)
   \   0000099A   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
    969                          BIT_CLR(temp, SR_FLAG_UNLOCK_DOOR_SPEED_CHECK_REQUESTED);
    970                          SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,temp);
   \   0000099E   0xF64F 0x31FF      MOVW     R1,#+64511
   \   000009A2   0xEA01 0x0200      AND      R2,R1,R0
   \   000009A6   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   000009AA   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   000009AE   0x.... 0x....      BL       SRData__UpdateShort
    971          
    972                          // Load a timeout to detect hardware integrity
    973                          SR_DATA_MCU_UPDATE_LONG(SR_Check_Unlock_Door_Speed_Timer, CHECK_UNLOCK_DOOR_SPEED_TIMEOUT_COUNTER);
   \   000009B2   0xF44F 0x72C8      MOV      R2,#+400
   \   000009B6   0xF204 0x5184      ADDW     R1,R4,#+1412
   \   000009BA   0xF204 0x505C      ADDW     R0,R4,#+1372
   \   000009BE   0x.... 0x....      BL       SRData__UpdateLong
    974          
    975                          // Zero the delta voltage step
    976                          SR_DATA_MCU_UPDATE_LONG(SR_Check_Unlock_Door_Speed_Delta_Voltage, 0);
   \   000009C2   0x2200             MOVS     R2,#+0
   \   000009C4   0xF504 0x61B0      ADD      R1,R4,#+1408
   \   000009C8   0xF504 0x60AC      ADD      R0,R4,#+1376
   \   000009CC   0x.... 0x....      BL       SRData__UpdateLong
    977          
    978                          // Enable lowers on to charge the boot strap capacitors
    979                          // the charging time is 5 ms.
    980                          SRMCPwm__TurnOnLowSideGates();
   \   000009D0   0x2000             MOVS     R0,#+0
   \   000009D2   0x6328             STR      R0,[R5, #+48]
   \   000009D4   0x62A8             STR      R0,[R5, #+40]
   \   000009D6   0x6228             STR      R0,[R5, #+32]
   \   000009D8   0x61A8             STR      R0,[R5, #+24]
   \   000009DA   0x6128             STR      R0,[R5, #+16]
   \   000009DC   0x60A8             STR      R0,[R5, #+8]
    981          
    982                          // Move state machine to perform the final check of the unlock door requirement
    983                          SR_DATA_MCU_UPDATE_BYTE(SR_SafetyMngr_State, SAFETY_MNGR_UNLOCK_DOOR_CHECK);
   \   000009DE   0x2207             MOVS     R2,#+7
   \   000009E0   0xF44F 0x7000      MOV      R0,#+512
   \   000009E4   0xF8C5 0x0090      STR      R0,[R5, #+144]
   \   000009E8   0x6DA8             LDR      R0,[R5, #+88]
   \   000009EA   0x0980             LSRS     R0,R0,#+6
   \   000009EC   0x0180             LSLS     R0,R0,#+6
   \   000009EE   0x65A8             STR      R0,[R5, #+88]
   \   000009F0   0xE346             B.N      ??SRMotorSafetyMgr__Handler5ms_18
    984                      }
    985                  }
    986          #endif
    987              }
    988          
    989          
    990          
    991              ////////////////////////////////////////////////////////////////////////////////////////////////
    992              ////////////////////////////////////////////////////////////////////////////////////////////////
    993              // after idling for some time, the integrity of the hardware shall be checked once,
    994              // once the check is over, the state machine shall get back to IDLE
    995              else if(temp == SAFETY_MNGR_UNLOCK_DOOR_CHECK)
   \                     ??SRMotorSafetyMgr__Handler5ms_23: (+1)
   \   000009F2   0x2807             CMP      R0,#+7
   \   000009F4   0xF040 0x81D0      BNE.W    ??SRMotorSafetyMgr__Handler5ms_28
    996              {
    997          #ifdef SR_BPM_MOTOR
    998          
    999                  // SR_Check_Unlock_Door_Speed_Timer is used as timeout for the algorithm
   1000                  temp2 = SR_Check_Unlock_Door_Speed_Timer;
   \   000009F8   0xF8D4 0x055C      LDR      R0,[R4, #+1372]
   1001                  if(temp2)
   \   000009FC   0x2800             CMP      R0,#+0
   \   000009FE   0xF000 0x80FE      BEQ.W    ??SRMotorSafetyMgr__Handler5ms_29
   1002                  {
   1003                      temp2--;
   1004                      SR_DATA_MCU_UPDATE_LONG(SR_Check_Unlock_Door_Speed_Timer, temp2);
   \   00000A02   0x1E42             SUBS     R2,R0,#+1
   \   00000A04   0xF204 0x5184      ADDW     R1,R4,#+1412
   \   00000A08   0xF204 0x505C      ADDW     R0,R4,#+1372
   \   00000A0C   0x.... 0x....      BL       SRData__UpdateLong
   1005          
   1006                      // Inject some voltage and look for current to check hardware integrity
   1007                      temp1 = SR_Check_Unlock_Door_Speed_Delta_Voltage;
   \   00000A10   0xF8D4 0x6560      LDR      R6,[R4, #+1376]
   1008                      if(temp1 < CHECK_UNLOCK_DOOR_MAX_VOLTAGE_COUNTS)
   \   00000A14   0xF5B6 0x7F7A      CMP      R6,#+1000
   \   00000A18   0xDA07             BGE.N    ??SRMotorSafetyMgr__Handler5ms_30
   1009                      {
   1010                          temp1 += CHECK_UNLOCK_DOOR_MAX_VOLTAGE_DUTY_STEP_COUNTS;
   \   00000A1A   0x3632             ADDS     R6,R6,#+50
   1011                          SR_DATA_MCU_UPDATE_LONG(SR_Check_Unlock_Door_Speed_Delta_Voltage, temp1);
   \   00000A1C   0x4632             MOV      R2,R6
   \   00000A1E   0xF504 0x61B0      ADD      R1,R4,#+1408
   \   00000A22   0xF504 0x60AC      ADD      R0,R4,#+1376
   \   00000A26   0x.... 0x....      BL       SRData__UpdateLong
   1012                      }
   1013          
   1014                      UpdatePwm((16384L + temp1), 16384L, (16384L - temp1));
   \                     ??SRMotorSafetyMgr__Handler5ms_30: (+1)
   \   00000A2A   0xF8DF 0x5524      LDR.W    R5,??SRMotorSafetyMgr__Handler5ms_2  ;; 0x40038008
   \   00000A2E   0x6828             LDR      R0,[R5, #+0]
   \   00000A30   0x1C40             ADDS     R0,R0,#+1
   \   00000A32   0xF5C6 0x4180      RSB      R1,R6,#+16384
   \   00000A36   0x4341             MULS     R1,R1,R0
   \   00000A38   0x03C2             LSLS     R2,R0,#+15
   \   00000A3A   0xF506 0x4380      ADD      R3,R6,#+16384
   \   00000A3E   0x4358             MULS     R0,R0,R3
   \   00000A40   0x0040             LSLS     R0,R0,#+1
   \   00000A42   0x1400             ASRS     R0,R0,#+16
   \   00000A44   0x6328             STR      R0,[R5, #+48]
   \   00000A46   0x1412             ASRS     R2,R2,#+16
   \   00000A48   0x4240             RSBS     R0,R0,#+0
   \   00000A4A   0x62A8             STR      R0,[R5, #+40]
   \   00000A4C   0x0049             LSLS     R1,R1,#+1
   \   00000A4E   0x4250             RSBS     R0,R2,#+0
   \   00000A50   0x61A8             STR      R0,[R5, #+24]
   \   00000A52   0x1409             ASRS     R1,R1,#+16
   \   00000A54   0x4248             RSBS     R0,R1,#+0
   \   00000A56   0x60A8             STR      R0,[R5, #+8]
   \   00000A58   0x622A             STR      R2,[R5, #+32]
   \   00000A5A   0xF44F 0x7000      MOV      R0,#+512
   \   00000A5E   0xF8C5 0x0090      STR      R0,[R5, #+144]
   \   00000A62   0x6129             STR      R1,[R5, #+16]
   1015          
   1016                      // Load currents to the stack
   1017                      temp_current_a = SR_CurrentA;
   \   00000A64   0xF9B4 0x03A8      LDRSH    R0,[R4, #+936]
   1018                      temp_current_b = SR_CurrentB;
   \   00000A68   0xF9B4 0x13AC      LDRSH    R1,[R4, #+940]
   1019                      temp_current_c = SR_CurrentC;
   \   00000A6C   0xF9B4 0x23B0      LDRSH    R2,[R4, #+944]
   1020          
   1021                      // One current will be positive, other negative and the third one shall be zero;
   1022                      // the zero one has a larger zone since it shall prevent hardware noise
   1023                      if( (temp_current_a <    -CHECK_UNLOCK_DOOR_CURRENT_THRESHOLDS_COUNTS)  &&
   1024                          (temp_current_b > -(2*CHECK_UNLOCK_DOOR_CURRENT_THRESHOLDS_COUNTS)) &&
   1025                          (temp_current_b <  (2*CHECK_UNLOCK_DOOR_CURRENT_THRESHOLDS_COUNTS)) &&
   1026                          (temp_current_c >     CHECK_UNLOCK_DOOR_CURRENT_THRESHOLDS_COUNTS)  )
   \   00000A70   0xF110 0x0F19      CMN      R0,#+25
   \   00000A74   0xF280 0x8312      BGE.W    ??SRMotorSafetyMgr__Handler5ms_14
   \   00000A78   0xF101 0x0031      ADD      R0,R1,#+49
   \   00000A7C   0x2863             CMP      R0,#+99
   \   00000A7E   0xF080 0x830D      BCS.W    ??SRMotorSafetyMgr__Handler5ms_14
   \   00000A82   0x2A1A             CMP      R2,#+26
   \   00000A84   0xF2C0 0x830A      BLT.W    ??SRMotorSafetyMgr__Handler5ms_14
   1027                      {
   1028                          SRMCPwm__TurnOffAllGates();
   \   00000A88   0x6DA8             LDR      R0,[R5, #+88]
   \   00000A8A   0xF040 0x003F      ORR      R0,R0,#0x3F
   \   00000A8E   0x65A8             STR      R0,[R5, #+88]
   \   00000A90   0x6EE8             LDR      R0,[R5, #+108]
   \   00000A92   0x0601             LSLS     R1,R0,#+24
   \   00000A94   0x0FC9             LSRS     R1,R1,#+31
   \   00000A96   0xBF1C             ITT      NE 
   \   00000A98   0xF020 0x008F      BICNE    R0,R0,#0x8F
   \   00000A9C   0x66E8             STRNE    R0,[R5, #+108]
   1029          
   1030                          // Reset the unlock door speed flag
   1031                          temp = SR_Motor_Flags;
   \   00000A9E   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   1032                          BIT_SET(temp, SR_FLAG_UNLOCK_DOOR_SPEED);
   1033                          SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,temp);
   \   00000AA2   0xF040 0x0201      ORR      R2,R0,#0x1
   \   00000AA6   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000AAA   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000AAE   0x.... 0x....      BL       SRData__UpdateShort
   1034          
   1035                          Init_Avg_Frequency();
   \   00000AB2   0xF504 0x715E      ADD      R1,R4,#+888
   \   00000AB6   0xF204 0x3075      ADDW     R0,R4,#+885
   \   00000ABA   0x.... 0x....      BL       SRData__CheckByte
   \   00000ABE   0xF204 0x5164      ADDW     R1,R4,#+1380
   \   00000AC2   0xF204 0x503C      ADDW     R0,R4,#+1340
   \   00000AC6   0x.... 0x....      BL       SRData__CheckLong
   \   00000ACA   0xF504 0x61AD      ADD      R1,R4,#+1384
   \   00000ACE   0xF504 0x60A8      ADD      R0,R4,#+1344
   \   00000AD2   0x.... 0x....      BL       SRData__CheckLong
   \   00000AD6   0xF204 0x516C      ADDW     R1,R4,#+1388
   \   00000ADA   0xF204 0x5044      ADDW     R0,R4,#+1348
   \   00000ADE   0x.... 0x....      BL       SRData__CheckLong
   \   00000AE2   0xF504 0x61AE      ADD      R1,R4,#+1392
   \   00000AE6   0xF504 0x60A9      ADD      R0,R4,#+1352
   \   00000AEA   0x.... 0x....      BL       SRData__CheckLong
   \   00000AEE   0xF204 0x5174      ADDW     R1,R4,#+1396
   \   00000AF2   0xF204 0x504C      ADDW     R0,R4,#+1356
   \   00000AF6   0x.... 0x....      BL       SRData__CheckLong
   \   00000AFA   0xF204 0x517C      ADDW     R1,R4,#+1404
   \   00000AFE   0xF504 0x60AB      ADD      R0,R4,#+1368
   \   00000B02   0x.... 0x....      BL       SRData__CheckLong
   \   00000B06   0xF504 0x61AF      ADD      R1,R4,#+1400
   \   00000B0A   0xF504 0x60AA      ADD      R0,R4,#+1360
   \   00000B0E   0x.... 0x....      BL       SRData__CheckLong
   \   00000B12   0xF204 0x518C      ADDW     R1,R4,#+1420
   \   00000B16   0xF204 0x3076      ADDW     R0,R4,#+886
   \   00000B1A   0x.... 0x....      BL       SRData__CheckByte
   \   00000B1E   0x6828             LDR      R0,[R5, #+0]
   \   00000B20   0x1C40             ADDS     R0,R0,#+1
   \   00000B22   0xEE00 0x0A10      VMOV     S0,R0
   \   00000B26   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000B2A   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000B2E   0xEE10 0x0A10      VMOV     R0,S0
   \   00000B32   0x1040             ASRS     R0,R0,#+1
   \   00000B34   0xEE00 0x0A10      VMOV     S0,R0
   \   00000B38   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000B3C   0xEDDF 0x0A93      VLDR.W   S1,??SRMotorSafetyMgr__Handler5ms_0  ;; 0x3f866666
   \   00000B40   0xEE60 0x0A20      VMUL.F32 S1,S0,S1
   \   00000B44   0xF204 0x503C      ADDW     R0,R4,#+1340
   \   00000B48   0xEEFD 0x0AE0      VCVT.S32.F32 S1,S1
   \   00000B4C   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
   \   00000B50   0xED9F 0x1A8F      VLDR.W   S2,??SRMotorSafetyMgr__Handler5ms_0+0x4  ;; 0x3f733333
   \   00000B54   0xEE20 0x0A01      VMUL.F32 S0,S0,S2
   \   00000B58   0xF204 0x5040      ADDW     R0,R4,#+1344
   \   00000B5C   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000B60   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   00000B64   0xEE10 0x2A90      VMOV     R2,S1
   \   00000B68   0xF204 0x5164      ADDW     R1,R4,#+1380
   \   00000B6C   0xF204 0x503C      ADDW     R0,R4,#+1340
   \   00000B70   0x.... 0x....      BL       SRData__UpdateLong
   \   00000B74   0xF8D4 0x2540      LDR      R2,[R4, #+1344]
   \   00000B78   0xF504 0x61AD      ADD      R1,R4,#+1384
   \   00000B7C   0xF504 0x60A8      ADD      R0,R4,#+1344
   \   00000B80   0x.... 0x....      BL       SRData__UpdateLong
   \   00000B84   0xF8D4 0x2540      LDR      R2,[R4, #+1344]
   \   00000B88   0xF204 0x516C      ADDW     R1,R4,#+1388
   \   00000B8C   0xF204 0x5044      ADDW     R0,R4,#+1348
   \   00000B90   0x.... 0x....      BL       SRData__UpdateLong
   \   00000B94   0x2200             MOVS     R2,#+0
   \   00000B96   0xF504 0x715E      ADD      R1,R4,#+888
   \   00000B9A   0xF204 0x3075      ADDW     R0,R4,#+885
   \   00000B9E   0x.... 0x....      BL       SRData__UpdateByte
   \   00000BA2   0x2200             MOVS     R2,#+0
   \   00000BA4   0xF504 0x61AE      ADD      R1,R4,#+1392
   \   00000BA8   0xF504 0x60A9      ADD      R0,R4,#+1352
   \   00000BAC   0x.... 0x....      BL       SRData__UpdateLong
   \   00000BB0   0xF04F 0x4280      MOV      R2,#+1073741824
   \   00000BB4   0xF204 0x5174      ADDW     R1,R4,#+1396
   \   00000BB8   0xF204 0x504C      ADDW     R0,R4,#+1356
   \   00000BBC   0x.... 0x....      BL       SRData__UpdateLong
   \   00000BC0   0xF04F 0x4280      MOV      R2,#+1073741824
   \   00000BC4   0xF204 0x517C      ADDW     R1,R4,#+1404
   \   00000BC8   0xF504 0x60AB      ADD      R0,R4,#+1368
   \   00000BCC   0x.... 0x....      BL       SRData__UpdateLong
   \   00000BD0   0x2200             MOVS     R2,#+0
   \   00000BD2   0xF504 0x61AF      ADD      R1,R4,#+1400
   \   00000BD6   0xF504 0x60AA      ADD      R0,R4,#+1360
   \   00000BDA   0x.... 0x....      BL       SRData__UpdateLong
   \   00000BDE   0x2200             MOVS     R2,#+0
   \   00000BE0   0xF504 0x6100      ADD      R1,R4,#+2048
   \   00000BE4   0xF204 0x5054      ADDW     R0,R4,#+1364
   \   00000BE8   0x.... 0x....      BL       SRData__UpdateLong
   \   00000BEC   0x2200             MOVS     R2,#+0
   \   00000BEE   0xF204 0x518C      ADDW     R1,R4,#+1420
   \   00000BF2   0xF204 0x3076      ADDW     R0,R4,#+886
   \   00000BF6   0x.... 0x....      BL       SRData__UpdateByte
   1036          
   1037                          SR_DATA_MCU_UPDATE_BYTE(SR_SafetyMngr_State,SAFETY_MNGR_IDLE);
   \   00000BFA   0x2202             MOVS     R2,#+2
   \   00000BFC   0xE240             B.N      ??SRMotorSafetyMgr__Handler5ms_18
   1038                      }
   1039                  }
   1040                  else // unlock door speed check time is over!
   1041                  {
   1042                      SRMCPwm__TurnOffAllGates();
   \                     ??SRMotorSafetyMgr__Handler5ms_29: (+1)
   \   00000BFE   0x4DD4             LDR.N    R5,??SRMotorSafetyMgr__Handler5ms_2  ;; 0x40038008
   \   00000C00   0x6DA8             LDR      R0,[R5, #+88]
   \   00000C02   0xF040 0x003F      ORR      R0,R0,#0x3F
   \   00000C06   0x65A8             STR      R0,[R5, #+88]
   \   00000C08   0x6EE8             LDR      R0,[R5, #+108]
   \   00000C0A   0x0601             LSLS     R1,R0,#+24
   \   00000C0C   0x0FC9             LSRS     R1,R1,#+31
   \   00000C0E   0xBF1C             ITT      NE 
   \   00000C10   0xF020 0x008F      BICNE    R0,R0,#0x8F
   \   00000C14   0x66E8             STRNE    R0,[R5, #+108]
   1043          
   1044                      // Unable to detect current on time, so, it has failed
   1045                      SetFault(SR_FAULT_UNLOCK_DOOR_SPEED_FAILED);
   \   00000C16   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   00000C1A   0xF040 0x0208      ORR      R2,R0,#0x8
   \   00000C1E   0xF504 0x7171      ADD      R1,R4,#+964
   \   00000C22   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   00000C26   0x.... 0x....      BL       SRData__UpdateShort
   \   00000C2A   0xF8B4 0x03A4      LDRH     R0,[R4, #+932]
   \   00000C2E   0xF040 0x0208      ORR      R2,R0,#0x8
   \   00000C32   0xF504 0x61B2      ADD      R1,R4,#+1424
   \   00000C36   0xF504 0x7069      ADD      R0,R4,#+932
   \   00000C3A   0x.... 0x....      BL       SRData__UpdateShort
   1046          
   1047                      Init_Avg_Frequency();
   \   00000C3E   0xF504 0x715E      ADD      R1,R4,#+888
   \   00000C42   0xF204 0x3075      ADDW     R0,R4,#+885
   \   00000C46   0x.... 0x....      BL       SRData__CheckByte
   \   00000C4A   0xF204 0x5164      ADDW     R1,R4,#+1380
   \   00000C4E   0xF204 0x503C      ADDW     R0,R4,#+1340
   \   00000C52   0x.... 0x....      BL       SRData__CheckLong
   \   00000C56   0xF504 0x61AD      ADD      R1,R4,#+1384
   \   00000C5A   0xF504 0x60A8      ADD      R0,R4,#+1344
   \   00000C5E   0x.... 0x....      BL       SRData__CheckLong
   \   00000C62   0xF204 0x516C      ADDW     R1,R4,#+1388
   \   00000C66   0xF204 0x5044      ADDW     R0,R4,#+1348
   \   00000C6A   0x.... 0x....      BL       SRData__CheckLong
   \   00000C6E   0xF504 0x61AE      ADD      R1,R4,#+1392
   \   00000C72   0xF504 0x60A9      ADD      R0,R4,#+1352
   \   00000C76   0x.... 0x....      BL       SRData__CheckLong
   \   00000C7A   0xF204 0x5174      ADDW     R1,R4,#+1396
   \   00000C7E   0xF204 0x504C      ADDW     R0,R4,#+1356
   \   00000C82   0x.... 0x....      BL       SRData__CheckLong
   \   00000C86   0xF204 0x517C      ADDW     R1,R4,#+1404
   \   00000C8A   0xF504 0x60AB      ADD      R0,R4,#+1368
   \   00000C8E   0x.... 0x....      BL       SRData__CheckLong
   \   00000C92   0xF504 0x61AF      ADD      R1,R4,#+1400
   \   00000C96   0xF504 0x60AA      ADD      R0,R4,#+1360
   \   00000C9A   0x.... 0x....      BL       SRData__CheckLong
   \   00000C9E   0xF204 0x518C      ADDW     R1,R4,#+1420
   \   00000CA2   0xF204 0x3076      ADDW     R0,R4,#+886
   \   00000CA6   0x.... 0x....      BL       SRData__CheckByte
   \   00000CAA   0x6828             LDR      R0,[R5, #+0]
   \   00000CAC   0x1C40             ADDS     R0,R0,#+1
   \   00000CAE   0xEE00 0x0A10      VMOV     S0,R0
   \   00000CB2   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000CB6   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000CBA   0xEE10 0x0A10      VMOV     R0,S0
   \   00000CBE   0x1040             ASRS     R0,R0,#+1
   \   00000CC0   0xEE00 0x0A10      VMOV     S0,R0
   \   00000CC4   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000CC8   0xEDDF 0x0A30      VLDR.W   S1,??SRMotorSafetyMgr__Handler5ms_0  ;; 0x3f866666
   \   00000CCC   0xEE60 0x0A20      VMUL.F32 S1,S0,S1
   \   00000CD0   0xF204 0x503C      ADDW     R0,R4,#+1340
   \   00000CD4   0xEEFD 0x0AE0      VCVT.S32.F32 S1,S1
   \   00000CD8   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
   \   00000CDC   0xED9F 0x1A2C      VLDR.W   S2,??SRMotorSafetyMgr__Handler5ms_0+0x4  ;; 0x3f733333
   \   00000CE0   0xEE20 0x0A01      VMUL.F32 S0,S0,S2
   \   00000CE4   0xF204 0x5040      ADDW     R0,R4,#+1344
   \   00000CE8   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000CEC   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   00000CF0   0xEE10 0x2A90      VMOV     R2,S1
   \   00000CF4   0xF204 0x5164      ADDW     R1,R4,#+1380
   \   00000CF8   0xF204 0x503C      ADDW     R0,R4,#+1340
   \   00000CFC   0x.... 0x....      BL       SRData__UpdateLong
   \   00000D00   0xF8D4 0x2540      LDR      R2,[R4, #+1344]
   \   00000D04   0xF504 0x61AD      ADD      R1,R4,#+1384
   \   00000D08   0xF504 0x60A8      ADD      R0,R4,#+1344
   \   00000D0C   0x.... 0x....      BL       SRData__UpdateLong
   \   00000D10   0xF8D4 0x2540      LDR      R2,[R4, #+1344]
   \   00000D14   0xF204 0x516C      ADDW     R1,R4,#+1388
   \   00000D18   0xF204 0x5044      ADDW     R0,R4,#+1348
   \   00000D1C   0x.... 0x....      BL       SRData__UpdateLong
   \   00000D20   0x2200             MOVS     R2,#+0
   \   00000D22   0xF504 0x715E      ADD      R1,R4,#+888
   \   00000D26   0xF204 0x3075      ADDW     R0,R4,#+885
   \   00000D2A   0x.... 0x....      BL       SRData__UpdateByte
   \   00000D2E   0x2200             MOVS     R2,#+0
   \   00000D30   0xF504 0x61AE      ADD      R1,R4,#+1392
   \   00000D34   0xF504 0x60A9      ADD      R0,R4,#+1352
   \   00000D38   0x.... 0x....      BL       SRData__UpdateLong
   \   00000D3C   0xF04F 0x4280      MOV      R2,#+1073741824
   \   00000D40   0xF204 0x5174      ADDW     R1,R4,#+1396
   \   00000D44   0xF204 0x504C      ADDW     R0,R4,#+1356
   \   00000D48   0x.... 0x....      BL       SRData__UpdateLong
   \   00000D4C   0xF04F 0x4280      MOV      R2,#+1073741824
   \   00000D50   0xF204 0x517C      ADDW     R1,R4,#+1404
   \   00000D54   0xF504 0x60AB      ADD      R0,R4,#+1368
   \   00000D58   0x.... 0x....      BL       SRData__UpdateLong
   \   00000D5C   0x2200             MOVS     R2,#+0
   \   00000D5E   0xF504 0x61AF      ADD      R1,R4,#+1400
   \   00000D62   0xF504 0x60AA      ADD      R0,R4,#+1360
   \   00000D66   0x.... 0x....      BL       SRData__UpdateLong
   \   00000D6A   0x2200             MOVS     R2,#+0
   \   00000D6C   0xF504 0x6100      ADD      R1,R4,#+2048
   \   00000D70   0xF204 0x5054      ADDW     R0,R4,#+1364
   \   00000D74   0x.... 0x....      BL       SRData__UpdateLong
   \   00000D78   0x2200             MOVS     R2,#+0
   \   00000D7A   0xF204 0x518C      ADDW     R1,R4,#+1420
   \   00000D7E   0xF204 0x3076      ADDW     R0,R4,#+886
   \   00000D82   0x.... 0x....      BL       SRData__UpdateByte
   1048          
   1049                      SR_DATA_MCU_UPDATE_LONG(SR_Timeout_Failure_Retry, TACHO_TIMEOUT); //Load time out
   \   00000D86   0x2278             MOVS     R2,#+120
   \   00000D88   0xE182             B.N      ??SRMotorSafetyMgr__Handler5ms_13
   \   00000D8A   0xBF00             Nop      
   \                     ??SRMotorSafetyMgr__Handler5ms_0:
   \   00000D8C   0x3F866666         DC32     0x3f866666
   \   00000D90   0x3F733333         DC32     0x3f733333
   \   00000D94   0x........         DC32     Mcl_Quantities
   1050                  }
   1051          
   1052          #endif
   1053          
   1054          #ifdef SR_CIM_MOTOR
   1055          
   1056                  // State required only for BPM, if the sw falls here, the
   1057                  // state variable is corrupted.
   1058                  SRDATA_CORRUPTION_EXCEPTION(10);
   1059          
   1060          #endif
   1061              }
   1062          
   1063          
   1064          
   1065          
   1066              ////////////////////////////////////////////////////////////////////////////////////////////////
   1067              ////////////////////////////////////////////////////////////////////////////////////////////////
   1068              /// Initialize the variables for this state machine and waiting until the power up is performed
   1069              else if(temp == SAFETY_MNGR_INITIALIZE)
   \                     ??SRMotorSafetyMgr__Handler5ms_28: (+1)
   \   00000D98   0x2801             CMP      R0,#+1
   \   00000D9A   0xF040 0x8103      BNE.W    ??SRMotorSafetyMgr__Handler5ms_31
   1070              {
   1071          
   1072                  AverageSensorsOffset();                 // Average the offsets and update the analog data
   \   00000D9E   0x2000             MOVS     R0,#+0
   \   00000DA0   0xF3EF 0x8510      MRS      R5,PRIMASK
   \   00000DA4   0xB672             CPSID    I
   \   00000DA6   0xF9B4 0x13A8      LDRSH    R1,[R4, #+936]
   \   00000DAA   0xF9B4 0x23C8      LDRSH    R2,[R4, #+968]
   \   00000DAE   0x43D2             MVNS     R2,R2
   \   00000DB0   0xB289             UXTH     R1,R1
   \   00000DB2   0xB292             UXTH     R2,R2
   \   00000DB4   0x4291             CMP      R1,R2
   \   00000DB6   0xBF18             IT       NE 
   \   00000DB8   0x2001             MOVNE    R0,#+1
   \   00000DBA   0xF9B4 0x13AC      LDRSH    R1,[R4, #+940]
   \   00000DBE   0xF9B4 0x23CC      LDRSH    R2,[R4, #+972]
   \   00000DC2   0x43D2             MVNS     R2,R2
   \   00000DC4   0xB289             UXTH     R1,R1
   \   00000DC6   0xB292             UXTH     R2,R2
   \   00000DC8   0x4291             CMP      R1,R2
   \   00000DCA   0xBF18             IT       NE 
   \   00000DCC   0x1C40             ADDNE    R0,R0,#+1
   \   00000DCE   0xF9B4 0x13B0      LDRSH    R1,[R4, #+944]
   \   00000DD2   0xF9B4 0x23D0      LDRSH    R2,[R4, #+976]
   \   00000DD6   0x43D2             MVNS     R2,R2
   \   00000DD8   0xB289             UXTH     R1,R1
   \   00000DDA   0xB292             UXTH     R2,R2
   \   00000DDC   0x4291             CMP      R1,R2
   \   00000DDE   0xBF18             IT       NE 
   \   00000DE0   0x1C40             ADDNE    R0,R0,#+1
   \   00000DE2   0xF9B4 0x13AA      LDRSH    R1,[R4, #+938]
   \   00000DE6   0xF9B4 0x23CA      LDRSH    R2,[R4, #+970]
   \   00000DEA   0x43D2             MVNS     R2,R2
   \   00000DEC   0xB289             UXTH     R1,R1
   \   00000DEE   0xB292             UXTH     R2,R2
   \   00000DF0   0x4291             CMP      R1,R2
   \   00000DF2   0xBF18             IT       NE 
   \   00000DF4   0x1C40             ADDNE    R0,R0,#+1
   \   00000DF6   0xF9B4 0x13AE      LDRSH    R1,[R4, #+942]
   \   00000DFA   0xF9B4 0x23CE      LDRSH    R2,[R4, #+974]
   \   00000DFE   0x43D2             MVNS     R2,R2
   \   00000E00   0xB289             UXTH     R1,R1
   \   00000E02   0xB292             UXTH     R2,R2
   \   00000E04   0x4291             CMP      R1,R2
   \   00000E06   0xBF18             IT       NE 
   \   00000E08   0x1C40             ADDNE    R0,R0,#+1
   \   00000E0A   0xF9B4 0x13B2      LDRSH    R1,[R4, #+946]
   \   00000E0E   0xF9B4 0x23D2      LDRSH    R2,[R4, #+978]
   \   00000E12   0x43D2             MVNS     R2,R2
   \   00000E14   0xB289             UXTH     R1,R1
   \   00000E16   0xB292             UXTH     R2,R2
   \   00000E18   0x4291             CMP      R1,R2
   \   00000E1A   0xBF18             IT       NE 
   \   00000E1C   0x1C40             ADDNE    R0,R0,#+1
   \   00000E1E   0xF9B4 0x13BC      LDRSH    R1,[R4, #+956]
   \   00000E22   0xF9B4 0x23DC      LDRSH    R2,[R4, #+988]
   \   00000E26   0x43D2             MVNS     R2,R2
   \   00000E28   0xB289             UXTH     R1,R1
   \   00000E2A   0xB292             UXTH     R2,R2
   \   00000E2C   0x4291             CMP      R1,R2
   \   00000E2E   0xBF18             IT       NE 
   \   00000E30   0x1C40             ADDNE    R0,R0,#+1
   \   00000E32   0xB120             CBZ.N    R0,??SRMotorSafetyMgr__Handler5ms_32
   \   00000E34   0x2200             MOVS     R2,#+0
   \   00000E36   0x2100             MOVS     R1,#+0
   \   00000E38   0x2001             MOVS     R0,#+1
   \   00000E3A   0x.... 0x....      BL       SRException__Queue
   \                     ??SRMotorSafetyMgr__Handler5ms_32: (+1)
   \   00000E3E   0xF385 0x8810      MSR      PRIMASK,R5
   \   00000E42   0xF504 0x61F7      ADD      R1,R4,#+1976
   \   00000E46   0xF204 0x40F4      ADDW     R0,R4,#+1268
   \   00000E4A   0x.... 0x....      BL       SRData__CheckLong
   \   00000E4E   0xF204 0x71BC      ADDW     R1,R4,#+1980
   \   00000E52   0xF504 0x609F      ADD      R0,R4,#+1272
   \   00000E56   0x.... 0x....      BL       SRData__CheckLong
   \   00000E5A   0xF504 0x61F8      ADD      R1,R4,#+1984
   \   00000E5E   0xF204 0x40FC      ADDW     R0,R4,#+1276
   \   00000E62   0x.... 0x....      BL       SRData__CheckLong
   \   00000E66   0xF8D4 0x04F4      LDR      R0,[R4, #+1268]
   \   00000E6A   0xF9B4 0x13A8      LDRSH    R1,[R4, #+936]
   \   00000E6E   0xF9B4 0x23AA      LDRSH    R2,[R4, #+938]
   \   00000E72   0x1851             ADDS     R1,R2,R1
   \   00000E74   0xEBA1 0x4120      SUB      R1,R1,R0, ASR #+16
   \   00000E78   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   00000E7C   0xEB00 0x15C2      ADD      R5,R0,R2, LSL #+7
   \   00000E80   0x462A             MOV      R2,R5
   \   00000E82   0xF504 0x61F7      ADD      R1,R4,#+1976
   \   00000E86   0xF204 0x40F4      ADDW     R0,R4,#+1268
   \   00000E8A   0x.... 0x....      BL       SRData__UpdateLong
   \   00000E8E   0x142A             ASRS     R2,R5,#+16
   \   00000E90   0xB292             UXTH     R2,R2
   \   00000E92   0xF204 0x31CA      ADDW     R1,R4,#+970
   \   00000E96   0xF204 0x30AA      ADDW     R0,R4,#+938
   \   00000E9A   0x.... 0x....      BL       SRData__UpdateShort
   \   00000E9E   0xF8D4 0x04F8      LDR      R0,[R4, #+1272]
   \   00000EA2   0xF9B4 0x13AC      LDRSH    R1,[R4, #+940]
   \   00000EA6   0xF9B4 0x23AE      LDRSH    R2,[R4, #+942]
   \   00000EAA   0x1851             ADDS     R1,R2,R1
   \   00000EAC   0xEBA1 0x4120      SUB      R1,R1,R0, ASR #+16
   \   00000EB0   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   00000EB4   0xEB00 0x15C2      ADD      R5,R0,R2, LSL #+7
   \   00000EB8   0x462A             MOV      R2,R5
   \   00000EBA   0xF204 0x71BC      ADDW     R1,R4,#+1980
   \   00000EBE   0xF504 0x609F      ADD      R0,R4,#+1272
   \   00000EC2   0x.... 0x....      BL       SRData__UpdateLong
   \   00000EC6   0x142A             ASRS     R2,R5,#+16
   \   00000EC8   0xB292             UXTH     R2,R2
   \   00000ECA   0xF204 0x31CE      ADDW     R1,R4,#+974
   \   00000ECE   0xF204 0x30AE      ADDW     R0,R4,#+942
   \   00000ED2   0x.... 0x....      BL       SRData__UpdateShort
   \   00000ED6   0xF8D4 0x04FC      LDR      R0,[R4, #+1276]
   \   00000EDA   0xF9B4 0x13B0      LDRSH    R1,[R4, #+944]
   \   00000EDE   0xF9B4 0x23B2      LDRSH    R2,[R4, #+946]
   \   00000EE2   0x1851             ADDS     R1,R2,R1
   \   00000EE4   0xEBA1 0x4120      SUB      R1,R1,R0, ASR #+16
   \   00000EE8   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   00000EEC   0xEB00 0x15C2      ADD      R5,R0,R2, LSL #+7
   \   00000EF0   0x462A             MOV      R2,R5
   \   00000EF2   0xF504 0x61F8      ADD      R1,R4,#+1984
   \   00000EF6   0xF204 0x40FC      ADDW     R0,R4,#+1276
   \   00000EFA   0x.... 0x....      BL       SRData__UpdateLong
   \   00000EFE   0x142A             ASRS     R2,R5,#+16
   \   00000F00   0xB292             UXTH     R2,R2
   \   00000F02   0xF204 0x31D2      ADDW     R1,R4,#+978
   \   00000F06   0xF204 0x30B2      ADDW     R0,R4,#+946
   \   00000F0A   0x.... 0x....      BL       SRData__UpdateShort
   1073          
   1074                  SR_MOTORSAFETY_MGR_ERROR_REACTION();
   \   00000F0E   0x4D10             LDR.N    R5,??SRMotorSafetyMgr__Handler5ms_2  ;; 0x40038008
   \   00000F10   0x2000             MOVS     R0,#+0
   \   00000F12   0x6328             STR      R0,[R5, #+48]
   \   00000F14   0x62A8             STR      R0,[R5, #+40]
   \   00000F16   0x6228             STR      R0,[R5, #+32]
   \   00000F18   0x61A8             STR      R0,[R5, #+24]
   \   00000F1A   0x6128             STR      R0,[R5, #+16]
   \   00000F1C   0x60A8             STR      R0,[R5, #+8]
   1075          
   1076                  PowerUpSensors();                       // Check and set a flag accordingly if the power up condition is already finished
   \   00000F1E   0xF204 0x5192      ADDW     R1,R4,#+1426
   \   00000F22   0xF44F 0x7000      MOV      R0,#+512
   \   00000F26   0xF8C5 0x0090      STR      R0,[R5, #+144]
   \   00000F2A   0x6DA8             LDR      R0,[R5, #+88]
   \   00000F2C   0x0980             LSRS     R0,R0,#+6
   \   00000F2E   0x0180             LSLS     R0,R0,#+6
   \   00000F30   0x65A8             STR      R0,[R5, #+88]
   \   00000F32   0xF204 0x30BE      ADDW     R0,R4,#+958
   \   00000F36   0x.... 0x....      BL       SRData__CheckShort
   \   00000F3A   0xF9B4 0x03BE      LDRSH    R0,[R4, #+958]
   \   00000F3E   0x28C8             CMP      R0,#+200
   \   00000F40   0xDA08             BGE.N    ??SRMotorSafetyMgr__Handler5ms_33
   \   00000F42   0x1C42             ADDS     R2,R0,#+1
   \   00000F44   0xB292             UXTH     R2,R2
   \   00000F46   0xF204 0x5192      ADDW     R1,R4,#+1426
   \   00000F4A   0xF204 0x30BE      ADDW     R0,R4,#+958
   \   00000F4E   0xE022             B.N      ??SRMotorSafetyMgr__Handler5ms_34
   \                     ??SRMotorSafetyMgr__Handler5ms_2:
   \   00000F50   0x40038008         DC32     0x40038008
   \                     ??SRMotorSafetyMgr__Handler5ms_33: (+1)
   \   00000F54   0xF8D4 0x0508      LDR      R0,[R4, #+1288]
   \   00000F58   0xF8D4 0x150C      LDR      R1,[R4, #+1292]
   \   00000F5C   0x280A             CMP      R0,#+10
   \   00000F5E   0xD21C             BCS.N    ??SRMotorSafetyMgr__Handler5ms_35
   \   00000F60   0x1C4D             ADDS     R5,R1,#+1
   \   00000F62   0x462A             MOV      R2,R5
   \   00000F64   0xF504 0x61FA      ADD      R1,R4,#+2000
   \   00000F68   0xF204 0x500C      ADDW     R0,R4,#+1292
   \   00000F6C   0x.... 0x....      BL       SRData__UpdateLong
   \   00000F70   0x2D06             CMP      R5,#+6
   \   00000F72   0xD312             BCC.N    ??SRMotorSafetyMgr__Handler5ms_35
   \   00000F74   0x2200             MOVS     R2,#+0
   \   00000F76   0xF504 0x61FA      ADD      R1,R4,#+2000
   \   00000F7A   0xF204 0x500C      ADDW     R0,R4,#+1292
   \   00000F7E   0x.... 0x....      BL       SRData__UpdateLong
   \   00000F82   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   00000F86   0xF64F 0x71DF      MOVW     R1,#+65503
   \   00000F8A   0xEA01 0x0200      AND      R2,R1,R0
   \   00000F8E   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000F92   0xF204 0x30A6      ADDW     R0,R4,#+934
   \                     ??SRMotorSafetyMgr__Handler5ms_34: (+1)
   \   00000F96   0x.... 0x....      BL       SRData__UpdateShort
   1077          
   1078                  // Check if the powering up stage has been completed
   1079                  temp = (sint32)SR_Motor_Flags;
   1080                  temp1 = BIT_TEST(temp, SR_FLAG_MICRO_POWERING_UP);
   1081          
   1082                  if(!temp1)
   \                     ??SRMotorSafetyMgr__Handler5ms_35: (+1)
   \   00000F9A   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   00000F9E   0x0680             LSLS     R0,R0,#+26
   \   00000FA0   0xD47C             BMI.N    ??SRMotorSafetyMgr__Handler5ms_14
   1083                  {
   1084                      SR_DATA_MCU_UPDATE_BYTE(SR_SafetyMngr_State,SAFETY_MNGR_POSTRUN_TESTS);
   \   00000FA2   0xE06C             B.N      ??SRMotorSafetyMgr__Handler5ms_15
   1085                  }
   1086              }
   1087          
   1088          
   1089              ////////////////////////////////////////////////////////////////////////////////////////////////
   1090              ////////////////////////////////////////////////////////////////////////////////////////////////
   1091              // If an error is found, the state machine shall stay in this ERROR state
   1092              else if(temp == SAFETY_MNGR_ERROR_FOUND)
   \                     ??SRMotorSafetyMgr__Handler5ms_31: (+1)
   \   00000FA4   0x2806             CMP      R0,#+6
   \   00000FA6   0xD179             BNE.N    ??SRMotorSafetyMgr__Handler5ms_14
   1093              {
   1094          
   1095                  temp2 = (uint32)SR_Motor_Fault;
   1096                  temp2  = BIT_TEST(temp2, SR_FAULT_OVER_CURRENT_TRIPPED);
   1097                  if(!temp2) // If no overcurrent failure has been found, then apply the pwm error reaction, otherwise turn off Pwm
   \   00000FA8   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   00000FAC   0xF3C0 0x1080      UBFX     R0,R0,#+6,#+1
   \   00000FB0   0xBB38             CBNZ.N   R0,??SRMotorSafetyMgr__Handler5ms_36
   1098                  {
   1099                      OverVoltageProtection();
   \   00000FB2   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   00000FB6   0xF3C0 0x2040      UBFX     R0,R0,#+9,#+1
   \   00000FBA   0xB180             CBZ.N    R0,??SRMotorSafetyMgr__Handler5ms_37
   \   00000FBC   0xF504 0x7177      ADD      R1,R4,#+988
   \   00000FC0   0xF504 0x706F      ADD      R0,R4,#+956
   \   00000FC4   0x.... 0x....      BL       SRData__CheckShort
   \   00000FC8   0xF9B4 0x03BC      LDRSH    R0,[R4, #+956]
   \   00000FCC   0xF640 0x7185      MOVW     R1,#+3973
   \   00000FD0   0x4288             CMP      R0,R1
   \   00000FD2   0xDA04             BGE.N    ??SRMotorSafetyMgr__Handler5ms_37
   \   00000FD4   0xF240 0x510D      MOVW     R1,#+1293
   \   00000FD8   0x4288             CMP      R0,R1
   \   00000FDA   0xDA1F             BGE.N    ??SRMotorSafetyMgr__Handler5ms_38
   \   00000FDC   0xE011             B.N      ??SRMotorSafetyMgr__Handler5ms_36
   \                     ??SRMotorSafetyMgr__Handler5ms_37: (+1)
   \   00000FDE   0x.... 0x....      LDR.W    R5,??DataTable192_3  ;; 0x40038008
   \   00000FE2   0x2000             MOVS     R0,#+0
   \   00000FE4   0x6328             STR      R0,[R5, #+48]
   \   00000FE6   0x62A8             STR      R0,[R5, #+40]
   \   00000FE8   0x6228             STR      R0,[R5, #+32]
   \   00000FEA   0x61A8             STR      R0,[R5, #+24]
   \   00000FEC   0x6128             STR      R0,[R5, #+16]
   \   00000FEE   0x60A8             STR      R0,[R5, #+8]
   \   00000FF0   0xF44F 0x7000      MOV      R0,#+512
   \   00000FF4   0xF8C5 0x0090      STR      R0,[R5, #+144]
   \   00000FF8   0x6DA8             LDR      R0,[R5, #+88]
   \   00000FFA   0x0980             LSRS     R0,R0,#+6
   \   00000FFC   0x0180             LSLS     R0,R0,#+6
   \   00000FFE   0x65A8             STR      R0,[R5, #+88]
   \   00001000   0xE00C             B.N      ??SRMotorSafetyMgr__Handler5ms_38
   1100                  }
   1101                  else
   1102                  {
   1103                      SRMCPwm__TurnOffAllGates();
   \                     ??SRMotorSafetyMgr__Handler5ms_36: (+1)
   \   00001002   0x.... 0x....      LDR.W    R5,??DataTable192_3  ;; 0x40038008
   \   00001006   0x6DA8             LDR      R0,[R5, #+88]
   \   00001008   0xF040 0x003F      ORR      R0,R0,#0x3F
   \   0000100C   0x65A8             STR      R0,[R5, #+88]
   \   0000100E   0x6EE8             LDR      R0,[R5, #+108]
   \   00001010   0x0601             LSLS     R1,R0,#+24
   \   00001012   0x0FC9             LSRS     R1,R1,#+31
   \   00001014   0xBF1C             ITT      NE 
   \   00001016   0xF020 0x008F      BICNE    R0,R0,#0x8F
   \   0000101A   0x66E8             STRNE    R0,[R5, #+108]
   1104                  }
   1105          
   1106                  temp2 = (uint32)SR_Motor_Fault;
   1107                  temp2  = BIT_TEST(temp2, SR_FAULT_OVER_HEATING);
   1108          
   1109                  if(!temp2)
   \                     ??SRMotorSafetyMgr__Handler5ms_38: (+1)
   \   0000101C   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   00001020   0xF3C0 0x2000      UBFX     R0,R0,#+8,#+1
   \   00001024   0x2800             CMP      R0,#+0
   \   00001026   0xD139             BNE.N    ??SRMotorSafetyMgr__Handler5ms_14
   1110                  {
   1111                      // no overheating condition
   1112                      temp2 = (uint32)SR_Timeout_Failure_Retry;
   \   00001028   0xF8D4 0x052C      LDR      R0,[R4, #+1324]
   1113          
   1114                      if(!temp2)//timeout to zero
   \   0000102C   0xBB78             CBNZ.N   R0,??SRMotorSafetyMgr__Handler5ms_39
   1115                      {
   1116                          SR_DATA_MCU_UPDATE_SHORT(SR_Phase_Lost_Counter,0);
   \   0000102E   0x2200             MOVS     R2,#+0
   \   00001030   0xF204 0x5194      ADDW     R1,R4,#+1428
   \   00001034   0xF504 0x7070      ADD      R0,R4,#+960
   \   00001038   0x.... 0x....      BL       SRData__UpdateShort
   1117          
   1118                          // Clear all Sr Fault except the overheating one
   1119                          SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Fault,0);
   \   0000103C   0x2200             MOVS     R2,#+0
   \   0000103E   0xF504 0x7171      ADD      R1,R4,#+964
   \   00001042   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   00001046   0x.... 0x....      BL       SRData__UpdateShort
   1120          
   1121                          // Go postrun test to restart the motor
   1122                          SR_INITMOTORMOVINGHANDLER();
   \   0000104A   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   0000104E   0xF64F 0x71FE      MOVW     R1,#+65534
   \   00001052   0xEA01 0x0200      AND      R2,R1,R0
   \   00001056   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   0000105A   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   0000105E   0x.... 0x....      BL       SRData__UpdateShort
   \   00001062   0x2200             MOVS     R2,#+0
   \   00001064   0xF504 0x61F9      ADD      R1,R4,#+1992
   \   00001068   0xF204 0x5004      ADDW     R0,R4,#+1284
   \   0000106C   0x.... 0x....      BL       SRData__UpdateLong
   \   00001070   0x2200             MOVS     R2,#+0
   \   00001072   0xF204 0x71C4      ADDW     R1,R4,#+1988
   \   00001076   0xF504 0x60A0      ADD      R0,R4,#+1280
   \   0000107A   0x.... 0x....      BL       SRData__UpdateLong
   1123                          SR_DATA_MCU_UPDATE_BYTE(SR_SafetyMngr_State,SAFETY_MNGR_POSTRUN_TESTS);
   \                     ??SRMotorSafetyMgr__Handler5ms_15: (+1)
   \   0000107E   0x2204             MOVS     R2,#+4
   \                     ??SRMotorSafetyMgr__Handler5ms_18: (+1)
   \   00001080   0xF204 0x3173      ADDW     R1,R4,#+883
   \   00001084   0xF204 0x3072      ADDW     R0,R4,#+882
   \   00001088   0x.... 0x....      BL       SRData__UpdateByte
   \   0000108C   0xE006             B.N      ??SRMotorSafetyMgr__Handler5ms_14
   1124          
   1125                      }
   1126                      else //reduce time
   1127                      {
   1128                          temp2--;
   1129                          SR_DATA_MCU_UPDATE_LONG(SR_Timeout_Failure_Retry,temp2);
   \                     ??SRMotorSafetyMgr__Handler5ms_39: (+1)
   \   0000108E   0x1E42             SUBS     R2,R0,#+1
   \                     ??SRMotorSafetyMgr__Handler5ms_13: (+1)
   \   00001090   0xF504 0x61FE      ADD      R1,R4,#+2032
   \   00001094   0xF204 0x502C      ADDW     R0,R4,#+1324
   \                     ??SRMotorSafetyMgr__Handler5ms_27: (+1)
   \   00001098   0x.... 0x....      BL       SRData__UpdateLong
   1130                      }
   1131                  }
   1132          
   1133                  SR_MOTORSAFETY_MGR_ERROR_HANDLER((uint8 *)&SR_SafetyMngr_State);
   1134          
   1135              }
   1136          
   1137          
   1138              SRMOTORSAFETYMGR_5MS_FLOW_HANDLER_END();
   \                     ??SRMotorSafetyMgr__Handler5ms_14: (+1)
   \   0000109C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   000010A0   0x2001             MOVS     R0,#+1
   \   000010A2   0x.... 0x....      B.W      SRFlow__MainLogEvent
   1139          }
   1140          
   1141          
   1142          
   1143          //---------------------------------------------------------------------------------------------------------------------
   1144          /**
   1145           *  @brief      Perform the motor over load verification
   1146           */

   \                                 In section .text, align 2, keep-with-next
   1147          void SRMotorSafetyMgr__Handler25ms(void)
   1148          {
   \                     SRMotorSafetyMgr__Handler25ms: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1149              uint16 temp;
   1150              uint16 temp2;
   1151          
   1152              SRMOTORSAFETYMGR_25MS_FLOW_HANDLER_BEGIN();
   \   00000002   0x2006             MOVS     R0,#+6
   \   00000004   0x.... 0x....      BL       SRFlow__MainLogEvent
   1153          
   1154              SR_DATA_MCU_CHECK_BYTE(SR_SafetyMngr_State);
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable192_4
   \   0000000C   0xF204 0x3173      ADDW     R1,R4,#+883
   \   00000010   0xF204 0x3072      ADDW     R0,R4,#+882
   \   00000014   0x.... 0x....      BL       SRData__CheckByte
   1155          
   1156              temp = (uint16)SR_SafetyMngr_State;
   \   00000018   0xF894 0x0372      LDRB     R0,[R4, #+882]
   1157          
   1158              temp2 = SR_Motor_Flags;
   \   0000001C   0xF8B4 0x13A6      LDRH     R1,[R4, #+934]
   1159              temp2 = BIT_TEST(temp2, SR_FLAG_MC_PARAMETERS_LOADED);
   1160          
   1161              if( (temp > SAFETY_MNGR_INITIALIZE) &&          // overheating temperature initialized
   1162                  (temp2) )                                   // and ensure parameters are loaded
   \   00000020   0x2802             CMP      R0,#+2
   \   00000022   0xF2C0 0x809F      BLT.W    ??SRMotorSafetyMgr__Handler25ms_0
   \   00000026   0xF3C1 0x2040      UBFX     R0,R1,#+9,#+1
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xF000 0x809A      BEQ.W    ??SRMotorSafetyMgr__Handler25ms_0
   1163              {
   1164                  CheckSafetyParameters();
   \   00000030   0xF8D4 0x04F0      LDR      R0,[R4, #+1264]
   \   00000034   0x2232             MOVS     R2,#+50
   \   00000036   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000003A   0x1C80             ADDS     R0,R0,#+2
   \   0000003C   0x.... 0x....      BL       Crc16__RangeProcess
   \   00000040   0xF8D4 0x14F0      LDR      R1,[R4, #+1264]
   \   00000044   0x8809             LDRH     R1,[R1, #+0]
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD004             BEQ.N    ??SRMotorSafetyMgr__Handler25ms_1
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x.... 0x....      BL       SRException__Queue
   1165          
   1166                  CheckVariables4Failure_25ms();
   \                     ??SRMotorSafetyMgr__Handler25ms_1: (+1)
   \   00000054   0xF504 0x7171      ADD      R1,R4,#+964
   \   00000058   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   0000005C   0x.... 0x....      BL       SRData__CheckShort
   \   00000060   0xF504 0x61B2      ADD      R1,R4,#+1424
   \   00000064   0xF504 0x7069      ADD      R0,R4,#+932
   \   00000068   0x.... 0x....      BL       SRData__CheckShort
   \   0000006C   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000070   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000074   0x.... 0x....      BL       SRData__CheckShort
   \   00000078   0xF204 0x5196      ADDW     R1,R4,#+1430
   \   0000007C   0xF204 0x30C2      ADDW     R0,R4,#+962
   \   00000080   0x.... 0x....      BL       SRData__CheckShort
   \   00000084   0xF204 0x71F4      ADDW     R1,R4,#+2036
   \   00000088   0xF504 0x60A6      ADD      R0,R4,#+1328
   \   0000008C   0x.... 0x....      BL       SRData__CheckFloat
   \   00000090   0xF204 0x71D4      ADDW     R1,R4,#+2004
   \   00000094   0xF504 0x60A2      ADD      R0,R4,#+1296
   \   00000098   0x.... 0x....      BL       SRData__CheckLong
   \   0000009C   0xF504 0x61FB      ADD      R1,R4,#+2008
   \   000000A0   0xF204 0x5014      ADDW     R0,R4,#+1300
   \   000000A4   0x.... 0x....      BL       SRData__CheckLong
   \   000000A8   0xF204 0x71DC      ADDW     R1,R4,#+2012
   \   000000AC   0xF504 0x60A3      ADD      R0,R4,#+1304
   \   000000B0   0x.... 0x....      BL       SRData__CheckLong
   1167          
   1168                  OverHeatingProtection();
   \   000000B4   0xF8B4 0x03C2      LDRH     R0,[R4, #+962]
   \   000000B8   0x1C40             ADDS     R0,R0,#+1
   \   000000BA   0xF8A4 0x03C2      STRH     R0,[R4, #+962]
   \   000000BE   0xF8B4 0x03C2      LDRH     R0,[R4, #+962]
   \   000000C2   0x2828             CMP      R0,#+40
   \   000000C4   0xDB04             BLT.N    ??SRMotorSafetyMgr__Handler25ms_2
   \   000000C6   0x.... 0x....      BL       ??RcThermalUpdate
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0xF8A4 0x03C2      STRH     R0,[R4, #+962]
   \                     ??SRMotorSafetyMgr__Handler25ms_2: (+1)
   \   000000D0   0xF8D4 0x0530      LDR      R0,[R4, #+1328]
   \   000000D4   0xF8B4 0x13A2      LDRH     R1,[R4, #+930]
   \   000000D8   0xEE00 0x0A10      VMOV     S0,R0
   \   000000DC   0xF3C1 0x2100      UBFX     R1,R1,#+8,#+1
   \   000000E0   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   000000E4   0x2900             CMP      R1,#+0
   \   000000E6   0xEE10 0x0A10      VMOV     R0,S0
   \   000000EA   0xF8D4 0x14F0      LDR      R1,[R4, #+1264]
   \   000000EE   0xB200             SXTH     R0,R0
   \   000000F0   0xD00E             BEQ.N    ??SRMotorSafetyMgr__Handler25ms_3
   \   000000F2   0xF9B1 0x1004      LDRSH    R1,[R1, #+4]
   \   000000F6   0x4288             CMP      R0,R1
   \   000000F8   0xDA22             BGE.N    ??SRMotorSafetyMgr__Handler25ms_4
   \   000000FA   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   000000FE   0xF64F 0x61FF      MOVW     R1,#+65279
   \   00000102   0xEA01 0x0200      AND      R2,R1,R0
   \   00000106   0xF504 0x7171      ADD      R1,R4,#+964
   \   0000010A   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   0000010E   0xE015             B.N      ??SRMotorSafetyMgr__Handler25ms_5
   \                     ??SRMotorSafetyMgr__Handler25ms_3: (+1)
   \   00000110   0xF9B1 0x1006      LDRSH    R1,[R1, #+6]
   \   00000114   0x4281             CMP      R1,R0
   \   00000116   0xDA13             BGE.N    ??SRMotorSafetyMgr__Handler25ms_4
   \   00000118   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   0000011C   0xF440 0x7280      ORR      R2,R0,#0x100
   \   00000120   0xF504 0x7171      ADD      R1,R4,#+964
   \   00000124   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   00000128   0x.... 0x....      BL       SRData__UpdateShort
   \   0000012C   0xF8B4 0x03A4      LDRH     R0,[R4, #+932]
   \   00000130   0xF440 0x7280      ORR      R2,R0,#0x100
   \   00000134   0xF504 0x61B2      ADD      R1,R4,#+1424
   \   00000138   0xF504 0x7069      ADD      R0,R4,#+932
   \                     ??SRMotorSafetyMgr__Handler25ms_5: (+1)
   \   0000013C   0x.... 0x....      BL       SRData__UpdateShort
   \                     ??SRMotorSafetyMgr__Handler25ms_4: (+1)
   \   00000140   0xF8B4 0x23C2      LDRH     R2,[R4, #+962]
   \   00000144   0xF204 0x5196      ADDW     R1,R4,#+1430
   \   00000148   0xF204 0x30C2      ADDW     R0,R4,#+962
   \   0000014C   0x.... 0x....      BL       SRData__UpdateShort
   \   00000150   0xF8D4 0x0530      LDR      R0,[R4, #+1328]
   \   00000154   0xEE00 0x0A10      VMOV     S0,R0
   \   00000158   0xF204 0x71F4      ADDW     R1,R4,#+2036
   \   0000015C   0xF504 0x60A6      ADD      R0,R4,#+1328
   \   00000160   0x.... 0x....      BL       SRData__UpdateFloat
   1169              }
   1170          
   1171              SRMOTORSAFETYMGR_25MS_FLOW_HANDLER_END();
   \                     ??SRMotorSafetyMgr__Handler25ms_0: (+1)
   \   00000164   0xE8BD 0x4010      POP      {R4,LR}
   \   00000168   0x2007             MOVS     R0,#+7
   \   0000016A   0x.... 0x....      B.W      SRFlow__MainLogEvent
   1172          }
   1173          
   1174          
   1175          
   1176          
   1177          //---------------------------------------------------------------------------------------------------------------------
   1178          /**
   1179           *  @brief      Return if there is any exception on the motor control
   1180           *  @return     TRUE (fault found) or FALSE (no fault found)
   1181           */

   \                                 In section .text, align 2, keep-with-next
   1182          uint8 SRMotorSafetyMgr__AnyFaultFound(void)
   1183          {
   \                     SRMotorSafetyMgr__AnyFaultFound: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1184              uint8 response;
   1185              uint16 temp;
   1186          
   1187              SR_DATA_MCU_CHECK_SHORT(SR_Motor_Fault);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable192_4
   \   00000006   0xF504 0x7171      ADD      R1,R4,#+964
   \   0000000A   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   0000000E   0x.... 0x....      BL       SRData__CheckShort
   1188          
   1189              response = TRUE;
   1190          
   1191              temp = SR_Motor_Fault;
   1192          
   1193              if(!temp)
   \   00000012   0xF8B4 0x13A2      LDRH     R1,[R4, #+930]
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xB901             CBNZ.N   R1,??SRMotorSafetyMgr__AnyFaultFound_0
   1194              {
   1195                  response = FALSE;
   \   0000001A   0x2000             MOVS     R0,#+0
   1196              }
   1197          
   1198              return(response);
   \                     ??SRMotorSafetyMgr__AnyFaultFound_0: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
   1199          }
   1200          
   1201          
   1202          
   1203          //---------------------------------------------------------------------------------------------------------------------
   1204          /**
   1205           *  @brief      Get if a single fault has happened.
   1206           *  @Param      request_this_fault gives which fault should be verified.
   1207           *              Check in the definition of SR_MOTOR_FAULT_LIST_TYPE
   1208           *  @return     TRUE: given fault found or FALSE: given fault not found
   1209           */

   \                                 In section .text, align 2, keep-with-next
   1210          uint8 SRMotorSafetyMgr__GetFault(SR_MOTOR_FAULT_LIST_TYPE request_this_fault)
   1211          {
   \                     SRMotorSafetyMgr__GetFault: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1212              uint8 response = TRUE;
   1213              uint16 temp;
   1214          
   1215              SR_DATA_MCU_CHECK_SHORT(SR_Motor_Fault);
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable192_4
   \   00000008   0xB081             SUB      SP,SP,#+4
   \   0000000A   0xF505 0x7171      ADD      R1,R5,#+964
   \   0000000E   0xF205 0x30A2      ADDW     R0,R5,#+930
   \   00000012   0x.... 0x....      BL       SRData__CheckShort
   1216          
   1217              temp = SR_Motor_Fault;
   1218              temp = BIT_TEST(temp, (SR_MOTOR_FAULT_LIST_TYPE)request_this_fault);
   1219          
   1220              // Return the status of the tested fault.
   1221              if(temp)
   1222              {
   1223                  response = TRUE;
   1224              }
   1225              else
   1226              {
   1227                  response = FALSE;
   1228              }
   1229          
   1230              return(response);
   \   00000016   0xF8B5 0x03A2      LDRH     R0,[R5, #+930]
   \   0000001A   0x40E0             LSRS     R0,R0,R4
   \   0000001C   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000020   0xB001             ADD      SP,SP,#+4
   \   00000022   0xBD30             POP      {R4,R5,PC}       ;; return
   1231          }
   1232          
   1233          
   1234          
   1235          //---------------------------------------------------------------------------------------------------------------------
   1236          /**
   1237           * Return if there any error below the MCI.
   1238           * @return  FALSE - No error detected or the error are already recovered
   1239           *          TRUE - There is a error somewhere.
   1240           */

   \                                 In section .text, align 2, keep-with-next
   1241          SR_MOTOR_FAULT_LIST_TYPE SRMotorSafetyMgr__GetListedError(void)
   1242          {
   \                     SRMotorSafetyMgr__GetListedError: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   1243              uint16 temp;
   1244              SR_MOTOR_FAULT_LIST_TYPE response;
   1245          
   1246              response = (SR_MOTOR_FAULT_LIST_TYPE)0xFF;     // By default, set all error in the flag.
   1247          
   1248              temp = (uint16)SR_DATA_MCU_CHECK_SHORT(SR_Motor_Fault);
   1249              if(temp == SRDATA_OK)                       // If the fault variable is intact...
   \   00000002   0x.... 0x....      LDR.W    R5,??DataTable192_4
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x24FF             MOVS     R4,#+255
   \   0000000A   0xF505 0x7171      ADD      R1,R5,#+964
   \   0000000E   0xF205 0x30A2      ADDW     R0,R5,#+930
   \   00000012   0x.... 0x....      BL       SRData__CheckShort
   \   00000016   0xB908             CBNZ.N   R0,??SRMotorSafetyMgr__GetListedError_0
   1250              {
   1251                  response = (SR_MOTOR_FAULT_LIST_TYPE) SR_Motor_Fault;              // update the feedback variable
   \   00000018   0xF8B5 0x43A2      LDRH     R4,[R5, #+930]
   1252              }
   1253          
   1254              return(response);
   \                     ??SRMotorSafetyMgr__GetListedError_0: (+1)
   \   0000001C   0xB2E0             UXTB     R0,R4
   \   0000001E   0xB001             ADD      SP,SP,#+4
   \   00000020   0xBD30             POP      {R4,R5,PC}       ;; return
   1255          }
   1256          
   1257          
   1258          
   1259          
   1260          //---------------------------------------------------------------------------------------------------------------------
   1261          /**
   1262           *  @brief      Get if a single fault has happened and kept in the holder register
   1263           *
   1264           *  @Param      request_this_fault gives which fault should be verified.
   1265           *              Check in the definition of SR_MOTOR_FAULT_LIST_TYPE
   1266           *  @return     TRUE: given fault found or FALSE: given fault not found
   1267           */

   \                                 In section .text, align 2, keep-with-next
   1268          uint8 SRMotorSafetyMgr__GetFaultHolder(SR_MOTOR_FAULT_LIST_TYPE request_this_fault)
   1269          {
   \                     SRMotorSafetyMgr__GetFaultHolder: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1270              uint8 response;
   1271              uint16 temp_u16_holder;
   1272          
   1273              SR_DATA_MCU_CHECK_SHORT(SR_Motor_Fault_Holder);
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable192_4
   \   00000008   0xB081             SUB      SP,SP,#+4
   \   0000000A   0xF505 0x61B2      ADD      R1,R5,#+1424
   \   0000000E   0xF505 0x7069      ADD      R0,R5,#+932
   \   00000012   0x.... 0x....      BL       SRData__CheckShort
   1274          
   1275              temp_u16_holder = SR_Motor_Fault_Holder;
   \   00000016   0xF8B5 0x13A4      LDRH     R1,[R5, #+932]
   1276              temp_u16_holder = BIT_TEST(temp_u16_holder, (SR_MOTOR_FAULT_LIST_TYPE)request_this_fault);
   1277          
   1278              response = TRUE;                                // By default, error is true.
   \   0000001A   0x2001             MOVS     R0,#+1
   1279              if(temp_u16_holder == FALSE)                    // check if correlated bit is reset
   \   0000001C   0x40E1             LSRS     R1,R1,R4
   \   0000001E   0x07C9             LSLS     R1,R1,#+31
   \   00000020   0xBF58             IT       PL 
   1280              {
   1281                  response = FALSE;                           // then return error is false.
   \   00000022   0x2000             MOVPL    R0,#+0
   1282              }
   1283          
   1284              return(response);
   \   00000024   0xB001             ADD      SP,SP,#+4
   \   00000026   0xBD30             POP      {R4,R5,PC}       ;; return
   1285          }
   1286          
   1287          
   1288          
   1289          
   1290          //---------------------------------------------------------------------------------------------------------------------
   1291          /**
   1292           *  @brief      Get if a single fault has happened.
   1293           *  @Param      request_this_fault gives which fault should be verified.
   1294           *              Check in the definition of SR_MOTOR_FLAGS_LIST_TYPE
   1295           *  @return     TRUE: given fault found or FALSE: given fault not found
   1296           */

   \                                 In section .text, align 2, keep-with-next
   1297          uint8 SRMotorSafetyMgr__GetFlag(SR_MOTOR_FLAGS_LIST_TYPE request_this_flag)
   1298          {
   \                     SRMotorSafetyMgr__GetFlag: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1299              uint16 temp;
   1300              uint8 response = FALSE;
   1301          
   1302              SR_DATA_MCU_CHECK_SHORT(SR_Motor_Flags);
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable192_4
   \   00000008   0xB081             SUB      SP,SP,#+4
   \   0000000A   0xF205 0x31C6      ADDW     R1,R5,#+966
   \   0000000E   0xF205 0x30A6      ADDW     R0,R5,#+934
   \   00000012   0x.... 0x....      BL       SRData__CheckShort
   1303          
   1304              temp = SR_Motor_Flags;
   1305              temp = BIT_TEST(temp, (SR_MOTOR_FLAGS_LIST_TYPE)request_this_flag);
   1306          
   1307              // Return the status of the tested flag.
   1308              if(temp)
   1309              {
   1310                  response = TRUE;
   1311              }
   1312              else
   1313              {
   1314                  response = FALSE;
   1315              }
   1316          
   1317              return(response);
   \   00000016   0xF8B5 0x03A6      LDRH     R0,[R5, #+934]
   \   0000001A   0x40E0             LSRS     R0,R0,R4
   \   0000001C   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000020   0xB001             ADD      SP,SP,#+4
   \   00000022   0xBD30             POP      {R4,R5,PC}       ;; return
   1318          }
   1319          
   1320          
   1321          
   1322          //---------------------------------------------------------------------------------------------------------------------
   1323          /**
   1324           *  @brief      Feeds back if the state machine is in IDLe state.
   1325           *              being controller by a Class A software.
   1326           *  @param      none
   1327           *  @return     TRUE: is in IDLE / FALSE: is at any other state
   1328           */

   \                                 In section .text, align 2, keep-with-next
   1329          uint8 SRMotorSafetyMgr__IsInIdle(void)
   1330          {
   \                     SRMotorSafetyMgr__IsInIdle: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1331              uint8 temp;
   1332              uint16 temp16;
   1333          
   1334              SR_DATA_MCU_CHECK_BYTE(SR_SafetyMngr_State);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable192_4
   \   00000006   0xF204 0x3173      ADDW     R1,R4,#+883
   \   0000000A   0xF204 0x3072      ADDW     R0,R4,#+882
   \   0000000E   0x.... 0x....      BL       SRData__CheckByte
   1335              SR_DATA_MCU_CHECK_BYTE(SR_Motor_Flags);
   \   00000012   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000016   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   0000001A   0x.... 0x....      BL       SRData__CheckByte
   1336          
   1337              temp = (uint8)SR_SafetyMngr_State;
   \   0000001E   0xF894 0x0372      LDRB     R0,[R4, #+882]
   1338              temp16 = SR_Motor_Flags;
   \   00000022   0xF8B4 0x13A6      LDRH     R1,[R4, #+934]
   1339          
   1340              if((temp == SAFETY_MNGR_IDLE) &&
   1341                 (BIT_TEST(temp16, SR_FLAG_REQUESTED_TO_START) == 0))
   \   00000026   0x2802             CMP      R0,#+2
   \   00000028   0xD106             BNE.N    ??SRMotorSafetyMgr__IsInIdle_0
   1342              {
   1343                  temp = TRUE;
   \   0000002A   0x0609             LSLS     R1,R1,#+24
   \   0000002C   0x0E88             LSRS     R0,R1,#+26
   \   0000002E   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000032   0xF080 0x0001      EOR      R0,R0,#0x1
   \   00000036   0xBD10             POP      {R4,PC}
   1344              }
   1345              else
   1346              {
   1347                  temp = FALSE;
   \                     ??SRMotorSafetyMgr__IsInIdle_0: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   1348              }
   1349          
   1350              return(temp);
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
   1351          }
   1352          
   1353          
   1354          
   1355          //---------------------------------------------------------------------------------------------------------------------
   1356          /**
   1357           * Warn the Safety Manager the motor is going to start - this routine shall
   1358           * trigger the class b plausibility check BEFORE starting the motor.
   1359           * @return  TRUE accepted request
   1360           *          FALSE denied request
   1361           */

   \                                 In section .text, align 2, keep-with-next
   1362          uint8 SRMotorSafetyMgr__Prepare2StartMotor(void)
   1363          {
   \                     SRMotorSafetyMgr__Prepare2StartMotor: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1364              uint16 temp;
   1365              uint16 temp2;
   1366          
   1367              SR_DATA_MCU_CHECK_BYTE(SR_SafetyMngr_State);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable192_4
   \   00000006   0xF204 0x3173      ADDW     R1,R4,#+883
   \   0000000A   0xF204 0x3072      ADDW     R0,R4,#+882
   \   0000000E   0x.... 0x....      BL       SRData__CheckByte
   1368              SR_DATA_MCU_CHECK_SHORT(SR_Motor_Flags);
   \   00000012   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000016   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   0000001A   0x.... 0x....      BL       SRData__CheckShort
   1369          
   1370              temp2 = SR_Motor_Flags;
   \   0000001E   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   1371              temp2 = BIT_TEST(temp2, SR_FLAG_MC_PARAMETERS_LOADED);
   1372          
   1373              temp = (uint16)SR_SafetyMngr_State;
   1374              if( (temp == SAFETY_MNGR_IDLE)  &&
   1375                  (temp2) )
   \   00000022   0xF894 0x1372      LDRB     R1,[R4, #+882]
   \   00000026   0x2902             CMP      R1,#+2
   \   00000028   0xD11A             BNE.N    ??SRMotorSafetyMgr__Prepare2StartMotor_0
   \   0000002A   0xF3C0 0x2040      UBFX     R0,R0,#+9,#+1
   \   0000002E   0xB1B8             CBZ.N    R0,??SRMotorSafetyMgr__Prepare2StartMotor_0
   1376              {
   1377                  temp = SR_Motor_Flags;
   \   00000030   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   1378                  BIT_SET(temp, SR_FLAG_REQUESTED_TO_START);
   1379                  SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,temp);
   \   00000034   0xF040 0x0204      ORR      R2,R0,#0x4
   \   00000038   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   0000003C   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000040   0x.... 0x....      BL       SRData__UpdateShort
   1380          
   1381                  temp = SR_Motor_Flags;
   \   00000044   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   1382                  BIT_CLR(temp, SR_FLAG_REQUESTED_TO_STOP);
   1383                  SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,temp);
   \   00000048   0xF64F 0x71F7      MOVW     R1,#+65527
   \   0000004C   0xEA01 0x0200      AND      R2,R1,R0
   \   00000050   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000054   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000058   0x.... 0x....      BL       SRData__UpdateShort
   1384          
   1385                  temp = TRUE;
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xBD10             POP      {R4,PC}
   1386              }
   1387              else
   1388              {
   1389                  temp = FALSE;
   \                     ??SRMotorSafetyMgr__Prepare2StartMotor_0: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   1390              }
   1391          
   1392          
   1393              return((uint8)temp);
   \   00000062   0xBD10             POP      {R4,PC}          ;; return
   1394          }
   1395          
   1396          
   1397          
   1398          //---------------------------------------------------------------------------------------------------------------------
   1399          /**
   1400           * Warn the Safety Manager the motor is going to stop soon - this routine shall
   1401           * trigger the class b zero speed measurements.
   1402           * @return  TRUE accepted request
   1403           *          FALSE denied request
   1404           */

   \                                 In section .text, align 2, keep-with-next
   1405          uint8 SRMotorSafetyMgr__Prepare2StopMotor(void)
   1406          {
   \                     SRMotorSafetyMgr__Prepare2StopMotor: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   1407              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
   1408              uint16 temp;
   1409              uint16 temp_flags;
   1410          
   1411              SR_DATA_MCU_CHECK_BYTE(SR_SafetyMngr_State);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable192_4
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0xF204 0x3173      ADDW     R1,R4,#+883
   \   0000000C   0xF204 0x3072      ADDW     R0,R4,#+882
   \   00000010   0x.... 0x....      BL       SRData__CheckByte
   1412              SR_DATA_MCU_CHECK_SHORT(SR_Motor_Flags);
   \   00000014   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000018   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   0000001C   0x.... 0x....      BL       SRData__CheckShort
   1413          
   1414              temp  = (uint16)SR_SafetyMngr_State;
   \   00000020   0xF894 0x0372      LDRB     R0,[R4, #+882]
   1415          
   1416              if( (temp == SAFETY_MNGR_RUNNING) ||
   1417                  (temp == SAFETY_MNGR_PRERUN_TESTS))
   \   00000024   0x2805             CMP      R0,#+5
   \   00000026   0xBF18             IT       NE 
   \   00000028   0x2803             CMPNE    R0,#+3
   \   0000002A   0xD111             BNE.N    ??SRMotorSafetyMgr__Prepare2StopMotor_0
   1418              {
   1419                  // From this moment on, the class B will
   1420                  // take over on the control of the pwm access
   1421          
   1422                  MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \   0000002C   0xF3EF 0x8510      MRS      R5,PRIMASK
   \   00000030   0xB672             CPSID    I
   1423          
   1424                  // Set the request to stop
   1425                  temp_flags = SR_Motor_Flags;
   \   00000032   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   1426                  BIT_SET(temp_flags, SR_FLAG_REQUESTED_TO_STOP);
   1427                  SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,temp_flags);
   \   00000036   0xF040 0x0208      ORR      R2,R0,#0x8
   \   0000003A   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   0000003E   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000042   0x.... 0x....      BL       SRData__UpdateShort
   1428          
   1429                  MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \   00000046   0xF385 0x8810      MSR      PRIMASK,R5
   1430          
   1431                  temp = TRUE;
   \   0000004A   0x2001             MOVS     R0,#+1
   1432              }
   1433              else
   1434              {
   1435                  temp = FALSE;
   1436              }
   1437          
   1438              return((uint8)temp);
   \   0000004C   0xB001             ADD      SP,SP,#+4
   \   0000004E   0xBD30             POP      {R4,R5,PC}
   \                     ??SRMotorSafetyMgr__Prepare2StopMotor_0: (+1)
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xB001             ADD      SP,SP,#+4
   \   00000054   0xBD30             POP      {R4,R5,PC}       ;; return
   1439          }
   1440          
   1441          
   1442          
   1443          //---------------------------------------------------------------------------------------------------------------------
   1444          /**
   1445           *  @brief      Force the motor to stop in a safe way, regardless if the motor is
   1446           *              being controller by a Class A software.
   1447           *  @param      none
   1448           *  @return     TRUE: accepted / FALSE: not accepted
   1449           */

   \                                 In section .text, align 2, keep-with-next
   1450          uint8 SRMotorSafetyMgr__ForceStop(void)
   1451          {
   \                     SRMotorSafetyMgr__ForceStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1452              uint16 temp;
   1453          
   1454              SR_DATA_MCU_CHECK_SHORT(SR_Motor_Flags);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable192_4
   \   00000006   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   0000000A   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   0000000E   0x.... 0x....      BL       SRData__CheckShort
   1455          
   1456              // Set the request to force stop
   1457              temp = SR_Motor_Flags;
   \   00000012   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   1458              BIT_SET(temp, SR_FLAG_FORCE_TO_STOP);
   1459              SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,temp);
   \   00000016   0xF440 0x6200      ORR      R2,R0,#0x800
   \   0000001A   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   0000001E   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000022   0x.... 0x....      BL       SRData__UpdateShort
   1460          
   1461              temp = SRMotorSafetyMgr__Prepare2StopMotor();
   1462          
   1463              return((uint8)temp);
   \   00000026   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002A   0x....             B.N      SRMotorSafetyMgr__Prepare2StopMotor
   1464          }
   1465          
   1466          
   1467          
   1468          //---------------------------------------------------------------------------------------------------------------------
   1469          /**
   1470           *  @brief      Update Pwm variables - class A part
   1471           *  @param      pwm values
   1472           *
   1473           */

   \                                 In section .text, align 2, keep-with-next
   1474          void SRMotorSafetyMgr__UpdatePwm(sint32 duty_a, sint32 duty_b, sint32 duty_c)
   1475          {
   \                     SRMotorSafetyMgr__UpdatePwm: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1476              uint16 temp;
   1477              sint32 max_pwm;
   1478          
   1479              SR_DATA_MCU_CHECK_SHORT(SR_Motor_Flags);
   \   00000006   0x.... 0x....      LDR.W    R7,??DataTable192_4
   \   0000000A   0xB081             SUB      SP,SP,#+4
   \   0000000C   0x4616             MOV      R6,R2
   \   0000000E   0xF207 0x31C6      ADDW     R1,R7,#+966
   \   00000012   0xF207 0x30A6      ADDW     R0,R7,#+934
   \   00000016   0x.... 0x....      BL       SRData__CheckShort
   1480          
   1481              temp = SR_Motor_Flags;
   1482              temp = BIT_TEST(temp, SR_FLAG_CLASS_A_PWM_ACCESS);
   1483              if(temp) // if the class A has access to the pwm peripheral
   \   0000001A   0xF8B7 0x03A6      LDRH     R0,[R7, #+934]
   \   0000001E   0x0780             LSLS     R0,R0,#+30
   \   00000020   0xD51B             BPL.N    ??SRMotorSafetyMgr__UpdatePwm_0
   1484              {
   1485                  //! Update pwm duty cycles when protection is not activated
   1486                  max_pwm = SRMotorSafetyMgr__GetMaxPwm();
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable192_3  ;; 0x40038008
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x1C49             ADDS     R1,R1,#+1
   1487          
   1488                  duty_a = (max_pwm * duty_a)>>15;
   1489                  duty_b = (max_pwm * duty_b)>>15;
   1490                  duty_c = (max_pwm * duty_c)>>15;
   1491          
   1492                  SRMCPWM__LOADALLPWMVALUES(duty_a, duty_b, duty_c);
   \   0000002A   0xFB06 0xF201      MUL      R2,R6,R1
   \   0000002E   0xFB05 0xF301      MUL      R3,R5,R1
   \   00000032   0x4361             MULS     R1,R1,R4
   \   00000034   0x0049             LSLS     R1,R1,#+1
   \   00000036   0x1409             ASRS     R1,R1,#+16
   \   00000038   0x6301             STR      R1,[R0, #+48]
   \   0000003A   0x005B             LSLS     R3,R3,#+1
   \   0000003C   0x4249             RSBS     R1,R1,#+0
   \   0000003E   0x6281             STR      R1,[R0, #+40]
   \   00000040   0x141B             ASRS     R3,R3,#+16
   \   00000042   0x4259             RSBS     R1,R3,#+0
   \   00000044   0x0052             LSLS     R2,R2,#+1
   \   00000046   0x6181             STR      R1,[R0, #+24]
   \   00000048   0x1412             ASRS     R2,R2,#+16
   \   0000004A   0x4251             RSBS     R1,R2,#+0
   \   0000004C   0x6081             STR      R1,[R0, #+8]
   \   0000004E   0x6203             STR      R3,[R0, #+32]
   \   00000050   0xF44F 0x7100      MOV      R1,#+512
   \   00000054   0x6102             STR      R2,[R0, #+16]
   \   00000056   0xF8C0 0x1090      STR      R1,[R0, #+144]
   1493              }
   1494          
   1495          }
   \                     ??SRMotorSafetyMgr__UpdatePwm_0: (+1)
   \   0000005A   0xB001             ADD      SP,SP,#+4
   \   0000005C   0xBDF0             POP      {R4-R7,PC}       ;; return
   1496          
   1497          
   1498          
   1499          //---------------------------------------------------------------------------------------------------------------------
   1500          /**
   1501           *  @brief      Set protection active flag and output pattern. If a pattern which is not defined
   1502           *              is passed as parameter, it will force the state machine to error state.
   1503           *  @param      OUTPUT_PATTERN_TYPE pattern
   1504           *  @return     TRUE: request accepted / FALSE: request denied
   1505           */

   \                                 In section .text, align 2, keep-with-next
   1506          uint8 SRMotorSafetyMgr__ConfigPwmPattern(OUTPUT_PATTERN_TYPE pattern)
   1507          {
   \                     SRMotorSafetyMgr__ConfigPwmPattern: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1508              uint16 temp;
   1509          
   1510              SR_DATA_MCU_CHECK_SHORT(SR_Motor_Flags);
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable192_4
   \   00000008   0xB081             SUB      SP,SP,#+4
   \   0000000A   0xF205 0x31C6      ADDW     R1,R5,#+966
   \   0000000E   0xF205 0x30A6      ADDW     R0,R5,#+934
   \   00000012   0x.... 0x....      BL       SRData__CheckShort
   1511          
   1512              temp = SR_Motor_Flags;
   1513              temp = BIT_TEST(temp, SR_FLAG_CLASS_A_PWM_ACCESS);
   \   00000016   0xF8B5 0x03A6      LDRH     R0,[R5, #+934]
   \   0000001A   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   1514              if(temp)    // if the class A has access to the pwm peripheral
   \   0000001E   0xB328             CBZ.N    R0,??SRMotorSafetyMgr__ConfigPwmPattern_0
   1515              {
   1516                  // The write the pattern asked by the class A to the pwm peripheral
   1517                  if(pattern == OUTPUT_PATTERN_LOWERS_ON)
   \   00000020   0x2C01             CMP      R4,#+1
   \   00000022   0xD113             BNE.N    ??SRMotorSafetyMgr__ConfigPwmPattern_1
   1518                  {
   1519                      temp = TRUE;
   1520          
   1521                      SRMCPwm__TurnOnLowSideGates();
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable192_5  ;; 0x40038010
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x628A             STR      R2,[R1, #+40]
   \   0000002C   0x620A             STR      R2,[R1, #+32]
   \   0000002E   0x618A             STR      R2,[R1, #+24]
   \   00000030   0x610A             STR      R2,[R1, #+16]
   \   00000032   0x608A             STR      R2,[R1, #+8]
   \   00000034   0x600A             STR      R2,[R1, #+0]
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xF44F 0x7200      MOV      R2,#+512
   \   0000003C   0xF8C1 0x2088      STR      R2,[R1, #+136]
   1522                  }
   1523                  else if(pattern == OUTPUT_PATTERN_ALL_DEV_OFF)
   1524                  {
   1525                      temp = TRUE;
   1526                      //! Turning only low side igbt off helps on the brownout management. Turn high side off does not help.
   1527                      SRMCPwm__TurnOffAllGates();
   1528                  }
   1529              }
   1530          
   1531              return(temp);
   \   00000040   0xB001             ADD      SP,SP,#+4
   \   00000042   0x6D0A             LDR      R2,[R1, #+80]
   \   00000044   0x0992             LSRS     R2,R2,#+6
   \   00000046   0x0192             LSLS     R2,R2,#+6
   \   00000048   0x650A             STR      R2,[R1, #+80]
   \   0000004A   0xBD30             POP      {R4,R5,PC}
   \                     ??SRMotorSafetyMgr__ConfigPwmPattern_1: (+1)
   \   0000004C   0x2C02             CMP      R4,#+2
   \   0000004E   0xD10D             BNE.N    ??SRMotorSafetyMgr__ConfigPwmPattern_0
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable192_5  ;; 0x40038010
   \   00000056   0x6D0A             LDR      R2,[R1, #+80]
   \   00000058   0xF042 0x023F      ORR      R2,R2,#0x3F
   \   0000005C   0x650A             STR      R2,[R1, #+80]
   \   0000005E   0x6E4A             LDR      R2,[R1, #+100]
   \   00000060   0x0613             LSLS     R3,R2,#+24
   \   00000062   0x0FDB             LSRS     R3,R3,#+31
   \   00000064   0xBF1C             ITT      NE 
   \   00000066   0xF022 0x028F      BICNE    R2,R2,#0x8F
   \   0000006A   0x664A             STRNE    R2,[R1, #+100]
   \                     ??SRMotorSafetyMgr__ConfigPwmPattern_0: (+1)
   \   0000006C   0xB001             ADD      SP,SP,#+4
   \   0000006E   0xBD30             POP      {R4,R5,PC}       ;; return
   1532          }
   1533          
   1534          
   1535          
   1536          //---------------------------------------------------------------------------------------------------------------------
   1537          /**
   1538           *  @brief      Gets the value set in the pwm peripheral and returns to the caller.
   1539           *              This method also encapsulates the register and does not provide
   1540           *              direct access to the peripheral register.
   1541           *  @param      none
   1542           *  @return     PWM Period set in the MCPwm peripheral
   1543           */

   \                                 In section .text, align 2, keep-with-next
   1544          sint32 SRMotorSafetyMgr__GetMaxPwm(void)
   1545          {
   1546              return(SRMCPWM__GETMAXPWM());
   \                     SRMotorSafetyMgr__GetMaxPwm: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable192_3  ;; 0x40038008
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x4770             BX       LR               ;; return
   1547          }
   1548          
   1549          
   1550          
   1551          //---------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
   1552          float SRMotorSafetyMgr__SR_SquaredCurrentRmsA()
   1553          {
   \                     SRMotorSafetyMgr__SR_SquaredCurrentRmsA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1554              float data;
   1555          
   1556              SR_DATA_MCU_CHECK_LONG(SR_SquaredCurrentRmsA);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable192_4
   \   00000006   0xF204 0x71D4      ADDW     R1,R4,#+2004
   \   0000000A   0xF504 0x60A2      ADD      R0,R4,#+1296
   \   0000000E   0x.... 0x....      BL       SRData__CheckLong
   1557              data = (SR_SquaredCurrentRmsA);
   1558              return(data);
   \   00000012   0xF8D4 0x0510      LDR      R0,[R4, #+1296]
   \   00000016   0xEE00 0x0A10      VMOV     S0,R0
   \   0000001A   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   1559          }
   1560          
   1561          //---------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
   1562          float SRMotorSafetyMgr__SR_SquaredCurrentRmsB()
   1563          {
   \                     SRMotorSafetyMgr__SR_SquaredCurrentRmsB: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1564              float data;
   1565          
   1566              SR_DATA_MCU_CHECK_LONG(SR_SquaredCurrentRmsB);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable192_4
   \   00000006   0xF504 0x61FB      ADD      R1,R4,#+2008
   \   0000000A   0xF204 0x5014      ADDW     R0,R4,#+1300
   \   0000000E   0x.... 0x....      BL       SRData__CheckLong
   1567              data = (SR_SquaredCurrentRmsB);
   1568              return(data);
   \   00000012   0xF8D4 0x0514      LDR      R0,[R4, #+1300]
   \   00000016   0xEE00 0x0A10      VMOV     S0,R0
   \   0000001A   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   1569          }
   1570          
   1571          //---------------------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
   1572          float SRMotorSafetyMgr__SR_SquaredCurrentRmsC()
   1573          {
   \                     SRMotorSafetyMgr__SR_SquaredCurrentRmsC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1574              float data;
   1575          
   1576              SR_DATA_MCU_CHECK_LONG(SR_SquaredCurrentRmsC);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable192_4
   \   00000006   0xF204 0x71DC      ADDW     R1,R4,#+2012
   \   0000000A   0xF504 0x60A3      ADD      R0,R4,#+1304
   \   0000000E   0x.... 0x....      BL       SRData__CheckLong
   1577              data = SR_SquaredCurrentRmsC;
   1578              return(data);
   \   00000012   0xF8D4 0x0518      LDR      R0,[R4, #+1304]
   \   00000016   0xEE00 0x0A10      VMOV     S0,R0
   \   0000001A   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   1579          }
   1580          
   1581          
   1582          
   1583          //---------------------------------------------------------------------------------------------------------------------
   1584          /**
   1585           *  @brief      Write the address of SRMotorSafety parameters.
   1586           *  @details
   1587           *
   1588           * @return  TRUE - value accepted
   1589           *          FALSE - value denied - default answer.
   1590           */
   1591          

   \                                 In section .text, align 4, keep-with-next
   1592          BOOL_TYPE SRMotorSafetyMgr__SetParams(void *params_address)
   1593          {
   \                     SRMotorSafetyMgr__SetParams: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   1594              BOOL_TYPE ret_val = FALSE;
   1595              uint16 temp;
   1596          
   1597              SR_DATA_MCU_CHECK_SHORT(SR_Motor_Flags);
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable192_4
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   0000000E   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000012   0x.... 0x....      BL       SRData__CheckShort
   1598          
   1599              if (params_address != NULL)
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD04F             BEQ.N    ??SRMotorSafetyMgr__SetParams_0
   1600              {
   1601                  SR_MotorSafety_Params = (MOTOR_SAFETY_PARAMS_TYPE *)params_address;
   \   0000001A   0xF8C4 0x54F0      STR      R5,[R4, #+1264]
   1602          
   1603                  temp = CheckSafetyParameters();
   \   0000001E   0x2232             MOVS     R2,#+50
   \   00000020   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000024   0x1CA8             ADDS     R0,R5,#+2
   \   00000026   0x.... 0x....      BL       Crc16__RangeProcess
   \   0000002A   0xF8D4 0x14F0      LDR      R1,[R4, #+1264]
   \   0000002E   0x8809             LDRH     R1,[R1, #+0]
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD012             BEQ.N    ??SRMotorSafetyMgr__SetParams_1
   \   00000034   0x2200             MOVS     R2,#+0
   \   00000036   0x4611             MOV      R1,R2
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x.... 0x....      BL       SRException__Queue
   1604                  if(temp == SRDATA_OK)
   1605                  {
   1606                      temp = SR_Motor_Flags;
   1607                      BIT_SET(temp, SR_FLAG_MC_PARAMETERS_LOADED);
   1608                      SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,temp);
   1609          
   1610                      InitOverHeatingProtection();
   1611          
   1612                      ret_val = TRUE;
   1613                  }
   1614                  else
   1615                  {
   1616                      temp = SR_Motor_Flags;
   \   0000003E   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   1617                      BIT_CLR(temp, SR_FLAG_MC_PARAMETERS_LOADED);
   1618                      SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,temp);
   \   00000042   0xF64F 0x51FF      MOVW     R1,#+65023
   \   00000046   0xEA01 0x0200      AND      R2,R1,R0
   \   0000004A   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   0000004E   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   00000052   0x.... 0x....      BL       SRData__UpdateShort
   1619                      ret_val = FALSE;
   1620                  }
   1621              }
   1622              return ret_val;
   \   00000056   0x4630             MOV      R0,R6
   \   00000058   0xBD70             POP      {R4-R6,PC}
   \                     ??SRMotorSafetyMgr__SetParams_1: (+1)
   \   0000005A   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   \   0000005E   0xF440 0x7200      ORR      R2,R0,#0x200
   \   00000062   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   00000066   0xF204 0x30A6      ADDW     R0,R4,#+934
   \   0000006A   0x.... 0x....      BL       SRData__UpdateShort
   \   0000006E   0x2200             MOVS     R2,#+0
   \   00000070   0xF204 0x5196      ADDW     R1,R4,#+1430
   \   00000074   0xF204 0x30C2      ADDW     R0,R4,#+962
   \   00000078   0x.... 0x....      BL       SRData__UpdateShort
   \   0000007C   0xF8D4 0x04F0      LDR      R0,[R4, #+1264]
   \   00000080   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   00000084   0xEE00 0x0A10      VMOV     S0,R0
   \   00000088   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000008C   0xF204 0x71F4      ADDW     R1,R4,#+2036
   \   00000090   0xF504 0x60A6      ADD      R0,R4,#+1328
   \   00000094   0x.... 0x....      BL       SRData__UpdateFloat
   \   00000098   0xED9F 0x....      VLDR.W   S0,??DataTable191  ;; 0x0
   \   0000009C   0xF504 0x61FF      ADD      R1,R4,#+2040
   \   000000A0   0xF504 0x60A7      ADD      R0,R4,#+1336
   \   000000A4   0x.... 0x....      BL       SRData__UpdateFloat
   \   000000A8   0xED9F 0x....      VLDR.W   S0,??DataTable191  ;; 0x0
   \   000000AC   0xF204 0x71FC      ADDW     R1,R4,#+2044
   \   000000B0   0xF204 0x5034      ADDW     R0,R4,#+1332
   \   000000B4   0x.... 0x....      BL       SRData__UpdateFloat
   \   000000B8   0x2601             MOVS     R6,#+1
   \                     ??SRMotorSafetyMgr__SetParams_0: (+1)
   \   000000BA   0x4630             MOV      R0,R6
   \   000000BC   0xBD70             POP      {R4-R6,PC}       ;; return
   1623          }
   1624          
   1625          
   1626          
   1627          
   1628          //---------------------------------------------------------------------------------------------------------------------
   1629          /**
   1630           *  @brief      Get the calculated fundamental frequency of voltage
   1631           *  @param      none
   1632           *  @return     [Hz] float - Class A interface - fundamental voltage
   1633           */

   \                                 In section .text, align 2, keep-with-next
   1634          float SRMotorSafetyMgr__GetVoltageFrequency(void)
   1635          {
   \                     SRMotorSafetyMgr__GetVoltageFrequency: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1636              SR_DATA_MCU_CHECK_FLOAT(SR_Voltage_Frequency);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable192_4
   \   00000006   0xF204 0x71FC      ADDW     R1,R4,#+2044
   \   0000000A   0xF204 0x5034      ADDW     R0,R4,#+1332
   \   0000000E   0x.... 0x....      BL       SRData__CheckFloat
   1637          
   1638              return(SR_Voltage_Frequency);
   \   00000012   0xF8D4 0x0534      LDR      R0,[R4, #+1332]
   \   00000016   0xEE00 0x0A10      VMOV     S0,R0
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
   1639          }
   1640          
   1641          
   1642          
   1643          
   1644          //---------------------------------------------------------------------------------------------------------------------
   1645          /**
   1646           *  @brief      Get the squared currents
   1647           *  @param      none
   1648           *  @return     [A] float - Class A interface - squared current sum of all 3 currents
   1649           */

   \                                 In section .text, align 2, keep-with-next
   1650          float SRMotorSafetyMgr__GetSquaredCurrents(void)
   1651          {
   \                     SRMotorSafetyMgr__GetSquaredCurrents: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1652              SR_DATA_MCU_CHECK_FLOAT(SR_Squared_Current);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable192_4
   \   00000006   0xF504 0x61FF      ADD      R1,R4,#+2040
   \   0000000A   0xF504 0x60A7      ADD      R0,R4,#+1336
   \   0000000E   0x.... 0x....      BL       SRData__CheckFloat
   1653          
   1654              return(SR_Squared_Current);
   \   00000012   0xF8D4 0x0538      LDR      R0,[R4, #+1336]
   \   00000016   0xEE00 0x0A10      VMOV     S0,R0
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
   1655          }
   1656          
   1657          
   1658          
   1659          
   1660          //---------------------------------------------------------------------------------------------------------------------
   1661          /**
   1662           *  @brief      Get the class B motor temperature (thermal model)
   1663           *  @param      none
   1664           *  @return     [deg C] float - Class A interface - motor temperature - calculated from thermal model
   1665           */

   \                                 In section .text, align 2, keep-with-next
   1666          float SRMotorSafetyMgr__GetMotorTemperature(void)
   1667          {
   \                     SRMotorSafetyMgr__GetMotorTemperature: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1668              SR_DATA_MCU_CHECK_FLOAT(SR_Overheating_Temp);
   \   00000002   0x....             LDR.N    R4,??DataTable192_4
   \   00000004   0xF204 0x71F4      ADDW     R1,R4,#+2036
   \   00000008   0xF504 0x60A6      ADD      R0,R4,#+1328
   \   0000000C   0x.... 0x....      BL       SRData__CheckFloat
   1669          
   1670              return(SR_Overheating_Temp);
   \   00000010   0xF8D4 0x0530      LDR      R0,[R4, #+1328]
   \   00000014   0xEE00 0x0A10      VMOV     S0,R0
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
   1671          }
   1672          
   1673          
   1674          
   1675          
   1676          //=====================================================================================================================
   1677          //-------------------------------------- Private Functions ------------------------------------------------------------
   1678          //=====================================================================================================================
   1679          
   1680          /**
   1681           *  @brief      Handler the unlock door speed (or rotor not moving) detection sub module. This shall be a part of the
   1682           *              whole class B protection. It uses two flags, one is to detect when the speed is really zero and,
   1683           *              when there is no movement in at the motor shaft. For safety issues, the zero speed detection
   1684           *              shall be used as flag for lid opening. There is also a flag which warns that the unlock door speed
   1685           *              was not able to be detected, this is not a fault and will not prevent the motor to start over.
   1686           *              This error in the unlock door speed flag shall be used in the door lock routine.
   1687           */
   1688          #ifdef __IAR_SYSTEMS_ICC__
   1689          #pragma inline = forced
   1690          #endif
   1691          uint8 CheckSafetyParameters(void)
   1692          {
   1693              sint16 check = SRDATA_OK;
   1694              uint16 crc;
   1695          
   1696              crc = Crc16__RangeProcess((uint8 *)&(SR_MotorSafety_Params->OverHeating_Temp_Init),0xFFFF,(SAFETY_MOTOR_PARAMETERS_NUM-2)); //lint !e928
   1697          
   1698              if( crc !=  SR_MotorSafety_Params->SrCrc)
   1699              {
   1700                  SRDATA_CORRUPTION_EXCEPTION(0);
   1701                  check = 1;
   1702              }
   1703          
   1704              return( (uint8)check);
   1705          }
   1706          
   1707          
   1708          
   1709          
   1710          /**
   1711           *  @brief      It tests the integrity of each variable used in this Class B module. It performs an OR
   1712           *              operation between all used variable.
   1713           *  @return     TRUE: at least one variable is corrupted
   1714           *              FALSE: all variables are ok (not corrupted)
   1715           */
   1716          #ifdef __IAR_SYSTEMS_ICC__
   1717          #pragma inline = forced
   1718          #endif
   1719          void CheckAnalogVariables4Failure(void)
   1720          {
   1721              sint16 check = SRDATA_OK;
   1722          
   1723              MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
   1724          
   1725              MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   1726          
   1727              SR_MCU_MOTOR_CHECK_SHORT(check,SR_CurrentA);
   1728              SR_MCU_MOTOR_CHECK_SHORT(check,SR_CurrentB);
   1729              SR_MCU_MOTOR_CHECK_SHORT(check,SR_CurrentC);
   1730              SR_MCU_MOTOR_CHECK_SHORT(check,SR_CurrentOffsetA);
   1731              SR_MCU_MOTOR_CHECK_SHORT(check,SR_CurrentOffsetB);
   1732              SR_MCU_MOTOR_CHECK_SHORT(check,SR_CurrentOffsetC);
   1733              SR_MCU_MOTOR_CHECK_SHORT(check,SR_DCBus);
   1734          
   1735              if(check)
   1736              {
   1737                  SRDATA_CORRUPTION_EXCEPTION(0);
   1738              }
   1739          
   1740              MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   1741          }
   1742          
   1743          
   1744          
   1745          
   1746          
   1747          
   1748          /**
   1749           *  @brief      It tests the integrity of each variable used in this Class B module. It performs an OR
   1750           *              operation between all used variable.
   1751           *  @return     TRUE: at least one variable is corrupted
   1752           *              FALSE: all variables are ok (not corrupted)
   1753           */
   1754          #ifdef __IAR_SYSTEMS_ICC__
   1755          #pragma inline = forced
   1756          #endif
   1757          void CheckVariables4Failure_Pwm(void)
   1758          {
   1759              sint16 check = SRDATA_OK;
   1760          
   1761              SR_MCU_MOTOR_CHECK_BYTE(check, SR_SafetyMngr_State);
   1762              SR_MCU_MOTOR_CHECK_SHORT(check, SR_Motor_Flags);
   1763              SR_MCU_MOTOR_CHECK_SHORT(check, SR_Motor_Fault);
   1764              SR_MCU_MOTOR_CHECK_SHORT(check, SR_Raw_CurrentA);
   1765              SR_MCU_MOTOR_CHECK_SHORT(check, SR_Raw_CurrentB);
   1766              SR_MCU_MOTOR_CHECK_SHORT(check, SR_Raw_CurrentC);
   1767              SR_MCU_MOTOR_CHECK_SHORT(check, SR_DCBus);
   1768          #ifdef SR_THIRD_CURRENT_RECONSTRUCTION
   1769              SR_MCU_MOTOR_CHECK_SHORT(check,SR_Sector);
   1770          #endif
   1771              SR_MCU_MOTOR_CHECK_BYTE(check, SR_SafetyMngr_State);
   1772          
   1773              if(check)
   1774              {
   1775                  SRDATA_CORRUPTION_EXCEPTION(0);
   1776              }
   1777          }
   1778          
   1779          
   1780          /**
   1781           *  @brief      It tests the integrity of each variable used in this Class B module. It performs an OR
   1782           *              operation between all used variable.
   1783           *  @return     TRUE: at least one variable is corrupted
   1784           *              FALSE: all variables are ok (not corrupted)
   1785           */
   1786          #ifdef __IAR_SYSTEMS_ICC__
   1787          #pragma inline = forced
   1788          #endif
   1789          void CheckVariables4Failure_250us(void)
   1790          {
   1791              SR_DATA_MCU_CHECK_BYTE(SR_SafetyMngr_State);
   1792          
   1793              SR_DATA_MCU_CHECK_SHORT(SR_Motor_Fault);
   1794              SR_DATA_MCU_CHECK_SHORT(SR_Motor_Fault_Holder);
   1795              SR_DATA_MCU_CHECK_SHORT(SR_Motor_Flags);
   1796              SR_DATA_MCU_CHECK_SHORT(SR_CurrentA);
   1797              SR_DATA_MCU_CHECK_SHORT(SR_CurrentB);
   1798              SR_DATA_MCU_CHECK_SHORT(SR_CurrentC);
   1799              SR_DATA_MCU_CHECK_SHORT(SR_CurrentOffsetA);
   1800              SR_DATA_MCU_CHECK_SHORT(SR_CurrentOffsetB);
   1801              SR_DATA_MCU_CHECK_SHORT(SR_CurrentOffsetC);
   1802              SR_DATA_MCU_CHECK_SHORT(SR_DCBus);
   1803              SR_DATA_MCU_CHECK_SHORT(SR_Raw_CurrentA);
   1804              SR_DATA_MCU_CHECK_SHORT(SR_Raw_CurrentB);
   1805              SR_DATA_MCU_CHECK_SHORT(SR_Raw_CurrentC);
   1806          
   1807              SR_DATA_MCU_CHECK_LONG(SR_SquaredCurrentRmsA);
   1808              SR_DATA_MCU_CHECK_LONG(SR_SquaredCurrentRmsB);
   1809              SR_DATA_MCU_CHECK_LONG(SR_SquaredCurrentRmsC);
   1810              SR_DATA_MCU_CHECK_LONG(SR_SquaredCurrentSumA);
   1811              SR_DATA_MCU_CHECK_LONG(SR_SquaredCurrentSumB);
   1812              SR_DATA_MCU_CHECK_LONG(SR_SquaredCurrentSumC);
   1813              SR_DATA_MCU_CHECK_LONG(SR_Curr_Rms_Counter);
   1814          }
   1815          
   1816          
   1817          /**
   1818           *  @brief      It tests the integrity of each variable used in this Class B module. It performs an OR
   1819           *              operation between all used variable.
   1820           *  @return     TRUE: at least one variable is corrupted
   1821           *              FALSE: all variables are ok (not corrupted)
   1822           */
   1823          #ifdef __IAR_SYSTEMS_ICC__
   1824          #pragma inline = forced
   1825          #endif
   1826          void CheckVariables4Failure_5ms(void)
   1827          {
   1828              SR_DATA_MCU_CHECK_BYTE(SR_SafetyMngr_State);
   1829              SR_DATA_MCU_CHECK_SHORT(SR_Motor_Fault);
   1830              SR_DATA_MCU_CHECK_SHORT(SR_Motor_Fault_Holder);
   1831              SR_DATA_MCU_CHECK_SHORT(SR_Motor_Flags);
   1832              SR_DATA_MCU_CHECK_LONG(SR_SquaredCurrentRmsA);
   1833              SR_DATA_MCU_CHECK_LONG(SR_SquaredCurrentRmsB);
   1834              SR_DATA_MCU_CHECK_LONG(SR_SquaredCurrentRmsC);
   1835              SR_DATA_MCU_CHECK_LONG(SR_SquaredCurrentsSum);
   1836              SR_DATA_MCU_CHECK_SHORT(SR_CurrentA);
   1837              SR_DATA_MCU_CHECK_SHORT(SR_CurrentB);
   1838              SR_DATA_MCU_CHECK_SHORT(SR_CurrentC);
   1839              SR_DATA_MCU_CHECK_SHORT(SR_Phase_Lost_Counter);
   1840              SR_DATA_MCU_CHECK_LONG(SR_CalibrationCntr);
   1841              SR_DATA_MCU_CHECK_LONG(SR_Timeout_Failure_Retry);
   1842          
   1843          #ifdef SR_CIM_MOTOR
   1844              SR_DATA_MCU_CHECK_LONG(SR_VerifyTargetCounter);
   1845          #else
   1846              SR_DATA_MCU_CHECK_LONG(SR_ZeroSpeedDebouncer);
   1847              SR_DATA_MCU_CHECK_LONG(SR_ZeroSpeedWithCurrTimer);
   1848              SR_DATA_MCU_CHECK_LONG(SR_Check_Unlock_Door_Speed_Timer);
   1849              SR_DATA_MCU_CHECK_LONG(SR_Check_Unlock_Door_Speed_Delta_Voltage);
   1850          #endif
   1851          
   1852          }
   1853          
   1854          
   1855          
   1856          /**
   1857           *  @brief      It tests the integrity of each variable used in this Class B module. It performs an OR
   1858           *              operation between all used variable.
   1859           *  @return     TRUE: at least one variable is corrupted
   1860           *              FALSE: all variables are ok (not corrupted)
   1861           */
   1862          #ifdef __IAR_SYSTEMS_ICC__
   1863          #pragma inline = forced
   1864          #endif
   1865          void CheckVariables4Failure_25ms(void)
   1866          {
   1867              SR_DATA_MCU_CHECK_SHORT(SR_Motor_Fault);
   1868              SR_DATA_MCU_CHECK_SHORT(SR_Motor_Fault_Holder);
   1869              SR_DATA_MCU_CHECK_SHORT(SR_Motor_Flags);
   1870              SR_DATA_MCU_CHECK_SHORT(SR_Overheating_Counter);
   1871              SR_DATA_MCU_CHECK_FLOAT(SR_Overheating_Temp);
   1872              SR_DATA_MCU_CHECK_LONG(SR_SquaredCurrentRmsA);
   1873              SR_DATA_MCU_CHECK_LONG(SR_SquaredCurrentRmsB);
   1874              SR_DATA_MCU_CHECK_LONG(SR_SquaredCurrentRmsC);
   1875          }
   1876          
   1877          
   1878          
   1879          
   1880          /**
   1881           *  @brief      Calculate the difference between the instantaneous adc value with the
   1882           *              average (if applicable) and save this values in SR variables. rate: 250 us
   1883           *  @return     none
   1884           *
   1885           */
   1886          #ifdef __IAR_SYSTEMS_ICC__
   1887          #pragma inline = forced
   1888          #endif
   1889          void CalculateRawAnalogData_250us(void)
   1890          {
   1891              sint16 raw_ia;
   1892              sint16 raw_ib;
   1893              sint16 raw_ic;
   1894          
   1895              raw_ia = SR_Raw_CurrentA - SR_CurrentOffsetA;   // Subtract zero offset
   1896              SR_DATA_MCU_UPDATE_SHORT(SR_CurrentA, raw_ia);
   1897          
   1898              raw_ib = SR_Raw_CurrentB - SR_CurrentOffsetB;   // Subtract zero offset
   1899              SR_DATA_MCU_UPDATE_SHORT(SR_CurrentB, raw_ib);
   1900          
   1901              raw_ic = SR_Raw_CurrentC - SR_CurrentOffsetC;   // Subtract zero offset
   1902              SR_DATA_MCU_UPDATE_SHORT(SR_CurrentC, raw_ic);
   1903          }
   1904          
   1905          /**
   1906           *  @brief      Checks for motor currents plausibility. If one of the three currents
   1907           *              is found out of the reading range, a fault is triggered.
   1908           *  @return     none
   1909           *
   1910           */
   1911          #ifdef __IAR_SYSTEMS_ICC__
   1912          #pragma inline = forced
   1913          #endif
   1914          void CheckCurrentsPlausibility(void)
   1915          {
   1916              if(SR_SafetyMngr_State == SAFETY_MNGR_RUNNING)
   1917              {
   1918                  if((SR_Raw_CurrentA < SR_CURRENT_PLAUSIBILITY_LOW_LIM) ||
   1919                     (SR_Raw_CurrentA > SR_CURRENT_PLAUSIBILITY_HIGH_LIM))
   1920                  {
   1921                      SetFault(SR_FAULT_CURRENT_SENSOR_FAILED);
   1922                      SR_DATA_MCU_UPDATE_LONG(SR_Timeout_Failure_Retry, ELECTRONIC_FAIL_TIMEOUT); //Load time out
   1923                  }
   1924          
   1925                  if((SR_Raw_CurrentB < SR_CURRENT_PLAUSIBILITY_LOW_LIM) ||
   1926                     (SR_Raw_CurrentB > SR_CURRENT_PLAUSIBILITY_HIGH_LIM))
   1927                  {
   1928                      SetFault(SR_FAULT_CURRENT_SENSOR_FAILED);
   1929                      SR_DATA_MCU_UPDATE_LONG(SR_Timeout_Failure_Retry, ELECTRONIC_FAIL_TIMEOUT); //Load time out
   1930                  }
   1931          
   1932                  if((SR_Raw_CurrentC < SR_CURRENT_PLAUSIBILITY_LOW_LIM) ||
   1933                     (SR_Raw_CurrentC > SR_CURRENT_PLAUSIBILITY_HIGH_LIM))
   1934                  {
   1935                      SetFault(SR_FAULT_CURRENT_SENSOR_FAILED);
   1936                      SR_DATA_MCU_UPDATE_LONG(SR_Timeout_Failure_Retry, ELECTRONIC_FAIL_TIMEOUT); //Load time out
   1937                  }
   1938              }
   1939          }
   1940          
   1941          
   1942          /**
   1943           *  @brief      Calculate the rms for each phase current
   1944           *  @return     none
   1945           *
   1946           */
   1947          #ifdef __IAR_SYSTEMS_ICC__
   1948          #pragma inline = forced
   1949          #endif
   1950          void CalculateRmsAnalogData(void)
   1951          {
   1952              sint32 temp_s32_1;
   1953              sint32 temp_s32_2;
   1954              sint32 temp_s32_3;
   1955              sint32 temp_counter_s32;
   1956          
   1957              /* This block calculate the rms for each phase current*/
   1958              temp_s32_1 = (sint32)SR_CurrentA;
   1959              temp_s32_1 = SR_SquaredCurrentSumA + ((temp_s32_1 * temp_s32_1)>>7);   //desired output format 17.15, input current are 21.11 format, 21.11*21.11 = 10.22 -> 17.15 = 10.22>>7
   1960          
   1961              temp_s32_2 = (sint32)SR_CurrentB;
   1962              temp_s32_2 = SR_SquaredCurrentSumB + ((temp_s32_2 * temp_s32_2)>>7);   //desired output format 17.15, input current are 21.11 format, 21.11*21.11 = 10.22 -> 17.15 = 10.22>>7
   1963          
   1964              temp_s32_3 = (sint32)SR_CurrentC;
   1965              temp_s32_3 = SR_SquaredCurrentSumC + ((temp_s32_3 * temp_s32_3)>>7);   //desired output format 17.15, input current are 21.11 format, 21.11*21.11 = 10.22 -> 17.15 = 10.22>>7
   1966          
   1967              temp_counter_s32 = SR_Curr_Rms_Counter;
   1968              temp_counter_s32++;
   1969          
   1970              if(temp_counter_s32 > RMS_COUNTER_SAMPLES_AT_TS) // Time elapsed - RMS_SAMPLING_TIME_MS
   1971              {
   1972                  /* Average of squared current */
   1973                  temp_s32_1 = temp_s32_1 / temp_counter_s32;
   1974                  SR_DATA_MCU_UPDATE_LONG(SR_SquaredCurrentRmsA, temp_s32_1);
   1975          
   1976                  temp_s32_2 = temp_s32_2 / temp_counter_s32;
   1977                  SR_DATA_MCU_UPDATE_LONG(SR_SquaredCurrentRmsB, temp_s32_2);
   1978          
   1979                  temp_s32_3 = temp_s32_3 / temp_counter_s32;
   1980                  SR_DATA_MCU_UPDATE_LONG(SR_SquaredCurrentRmsC, temp_s32_3);
   1981          
   1982                  // Reset of the sum terms
   1983                  temp_counter_s32 = 0;
   1984                  temp_s32_1 = 0;
   1985                  temp_s32_2 = 0;
   1986                  temp_s32_3 = 0;
   1987              }
   1988          
   1989              //Update Sr Data
   1990              SR_DATA_MCU_UPDATE_LONG(SR_SquaredCurrentSumA, temp_s32_1);
   1991              SR_DATA_MCU_UPDATE_LONG(SR_SquaredCurrentSumB, temp_s32_2);
   1992              SR_DATA_MCU_UPDATE_LONG(SR_SquaredCurrentSumC, temp_s32_3);
   1993              SR_DATA_MCU_UPDATE_LONG(SR_Curr_Rms_Counter, temp_counter_s32);
   1994          
   1995          }
   1996          
   1997          
   1998          
   1999          //---------------------------------------------------------------------------------------------------------------------
   2000          /**
   2001           *  @brief      Handler of the over current detection (locked rotor and over load).
   2002           *              It uses one single counter for two different periods. The time is counted when some shaft movement
   2003           *              is detected. The sum of the squared current is used in order to compare to a threshold. A debouncer is
   2004           *              implemented in order filter out some noise due to some current threshold crossings. This
   2005           *              current threshold is a sum of the squared value of the currents, it also considers the worst case
   2006           *              for noise in the current sensors. This debouncer implements a counting up and down
   2007           *              according to the comparison to this zero speed current threshold; the debounce is not zeroed after
   2008           *              crossing down the threshold because the "history" of some previous values shall be considered in the
   2009           *              future decisions. There is also a said starting time, which it is used todetect either a locked rotor
   2010           *              or overload. No speed information is used in this method, only sensed current.
   2011           *
   2012           *  @param      none
   2013           *  @return     none.
   2014           */
   2015          #ifdef __IAR_SYSTEMS_ICC__
   2016          #pragma inline = forced
   2017          #endif
   2018          void PhaseLostHandler(void)
   2019          {
   2020              uint32 tmp32;
   2021              uint16 temp;
   2022          
   2023          
   2024              //** phase lost management
   2025              if(SR_SquaredCurrentRmsB < CURRENT_LOW_THLD_A)
   2026              {
   2027                  if( (SR_SquaredCurrentRmsC > CURRENT_HIGH_THLD_A) &&
   2028                  (SR_SquaredCurrentRmsA > CURRENT_HIGH_THLD_A))// &&
   2029                      //(MATHCALC__ABS( SR_SquaredCurrentRmsA - SR_SquaredCurrentRmsC ) )< CURRENT_NOISE)
   2030                  {
   2031                      tmp32 = (uint32)SR_Motor_Flags;
   2032                      BIT_SET(tmp32, SR_FLAG_DETECTION_PHASE_LOST);
   2033                      SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,tmp32);
   2034                  }
   2035              }
   2036              else if(SR_SquaredCurrentRmsC < CURRENT_LOW_THLD_A)
   2037              {
   2038                  if( (SR_SquaredCurrentRmsB > CURRENT_HIGH_THLD_A) &&
   2039                      (SR_SquaredCurrentRmsA > CURRENT_HIGH_THLD_A) )//&&
   2040                      //(MATHCALC__ABS( SR_SquaredCurrentRmsA - SR_SquaredCurrentRmsB ) )< CURRENT_NOISE)
   2041                  {
   2042                      tmp32 = (uint32)SR_Motor_Flags;
   2043                      BIT_SET(tmp32, SR_FLAG_DETECTION_PHASE_LOST);
   2044                      SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,tmp32);
   2045                  }
   2046              }
   2047              else if(SR_SquaredCurrentRmsA < CURRENT_LOW_THLD_A)
   2048              {
   2049                  if( (SR_SquaredCurrentRmsC > CURRENT_HIGH_THLD_A) &&
   2050                      (SR_SquaredCurrentRmsB > CURRENT_HIGH_THLD_A) )//&&
   2051                      //(MATHCALC__ABS( SR_SquaredCurrentRmsB - SR_SquaredCurrentRmsC ) )< CURRENT_NOISE)
   2052                  {
   2053                      tmp32 = (uint32)SR_Motor_Flags;
   2054                      BIT_SET(tmp32, SR_FLAG_DETECTION_PHASE_LOST);
   2055                      SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,tmp32);
   2056                  }
   2057              }
   2058              else
   2059              {
   2060                  tmp32 = (uint32)SR_Motor_Flags;
   2061                  BIT_CLR(tmp32, SR_FLAG_DETECTION_PHASE_LOST);
   2062                  SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,tmp32);
   2063              }
   2064          
   2065              temp = SR_Motor_Flags;
   2066              temp = BIT_TEST(temp, SR_FLAG_DETECTION_PHASE_LOST);
   2067          
   2068              if(temp)
   2069              {
   2070                  SR_Phase_Lost_Counter++;
   2071                  if(SR_Phase_Lost_Counter > PHASE_LOST_COUNTER_THLD)
   2072                  {
   2073                      SR_Phase_Lost_Counter = PHASE_LOST_COUNTER_THLD;
   2074          
   2075                      SetFault(SR_FAULT_PHASE_LOST);
   2076          
   2077                      SR_DATA_MCU_UPDATE_LONG(SR_Timeout_Failure_Retry,PHASE_LOST_TIMEOUT); //Load time out
   2078                  }
   2079              }
   2080              else
   2081              {
   2082                  if(SR_Phase_Lost_Counter>0)
   2083                  {
   2084                      SR_Phase_Lost_Counter--;
   2085                  }
   2086              }
   2087          
   2088              SR_DATA_MCU_UPDATE_SHORT(SR_Phase_Lost_Counter,SR_Phase_Lost_Counter);
   2089          
   2090          }
   2091          
   2092          
   2093          /**
   2094           *  @brief      Simplified RC motor thermal model.
   2095           *
   2096           *  @return     none
   2097           */

   \                                 In section .text, align 4, keep-with-next
   2098          void RcThermalUpdate(void)
   2099          {
   \                     ??RcThermalUpdate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2100              float gt;                                       //overall conductance from motor to environment
   2101              float psteel;                                   //steel heat loss dissipation in the motor
   2102              float qjoule;                                   //Winding joule loss dissipation in the motor
   2103              float qdiss;                                    //overall heat dissipation in the motor (qjoule+qsteel)
   2104              float qnet;                                     //net heat accumulated in the motor Capacitance (qdiss-gt(twind-tamb))
   2105              float dTdt;                                     //time derivative of the temperature
   2106              float temp_delta;                               //difference between motor temperature and enviroment temperature
   2107              float squared_current_f;                        //motor squared current in floating point
   2108              float squared_current_pu;                       //motor squared current in fixed point
   2109              float motor_speed_f;                            //motor speed in floating point
   2110          
   2111          
   2112              // delta temperature calculation
   2113              temp_delta = SR_Overheating_Temp - SR_MotorSafety_Params->Rc_Thermal.Tamb;
   \   00000002   0x....             LDR.N    R4,??DataTable192_4
   \   00000004   0xED2D 0x8B04      VPUSH    {D8-D9}
   \   00000008   0xF8D4 0x04F0      LDR      R0,[R4, #+1264]
   \   0000000C   0xF9B0 0x0008      LDRSH    R0,[R0, #+8]
   \   00000010   0xEE00 0x0A10      VMOV     S0,R0
   \   00000014   0xF8D4 0x0530      LDR      R0,[R4, #+1328]
   \   00000018   0xEE00 0x0A90      VMOV     S1,R0
   \   0000001C   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   2114          
   2115          
   2116              // Calculation of Motor Thermal Model Input -> Motor current RMS (Ia^2 + Ib^2 + Ic^2)
   2117              squared_current_pu = SR_SquaredCurrentRmsA;
   \   00000020   0xF8D4 0x0510      LDR      R0,[R4, #+1296]
   \   00000024   0xEE70 0x8AC0      VSUB.F32 S17,S1,S0
   \   00000028   0xEE00 0x0A10      VMOV     S0,R0
   2118              squared_current_pu += SR_SquaredCurrentRmsB;
   \   0000002C   0xF8D4 0x0514      LDR      R0,[R4, #+1300]
   \   00000030   0xEE00 0x0A90      VMOV     S1,R0
   2119              squared_current_pu += SR_SquaredCurrentRmsC;
   2120          
   2121              // motor square current format transformation: from fixed point to floating
   2122              squared_current_f = SRMC__IQ2REALF(squared_current_pu, BASE_CURRENT*BASE_CURRENT*ONE_THIRD, 15);
   \   00000034   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000038   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   0000003C   0xF8D4 0x0518      LDR      R0,[R4, #+1304]
   \   00000040   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   00000044   0xEE00 0x0A90      VMOV     S1,R0
   \   00000048   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   0000004C   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   00000050   0xEDDF 0x....      VLDR.W   S1,??DataTable192  ;; 0x41b42eb3
   \   00000054   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000058   0xEDDF 0x....      VLDR.W   S1,??DataTable192_1  ;; 0x38000000
   \   0000005C   0xEE20 0x8A20      VMUL.F32 S16,S0,S1
   2123          
   2124          #ifdef SR_BPM_MOTOR
   2125          
   2126              // Check variable integrity
   2127              SR_DATA_MCU_CHECK_BYTE(SR_Avg_Fund_Period_Cycle_Total);
   \   00000060   0xF204 0x3177      ADDW     R1,R4,#+887
   \   00000064   0xF504 0x705D      ADD      R0,R4,#+884
   \   00000068   0x.... 0x....      BL       SRData__CheckByte
   2128              SR_DATA_MCU_CHECK_LONG(SR_Avg_Fund_Period);
   \   0000006C   0xF204 0x517C      ADDW     R1,R4,#+1404
   \   00000070   0xF504 0x60AB      ADD      R0,R4,#+1368
   \   00000074   0x.... 0x....      BL       SRData__CheckLong
   2129          
   2130              // motor speed format transformation: from fixed point to floating
   2131              motor_speed_f = (RMS_SAMPLER_FREQUENCY * SR_Avg_Fund_Period_Cycle_Total)/(1.0f + SR_Avg_Fund_Period);  // +1 to prevent zero division
   \   00000078   0xF894 0x0374      LDRB     R0,[R4, #+884]
   \   0000007C   0xEE00 0x0A10      VMOV     S0,R0
   \   00000080   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000084   0xEDDF 0x....      VLDR.W   S1,??DataTable192_2  ;; 0x457a0000
   \   00000088   0xF8D4 0x0558      LDR      R0,[R4, #+1368]
   \   0000008C   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000090   0xEE00 0x0A90      VMOV     S1,R0
   \   00000094   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \   00000098   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   2132          
   2133          #else //SR_CIM_MOTOR
   2134          
   2135              motor_speed_f = 0.0f;
   2136          
   2137          #endif
   2138          
   2139              ///////////////////////Losses being generated in the Motor - Steel + Joulse Losses/////////////////
   2140              //Steel Losses
   2141              psteel = SR_MotorSafety_Params->Rc_Thermal.A1 * motor_speed_f + SR_MotorSafety_Params->Rc_Thermal.A2 * (motor_speed_f*motor_speed_f);
   \   0000009C   0xF8D4 0x04F0      LDR      R0,[R4, #+1264]
   2142          
   2143              //Joule losses    - considering variation of resitance with temperature
   2144              qjoule=3*SR_MotorSafety_Params->Rc_Thermal.Rwind*(1.0f+SR_MotorSafety_Params->Rc_Thermal.Alfa_Winding*(temp_delta))*squared_current_f;
   2145          
   2146              /////////////////////////////heat being dissipated by the motor to the air///////////////////////////////
   2147              //Overall thermal conductance from motor mass to the environment
   2148              if (motor_speed_f > SR_MotorSafety_Params->Rc_Thermal.SSpeed)
   \   000000A0   0xF9B0 0x100A      LDRSH    R1,[R0, #+10]
   \   000000A4   0xEE70 0x0A81      VADD.F32 S1,S1,S2
   \   000000A8   0xEE80 0x9A20      VDIV.F32 S18,S0,S1
   \   000000AC   0xED90 0x0A05      VLDR     S0,[R0, #+20]
   \   000000B0   0xED90 0x1A06      VLDR     S2,[R0, #+24]
   \   000000B4   0xEE20 0x0A09      VMUL.F32 S0,S0,S18
   \   000000B8   0xEE69 0x0A09      VMUL.F32 S1,S18,S18
   \   000000BC   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   \   000000C0   0xEDD0 0x0A07      VLDR     S1,[R0, #+28]
   \   000000C4   0xEEB0 0x1A08      VMOV.F32 S2,#3.0
   \   000000C8   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   000000CC   0xED90 0x1A08      VLDR     S2,[R0, #+32]
   \   000000D0   0xEEF7 0x1A00      VMOV.F32 S3,#1.0
   \   000000D4   0xEE41 0x1A28      VMLA.F32 S3,S2,S17
   \   000000D8   0xEE01 0x1A10      VMOV     S2,R1
   \   000000DC   0xEEB8 0x1AC1      VCVT.F32.S32 S2,S2
   \   000000E0   0xEE60 0x0AA1      VMUL.F32 S1,S1,S3
   \   000000E4   0xEEB4 0x1A49      VCMP.F32 S2,S18
   \   000000E8   0xEE60 0x0A88      VMUL.F32 S1,S1,S16
   \   000000EC   0xEEF1 0xFA10      FMSTAT   
   \   000000F0   0xBF4F             ITEEE    MI 
   2149              {
   2150                  gt = SR_MotorSafety_Params->Rc_Thermal.Gspin; //Spinning  SSpeed is the threshold to switch
   \   000000F2   0xED90 0x1A0B      VLDRMI   S2,[R0, #+44]
   2151              }
   2152              else
   2153              {
   2154                  gt = SR_MotorSafety_Params->Rc_Thermal.Gtumb1*(temp_delta) + SR_MotorSafety_Params->Rc_Thermal.Gtumb;  //Tumble
   \   000000F6   0xEDD0 0x1A0A      VLDRPL   S3,[R0, #+40]
   \   000000FA   0xED90 0x1A09      VLDRPL   S2,[R0, #+36]
   \   000000FE   0xEE01 0x1AA8      VMLAPL.F32 S2,S3,S17
   2155              }
   2156          
   2157          
   2158              //Dissipated Heat
   2159              qdiss =  gt*(temp_delta);
   2160          
   2161              //Net heat stored inside the motor - that generated the temperature variation
   2162              qnet =  qjoule + psteel - qdiss;
   2163          
   2164              //Temperature derivative with time
   2165              dTdt= qnet*SR_MotorSafety_Params->Rc_Thermal.Cmot_Inv;
   2166          
   2167              //Update motor temperature
   2168              SR_Overheating_Temp = SR_Overheating_Temp + dTdt*(SR_MotorSafety_Params->Rc_Thermal.Dt);
   \   00000102   0xEE30 0x0A80      VADD.F32 S0,S1,S0
   \   00000106   0xEE01 0x0A68      VMLS.F32 S0,S2,S17
   \   0000010A   0xEDD0 0x0A03      VLDR     S1,[R0, #+12]
   \   0000010E   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000112   0xEDD0 0x0A04      VLDR     S1,[R0, #+16]
   \   00000116   0xF8D4 0x0530      LDR      R0,[R4, #+1328]
   \   0000011A   0xEE01 0x0A10      VMOV     S2,R0
   \   0000011E   0xF204 0x5030      ADDW     R0,R4,#+1328
   \   00000122   0xEE00 0x1A20      VMLA.F32 S2,S0,S1
   \   00000126   0xED80 0x1A00      VSTR     S2,[R0, #0]
   2169          
   2170              // Check and update variables to communicate to other modules.
   2171              SR_DATA_MCU_CHECK_FLOAT(SR_Squared_Current);
   \   0000012A   0xF504 0x61FF      ADD      R1,R4,#+2040
   \   0000012E   0xF504 0x60A7      ADD      R0,R4,#+1336
   \   00000132   0x.... 0x....      BL       SRData__CheckFloat
   2172              SR_DATA_MCU_CHECK_FLOAT(SR_Voltage_Frequency);
   \   00000136   0xF204 0x71FC      ADDW     R1,R4,#+2044
   \   0000013A   0xF204 0x5034      ADDW     R0,R4,#+1332
   \   0000013E   0x.... 0x....      BL       SRData__CheckFloat
   2173          
   2174              SR_DATA_MCU_UPDATE_FLOAT(SR_Squared_Current, squared_current_f);
   \   00000142   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000146   0xF504 0x61FF      ADD      R1,R4,#+2040
   \   0000014A   0xF504 0x60A7      ADD      R0,R4,#+1336
   \   0000014E   0x.... 0x....      BL       SRData__UpdateFloat
   2175              SR_DATA_MCU_UPDATE_FLOAT(SR_Voltage_Frequency, motor_speed_f);
   \   00000152   0xEEB0 0x0A49      VMOV.F32 S0,S18
   \   00000156   0xF204 0x71FC      ADDW     R1,R4,#+2044
   \   0000015A   0xF204 0x5034      ADDW     R0,R4,#+1332
   \   0000015E   0xECBD 0x8B04      VPOP     {D8-D9}
   \   00000162   0xE8BD 0x4010      POP      {R4,LR}
   \   00000166   0x.... 0x....      B.W      SRData__UpdateFloat
   2176          }
   2177          
   2178          
   2179          
   2180          
   2181          /**
   2182           *  @brief      Motor overheating Protection based on a simplified motor thermal model.
   2183           *
   2184           *  @return     none
   2185           */
   2186          #ifdef __IAR_SYSTEMS_ICC__
   2187          #pragma inline = forced
   2188          #endif
   2189          void InitOverHeatingProtection(void)
   2190          {
   2191              SR_DATA_MCU_UPDATE_SHORT(SR_Overheating_Counter,0);             // Reset the overheating counter
   2192              SR_DATA_MCU_UPDATE_FLOAT(SR_Overheating_Temp,(float)SR_MotorSafety_Params->OverHeating_Temp_Init); // Init the overheating temperature
   2193          
   2194              SR_DATA_MCU_UPDATE_FLOAT(SR_Squared_Current, 0.0f);
   2195              SR_DATA_MCU_UPDATE_FLOAT(SR_Voltage_Frequency, 0.0f);
   2196          }
   2197          
   2198          
   2199          
   2200          
   2201          /**
   2202           *  @brief      Motor overheating Protection based on a simplified motor thermal model.
   2203           *
   2204           *  @return     none
   2205           */
   2206          #ifdef __IAR_SYSTEMS_ICC__
   2207          #pragma inline = forced
   2208          #endif
   2209          void OverHeatingProtection(void)
   2210          {
   2211              sint16 temp;
   2212              uint16 temp1;
   2213          
   2214              SR_Overheating_Counter++;
   2215          
   2216              if(SR_Overheating_Counter >= ONE_SEC_TICK)
   2217              {
   2218                  RcThermalUpdate();
   2219          
   2220                  SR_Overheating_Counter = 0;
   2221              }
   2222          
   2223              temp = (sint16)SR_Overheating_Temp;             // Conversion from float to int
   2224          
   2225              temp1 = SR_Motor_Fault;
   2226              temp1 = BIT_TEST(temp1, SR_FAULT_OVER_HEATING);
   2227              if(temp1) // If overheating condition detected
   2228              {
   2229                  if(temp < SR_MotorSafety_Params->OverHeating_Temp_Low)
   2230                  {
   2231                      // Motor temperature is lower than the lower threshold  -> Clear the overheating fault
   2232                      ClearFault(SR_FAULT_OVER_HEATING);
   2233                  }
   2234              }
   2235              else
   2236              {
   2237                  if(temp > SR_MotorSafety_Params->OverHeating_Temp_High)
   2238                  {
   2239                      // Motor temperature is higher than the maximum allowed  -> Set the overheating fault
   2240                      SetFault(SR_FAULT_OVER_HEATING);
   2241                  }
   2242              }
   2243          
   2244          
   2245              SR_DATA_MCU_UPDATE_SHORT(SR_Overheating_Counter,SR_Overheating_Counter);
   2246              SR_DATA_MCU_UPDATE_FLOAT(SR_Overheating_Temp,SR_Overheating_Temp);
   2247          }
   2248          
   2249          
   2250          
   2251          
   2252          /**
   2253           *  @brief      Performs the diagnostic of motor control peripherals (Atod and Pwm)
   2254           *  @return     none
   2255           *
   2256           */
   2257          #ifdef __IAR_SYSTEMS_ICC__
   2258          #pragma inline = forced
   2259          #endif
   2260          void PeripheralDiagnostic(void)
   2261          {
   2262              uint32 temp;
   2263              uint16 temp_flags;
   2264          
   2265              if(SR_SafetyMngr_State == SAFETY_MNGR_PRERUN_TESTS)
   2266              {
   2267                  // Perform the Shut Down pin plausibility check
   2268                  SRMCPwm__DiagnosticHandler();
   2269          
   2270                  // Perfom the ADCs plausibility check
   2271                  SRMCAtod__DiagnosticHandler();
   2272          
   2273                  // Read flag and fault to temp variables.
   2274                  temp_flags = SR_Motor_Flags;
   2275          
   2276                  // Handle the feedbacks
   2277          
   2278                  // AtoD module
   2279                  temp = SRMCAtod__GetDiagnosticFeedback();
   2280                  if (temp == SR_MCATOD_ERROR_PERIPHERAL_SAFE)
   2281                  {
   2282                      BIT_SET(temp_flags, SR_FLAG_ADC_PLAUSIB_CHECK_OK);
   2283                  }
   2284                  else if(temp == SR_MCATOD_ERROR_PERIPHERAL_NOT_SAFE)
   2285                  {
   2286                      SetFault(SR_FAULT_CURRENT_SENSOR_FAILED);
   2287          
   2288                      SR_DATA_MCU_UPDATE_LONG(SR_Timeout_Failure_Retry,ELECTRONIC_FAIL_TIMEOUT); //Load time out
   2289                  }
   2290          
   2291                  // PWM module
   2292                  temp = SRMCPwm__GetDiagnosticFeedback();
   2293                  if (temp == SR_MCPWM_ERROR_PERIPHERAL_SAFE)
   2294                  {
   2295                      BIT_SET(temp_flags, SR_FLAG_SHUTDOWN_PLAUSIB_CHECK_OK);
   2296                  }
   2297                  else if (temp == SR_MCPWM_ERROR_PERIPHERAL_NOT_SAFE)
   2298                  {
   2299                      SetFault(SR_FAULT_SHUTDOWN_HARDWARE_FAILED);
   2300          
   2301                      SR_DATA_MCU_UPDATE_LONG(SR_Timeout_Failure_Retry,ELECTRONIC_FAIL_TIMEOUT); //Load time out
   2302                  }
   2303          
   2304                  // If there is nothing wrong in the plausibility chech of the sensors...
   2305                  if( (BIT_TEST(temp_flags, SR_FLAG_ADC_PLAUSIB_CHECK_OK) != 0)       &&
   2306                      (BIT_TEST(temp_flags, SR_FLAG_SHUTDOWN_PLAUSIB_CHECK_OK) != 0)  )
   2307                  {
   2308          
   2309                      // Check if the signals from the hardware are within the
   2310                      // acceptable levels.
   2311                      temp = MotorAnalogCircuitCheck();
   2312          
   2313                      if (temp == MOTOR_ANALOG_CHECK_CURR_FAIL)
   2314                      {
   2315                          SetFault(SR_FAULT_CURRENT_SENSOR_FAILED);
   2316          
   2317                          SR_DATA_MCU_UPDATE_LONG(SR_Timeout_Failure_Retry,ELECTRONIC_FAIL_TIMEOUT); //Load time out
   2318                      }
   2319                      else if (temp == MOTOR_ANALOG_CHECK_VBUS_FAIL)
   2320                      {
   2321                          SetFault(SR_FAULT_VOLTAGE_SENSOR_FAILED);
   2322          
   2323                          SR_DATA_MCU_UPDATE_LONG(SR_Timeout_Failure_Retry,ELECTRONIC_FAIL_TIMEOUT); //Load time out
   2324                      }
   2325                      else // no hardware circuit error was found so far.
   2326                      {
   2327                          BIT_SET(temp_flags, SR_FLAG_PRERUN_TESTS_FINISHED);     // Warn the initial tests were performed
   2328                      }
   2329          
   2330                      // Reset plausibility checks status - RICUPL
   2331                      BIT_CLR(temp_flags, SR_FLAG_ADC_PLAUSIB_CHECK_OK);
   2332                      BIT_CLR(temp_flags, SR_FLAG_SHUTDOWN_PLAUSIB_CHECK_OK);
   2333                  }
   2334          
   2335                  SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags, temp_flags);
   2336              }
   2337              else if (SR_SafetyMngr_State == SAFETY_MNGR_POSTRUN_TESTS)
   2338              {
   2339                  // Perform the Shut Down pin plausibility check
   2340                  SRMCPwm__DiagnosticHandler();
   2341              }
   2342          
   2343          }
   2344          
   2345          
   2346          
   2347          /**
   2348           *  @brief      Manage the  Class A Pwm Access
   2349           *  @return     none
   2350           *
   2351           */
   2352          #ifdef __IAR_SYSTEMS_ICC__
   2353          #pragma inline = forced
   2354          #endif
   2355          void ClassAPwmAccess(void)
   2356          {
   2357              // Class A Pwm Access management
   2358              if (SR_SafetyMngr_State == SAFETY_MNGR_RUNNING)
   2359              {
   2360                  if(SR_Motor_Fault == 0 && (BIT_TEST(SR_Motor_Flags, SR_FLAG_REQUESTED_TO_STOP) == 0))
   2361                  {// No safety fault and request to stop are detected
   2362          
   2363                      // Allow the pwm access by Class A software,
   2364                      // the Class A shall start accessing the pwm driver from this moment...
   2365                      BIT_SET(SR_Motor_Flags, SR_FLAG_CLASS_A_PWM_ACCESS);
   2366                      SR_MCU_MOTOR_UPDATE_N_VAR(SR_Motor_Flags);
   2367          
   2368                  }
   2369                  else
   2370                  {
   2371                      // Class A software is not allowed to access the peripheral
   2372                      BIT_CLR(SR_Motor_Flags, SR_FLAG_CLASS_A_PWM_ACCESS);
   2373                      SR_MCU_MOTOR_UPDATE_N_VAR(SR_Motor_Flags);
   2374          
   2375                      // The state machine is still in running and a fault is detected,
   2376                      // apply the pwm error reaction before the 5 ms handler action
   2377                      SR_MOTORSAFETY_MGR_ERROR_REACTION();
   2378                  }
   2379          
   2380              }
   2381              else
   2382              {
   2383                  // Class A software is not allowed to access the peripheral
   2384                  BIT_CLR(SR_Motor_Flags, SR_FLAG_CLASS_A_PWM_ACCESS);
   2385                  SR_MCU_MOTOR_UPDATE_N_VAR(SR_Motor_Flags);
   2386              }
   2387          }
   2388          
   2389          
   2390          /**
   2391           *  @brief      Test if the power up condition for the MCU have already reached.
   2392           *              If the sum of the square of each current is smaller than the following
   2393           *              threshold, then the powering up is done in the current sensoring point
   2394           *              of view. The trick is: when the micro is powering up, the current offset
   2395           *              will take long time to stabilize, due to a low pass filter with a very
   2396           *              low cut off frequency. As for starting, then a current will be reading
   2397           *              (there is no current flowing the shunt resistors), so, when the offset
   2398           *              filter is stabilized, then the read current (i1, i2, i3) will be very
   2399           *              close to zero. It is not zero, since there is some noise in those sensors.
   2400           *  @return     TRUE: power up is already finished
   2401           *              FALSE: power up it not completed yet.
   2402           *
   2403           */
   2404          #ifdef __IAR_SYSTEMS_ICC__
   2405          #pragma inline = forced
   2406          #endif
   2407          void PowerUpSensors(void)
   2408          {
   2409              sint16 temp;
   2410              uint32 temp1;
   2411              uint32 temp2;
   2412          
   2413              SR_DATA_MCU_CHECK_SHORT(SR_PowerUpTimer);
   2414          
   2415              // Just count up a dummy timer, only used
   2416              // to prevent any hardware noise from the hardware power-up
   2417              temp = SR_PowerUpTimer;
   2418              if(temp < SR_POWER_UP_DELAY_TIMER)
   2419              {
   2420                  temp++;
   2421                  SR_DATA_MCU_UPDATE_SHORT(SR_PowerUpTimer,temp);
   2422              }
   2423              else
   2424              {
   2425                  // If the sum of the square current has converged to zero
   2426                  // then declare the power up is finished.
   2427                  temp1 = SR_SquaredCurrentsSum;
   2428                  temp2 = SR_CalibrationCntr;
   2429                  if(temp1 < SR_POWERING_UP_CURRENTS_THRESHOLD)
   2430                  {
   2431                      temp2++;
   2432                      SR_DATA_MCU_UPDATE_LONG(SR_CalibrationCntr,temp2);
   2433                      if (temp2 > SR_CALIBRATION_CNTR_THRESHOLD)
   2434                      {
   2435                          SR_DATA_MCU_UPDATE_LONG(SR_CalibrationCntr,0);
   2436                          // The currents readings are stabilized, so, transitory is finished!
   2437                          temp = (uint16)SR_Motor_Flags;
   2438                          BIT_CLR(temp, SR_FLAG_MICRO_POWERING_UP);
   2439                          SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,(uint16)temp);
   2440                      }
   2441                  }
   2442              }
   2443          
   2444          }
   2445          
   2446          
   2447          
   2448          /**
   2449           *  @brief      Calculate the average of the sensors offsets
   2450           *  @return     none
   2451           */
   2452          #ifdef __IAR_SYSTEMS_ICC__
   2453          #pragma inline = forced
   2454          #endif
   2455          void AverageSensorsOffset(void)
   2456          {
   2457              sint32 tempS32_1;
   2458              sint32 tempS32_2;
   2459          
   2460          
   2461              CheckAnalogVariables4Failure();
   2462              SR_DATA_MCU_CHECK_LONG(SR_CurrentOffsetHistA);
   2463              SR_DATA_MCU_CHECK_LONG(SR_CurrentOffsetHistB);
   2464              SR_DATA_MCU_CHECK_LONG(SR_CurrentOffsetHistC);
   2465          
   2466          
   2467              //////////////////////////////////////////////////////////////////////////////////////////////////////
   2468              tempS32_1 = SR_CurrentOffsetHistA;
   2469          
   2470              //tempS32_2 = SRMCATOD__GETADC1();                  // Read the converted values...
   2471              tempS32_2 = SR_CurrentA + SR_CurrentOffsetA;
   2472          
   2473              tempS32_2 -= (tempS32_1 >> 16);                 // Subtract zero offset
   2474              // this make 400ms time constant for 16kHz sampling frequency, i.e. reach final value in 6 x 400ms
   2475              tempS32_1 += tempS32_2 * AVERAGE_CURR_SENSOR_OFFSET_LPF_FACTOR;
   2476          
   2477              SR_DATA_MCU_UPDATE_LONG(SR_CurrentOffsetHistA,tempS32_1);
   2478              tempS32_1 = tempS32_1 >> 16;
   2479              SR_DATA_MCU_UPDATE_SHORT(SR_CurrentOffsetA,(sint16)tempS32_1);
   2480          
   2481          
   2482              //////////////////////////////////////////////////////////////////////////////////////////////////////
   2483              tempS32_1 = SR_CurrentOffsetHistB;
   2484          
   2485              //tempS32_2 = SRMCATOD__GETADC2();                  // Read the converted values...
   2486              tempS32_2 = SR_CurrentB + SR_CurrentOffsetB;
   2487          
   2488              tempS32_2 -= (tempS32_1 >> 16);                 // Subtract zero offset
   2489              // this make 400ms time constant for 16kHz sampling frequency, i.e. reach final value in 6 x 400ms
   2490              tempS32_1 += tempS32_2 * AVERAGE_CURR_SENSOR_OFFSET_LPF_FACTOR; 
   2491              
   2492              SR_DATA_MCU_UPDATE_LONG(SR_CurrentOffsetHistB,tempS32_1);
   2493              tempS32_1 = tempS32_1 >> 16;
   2494              SR_DATA_MCU_UPDATE_SHORT(SR_CurrentOffsetB,(sint16)tempS32_1);
   2495          
   2496          
   2497              //////////////////////////////////////////////////////////////////////////////////////////////////////
   2498              tempS32_1 = SR_CurrentOffsetHistC;
   2499          
   2500              //tempS32_2 = SRMCATOD__GETADC3();                  // Read the converted values...
   2501              tempS32_2 = SR_CurrentC + SR_CurrentOffsetC;
   2502          
   2503              tempS32_2 -= (tempS32_1 >> 16);                 // Subtract zero offset
   2504              // this make 400ms time constant for 16kHz sampling frequency, i.e. reach final value in 6 x 400ms
   2505              tempS32_1 += tempS32_2 * AVERAGE_CURR_SENSOR_OFFSET_LPF_FACTOR;
   2506              
   2507              SR_DATA_MCU_UPDATE_LONG(SR_CurrentOffsetHistC,tempS32_1);
   2508              tempS32_1 = tempS32_1 >> 16;
   2509              SR_DATA_MCU_UPDATE_SHORT(SR_CurrentOffsetC,(sint16)tempS32_1);
   2510          }
   2511          
   2512          
   2513          
   2514          
   2515          /**
   2516           *  @brief      Get the feed about the shut down pin and feeds back
   2517           *              in the case of a failure.
   2518           *  @return     TRUE: fault found; FALSE: nothing wrong
   2519           */
   2520          #ifdef __IAR_SYSTEMS_ICC__
   2521          #pragma inline = forced
   2522          #endif
   2523          uint8 CheckHwFaultStatus(void)
   2524          {
   2525              uint8 temp = FALSE;                     // Return variable
   2526              uint8 temp1;                            // temporary variable for SD pin feedback
   2527          
   2528              temp1 = SRMCPwm__GetHwFaultStatus();            // Gets SD pin status
   2529              if(temp1 == TRUE)                               // In case HW fault detected
   2530              {
   2531                  SetFault(SR_FAULT_OVER_CURRENT_TRIPPED);
   2532          
   2533                  temp = TRUE;                                // Updates flags in classB and returns failure detected
   2534              }
   2535              return(temp);                                   // Returns check response
   2536          }
   2537          
   2538          
   2539          
   2540          
   2541          /**
   2542           *  @brief      Calculate the average of the sensors offsets
   2543           *  @return     none
   2544           */
   2545          #ifdef __IAR_SYSTEMS_ICC__
   2546          #pragma inline = forced
   2547          #endif
   2548          MOTOR_ANALOG_CHECK_TYPE MotorAnalogCircuitCheck(void)
   2549          {
   2550              MOTOR_ANALOG_CHECK_TYPE response;

   \                                 In section .bss, align 2
   \   00000000                      DS8 2
   2551              static sint16 delta_curr_a;

   \                                 In section .bss, align 2
   \   00000000                      DS8 2
   2552              static sint16 delta_curr_b;

   \                                 In section .bss, align 2
   \   00000000                      DS8 2
   2553              static sint16 delta_curr_c;

   \                                 In section .bss, align 2
   \   00000000                      DS8 2
   2554              static sint16 vbus;
   2555          
   2556              //Check of offset for current of phase A
   2557              delta_curr_a = SR_CurrentOffsetA - CURR_OFFSET_REF;
   2558              if(delta_curr_a<0)
   2559              {
   2560                  delta_curr_a = -delta_curr_a;
   2561              }
   2562          
   2563              //Check of offset for current of phase B
   2564              delta_curr_b = SR_CurrentOffsetB - CURR_OFFSET_REF;
   2565              if(delta_curr_b<0)
   2566              {
   2567                  delta_curr_b = -delta_curr_b;
   2568              }
   2569          
   2570              //Check of offset for current of phase C
   2571              delta_curr_c = SR_CurrentOffsetC - CURR_OFFSET_REF;
   2572              if(delta_curr_c<0)
   2573              {
   2574                  delta_curr_c = -delta_curr_c;
   2575              }
   2576          
   2577              //Check for consistency of vbus reading
   2578              vbus = SR_DCBus;
   2579          
   2580              if( (delta_curr_a > CURR_OFFSET_THD) ||
   2581                  (delta_curr_b > CURR_OFFSET_THD) ||
   2582                  (delta_curr_c > CURR_OFFSET_THD))
   2583              {
   2584                  response = MOTOR_ANALOG_CHECK_CURR_FAIL;
   2585              }
   2586              else if( (vbus > VBUS_SR_HIGH_LIM) ||
   2587                       (vbus < VBUS_SR_LOW_LIM)  )
   2588              {
   2589                  response = MOTOR_ANALOG_CHECK_VBUS_FAIL;
   2590              }
   2591              else
   2592              {
   2593                  response = MOTOR_ANALOG_CHECK_CORRECT;
   2594              }
   2595          
   2596              return(response);
   2597          }
   2598          
   2599          
   2600          
   2601          
   2602          /**
   2603           *  @brief      Evaluate if the voltage is within allowed range
   2604           *  @return     none
   2605           */
   2606          void OverVoltageCheck(void)
   2607          {
   2608              sint16 vbus;
   2609              uint16 temp;
   2610          
   2611              temp = (uint16)SR_SafetyMngr_State;
   2612              if(temp != SAFETY_MNGR_PRERUN_TESTS) //DC-Bus adc value is not reliable during adc diagnostic execution
   2613              {
   2614                  //Check for consistency of vbus reading
   2615                  SR_DATA_MCU_CHECK_SHORT(SR_DCBus);
   2616                  vbus = SR_DCBus;
   2617          
   2618                  // Powering up stage is completed -> adc signals are reliable
   2619                  if( (vbus > VBUS_SR_HIGH_THR_AD_COUNTS) ||
   2620                      (vbus < VBUS_SR_LOW_THR_AD_COUNTS)  )
   2621                  {
   2622                      SetFault(SR_FAULT_DC_VOLTAGE_OUT_OF_RANGE);
   2623          
   2624                      // Apply default reaction and let the protection do its work on next call of "OverVoltageProtection()"
   2625                      SR_MOTORSAFETY_MGR_ERROR_REACTION();
   2626          
   2627                      SR_DATA_MCU_UPDATE_LONG(SR_Timeout_Failure_Retry,VOLTAGE_ERROR_TIMEOUT); //Load time out
   2628                  }
   2629              }
   2630          }
   2631          
   2632          
   2633          
   2634          
   2635          /**
   2636           *  @brief      In the case the dc bus voltage is outside safe levels, take some
   2637           *              action to keep the voltage within safe level.
   2638           *  @oaram      none
   2639           *  @return     none
   2640           */
   2641          void OverVoltageProtection(void)
   2642          {
   2643              sint16 vbus;
   2644              uint16 temp;
   2645          
   2646              temp = SR_Motor_Fault;
   2647              temp = BIT_TEST(temp, SR_FAULT_DC_VOLTAGE_OUT_OF_RANGE);
   2648          
   2649              if(temp)
   2650              {
   2651                  //Check for consistency of vbus reading
   2652                  SR_DATA_MCU_CHECK_SHORT(SR_DCBus);
   2653                  vbus = SR_DCBus;
   2654          
   2655                  // Powering up stage is completed -> adc signals are reliable
   2656                  // Dc Voltage out of range fault detected
   2657                  if(vbus > VBUS_SR_HIGH_THR_AD_COUNTS)
   2658                  {
   2659                      SR_MOTORSAFETY_MGR_ERROR_REACTION();
   2660                  }
   2661                  else if(vbus < VBUS_SR_LOW_THR_AD_COUNTS)
   2662                  {
   2663                      SRMCPwm__TurnOffAllGates();
   2664                  }
   2665              }
   2666              else
   2667              {
   2668                  SR_MOTORSAFETY_MGR_ERROR_REACTION();
   2669              }
   2670          }
   2671          
   2672          #ifdef SR_CIM_MOTOR
   2673          
   2674          #ifdef __IAR_SYSTEMS_ICC__
   2675          #pragma inline = forced
   2676          #endif
   2677          void InitMotorMovingHandlerCim(void)
   2678          {
   2679              uint16 temp;
   2680          
   2681              //! To be safe start the motor warning that it is moving.
   2682          
   2683              // Reset the zero speed flag, i.e., the motor is moving
   2684              temp = SR_Motor_Flags;
   2685              BIT_CLR(temp, SR_FLAG_UNLOCK_DOOR_SPEED);
   2686              SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,temp);
   2687          
   2688              // Set the rotor moving flag, i.e., the motor is moving
   2689              ClearFault(SR_FAULT_UNLOCK_DOOR_SPEED_FAILED);
   2690          
   2691              // Reset the Tacho zero speed check counter
   2692              SR_DATA_MCU_UPDATE_LONG(SR_VerifyTargetCounter,0);
   2693          
   2694          
   2695          }
   2696          
   2697          /**
   2698           *  @brief      Handler the unlock door speed (or rotor not moving) detection sub module. This shall be a part of the
   2699           *              whole class B protection. It uses two flags, one is to detect when the speed is really zero and,
   2700           *              when there is no movement in at the motor shaft. For safety issues, the zero speed detection
   2701           *              shall be used as flag for lid opening. There is also a flag which warns that the unlock door speed
   2702           *              was not able to be detected, this is not a fault and will not prevent the motor to start over.
   2703           *              This error in the unlock door speed flag shall be used in the door lock routine.
   2704           */
   2705          void MotorMovingHandlerCim(void)
   2706          {
   2707              uint32 temp;
   2708          #ifndef SKIP_MOTOR_MOVING_CHECK
   2709              if (SRMCInputCapture__GetMovementStatus(SR_UNLOCKDOORSPEED_LOW_COUNTER_THR))
   2710              {
   2711                  // motor is moving
   2712                  // update the state
   2713          
   2714                  // Clear the unlock door speed flag.
   2715                  temp = (uint32)SR_Motor_Flags;
   2716                  BIT_CLR(temp, SR_FLAG_UNLOCK_DOOR_SPEED);
   2717                  SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,(uint16)temp);
   2718          
   2719                  temp = SR_VerifyTargetCounter;
   2720                  if (temp < SR_UNLOCKDOORSPEED_TARGET_NOT_REACHED_TIMEOUT)
   2721                  {
   2722                      // wait state
   2723                      temp++;
   2724                      SR_DATA_MCU_UPDATE_LONG(SR_VerifyTargetCounter,temp);
   2725                  }
   2726                  else
   2727                  {
   2728                      // timeout state
   2729                      // Set the flag that a failure has happened while detecting the unlock door speed flag
   2730                      SetFault(SR_FAULT_UNLOCK_DOOR_SPEED_FAILED);
   2731                  }
   2732              }
   2733              else
   2734          #endif
   2735              {
   2736                  // motor is stopped
   2737          
   2738                  // Set the unlock door speed flag.
   2739                  temp = (uint32)SR_Motor_Flags;
   2740                  BIT_SET(temp, SR_FLAG_UNLOCK_DOOR_SPEED);
   2741                  SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,(uint16)temp);
   2742              }
   2743          }
   2744          
   2745          
   2746          #ifdef __IAR_SYSTEMS_ICC__
   2747          #pragma inline = forced
   2748          #endif
   2749          
   2750          
   2751          #ifdef __IAR_SYSTEMS_ICC__
   2752          #pragma inline = forced
   2753          #endif
   2754          void InputCapturePlausibilityHandler(void)
   2755          {
   2756              uint16 temp;
   2757          
   2758              temp = SRMCInputCapture__GetDiagnosticFeedback();
   2759          
   2760              if (temp == SR_IC_MIN_TACH_ERROR)
   2761              {
   2762                  // Set the plausibility fault
   2763                  SetFault(SR_FAULT_INPUTCAPTURE_PLAUSIBILITY_MIN_FAILED);
   2764          
   2765                  SR_DATA_MCU_UPDATE_LONG(SR_Timeout_Failure_Retry,TACHO_TIMEOUT); //Load time out
   2766              }
   2767              else if (temp == SR_IC_MAX_SPEED_ERROR)
   2768              {
   2769                  SetFault(SR_FAULT_INPUTCAPTURE_PLAUSIBILITY_MAX_FAILED);
   2770          
   2771                  SR_DATA_MCU_UPDATE_LONG(SR_Timeout_Failure_Retry,TACHO_TIMEOUT); //Load time out
   2772              }
   2773              else if ((temp == SR_IC_TEST_NOT_INITIALIZED) || (temp == SR_IC_ERROR_PERIPHERAL_NOT_SAFE))
   2774              {
   2775                  // todo: which fault report?
   2776                  // Set the plausibility fault
   2777                  SetFault(SR_FAULT_INPUTCAPTURE_PLAUSIBILITY_MAX_FAILED);
   2778          
   2779                  SR_DATA_MCU_UPDATE_LONG(SR_Timeout_Failure_Retry,TACHO_TIMEOUT); //Load time out
   2780              }
   2781          }
   2782          
   2783          
   2784          
   2785          
   2786          //---------------------------------------------------------------------------------------------------------------------
   2787          /**
   2788           *  @brief      Get the latest captured value of the InputCapture driver.
   2789           *  @param      none
   2790           *  @return     Last value of the InputCapture driver. Zero if the IC driver is disabled
   2791           */
   2792          unsigned int SRMotorSafetyMgr__GetInputCaptureCounterValue(void)
   2793          {
   2794              unsigned int res = 0;
   2795              if (SRMCInputCapture__GetStatus() == INPUTCAPTURE_ENABLED)
   2796              {
   2797                  res = SRMCInputCapture__GetCounterValue();
   2798              }
   2799          
   2800              return res;
   2801          }
   2802          
   2803          
   2804          
   2805          
   2806          //---------------------------------------------------------------------------------------------------------------------
   2807          /**
   2808           *  @brief      Get if a Input Capture match event occurred.
   2809           *  @param      none
   2810           *  @return     TRUE: match event occurred; FALSE: no match event occurred.
   2811           */
   2812          uint8 SRMotorSafetyMgr__GetInputCaptureMatchEvent(void)
   2813          {
   2814              uint8 res = 0;
   2815          
   2816              if (SRMCInputCapture__GetStatus() == INPUTCAPTURE_ENABLED)
   2817              {
   2818                  res = SRMCInputCapture__GetMatchEvent();
   2819              }
   2820          
   2821              return res;
   2822          }
   2823          #endif
   2824          
   2825          
   2826          
   2827          
   2828          #ifdef SR_BPM_MOTOR
   2829          /**
   2830           *  @brief      Initializes the variable of the unlock door speed algorithm.
   2831           *  @param      None
   2832           *  @return     None
   2833           *
   2834           */
   2835          #ifdef __IAR_SYSTEMS_ICC__
   2836          #pragma inline = forced
   2837          #endif
   2838          void InitMotorMovingHandlerBpm(void)
   2839          {
   2840              uint16 temp;
   2841          
   2842              //! To be safe start the motor warning that it is moving.
   2843          
   2844              // Reset the zero speed flag, i.e., the motor is moving
   2845              temp = SR_Motor_Flags;
   2846              BIT_CLR(temp, SR_FLAG_UNLOCK_DOOR_SPEED);
   2847              SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,temp);
   2848          
   2849              SR_DATA_MCU_UPDATE_LONG(SR_ZeroSpeedWithCurrTimer,0);
   2850          
   2851              SR_DATA_MCU_UPDATE_LONG(SR_ZeroSpeedDebouncer,0);                           // Initialize reseting the zero speed debouncer
   2852          }
   2853          
   2854          
   2855          
   2856          
   2857          /**
   2858           *  @brief      Handles the the unlock door speed algorithm.
   2859           *  @details    Call rate: every 5 ms
   2860           *  @param      None
   2861           *  @return     None
   2862           *
   2863           */

   \                                 In section .text, align 2, keep-with-next
   2864          void MotorMovingHandlerBpm(void)
   2865          {
   \                     ??MotorMovingHandlerBpm: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   2866              uint32 temp;
   2867              uint32 temp1;
   2868              uint32 temp_a;
   2869              uint32 temp_b;
   2870          
   2871          #ifndef SKIP_MOTOR_MOVING_CHECK
   2872              CheckAnalogVariables4Failure(); // Check for corrupted data
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF3EF 0x8510      MRS      R5,PRIMASK
   \   0000000A   0xB672             CPSID    I
   \   0000000C   0x....             LDR.N    R4,??DataTable192_4
   \   0000000E   0xF9B4 0x13A8      LDRSH    R1,[R4, #+936]
   \   00000012   0xF9B4 0x23C8      LDRSH    R2,[R4, #+968]
   \   00000016   0x43D2             MVNS     R2,R2
   \   00000018   0xB289             UXTH     R1,R1
   \   0000001A   0xB292             UXTH     R2,R2
   \   0000001C   0x4291             CMP      R1,R2
   \   0000001E   0xBF18             IT       NE 
   \   00000020   0x2001             MOVNE    R0,#+1
   \   00000022   0xF9B4 0x13AC      LDRSH    R1,[R4, #+940]
   \   00000026   0xF9B4 0x23CC      LDRSH    R2,[R4, #+972]
   \   0000002A   0x43D2             MVNS     R2,R2
   \   0000002C   0xB289             UXTH     R1,R1
   \   0000002E   0xB292             UXTH     R2,R2
   \   00000030   0x4291             CMP      R1,R2
   \   00000032   0xBF18             IT       NE 
   \   00000034   0x1C40             ADDNE    R0,R0,#+1
   \   00000036   0xF9B4 0x13B0      LDRSH    R1,[R4, #+944]
   \   0000003A   0xF9B4 0x23D0      LDRSH    R2,[R4, #+976]
   \   0000003E   0x43D2             MVNS     R2,R2
   \   00000040   0xB289             UXTH     R1,R1
   \   00000042   0xB292             UXTH     R2,R2
   \   00000044   0x4291             CMP      R1,R2
   \   00000046   0xBF18             IT       NE 
   \   00000048   0x1C40             ADDNE    R0,R0,#+1
   \   0000004A   0xF9B4 0x13AA      LDRSH    R1,[R4, #+938]
   \   0000004E   0xF9B4 0x23CA      LDRSH    R2,[R4, #+970]
   \   00000052   0x43D2             MVNS     R2,R2
   \   00000054   0xB289             UXTH     R1,R1
   \   00000056   0xB292             UXTH     R2,R2
   \   00000058   0x4291             CMP      R1,R2
   \   0000005A   0xBF18             IT       NE 
   \   0000005C   0x1C40             ADDNE    R0,R0,#+1
   \   0000005E   0xF9B4 0x13AE      LDRSH    R1,[R4, #+942]
   \   00000062   0xF9B4 0x23CE      LDRSH    R2,[R4, #+974]
   \   00000066   0x43D2             MVNS     R2,R2
   \   00000068   0xB289             UXTH     R1,R1
   \   0000006A   0xB292             UXTH     R2,R2
   \   0000006C   0x4291             CMP      R1,R2
   \   0000006E   0xBF18             IT       NE 
   \   00000070   0x1C40             ADDNE    R0,R0,#+1
   \   00000072   0xF9B4 0x13B2      LDRSH    R1,[R4, #+946]
   \   00000076   0xF9B4 0x23D2      LDRSH    R2,[R4, #+978]
   \   0000007A   0x43D2             MVNS     R2,R2
   \   0000007C   0xB289             UXTH     R1,R1
   \   0000007E   0xB292             UXTH     R2,R2
   \   00000080   0x4291             CMP      R1,R2
   \   00000082   0xBF18             IT       NE 
   \   00000084   0x1C40             ADDNE    R0,R0,#+1
   \   00000086   0xF9B4 0x13BC      LDRSH    R1,[R4, #+956]
   \   0000008A   0xF9B4 0x23DC      LDRSH    R2,[R4, #+988]
   \   0000008E   0x43D2             MVNS     R2,R2
   \   00000090   0xB289             UXTH     R1,R1
   \   00000092   0xB292             UXTH     R2,R2
   \   00000094   0x4291             CMP      R1,R2
   \   00000096   0xBF18             IT       NE 
   \   00000098   0x1C40             ADDNE    R0,R0,#+1
   \   0000009A   0xB120             CBZ.N    R0,??MotorMovingHandlerBpm_1
   \   0000009C   0x2200             MOVS     R2,#+0
   \   0000009E   0x2100             MOVS     R1,#+0
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0x.... 0x....      BL       SRException__Queue
   \                     ??MotorMovingHandlerBpm_1: (+1)
   \   000000A6   0xF385 0x8810      MSR      PRIMASK,R5
   2873          
   2874              // Count up the timeout to stop the motor
   2875              temp = SR_ZeroSpeedWithCurrTimer;
   \   000000AA   0xF8D4 0x0504      LDR      R0,[R4, #+1284]
   2876              if(temp < SR_MAX_LONG_VARIABLE)
   \   000000AE   0x2100             MOVS     R1,#+0
   \   000000B0   0xF06F 0x0201      MVN      R2,#+1
   \   000000B4   0x4289             CMP      R1,R1
   \   000000B6   0xDC09             BGT.N    ??MotorMovingHandlerBpm_2
   \   000000B8   0xDB01             BLT.N    ??MotorMovingHandlerBpm_3
   \   000000BA   0x4290             CMP      R0,R2
   \   000000BC   0xD206             BCS.N    ??MotorMovingHandlerBpm_2
   2877              {
   2878                  temp++;
   2879                  SR_DATA_MCU_UPDATE_LONG(SR_ZeroSpeedWithCurrTimer,temp);
   \                     ??MotorMovingHandlerBpm_3: (+1)
   \   000000BE   0x1C42             ADDS     R2,R0,#+1
   \   000000C0   0xF504 0x61F9      ADD      R1,R4,#+1992
   \   000000C4   0xF204 0x5004      ADDW     R0,R4,#+1284
   \   000000C8   0x.... 0x....      BL       SRData__UpdateLong
   2880              }
   2881          
   2882              temp1 = SR_SquaredCurrentsSum;
   \                     ??MotorMovingHandlerBpm_2: (+1)
   \   000000CC   0xF8D4 0x0508      LDR      R0,[R4, #+1288]
   2883          
   2884              //// The block below implements the unlock door speed debouncer
   2885              // if the sum of the squared currents is close to zero
   2886              // and the pwm is performing the "lowers on"
   2887              temp = SR_ZeroSpeedDebouncer;
   \   000000D0   0xF8D4 0x1500      LDR      R1,[R4, #+1280]
   2888              if((temp1 < SR_UNLOCKDOORSPEED_CURR_THRES_FIXP)&&(temp < SR_UNLOCKDOORSPEED_DEBOUNCING_COUNTER)) // SRMCpwm driver is changed.
   \   000000D4   0xF242 0x7210      MOVW     R2,#+10000
   \   000000D8   0x4290             CMP      R0,R2
   \   000000DA   0xBF38             IT       CC 
   \   000000DC   0xF5B1 0x7FA0      CMPCC    R1,#+320
   \   000000E0   0xD244             BCS.N    ??MotorMovingHandlerBpm_4
   2889              {   // ZeroSpeedDebouncer does not already reached the desired value
   2890                  // If no exception in the hardware has been read (shut down input)
   2891                  temp = (uint32)CheckHwFaultStatus();
   \   000000E2   0xF204 0x518A      ADDW     R1,R4,#+1418
   \   000000E6   0xF504 0x705C      ADD      R0,R4,#+880
   \   000000EA   0x.... 0x....      BL       SRData__CheckByte
   \   000000EE   0xBB60             CBNZ.N   R0,??MotorMovingHandlerBpm_5
   \   000000F0   0xF894 0x0370      LDRB     R0,[R4, #+880]
   \   000000F4   0x2804             CMP      R0,#+4
   \   000000F6   0xBF18             IT       NE 
   \   000000F8   0x2800             CMPNE    R0,#+0
   \   000000FA   0xD126             BNE.N    ??MotorMovingHandlerBpm_5
   \   000000FC   0x....             LDR.N    R0,??DataTable192_6  ;; 0x40038074
   \   000000FE   0x6800             LDR      R0,[R0, #+0]
   \   00000100   0x0600             LSLS     R0,R0,#+24
   \   00000102   0x0FC0             LSRS     R0,R0,#+31
   \   00000104   0xD021             BEQ.N    ??MotorMovingHandlerBpm_5
   \   00000106   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   0000010A   0xF040 0x0240      ORR      R2,R0,#0x40
   \   0000010E   0xF504 0x7171      ADD      R1,R4,#+964
   \   00000112   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   00000116   0x.... 0x....      BL       SRData__UpdateShort
   \   0000011A   0xF8B4 0x03A4      LDRH     R0,[R4, #+932]
   \   0000011E   0xF040 0x0240      ORR      R2,R0,#0x40
   \   00000122   0xF504 0x61B2      ADD      R1,R4,#+1424
   \   00000126   0xF504 0x7069      ADD      R0,R4,#+932
   \   0000012A   0x.... 0x....      BL       SRData__UpdateShort
   2892                  if(!temp)
   2893                  {
   2894                      // Increment the "debouncer" timer
   2895                      temp = SR_ZeroSpeedDebouncer;
   2896                      if(temp < SR_MAX_LONG_VARIABLE)
   2897                      {
   2898                          temp++;
   2899                          SR_DATA_MCU_UPDATE_LONG(SR_ZeroSpeedDebouncer,temp);
   2900                      }
   2901          
   2902                  }
   2903                  else // else a hardware exception has happened
   2904                  {
   2905                      // then zero the "debouncer" timer.
   2906                      SR_DATA_MCU_UPDATE_LONG(SR_ZeroSpeedDebouncer,0);
   \   0000012E   0x2200             MOVS     R2,#+0
   \   00000130   0xF204 0x71C4      ADDW     R1,R4,#+1988
   \   00000134   0xF504 0x60A0      ADD      R0,R4,#+1280
   \   00000138   0x.... 0x....      BL       SRData__UpdateLong
   2907          
   2908                      // Hw faults are detected -> wait 60 s before turn-on again PWM
   2909                      SR_DATA_MCU_UPDATE_LONG(SR_Timeout_Failure_Retry,HW_FAULT_POSTRUN_TIMEOUT); //Load time out
   \   0000013C   0xF642 0x62E0      MOVW     R2,#+12000
   \   00000140   0xF504 0x61FE      ADD      R1,R4,#+2032
   \   00000144   0xF204 0x502C      ADDW     R0,R4,#+1324
   \   00000148   0xE00E             B.N      ??MotorMovingHandlerBpm_6
   2910                  }
   \                     ??MotorMovingHandlerBpm_5: (+1)
   \   0000014A   0xF8D4 0x0500      LDR      R0,[R4, #+1280]
   \   0000014E   0x2100             MOVS     R1,#+0
   \   00000150   0xF06F 0x0201      MVN      R2,#+1
   \   00000154   0x4289             CMP      R1,R1
   \   00000156   0xDC09             BGT.N    ??MotorMovingHandlerBpm_4
   \   00000158   0xDB01             BLT.N    ??MotorMovingHandlerBpm_7
   \   0000015A   0x4290             CMP      R0,R2
   \   0000015C   0xD206             BCS.N    ??MotorMovingHandlerBpm_4
   \                     ??MotorMovingHandlerBpm_7: (+1)
   \   0000015E   0x1C42             ADDS     R2,R0,#+1
   \   00000160   0xF204 0x71C4      ADDW     R1,R4,#+1988
   \   00000164   0xF504 0x60A0      ADD      R0,R4,#+1280
   \                     ??MotorMovingHandlerBpm_6: (+1)
   \   00000168   0x.... 0x....      BL       SRData__UpdateLong
   2911              }
   2912          
   2913              // If the time is longer enough and very short compared to the zero speed detection
   2914              temp = SR_ZeroSpeedDebouncer;
   2915          
   2916              // Debounce the time for "unlock door speed" flag
   2917              // The "debouncer" time is over, then...
   2918              if(temp >= SR_UNLOCKDOORSPEED_DEBOUNCING_COUNTER)
   \                     ??MotorMovingHandlerBpm_4: (+1)
   \   0000016C   0xF8D4 0x0500      LDR      R0,[R4, #+1280]
   \   00000170   0xF5B0 0x7FA0      CMP      R0,#+320
   \   00000174   0xD327             BCC.N    ??MotorMovingHandlerBpm_8
   2919              {
   2920                  // Trigger the shut down pin before setting the unlock door speed flags.
   2921                  // Start the Shut down plausibility check
   2922                  SRMCPwm__EnableDiagnostic(SD_PIN_ZERO_TIME, SD_PIN_ONE_TIME);
   \   00000176   0xF44F 0x71A0      MOV      R1,#+320
   \   0000017A   0x2028             MOVS     R0,#+40
   \   0000017C   0x.... 0x....      BL       SRMCPwm__EnableDiagnostic
   2923          
   2924                  // Read the SRMCPwm diagnosis feedback
   2925                  temp = SRMCPwm__GetDiagnosticFeedback();
   \   00000180   0x.... 0x....      BL       SRMCPwm__GetDiagnosticFeedback
   2926          
   2927                  // If the pwm peripheral is unsafe...
   2928                  if(temp == SR_MCPWM_ERROR_PERIPHERAL_NOT_SAFE)
   \   00000184   0x2804             CMP      R0,#+4
   \   00000186   0xD112             BNE.N    ??MotorMovingHandlerBpm_9
   2929                  {
   2930                      // Set the flag warning the shut down circuit is malfunctioning.
   2931                      SetFault(SR_FAULT_SHUTDOWN_HARDWARE_FAILED);
   \   00000188   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   0000018C   0xF040 0x0204      ORR      R2,R0,#0x4
   \   00000190   0xF504 0x7171      ADD      R1,R4,#+964
   \   00000194   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   00000198   0x.... 0x....      BL       SRData__UpdateShort
   \   0000019C   0xF8B4 0x03A4      LDRH     R0,[R4, #+932]
   \   000001A0   0xF040 0x0204      ORR      R2,R0,#0x4
   \   000001A4   0xF504 0x61B2      ADD      R1,R4,#+1424
   \   000001A8   0xF504 0x7069      ADD      R0,R4,#+932
   \   000001AC   0xE009             B.N      ??MotorMovingHandlerBpm_10
   2932          
   2933                  }
   2934                  else if(temp == SR_MCPWM_ERROR_PERIPHERAL_SAFE) // if the shut down is safe
   \                     ??MotorMovingHandlerBpm_9: (+1)
   \   000001AE   0x2805             CMP      R0,#+5
   \   000001B0   0xD109             BNE.N    ??MotorMovingHandlerBpm_8
   2935                  {
   2936                      // Found zero speed with zero vector (1 test passed - zero motor currents), set the unlock door speed check request to execute 2 test (not zero motor currents)
   2937                      temp1 = (uint32)SR_Motor_Flags;
   \   000001B2   0xF8B4 0x03A6      LDRH     R0,[R4, #+934]
   2938                      BIT_SET(temp1, SR_FLAG_UNLOCK_DOOR_SPEED_CHECK_REQUESTED);
   2939                      SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,temp1);
   \   000001B6   0xF440 0x6280      ORR      R2,R0,#0x400
   \   000001BA   0xF204 0x31C6      ADDW     R1,R4,#+966
   \   000001BE   0xF204 0x30A6      ADDW     R0,R4,#+934
   \                     ??MotorMovingHandlerBpm_10: (+1)
   \   000001C2   0x.... 0x....      BL       SRData__UpdateShort
   2940                  }
   2941              }
   2942          
   2943              // Get all faults that prevents the unlock door speed be read properly
   2944              temp_a  = SR_Motor_Fault;
   \                     ??MotorMovingHandlerBpm_8: (+1)
   \   000001C6   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   2945              temp_b  = BIT_TEST(temp_a, SR_FAULT_CURRENT_SENSOR_FAILED);
   2946              temp_b += BIT_TEST(temp_a, SR_FAULT_VOLTAGE_SENSOR_FAILED);
   2947              temp_b += BIT_TEST(temp_a, SR_FAULT_SHUTDOWN_HARDWARE_FAILED);
   2948          
   2949              // If the timeout is expired.
   2950              temp = SR_ZeroSpeedWithCurrTimer;
   2951              if( (temp >= SR_UNLOCKDOORSPEED_FAIL_TIMER_COUNTER) ||
   2952                  (temp_b) )
   \   000001CA   0xF8D4 0x1504      LDR      R1,[R4, #+1284]
   \   000001CE   0xF5B1 0x4F48      CMP      R1,#+51200
   \   000001D2   0xD205             BCS.N    ??MotorMovingHandlerBpm_11
   \   000001D4   0x07C1             LSLS     R1,R0,#+31
   \   000001D6   0xD403             BMI.N    ??MotorMovingHandlerBpm_11
   \   000001D8   0x0781             LSLS     R1,R0,#+30
   \   000001DA   0xD401             BMI.N    ??MotorMovingHandlerBpm_11
   \   000001DC   0x0740             LSLS     R0,R0,#+29
   \   000001DE   0xD516             BPL.N    ??MotorMovingHandlerBpm_12
   2953              {
   2954                  // Set the flag that a failure has happened while detecting the unlock door speed flag
   2955                  SetFault(SR_FAULT_UNLOCK_DOOR_SPEED_FAILED);
   \                     ??MotorMovingHandlerBpm_11: (+1)
   \   000001E0   0xF8B4 0x03A2      LDRH     R0,[R4, #+930]
   \   000001E4   0xF040 0x0208      ORR      R2,R0,#0x8
   \   000001E8   0xF504 0x7171      ADD      R1,R4,#+964
   \   000001EC   0xF204 0x30A2      ADDW     R0,R4,#+930
   \   000001F0   0x.... 0x....      BL       SRData__UpdateShort
   \   000001F4   0xF8B4 0x03A4      LDRH     R0,[R4, #+932]
   \   000001F8   0xF040 0x0208      ORR      R2,R0,#0x8
   \   000001FC   0xF504 0x61B2      ADD      R1,R4,#+1424
   \   00000200   0xF504 0x7069      ADD      R0,R4,#+932
   \   00000204   0xB001             ADD      SP,SP,#+4
   \   00000206   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   0000020A   0x.... 0x....      B.W      SRData__UpdateShort
   2956              }
   2957          #else
   2958              // Mock for BPM
   2959              // motor is stopped
   2960              // Clear the flag that the shut down was corrupted from previous run
   2961              ClearFault(SR_FAULT_SHUTDOWN_HARDWARE_FAILED);
   2962          
   2963              // Set the zero speed flag.
   2964              temp1 = (uint32)SR_Motor_Flags;
   2965              BIT_SET(temp1, SR_FLAG_UNLOCK_DOOR_SPEED_CHECK_REQUESTED);
   2966              SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Flags,temp1);
   2967          
   2968              // Clear the flag  that a failure has happened while detection the zero speed
   2969              ClearFault(SR_FAULT_UNLOCK_DOOR_SPEED_FAILED);
   2970          #endif
   2971          }
   \                     ??MotorMovingHandlerBpm_12: (+1)
   \   0000020E   0xB001             ADD      SP,SP,#+4
   \   00000210   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x47000000         DC32     0x47000000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     Mcl_Quantities

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x3A80ADFD         DC32     0x3a80adfd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x40038008         DC32     0x40038008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x3DD67750         DC32     0x3dd67750

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x3903126F         DC32     0x3903126f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x4918C9EB         DC32     0x4918c9eb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x........         DC32     Mcl_Quantities

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \   00000000   0x35D67750         DC32     0x35d67750

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \   00000000   0x469AB001         DC32     0x469ab001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_3:
   \   00000000   0x42C80000         DC32     0x42c80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_4:
   \   00000000   0xFFD7EC7F         DC32     0xffd7ec7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0xFFFBFFFD         DC32     0xfffbfffd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x3903126F         DC32     0x3903126f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_1:
   \   00000000   0x3DD67750         DC32     0x3dd67750

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \   00000000   0x3EAAAAAB         DC32     0x3eaaaaab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \   00000000   0x3F7AE148         DC32     0x3f7ae148

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_1:
   \   00000000   0x3CA3D70A         DC32     0x3ca3d70a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_2:
   \   00000000   0x........         DC32     Mcl_Quantities+0x4D8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38:
   \   00000000   0x3F866666         DC32     0x3f866666

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_1:
   \   00000000   0x3F733333         DC32     0x3f733333

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_2:
   \   00000000   0x3DD67750         DC32     0x3dd67750

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39:
   \   00000000   0x3903126F         DC32     0x3903126f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42:
   \   00000000   0x3F19999A         DC32     0x3f19999a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43:
   \   00000000   0x3FC90FDB         DC32     0x3fc90fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45:
   \   00000000   0x........         DC32     Mcl_Quantities

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46:
   \   00000000   0x3DCCCCCD         DC32     0x3dcccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_1:
   \   00000000   0x400CCCCD         DC32     0x400ccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_2:
   \   00000000   0x35D67750         DC32     0x35d67750

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_3:
   \   00000000   0x3E4CCCCD         DC32     0x3e4ccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_4:
   \   00000000   0x469AB001         DC32     0x469ab001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_5:
   \   00000000   0x42C80000         DC32     0x42c80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_6:
   \   00000000   0x41F00000         DC32     0x41f00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_7:
   \   00000000   0x........         DC32     Mcl_Quantities

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47:
   \   00000000   0x3D000000         DC32     0x3d000000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_1:
   \   00000000   0x3683126F         DC32     0x3683126f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_2:
   \   00000000   0x3903126F         DC32     0x3903126f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_3:
   \   00000000   0x3A4DE32F         DC32     0x3a4de32f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48:
   \   00000000   0x40C90FDC         DC32     0x40c90fdc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49:
   \   00000000   0xC0C90FDB         DC32     0xc0c90fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50:
   \   00000000   0x3A0EFA35         DC32     0x3a0efa35

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_1:
   \   00000000   0x40C90FDB         DC32     0x40c90fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55:
   \   00000000   0x3F733333         DC32     0x3f733333

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_1:
   \   00000000   0x3DCCCCCD         DC32     0x3dcccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_2:
   \   00000000   0x3D000000         DC32     0x3d000000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_3:
   \   00000000   0x4346F7B0         DC32     0x4346f7b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56:
   \   00000000   0x3CA3D70A         DC32     0x3ca3d70a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56_1:
   \   00000000   0x3D4CCCCD         DC32     0x3d4ccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56_2:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58:
   \   00000000   0x3F13CD3A         DC32     0x3f13cd3a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59:
   \   00000000   0x3E22F983         DC32     0x3e22f983

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_1:
   \   00000000   0xB4800000         DC32     0xb4800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_2:
   \   00000000   0x44000000         DC32     0x44000000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_3:
   \   00000000   0x........         DC32     Mcl_Quantities

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_4:
   \   00000000   0x3DD67750         DC32     0x3dd67750

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable62:
   \   00000000   0x3F13CD3A         DC32     0x3f13cd3a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable62_1:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable62_2:
   \   00000000   0x3DCCCCCD         DC32     0x3dcccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64:
   \   00000000   0x3A83126F         DC32     0x3a83126f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64_1:
   \   00000000   0x3F800001         DC32     0x3f800001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64_2:
   \   00000000   0x400CCCCD         DC32     0x400ccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64_3:
   \   00000000   0x........         DC32     Mcl_Quantities

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65:
   \   00000000   0x3C23D70A         DC32     0x3c23d70a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable66:
   \   00000000   0x3EAAAAAB         DC32     0x3eaaaaab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable66_1:
   \   00000000   0x3E4CCCCD         DC32     0x3e4ccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable66_2:
   \   00000000   0x3F13CD3A         DC32     0x3f13cd3a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable66_3:
   \   00000000   0x3DA3D70B         DC32     0x3da3d70b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable66_4:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable66_5:
   \   00000000   0x3C4CCCCD         DC32     0x3c4ccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable66_6:
   \   00000000   0x3E22F983         DC32     0x3e22f983

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable66_7:
   \   00000000   0xB4800000         DC32     0xb4800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable66_8:
   \   00000000   0x44000000         DC32     0x44000000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable66_9:
   \   00000000   0x........         DC32     sinTable_wp_f32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67:
   \   00000000   0x45F9FFFF         DC32     0x45f9ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68:
   \   00000000   0x3E22F983         DC32     0x3e22f983

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_1:
   \   00000000   0xB4800000         DC32     0xb4800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_2:
   \   00000000   0x44000000         DC32     0x44000000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69:
   \   00000000   0x40490FDC         DC32     0x40490fdc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable70:
   \   00000000   0xC0C90FDB         DC32     0xc0c90fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable70_1:
   \   00000000   0xC0490FDB         DC32     0xc0490fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable70_2:
   \   00000000   0x40C90FDB         DC32     0x40c90fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable70_3:
   \   00000000   0x3F7E0000         DC32     0x3f7e0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable70_4:
   \   00000000   0x3C000000         DC32     0x3c000000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72:
   \   00000000   0x4185F9DB         DC32     0x4185f9db

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_1:
   \   00000000   0x38AEC174         DC32     0x38aec174

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_2:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable75:
   \   00000000   0x3F866666         DC32     0x3f866666

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable75_1:
   \   00000000   0x3F733333         DC32     0x3f733333

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable75_2:
   \   00000000   0x3DD67750         DC32     0x3dd67750

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable75_3:
   \   00000000   0x........         DC32     Speed_PLL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76:
   \   00000000   0x3FDDB3D7         DC32     0x3fddb3d7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76_1:
   \   00000000   0x3F5DB3D7         DC32     0x3f5db3d7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76_2:
   \   00000000   0xBF5DB3D7         DC32     0xbf5db3d7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76_3:
   \   00000000   0x3F800001         DC32     0x3f800001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76_4:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76_5:
   \   00000000   0x3F6B8520         DC32     0x3f6b8520

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76_6:
   \   00000000   0x3F6B851F         DC32     0x3f6b851f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76_7:
   \   00000000   0x3F70A3D8         DC32     0x3f70a3d8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable82:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable86:
   \   00000000   0x3DD67750         DC32     0x3dd67750

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable86_1:
   \   00000000   0x........         DC32     sinTable_wp_f32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable86_2:
   \   00000000   0x35D67750         DC32     0x35d67750

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable86_3:
   \   00000000   0x469AB001         DC32     0x469ab001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable86_4:
   \   00000000   0x42C80000         DC32     0x42c80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable90:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable91:
   \   00000000   0x37800000         DC32     0x37800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable92:
   \   00000000   0x........         DC32     Mcl_Quantities

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable92_1:
   \   00000000   0x44800000         DC32     0x44800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable92_2:
   \   00000000   0x42800000         DC32     0x42800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable94:
   \   00000000   0x3EAAAAAB         DC32     0x3eaaaaab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable94_1:
   \   00000000   0x3F13CD3A         DC32     0x3f13cd3a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable95:
   \   00000000   0x3F5DB3D7         DC32     0x3f5db3d7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable96:
   \   00000000   0x........         DC32     Mcl_Quantities

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable96_1:
   \   00000000   0x........         DC32     Mcl_Quantities+0x47C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable96_2:
   \   00000000   0x3F19999A         DC32     0x3f19999a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable96_3:
   \   00000000   0x3903126F         DC32     0x3903126f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable96_4:
   \   00000000   0x3FC90FDB         DC32     0x3fc90fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable104:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable104_1:
   \   00000000   0x40490FDB         DC32     0x40490fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable104_2:
   \   00000000   0x3E22F983         DC32     0x3e22f983

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable104_3:
   \   00000000   0xB4800000         DC32     0xb4800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable104_4:
   \   00000000   0x44000000         DC32     0x44000000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable104_5:
   \   00000000   0xC4000000         DC32     0xc4000000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable104_6:
   \   00000000   0xFFFF8000         DC32     0xffff8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable104_7:
   \   00000000   0xFFFFAD51         DC32     0xffffad51

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable106:
   \   00000000   0xFFFFED1C         DC32     0xffffed1c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable106_1:
   \   00000000   0xFFFFC000         DC32     0xffffc000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable107:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable110:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable112:
   \   00000000   0xC0000001         DC32     0xc0000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable113:
   \   00000000   0x3FDDB3D7         DC32     0x3fddb3d7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable113_1:
   \   00000000   0x3F5DB3D7         DC32     0x3f5db3d7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable113_2:
   \   00000000   0xBF5DB3D7         DC32     0xbf5db3d7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable113_3:
   \   00000000   0x3F800001         DC32     0x3f800001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable114:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable114_1:
   \   00000000   0x3F6B8520         DC32     0x3f6b8520

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable114_2:
   \   00000000   0x3F6B851F         DC32     0x3f6b851f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable114_3:
   \   00000000   0x3F70A3D8         DC32     0x3f70a3d8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable115:
   \   00000000   0xBF7FFFFE         DC32     0xbf7ffffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable115_1:
   \   00000000   0x3C83126F         DC32     0x3c83126f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable117:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable119:
   \   00000000   0x3FDDB3D7         DC32     0x3fddb3d7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable119_1:
   \   00000000   0x3F5DB3D7         DC32     0x3f5db3d7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable119_2:
   \   00000000   0xBF5DB3D7         DC32     0xbf5db3d7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable119_3:
   \   00000000   0x3F800001         DC32     0x3f800001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable119_4:
   \   00000000   0x3F93CD36         DC32     0x3f93cd36

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable119_5:
   \   00000000   0x3F860A92         DC32     0x3f860a92

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable119_6:
   \   00000000   0x3F6B8520         DC32     0x3f6b8520

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable119_7:
   \   00000000   0x3F6B851F         DC32     0x3f6b851f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable119_8:
   \   00000000   0x3F70A3D8         DC32     0x3f70a3d8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable119_9:
   \   00000000   0x........         DC32     ??vs_alpha_beta_comp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable121:
   \   00000000   0xFFFF9126         DC32     0xffff9126

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127:
   \   00000000   0xFFFFF06E         DC32     0xfffff06e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable133:
   \   00000000   0x3DD67750         DC32     0x3dd67750

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable134:
   \   00000000   0x........         DC32     ??vs_alpha_beta_comp_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136:
   \   00000000   0x3903126F         DC32     0x3903126f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable139:
   \   00000000   0x3D567751         DC32     0x3d567751

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable139_1:
   \   00000000   0x3D567750         DC32     0x3d567750

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable140:
   \   00000000   0x3A80ADFD         DC32     0x3a80adfd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable146:
   \   00000000   0x........         DC32     Mcl_Quantities

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable156:
   \   00000000   0x........         DC32     Mcl_Quantities+0x4AC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable158:
   \   00000000   0x49742400         DC32     0x49742400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable158_1:
   \   00000000   0x427C0000         DC32     0x427c0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable159:
   \   00000000   0x447A0000         DC32     0x447a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable162:
   \   00000000   0x........         DC32     Mcl_Quantities+0x4D0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable164:
   \   00000000   0x........         DC32     Mcl_Quantities+0x4DC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable164_1:
   \   00000000   0x........         DC32     Mcl_Quantities+0x4D8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable164_2:
   \   00000000   0x40048018         DC32     0x40048018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable164_3:
   \   00000000   0x40036000         DC32     0x40036000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable164_4:
   \   00000000   0x00020303         DC32     0x20303

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable164_5:
   \   00000000   0x000A0880         DC32     0xa0880

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable164_6:
   \   00000000   0x4007D002         DC32     0x4007d002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable165:
   \   00000000   0x4003B000         DC32     0x4003b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable166:
   \   00000000   0x40027000         DC32     0x40027000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable166_1:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable166_2:
   \   00000000   0x4005200C         DC32     0x4005200c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable166_3:
   \   00000000   0x4004D040         DC32     0x4004d040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable167:
   \   00000000   0x4004A008         DC32     0x4004a008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable167_1:
   \   00000000   0x4004A004         DC32     0x4004a004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable167_2:
   \   00000000   0x40048038         DC32     0x40048038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable167_3:
   \   00000000   0x400FF0C4         DC32     0x400ff0c4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable167_4:
   \   00000000   0x4004C000         DC32     0x4004c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable167_5:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable167_6:
   \   00000000   0x420C0000         DC32     0x420c0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable167_7:
   \   00000000   0x4004800C         DC32     0x4004800c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable167_8:
   \   00000000   0x........         DC32     Mcl_Quantities

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable167_9:
   \   00000000   0x40038000         DC32     0x40038000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable167_10:
   \   00000000   0x3F866666         DC32     0x3f866666

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable167_11:
   \   00000000   0x3F733333         DC32     0x3f733333

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable167_12:
   \   00000000   0x00737373         DC32     0x737373

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable167_13:
   \   00000000   0x40038010         DC32     0x40038010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable167_14:
   \   00000000   0x40038060         DC32     0x40038060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable167_15:
   \   00000000   0x40038008         DC32     0x40038008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable168:
   \   00000000   0x40038074         DC32     0x40038074

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169:
   \   00000000   0x........         DC32     Mcl_Quantities

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_1:
   \   00000000   0x4003B000         DC32     0x4003b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_2:
   \   00000000   0x40027000         DC32     0x40027000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_3:
   \   00000000   0x40038010         DC32     0x40038010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_4:
   \   00000000   0x40038038         DC32     0x40038038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable191:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192:
   \   00000000   0x41B42EB3         DC32     0x41b42eb3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_1:
   \   00000000   0x38000000         DC32     0x38000000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_2:
   \   00000000   0x457A0000         DC32     0x457a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_3:
   \   00000000   0x40038008         DC32     0x40038008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_4:
   \   00000000   0x........         DC32     Mcl_Quantities

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_5:
   \   00000000   0x40038010         DC32     0x40038010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_6:
   \   00000000   0x40038074         DC32     0x40038074
   2972          
   2973          #endif
   2974          
   2975          
   2976          
   2977          
   2978          
   2979          
   2980          /**
   2981           *  @brief      Initialize the variables used by the frequency measurement module.
   2982           *  @details    Called every motor control state machine starting up
   2983           *  @param      None
   2984           *  @return     None
   2985           *
   2986           */
   2987          #ifdef __IAR_SYSTEMS_ICC__
   2988          #pragma inline = forced
   2989          #endif
   2990          void Init_Avg_Frequency(void)
   2991          {
   2992          #ifdef SR_BPM_MOTOR
   2993          
   2994              sint32 temp_s32;
   2995          
   2996              SR_DATA_MCU_CHECK_BYTE(SR_Avg_Cross_Event);
   2997              SR_DATA_MCU_CHECK_LONG(SR_Avg_Fund_Period_High_Threshold);
   2998              SR_DATA_MCU_CHECK_LONG(SR_Avg_Fund_Period_Low_Threshold);
   2999              SR_DATA_MCU_CHECK_LONG(SR_Avg_Threshold);
   3000              SR_DATA_MCU_CHECK_LONG(SR_Avg_Fund_Period_Time_Counter);
   3001              SR_DATA_MCU_CHECK_LONG(SR_Avg_Fund_Period_Cycle_Counter);
   3002              SR_DATA_MCU_CHECK_LONG(SR_Avg_Fund_Period);
   3003              SR_DATA_MCU_CHECK_LONG(SR_Applied_Duty_A_Sum);
   3004              SR_DATA_MCU_CHECK_BYTE(SR_Avg_Fund_Ignored_First);
   3005          
   3006              temp_s32 = SRMCPWM__GETMAXPWM();
   3007              temp_s32 = (sint32)(SR_MODULATION_LIMIT * (float)temp_s32);
   3008              temp_s32 = temp_s32>>1;                         //!< Half value of the maximum duty, e.g. 0.5 pu
   3009              SR_Avg_Fund_Period_High_Threshold = (sint32)(((100.0f + AVG_THRESHOLD_HT)/100.0f) * temp_s32);  //!< High threshold hysteresis value;
   3010              SR_Avg_Fund_Period_Low_Threshold =  (sint32)(((100.0f - AVG_THRESHOLD_HT)/100.0f) * temp_s32);  //!< Low threshold hysteresis value
   3011          
   3012              SR_DATA_MCU_UPDATE_LONG(SR_Avg_Fund_Period_High_Threshold, SR_Avg_Fund_Period_High_Threshold);
   3013              SR_DATA_MCU_UPDATE_LONG(SR_Avg_Fund_Period_Low_Threshold, SR_Avg_Fund_Period_Low_Threshold);
   3014              SR_DATA_MCU_UPDATE_LONG(SR_Avg_Threshold, SR_Avg_Fund_Period_Low_Threshold);
   3015          
   3016              SR_DATA_MCU_UPDATE_BYTE(SR_Avg_Cross_Event, FALSE);
   3017              SR_DATA_MCU_UPDATE_LONG(SR_Avg_Fund_Period_Time_Counter, 0);
   3018              SR_DATA_MCU_UPDATE_LONG(SR_Avg_Fund_Period_Cycle_Counter, SR_MOTOR_SAFETY_MNGR_MAX_PERIOD_COUNTER);
   3019              SR_DATA_MCU_UPDATE_LONG(SR_Avg_Fund_Period, SR_MOTOR_SAFETY_MNGR_MAX_PERIOD_COUNTER);
   3020              SR_DATA_MCU_UPDATE_LONG(SR_Applied_Duty_A_Sum, 0);
   3021              SR_DATA_MCU_UPDATE_LONG(SR_Applied_Duty_A_Sum_High, 0);
   3022          
   3023              SR_DATA_MCU_UPDATE_BYTE(SR_Avg_Fund_Ignored_First, FALSE);
   3024          
   3025          #else // SR_CIM_MOTOR
   3026          
   3027          
   3028          #endif
   3029          }
   3030          
   3031          
   3032          
   3033          
   3034          /**
   3035           *  @brief      Measure the avereage frequency
   3036           *  @details    Call rate every motor control rate (pwm rate)
   3037           *  @param      None
   3038           *  @return     None
   3039           *
   3040           */
   3041          #ifdef __IAR_SYSTEMS_ICC__
   3042          #pragma inline = forced
   3043          #endif
   3044          void Calc_Avg_Frequency(void)
   3045          {
   3046          #ifdef SR_BPM_MOTOR
   3047          
   3048              uint32 temp_u32;
   3049              sint32 temp_s32;
   3050              sint32 temp_s32_1;
   3051              sint32 temp_s32_low;
   3052              sint32 temp_s32_high;
   3053          
   3054              SR_DATA_MCU_CHECK_LONG(SR_Avg_Fund_Period_Time_Counter);
   3055              SR_DATA_MCU_CHECK_LONG(SR_Avg_Fund_Period_Cycle_Counter);
   3056              SR_DATA_MCU_CHECK_LONG(SR_Applied_Duty_A_Sum);
   3057              SR_DATA_MCU_CHECK_LONG(SR_Applied_Duty_A_Sum_High);
   3058              SR_DATA_MCU_CHECK_LONG(SR_Avg_Threshold);
   3059              SR_DATA_MCU_CHECK_LONG(SR_Avg_Fund_Period_Low_Threshold);
   3060              SR_DATA_MCU_CHECK_LONG(SR_Avg_Fund_Period_High_Threshold);
   3061              SR_DATA_MCU_CHECK_BYTE(SR_Avg_Cross_Event);
   3062              SR_DATA_MCU_CHECK_BYTE(SR_Avg_Fund_Period_Cycle_Total);
   3063              SR_DATA_MCU_CHECK_BYTE(SR_Avg_Fund_Ignored_First);
   3064          
   3065              temp_u32 = SR_Avg_Fund_Period_Time_Counter;
   3066              if(temp_u32 < SR_MOTOR_SAFETY_MNGR_MAX_PERIOD_COUNTER)
   3067              {
   3068                  temp_u32++;
   3069                  SR_DATA_MCU_UPDATE_LONG(SR_Avg_Fund_Period_Time_Counter, temp_u32);
   3070              }
   3071          
   3072              temp_s32 = SRMCPWM__GET_PWM_A();
   3073          
   3074              temp_s32_1 = SR_Applied_Duty_A_Sum;
   3075              SRMC__FILTER_CALC(temp_s32, temp_s32_1, SRMOTOR_SAFETY_AVG_CALC_COFF_FREQ_LOW_SPD);
   3076              SR_DATA_MCU_UPDATE_LONG(SR_Applied_Duty_A_Sum, temp_s32_1);
   3077              temp_s32_low = SRMC__FILTER_GET_FILTERED_VAR(temp_s32_1, SRMOTOR_SAFETY_AVG_CALC_COFF_FREQ_LOW_SPD);
   3078          
   3079              temp_s32_1 = SR_Applied_Duty_A_Sum_High;
   3080              SRMC__FILTER_CALC(temp_s32, temp_s32_1, SRMOTOR_SAFETY_AVG_CALC_COFF_FREQ_HI_SPD);
   3081              SR_DATA_MCU_UPDATE_LONG(SR_Applied_Duty_A_Sum_High, temp_s32_1);
   3082              temp_s32_high = SRMC__FILTER_GET_FILTERED_VAR(temp_s32_1, SRMOTOR_SAFETY_AVG_CALC_COFF_FREQ_HI_SPD);
   3083          
   3084              // Select which filtered value will be used in the threshold, there is a small glitch
   3085              // when jumping from filter to other one but the error is small.
   3086              temp_s32 = SR_Avg_Fund_Period;
   3087              if(temp_s32 < SRMOTOR_SAFETY_AVG_HIST_LOW_TO_HIGH_THRES)
   3088              {
   3089                  temp_s32 = temp_s32_high;
   3090              }
   3091              else
   3092              {
   3093                  temp_s32 = temp_s32_low;
   3094              }
   3095          
   3096              // Look for complete cycles and count the time accordingly.
   3097              if(temp_s32 > SR_Avg_Threshold)
   3098              {
   3099                  SR_DATA_MCU_UPDATE_LONG(SR_Avg_Threshold, SR_Avg_Fund_Period_Low_Threshold);
   3100          
   3101                  if(SR_Avg_Cross_Event == TRUE)
   3102                  {
   3103                      SR_DATA_MCU_UPDATE_BYTE(SR_Avg_Cross_Event, FALSE);
   3104          
   3105                      temp_u32 = SR_Avg_Fund_Period_Cycle_Counter;
   3106                      temp_u32++;
   3107                      SR_DATA_MCU_UPDATE_LONG(SR_Avg_Fund_Period_Cycle_Counter, temp_u32);
   3108          
   3109                      if(SR_Avg_Fund_Period_Cycle_Counter >= SR_Avg_Fund_Period_Cycle_Total)
   3110                      {
   3111                      	if(SR_Avg_Fund_Ignored_First == TRUE)
   3112                      	{
   3113                      		SR_DATA_MCU_UPDATE_LONG(SR_Avg_Fund_Period, SR_Avg_Fund_Period_Time_Counter);
   3114                      	}
   3115                      	else
   3116                      	{
   3117                      		SR_DATA_MCU_UPDATE_BYTE(SR_Avg_Fund_Ignored_First, TRUE);
   3118                      	}
   3119          
   3120                          SR_DATA_MCU_UPDATE_LONG(SR_Avg_Fund_Period_Cycle_Counter, 0);
   3121                          SR_DATA_MCU_UPDATE_LONG(SR_Avg_Fund_Period_Time_Counter, 0);
   3122                      }
   3123                  }
   3124              }
   3125              else if(temp_s32 < SR_Avg_Threshold)
   3126              {
   3127                  SR_DATA_MCU_UPDATE_LONG(SR_Avg_Threshold, SR_Avg_Fund_Period_High_Threshold);
   3128                  SR_DATA_MCU_UPDATE_BYTE(SR_Avg_Cross_Event, TRUE);
   3129              }
   3130          
   3131          #endif
   3132          }
   3133          
   3134          
   3135          
   3136          
   3137          /**
   3138           *  @brief      Compare the averaged speed to a threshold.
   3139           *  @details    Called every 5 ms
   3140           *  @param      None
   3141           *  @return     None - calls back the Speed Monitor with TRUE (speed above) or FALSE (speed below) threshold.
   3142           *
   3143           */
   3144          #ifdef __IAR_SYSTEMS_ICC__
   3145          #pragma inline = forced
   3146          #endif
   3147          void Check_Avg_Frequency(void)
   3148          {
   3149          #ifdef SR_BPM_MOTOR
   3150          
   3151              uint16 temp;
   3152          
   3153              SR_DATA_MCU_CHECK_LONG(SR_Avg_Fund_Period);
   3154          
   3155          
   3156              temp = SR_Motor_Flags;
   3157              temp = BIT_TEST(temp, SR_FLAG_MC_PARAMETERS_LOADED);
   3158          
   3159              if(temp) // ensure parameters are loaded
   3160              {
   3161          
   3162                  if(SR_Avg_Fund_Period < SR_MotorSafety_Params->Avg_Fund_Period_Threshold_1)
   3163                  {
   3164                      // Call back warning the frequency is above the threshold set
   3165                      SR_MOTOR_SAFETY_MGR__AVG_FREQUENCY_ABOVE_THREHOLD();
   3166                  }
   3167                  else
   3168                  {
   3169                      // Call back warning the frequency is below the threshold set
   3170                      SR_MOTOR_SAFETY_MGR__AVG_FREQUENCY_BELOW_THREHOLD();
   3171                  }
   3172              }
   3173          #else //SR_CIM_MOTOR
   3174          
   3175              // To be implemented.
   3176          
   3177          #endif
   3178          }
   3179          
   3180          
   3181          
   3182          
   3183          
   3184          //---------------------------------------------------------------------------------------------------------------------
   3185          /**
   3186           *  @brief      Update Pwm variables - shall be only used by class B part
   3187           *  @param      pwm values
   3188           *
   3189           */
   3190          #ifdef __IAR_SYSTEMS_ICC__
   3191          #pragma inline = forced
   3192          #endif
   3193          
   3194          #ifdef SR_BPM_MOTOR
   3195          void UpdatePwm(sint32 duty_a, sint32 duty_b, sint32 duty_c)
   3196          {
   3197              sint32 max_pwm;
   3198          
   3199              //! Update pwm duty cycles when protection is not activated
   3200              max_pwm = SRMotorSafetyMgr__GetMaxPwm();
   3201          
   3202              duty_a = (max_pwm * duty_a)>>15;
   3203              duty_b = (max_pwm * duty_b)>>15;
   3204              duty_c = (max_pwm * duty_c)>>15;
   3205          
   3206              SRMCPWM__LOADALLPWMVALUES(duty_a, duty_b, duty_c);
   3207          }
   3208          #endif
   3209          
   3210          #ifdef SR_THIRD_CURRENT_RECONSTRUCTION
   3211          //---------------------------------------------------------------------------------------------------------------------
   3212          /**
   3213           *  @brief      Update ADC configuration according to duty-cycle pattern
   3214           *  @details    The ADC is configured so that the two currents corresponding to the
   3215           *              shortest duties are sampled on the first trigger event
   3216           *  @param
   3217           *
   3218           */
   3219          #ifdef __IAR_SYSTEMS_ICC__
   3220          #pragma inline = forced
   3221          #endif
   3222          void UpdateAdcConfig()
   3223          {
   3224              sint32 temp_s32;
   3225              uint16 index;   
   3226              sint32 b;
   3227              sint32 c;
   3228              if(SR_SafetyMngr_State != SAFETY_MNGR_PRERUN_TESTS)  // in prerun we must not touch the ADC configuration
   3229              {
   3230                  // Reconfigure ADC connections according to sector for third current reconstruction strategy
   3231                  if (SR_SafetyMngr_State != SAFETY_MNGR_RUNNING)
   3232                  {   // read all currents for correct offset update
   3233                      index = 0;
   3234                  }
   3235                  else
   3236                  {
   3237                      // calculate the index of the current corresponding to the longest duty (SR_sector)
   3238                      b = SRMCPWM__GET_PWM_B();
   3239                      c = SRMCPWM__GET_PWM_C();
   3240          
   3241                      temp_s32 = SRMCPWM__GET_PWM_A();
   3242                      index = 1;
   3243          
   3244                      if (b > temp_s32)
   3245                      {
   3246                          temp_s32 = b;
   3247                          index = 2;
   3248                      }
   3249          
   3250                      if (c > temp_s32)
   3251                      {
   3252                          index = 3;
   3253                      }
   3254                  }
   3255          
   3256                  SR_Sector = index;
   3257                  SR_MCU_MOTOR_UPDATE_N_VAR(SR_Sector);
   3258          
   3259                  // and reconfigure ADC accordingly
   3260                  switch (SR_Sector)
   3261                  {
   3262                      case 1:
   3263                          SRMCATOD__SETADC2_REC1();
   3264                          SRMCATOD__SETADC3_REC1();
   3265                          break;
   3266          
   3267                      case 2:
   3268                          SRMCATOD__SETADC1_REC2();
   3269                          SRMCATOD__SETADC3_REC2();
   3270                          break;
   3271          
   3272                      case 3:
   3273                          SRMCATOD__SETADC1_REC3();
   3274                          SRMCATOD__SETADC2_REC3();
   3275                          break;
   3276          
   3277                      default:
   3278                          SRMCATOD__SETADC1_DEFAULT();
   3279                          SRMCATOD__SETADC2_DEFAULT();
   3280                          SRMCATOD__SETADC3_DEFAULT();
   3281                          SRMCATOD__SETDCBUSVOLTAGE_DEFAULT();
   3282                          break;
   3283                  }
   3284              }
   3285          }
   3286          #endif
   3287          
   3288          
   3289          
   3290          //---------------------------------------------------------------------------------------------------------------------
   3291          /**
   3292           *  @brief      Set a bit fault in the fault and fault holder registers and deny access from class A.
   3293           *  @param[in]  error bit - refer to the SR_MOTOR_FAULT_LIST_TYPE for the bit definition
   3294           *
   3295           */
   3296          void SetFault(uint16 fault)
   3297          {
   3298          	uint16 temp_u16;
   3299          
   3300          	temp_u16 = SR_Motor_Fault;
   3301          	BIT_SET(temp_u16, fault);
   3302          	SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Fault, temp_u16);
   3303          
   3304          	temp_u16 = SR_Motor_Fault_Holder;
   3305          	BIT_SET(temp_u16, fault);
   3306          	SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Fault_Holder, temp_u16);
   3307          }
   3308          
   3309          
   3310          
   3311          
   3312          //---------------------------------------------------------------------------------------------------------------------
   3313          /**
   3314           *  @brief      Only clears the bit fault in the fault register.
   3315           *  @param[in]  error bit - refer to the SR_MOTOR_FAULT_LIST_TYPE for the bit definition
   3316           *
   3317           */
   3318          void ClearFault(uint16 fault)
   3319          {
   3320          	uint16 temp_fault;
   3321          	temp_fault = SR_Motor_Fault;
   3322          	BIT_CLR(temp_fault, (fault));
   3323          	SR_DATA_MCU_UPDATE_SHORT(SR_Motor_Fault, temp_fault);
   3324          }
   3325          
   3326          
   3327          
   3328          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Braking__DqRefHandler
       0   Braking__Initialize
       0   Braking__ResetState
       0   Braking__SpeedCtrlHandler
       0   ClrkPark__DirectClarke
       0   ClrkPark__DirectClarkeF
      12   ClrkPark__DirectPark
       0   ClrkPark__DirectParkF
       0   ClrkPark__InverseClarke
       0   ClrkPark__InverseClarkeF
      12   ClrkPark__InversePark
       0   ClrkPark__InverseParkF
       0   Delta_Speed_Handler
      40   Estimate_Stator_Resistance
        40   -> MathCalc__SinCosF
        40   -> MclDqCtrl__RunningHandler
        40   -> MclInputProc__RunningHandler
        40   -> MclObserver__RunningHandler
        40   -> MclPwm__RunningHandler
        40   -> ResistanceEstimation__Calculate
        40   -> ThermalModel__SetStatorTemperature
       8   Filters__FIRFilter
       0   Filters__IIR1
       0   Filters__IIR1F
       0   Filters__IIR1Init
       0   Filters__IIR1InitF
      12   Filters__MovAvgUShort
      12   Filters__MovingAverageShort
       0   Filters__SimpleLpf
         0 __aeabi_lasr
      16   Inductance_Correction
        16   -> MathCalc__GetInterpolationFastF
      24   Manual_Injection_Control
        24   -> MathCalc__SinCosF
        24   -> MclDqCtrl__RunningHandler
        24   -> MclInputProc__RunningHandler
        24   -> MclObserver__RunningHandler
        24   -> MclPwm__RunningHandler
      12   MathCalc__Arctan2
       0   MathCalc__Arctan2F
         0   -> atan2f
       0   MathCalc__Cos
       0   MathCalc__CosF
       0   MathCalc__CountLeadingBitsOnSigned
       0   MathCalc__CountLeadingBitsOnUnsigned
      12   MathCalc__GetInterpolation
      16   MathCalc__GetInterpolation2
       8   MathCalc__GetInterpolation2Fast
       8   MathCalc__GetInterpolationFast
       0   MathCalc__GetInterpolationFastF
       0   MathCalc__GetSinCos
       0   MathCalc__GetSinCosF
       4   MathCalc__Interpolate
       0   MathCalc__Sin
      12   MathCalc__SinCos
       0   MathCalc__SinCosF
      12   MathCalc__SinCosLut
       0   MathCalc__SinF
       0   MathCalc__SqrtF
       8   MathCalc__SqrtFloat
         8   -> sqrtf
       0   MathCalc__SqrtLut
       0   MathCalc__SqrtNwtRph
       0   MathCalc__f_Interpolate
      16   MathCalc__f_SinCos
        16   -> __iar_FSin
       0   Mci__1msHandler
         0   -> Mcl__1msHandler
       8   Mci__250usHandler
         8   -> BoardDebugging__250usHandler
         0   -> Mcl__250usHandler
       8   Mci__25msHandler
         8   -> BoardDebugging__25msHandler
         0   -> Mcl__25msHandler
         8   -> SurgeRelay__25msHandler
      16   Mci__5msHandler
        16   -> Mcl__GetDigital
         0   -> Running_Parallel_5msHandler
        16   -> SRData__CheckShort
        16   -> SpeedRefGen__GetStatus
       0   Mci__ClearError
       0   Mci__FvtGetResult
         0   -> MclFvt__GetResult
       0   Mci__FvtGetStatus
       0   Mci__FvtStart
       8   Mci__FvtStop
         8   -> SRData__CheckShort
         8   -> SRData__UpdateShort
         8   -> SRMotorSafetyMgr__Prepare2StopMotor
       0   Mci__GetAnalog
       0   Mci__GetDigital
       0   Mci__GetDigitalList
       0   Mci__GetError
       0   Mci__GetErrorList
       0   Mci__HallHandler
       8   Mci__Initialize
         8   -> BoardDebugging__Initialize
         8   -> Gpio__PinConfig
         8   -> Gpio__PinWrite
         8   -> Mcl__Initialize
      16   Mci__Manual_Injection
      24   Mci__PwmHandler
         0   -> BoardDebugging__PwmHandler
        24   -> Estimate_Stator_Resistance
        24   -> MclFvt__Entry
        24   -> MclFvt__PwmHandler
        24   -> MclObserver__ResetState
        24   -> MclSpeedCtrl__ResetState
        24   -> Mcl__GetDigital
        24   -> Mcl__ResetAll
        24   -> Mcl__RunningHandler
        24   -> Mcl__RunningReset
        24   -> Mcl__StoppingHandler
        24   -> SRData__CheckByte
        24   -> SRData__CheckShort
        24   -> SRMotorSafetyMgr__Prepare2StartMotor
        24   -> SRMotorSafetyMgr__Prepare2StopMotor
        24   -> SpeedRefGen__Generator
      12   Mci__Run
       0   Mci__SetAnalog
       0   Mci__SetDigital
       0   Mci__SetParams
         0   -> Mcl__SetParams
       8   Mci__Stop
         8   -> SRData__CheckShort
         8   -> SRData__UpdateShort
         8   -> SRMotorSafetyMgr__Prepare2StopMotor
       0   MclDqCtrl__25msHandler
         0   -> Torque_Flux_Gains_Scheduler
       0   MclDqCtrl__Initialize
       0   MclDqCtrl__OverrideRegGains
       0   MclDqCtrl__ResetState
      16   MclDqCtrl__RunningHandler
        16   -> Pi__CalcPiF
      16   MclDqRef__1msHandler
        16   -> Braking__DqRefHandler
       0   MclDqRef__Initialize
       0   MclDqRef__ResetState
      24   MclDqRef__RunningHandler
        24   -> MathCalc__GetInterpolationFastF
       0   MclFvt__Entry
       0   MclFvt__Exit
       0   MclFvt__GetResult
       0   MclFvt__GetStatus
       0   MclFvt__GuardCondition
      56   MclFvt__PwmHandler
        56   -> MathCalc__SinCosF
        56   -> Mci__GetAnalog
        56   -> MclDqCtrl__RunningHandler
        56   -> MclInputProc__RunningHandler
        56   -> MclPwm__RunningHandler
        56   -> SRData__CheckShort
       0   MclInputProc__1msRunningHandler
       0   MclInputProc__Initialize
       0   MclInputProc__ResetState
       0   MclInputProc__RunningHandler
      24   MclObserver__1msHandler
        24   -> Inductance_Correction
        24   -> MathCalc__GetInterpolationFastF
        24   -> Resistance_Adaptation
      16   MclObserver__Initialize
        16   -> Inductance_Correction
        16   -> MclObserver__ResetState
       8   MclObserver__ResetState
      72   MclObserver__RunningHandler
        72   -> MathCalc__GetSinCosF
       0   MclPwm__25msHandler
       0   MclPwm__Initialize
       0   MclPwm__ResetState
       8   MclPwm__RunningHandler
         0   -> PwmModulation__DeadtimeCompensationGradientF
         0   -> PwmModulation__InverterLossCompF
       8   MclSpeedCtrl__1msHandler
         8   -> Braking__SpeedCtrlHandler
       8   MclSpeedCtrl__25msHandler
         8   -> Speed_Gain_Scheduler
       0   MclSpeedCtrl__Initialize
       0   MclSpeedCtrl__ResetState
      24   MclSpeedCtrl__RunningHandler
        24   -> MathCalc__GetInterpolationFastF
        24   -> Pi__CalcPiF
       0   MclSpeedCtrl__SetDeltaSpeedRef
       0   MclSpeedCtrl__SetSpeedGainIndex
       0   MclSpeedCtrl__SetSpeedRegLimit
       8   Mcl__1msHandler
         8   -> Braking__SpeedCtrlHandler
         0   -> MclDqRef__1msHandler
         8   -> MclInputProc__1msRunningHandler
         8   -> MclObserver__1msHandler
      16   Mcl__250usHandler
        16   -> SRData__CheckShort
       8   Mcl__25msHandler
         8   -> Speed_Gain_Scheduler
         8   -> ThermalModel__GetStatorTemperature
         8   -> ThermalModel__Handler25ms
         8   -> TimerDefinition
         8   -> Torque_Flux_Gains_Scheduler
       0   Mcl__5msHandler
         0   -> Running_Parallel_5msHandler
       4   Mcl__GetDigital
       8   Mcl__Initialize
         8   -> MclObserver__ResetState
         8   -> MclSpeedCtrl__ResetState
         8   -> Mcl__RunningReset
         8   -> ThermalModel__Initialize
       0   Mcl__ManualHandler
         0   -> Manual_Injection_Control
       0   Mcl__ManualReset
       8   Mcl__ParamsInitialize
         8   -> MclDqCtrl__ResetState
         8   -> MclObserver__Initialize
         8   -> ResistanceEstimation__Initialize
       8   Mcl__ResetAll
         8   -> MclDqCtrl__ResetState
         8   -> MclObserver__ResetState
         8   -> MclSpeedCtrl__ResetState
         8   -> Mcl__RunningReset
       0   Mcl__ResetDigital
       8   Mcl__RunningHandler
         8   -> MclDqCtrl__RunningHandler
         8   -> MclDqRef__RunningHandler
         8   -> MclInputProc__RunningHandler
         8   -> MclObserver__RunningHandler
         0   -> MclPwm__RunningHandler
         8   -> MclSpeedCtrl__RunningHandler
         8   -> SpeedRefGen__GetStatus
       8   Mcl__RunningReset
         8   -> MclDqCtrl__ResetState
         8   -> MclObserver__ResetState
         8   -> MclPwm__ResetState
         8   -> MclSpeedCtrl__ResetState
       0   Mcl__SetAnalog
       0   Mcl__SetDigital
       8   Mcl__SetParams
         8   -> Mcl__ParamsInitialize
       8   Mcl__StartingHandler
         8   -> Estimate_Stator_Resistance
       0   Mcl__StartingReset
       0   Mcl__StoppingHandler
       8   Mcl__StoppingReset
         0   -> MclObserver__ResetState
         8   -> MclSpeedCtrl__ResetState
      16   MotorMovingHandlerBpm
        16   -> SRData__CheckByte
        16   -> SRData__UpdateLong
         0   -> SRData__UpdateShort
        16   -> SRData__UpdateShort
        16   -> SRException__Queue
        16   -> SRMCPwm__EnableDiagnostic
        16   -> SRMCPwm__GetDiagnosticFeedback
       0   Pi__CalcPiBackCalcF
       0   Pi__CalcPiF
      16   Pi__CalcPiQ30
      24   Pi__CalcPiQ30_new
        24 __aeabi_llsl
      40   Pi__CalcPiQ60
        40 __aeabi_lasr
        40 __aeabi_llsl
      32   Pi__CalcPiQ60_new
        32 __aeabi_lasr
        32 __aeabi_llsl
       0   Pi__InitPiQ30
       0   Pi__InitPiQ60
       0   Pi__Initialize
       0   Pi__IntegBE
      20   Pi__IntegBESat
        20 __aeabi_lasr
      36   Pi__PiRegBackCalc
        36 __aeabi_lasr
      32   Pi__PiRegBackCalc_FixedGains
      48   Pi__PiRegBackCalc_FloatGains
        48   -> __aeabi_f2lz
      28   Pi__PiRegClamp
        28 __aeabi_lasr
      28   Pi__PiRegNoAntiWindup
        28 __aeabi_lasr
       0   Pi__PiRegNoAntiWindupF
       0   PwmModulation__DeadtimeCompensationGradientF
       0   PwmModulation__DeadtimeCompensationGradient_v2
      24   PwmModulation__InverterLossCompF
        24   -> MathCalc__GetInterpolationFastF
      24   PwmModulation__InverterLossComp_v2
        24   -> MathCalc__GetInterpolationFast
       0   PwmModulation__SpaceVectorModulationF
       0   PwmModulation__SpaceVectorModulationRectangular
       0   PwmModulation__SpaceVectorModulationRectangularF
      32   PwmModulation__SpaceVectorModulationSixSteps
        32   -> MathCalc__SinF
        32   -> asinf
      12   PwmModulation__SpaceVectorModulation_v2
      24   RcThermalUpdate
        24   -> SRData__CheckByte
        24   -> SRData__CheckFloat
        24   -> SRData__CheckLong
         0   -> SRData__UpdateFloat
        24   -> SRData__UpdateFloat
       0   ResetQuantities
      28   ResistanceEstimation__Calculate
       0   ResistanceEstimation__GetResistance
       0   ResistanceEstimation__Handler25ms
         0   -> TimerDefinition
       0   ResistanceEstimation__Initialize
       0   ResistanceEstimation__IsResBeenUpdated
       0   ResistanceEstimation__Requested
       0   ResistanceEstimation__Start
       0   Resistance_Adaptation
       0   RotorFlux_Correction
       0   Running_Parallel_5msHandler
      24   SRInitializeAD0
        24   -> Micro__NVICDisableIRQ
        24   -> Micro__Trap
      24   SRInitializeAD1
        24   -> Micro__NVICDisableIRQ
         0   -> Micro__NVICEnableIRQ
        24   -> Micro__Trap
      24   SRMCAtod__DiagnosticHandler
        24   -> SRData__CheckByte
        24   -> SRData__CheckShort
         0   -> SRData__UpdateByte
        24   -> SRData__UpdateByte
      16   SRMCAtod__EnableDiagnostic
        16   -> SRData__CheckByte
        16   -> SRData__CheckShort
         0   -> SRData__UpdateByte
        16   -> SRData__UpdateShort
      16   SRMCAtod__GetDiagnosticFeedback
        16   -> SRData__CheckByte
        16   -> SRData__UpdateByte
       0   SRMCAtod__ISR
         0   -> SRMotorSafetyMgr__MCPwmHandler
       8   SRMCAtod__Initialize
         8   -> Micro__NVICDisableIRQ
         8   -> Micro__NVICEnableIRQ
         8   -> SRData__UpdateByte
         8   -> SRData__UpdateShort
         8   -> SRInitializeAD0
         8   -> SRInitializeAD1
       0   SRMCPDB__ISR
      24   SRMCPwm__DiagnosticHandler
        24   -> Comparator__SetThr
        24   -> SRData__CheckByte
        24   -> SRData__CheckLong
         0   -> SRData__UpdateByte
        24   -> SRData__UpdateByte
         0   -> SRData__UpdateLong
        24   -> SRData__UpdateLong
       0   SRMCPwm__DisablePwmOutput
      24   SRMCPwm__EnableDiagnostic
        24   -> SRData__CheckByte
        24   -> SRData__CheckLong
         0   -> SRData__UpdateByte
        24   -> SRData__UpdateLong
       0   SRMCPwm__EnablePwmOutput
       0   SRMCPwm__GetDeadtimeNanosec
      16   SRMCPwm__GetDiagnosticFeedback
        16   -> SRData__CheckByte
        16   -> SRData__UpdateByte
      16   SRMCPwm__GetHwFaultStatus
        16   -> SRData__CheckByte
       0   SRMCPwm__GetMaxPwm
       0   SRMCPwm__GetPwmFrequencyHz
       0   SRMCPwm__Handler250us
      48   SRMCPwm__Initialize
        48   -> Comparator__Config
        48   -> Micro__GetClock
         0   -> SRData__UpdateByte
        48   -> SRData__UpdateByte
        48   -> SRData__UpdateLong
       0   SRMCPwm__Initialize_Before_Boot
       0   SRMCPwm__LoadAllPwmValues
       0   SRMCPwm__PwmISR
       0   SRMCPwm__StartCounter
       0   SRMCPwm__StopCounter
       0   SRMCPwm__TurnOffAllGates
       0   SRMCPwm__TurnOffHighSideGates
       0   SRMCPwm__TurnOffLowSideGates
       0   SRMCPwm__TurnOnHighSideGates
       0   SRMCPwm__TurnOnLowSideGates
       8   SRMotorSafetyMgr__AnyFaultFound
         8   -> SRData__CheckShort
      16   SRMotorSafetyMgr__ConfigPwmPattern
        16   -> SRData__CheckShort
       8   SRMotorSafetyMgr__ForceStop
         8   -> SRData__CheckShort
         8   -> SRData__UpdateShort
         0   -> SRMotorSafetyMgr__Prepare2StopMotor
      16   SRMotorSafetyMgr__GetFault
        16   -> SRData__CheckShort
      16   SRMotorSafetyMgr__GetFaultHolder
        16   -> SRData__CheckShort
      16   SRMotorSafetyMgr__GetFlag
        16   -> SRData__CheckShort
      16   SRMotorSafetyMgr__GetListedError
        16   -> SRData__CheckShort
       0   SRMotorSafetyMgr__GetMaxPwm
       8   SRMotorSafetyMgr__GetMotorTemperature
         8   -> SRData__CheckFloat
       8   SRMotorSafetyMgr__GetSquaredCurrents
         8   -> SRData__CheckFloat
       8   SRMotorSafetyMgr__GetVoltageFrequency
         8   -> SRData__CheckFloat
       8   SRMotorSafetyMgr__Handler1ms
         0   -> SRFlow__ISRLogEvent
         8   -> SRFlow__ISRLogEvent
      24   SRMotorSafetyMgr__Handler250us
        24   -> SRData__CheckByte
        24   -> SRData__CheckLong
        24   -> SRData__CheckShort
        24   -> SRData__UpdateByte
        24   -> SRData__UpdateLong
        24   -> SRData__UpdateShort
         0   -> SRFlow__ISRLogEvent
        24   -> SRFlow__ISRLogEvent
       8   SRMotorSafetyMgr__Handler25ms
         8   -> Crc16__RangeProcess
         8   -> RcThermalUpdate
         8   -> SRData__CheckByte
         8   -> SRData__CheckFloat
         8   -> SRData__CheckLong
         8   -> SRData__CheckShort
         8   -> SRData__UpdateFloat
         8   -> SRData__UpdateShort
         8   -> SRException__Queue
         0   -> SRFlow__MainLogEvent
         8   -> SRFlow__MainLogEvent
      16   SRMotorSafetyMgr__Handler5ms
        16   -> MotorMovingHandlerBpm
        16   -> SRData__CheckByte
        16   -> SRData__CheckLong
        16   -> SRData__CheckShort
        16   -> SRData__UpdateByte
        16   -> SRData__UpdateLong
        16   -> SRData__UpdateShort
        16   -> SRException__Queue
         0   -> SRFlow__MainLogEvent
        16   -> SRFlow__MainLogEvent
        16   -> SRMCPwm__EnableDiagnostic
      16   SRMotorSafetyMgr__Initialize
        16   -> Mci__Initialize
        16   -> SRData__CheckByte
        16   -> SRData__CheckLong
        16   -> SRData__UpdateByte
        16   -> SRData__UpdateFloat
        16   -> SRData__UpdateLong
        16   -> SRData__UpdateShort
         0   -> SRFlow__InitLogEvent
        16   -> SRFlow__InitLogEvent
        16   -> SRMCAtod__Initialize
        16   -> SRMCPwm__Initialize
       8   SRMotorSafetyMgr__IsInIdle
         8   -> SRData__CheckByte
      32   SRMotorSafetyMgr__MCPwmHandler
        32   -> Mci__PwmHandler
        32   -> SRData__UpdateLong
        32   -> SRData__UpdateShort
        32   -> SRException__Queue
        32   -> SRIsrMonitor__EnterIsr
         0   -> SRIsrMonitor__ExitIsr
        32   -> SRMCAtod__DiagnosticHandler
        32   -> SRMCAtod__GetDiagnosticFeedback
        32   -> SRMCPwm__DiagnosticHandler
        32   -> SRMCPwm__GetDiagnosticFeedback
       8   SRMotorSafetyMgr__Prepare2StartMotor
         8   -> SRData__CheckByte
         8   -> SRData__CheckShort
         8   -> SRData__UpdateShort
      16   SRMotorSafetyMgr__Prepare2StopMotor
        16   -> SRData__CheckByte
        16   -> SRData__CheckShort
        16   -> SRData__UpdateShort
       8   SRMotorSafetyMgr__SR_SquaredCurrentRmsA
         8   -> SRData__CheckLong
       8   SRMotorSafetyMgr__SR_SquaredCurrentRmsB
         8   -> SRData__CheckLong
       8   SRMotorSafetyMgr__SR_SquaredCurrentRmsC
         8   -> SRData__CheckLong
      16   SRMotorSafetyMgr__SetParams
        16   -> Crc16__RangeProcess
        16   -> SRData__CheckShort
        16   -> SRData__UpdateFloat
        16   -> SRData__UpdateShort
        16   -> SRException__Queue
      24   SRMotorSafetyMgr__UpdatePwm
        24   -> SRData__CheckShort
       0   SpeedRefGen__ApplyDefaultAccel
       0   SpeedRefGen__Generator
       0   SpeedRefGen__GetSpeedRef
       0   SpeedRefGen__GetSpeedRefIQ
       0   SpeedRefGen__GetSpeedTarget
       0   SpeedRefGen__GetSpeedTargetIQ
       0   SpeedRefGen__GetStatus
       0   SpeedRefGen__Initialize
       0   SpeedRefGen__Reset
       0   SpeedRefGen__SetNewSpeed
       0   SpeedRefGen__SetSpeedParams
      12   Speed_Gain_Scheduler
      16   SurgeRelay__25msHandler
         0   -> Gpio__PinWrite
        16   -> Gpio__PinWrite
        16   -> Mci__GetAnalog
       0   SurgeRelay__Action
         0   -> Gpio__PinWrite
       8   SurgeRelay__Initialize
         8   -> Gpio__PinConfig
         0   -> Gpio__PinWrite
       0   SurgeRelay__IsBusReady
       0   TimerDefinition
      16   Torque_Flux_Gains_Scheduler


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable104
       4  ??DataTable104_1
       4  ??DataTable104_2
       4  ??DataTable104_3
       4  ??DataTable104_4
       4  ??DataTable104_5
       4  ??DataTable104_6
       4  ??DataTable104_7
       4  ??DataTable106
       4  ??DataTable106_1
       4  ??DataTable107
       4  ??DataTable11
       4  ??DataTable110
       4  ??DataTable112
       4  ??DataTable113
       4  ??DataTable113_1
       4  ??DataTable113_2
       4  ??DataTable113_3
       4  ??DataTable114
       4  ??DataTable114_1
       4  ??DataTable114_2
       4  ??DataTable114_3
       4  ??DataTable115
       4  ??DataTable115_1
       4  ??DataTable117
       4  ??DataTable119
       4  ??DataTable119_1
       4  ??DataTable119_2
       4  ??DataTable119_3
       4  ??DataTable119_4
       4  ??DataTable119_5
       4  ??DataTable119_6
       4  ??DataTable119_7
       4  ??DataTable119_8
       4  ??DataTable119_9
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable121
       4  ??DataTable123
       4  ??DataTable127
       4  ??DataTable13
       4  ??DataTable133
       4  ??DataTable134
       4  ??DataTable136
       4  ??DataTable139
       4  ??DataTable139_1
       4  ??DataTable140
       4  ??DataTable146
       4  ??DataTable15
       4  ??DataTable156
       4  ??DataTable158
       4  ??DataTable158_1
       4  ??DataTable159
       4  ??DataTable15_1
       4  ??DataTable162
       4  ??DataTable164
       4  ??DataTable164_1
       4  ??DataTable164_2
       4  ??DataTable164_3
       4  ??DataTable164_4
       4  ??DataTable164_5
       4  ??DataTable164_6
       4  ??DataTable165
       4  ??DataTable166
       4  ??DataTable166_1
       4  ??DataTable166_2
       4  ??DataTable166_3
       4  ??DataTable167
       4  ??DataTable167_1
       4  ??DataTable167_10
       4  ??DataTable167_11
       4  ??DataTable167_12
       4  ??DataTable167_13
       4  ??DataTable167_14
       4  ??DataTable167_15
       4  ??DataTable167_2
       4  ??DataTable167_3
       4  ??DataTable167_4
       4  ??DataTable167_5
       4  ??DataTable167_6
       4  ??DataTable167_7
       4  ??DataTable167_8
       4  ??DataTable167_9
       4  ??DataTable168
       4  ??DataTable169
       4  ??DataTable169_1
       4  ??DataTable169_2
       4  ??DataTable169_3
       4  ??DataTable169_4
       4  ??DataTable191
       4  ??DataTable192
       4  ??DataTable192_1
       4  ??DataTable192_2
       4  ??DataTable192_3
       4  ??DataTable192_4
       4  ??DataTable192_5
       4  ??DataTable192_6
       4  ??DataTable24
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable25_3
       4  ??DataTable25_4
       4  ??DataTable26
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable35
       4  ??DataTable36
       4  ??DataTable37
       4  ??DataTable37_1
       4  ??DataTable37_2
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable38_2
       4  ??DataTable39
       4  ??DataTable42
       4  ??DataTable43
       4  ??DataTable45
       4  ??DataTable46
       4  ??DataTable46_1
       4  ??DataTable46_2
       4  ??DataTable46_3
       4  ??DataTable46_4
       4  ??DataTable46_5
       4  ??DataTable46_6
       4  ??DataTable46_7
       4  ??DataTable47
       4  ??DataTable47_1
       4  ??DataTable47_2
       4  ??DataTable47_3
       4  ??DataTable48
       4  ??DataTable49
       4  ??DataTable50
       4  ??DataTable51
       4  ??DataTable51_1
       4  ??DataTable55
       4  ??DataTable55_1
       4  ??DataTable55_2
       4  ??DataTable55_3
       4  ??DataTable56
       4  ??DataTable56_1
       4  ??DataTable56_2
       4  ??DataTable58
       4  ??DataTable59
       4  ??DataTable59_1
       4  ??DataTable59_2
       4  ??DataTable59_3
       4  ??DataTable59_4
       4  ??DataTable62
       4  ??DataTable62_1
       4  ??DataTable62_2
       4  ??DataTable64
       4  ??DataTable64_1
       4  ??DataTable64_2
       4  ??DataTable64_3
       4  ??DataTable65
       4  ??DataTable66
       4  ??DataTable66_1
       4  ??DataTable66_2
       4  ??DataTable66_3
       4  ??DataTable66_4
       4  ??DataTable66_5
       4  ??DataTable66_6
       4  ??DataTable66_7
       4  ??DataTable66_8
       4  ??DataTable66_9
       4  ??DataTable67
       4  ??DataTable68
       4  ??DataTable68_1
       4  ??DataTable68_2
       4  ??DataTable69
       4  ??DataTable70
       4  ??DataTable70_1
       4  ??DataTable70_2
       4  ??DataTable70_3
       4  ??DataTable70_4
       4  ??DataTable72
       4  ??DataTable72_1
       4  ??DataTable72_2
       4  ??DataTable75
       4  ??DataTable75_1
       4  ??DataTable75_2
       4  ??DataTable75_3
       4  ??DataTable76
       4  ??DataTable76_1
       4  ??DataTable76_2
       4  ??DataTable76_3
       4  ??DataTable76_4
       4  ??DataTable76_5
       4  ??DataTable76_6
       4  ??DataTable76_7
       4  ??DataTable82
       4  ??DataTable86
       4  ??DataTable86_1
       4  ??DataTable86_2
       4  ??DataTable86_3
       4  ??DataTable86_4
       4  ??DataTable90
       4  ??DataTable91
       4  ??DataTable92
       4  ??DataTable92_1
       4  ??DataTable92_2
       4  ??DataTable94
       4  ??DataTable94_1
       4  ??DataTable95
       4  ??DataTable96
       4  ??DataTable96_1
       4  ??DataTable96_2
       4  ??DataTable96_3
       4  ??DataTable96_4
       4  Braking_Resistance
     320  Braking__DqRefHandler
      28  Braking__Initialize
      20  Braking__ResetState
     348  Braking__SpeedCtrlHandler
       2  Bus_Voltage
       2  CHECK_UNLOCK_DOOR_CURRENT_THRESHOLDS_COUNTS
       4  CHECK_UNLOCK_DOOR_MAX_VOLTAGE_COUNTS
       4  CHECK_UNLOCK_DOOR_MAX_VOLTAGE_DUTY_STEP_COUNTS
       4  CHECK_UNLOCK_DOOR_SPEED_IDLING_BEFORE_CHECK_COUNT
       4  CHECK_UNLOCK_DOOR_SPEED_TIMEOUT_COUNTER
      44  ClrkPark__DirectClarke
      70  ClrkPark__DirectClarkeF
      40  ClrkPark__DirectPark
      62  ClrkPark__DirectParkF
      64  ClrkPark__InverseClarke
      82  ClrkPark__InverseClarkeF
      40  ClrkPark__InversePark
      62  ClrkPark__InverseParkF
      24  Delta_Speed_Handler
     356  Estimate_Stator_Resistance
      80  Filters__FIRFilter
      58  Filters__IIR1
      46  Filters__IIR1F
       8  Filters__IIR1Init
       8  Filters__IIR1InitF
     138  Filters__MovAvgUShort
     138  Filters__MovingAverageShort
      14  Filters__SimpleLpf
       2  Forced_Gain_Timeout
       4  Id_Braking_Target
      90  Inductance_Correction
       4  Inv_Temp_LUT_X_Inv_Step_Mitsubishi
       4  Inv_Temp_LUT_X_Inv_Step_ST
      32  Inverter_Temp_LUT_Ext_Array
      24  Inverter_Temp_LUT_Mitsubishi
    1208  Inverter_Temp_LUT_ST
       4  Last_Mech_Rotor_Pos
     790  Manual_Injection_Control
     262  MathCalc__Arctan2
      16  MathCalc__Arctan2F
      88  MathCalc__Cos
     120  MathCalc__CosF
      20  MathCalc__CountLeadingBitsOnSigned
       6  MathCalc__CountLeadingBitsOnUnsigned
      82  MathCalc__GetInterpolation
     136  MathCalc__GetInterpolation2
     122  MathCalc__GetInterpolation2Fast
      74  MathCalc__GetInterpolationFast
     104  MathCalc__GetInterpolationFastF
     116  MathCalc__GetSinCos
     254  MathCalc__GetSinCosF
      32  MathCalc__Interpolate
      82  MathCalc__Sin
     172  MathCalc__SinCos
     152  MathCalc__SinCosF
      84  MathCalc__SinCosLut
     134  MathCalc__SinF
      22  MathCalc__SqrtF
      28  MathCalc__SqrtFloat
      56  MathCalc__SqrtLut
      32  MathCalc__SqrtNwtRph
      42  MathCalc__f_Interpolate
      58  MathCalc__f_SinCos
       4  Max_Delta_Rpm
       4  Max_Joule_Loss
       4  Mci__1msHandler
      18  Mci__250usHandler
      22  Mci__25msHandler
    1070  Mci__5msHandler
      34  Mci__ClearError
      12  Mci__FvtGetResult
      34  Mci__FvtGetStatus
     182  Mci__FvtStart
      90  Mci__FvtStop
     268  Mci__GetAnalog
      82  Mci__GetDigital
      22  Mci__GetDigitalList
     386  Mci__GetError
      24  Mci__GetErrorList
       2  Mci__HallHandler
     128  Mci__Initialize
     348  Mci__Manual_Injection
    2630  Mci__PwmHandler
     306  Mci__Run
     202  Mci__SetAnalog
       4  Mci__SetDigital
       4  Mci__SetParams
     268  Mci__Stop
       4  MclDqCtrl__25msHandler
      74  MclDqCtrl__Initialize
      30  MclDqCtrl__OverrideRegGains
      74  MclDqCtrl__ResetState
     444  MclDqCtrl__RunningHandler
      76  MclDqRef__1msHandler
      14  MclDqRef__Initialize
      28  MclDqRef__ResetState
     776  MclDqRef__RunningHandler
     122  MclFvt__Entry
      14  MclFvt__Exit
     212  MclFvt__GetResult
      34  MclFvt__GetStatus
      18  MclFvt__GuardCondition
     750  MclFvt__PwmHandler
     132  MclInputProc__1msRunningHandler
      10  MclInputProc__Initialize
       2  MclInputProc__ResetState
     286  MclInputProc__RunningHandler
     218  MclObserver__1msHandler
      74  MclObserver__Initialize
     338  MclObserver__ResetState
    1504  MclObserver__RunningHandler
      78  MclPwm__25msHandler
      30  MclPwm__Initialize
     102  MclPwm__ResetState
     476  MclPwm__RunningHandler
      22  MclSpeedCtrl__1msHandler
      36  MclSpeedCtrl__25msHandler
     124  MclSpeedCtrl__Initialize
      94  MclSpeedCtrl__ResetState
     356  MclSpeedCtrl__RunningHandler
      82  MclSpeedCtrl__SetDeltaSpeedRef
      42  MclSpeedCtrl__SetSpeedGainIndex
      64  MclSpeedCtrl__SetSpeedRegLimit
    2052  Mcl_Quantities
          Mcl_Cs
          Mcl_IO
          MclObserver_Params
          Mcl_DQ_Ctrl_IO
          Mcl_Observer_IO
          MclFvt_Data_Test_Dc_Current
          Mcl_Input_Proc_IO
          Mcl_DQ_Ref_IO
          Flux_Controller
          Torque_Controller
          Speed_Controller
          Load_Angle_Limiter
          Mcl_Pwm_IO
          Mcl_Speed_Ctrl_IO
          MclSpeedCtrl_Params
          MclDqRef_Params
          MclPwm_Params
          Res_Est_IO
          Mci_Control_State
          pwm_post_scaler
          time_postscaler
          Mcl_Starting_State
          Mcl_Flow_Manager
          switching_angle
          My_WbLim_Flag
          My_Mflux_Flag
          window_avg
          Inverter_Compensation_Selector
          Pwm_Sector
          Forced_Gain_Selector
          My_TqLim_Flag
          MclFvt_Step
          MclFvt_State
          MclFvt_Status
          MclFvt_Error_List
          fvt_debug_averaging
          Res_Measure_Rate_State
          Res_Est_State
          Res_Frequency_Counter
          Res_Frequency_Counter_Spin
          Time_Prescaler
          Apply_Default_Accel
          Surge_State
          Bus_Voltage_Timer
          SR_State
          SR_Fault_Holder
          SR_MCPwm_Diag_State
          SR_MCPwm_Errors
          SR_SafetyMngr_State
          NSR_SafetyMngr_State
          SR_Avg_Fund_Period_Cycle_Total
          SR_Avg_Cross_Event
          SR_Avg_Fund_Ignored_First
          NSR_Avg_Fund_Period_Cycle_Total
          NSR_Avg_Cross_Event
          pwm_post_scaler
          Mci_GP_Timer
          N_Samples
          Over_Torque_Time_Counter
          local_debouncer
          relative_time
          Forced_Gain_Timer
          Delta_Speed_Timer
          relative_time
          MclFvt_Generic_Timer
          Res_Est_Flags
          Speed_Oscillation_Debouncer
          Res_Frequency_Timer
          This_Timer
          This_Timeout
          Sample_Counter
          Bus_Voltage_Previous
          SR_Threshold
          MaxPwm
          PwmFrequency
          DeadTimeNanosec
          SR_Motor_Fault
          SR_Motor_Fault_Holder
          SR_Motor_Flags
          SR_CurrentA
          SR_CurrentOffsetA
          SR_CurrentB
          SR_CurrentOffsetB
          SR_CurrentC
          SR_CurrentOffsetC
          SR_Raw_CurrentA
          SR_Raw_CurrentB
          SR_Raw_CurrentC
          SR_Sector
          SR_DCBus
          SR_PowerUpTimer
          SR_Phase_Lost_Counter
          SR_Overheating_Counter
          NSR_Motor_Fault
          NSR_Motor_Flags
          NSR_CurrentA
          NSR_CurrentOffsetA
          NSR_CurrentB
          NSR_CurrentOffsetB
          NSR_CurrentC
          NSR_CurrentOffsetC
          NSR_Raw_CurrentA
          NSR_Raw_CurrentB
          NSR_Raw_CurrentC
          NSR_Sector
          NSR_DCBus
          Mci_Error
          Mci_Error_Holder
          Mci_Flow_Control
          Mci_Status_Control
          My_Measured_Temp
          Mcl_Params_Displ1
          Mcl_Params_Displ3
          Mcl_Params_Displ4
          Mcl_Params_Displ9
          Mcl_Params_Displ10
          Mcl_Params_Displ11
          Manual_Inject_Level
          Manual_Inject_Param
          Manual_Pos_Reference
          I1_Rms_Sum
          I2_Rms_Sum
          I3_Rms_Sum
          Mean_Speed_Sum
          N_Samples_inv
          Id_Braking
          Id_Braking_Max
          Torque_Brake_Max
          Speed_Filtered
          Torque_Brake_Max_thr
          My_Max_Braking_Current
          My_Max_Braking_Torque
          My_Is_Abs
          gains_indexer_previous
          gains_indexer
          Over_Flux_Ratio
          Id_Braking
          Flux_Min
          My_Flux_Gain
          DC_Bus_RMS_Sum
          DC_Bus_RMS
          Speed_Threshold_High
          Speed_Threshold_Low
          Speed_Threshold
          My_Max_Torque
          Torque_Max_Braking
          Delta_Speed_Rot_Ref
          Max_Squared_Inv_Current_Appl
          Max_Design_Motor_Torque
          Max_Design_Motor_Torque_Appl
          My_Torque_Gain
          gains_indexer_previous
          gains_indexer
          MclFvt_Injection_Inst_Level
          MclFvt_Injection_Level
          MclFvt_Injection_Level_Rate
          MclFvt_Injection_Position
          Estimated_Resistance
          Last_Estimated_Resistance
          Timer_To_Reset_Resistance
          Voltage_Level
          Voltage_1st_Sum
          Current_1st_Sum
          Voltage_2nd_Sum
          Current_2nd_Sum
          Delta_Current_Nominal
          Default_Accel
          Increment
          SpeedRef_Target_Speed
          SpeedRef_Reference_Speed
          SR_MCPwm_Zero_Timeout
          SR_MCPwm_One_Timeout
          SR_MCPwm_Pulse_Active_Level
          SR_MCPwm_Pulse_Default_Level
          SR_MotorSafety_Params
          SR_CurrentOffsetHistA
          SR_CurrentOffsetHistB
          SR_CurrentOffsetHistC
          SR_ZeroSpeedDebouncer
          SR_ZeroSpeedWithCurrTimer
          SR_SquaredCurrentsSum
          SR_CalibrationCntr
          SR_SquaredCurrentRmsA
          SR_SquaredCurrentRmsB
          SR_SquaredCurrentRmsC
          SR_SquaredCurrentSumA
          SR_SquaredCurrentSumB
          SR_SquaredCurrentSumC
          SR_Curr_Rms_Counter
          SR_Timeout_Failure_Retry
          SR_Overheating_Temp
          SR_Voltage_Frequency
          SR_Squared_Current
          SR_Avg_Fund_Period_High_Threshold
          SR_Avg_Fund_Period_Low_Threshold
          SR_Avg_Threshold
          SR_Avg_Fund_Period_Time_Counter
          SR_Avg_Fund_Period_Cycle_Counter
          SR_Applied_Duty_A_Sum
          SR_Applied_Duty_A_Sum_High
          SR_Avg_Fund_Period
          SR_Check_Unlock_Door_Speed_Timer
          SR_Check_Unlock_Door_Speed_Delta_Voltage
          NSR_Avg_Fund_Period_High_Threshold
          NSR_Avg_Fund_Period_Low_Threshold
          NSR_Avg_Threshold
          NSR_Avg_Fund_Period_Time_Counter
          NSR_Avg_Fund_Period_Cycle_Counter
          NSR_Applied_Duty_A_Sum
          NSR_Avg_Fund_Period
          NSR_Check_Unlock_Door_Speed_Delta_Voltage
          NSR_Check_Unlock_Door_Speed_Timer
          NSR_State
          NSR_Fault_Holder
          NSR_MCPwm_Diag_State
          NSR_MCPwm_Errors
          NSR_Avg_Fund_Ignored_First
          NSR_Threshold
          NSR_Motor_Fault_Holder
          NSR_PowerUpTimer
          NSR_Phase_Lost_Counter
          NSR_Overheating_Counter
          Dutycycle_By_Current_LUT
          step_inv_pwm_comp
          sizeof_inv_comp_lut
          NSR_MCPwm_Zero_Timeout
          NSR_MCPwm_One_Timeout
          NSR_MCPwm_Pulse_Active_Level
          NSR_MCPwm_Pulse_Default_Level
          NSR_CurrentOffsetHistA
          NSR_CurrentOffsetHistB
          NSR_CurrentOffsetHistC
          NSR_ZeroSpeedDebouncer
          NSR_ZeroSpeedWithCurrTimer
          NSR_SquaredCurrentsSum
          NSR_CalibrationCntr
          NSR_SquaredCurrentRmsA
          NSR_SquaredCurrentRmsB
          NSR_SquaredCurrentRmsC
          NSR_SquaredCurrentSumA
          NSR_SquaredCurrentSumB
          NSR_SquaredCurrentSumC
          NSR_Curr_Rms_Counter
          NSR_Timeout_Failure_Retry
          NSR_Overheating_Temp
          NSR_Squared_Current
          NSR_Voltage_Frequency
          NSR_Applied_Duty_A_Sum_High
     114  Mcl__1msHandler
     344  Mcl__250usHandler
     252  Mcl__25msHandler
      18  Mcl__5msHandler
     188  Mcl__GetDigital
     636  Mcl__Initialize
       2  Mcl__ManualHandler
     108  Mcl__ManualReset
     488  Mcl__ParamsInitialize
     114  Mcl__ResetAll
      26  Mcl__ResetDigital
     234  Mcl__RunningHandler
     162  Mcl__RunningReset
     198  Mcl__SetAnalog
     110  Mcl__SetDigital
      72  Mcl__SetParams
      28  Mcl__StartingHandler
     204  Mcl__StartingReset
      66  Mcl__StoppingHandler
      40  Mcl__StoppingReset
       4  Mech_Rotor_Pos_Acc_Err
       4  Min_Speed_For_Fixed_Accel
     530  MotorMovingHandlerBpm
     126  Pi__CalcPiBackCalcF
     112  Pi__CalcPiF
     132  Pi__CalcPiQ30
     140  Pi__CalcPiQ30_new
     294  Pi__CalcPiQ60
     176  Pi__CalcPiQ60_new
       8  Pi__InitPiQ30
      10  Pi__InitPiQ60
       2  Pi__Initialize
      22  Pi__IntegBE
     102  Pi__IntegBESat
     176  Pi__PiRegBackCalc
     192  Pi__PiRegBackCalc_FixedGains
     174  Pi__PiRegBackCalc_FloatGains
     228  Pi__PiRegClamp
     198  Pi__PiRegNoAntiWindup
      68  Pi__PiRegNoAntiWindupF
       4  Previous_Target_Speed
     350  PwmModulation__DeadtimeCompensationGradientF
     210  PwmModulation__DeadtimeCompensationGradient_v2
     258  PwmModulation__InverterLossCompF
     140  PwmModulation__InverterLossComp_v2
     476  PwmModulation__SpaceVectorModulationF
     218  PwmModulation__SpaceVectorModulationRectangular
     306  PwmModulation__SpaceVectorModulationRectangularF
     540  PwmModulation__SpaceVectorModulationSixSteps
     296  PwmModulation__SpaceVectorModulation_v2
     362  RcThermalUpdate
      32  ResetQuantities
     770  ResistanceEstimation__Calculate
      10  ResistanceEstimation__GetResistance
      18  ResistanceEstimation__Handler25ms
      94  ResistanceEstimation__Initialize
      18  ResistanceEstimation__IsResBeenUpdated
      14  ResistanceEstimation__Requested
      60  ResistanceEstimation__Start
     244  Resistance_Adaptation
     118  RotorFlux_Correction
       4  Rotor_Mech_Position
     286  Running_Parallel_5msHandler
     182  SRInitializeAD0
     186  SRInitializeAD1
     552  SRMCAtod__DiagnosticHandler
      82  SRMCAtod__EnableDiagnostic
      86  SRMCAtod__GetDiagnosticFeedback
      70  SRMCAtod__ISR
     152  SRMCAtod__Initialize
      82  SRMCPDB__ISR
     754  SRMCPwm__DiagnosticHandler
     128  SRMCPwm__DisablePwmOutput
     138  SRMCPwm__EnableDiagnostic
     128  SRMCPwm__EnablePwmOutput
      10  SRMCPwm__GetDeadtimeNanosec
      98  SRMCPwm__GetDiagnosticFeedback
      56  SRMCPwm__GetHwFaultStatus
      10  SRMCPwm__GetMaxPwm
      10  SRMCPwm__GetPwmFrequencyHz
       2  SRMCPwm__Handler250us
     530  SRMCPwm__Initialize
     134  SRMCPwm__Initialize_Before_Boot
      38  SRMCPwm__LoadAllPwmValues
       2  SRMCPwm__PwmISR
      30  SRMCPwm__StartCounter
      26  SRMCPwm__StopCounter
      28  SRMCPwm__TurnOffAllGates
      14  SRMCPwm__TurnOffHighSideGates
      14  SRMCPwm__TurnOffLowSideGates
      44  SRMCPwm__TurnOnHighSideGates
      36  SRMCPwm__TurnOnLowSideGates
      30  SRMotorSafetyMgr__AnyFaultFound
     112  SRMotorSafetyMgr__ConfigPwmPattern
      44  SRMotorSafetyMgr__ForceStop
      36  SRMotorSafetyMgr__GetFault
      40  SRMotorSafetyMgr__GetFaultHolder
      36  SRMotorSafetyMgr__GetFlag
      34  SRMotorSafetyMgr__GetListedError
      10  SRMotorSafetyMgr__GetMaxPwm
      26  SRMotorSafetyMgr__GetMotorTemperature
      28  SRMotorSafetyMgr__GetSquaredCurrents
      28  SRMotorSafetyMgr__GetVoltageFrequency
      22  SRMotorSafetyMgr__Handler1ms
    1118  SRMotorSafetyMgr__Handler250us
     366  SRMotorSafetyMgr__Handler25ms
    4262  SRMotorSafetyMgr__Handler5ms
    1092  SRMotorSafetyMgr__Initialize
      60  SRMotorSafetyMgr__IsInIdle
    1164  SRMotorSafetyMgr__MCPwmHandler
     100  SRMotorSafetyMgr__Prepare2StartMotor
      86  SRMotorSafetyMgr__Prepare2StopMotor
      32  SRMotorSafetyMgr__SR_SquaredCurrentRmsA
      32  SRMotorSafetyMgr__SR_SquaredCurrentRmsB
      32  SRMotorSafetyMgr__SR_SquaredCurrentRmsC
     190  SRMotorSafetyMgr__SetParams
      94  SRMotorSafetyMgr__UpdatePwm
       4  SizeOf_Inv_Temp_LUT_Mitsubishi
       4  SizeOf_Inv_Temp_LUT_ST
      18  SpeedRefGen__ApplyDefaultAccel
     198  SpeedRefGen__Generator
      10  SpeedRefGen__GetSpeedRef
      40  SpeedRefGen__GetSpeedRefIQ
      10  SpeedRefGen__GetSpeedTarget
      40  SpeedRefGen__GetSpeedTargetIQ
      98  SpeedRefGen__GetStatus
      30  SpeedRefGen__Initialize
      12  SpeedRefGen__Reset
     154  SpeedRefGen__SetNewSpeed
      26  SpeedRefGen__SetSpeedParams
     356  Speed_Gain_Scheduler
     196  Speed_PLL
          Stator_Emf
          Stator_Emf_Err
          Stator_Lambda
          Rotor_Lambda
          Rotor_Curr_Id
          Rotor_Curr_Iq
          Rotor_Curr_Iq_Abs
          Rotor_Curr_Id_Abs
          Pole_Pairs_Inv
          Rotor_Lambda_Mod
          Sin_Rot_k1
          Cos_Rot_k1
          EM_Torque
          EM_Torque_Filt_Sum
          dLambdas_alpha_old
          dLambdas_beta_old
          Rotor_Position
          Flux_Error
          Obs_Speed_Stator_Flux
          Obs_Speed_Rotor_Flux
          Obs_Speed_Rotor_Flux_sum
          Error_Flux_Alpha_1
          Error_Flux_Beta_1
          Stator_Resistance_Corr
          Err_Lim_Lower
          Err_Lim_Upper
          Speed_Transition_Counter
     256  SquareRootTable
       4  Starting_Accel
     166  SurgeRelay__25msHandler
      74  SurgeRelay__Action
      52  SurgeRelay__Initialize
      20  SurgeRelay__IsBusReady
     268  TimerDefinition
     434  Torque_Flux_Gains_Scheduler
      56  XPLLVars
      32  debruijn_to_std_signed
      32  debruijn_to_std_unsigned
       2  delta_curr_a
       2  delta_curr_b
       2  delta_curr_c
     512  sinTable
    2052  sinTable_wp_f32
       2  vbus
      12  vs_alpha_beta_comp
      12  vs_alpha_beta_comp

 
    328 bytes in section .bss
  3 332 bytes in section .data
     82 bytes in section .rodata
 47 380 bytes in section .text
 
 47 380 bytes of CODE  memory
     82 bytes of CONST memory
  3 660 bytes of DATA  memory

Errors: none
Warnings: 1
