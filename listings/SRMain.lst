###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        19/Nov/2024  13:15:45
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  XCategory\Common\SRMain\SRMain.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        SRMain.obj -l ..\listings\SRMain.lst XCategory\Common\SRMain\SRMain.c
#    List file    =  ..\listings\SRMain.lst
#    Object file  =  SRMain.obj
#
###############################################################################

C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Common\SRMain\SRMain.c
      1          /**
      2           *  @defgroup   CLASS_B
      3           *  @file       SRMain.c
      4           *  @brief      main() routine and primary timer ISR routine.
      5           *
      6           *  @details    This module contains the main() routine and the main interrupt service routine.
      7           *              The main() routine is the program's entry point.  The main interrupt service routine
      8           *              manages the timing for the application.
      9           *
     10           *              This module has been constructed similar to a GDM.  So the only required changes are
     11           *              to the main_prv_prm.h file.  Both main.c and main.h are not intended to be changed
     12           *              when used in a different application.
     13           *
     14           *              There are a series of constant arrays that are lists of routines to call at certain
     15           *              points in the execution of the main loop and the main interrupt service routine.
     16           *              Each array is described in the comments associated with that array.
     17           *              They are summarized here:
     18           *
     19           *              <pre>
     20           *              Function List               Purpose
     21           *              -----------------------     --------------------------------------------------------
     22           *              Initialization_Tasks        NULL terminated list of tasks to execute before entering
     23           *                                          the infinite loop.
     24           *              -----------------------     --------------------------------------------------------
     25           *              Every_Slot_Tasks            NULL terminated list of tasks to execute at the
     26           *                                          beginning of every slot.
     27           *              -----------------------     --------------------------------------------------------
     28           *              Main_Slot{n}_Tasks          NULL terminated list of tasks to execute during slot(n)
     29           *                                          of the main routine.
     30           *              -----------------------     --------------------------------------------------------
     31           *              Main_Tasks                  Array made up of the Main_Slot{n}_Tasks[] arrays.
     32           *                                          Determines the sequence of slots and the number of slots.
     33           *              -----------------------     --------------------------------------------------------
     34           *              Every_Interrupt_Tasks       NULL terminated list of tasks to execute at the start of
     35           *                                          every main interrupt.
     36           *              -----------------------     --------------------------------------------------------
     37           *              Interrupt_Slot(n)_Tasks     NULL terminated list of tasks to execute during slot(n)
     38           *                                          of the main interrupt service routine.
     39           *              -----------------------     --------------------------------------------------------
     40           *              Interrupt_Tasks             Array made up of the Interrupt_Slot(n)_Tasks[] arrays.
     41           *                                          Determines the sequence of slots and the number of slots.
     42           *              -----------------------     --------------------------------------------------------
     43           *              </pre>
     44           *
     45           *              When configuring this module for a new application, the programmer should create a
     46           *              Main_Slot(n)_Tasks[] array for each of the slots desired in the main loop.  Also,
     47           *              create an Interrupt_Slot(n)_Tasks[] array for each of the slots desired in the main
     48           *              interrupt service routine.  The programmer should set the SLOT_TIME equal to the
     49           *              number of interrupts that make up a single slot.
     50           *
     51           *
     52           *  
     53           *
     54           *  @copyright  Copyright 2007 -   Whirlpool Corporation.  All rights reserved - CONFIDENTIAL.
     55           */
     56          //---------------------------------------------------------------------------------------------------------------------
     57          //---------------------------------------------------------------------------------------------------------------------
     58          
     59          
     60          //-------------------------------------- Include Files ----------------------------------------------------------------
     61          #include "C_Extensions.h"
     62          #include "SRMicro.h"
     63          #include "SRMain.h"
     64          
     65          //! A cosntant pointer to a function with no return value or parameters.
     66          typedef void (* const TASK_TYPE)(void);
     67          
     68          //! A constant pointer to a list of TASK_TYPESs.
     69          typedef void (* const * const TASK_LIST_TYPE)(void);
     70          
     71          //! A NULL pointer to use as a terminator for function lists.
     72          #define NULL_TASK ((TASK_TYPE)0)
                         ^
Warning[Pe047]: incompatible redefinition of macro "NULL_TASK" (declared at
          line 61 of "XCategory/Driver/API/Micro/C_Extensions.h")
     73          
     74          
     75          #include "SRMain_prv.h"

  extern const volatile GPIO_DEF * GPIO_PORT_LIST[];
  ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Driver\Gpio\Gpio_macros.h",34  Remark[Pe083]: 
          type qualifier specified more than once

  PACKED typedef struct
         ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Driver\API\Gpio\Gpio.h",41  Remark[Pe082]: 
          storage class is not first

   \                                 In section .text, align 4, keep-with-next
   \   __absolute TASK_TYPE SRInitialization_Tasks[9]
   \                     SRInitialization_Tasks:
   \   00000000   0x........         DC32 Micro__Initialize, Micro__SetNormalSpeedMode, Gpio__Initialize
   \              0x........   
   \              0x........   
   \   0000000C   0x........         DC32 Comparator__Initialize, SRException__Initialize
   \              0x........   
   \   00000014   0x........         DC32 SRClockMonitor__Initialize, SRIsrMonitor__Initialize
   \              0x........   
   \   0000001C   0x........         DC32 SRMotorSafetyMgr__Initialize, 0H
   \              0x00000000   

   \                                 In section .text, align 4, keep-with-next
   \   __absolute TASK_TYPE SREvery_Slot_Tasks[2]
   \                     SREvery_Slot_Tasks:
   \   00000000   0x........         DC32 SRMotorSafetyMgr__Handler5ms, 0H
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute TASK_TYPE SRMain_Slot0_Tasks[2]
   \                     SRMain_Slot0_Tasks:
   \   00000000   0x........         DC32 Micro__SRRamTest, 0H
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute TASK_TYPE SRMain_Slot1_Tasks[2]
   \                     SRMain_Slot1_Tasks:
   \   00000000   0x........         DC32 Micro__SRFlashTest, 0H
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute TASK_TYPE SRMain_Slot2_Tasks[2]
   \                     SRMain_Slot2_Tasks:
   \   00000000   0x........         DC32 SRMotorSafetyMgr__Handler25ms, 0H
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute TASK_TYPE SRMain_Slot3_Tasks[1]
   \                     SRMain_Slot3_Tasks:
   \   00000000   0x00000000         DC32 0H

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute TASK_TYPE SRMain_Slot4_Tasks[1]
   \                     SRMain_Slot4_Tasks:
   \   00000000   0x00000000         DC32 0H

   \                                 In section .text, align 4, keep-with-next
   \   __absolute TASK_LIST_TYPE SRMain_Tasks[5]
   \                     SRMain_Tasks:
   \   00000000   0x........         DC32 SRMain_Slot0_Tasks, SRMain_Slot1_Tasks, SRMain_Slot2_Tasks
   \              0x........   
   \              0x........   
   \   0000000C   0x........         DC32 SRMain_Slot3_Tasks, SRMain_Slot4_Tasks
   \              0x........   

   \                                 In section .text, align 4, keep-with-next
   \   __absolute TASK_TYPE SREvery_Interrupt_Tasks[2]
   \                     SREvery_Interrupt_Tasks:
   \   00000000   0x........         DC32 SRMotorSafetyMgr__Handler250us, 0H
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute TASK_TYPE SRInterrupt_Slot0_Tasks[2]
   \                     SRInterrupt_Slot0_Tasks:
   \   00000000   0x........         DC32 SRClockMonitor__Monitor1ms, 0H
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute TASK_TYPE SRInterrupt_Slot1_Tasks[2]
   \                     SRInterrupt_Slot1_Tasks:
   \   00000000   0x........         DC32 SRIsrMonitor__Handler, 0H
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute TASK_TYPE SRInterrupt_Slot2_Tasks[2]
   \                     SRInterrupt_Slot2_Tasks:
   \   00000000   0x........         DC32 SRMotorSafetyMgr__Handler1ms, 0H
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute TASK_TYPE SRInterrupt_Slot3_Tasks[2]
   \                     SRInterrupt_Slot3_Tasks:
   \   00000000   0x........         DC32 SRMotorSafetyInfoParamsMgr__Handler1ms, 0H
   \              0x00000000   

   \                                 In section .text, align 4, keep-with-next
   \   __absolute TASK_LIST_TYPE SRInterrupt_Tasks[4]
   \                     SRInterrupt_Tasks:
   \   00000000   0x........         DC32 SRInterrupt_Slot0_Tasks, SRInterrupt_Slot1_Tasks
   \              0x........   
   \   00000008   0x........         DC32 SRInterrupt_Slot2_Tasks, SRInterrupt_Slot3_Tasks
   \              0x........   
     76          #include "Main_prv.h"

  PACKED typedef struct
         ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Common\SettingFile\SettingFile.h",39  Remark[Pe082]: 
          storage class is not first

  PACKED typedef struct API019_APPLIANCE_DATA_STRUCT
         ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Application\Reveal_APIs\API019ProductInfo\API019ProductInfo_Defs.h",42  Remark[Pe082]: 
          storage class is not first

  PACKED typedef struct API019_BOARD_DATA_STRUCT
         ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Application\Reveal_APIs\API019ProductInfo\API019ProductInfo_Defs.h",50  Remark[Pe082]: 
          storage class is not first

  PACKED typedef struct API019_TEST_DATA_STRUCT
         ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Application\Reveal_APIs\API019ProductInfo\API019ProductInfo_Defs.h",141  Remark[Pe082]: 
          storage class is not first

  PACKED typedef struct API019_SERVICE_DATA_STRUCT
         ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Application\Reveal_APIs\API019ProductInfo\API019ProductInfo_Defs.h",150  Remark[Pe082]: 
          storage class is not first

  PACKED typedef struct API019_PROJECT_DATA_STRUCT
         ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Application\Reveal_APIs\API019ProductInfo\API019ProductInfo_Defs.h",183  Remark[Pe082]: 
          storage class is not first

  PACKED typedef struct
         ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Common\SystemTimers\SystemTimers.h",45  Remark[Pe082]: 
          storage class is not first

  PACKED typedef struct
         ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Common\SystemTimers\SystemTimers.h",56  Remark[Pe082]: 
          storage class is not first

  PACKED typedef struct
         ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Application\SFUpdater\SFUpdater_defs.h",30  Remark[Pe082]: 
          storage class is not first

  PACKED typedef struct
         ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Application\SFUpdater\SFUpdater.h",35  Remark[Pe082]: 
          storage class is not first

   \                                 In section .text, align 4, keep-with-next
   \   __absolute TASK_TYPE Initialization_Tasks[5]
   \                     Initialization_Tasks:
   \   00000000   0x........         DC32 ProtocolMainExternal__Initialize, ProtocolInfo__Initialize
   \              0x........   
   \   00000008   0x........         DC32 MciParametersLoader__Initialize, TimerInterrupt__Initialize, 0H
   \              0x........   
   \              0x00000000   

   \                                 In section .text, align 4, keep-with-next
   \   __absolute TASK_TYPE Every_Slot_Tasks[2]
   \                     Every_Slot_Tasks:
   \   00000000   0x........         DC32 Mci__5msHandler, 0H
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute TASK_TYPE Main_Slot0_Tasks[2]
   \                     Main_Slot0_Tasks:
   \   00000000   0x........         DC32 MciParametersLoader__25msHandler, 0H
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute TASK_TYPE Main_Slot1_Tasks[2]
   \                     Main_Slot1_Tasks:
   \   00000000   0x........         DC32 Mci__25msHandler, 0H
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute TASK_TYPE Main_Slot2_Tasks[1]
   \                     Main_Slot2_Tasks:
   \   00000000   0x00000000         DC32 0H

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute TASK_TYPE Main_Slot3_Tasks[1]
   \                     Main_Slot3_Tasks:
   \   00000000   0x00000000         DC32 0H

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute TASK_TYPE Main_Slot4_Tasks[1]
   \                     Main_Slot4_Tasks:
   \   00000000   0x00000000         DC32 0H

   \                                 In section .text, align 4, keep-with-next
   \   __absolute TASK_LIST_TYPE Main_Tasks[5]
   \                     Main_Tasks:
   \   00000000   0x........         DC32 Main_Slot0_Tasks, Main_Slot1_Tasks, Main_Slot2_Tasks
   \              0x........   
   \              0x........   
   \   0000000C   0x........         DC32 Main_Slot3_Tasks, Main_Slot4_Tasks
   \              0x........   

   \                                 In section .text, align 4, keep-with-next
   \   __absolute TASK_TYPE Every_Interrupt_Tasks[3]
   \                     Every_Interrupt_Tasks:
   \   00000000   0x........         DC32 Uart__Handler, Mci__250usHandler, 0H
   \              0x........   
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute TASK_TYPE Interrupt_Slot0_Tasks[1]
   \                     Interrupt_Slot0_Tasks:
   \   00000000   0x00000000         DC32 0H

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute TASK_TYPE Interrupt_Slot1_Tasks[2]
   \                     Interrupt_Slot1_Tasks:
   \   00000000   0x........         DC32 Mci__1msHandler, 0H
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute TASK_TYPE Interrupt_Slot2_Tasks[1]
   \                     Interrupt_Slot2_Tasks:
   \   00000000   0x00000000         DC32 0H

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute TASK_TYPE Interrupt_Slot3_Tasks[1]
   \                     Interrupt_Slot3_Tasks:
   \   00000000   0x00000000         DC32 0H

   \                                 In section .text, align 4, keep-with-next
   \   __absolute TASK_LIST_TYPE Interrupt_Tasks[4]
   \                     Interrupt_Tasks:
   \   00000000   0x........         DC32 Interrupt_Slot0_Tasks, Interrupt_Slot1_Tasks
   \              0x........   
   \   00000008   0x........         DC32 Interrupt_Slot2_Tasks, Interrupt_Slot3_Tasks
   \              0x........   
     77          
     78          #ifndef SRMAIN_RESETS_STACK_POINTER
     79              #define SRMAIN_RESETS_STACK_POINTER  ENABLED
     80          #endif
     81          
     82          #ifndef SRMAIN_LOW_POWER_FEATURE
     83              #define SRMAIN_LOW_POWER_FEATURE   DISABLED
     84          #endif
     85          
     86          #if (SRMAIN_LOW_POWER_FEATURE == ENABLED)
     87              #include "SRPowerMgr.h"
     88          #endif
     89          
     90          
     91          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     92          
     93          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     94          
     95          
     96          
     97          #if (SRMAIN_LOW_POWER_FEATURE == ENABLED)
     98              typedef enum
     99              {
    100                  SRMAIN_STATE_NORMAL_POWER,
    101                  SRMAIN_STATE_SWITHCING_TO_LOW_POWER,
    102                  SRMAIN_STATE_LOW_POWER,
    103                  SRMAIN_STATE_SWITHING_TO_NORMAL_POWER
    104              } SRMAIN_POWER_STATE;
    105          #endif
    106          
    107          //  --- Constants
    108          //! Number of slots in the main loop
    109          #define MAIN_SLOT_COUNT (sizeof(Main_Tasks)/sizeof(TASK_LIST_TYPE))
    110          #define SR_MAIN_SLOT_COUNT (sizeof(SRMain_Tasks)/sizeof(TASK_LIST_TYPE))
    111          
    112          //! Number of slots in the main interrupt
    113          #define INTERRUPT_SLOT_COUNT (sizeof(Interrupt_Tasks)/sizeof(TASK_LIST_TYPE))
    114          #define SR_INTERRUPT_SLOT_COUNT (sizeof(Interrupt_Tasks)/sizeof(TASK_LIST_TYPE))
    115          
    116          
    117          /** @breif      Duration of each slot in the main loop.
    118           *  @details    The number of interrupts per main slot in the gated slotted architecture.
    119           *              Example: 250 microsecond interrupt rate is 4 interrupts per millisecond.
    120           *                       For 5 millisecond slots: SLOT_TIME = 5 * 4.
    121           */
    122          #define SLOT_TIME (SR_INTERRUPTS_PER_MILLISECOND * SR_MILLISECONDS_PER_MAIN_SLOT)
    123          
    124          
    125          //  --- Variables
    126          
    127          #if (SRMAIN_LOW_POWER_FEATURE == ENABLED)
    128              SRMAIN_POWER_STATE SRMain_Power_State;
    129          #endif
    130          
    131          
    132          //! Number of the current main loop slot in the main() routine

   \                                 In section .bss, align 1
    133          static uint8 Main_Slot;
   \                     Main_Slot:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 1
   \   00000003                      DS8 1
   \   00000004                      DS8 1
   \   00000005                      DS8 1
    134          
    135          //! Number of the current interrupt slot in the timer interrupt service routine
    136          static TINY uint8 Interrupt_Slot;
    137          
    138          //! Timer to measure a single slot duration
    139          static uint8 Main_Slot_Timer;
    140          
    141          //! Value of Main_Slot_Timer the last time a Slot was executed
    142          static uint8 Main_Slot_Timer_Diff;
    143          
    144          #if (SRMAIN_LOW_POWER_FEATURE == ENABLED)
    145              static SRMAIN_POWER_STATE N_SRMain_Power_State;
    146          #endif
    147          
    148          //! Number of the current main loop slot in the main() routine
    149          static uint8 N_Main_Slot;
    150          
    151          //! Number of the current interrupt slot in the timer interrupt service routine
    152          static TINY uint8 N_Interrupt_Slot;
    153          
    154          
    155          #define SRMAIN_COMPLEMENT(data)    (~(data))
    156          
    157          
    158          //!Add a routine to perform timing check for 5ms slots
    159          //!This routine will be called after the execution of the code of any 5ms slot.
    160          #ifndef MAIN_SLOT_CHECK
    161              #define MAIN_SLOT_CHECK(a,b)
    162          #endif
    163          
    164          //! Add a routine to perform timing check on Main Slots
    165          //! This routine will be called before any instruction with the slot synchronization
    166          #ifndef MAIN_DEBUG_BEFORE_SLOTS
    167              #define MAIN_DEBUG_BEFORE_SLOTS()
    168          #endif
    169          
    170          //! Add a routine to perform timing check on Main Slots
    171          //! This routine will be called after all instructions with the slot synchronization
    172          #ifndef MAIN_DEBUG_AFTER_SLOTS
    173              #define MAIN_DEBUG_AFTER_SLOTS()
    174          #endif
    175          
    176          //! Add a routine to perform timing check on Timer Interruption Slots
    177          //! This routine will be called before any instruction in the Timer Interruption
    178          #ifndef MAIN_DEBUG_BEFORE_INTERRUPT_SLOTS
    179              #define MAIN_DEBUG_BEFORE_INTERRUPT_SLOTS()
    180          #endif
    181          
    182          //! Add a routine to perform timing check on Timer Interruption Slots
    183          //! This routine will be called after all instructions in the Timer Interruption
    184          #ifndef MAIN_DEBUG_AFTER_INTERRUPT_SLOTS
    185              #define MAIN_DEBUG_AFTER_INTERRUPT_SLOTS()
    186          #endif
    187          
    188          //! This macro could be used to verify the integrity of the SR Varaibles
    189          #ifndef SRMAIN_CHECK_SR_VARIABLES
    190              #define SRMAIN_CHECK_SR_VARIABLES()
    191          #endif
    192          
    193          //! This macro is used along with SRMAIN_CHECK_SR_VARIABLES by CRCs the variables
    194          #ifndef SRMAIN_CRC_SR_VARIABLES
    195              #define SRMAIN_CRC_SR_VARIABLES()
    196          #endif
    197          
    198          
    199          //! Macro for checking the SR Variables in the Timer Interrupt
    200          #ifndef SRMAIN_CHECK_INTERRUPT_SR_VARIABLES
    201              #define SRMAIN_CHECK_INTERRUPT_SR_VARIABLES()
    202          #endif
    203          
    204          //! Macro for checking the SR Variables  in the Timer Interrupt
    205          #ifndef SRMAIN_CRC_INTERRUPT_SR_VARIABLES
    206              #define SRMAIN_CRC_INTERRUPT_SR_VARIABLES()
    207          #endif
    208          
    209          
    210          //! Macro for SQC Timer interrupt slot test
    211          #ifndef MAIN_TIMER_ISR_END
    212              #define MAIN_TIMER_ISR_END(slot)
    213          #endif
    214          

   \                                 In section .bss, align 1
   \   00000000                      DS8 1
    215          static uint8 previews_slot;
    216          
    217          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
    218          
    219          void ExecuteTasks(TASK_TYPE * task_list);
    220          static void SRMainUpdateByte(uint8 * data, uint8 * ndata,uint8 value);
    221          static BOOL_TYPE SRMainCheckByte(uint8 * data, uint8 * ndata);
    222          
    223          //=====================================================================================================================
    224          //-------------------------------------- Public Functions -------------------------------------------------------------
    225          //=====================================================================================================================
    226          
    227          
    228          //---------------------------------------------------------------------------------------------------------------------
    229          /**
    230           *  @brief      The application's main routine
    231           *
    232           *  @image      html SRMain_Activity.jpg
    233           *
    234           *  @details    This routine implements a main loop with a gated slotted architecture.
    235           *              It can be configured through the parameter files.
    236           *
    237           *              NOTE:
    238           *              If the MAIN_RESETS_STACK_POINTER compiler directive is defined, then all
    239           *              local variables must be declared as static or they will be placed on the
    240           *              stack.  Since the main loop resets the stack pointer, the variables will
    241           *              be lost.
    242           */

   \                                 In section .text, align 4, keep-with-next
    243          void main(void)
    244          {
   \                     main: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB081             SUB      SP,SP,#+4
    245          
    246              #if (SRMAIN_RESETS_STACK_POINTER == ENABLED)
    247                  // Execute all the time that we are not executing a Slot.
    248                  // Ensure that the stack pointer is correct.
    249                  DISABLE_INTERRUPTS();   // Ensure that the interrupts are disabled before reset the stack pointer
   \   00000006   0xB672             CPSID    I
   \   00000008   0x.... 0x....      LDR.W    R11,??DataTable29
   \   0000000C   0x4658             MOV      R0,R11
    250                  RESET_STACK_POINTER();
                         ^
Warning[Pe223]: function "__MSR_MSP" declared implicitly
   \   0000000E   0x.... 0x....      BL       __MSR_MSP
    251                  DISABLE_INTERRUPTS();   // ensure that the interrupts are disabled after reset the stack pointer
   \   00000012   0xB672             CPSID    I
    252              #endif
    253              //--------------------------------------------------------------------------
    254              //  --- Initialize program
    255          
    256              // Initialize the SR Flow control module
    257              SR_FLOW_INITILIZE();
   \   00000014   0x.... 0x....      BL       SRFlow__Initialize
    258          
    259              // Initialize main() routine variables.
    260              Main_Slot_Timer = SLOT_TIME;                    // Timer for main slots
   \   00000018   0x....             LDR.N    R5,??DataTable29_1
    261              Main_Slot_Timer_Diff = 0;                       // Provides mutual exclusion with the timer interrupt
    262          
    263              //Main_Slot = 0;
    264              SRMainUpdateByte(&Main_Slot, &N_Main_Slot,0);
    265          
    266              //Interrupt_Slot = 0;
    267              SRMainUpdateByte(&Interrupt_Slot, &N_Interrupt_Slot,0);
    268          
    269              // Initialize the SR microcontroller and application modules
    270              ExecuteTasks(SRInitialization_Tasks);
   \   0000001A   0x.... 0x....      ADR.W    R7,SRInitialization_Tasks
   \   0000001E   0x2014             MOVS     R0,#+20
   \   00000020   0x70A8             STRB     R0,[R5, #+2]
   \   00000022   0x26FF             MOVS     R6,#+255
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x70E8             STRB     R0,[R5, #+3]
   \   00000028   0x7028             STRB     R0,[R5, #+0]
   \   0000002A   0x712E             STRB     R6,[R5, #+4]
   \   0000002C   0x7068             STRB     R0,[R5, #+1]
   \   0000002E   0x716E             STRB     R6,[R5, #+5]
   \   00000030   0xE003             B.N      ??main_0
   \   00000032   0xBF00             Nop      
   \                     ??main_1: (+1)
   \   00000034   0xF857 0x0B04      LDR      R0,[R7], #+4
   \   00000038   0x4780             BLX      R0
   \                     ??main_0: (+1)
   \   0000003A   0x6838             LDR      R0,[R7, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD1F9             BNE.N    ??main_1
    271          
    272              // Initialize the Class A application modules
    273              ExecuteTasks(Initialization_Tasks);
   \   00000040   0x.... 0x....      ADR.W    R7,Initialization_Tasks
   \   00000044   0xE003             B.N      ??main_2
   \   00000046   0xBF00             Nop      
   \                     ??main_3: (+1)
   \   00000048   0xF857 0x0B04      LDR      R0,[R7], #+4
   \   0000004C   0x4780             BLX      R0
   \                     ??main_2: (+1)
   \   0000004E   0x6838             LDR      R0,[R7, #+0]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD1F9             BNE.N    ??main_3
    274          
    275              // Macro that calls the SRFlow modules to test if the Initialize sequence was executed property
    276              SR_FLOW_CHECK_INIT();
   \   00000054   0x.... 0x....      BL       SRFlow__InitCheck
   \   00000058   0x.... 0x....      ADR.W    R7,Main_Tasks
   \   0000005C   0x.... 0x....      ADR.W    R8,Every_Slot_Tasks
   \   00000060   0x.... 0x....      ADR.W    R9,SRMain_Tasks
   \   00000064   0x.... 0x....      ADR.W    R10,SREvery_Slot_Tasks
   \   00000068   0xE004             B.N      ??main_4
    277          
    278              #if (SRMAIN_LOW_POWER_FEATURE == ENABLED)
    279                  SRMainUpdateByte((uint8 *)&SRMain_Power_State,(uint8 *)&N_SRMain_Power_State,SRMAIN_STATE_NORMAL_POWER);
    280              #endif
    281          
    282          
    283              //--------------------------------------------------------------------------
    284              //  --- Begin Main (Infinite) Loop
    285              for (;;)
    286              {
    287          
    288                  #if (SRMAIN_LOW_POWER_FEATURE == ENABLED)
    289          
    290                      if (SRMainCheckByte((uint8 *)&SRMain_Power_State,(uint8 *)&N_SRMain_Power_State) == FALSE)
    291                      {
    292                          SRMainUpdateByte((uint8 *)&SRMain_Power_State,(uint8 *)&N_SRMain_Power_State,SRMAIN_STATE_NORMAL_POWER);
    293                      }
    294          
    295                      switch (SRMain_Power_State)
    296                      {
    297                          case SRMAIN_STATE_NORMAL_POWER:
    298                  #endif
    299          
    300                              // Time Gate for Slotted Architecture
    301                              // Implementation catches up if it falls behind
    302                              if ((uint8)(Main_Slot_Timer - Main_Slot_Timer_Diff) >= SLOT_TIME)
    303                              {
    304                                  // '+=' operator used here so that overruns are eventually caught up
    305                                  Main_Slot_Timer_Diff += SLOT_TIME;
    306          
    307                                  // Macro for timing analyzes
    308                                  MAIN_DEBUG_BEFORE_SLOTS();
    309          
    310                                  // Macro for checking the SR Variables
    311                                  SRMAIN_CHECK_SR_VARIABLES();
    312          
    313                                  // Placement here insures that both the main loop and the main timer interrupt are running.
    314                                  // Ideally, this would be the only call anywhere in the code.
    315                                  SRMicro__ServiceWatchdog();
    316          
    317                                  // Execute tasks that run SR every slot
    318                                  ExecuteTasks(SREvery_Slot_Tasks);
    319          
    320                                  // Execute tasks that only run during a specific slot
    321                                  ExecuteTasks(SRMain_Tasks[Main_Slot]);
    322          
    323                                  // Macro for checking the SR Variables
    324                                  SRMAIN_CRC_SR_VARIABLES();
    325          
    326                                  // Execute tasks that run every slot
    327                                  ExecuteTasks(Every_Slot_Tasks);
    328          
    329          
    330                                  // Execute tasks that only run during a specific slot for Class A code
    331                                  if (Main_Slot < MAIN_SLOT_COUNT)
    332                                  {
    333                                      ExecuteTasks(Main_Tasks[Main_Slot]);
    334                                  }
    335          
    336                                  previews_slot = Main_Slot;
    337          
    338                                  // Move to the next main loop Slot.  Roll back to zero if necessary.
    339                                  if (SRMainCheckByte(&Main_Slot,&N_Main_Slot) == FALSE)
    340                                  {
    341                                      // Main_Slot data corrupted
    342                                      SRMainUpdateByte(&Main_Slot, &N_Main_Slot,0);
    343                                  }
    344                                  else
    345                                  {
    346                                      // If slot if okay, keeping counting
    347                                      SRMainUpdateByte(&Main_Slot, &N_Main_Slot,Main_Slot+1);
    348                                  }
    349          
    350                                  if (Main_Slot >= SR_MAIN_SLOT_COUNT)
    351                                  {
    352                                      SRMainUpdateByte(&Main_Slot, &N_Main_Slot,0);
    353                                      SR_FLOW_CHECK_MAIN();
    354                                  }
    355          
    356                                  // Tests if the Slot Time was respected
    357                                  if ((uint8)(Main_Slot_Timer - Main_Slot_Timer_Diff) >= SLOT_TIME)
    358                                  {
    359                                      // Exception: Main Slot Time Violation
    360                                      SR_EXCEPTION_MAIN_SLOT_VIOLATION((Main_Slot_Timer - Main_Slot_Timer_Diff),SLOT_TIME);
    361          
    362                                  }
    363                                  MAIN_SLOT_CHECK((Main_Slot_Timer - Main_Slot_Timer_Diff),previews_slot);
    364          
    365                                  // Macro for timing analyzes
    366                                  MAIN_DEBUG_AFTER_SLOTS();
    367                              }                                           //End 5 millisecond gate
    368                              else
    369                              {
    370                                  #if (SRMAIN_RESETS_STACK_POINTER == ENABLED)
    371                                      // Execute all the time that we are not executing a Slot.
    372                                      // Ensure that the stack pointer is correct.
    373                                      DISABLE_INTERRUPTS();
   \                     ??main_5: (+1)
   \   0000006A   0xB672             CPSID    I
    374                                      RESET_STACK_POINTER();
   \   0000006C   0x4658             MOV      R0,R11
   \   0000006E   0x.... 0x....      BL       __MSR_MSP
    375                                      ENABLE_INTERRUPTS();
   \   00000072   0xB662             CPSIE    I
    376          
    377                                  #endif
    378          
    379                                  // The code associated to NOISE_IMMUNITY runs between slots.
    380                                  // Ensure that the code is not too long that could cause problems to the slots.
    381                                  SRNOISE_IMMUNITY();
    382                              }
   \                     ??main_4: (+1)
   \   00000074   0x78E8             LDRB     R0,[R5, #+3]
   \   00000076   0x78A9             LDRB     R1,[R5, #+2]
   \   00000078   0x1A09             SUBS     R1,R1,R0
   \   0000007A   0xB2C9             UXTB     R1,R1
   \   0000007C   0x2914             CMP      R1,#+20
   \   0000007E   0xDBF4             BLT.N    ??main_5
   \   00000080   0x3014             ADDS     R0,R0,#+20
   \   00000082   0x70E8             STRB     R0,[R5, #+3]
   \   00000084   0x.... 0x....      BL       Micro__ServiceWatchdog
   \   00000088   0x4654             MOV      R4,R10
   \   0000008A   0xE002             B.N      ??main_6
   \                     ??main_7: (+1)
   \   0000008C   0xF854 0x0B04      LDR      R0,[R4], #+4
   \   00000090   0x4780             BLX      R0
   \                     ??main_6: (+1)
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD1F9             BNE.N    ??main_7
   \   00000098   0x7828             LDRB     R0,[R5, #+0]
   \   0000009A   0xF859 0x4020      LDR      R4,[R9, R0, LSL #+2]
   \   0000009E   0xE002             B.N      ??main_8
   \                     ??main_9: (+1)
   \   000000A0   0xF854 0x0B04      LDR      R0,[R4], #+4
   \   000000A4   0x4780             BLX      R0
   \                     ??main_8: (+1)
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD1F9             BNE.N    ??main_9
   \   000000AC   0x4644             MOV      R4,R8
   \   000000AE   0xE002             B.N      ??main_10
   \                     ??main_11: (+1)
   \   000000B0   0xF854 0x0B04      LDR      R0,[R4], #+4
   \   000000B4   0x4780             BLX      R0
   \                     ??main_10: (+1)
   \   000000B6   0x6820             LDR      R0,[R4, #+0]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD1F9             BNE.N    ??main_11
   \   000000BC   0x7828             LDRB     R0,[R5, #+0]
   \   000000BE   0x2805             CMP      R0,#+5
   \   000000C0   0xD208             BCS.N    ??main_12
   \   000000C2   0xF857 0x4020      LDR      R4,[R7, R0, LSL #+2]
   \   000000C6   0xE002             B.N      ??main_13
   \                     ??main_14: (+1)
   \   000000C8   0xF854 0x0B04      LDR      R0,[R4], #+4
   \   000000CC   0x4780             BLX      R0
   \                     ??main_13: (+1)
   \   000000CE   0x6820             LDR      R0,[R4, #+0]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD1F9             BNE.N    ??main_14
   \                     ??main_12: (+1)
   \   000000D4   0x7828             LDRB     R0,[R5, #+0]
   \   000000D6   0x792A             LDRB     R2,[R5, #+4]
   \   000000D8   0x43C1             MVNS     R1,R0
   \   000000DA   0xB2C9             UXTB     R1,R1
   \   000000DC   0x4291             CMP      R1,R2
   \   000000DE   0xD002             BEQ.N    ??main_15
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x21FF             MOVS     R1,#+255
   \   000000E4   0xE002             B.N      ??main_16
   \                     ??main_15: (+1)
   \   000000E6   0x1C40             ADDS     R0,R0,#+1
   \   000000E8   0xB2C0             UXTB     R0,R0
   \   000000EA   0x43C1             MVNS     R1,R0
   \                     ??main_16: (+1)
   \   000000EC   0x7028             STRB     R0,[R5, #+0]
   \   000000EE   0x7129             STRB     R1,[R5, #+4]
   \   000000F0   0x7828             LDRB     R0,[R5, #+0]
   \   000000F2   0x2805             CMP      R0,#+5
   \   000000F4   0xD3BE             BCC.N    ??main_4
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0x7028             STRB     R0,[R5, #+0]
   \   000000FA   0x712E             STRB     R6,[R5, #+4]
   \   000000FC   0x.... 0x....      BL       SRFlow__MainCheck
   \   00000100   0xE7B8             B.N      ??main_4
    383          #if (SRMAIN_LOW_POWER_FEATURE == ENABLED)
    384                              if (SRPowerMgr__GetPowerModeState() == SRPOWERMGR_STATE_LOW_POWER)
    385                              {
    386                                  SRMainUpdateByte((uint8 *)&SRMain_Power_State,(uint8 *)&N_SRMain_Power_State,SRMAIN_STATE_SWITHCING_TO_LOW_POWER);
    387                              }
    388                              break;
    389                          case SRMAIN_STATE_SWITHCING_TO_LOW_POWER:
    390                              SRPowerMgr__SwitchToLowPowerTasks();
    391                              SRMainUpdateByte((uint8 *)&SRMain_Power_State,(uint8 *)&N_SRMain_Power_State,SRMAIN_STATE_LOW_POWER);
    392          
    393                              SR_FLOW_INITILIZE();    // Forces Initialization so the LowPower events can be log from the begin.
    394                              break;
    395                          case SRMAIN_STATE_LOW_POWER:
    396                              // Placement here insures that both the main loop and the main timer interrupt are running.
    397                              // Ideally, this would be the only call anywhere in the code.
    398                              SRMicro__ServiceWatchdog();
    399          
    400                              // Execute tasks that run SR every slot
    401                              ExecuteTasks(SRLowPower_Tasks);
    402          
    403                              SR_FLOW_CHECK_LOWPOWER();
    404          
    405                              // Execute tasks that run every slot
    406                              ExecuteTasks(LowPower_Tasks);
    407          
    408                              if (SRPowerMgr__GetPowerModeState() == SRPOWERMGR_STATE_NORMAL_POWER)
    409                              {
    410                                  SRMainUpdateByte((uint8 *)&SRMain_Power_State,(uint8 *)&N_SRMain_Power_State,SRMAIN_STATE_SWITHING_TO_NORMAL_POWER);
    411                              }
    412                              else
    413                              {
    414                                  SRPowerMgr__GoSleep();
    415                              }
    416          
    417                              break;
    418                          case SRMAIN_STATE_SWITHING_TO_NORMAL_POWER:
    419          
    420                              // Actions to be taken when switching to the Normal Power Mode.
    421                              // tasks that must be initializes should be included within SRPowerMgr__SwitchToNormalPowerTasks
    422                              SRPowerMgr__SwitchToNormalPowerTasks();
    423          
    424                              // Initialize the SR Flow control module
    425                              SR_FLOW_INITILIZE();
    426          
    427                              //Main_Slot = 0;
    428                              SRMainUpdateByte(&Main_Slot, &N_Main_Slot,0);
    429          
    430                              //Interrupt_Slot = 0;
    431                              SRMainUpdateByte(&Interrupt_Slot, &N_Interrupt_Slot,0);
    432          
    433                              // There's no Break in this state, it falls down to the default case
    434                              //lint -fallthrough
    435                          default:
    436                              SRMainUpdateByte((uint8 *)&SRMain_Power_State,(uint8 *)&N_SRMain_Power_State,SRMAIN_STATE_NORMAL_POWER);
    437                              break;
    438                      }
    439          #endif
    440              }                                               //End forever loop
    441          }                                                   //End main
    442          
    443          
    444          //---------------------------------------------------------------------------------------------------------------------
    445          /**
    446           *  @brief      Interrupt handler for the timer interrupt.
    447           *
    448           *  @image      html SRMain_ISR_Activity.jpg
    449           *
    450           *  @details    This routine implements an interrupt service routine with a gated slotted
    451           *              architecture.  Each interrupt calls the routines for the next interrupt slot.
    452           *              It can be configured through the parameter files.
    453           */

   \                                 In section .text, align 4, keep-with-next
    454          INTERRUPT_DIRECTIVE void SRMain__TimerISR( void )
    455          {
   \                     SRMain__TimerISR: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    456              // Macro for timing analyzes
    457              MAIN_DEBUG_BEFORE_INTERRUPT_SLOTS();
    458          
    459          #if (SRMAIN_LOW_POWER_FEATURE == ENABLED)
    460              if (SRMain_Power_State == SRMAIN_STATE_NORMAL_POWER)
    461              {
    462          #endif
    463          
    464          
    465                  // Macro for checking the SR Variables
    466                  SRMAIN_CHECK_INTERRUPT_SR_VARIABLES();
    467          
    468                  // SR Tasks every Timer Interrupt
    469                  ExecuteTasks(SREvery_Interrupt_Tasks);
   \   00000004   0x.... 0x....      ADR.W    R4,SREvery_Interrupt_Tasks
   \   00000008   0xE003             B.N      ??SRMain__TimerISR_0
   \   0000000A   0xBF00             Nop      
   \                     ??SRMain__TimerISR_1: (+1)
   \   0000000C   0xF854 0x0B04      LDR      R0,[R4], #+4
   \   00000010   0x4780             BLX      R0
   \                     ??SRMain__TimerISR_0: (+1)
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD1F9             BNE.N    ??SRMain__TimerISR_1
    470          
    471                  // SR Tasks specific Timer Interrupt Slot
    472                  ExecuteTasks(SRInterrupt_Tasks[Interrupt_Slot]);
   \   00000018   0x....             LDR.N    R4,??DataTable29_1
   \   0000001A   0x.... 0x....      ADR.W    R0,SRInterrupt_Tasks
   \   0000001E   0x7861             LDRB     R1,[R4, #+1]
   \   00000020   0xF850 0x5021      LDR      R5,[R0, R1, LSL #+2]
   \   00000024   0xE003             B.N      ??SRMain__TimerISR_2
   \   00000026   0xBF00             Nop      
   \                     ??SRMain__TimerISR_3: (+1)
   \   00000028   0xF855 0x0B04      LDR      R0,[R5], #+4
   \   0000002C   0x4780             BLX      R0
   \                     ??SRMain__TimerISR_2: (+1)
   \   0000002E   0x6828             LDR      R0,[R5, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD1F9             BNE.N    ??SRMain__TimerISR_3
    473          
    474                  // Macro for checking the SR Variables
    475                  SRMAIN_CRC_INTERRUPT_SR_VARIABLES();
    476          
    477                  // Class A Tasks every Timer Interrupt
    478                  ExecuteTasks(Every_Interrupt_Tasks);
   \   00000034   0x.... 0x....      ADR.W    R5,Every_Interrupt_Tasks
   \   00000038   0xE003             B.N      ??SRMain__TimerISR_4
   \   0000003A   0xBF00             Nop      
   \                     ??SRMain__TimerISR_5: (+1)
   \   0000003C   0xF855 0x0B04      LDR      R0,[R5], #+4
   \   00000040   0x4780             BLX      R0
   \                     ??SRMain__TimerISR_4: (+1)
   \   00000042   0x6828             LDR      R0,[R5, #+0]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD1F9             BNE.N    ??SRMain__TimerISR_5
    479          
    480                  // Class A Tasks specific Timer Interrupt Slot
    481                  if (Interrupt_Slot < INTERRUPT_SLOT_COUNT)
   \   00000048   0x7860             LDRB     R0,[R4, #+1]
   \   0000004A   0x2804             CMP      R0,#+4
   \   0000004C   0xD20A             BCS.N    ??SRMain__TimerISR_6
    482                  {
    483                      ExecuteTasks(Interrupt_Tasks[Interrupt_Slot]);
   \   0000004E   0x.... 0x....      ADR.W    R1,Interrupt_Tasks
   \   00000052   0xF851 0x5020      LDR      R5,[R1, R0, LSL #+2]
   \   00000056   0xE002             B.N      ??SRMain__TimerISR_7
   \                     ??SRMain__TimerISR_8: (+1)
   \   00000058   0xF855 0x0B04      LDR      R0,[R5], #+4
   \   0000005C   0x4780             BLX      R0
   \                     ??SRMain__TimerISR_7: (+1)
   \   0000005E   0x6828             LDR      R0,[R5, #+0]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD1F9             BNE.N    ??SRMain__TimerISR_8
    484                  }
    485          
    486                  MAIN_TIMER_ISR_END(Interrupt_Slot);
    487          
    488                  // Move to the next interrupt Slot.  Roll back to zero if necessary.
    489                  //Interrupt_Slot++;
    490                  if (SRMainCheckByte(&Interrupt_Slot, &N_Interrupt_Slot) == FALSE)
   \                     ??SRMain__TimerISR_6: (+1)
   \   00000064   0x7860             LDRB     R0,[R4, #+1]
   \   00000066   0x7962             LDRB     R2,[R4, #+5]
   \   00000068   0x43C1             MVNS     R1,R0
   \   0000006A   0xB2C9             UXTB     R1,R1
   \   0000006C   0x4291             CMP      R1,R2
   \   0000006E   0xD002             BEQ.N    ??SRMain__TimerISR_9
    491                  {
    492                      // slot corrupted
    493                      SRMainUpdateByte(&Interrupt_Slot, &N_Interrupt_Slot,0);
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x21FF             MOVS     R1,#+255
    494                  }
   \   00000074   0xE002             B.N      ??SRMain__TimerISR_10
    495                  else
    496                  {
    497                      SRMainUpdateByte(&Interrupt_Slot, &N_Interrupt_Slot,Interrupt_Slot + 1);
   \                     ??SRMain__TimerISR_9: (+1)
   \   00000076   0x1C40             ADDS     R0,R0,#+1
   \   00000078   0xB2C0             UXTB     R0,R0
   \   0000007A   0x43C1             MVNS     R1,R0
    498                  }
   \                     ??SRMain__TimerISR_10: (+1)
   \   0000007C   0x7060             STRB     R0,[R4, #+1]
   \   0000007E   0x7161             STRB     R1,[R4, #+5]
    499          
    500          
    501                  if (Interrupt_Slot >= SR_INTERRUPT_SLOT_COUNT)
   \   00000080   0x7860             LDRB     R0,[R4, #+1]
   \   00000082   0x2804             CMP      R0,#+4
   \   00000084   0xD305             BCC.N    ??SRMain__TimerISR_11
    502                  {
    503                      //Interrupt_Slot = 0;
    504                      SRMainUpdateByte(&Interrupt_Slot, &N_Interrupt_Slot,0);
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x7060             STRB     R0,[R4, #+1]
   \   0000008A   0x20FF             MOVS     R0,#+255
   \   0000008C   0x7160             STRB     R0,[R4, #+5]
    505                      // Macro to the SR Flow control on the ISR SR tasks
    506                      SR_FLOW_CHECK_ISR();
   \   0000008E   0x.... 0x....      BL       SRFlow__ISRCheck
    507                  }
    508          
    509                  // Increment Main_Slot_Timer to synch Main Slot Time
    510                  Main_Slot_Timer++;
    511          
    512          #if (SRMAIN_LOW_POWER_FEATURE == ENABLED)
    513              }
    514              else
    515              {
    516                  TimerInterrupt__SetupNext();
    517              }
    518          #endif
    519          
    520              // Macro for timing analyzes
    521              MAIN_DEBUG_AFTER_INTERRUPT_SLOTS();
    522          }
   \                     ??SRMain__TimerISR_11: (+1)
   \   00000092   0xB001             ADD      SP,SP,#+4
   \   00000094   0x78A0             LDRB     R0,[R4, #+2]
   \   00000096   0x1C40             ADDS     R0,R0,#+1
   \   00000098   0x70A0             STRB     R0,[R4, #+2]
   \   0000009A   0xBD30             POP      {R4,R5,PC}       ;; return
    523          
    524          
    525          //=====================================================================================================================
    526          //-------------------------------------- Private Functions ------------------------------------------------------------
    527          //=====================================================================================================================
    528          
    529          
    530          //---------------------------------------------------------------------------------------------------------------------
    531          /**
    532           *  @brief      Execute the list of tasks pointed to by task_list.
    533           *  @details    This code is approximately a 33% improvement in execution time and a 44%
    534           *              improvement in code size over a version that uses an index into the task_list
    535           *              array.  Former code shown here.
    536           *              <pre>
    537           *                  void ExecuteTasks(TASK_TYPE task_list[])
    538           *                  {
    539           *                      uint8 task;
    540           *
    541           *                      for (task=0; task_list[task] != NULL_TASK; task++)
    542           *                      {
    543           *                          task_list[task]();
    544           *                      }
    545           *                  }
    546           *              </pre>
    547           *
    548           *  @param      task_list = Null-terminated list of tasks to execute.
    549           *                          Each task must have the prototype: void Task(void)
    550           */

   \                                 In section .text, align 4, keep-with-next
    551          void ExecuteTasks(TASK_TYPE * task_list)
    552          {
   \                     ExecuteTasks: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xE003             B.N      ??ExecuteTasks_0
   \   00000006   0xBF00             Nop      
    553              while (*task_list != NULL_TASK)
    554              {
    555                  (*task_list)();
   \                     ??ExecuteTasks_1: (+1)
   \   00000008   0xF854 0x0B04      LDR      R0,[R4], #+4
   \   0000000C   0x4780             BLX      R0
    556                  task_list++;
    557              }
   \                     ??ExecuteTasks_0: (+1)
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD1F9             BNE.N    ??ExecuteTasks_1
    558          }
   \   00000014   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   0x........         DC32     SFE(CSTACK)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_1:
   \   00000000   0x........         DC32     Main_Slot
    559          
    560          
    561          /**
    562           * This method updates a Safety Byte Variable and it's backup variable
    563           *
    564           * @param data
    565           * @param ndata
    566           * @param value
    567           */
    568          static void SRMainUpdateByte(uint8 * data, uint8 * ndata,uint8 value)
    569          {
    570              *data = value;
    571              *ndata = SRMAIN_COMPLEMENT(value);
                              ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
    572          }
    573          
    574          /**
    575           * This method checks a Safety Byte Variable and its backup
    576           *
    577           * @param data
    578           * @param ndata
    579           * @return
    580           */
    581          static BOOL_TYPE SRMainCheckByte(uint8 * data, uint8 * ndata)
    582          {
    583              uint8 aux;
    584              BOOL_TYPE response;
    585              response = TRUE;
    586          
    587              aux = SRMAIN_COMPLEMENT(*data);
                           ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)

  static uint8 previews_slot;
               ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Common\SRMain\SRMain.c",215  Warning[Pe550]: 
          variable "previews_slot" was set but never used
    588              if (aux != (*ndata) )
    589              {
    590          
    591              	SR_EXCEPTION_MAIN_CORRUPT_BYTE_EXCEPTION(*data,*ndata);
    592                  response = FALSE;
    593              }
    594              return (response);
    595          }
    596          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   ExecuteTasks
         8   -- Indirect call
      16   SRMain__TimerISR
        16   -- Indirect call
        16   -> SRFlow__ISRCheck
      40   main
        40   -- Indirect call
        40   -> Micro__ServiceWatchdog
        40   -> SRFlow__InitCheck
        40   -> SRFlow__Initialize
        40   -> SRFlow__MainCheck
        40   -> __MSR_MSP


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable29
       4  ??DataTable29_1
      12  Every_Interrupt_Tasks
       8  Every_Slot_Tasks
      22  ExecuteTasks
      20  Initialization_Tasks
       4  Interrupt_Slot0_Tasks
       8  Interrupt_Slot1_Tasks
       4  Interrupt_Slot2_Tasks
       4  Interrupt_Slot3_Tasks
      16  Interrupt_Tasks
       6  Main_Slot
          Interrupt_Slot
          Main_Slot_Timer
          Main_Slot_Timer_Diff
          N_Main_Slot
          N_Interrupt_Slot
       8  Main_Slot0_Tasks
       8  Main_Slot1_Tasks
       4  Main_Slot2_Tasks
       4  Main_Slot3_Tasks
       4  Main_Slot4_Tasks
      20  Main_Tasks
       8  SREvery_Interrupt_Tasks
       8  SREvery_Slot_Tasks
      36  SRInitialization_Tasks
       8  SRInterrupt_Slot0_Tasks
       8  SRInterrupt_Slot1_Tasks
       8  SRInterrupt_Slot2_Tasks
       8  SRInterrupt_Slot3_Tasks
      16  SRInterrupt_Tasks
       8  SRMain_Slot0_Tasks
       8  SRMain_Slot1_Tasks
       8  SRMain_Slot2_Tasks
       4  SRMain_Slot3_Tasks
       4  SRMain_Slot4_Tasks
      20  SRMain_Tasks
     156  SRMain__TimerISR
     258  main
       1  previews_slot

 
   7 bytes in section .bss
 112 bytes in section .rodata
 608 bytes in section .text
 
 608 bytes of CODE  memory
 112 bytes of CONST memory
   7 bytes of DATA  memory

Errors: none
Warnings: 3
