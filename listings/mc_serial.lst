###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        13/Mar/2025  15:31:21
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  Category\Common\MasterCommander\Source\mc_serial.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        mc_serial.obj -l ..\listings\mc_serial.lst
#        Category\Common\MasterCommander\Source\mc_serial.c
#    List file    =  ..\listings\mc_serial.lst
#    Object file  =  mc_serial.obj
#
###############################################################################

C:\Data\Repository\WindyStrip_DTC_Orca\source\Category\Common\MasterCommander\Source\mc_serial.c
      1          /**
      2           *  @file
      3           *
      4           *  @brief      MasterCommander serial communication routines
      5           *
      6           *
      7           *  $Header: $
      8           *
      9           *  @copyright  Copyright 2016-$Date$. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     10           */
     11          //---------------------------------------------------------------------------------------------------------------------
     12          
     13          //-------------------------------------- Include Files ----------------------------------------------------------------
     14          
     15          #include "master_commander.h"
     16          #include "mc_llmem.h"
     17          #include "mc_private.h"
     18          #include "mc_protocol.h"
     19          #include "MasterCommander.h"
     20          
     21          #if !(MC_DISABLE)
     22          
     23          #if MC_USE_SERIAL
     24          
     25          /***********************************
     26          *  local variables 
     27          ***********************************/
     28          
     29          /* mc communication buffer (in/out) plus the STS and LEN bytes */

   \                                 In section .bss, align 4
     30          static MC_BCHR pcm_pCommBuffer[MC_COMM_BUFFER_SIZE+3];
     31          
     32          /* mc runtime flags */
     33          /*lint -e{960} using union */
     34          typedef volatile union 
     35          {
     36              MC_FLAGS all;
     37              
     38              struct
     39              {
     40                  unsigned bTxActive : 1;         /* response is being transmitted */
     41          #if MC_USE_SCI
     42                  unsigned bTxWaitTC : 1;         /* response sent, wait for transmission complete */
     43          #endif
     44                  unsigned bTxLastCharSOB   : 1;  /* last transmitted char was equal to SOB  */
     45                  unsigned bRxLastCharSOB   : 1;  /* last received character was SOB */
     46                  unsigned bRxMsgLengthNext : 1;  /* expect the length byte next time */
     47          #if MC_USE_JTAG
     48                  unsigned bJtagRIEPending  : 1;  /* JTAG RIE bit failed to be set, try again later */
     49          #endif
     50          #if (MC_USE_USB_CDC) || (MC_USE_MQX_IO) || (MC_USE_JTAG)
     51                  unsigned bTxFirstSobSend  : 1;  /* to send SOB char at the begin of the packet */
     52          #endif
     53          #if MC_USE_MQX_IO
     54                  unsigned bMqxReadyToSend  : 1;  /* to send next character in transmit routine */
     55          #endif
     56          #if MC_USE_USB_CDC
     57                  unsigned bUsbCdcStartApp   : 1; /* mc USB CDC Application start Init Flag */
     58                  unsigned bUsbCdcStartTrans : 1; /* mc USB CDC Application Carrier Activate Flag */
     59                  unsigned bUsbReadyToDecode : 1; /* mc packet is received, ready to decode in Poll function in Short Interrupt mode */
     60          #endif
     61              } flg;
     62              
     63          } MC_SERIAL_FLAGS;
     64          
     65          static MC_SERIAL_FLAGS pcm_wFlags;
     66          
     67          /* receive and transmit buffers and counters */
     68          static MC_SIZE8 pcm_nTxTodo;     /* transmission to-do counter (0 when tx is idle) */
   \                     pcm_nTxTodo:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 1
   \   00000003                      DS8 1
   \   00000004                      DS8 64
   \   00000044                      DS8 4
   \   00000048                      DS8 4
   \   0000004C                      DS8 4
     69          static MC_SIZE8 pcm_nRxTodo;     /* reception to-do counter (0 when rx is idle) */
     70          static MC_BPTR  pcm_pTxBuff;     /* pointer to next byte to transmit */
     71          static MC_BPTR  pcm_pRxBuff;     /* pointer to next free place in RX buffer */
     72          static MC_BCHR  pcm_nRxCheckSum; /* checksum of data being received */
     73          
     74          /***********************************
     75          *  local function prototypes
     76          ***********************************/
     77          
     78          static void MC_Listen(void);
     79          static void MC_SendError(MC_BCHR nErrCode);
     80          
     81          #else /* MC_USE_SERIAL */
     82          
     83          /*lint -efile(766, mc_protocol.h) include file is not used in this case */
     84          
     85          #endif /* MC_USE_SERIAL */
     86          
     87          #if (MC_USE_SCI) || (MC_USE_JTAG)
     88          /***********************************
     89          *  local variables 
     90          ***********************************/
     91          
     92          /* SHORT_INTR receive queue (circular buffer) */
     93          #if MC_SHORT_INTR
     94          static MC_BCHR  pcm_pRQueueBuffer[MC_COMM_RQUEUE_SIZE];
     95          static MC_BPTR  pcm_pRQueueRP;   /* SHORT_INTR queue read-pointer */
     96          static MC_BPTR  pcm_pRQueueWP;   /* SHORT_INTR queue write-pointer */
     97          #endif
     98          
     99          /***********************************
    100          *  local function prototypes
    101          ***********************************/
    102          
    103          #if MC_SHORT_INTR
    104          static void MC_RxQueue(MC_BCHR nRxChar);
    105          static void MC_RxDequeue(void);
    106          #endif
    107          
    108          /*lint -esym(752,MC_RxQueue) this may be unreferenced in some cases */
    109          /*lint -esym(752,MC_RxDequeue) this may be unreferenced in some cases */
    110          
    111          /*******************************************************************************
    112          *
    113          * @brief    Routine to quick-receive a character (put to a queue only)
    114          *
    115          * This function puts received character into a queue and exits as soon as possible.
    116          *
    117          *******************************************************************************/
    118          
    119          #if MC_SHORT_INTR
    120          
    121          static void MC_RxQueue(MC_BCHR nRxChar)
    122          {
    123              /* future value of write pointer */
    124              MC_BPTR wpnext = pcm_pRQueueWP + 1;
    125              
    126              /*lint -e{946} pointer arithmetic is okay here (same array) */
    127              if(wpnext >= (pcm_pRQueueBuffer + MC_COMM_RQUEUE_SIZE))
    128              {
    129                  wpnext = pcm_pRQueueBuffer;
    130              }
    131              
    132              /* any space in queue? */
    133              if(wpnext != pcm_pRQueueRP)
    134              {
    135                  *pcm_pRQueueWP = (MC_U8) nRxChar;
    136                  pcm_pRQueueWP = wpnext;
    137              }
    138          }
    139          
    140          #endif /* MC_SHORT_INTR  */
    141          
    142          /*******************************************************************************
    143          *
    144          * @brief    Late processing of queued characters
    145          *
    146          * This function takes the queued characters and calls MC_Rx() for each of them,
    147          * just like as the characters would be received from SCI one by one.
    148          *
    149          *******************************************************************************/
    150          
    151          #if MC_SHORT_INTR
    152          
    153          static void MC_RxDequeue(void)
    154          { 
    155              MC_BCHR nChar = 0U;
    156              
    157              /* get all queued characters */
    158              while(pcm_pRQueueRP != pcm_pRQueueWP)
    159              {
    160                  nChar = *pcm_pRQueueRP++;
    161          
    162                  /*lint -e{946} pointer arithmetic is okay here (same array) */
    163                  if(pcm_pRQueueRP >= (pcm_pRQueueBuffer + MC_COMM_RQUEUE_SIZE))
    164                  {
    165                      pcm_pRQueueRP = pcm_pRQueueBuffer;
    166                  }
    167                  
    168                  /* emulate the SCI receive event */
    169                  if(!pcm_wFlags.flg.bTxActive)
    170                  {
    171                      (void)MC_Rx(nChar);
    172                  }
    173              }
    174          }
    175          
    176          #endif /* MC_SHORT_INTR */
    177          
    178          #endif /* (MC_USE_SCI) || (MC_USE_JTAG) */
    179          
    180          #if MC_USE_SCI
    181          
    182          /**************************************************************************//*!
    183          *
    184          * @brief    Handle SCI communication (both TX and RX)
    185          *
    186          * This function checks the SCI flags and calls the Rx and/or Tx functions
    187          *
    188          * @note This function can be called either from SCI ISR or from the polling routine
    189          *
    190          ******************************************************************************/
    191          

   \                                 In section .text, align 2, keep-with-next
    192          void MC_ProcessSCI(void)
    193          {
   \                     MC_ProcessSCI: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    194          	unsigned char i;
    195              /* read & clear status     */
    196              MC_SCISR wSciSR;
    197          
    198              /* transmitter active and empty? */
    199              if (pcm_wFlags.flg.bTxActive)
   \   00000002   0x....             LDR.N    R4,??DataTable4
   \   00000004   0x6C60             LDR      R0,[R4, #+68]
   \   00000006   0x07C0             LSLS     R0,R0,#+31
   \   00000008   0xD525             BPL.N    ??MC_ProcessSCI_0
    200              {
    201              	wSciSR = Uart__GetStatus(MASTERCOMMANDER_COMPORT, UART_STATUS_TX_AVAILABLE);
    202          
    203                  /* able to accept another character? */
    204                  if(wSciSR)
   \   0000000A   0x2103             MOVS     R1,#+3
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      BL       Uart__GetStatus
   \   00000012   0xB368             CBZ.N    R0,??MC_ProcessSCI_1
    205                  {
    206          			MC_U8 ch;
    207          			/* just put the byte into the SCI transmit buffer */
    208          			if(!MC_Tx(&ch))
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0xB1A0             CBZ.N    R0,??MC_ProcessSCI_2
   \   00000018   0x6CA2             LDR      R2,[R4, #+72]
   \   0000001A   0x7811             LDRB     R1,[R2, #+0]
   \   0000001C   0x292B             CMP      R1,#+43
   \   0000001E   0xD107             BNE.N    ??MC_ProcessSCI_3
   \   00000020   0x6C63             LDR      R3,[R4, #+68]
   \   00000022   0xF083 0x0304      EOR      R3,R3,#0x4
   \   00000026   0x6463             STR      R3,[R4, #+68]
   \   00000028   0x6C63             LDR      R3,[R4, #+68]
   \   0000002A   0xF3C3 0x0380      UBFX     R3,R3,#+2,#+1
   \   0000002E   0xB91B             CBNZ.N   R3,??MC_ProcessSCI_4
   \                     ??MC_ProcessSCI_3: (+1)
   \   00000030   0x1E40             SUBS     R0,R0,#+1
   \   00000032   0x7020             STRB     R0,[R4, #+0]
   \   00000034   0x1C50             ADDS     R0,R2,#+1
   \   00000036   0x64A0             STR      R0,[R4, #+72]
    209          				Uart__WriteByte(MASTERCOMMANDER_COMPORT, ch);
   \                     ??MC_ProcessSCI_4: (+1)
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000003E   0x.... 0x....      B.W      Uart__WriteByte
    210                  }
    211                  
    212          #if MC_SCI_HAS_TXQUEUE
    213                  /* waiting for transmission complete flag? */
    214                  if(pcm_wFlags.flg.bTxWaitTC && (wSciSR & MC_SCISR_TC))
    215                  {
    216                      /* after TC, we can switch to listen mode safely */
    217                      MC_Listen();
    218                  }
    219          #endif
    220          
    221          
    222          #if !MC_SCI_TWOWIRE_ONLY
    223                  /* read-out and ignore any received character (loopback) */
    224                  if(wSciSR & MC_SCISR_RDRF)
    225                  {
    226                      /*lint -esym(550, nRxChar) */
    227                      volatile MC_U16 nRxChar;
    228                      nRxChar = Uart__ReadByte(MASTERCOMMANDER_COMPORT);
    229                  }
    230          #endif
    231              }
   \                     ??MC_ProcessSCI_2: (+1)
   \   00000042   0x7060             STRB     R0,[R4, #+1]
   \   00000044   0x6C60             LDR      R0,[R4, #+68]
   \   00000046   0x0840             LSRS     R0,R0,#+1
   \   00000048   0x0040             LSLS     R0,R0,#+1
   \   0000004A   0x6460             STR      R0,[R4, #+68]
   \   0000004C   0x6C60             LDR      R0,[R4, #+68]
   \   0000004E   0xF020 0x0002      BIC      R0,R0,#0x2
   \   00000052   0x6460             STR      R0,[R4, #+68]
   \   00000054   0xBD10             POP      {R4,PC}
    232              /* transmitter not active, able to receive */
    233              else
    234              {
    235              	wSciSR = Uart__GetStatus(MASTERCOMMANDER_COMPORT, UART_STATUS_RX_AVAILABLE);
   \                     ??MC_ProcessSCI_0: (+1)
   \   00000056   0x2104             MOVS     R1,#+4
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x.... 0x....      BL       Uart__GetStatus
   \   0000005E   0x0004             MOVS     R4,R0
    236          
    237                  /* data byte received? */
    238                  if(wSciSR)
   \   00000060   0xD006             BEQ.N    ??MC_ProcessSCI_1
    239                  {
    240                  	for(i = 0; i < wSciSR; i++)
    241                  	{
    242          				MC_BCHR nRxChar = 0U;
    243          				nRxChar = (MC_BCHR)Uart__ReadByte(MASTERCOMMANDER_COMPORT);
   \                     ??MC_ProcessSCI_5: (+1)
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0x.... 0x....      BL       Uart__ReadByte
    244          
    245          #if MC_SHORT_INTR
    246          			MC_RxQueue(nRxChar);
    247          #else
    248          			(void)MC_Rx(nRxChar);
   \   00000068   0x.... 0x....      BL       MC_Rx
    249          #endif
    250                  	}
   \   0000006C   0x1E64             SUBS     R4,R4,#+1
   \   0000006E   0xD1F8             BNE.N    ??MC_ProcessSCI_5
    251                  }
    252              }
    253          }
   \                     ??MC_ProcessSCI_1: (+1)
   \   00000070   0xBD10             POP      {R4,PC}          ;; return
    254          
    255          #endif /* MC_USE_SCI */
    256          
    257          
    258          #if MC_USE_JTAG
    259          
    260          /***********************************
    261          *  local function prototypes
    262          ***********************************/
    263          
    264          static void MC_FlushJtagTx(void);
    265          
    266          /**************************************************************************//*!
    267          *
    268          * @brief    Flush one communication JTAG word 
    269          *
    270          * This function gets the 4 bytes from mc TX buffer and place them to
    271          * JTAG transmit register.
    272          *
    273          ******************************************************************************/
    274          
    275          static void MC_FlushJtagTx(void)
    276          {
    277              MC_U8 i;
    278              MC_U32 wJtagTxData;
    279              register MC_U16 wJtagSR = MC_JTAG_GETSR();
    280              /* complete word to send */
    281              for (i=0; i<4; i++)
    282              {
    283                  MC_U8 ch;
    284                  if (MC_Tx(&ch))
    285                      ch = 0xff;
    286                  wJtagTxData = (wJtagTxData << 8) | ch;
    287              }
    288          
    289              /* send the word just completed */
    290              MC_JTAG_PUTDWORD(wJtagTxData);
    291          }
    292          
    293          /**************************************************************************//*!
    294          *
    295          * @brief    Handle JTAG communication (both TX and RX)
    296          *
    297          * This function checks the JTAG flags and calls the Rx and/or Tx functions
    298          *
    299          * @note This function can be called either from JTAG ISR or from the polling routine
    300          *
    301          ******************************************************************************/
    302          
    303          void MC_ProcessJTAG(void)
    304          {
    305              /* read & clear status     */
    306              register MC_U16 wJtagSR = MC_JTAG_GETSR();
    307          
    308              /* transmitter active? */
    309              if (pcm_wFlags.flg.bTxActive)
    310              {
    311                  /* able to transmit a new character? (TX must be empty = read-out by PC) */
    312                  if(!(wJtagSR & MC_JTAG_OTXRXSR_TDF))
    313                  {
    314                  
    315          #if MC_USE_JTAG_TXFIX
    316                      /* if TDF bit is useless due to silicon bug, use the RX flag */
    317                      /* instead (PC sends us a dummy word to kick the RX flag on) */
    318                      if(wJtagSR & MC_JTAG_OTXRXSR_RDF)
    319          #endif
    320                      {
    321                          MC_FlushJtagTx();
    322                      }               
    323                  }
    324          
    325                  /* ignore (read-out) the JTAG-received word */
    326                  if(wJtagSR & MC_JTAG_OTXRXSR_RDF)
    327                  {
    328                      /*lint -esym(550, nRxWord) */
    329                      volatile MC_U16 nRxWord;
    330                      nRxWord = MC_JTAG_GETWORD();
    331                  }
    332              }
    333              /* transmitter not active */
    334              else
    335              {
    336                  /* JTAG 32bit word (four bytes) received? */
    337                  if(wJtagSR & MC_JTAG_OTXRXSR_RDF)
    338                  {
    339                      register MC_U32 nRxDWord;
    340                      MC_INDEX i;
    341                      
    342                      nRxDWord = MC_JTAG_GETDWORD();
    343                      
    344                      /* process all bytes, MSB first */
    345                      for(i=0; i<4; i++)
    346                      {
    347          #if MC_SHORT_INTR
    348                          MC_RxQueue((MC_BCHR)((nRxDWord >> 24U) & 0xffU));
    349          
    350          #else
    351                          (void)MC_Rx((MC_BCHR)((nRxDWord >> 24U) & 0xffU));
    352                      
    353                          /* ignore the rest if previous bytes triggered a transmission */
    354                          /* (i.e. the packet was complete and only filled-up to 32bit word) */
    355                          if(pcm_wFlags.flg.bTxActive)
    356                          {
    357                              break;
    358                          }
    359          #endif
    360                          /* next byte of 32bit word */
    361                          nRxDWord = nRxDWord << 8;
    362                      }
    363                  }
    364              }
    365          }
    366          
    367          #endif /* MC_USE_JTAG */
    368          
    369          /******************************************************************************
    370          ****************************************************************************//*!
    371          *
    372          * mc MQX IO serial communication routines
    373          * 
    374          *******************************************************************************/
    375          
    376          #if MC_USE_MQX_IO
    377          
    378          #include <mqx.h>
    379          #include <bsp.h>
    380          
    381          /***********************************
    382          *  local variables 
    383          ***********************************/
    384          
    385          static FILE_PTR devfd = NULL;       /* pointer to open mc communication interface */
    386          
    387          /***********************************
    388          *  local function prototypes
    389          ***********************************/
    390          
    391          static MC_BOOL MC_InitMQX(void);
    392          static void MC_ProcessMQXIO(void);
    393          
    394          /**************************************************************************//*!
    395          *
    396          * @brief    MQX communication interface initialization
    397          *
    398          ******************************************************************************/
    399          
    400          static MC_BOOL MC_InitMQX(void)
    401          {   
    402              /* Open communication port */
    403              devfd = fopen (MC_MQX_IO_CHANNEL, (char const *)MC_MQX_IO_PARAMETER);
    404          
    405              return (devfd != NULL);
    406          }
    407          
    408          /*******************************************************************************
    409          *
    410          * @brief    Handle MQX IO serial communication (both TX and RX)
    411          *
    412          * This function calls MQX IO fread() function to get character and process it by 
    413          * 
    414          * MC_Rx function when mc packet is receiving. This function also transmit
    415          *
    416          * mc response. Character to be send is provided by call of MC_Tx function
    417          * 
    418          * and passed down to fwrite() function.
    419          *
    420          *******************************************************************************/
    421          
    422          static void MC_ProcessMQXIO(void)
    423          { 
    424              if (devfd != NULL)
    425              {
    426                   static MC_U8 TxChar = 0;
    427                  /* transmitter not active, able to receive */
    428                  if ((!pcm_wFlags.flg.bTxActive) && (!pcm_wFlags.flg.bMqxReadyToSend))
    429                  {
    430                      MC_U8 nRxChar;
    431                      /* read all available bytes from communication interface */
    432                      while (fread(&nRxChar, 1, 1, devfd)) { 
    433                          if(MC_Rx(nRxChar))
    434                              break;
    435                      }
    436                  }
    437          
    438                  /* transmitter active and empty? */
    439                  if (pcm_wFlags.flg.bTxActive || pcm_wFlags.flg.bMqxReadyToSend)
    440                  {
    441                      while (1)
    442                      {
    443                          /* write character when is valid */
    444                          if (pcm_wFlags.flg.bMqxReadyToSend)
    445                          {
    446                              if (fwrite(&TxChar, 1, 1, devfd))
    447                                  /* character was successfully send, ready to get next character */
    448                                  pcm_wFlags.flg.bMqxReadyToSend = 0;
    449                              else
    450                                  /* character write failed, needs to be send next call */
    451                                  break;
    452          
    453                          }
    454                          /* is ready to get next character? */
    455                          if (MC_Tx((MC_U8*)&TxChar))
    456                              /* mc packet is sent, exit loop */
    457                              break;
    458                          /* read next character, set its validity to be send */
    459                          pcm_wFlags.flg.bMqxReadyToSend = 1;
    460                      }
    461                  }	
    462              }
    463          }
    464          
    465          #else /* MC_USE_MQX_IO */
    466          
    467          /*lint -efile(766, mc_protocol.h) include file is not used in this case */
    468          
    469          #endif /* MC_USE_MQX_IO */
    470          
    471          /******************************************************************************
    472          ****************************************************************************//*!
    473          *
    474          * mc USB CDC serial communication routines
    475          * 
    476          *******************************************************************************/
    477          
    478          #if MC_USE_USB_CDC
    479          #include "usb_cdc.h"        /* USB CDC Class Header File */
    480          
    481          /***********************************
    482          *  Global variables
    483          ***********************************/
    484          MC_U8 send_buf[DIC_BULK_IN_ENDP_PACKET_SIZE]; //buffer for store packet to send
    485          
    486          /***********************************
    487          *  local function prototypes
    488          ***********************************/
    489          
    490          static MC_BOOL MC_InitUSB(void);
    491          static void MC_ProcessUSB(void);
    492          static void MC_SendUsbPacket(void);
    493          
    494          static void MC_USB_CDC_Callback(MC_U8 controller_ID,
    495                                  MC_U8 event_type, void* val);
    496          static void MC_USB_CDC_Notify_Callback(MC_U8 controller_ID,
    497                                  MC_U8 event_type, void* val);
    498          
    499          /**************************************************************************//*!
    500          *
    501          * @brief    USB CDC communication interface initialization
    502          *
    503          ******************************************************************************/
    504          
    505          static MC_BOOL MC_InitUSB(void)
    506          {   
    507              MC_U8   error;
    508          
    509              /* Initialize the USB interface */
    510              error = USB_Class_CDC_Init(MC_USB_CDC_ID,MC_USB_CDC_Callback,
    511                                          NULL,MC_USB_CDC_Notify_Callback, TRUE);
    512              if(error != USB_OK)
    513              {
    514                  /* Error initializing USB-CDC Class */
    515                  return MC_FALSE;
    516              }
    517          
    518              return MC_TRUE;
    519          }
    520          
    521          /**************************************************************************//*!
    522          *
    523          * @brief    Handle USB CDC class periodic task and initialize mc TX packet
    524          *
    525          * This function perform USB CDC periodic task. In Short Interrupt mode also decode
    526          * received mc packet and initialize transmit
    527          *
    528          ******************************************************************************/
    529          static void MC_ProcessUSB(void)
    530          { 
    531              /* call the periodic task function */
    532              USB_Class_CDC_Periodic_Task();
    533          
    534          #if MC_SHORT_INTR
    535              /*check whether enumeration is complete or not */
    536              if((pcm_wFlags.flg.bUsbCdcStartApp) && (pcm_wFlags.flg.bUsbCdcStartTrans))
    537              {
    538                  /*transmitter not active, able to receive */
    539                  if ((!pcm_wFlags.flg.bTxActive) && (pcm_wFlags.flg.bUsbReadyToDecode))
    540                  {
    541                      MC_ProtocolDecoder(pcm_pCommBuffer);
    542                      pcm_wFlags.flg.bUsbReadyToDecode = 0;
    543                  }
    544              }
    545          #endif	
    546          }
    547          
    548          
    549          /**************************************************************************//*!
    550          *
    551          * @brief    Get data from mc TX buffer and send the data to USB device
    552          *
    553          * This function checks the mc transmit state and when mc is
    554          * ready to send response to PC, copy mc TX data to local buffer and
    555          * pass down the buffer to USB CDC TX function. 
    556          *
    557          ******************************************************************************/
    558          
    559          static void MC_SendUsbPacket(void)
    560          {
    561              /* transmitter active and empty? */
    562              if (pcm_wFlags.flg.bTxActive)
    563              {
    564                  MC_U8 index;
    565          
    566                  /* fill in the transmitter buffer */
    567                  for (index = 0; index < DIC_BULK_IN_ENDP_PACKET_SIZE; index++){
    568                      MC_U8 TxChar;
    569                      if (MC_Tx(&TxChar))
    570                          break;
    571                      send_buf[index] = TxChar;
    572                  }
    573                  
    574                 USB_Class_CDC_Interface_DIC_Send_Data(MC_USB_CDC_ID, send_buf,index);
    575              }
    576          }
    577          
    578          /******************************************************************************
    579           *
    580           *    @name        MC_USB_CDC_Callback
    581           *
    582           *    @brief       This function handles Class callback
    583           *
    584           *    @param       controller_ID    : Controller ID
    585           *    @param       event_type       : Value of the event
    586           *    @param       val              : gives the configuration value
    587           *
    588           *    @return      None
    589           *
    590           *****************************************************************************
    591           * This function is called from the class layer whenever reset occurs or enum
    592           * is complete. After the enum is complete this function sets a variable so
    593           * that the application can start.
    594           * This function also receives DATA Send and RECEIVED Events
    595           *****************************************************************************/
    596          
    597          static void MC_USB_CDC_Callback (
    598              MC_U8 controller_ID,   /* [IN] Controller ID */
    599              MC_U8 event_type,      /* [IN] value of the event */
    600              void* val               /* [IN] gives the configuration value */
    601          )
    602          {
    603              UNUSED (controller_ID)
    604              UNUSED (val)
    605              if(event_type == USB_APP_BUS_RESET)
    606              {
    607                  pcm_wFlags.flg.bUsbCdcStartApp = 0U;
    608              }
    609              else if(event_type == USB_APP_ENUM_COMPLETE)
    610              {
    611                  pcm_wFlags.flg.bUsbCdcStartApp = 1U;
    612              }
    613              else if((event_type == USB_APP_DATA_RECEIVED) && (pcm_wFlags.flg.bUsbCdcStartTrans))
    614              {
    615                  /* manage received data */
    616                  if (pcm_wFlags.flg.bUsbCdcStartApp)
    617                  {
    618                      /* Copy Received Data buffer to Application Buffer */
    619                      USB_PACKET_SIZE BytesToBeCopied;
    620                      APP_DATA_STRUCT* dp_rcv = (APP_DATA_STRUCT*)val;
    621                      BytesToBeCopied = dp_rcv->data_size;
    622          
    623                      /* transmitter not active, able to receive */
    624                      if (!pcm_wFlags.flg.bTxActive)
    625                      {
    626                          MC_U8 index;
    627                          for(index = 0 ; index<BytesToBeCopied ; index++){
    628                              if(MC_Rx(dp_rcv->data_ptr[index])){
    629                                  break;
    630                              }
    631                          }
    632                          /* continue receiving, when packet is not decoded */
    633                          if (index == BytesToBeCopied) /* receive next packet only when are not received all bytes of packet */
    634                              (void)USB_Class_CDC_Interface_DIC_Recv_Data(MC_USB_CDC_ID, NULL, 0);
    635                      }
    636                  }
    637              }
    638              else if((event_type == USB_APP_SEND_COMPLETE) && (pcm_wFlags.flg.bUsbCdcStartTrans))
    639              {
    640                  if ((pcm_wFlags.flg.bUsbCdcStartApp) && (pcm_wFlags.flg.bTxActive))
    641                      /* Finalize USB packet to transmit and send packet */
    642                      MC_SendUsbPacket();
    643                  else
    644                      /* Previous Send is complete. Queue next receive */
    645                      (void)USB_Class_CDC_Interface_DIC_Recv_Data(MC_USB_CDC_ID, NULL, 0);
    646              }
    647          
    648              return;
    649          }
    650          
    651          /******************************************************************************
    652           *
    653           *    @name        MC_USB_CDC_Notify_Callback
    654           *
    655           *    @brief       This function handles PSTN Sub Class callbacks
    656           *
    657           *    @param       controller_ID    : Controller ID
    658           *    @param       event_type       : PSTN Event Type
    659           *    @param       val              : gives the configuration value
    660           *
    661           *    @return      None
    662           *
    663           *****************************************************************************
    664           * This function handles USB_APP_CDC_CARRIER_ACTIVATED and
    665           * USB_APP_CDC_CARRIER_DEACTIVATED PSTN Events
    666           *****************************************************************************/
    667          
    668          static void MC_USB_CDC_Notify_Callback (
    669              MC_U8 controller_ID,   /* [IN] Controller ID */
    670              MC_U8 event_type,      /* [IN] PSTN Event Type */
    671              void* val               /* [IN] gives the configuration value */
    672          )
    673          {
    674              UNUSED (controller_ID)
    675              UNUSED (val)
    676              if(pcm_wFlags.flg.bUsbCdcStartApp)
    677              {
    678                  if(event_type == USB_APP_CDC_CARRIER_ACTIVATED)
    679                  {
    680                      pcm_wFlags.flg.bUsbCdcStartTrans = 1U;
    681                  }
    682                  else if(event_type == USB_APP_CDC_CARRIER_DEACTIVATED)
    683                  {
    684                      pcm_wFlags.flg.bUsbCdcStartTrans = 0U;
    685                  }
    686              }
    687              return;
    688          }
    689          
    690          #else /* MC_USE_USB_CDC */
    691          
    692          /*lint -efile(766, mc_protocol.h) include file is not used in this case */
    693          
    694          #endif /* MC_USE_USB_CDC */
    695          
    696          
    697          #if MC_USE_SERIAL
    698          
    699          /**************************************************************************//*!
    700          *
    701          * @brief    Start listening on a serial line
    702          *
    703          * Reset the receiver machine and start listening on a serial line
    704          *
    705          ******************************************************************************/
    706          
    707          static void MC_Listen(void)
    708          {
    709              pcm_nRxTodo = 0U;
    710          
    711              /* disable transmitter state machine */
    712              pcm_wFlags.flg.bTxActive = 0U;
    713          
    714          #if MC_USE_SCI
    715              pcm_wFlags.flg.bTxWaitTC = 0U;
    716              /* disable transmitter, enable receiver (enables single-wire connection) */
    717          #if !MC_SCI_TWOWIRE_ONLY
    718              MC_SCI_TD();
    719              MC_SCI_RE();
    720          #endif
    721          #endif /* MC_USE_SCI */
    722          
    723              /* disable transmit, enable receive interrupts */
    724          #if MC_SHORT_INTR || MC_LONG_INTR
    725          #if MC_USE_SCI
    726              MC_SCI_DTXI();   /* disable SCI transmit interrupt */
    727              MC_SCI_ERXI();   /* enable SCI receive interrupt */
    728              
    729          #elif MC_USE_JTAG
    730              MC_JTAG_DTXI();  /* disable JTAG transmit interrupt  */
    731              MC_JTAG_ERXI();  /* enable JTAG receive interrupt  */
    732          
    733              /* RIE bit is forced low by HW until EONCE is first accessed, we will try again in MC_Poll */
    734              if(!MC_JTAG_ERXI_CHECK())
    735                  pcm_wFlags.flg.bJtagRIEPending = 1;
    736          
    737          #endif /* MC_USE_SCI / MC_USE_JTAG  */
    738          #endif /* MC_SHORT_INTR || MC_LONG_INTR */
    739          }
    740          
    741          /**************************************************************************//*!
    742          *
    743          * @brief    Send response of given error code (no data) 
    744          *
    745          * @param    nErrCode - error code to be sent
    746          *
    747          ******************************************************************************/
    748          
    749          static void MC_SendError(MC_BCHR nErrCode)
    750          {
    751              /* fill & send single-byte response */
    752              *pcm_pCommBuffer = nErrCode;
    753              MC_SendResponse(pcm_pCommBuffer, 1U);
    754          }
    755          
    756          /**************************************************************************//*!
    757          *
    758          * @brief    Finalize transmit buffer before transmitting 
    759          *
    760          * @param    nLength - response length (1 for status + data length)
    761          *
    762          *
    763          * This Function takes the data already prepared in the transmit buffer 
    764          * (inlcuding the status byte). It computes the check sum and kicks on tx.
    765          *
    766          ******************************************************************************/
    767          

   \                                 In section .text, align 4, keep-with-next
    768          void MC_SendResponse(MC_BPTR pResponse, MC_SIZE8 nLength)
    769          {
   \                     MC_SendResponse: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    770              MC_U16 chSum = 0U;
    771              MC_SIZE8 i;
    772              MC_U8 c;
    773          
    774              /* remember the buffer to be sent */
    775              pcm_pTxBuff = pResponse;
   \   00000002   0x....             LDR.N    R2,??DataTable4
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x6490             STR      R0,[R2, #+72]
    776              
    777              /* status byte and data are already there, compute checksum only     */
    778              for (i=0U; i<nLength; i++)
   \   0000000A   0xB301             CBZ.N    R1,??MC_SendResponse_0
   \   0000000C   0xF011 0x0503      ANDS     R5,R1,#0x3
   \   00000010   0xF000 0x8007      BEQ.W    ??MC_SendResponse_1
    779              {
    780                  c = 0U;
    781                  pResponse = MC_ValueFromBuffer8(&c, pResponse);
   \                     ??MC_SendResponse_2: (+1)
   \   00000014   0xF810 0x6B01      LDRB     R6,[R0], #+1
    782                  /* add character to checksum */
    783                  chSum += c;
    784                  /* prevent saturation to happen on DSP platforms */
    785                  chSum &= 0xffU;
   \   00000018   0xFA53 0xF386      UXTAB    R3,R3,R6
   \   0000001C   0xB2DB             UXTB     R3,R3
   \   0000001E   0x1E6D             SUBS     R5,R5,#+1
   \   00000020   0xD1F8             BNE.N    ??MC_SendResponse_2
   \                     ??MC_SendResponse_1: (+1)
   \   00000022   0x088C             LSRS     R4,R1,#+2
   \   00000024   0xF000 0x8013      BEQ.W    ??MC_SendResponse_0
   \                     ??MC_SendResponse_3: (+1)
   \   00000028   0xF810 0x5B01      LDRB     R5,[R0], #+1
   \   0000002C   0xF810 0x6B01      LDRB     R6,[R0], #+1
   \   00000030   0xF810 0x7B01      LDRB     R7,[R0], #+1
   \   00000034   0xF810 0xCB01      LDRB     R12,[R0], #+1
   \   00000038   0xFA53 0xF385      UXTAB    R3,R3,R5
   \   0000003C   0xFA53 0xF386      UXTAB    R3,R3,R6
   \   00000040   0xFA53 0xF387      UXTAB    R3,R3,R7
   \   00000044   0xFA53 0xF38C      UXTAB    R3,R3,R12
   \   00000048   0xB2DB             UXTB     R3,R3
    786              }
   \   0000004A   0x1E64             SUBS     R4,R4,#+1
   \   0000004C   0xD1EC             BNE.N    ??MC_SendResponse_3
    787              
    788              /* store checksum after the message */
    789              pResponse = MC_ValueToBuffer8(pResponse, (MC_U8) (((MC_U8)(~chSum)) + 1U));
                                                                                ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \                     ??MC_SendResponse_0: (+1)
   \   0000004E   0x43DB             MVNS     R3,R3
   \   00000050   0x1C5B             ADDS     R3,R3,#+1
   \   00000052   0x7003             STRB     R3,[R0, #+0]
    790          
    791              /* send the message and the checksum and the SOB */
    792              pcm_nTxTodo = (MC_SIZE8) (nLength + 1U);
   \   00000054   0x1C48             ADDS     R0,R1,#+1
   \   00000056   0x7010             STRB     R0,[R2, #+0]
   \   00000058   0x2103             MOVS     R1,#+3
    793              
    794              /* now transmitting the response */
    795              pcm_wFlags.flg.bTxActive = 1U;
   \   0000005A   0x6C50             LDR      R0,[R2, #+68]
   \   0000005C   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000060   0x6450             STR      R0,[R2, #+68]
    796          
    797          #if (MC_USE_USB_CDC) || (MC_USE_MQX_IO) || (MC_USE_JTAG)
    798              pcm_wFlags.flg.bTxFirstSobSend = 1U;
    799          #endif
    800          
    801          #if MC_USE_SCI
    802              pcm_wFlags.flg.bTxWaitTC = 0U;
   \   00000062   0x6C50             LDR      R0,[R2, #+68]
   \   00000064   0xF020 0x0002      BIC      R0,R0,#0x2
   \   00000068   0x6450             STR      R0,[R2, #+68]
    803          #endif
    804          
    805              /* do not replicate the initial SOB  */
    806              pcm_wFlags.flg.bTxLastCharSOB = 0U;
   \   0000006A   0x6C50             LDR      R0,[R2, #+68]
   \   0000006C   0xF020 0x0004      BIC      R0,R0,#0x4
   \   00000070   0x6450             STR      R0,[R2, #+68]
    807              
    808          #if MC_USE_SCI
    809              {
    810                  /*lint -esym(550, dummySR) */        
    811                  volatile MC_SCISR dummySR;
    812          
    813                  /* disable receiver, enable transmitter (single-wire communication) */
    814          #if !MC_SCI_TWOWIRE_ONLY
    815                  MC_SCI_RD();
    816                  MC_SCI_TE();
    817          #endif        
    818                  /* kick on the SCI transmission (also clears TX Empty flag on some platforms) */
    819                  dummySR = MC_SCI_GETSR();
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x.... 0x....      BL       Uart__GetStatus
   \   00000078   0xF88D 0x0000      STRB     R0,[SP, #+0]
    820                  MC_SCI_PUTCHAR(MC_SOB);
   \   0000007C   0xB001             ADD      SP,SP,#+4
   \   0000007E   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   00000082   0x212B             MOVS     R1,#+43
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x.... 0x....      B.W      Uart__WriteByte
    821              }
    822              
    823          #elif MC_USE_JTAG
    824              /* kick on the JTAG transmission */
    825              MC_FlushJtagTx();
    826          #endif
    827          
    828              /* TX interrupt enable, RX interrupt disable */
    829          #if (MC_LONG_INTR) || (MC_SHORT_INTR)
    830          #if MC_USE_SCI
    831              MC_SCI_DRXI();
    832              MC_SCI_ETXI();
    833              
    834          #elif MC_USE_JTAG
    835          #if MC_USE_JTAG_TXFIX
    836              /* in TX-bugfix mode, keep the RX interrupt enabled as it */
    837              /* is used as "able-to-TX" notification from the PC */
    838              MC_JTAG_ERXI();
    839          #else
    840              /* otherwise, JTAG is very same as the SCI */
    841              if(pcm_wFlags.flg.bTxActive) //enable TX interrupt only when is not one word response 
    842              {
    843                  MC_JTAG_DRXI();
    844                  MC_JTAG_ETXI();
    845              }
    846          #endif              
    847          
    848          #elif MC_USE_USB_CDC
    849              if ((pcm_wFlags.flg.bUsbCdcStartApp) && (pcm_wFlags.flg.bTxActive) && (pcm_wFlags.flg.bUsbCdcStartTrans))
    850                  /* Finalize USB packet to transmit and send packet */
    851                  MC_SendUsbPacket();
    852              else
    853                  /* Previous Send is complete. Queue next receive */
    854                  (void)USB_Class_CDC_Interface_DIC_Recv_Data(MC_USB_CDC_ID, NULL, 0);
    855          #endif
    856          #endif /* MC_LONG_INTR || MC_SHORT_INTR */
    857          }
    858          
    859          /**************************************************************************//*!
    860          *
    861          * @brief    Output buffer transmission
    862          * 
    863          * @param  pTxChar  The character to be transmit 
    864          *
    865          * get ready buffer(prepare data to send)
    866          *
    867          ******************************************************************************/
    868          

   \                                 In section .text, align 2, keep-with-next
    869          MC_BOOL MC_Tx(MC_U8* pTxChar)
    870          {
    871          #if (MC_USE_USB_CDC) || (MC_USE_MQX_IO) || (MC_USE_JTAG)
    872              /* to send first SOB byte*/
    873              if (pcm_wFlags.flg.bTxFirstSobSend)
    874              {
    875                  *pTxChar = MC_SOB;
    876                  pcm_wFlags.flg.bTxFirstSobSend = 0U;
    877                  return MC_FALSE;
    878              }
    879          #endif      
    880              if (pcm_nTxTodo)
   \                     MC_Tx: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable4
   \   00000002   0x780A             LDRB     R2,[R1, #+0]
   \   00000004   0xB1AA             CBZ.N    R2,??MC_Tx_0
    881              {
    882                  /* fetch & send character ready to transmit */
    883                  /*lint -e{534} ignoring return value */
    884                  (void)MC_ValueFromBuffer8(pTxChar, pcm_pTxBuff);
   \   00000006   0x6C8B             LDR      R3,[R1, #+72]
   \   00000008   0xF893 0xC000      LDRB     R12,[R3, #+0]
   \   0000000C   0xF880 0xC000      STRB     R12,[R0, #+0]
    885                  
    886                  /* first, handle the replicated SOB characters */
    887                  if (*pTxChar == MC_SOB)
   \   00000010   0xF1BC 0x0F2B      CMP      R12,#+43
   \   00000014   0xD107             BNE.N    ??MC_Tx_1
    888                  {
    889                      pcm_wFlags.flg.bTxLastCharSOB ^= 1U;
   \   00000016   0x6C48             LDR      R0,[R1, #+68]
   \   00000018   0xF080 0x0004      EOR      R0,R0,#0x4
   \   0000001C   0x6448             STR      R0,[R1, #+68]
    890                      if ((pcm_wFlags.flg.bTxLastCharSOB))
   \   0000001E   0x6C48             LDR      R0,[R1, #+68]
   \   00000020   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   00000024   0xB918             CBNZ.N   R0,??MC_Tx_2
    891                      {
    892                          /* yes, repeat the SOB next time */
    893                          return MC_FALSE;
    894                      }
    895                  }
    896                  /* no, advance tx buffer pointer */
    897                  pcm_nTxTodo--;
   \                     ??MC_Tx_1: (+1)
   \   00000026   0x1E50             SUBS     R0,R2,#+1
   \   00000028   0x7008             STRB     R0,[R1, #+0]
    898                  pcm_pTxBuff = MC_SkipInBuffer(pcm_pTxBuff, 1U);
   \   0000002A   0x1C58             ADDS     R0,R3,#+1
   \   0000002C   0x6488             STR      R0,[R1, #+72]
    899                  return MC_FALSE;
   \                     ??MC_Tx_2: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x4770             BX       LR
    900              }
    901              
    902              /* when SCI TX buffering is enabled, we must first wait until all 
    903                 characters are physically transmitted (before disabling transmitter) */
    904          #if MC_USE_SCI
    905            #if MC_SCI_HAS_TXQUEUE
    906              pcm_wFlags.flg.bTxWaitTC = 1;
    907          
    908              /* wait for SCI TC interrupt */
    909              #if MC_SHORT_INTR || MC_LONG_INTR
    910              MC_SCI_ETCI();
    911              #endif
    912            #else
    913              /* start listening immediately */
    914              MC_Listen();
   \                     ??MC_Tx_0: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x7048             STRB     R0,[R1, #+1]
   \   00000036   0x6C48             LDR      R0,[R1, #+68]
   \   00000038   0x0840             LSRS     R0,R0,#+1
   \   0000003A   0x0040             LSLS     R0,R0,#+1
   \   0000003C   0x6448             STR      R0,[R1, #+68]
   \   0000003E   0x6C48             LDR      R0,[R1, #+68]
   \   00000040   0xF020 0x0002      BIC      R0,R0,#0x2
   \   00000044   0x6448             STR      R0,[R1, #+68]
    915            #endif  
    916          #else
    917              /* start listening immediately */
    918              MC_Listen();
    919          #endif
    920          
    921              return MC_TRUE;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x4770             BX       LR               ;; return
    922          }
    923          
    924          
    925          /**************************************************************************//*!
    926          *
    927          * @brief  Handle received character 
    928          *
    929          * @param  nRxChar  The character to be processed 
    930          * 
    931          * Handle the character received and -if the message is complete- call the 
    932          * protocol decode routine. 
    933          *
    934          ******************************************************************************/
    935          

   \                                 In section .text, align 2, keep-with-next
    936          MC_BOOL MC_Rx(MC_BCHR nRxChar)
    937          {
   \                     MC_Rx: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    938              MC_SERIAL_FLAGS * pflg = &pcm_wFlags;
    939              /* first, handle the replicated SOB characters */
    940              if(nRxChar == MC_SOB)
   \   00000002   0x....             LDR.N    R2,??DataTable4
   \   00000004   0x282B             CMP      R0,#+43
   \   00000006   0xD108             BNE.N    ??MC_Rx_0
    941              {
    942                  pflg->flg.bRxLastCharSOB ^= 1;
   \   00000008   0x6C51             LDR      R1,[R2, #+68]
   \   0000000A   0xF081 0x0108      EOR      R1,R1,#0x8
   \   0000000E   0x6451             STR      R1,[R2, #+68]
    943                  if(pflg->flg.bRxLastCharSOB)
   \   00000010   0x6C51             LDR      R1,[R2, #+68]
   \   00000012   0xF3C1 0x01C0      UBFX     R1,R1,#+3,#+1
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD152             BNE.N    ??MC_Rx_1
    944                  {
    945                      /* this is either the first byte of replicated SOB or a  */
    946                      /* real Start-of-Block mark - we will decide next time in MC_Rx */
    947                      return MC_FALSE;
    948                  }
    949              }
    950              
    951              /* we have got a common character preceded by the SOB -  */
    952              /* this is the command code! */
    953              if(pflg->flg.bRxLastCharSOB)
   \                     ??MC_Rx_0: (+1)
   \   0000001A   0x6C51             LDR      R1,[R2, #+68]
   \   0000001C   0xF3C1 0x01C0      UBFX     R1,R1,#+3,#+1
   \   00000020   0xB1D9             CBZ.N    R1,??MC_Rx_2
    954              {
    955                  /* reset receiving process */
    956                  pcm_pRxBuff = pcm_pCommBuffer;
    957                  *pcm_pRxBuff++ = nRxChar;
   \   00000022   0x1D51             ADDS     R1,R2,#+5
   \   00000024   0x7110             STRB     R0,[R2, #+4]
   \   00000026   0x64D1             STR      R1,[R2, #+76]
    958          
    959                  /* start computing the checksum */
    960                  pcm_nRxCheckSum = nRxChar;
   \   00000028   0x7090             STRB     R0,[R2, #+2]
    961                  pcm_nRxTodo = 0U;
   \   0000002A   0x2100             MOVS     R1,#+0
    962              
    963                  /* if the standard command was received, the message length will come in next byte */
    964                  pflg->flg.bRxMsgLengthNext = 1U;
   \   0000002C   0x6C53             LDR      R3,[R2, #+68]
   \   0000002E   0xF043 0x0310      ORR      R3,R3,#0x10
   \   00000032   0x6453             STR      R3,[R2, #+68]
    965          
    966                  /* fast command? */
    967                  if(!((~nRxChar) & MC_FASTCMD))
                               ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \   00000034   0x43C3             MVNS     R3,R0
   \   00000036   0xF013 0x03C0      ANDS     R3,R3,#0xC0
   \   0000003A   0xD107             BNE.N    ??MC_Rx_3
    968                  {
    969                      /* fast command received, there will be no length information */
    970                      pflg->flg.bRxMsgLengthNext = 0U;
   \   0000003C   0x6C51             LDR      R1,[R2, #+68]
   \   0000003E   0xF021 0x0110      BIC      R1,R1,#0x10
   \   00000042   0x6451             STR      R1,[R2, #+68]
    971                      /* as it is encoded in the command byte directly */
    972                      pcm_nRxTodo = (MC_SIZE8)
    973                          (((((MC_SIZE8)nRxChar) & MC_FASTCMD_DATALEN_MASK) >> MC_FASTCMD_DATALEN_SHIFT) + 1U);
   \   00000044   0x08C0             LSRS     R0,R0,#+3
   \   00000046   0xF000 0x0006      AND      R0,R0,#0x6
   \   0000004A   0x1C41             ADDS     R1,R0,#+1
   \                     ??MC_Rx_3: (+1)
   \   0000004C   0x7051             STRB     R1,[R2, #+1]
    974                  }
    975          
    976                  /* command code stored & processed */
    977                  pflg->flg.bRxLastCharSOB = 0U;
   \   0000004E   0x6C50             LDR      R0,[R2, #+68]
   \   00000050   0xF020 0x0008      BIC      R0,R0,#0x8
   \   00000054   0x6450             STR      R0,[R2, #+68]
    978                  return MC_FALSE;
    979              }
    980          
    981              /* we are waiting for the length byte */
    982              if(pflg->flg.bRxMsgLengthNext)
    983              {
    984                  /* this byte, total data length and the checksum */
    985                  pcm_nRxTodo = (MC_SIZE8) (1U + ((MC_SIZE8)nRxChar) + 1U);
    986                  /* now read the data bytes */
    987                  pflg->flg.bRxMsgLengthNext = 0U;
    988          
    989              }
    990          
    991              /* waiting for a data byte? */
    992              if(pcm_nRxTodo)
    993              {
    994                  /* add this byte to checksum */
    995                  pcm_nRxCheckSum += nRxChar;
    996          
    997                  /* decrease number of expected bytes */
    998                  pcm_nRxTodo--;
    999                  /* was it the last byte of the message (checksum)? */
   1000                  if(!pcm_nRxTodo)
   1001                  {
   1002                      /* receive buffer overflow? */
   1003                      if(pcm_pRxBuff == NULL)
   1004                      {
   1005                          MC_SendError(MC_STC_CMDTOOLONG);
   1006                      }
   1007                      /* checksum error? */
   1008                      else if((pcm_nRxCheckSum & 0xffU) != 0U)
   1009                      {
   1010                          MC_SendError(MC_STC_CMDCSERR);
   1011                      }
   1012                      /* message is okay */
   1013                      else 
   1014                      {
   1015          #if (MC_USE_USB_CDC) && (MC_SHORT_INTR)
   1016                          /* Decode protocol and send response in Poll function */
   1017                          pflg->flg.bUsbReadyToDecode = 1U;
   1018          #else
   1019                          
   1020                          /* do decode now! */
   1021                          MC_ProtocolDecoder(pcm_pCommBuffer);
   1022          #endif
   1023                      }
   1024          
   1025                      return MC_TRUE;
   1026                  }
   1027                  /* not the last character yet */
   1028                  else 
   1029                  {   
   1030                      /* is there still a space in the buffer? */
   1031                      if(pcm_pRxBuff)
   1032                      {
   1033                          /*lint -e{946} pointer arithmetic is okay here (same array) */
   1034                          if(pcm_pRxBuff < (pcm_pCommBuffer + MC_COMM_BUFFER_SIZE))
   1035                          {
   1036                              /* store byte  */
   1037                              *pcm_pRxBuff++ = nRxChar;
   1038                          }
   1039                          /* buffer is full! */
   1040                          else
   1041                          {
   1042                              /* NULL rx pointer means buffer overflow - but we still need */
   1043                              /* to receive all message characters (for the single-wire mode) */
   1044                              /* so keep "receiving" - but throw away all characters from now */
   1045                              pcm_pRxBuff = NULL;
   1046                          }
   1047                      }
   1048                  }
   1049              }
   1050              return MC_FALSE;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xBD10             POP      {R4,PC}
   \                     ??MC_Rx_2: (+1)
   \   0000005A   0x6C51             LDR      R1,[R2, #+68]
   \   0000005C   0xF3C1 0x1100      UBFX     R1,R1,#+4,#+1
   \   00000060   0xB129             CBZ.N    R1,??MC_Rx_4
   \   00000062   0x1C81             ADDS     R1,R0,#+2
   \   00000064   0x7051             STRB     R1,[R2, #+1]
   \   00000066   0x6C51             LDR      R1,[R2, #+68]
   \   00000068   0xF021 0x0110      BIC      R1,R1,#0x10
   \   0000006C   0x6451             STR      R1,[R2, #+68]
   \                     ??MC_Rx_4: (+1)
   \   0000006E   0x7851             LDRB     R1,[R2, #+1]
   \   00000070   0xB331             CBZ.N    R1,??MC_Rx_1
   \   00000072   0x1E49             SUBS     R1,R1,#+1
   \   00000074   0x7893             LDRB     R3,[R2, #+2]
   \   00000076   0x6CD4             LDR      R4,[R2, #+76]
   \   00000078   0x7051             STRB     R1,[R2, #+1]
   \   0000007A   0x18C3             ADDS     R3,R0,R3
   \   0000007C   0x7093             STRB     R3,[R2, #+2]
   \   0000007E   0xB2C9             UXTB     R1,R1
   \   00000080   0xB989             CBNZ.N   R1,??MC_Rx_5
   \   00000082   0xB90C             CBNZ.N   R4,??MC_Rx_6
   \   00000084   0x2083             MOVS     R0,#+131
   \   00000086   0xE002             B.N      ??MC_Rx_7
   \                     ??MC_Rx_6: (+1)
   \   00000088   0xB2DB             UXTB     R3,R3
   \   0000008A   0xB13B             CBZ.N    R3,??MC_Rx_8
   \   0000008C   0x2082             MOVS     R0,#+130
   \                     ??MC_Rx_7: (+1)
   \   0000008E   0x7110             STRB     R0,[R2, #+4]
   \   00000090   0x2101             MOVS     R1,#+1
   \   00000092   0x1D10             ADDS     R0,R2,#+4
   \   00000094   0x.... 0x....      BL       MC_SendResponse
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0xBD10             POP      {R4,PC}
   \                     ??MC_Rx_8: (+1)
   \   0000009C   0x1D10             ADDS     R0,R2,#+4
   \   0000009E   0x.... 0x....      BL       MC_ProtocolDecoder
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0xBD10             POP      {R4,PC}
   \                     ??MC_Rx_5: (+1)
   \   000000A6   0xB15C             CBZ.N    R4,??MC_Rx_1
   \   000000A8   0xF102 0x013E      ADD      R1,R2,#+62
   \   000000AC   0x428C             CMP      R4,R1
   \   000000AE   0xD205             BCS.N    ??MC_Rx_9
   \   000000B0   0x1C61             ADDS     R1,R4,#+1
   \   000000B2   0x64D1             STR      R1,[R2, #+76]
   \   000000B4   0xF801 0x0D01      STRB     R0,[R1, #-1]!
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xBD10             POP      {R4,PC}
   \                     ??MC_Rx_9: (+1)
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x64D0             STR      R0,[R2, #+76]
   \                     ??MC_Rx_1: (+1)
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xBD10             POP      {R4,PC}          ;; return
   1051          }
   1052          
   1053          /**************************************************************************//*!
   1054          *
   1055          * @brief    Serial communication initialization
   1056          *
   1057          ******************************************************************************/
   1058          

   \                                 In section .text, align 2, keep-with-next
   1059          MC_BOOL MC_InitSerial(void)
   1060          {   
   1061              /* initialize all state variables */
   1062              pcm_wFlags.all = 0U;
   \                     MC_InitSerial: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0xF880 0x1044      STRB     R1,[R0, #+68]
   1063              pcm_nTxTodo = 0U;
   \   00000008   0x7001             STRB     R1,[R0, #+0]
   1064          
   1065          /* Initialize SCI and JTAG interface */
   1066          #if (MC_USE_SCI) && (MC_SCI_TWOWIRE_ONLY)
   1067              /* to enable TX and RX together in mc initialization */
   1068              // RICUPL
   1069              //MC_SCI_TE_RE();
   1070          #endif
   1071              
   1072          #if (MC_SHORT_INTR) & ((MC_USE_SCI) || (MC_USE_JTAG))
   1073              pcm_pRQueueRP = pcm_pRQueueBuffer;
   1074              pcm_pRQueueWP = pcm_pRQueueBuffer;
   1075          #endif
   1076          
   1077          #if MC_USE_MQX_IO
   1078              if (!MC_InitMQX())
   1079                  return MC_FALSE;
   1080          #endif
   1081          
   1082          #if MC_USE_USB_CDC
   1083              if (!MC_InitUSB())
   1084                  return MC_FALSE;
   1085          #endif
   1086          
   1087              /* start listening for commands */
   1088              MC_Listen();
   \   0000000A   0x7041             STRB     R1,[R0, #+1]
   \   0000000C   0x6C41             LDR      R1,[R0, #+68]
   \   0000000E   0x0849             LSRS     R1,R1,#+1
   \   00000010   0x0049             LSLS     R1,R1,#+1
   \   00000012   0x6441             STR      R1,[R0, #+68]
   \   00000014   0x6C41             LDR      R1,[R0, #+68]
   \   00000016   0xF021 0x0102      BIC      R1,R1,#0x2
   \   0000001A   0x6441             STR      R1,[R0, #+68]
   1089              return MC_TRUE;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x4770             BX       LR               ;; return
   1090          }
   1091          
   1092          
   1093          /*******************************************************************************
   1094          *
   1095          * @brief    API: Main "Polling" call from the application main loop
   1096          *
   1097          * This function either handles all the SCI communication (polling-only mode = 
   1098          * MC_POLL_DRIVEN) or decodes messages received on the background by SCI interrupt
   1099          * (short-interrupt mode = MC_SHORT_INTR).
   1100          *
   1101          * In the JTAG interrupt-driven mode (both short and long), this function also checks
   1102          * if setting the JTAG RIE bit failed recently. This may happen because of the 
   1103          * RIE is held low by the EONCE hardware until the EONCE is first accessed from host.
   1104          * MC_Init (->MC_Listen) is often called while the PC-side mc is still
   1105          * turned off. So really, the JTAG is not enabled by this time and RIE bit is not set.
   1106          * This problem is detected (see how bJtagRIEPending is set above in FSMTR_Listen)
   1107          * and it is tried to be fixed periodically here in MC_Poll.
   1108          *
   1109          *******************************************************************************/
   1110          

   \                                 In section .text, align 2, keep-with-next
   1111          void MC_Poll(void)
   1112          { 
   1113          #if !MC_POLL_DRIVEN && MC_USE_JTAG
   1114              /* in the interrupt-driven JTAG mode, the JTAG RIE may have failed to be set recently */
   1115              if(pcm_wFlags.flg.bJtagRIEPending)
   1116              {
   1117                  MC_JTAG_ERXI();  /* try to enable JTAG receive interrupt now */
   1118          
   1119                  /* succeeded? */
   1120                  if(MC_JTAG_ERXI_CHECK())
   1121                      pcm_wFlags.flg.bJtagRIEPending = 0; /* yes!, enough until it fails again (never?) */
   1122              }
   1123          #endif    
   1124          
   1125          #if MC_USE_MQX_IO
   1126              /* polled MQX IO mode */
   1127              MC_ProcessMQXIO();
   1128          #endif
   1129          
   1130          #if MC_POLL_DRIVEN
   1131          
   1132          #if MC_USE_SCI
   1133              /* polled SCI mode */
   1134              MC_ProcessSCI();
   \                     MC_Poll: (+1)
   \   00000000   0x....             B.N      MC_ProcessSCI
   1135              
   1136          #elif MC_USE_JTAG
   1137              /* polled JTAG mode */
   1138              MC_ProcessJTAG();
   1139          #endif
   1140              
   1141          #elif MC_SHORT_INTR
   1142          
   1143          #if MC_USE_USB_CDC
   1144              /*  */
   1145              MC_ProcessUSB();
   1146          #elif (MC_USE_SCI || MC_USE_JTAG)
   1147          
   1148              /* process queued SCI characters */
   1149              MC_RxDequeue();
   1150          #endif
   1151          
   1152          #endif
   1153          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     pcm_nTxTodo
   1154          
   1155          #endif /* MC_USE_SERIAL */
   1156          
   1157          #endif /* !(MC_DISABLE) */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   MC_InitSerial
       0   MC_Poll
         0   -> MC_ProcessSCI
       8   MC_ProcessSCI
         8   -> MC_Rx
         8   -> Uart__GetStatus
         8   -> Uart__ReadByte
         0   -> Uart__WriteByte
       8   MC_Rx
         8   -> MC_ProtocolDecoder
         8   -> MC_SendResponse
      24   MC_SendResponse
        24   -> Uart__GetStatus
         0   -> Uart__WriteByte
       0   MC_Tx


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
      32  MC_InitSerial
       2  MC_Poll
     114  MC_ProcessSCI
     196  MC_Rx
     138  MC_SendResponse
      74  MC_Tx
      80  pcm_nTxTodo
          pcm_nRxTodo
          pcm_nRxCheckSum
          pcm_pCommBuffer
          pcm_wFlags
          pcm_pTxBuff
          pcm_pRxBuff

 
  80 bytes in section .bss
 560 bytes in section .text
 
 560 bytes of CODE memory
  80 bytes of DATA memory

Errors: none
Warnings: none
