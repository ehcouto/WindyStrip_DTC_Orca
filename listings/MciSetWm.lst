###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        13/Mar/2025  15:31:09
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  Category\Application\MciSetWm\MciSetWm.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        MciSetWm.obj -l ..\listings\MciSetWm.lst
#        Category\Application\MciSetWm\MciSetWm.c
#    List file    =  ..\listings\MciSetWm.lst
#    Object file  =  MciSetWm.obj
#
###############################################################################

C:\Data\Repository\WindyStrip_DTC_Orca\source\Category\Application\MciSetWm\MciSetWm.c
      1          /**
      2           *  @file       MciSetWms.c
      3           *
      4           *  @brief      Indesit Wm Mci Setting Algorithms module
      5           *
      6           *  $Header: $
      7           *
      8           *  @copyright  Copyright 2016-$Date$. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
      9           */
     10          //---------------------------------------------------------------------------------------------------------------------
     11          //---------------------------------------------------------------------------------------------------------------------
     12          
     13          
     14          //-------------------------------------- Include Files ----------------------------------------------------------------
     15          #include "MciSetWm.h"
     16          #include "MciSensorsWm.h"
     17          #include "Mci.h"
     18          #include "MathCalc.h"
     19          
     20          
     21          #if (MCI_SET_PARAMETERS_INTERNAL == ENABLED)
     22              #include "MciSetWm_prv.h"  //Mca parameters

   \                                 In section .data, align 4

  #endif  /* MCISETWM_PRV_ */
                             ^
"C:\Data\Repository\WindyStrip_DTC_Orca\source\ProjectSpecific\Mci\Mcl\MciSetWm_prv.h",87  Remark[Pe001]: 
          last line of file ends without a newline
     23          #else
     24          #if (PLATFORM_USED == NUCLEUS_BASED)
     25              #include "string.h"
     26              #include "SettingFile.h"
     27          #else
     28              #include "Params.h"
     29          #endif
     30          #endif
     31          //-------------------------------------- PUBLIC (Variables) -----------------------------------------------------------
     32          
     33          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
     34          #define SPEED_CONV_FACTOR       1.0f/(2.0f * 19800.0f)  // RPM<<16   to  IQ15 p.u.
     35          #define TORQUE_CONV_FACTOR      2.0f * 4.0f             // IQ15 p.u. to  Nm<<16
     36          
     37          static BOOL_TYPE ParamsReady;
   \                     ParamsReady:
   \   00000000   0x00               DC8 0
   \   00000001   0x00               DC8 0
   \   00000002   0x00               DC8 0
   \   00000003   0x00               DC8 0
   \   00000004   0x00 0x00          DC8 0, 0
   \   00000006   0x00 0x00          DC8 0, 0
   \   00000008   0x00 0x00          DC8 0, 0
   \   0000000A   0x00 0x00          DC8 0, 0
   \   0000000C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   __absolute unsigned short MciSetWm_Params_SF[70]
   \                     MciSetWm_Params_SF:
   \   00000010   0x0000 0x0000      DC16 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
   \   0000003C   0x0000 0x1B16      DC16 0, 6934, 11558, 19263, 23116, 26969, 0, 0, 0, 10059, 5958, 3576
   \              0x2D26 0x4B3F
   \              0x5A4C 0x6959
   \              0x0000 0x0000
   \              0x0000 0x274B
   \              0x1746 0x0DF8
   \   00000054   0x0BE4 0x0B00      DC16 3044, 2816, 0, 0, 0, 10059, 5958, 3576, 3044, 2816, 0, 0, 0, 0
   \              0x0000 0x0000
   \              0x0000 0x274B
   \              0x1746 0x0DF8
   \              0x0BE4 0x0B00
   \              0x0000 0x0000
   \              0x0000 0x0000
   \   00000070   0x8E76 0xD86F      DC16 36470, 55407, 61015, 63599, 0, 0, 0, 0, 36470, 55407, 61015, 63599
   \              0xEE57 0xF86F
   \              0x0000 0x0000
   \              0x0000 0x0000
   \              0x8E76 0xD86F
   \              0xEE57 0xF86F
   \   00000088   0x0000 0x0000      DC16 0, 0, 0, 311, 24920, 0, 0, 0, 0, 0
   \              0x0000 0x0137
   \              0x6158 0x0000
   \              0x0000 0x0000
   \              0x0000 0x0000
     38          static MCISETWM_PARAMS_TYPE *MciSetWm_Params;
     39          
     40          #if (CIM_SOFT_START == ENABLED)
                      ^
Remark[Pe193]: zero used for undefined preprocessing identifier
          "CIM_SOFT_START"
     41          static uint32 Soft_Start_Max_Cnt;
     42          static sint16 Previous_End_Speed;
     43          #endif
     44          
     45          #if (DYNAMIC_TORQUE_LIMITS == ENABLED)
     46          static uint16 Vdc_Period_Cnt;
     47          static sint16 Vdc_Min;
     48          static sint16 Vdc_Min_Tmp;
     49          static BOOL_TYPE LimitNorm_Request;
     50          static BOOL_TYPE VdcNorm_Flag;
     51          #endif
     52          
     53          #if (UPDATE_SPEED_REGULATOR == ENABLED)
     54          static sint32 Previous_Speed_Ref;
     55          #endif
     56          
     57          #if (MCI_SET_PARAMETERS_INTERNAL == ENABLED)
     58          
     59          #else
     60          
     61          
     62          #if (PLATFORM_USED == NUCLEUS_BASED)
     63              #define MCA_SET_WM_PARAMETERS_SIZE                  sizeof(MCISETWM_PARAMS_TYPE)
     64              SETTINGFILE_LOADER_TYPE Mca_Set_Wm_Prm_Flash_Ptr;
     65              uint8 Mca_Set_Wm_Prm_Ram[MCA_SET_WM_PARAMETERS_SIZE];
     66          #else
     67              PARAMS_LOADER_TYPE Mca_Set_Wm_Prm_Ram;
     68          #endif
     69          #endif
     70          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
     71          #ifdef MOTOR_CIM_TYPE
     72          
     73          #if (CIM_SOFT_START == ENABLED)
     74          static void UpdateSoftStartInit(void);
     75          static void UpdateSoftStartOnStart(void);
     76          static void UpdateSoftStartOnStop(void);
     77          static void SetMaxSoftStart(void);
     78          #endif
     79          
     80          #endif
     81          
     82          
     83          #if (UPDATE_SPEED_FIR_TAPS == ENABLED)
                      ^
Remark[Pe193]: zero used for undefined preprocessing identifier
          "UPDATE_SPEED_FIR_TAPS"
     84          static void UpdateSpeedFirTaps(void);
     85          #endif
     86          
     87          #if (UPDATE_SPEED_REGULATOR == ENABLED)
     88          static void UpdateSpeedRegulator(void);
     89          #endif
     90          
     91          #if (DYNAMIC_TORQUE_LIMITS == ENABLED)
     92          static void DynamicTorqueLimits(void);
     93          #endif
     94          //=====================================================================================================================
     95          //-------------------------------------- Public Functions -------------------------------------------------------------
     96          //=====================================================================================================================
     97          //---------------------------------------------------------------------------------------------------------------------
     98          
     99          //---------------------------------------------------------------------------------------------------------------------
    100          /**
    101           *  @brief      It Initializes the module MciSetWms and its variables.
    102           *
    103           */

   \                                 In section .text, align 2, keep-with-next
    104          void MciSetWm__Initialize(void)
    105          {
    106              ParamsReady = FALSE;
    107          
    108          #if (MCI_SET_PARAMETERS_INTERNAL == ENABLED)
    109              MciSetWm_Params = (MCISETWM_PARAMS_TYPE *) (&MciSetWm_Params_SF[0]);
   \                     MciSetWm__Initialize: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4_2
   \   00000002   0xF100 0x0110      ADD      R1,R0,#+16
   \   00000006   0x60C1             STR      R1,[R0, #+12]
    110              ParamsReady = TRUE;
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
    111          #else
    112              #if (PLATFORM_USED == NUCLEUS_BASED)
    113              if((SettingFile__IsValid() == TRUE) &&
    114                  (SettingFile__BasicLoader(SF_PTR_MCU_MCA, SF_DISPL_MOTOR_MCI_SET_WM, &Mca_Set_Wm_Prm_Flash_Ptr) == PASS))
    115              {
    116                  memcpy(&Mca_Set_Wm_Prm_Ram, Mca_Set_Wm_Prm_Flash_Ptr.Data, Mca_Set_Wm_Prm_Flash_Ptr.Length); //Copy from Flash to RAM
    117                  MciSetWm_Params = (MCISETWM_PARAMS_TYPE *) (&Mca_Set_Wm_Prm_Ram);
    118                  ParamsReady = TRUE;;
    119              }
    120              #else
    121              if(Params__BasicLoader(SF_PTR_MCU_MCA, SF_DISPL_MOTOR_MCI_SET_WM, &Mca_Set_Wm_Prm_Ram) == PASS)
    122              {
    123                  MciSetWm_Params = (MCISETWM_PARAMS_TYPE *) (Mca_Set_Wm_Prm_Ram.Data);
    124                  ParamsReady = TRUE;;
    125              }
    126              #endif
    127          #endif
    128          
    129          #if (DYNAMIC_TORQUE_LIMITS == ENABLED)
    130              Vdc_Min = 0x7FFF;
   \   0000000C   0xF647 0x71FF      MOVW     R1,#+32767
   \   00000010   0x80C1             STRH     R1,[R0, #+6]
    131              Vdc_Min_Tmp = 0x7FFF;
   \   00000012   0x8101             STRH     R1,[R0, #+8]
    132              Vdc_Period_Cnt = 0;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x8081             STRH     R1,[R0, #+4]
    133          #endif
    134          }
   \   00000018   0x4770             BX       LR               ;; return
    135          
    136          
    137          //---------------------------------------------------------------------------------------------------------------------
    138          /**
    139           *  @brief      Feeds back if Mci Set module parameters are loaded.
    140           *
    141           *  @param      none
    142           *  @return     TRUE: parameters are loaded / FALSE: parameters are not loaded
    143           */

   \                                 In section .text, align 2, keep-with-next
    144          BOOL_TYPE MciSetWm__IsParamsReady(void)
    145          {
    146              return(ParamsReady);
   \                     MciSetWm__IsParamsReady: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4_2
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    147          }
    148          
    149          
    150          
    151          //---------------------------------------------------------------------------------------------------------------------
    152          /**
    153           *  @brief      Handle Wm Set Mci events of 5ms.
    154           *
    155           *  @param
    156           *  @return
    157           */

   \                                 In section .text, align 2, keep-with-next
    158          void MciSetWm__5msHandler(void)
    159          {
    160          	if(ParamsReady == TRUE)
   \                     MciSetWm__5msHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4_2
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xBF08             IT       EQ 
    161          	{
    162          #if (UPDATE_SPEED_FIR_TAPS == ENABLED)
                      ^
Remark[Pe193]: zero used for undefined preprocessing identifier
          "UPDATE_SPEED_FIR_TAPS"
    163          		UpdateSpeedFirTaps();
    164          #endif
    165          
    166          #if (UPDATE_SPEED_REGULATOR == ENABLED)
    167          		UpdateSpeedRegulator();
    168          #endif
    169          
    170          #if (DYNAMIC_TORQUE_LIMITS == ENABLED)
    171          		DynamicTorqueLimits();
   \   00000008   0x.... 0x....      BEQ.W    DynamicTorqueLimits
    172          #endif
    173          	}
    174          
    175              else //parameters not loaded
    176              {
    177                  #if (MCI_SET_PARAMETERS_INTERNAL == ENABLED)
    178          
    179                  MciSetWm_Params = (MCISETWM_PARAMS_TYPE *) (&MciSetWm_Params_SF[0]);
   \   0000000C   0xF100 0x0110      ADD      R1,R0,#+16
   \   00000010   0x60C1             STR      R1,[R0, #+12]
    180                  ParamsReady = TRUE;
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x7001             STRB     R1,[R0, #+0]
    181          
    182                  #else
    183                  #if (PLATFORM_USED == NUCLEUS_BASED)
    184                  if((SettingFile__IsValid() == TRUE) &&
    185                      (SettingFile__BasicLoader(SF_PTR_MCU_MCA, SF_DISPL_MOTOR_MCI_SET_WM, &Mca_Set_Wm_Prm_Flash_Ptr) == PASS))
    186                  {
    187                      memcpy(&Mca_Set_Wm_Prm_Ram, Mca_Set_Wm_Prm_Flash_Ptr.Data, Mca_Set_Wm_Prm_Flash_Ptr.Length); //Copy from Flash to RAM
    188                      MciSetWm_Params = (MCISETWM_PARAMS_TYPE *) (&Mca_Set_Wm_Prm_Ram);
    189                      ParamsReady = TRUE;;
    190                  }
    191                  #else
    192                  if(Params__BasicLoader(SF_PTR_MCU_MCA, SF_DISPL_MOTOR_MCI_SET_WM, &Mca_Set_Wm_Prm_Ram) == PASS)
    193                  {
    194                     MciSetWm_Params = (MCISETWM_PARAMS_TYPE *) (Mca_Set_Wm_Prm_Ram.Data);
    195                     ParamsReady = TRUE;;
    196                  }
    197                  #endif
    198                  #endif
    199              }
    200          }
   \   00000016   0x4770             BX       LR               ;; return
    201          
    202          
    203          #if (UPDATE_SPEED_REGULATOR == ENABLED)
    204          /**
    205           *  @brief     Update PI speed gains according the target speed
    206           *  @details   input must be always positive; usually the absolute value of SpeedRef is used
    207           *
    208           *
    209           *  @param[in]  speed_ref = reference speed used to update the PI speed gains (must be positive)
    210           *  @param[out]
    211           *  @return
    212           */
    213          void UpdateSpeedRegulator(void)
    214          {
    215              sint32 speed_ref;
    216          
    217          	speed_ref = MATHCALC__ABS((Mci__GetAnalog(MOTOR0, MCI_AI_TARGET_SPEED_RPM_S16)>>16));
    218          
    219          	if(speed_ref != Previous_Speed_Ref)
    220          	{
    221          		if(speed_ref > MciSetWm_Params->High_Regulators_Thr_Speed)
    222          		{
    223          			// [ applying very high regulator ]
    224          			Mci__SetAnalog(MOTOR0, MCI_AO_SPEED_LOOP_GAIN_TABLE_INDEX, (sint32)&MciSetWm_Params->Prop_Gain_Speed_Very_High_Lo);
    225          		}
    226          		else if(speed_ref > MciSetWm_Params->Med_Regulators_Thr_Speed)
    227          		{
    228          			// [ applying high regulator ]
    229          			Mci__SetAnalog(MOTOR0, MCI_AO_SPEED_LOOP_GAIN_TABLE_INDEX, (sint32)&MciSetWm_Params->Prop_Gain_Speed_High_Lo);
    230          		}
    231          		else if(speed_ref > MciSetWm_Params->Low_Regulators_Thr_Speed)
    232          		{
    233          			// [ applying med regulator ]
    234          			Mci__SetAnalog(MOTOR0, MCI_AO_SPEED_LOOP_GAIN_TABLE_INDEX, (sint32)&MciSetWm_Params->Prop_Gain_Speed_Med_Lo);
    235          		}
    236          		else
    237          		{
    238          			// [ applying low regulator]
    239          			Mci__SetAnalog(MOTOR0, MCI_AO_SPEED_LOOP_GAIN_TABLE_INDEX, (sint32)&MciSetWm_Params->Prop_Gain_Speed_Low_Lo);
    240          		}
    241          	}
    242          
    243          	Previous_Speed_Ref = speed_ref;
    244          
    245          }
    246          #endif
    247          
    248          #if (DYNAMIC_TORQUE_LIMITS == ENABLED)
    249          //---------------------------------------------------------------------------------------------------------------------
    250          /**
    251           *  @brief      Request meaning
    252           *
    253           *  @param      mean_request = meaning request state
    254           *
    255           */

   \                                 In section .text, align 2, keep-with-next
    256          void MciSetWm__LimitNormRequest(BOOL_TYPE limitnorm_request)
    257          {
    258              LimitNorm_Request = limitnorm_request;
   \                     MciSetWm__LimitNormRequest: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable4_2
   \   00000002   0x7048             STRB     R0,[R1, #+1]
    259          }
   \   00000004   0x4770             BX       LR               ;; return
    260          
    261          #endif
    262          
    263          
    264          #ifdef MOTOR_CIM_TYPE
    265          
    266          #if (UPDATE_SPEED_FIR_TAPS == ENABLED)
    267          //---------------------------------------------------------------------------------------------------------------------
    268          /**
    269           *  @brief     Update Taps for FIR filter used in speed calculation
    270           *  @details   input must be always positive; usually the absolute value of SpeedRef is used
    271           *
    272           *
    273           *  @param[in]  speed_ref = reference speed used to update the desired Taps of the Speed FIR Filter (must be positive)
    274           *  @param[out]
    275           *  @return
    276           */
    277          void UpdateSpeedFirTaps(void)
    278          {
    279           	sint32 speed_set_point;
    280          
    281          	speed_set_point = MATHCALC__ABS((Mci__GetAnalog(MOTOR0, MCI_AI_SPEED_REFERENCE_RPM_S16)>>16));
    282          
    283          	if(speed_set_point > MciSetWm_Params->Med_Regulators_Thr_Speed)
    284          	{// [ applying high taps ]
    285          		Mci__SetAnalog(MOTOR0, MCI_AO_SPEED_FIR_TAPS_TABLE_INDEX, MciSetWm_Params->Speed_Taps_High);
    286          
    287          	}
    288          	else if(speed_set_point> MciSetWm_Params->Low_Regulators_Thr_Speed)
    289          	{// [ applying med taps ]
    290          		Mci__SetAnalog(MOTOR0, MCI_AO_SPEED_FIR_TAPS_TABLE_INDEX, MciSetWm_Params->Speed_Taps_Med);
    291          
    292          	}
    293          	else if(speed_set_point > STARTUP_THR_SPEED_PERC)
    294          	{// [ applying low taps]
    295          		Mci__SetAnalog(MOTOR0, MCI_AO_SPEED_FIR_TAPS_TABLE_INDEX, MciSetWm_Params->Speed_Taps_Low);
    296          
    297          	}
    298          	else
    299          	{
    300          		Mci__SetAnalog(MOTOR0, MCI_AO_SPEED_FIR_TAPS_TABLE_INDEX, SPEED_TAPS_STARTUP);
    301          	}
    302          
    303          }
    304          
    305          
    306          #endif
    307          
    308          
    309          
    310          #if (CIM_SOFT_START == ENABLED)
    311          //---------------------------------------------------------------------------------------------------------------------
    312          /**
    313           *  @brief     Soft Start Update
    314           *  @details
    315           *
    316           *
    317           *  @param[in]
    318           *  @param[out]
    319           *  @return
    320           */
    321          uint8 MciSetWm__SoftStart(SOFT_START_STATE_ENUM_T soft_start_state)
    322          {
    323              uint8 ret_val = FALSE;
    324          
    325              if(ParamsReady == TRUE)
    326              {
    327          	   switch(soft_start_state)
    328          	   {
    329          
    330          			case SOFT_START_INITIALIZATION:		// Init the softstart counter
    331          				UpdateSoftStartInit();
    332          				ret_val = TRUE;
    333          				break;
    334          
    335          			case SOFT_START_ON_START:			// Update the softstart counter at the motor starting based on the previous speed
    336          				UpdateSoftStartOnStart();
    337          				ret_val = TRUE;
    338          				break;
    339          
    340          			case SOFT_START_ON_STOP:			// Update the softstart counter at the motor stopping based on the previous torque
    341          				UpdateSoftStartOnStop();
    342          				ret_val = TRUE;
    343          				break;
    344          
    345          			case SOFT_START_MAX_REQUEST:		// max soft start request for 20 starts
    346          				SetMaxSoftStart();
    347          				ret_val = TRUE;
    348          				break;
    349          
    350          
    351          			default:
    352          				//
    353          				break;
    354          		}
    355              }
    356          
    357              return(ret_val);
    358          }
    359          
    360          
    361          //---------------------------------------------------------------------------------------------------------------------
    362          /**
    363           *  @brief     Soft Start Update
    364           *  @details   Init the softstart counter
    365           *
    366           *
    367           *  @param[in]  )
    368           *  @param[out]
    369           *  @return
    370           */
    371          static void UpdateSoftStartInit(void)
    372          {
    373          	Previous_End_Speed = 0;
    374          
    375          	if(Soft_Start_Max_Cnt == 0)
    376          	{
    377          		Mci__SetAnalog(MOTOR0, MCI_AO_SOFTSTART_COUNTER_INDEX, SOFT_START_APP_MED_COUNTER);
    378          	}
    379          	else
    380          	{
    381          		Mci__SetAnalog(MOTOR0, MCI_AO_SOFTSTART_COUNTER_INDEX, SOFT_START_APP_MAX_COUNTER);
    382          	}
    383          }
    384          
    385          
    386          
    387          
    388          //---------------------------------------------------------------------------------------------------------------------
    389          /**
    390           *  @brief     Soft Start Update
    391           *  @details   Update the softstart counter at the motor starting based on the previous speed
    392           *
    393           *
    394           *  @param[in]
    395           *  @param[out]
    396           *  @return
    397           */
    398          static void UpdateSoftStartOnStart(void)
    399          {
    400              uint16 soft_start_cnt;
    401              sint32 speed_set_point_abs;
    402              sint32 delta_speed_abs;
    403              sint32 ramp_end_speed_abs;
    404          
    405              speed_set_point_abs = MATHCALC__ABS((Mci__GetAnalog(MOTOR0, MCI_AI_SPEED_REFERENCE_RPM_S16)>>16));
    406          
    407          	ramp_end_speed_abs = Mci__GetAnalog(MOTOR0, MCI_AI_TARGET_SPEED_RPM_S16)>>16;
    408          	ramp_end_speed_abs = MATHCALC__ABS(ramp_end_speed_abs);
    409          
    410              if(speed_set_point_abs == 0)
    411              {
    412              	delta_speed_abs = ramp_end_speed_abs - Previous_End_Speed;
    413                  delta_speed_abs = MATHCALC__ABS(delta_speed_abs);
    414          
    415                  if((delta_speed_abs > SOFT_START_SPEED_TOLLERANCE)&&(Previous_End_Speed != 0))
    416                  {// [ delta previous speed > tollerance --> re-initialize the SoftStart_Counter
    417          
    418                      soft_start_cnt = SOFT_START_APP_MAX_COUNTER;
    419          
    420                      Mci__SetAnalog(MOTOR0, MCI_AO_SOFTSTART_COUNTER_INDEX, soft_start_cnt);
    421                  }
    422              }
    423          
    424              Previous_End_Speed = ramp_end_speed_abs;
    425          }
    426          
    427          
    428          
    429          //---------------------------------------------------------------------------------------------------------------------
    430          /**
    431           *  @brief     Soft Start Update
    432           *  @details   Update the softstart counter at the motor stopping based on the previous torque
    433           *
    434           *
    435           *  @param[in]
    436           *  @param[out]
    437           *  @return
    438           */
    439          static void UpdateSoftStartOnStop(void)
    440          {
    441              uint16 soft_start_cnt;
    442              sint16 me_mean;
    443              sint32 temp32;
    444              sint32 ramp_end_speed_abs;
    445          
    446              if ((ParamsReady == TRUE)&&(Mci__GetAnalog(MOTOR0, MCI_AI_INTERNAL_MCI_STATE)>2))
    447              {
    448          		me_mean = MciSensorsWm__GetIndesitAnalog(MCISENSORSWM_AI_TORQUE_MEAN);
    449          		me_mean = MATHCALC__ABS(me_mean);
    450          
    451          		/****** SoftStart Counter Calculation - begin ************/
    452          		if (me_mean)
    453          		{
    454          
    455          			temp32 = (sint32)(((MciSetWm_Params->Soft_Start_Rel)<<IQ15)/(MciSetWm_Params->Torque_Ref_Max_Startup));
    456          
    457          
    458          			soft_start_cnt = (uint16) IQMATH__Q15MULQ15(me_mean,(sint16)temp32);
    459          
    460          
    461          			if (soft_start_cnt > SOFT_START_APP_MAX_COUNTER)
    462          			{
    463          				soft_start_cnt = SOFT_START_APP_MAX_COUNTER;
    464          			}
    465          			else if (soft_start_cnt < SOFT_START_APP_MIN_COUNTER)
    466          			{
    467          				soft_start_cnt = SOFT_START_APP_MIN_COUNTER;
    468          			}
    469          
    470          		}
    471          		else
    472          		{
    473          			if(Mci__GetDigital(MOTOR0, MCI_DI_IDLE) == TRUE)
    474          			{
    475          				soft_start_cnt = SOFT_START_APP_MED_COUNTER;
    476          			}
    477          			else
    478          			{
    479          				soft_start_cnt = SOFT_START_APP_MAX_COUNTER;
    480          			}
    481          		}
    482          		/****** SoftStart Counter Calculation - end ************/
    483          
    484          		ramp_end_speed_abs = Mci__GetAnalog(MOTOR0, MCI_AI_TARGET_SPEED_RPM_S16)>>16;
    485          		ramp_end_speed_abs = MATHCALC__ABS(ramp_end_speed_abs);
    486          
    487          		if((Soft_Start_Max_Cnt != 0)||(ramp_end_speed_abs > MciSetWm_Params->Low_Regulators_Thr_Speed))
    488          		{
    489          			if(Soft_Start_Max_Cnt != 0) //decrease the counter
    490          			{
    491          				Soft_Start_Max_Cnt--;
    492          			}
    493          
    494          			soft_start_cnt = SOFT_START_APP_MAX_COUNTER;
    495          		}
    496          
    497          		Mci__SetAnalog(MOTOR0, MCI_AO_SOFTSTART_COUNTER_INDEX, soft_start_cnt);
    498              }
    499          }
    500          
    501          
    502          //---------------------------------------------------------------------------------------------------------------------
    503          /**
    504           *  @brief     Request a Max Soft Start Counter for 20 starts
    505           *  @details
    506           *
    507           *
    508           *  @param[in]
    509           *  @param[out]
    510           *  @return
    511           */
    512          static void SetMaxSoftStart(void)
    513          {
    514          	Soft_Start_Max_Cnt = SOFT_START_MAX_CNT_PERIOD;
    515          }
    516          
    517          #endif
    518          
    519          #endif
    520          
    521          #if (DYNAMIC_TORQUE_LIMITS == ENABLED)
    522          //---------------------------------------------------------------------------------------------------------------------
    523          /**
    524           *  @brief     Dynamic torque limits
    525           *  @details   Calculation of the torque spinning limits.
    526           *  @param[in]
    527           *  @param[out]
    528           *  @return
    529           */

   \                                 In section .text, align 4, keep-with-next
    530          static void DynamicTorqueLimits(void)
    531          {
   \                     DynamicTorqueLimits: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    532              sint32  torque_limit; //Q17.15
    533              sint16  speed;
    534              uint16  i;
    535              sint16*  torque_limit_table;
    536              sint16*  m_limit_table;
    537              sint16   vdc;
    538          
    539              vdc = Mci__GetAnalog(MOTOR0, MCI_AI_BUS_VOLTAGE_S16)>>16;
   \   00000002   0x210D             MOVS     R1,#+13
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       Mci__GetAnalog
    540          
    541              Vdc_Period_Cnt++;
   \   0000000A   0x....             LDR.N    R4,??DataTable4_2
   \   0000000C   0x88A1             LDRH     R1,[R4, #+4]
    542              if(Vdc_Period_Cnt > VDC_PERIOD_MIN)
   \   0000000E   0xF9B4 0x2008      LDRSH    R2,[R4, #+8]
   \   00000012   0x1C49             ADDS     R1,R1,#+1
   \   00000014   0x1400             ASRS     R0,R0,#+16
   \   00000016   0xB289             UXTH     R1,R1
   \   00000018   0xF5B1 0x7FFA      CMP      R1,#+500
   \   0000001C   0xDD04             BLE.N    ??DynamicTorqueLimits_0
    543              {
    544                  Vdc_Period_Cnt = 0;
   \   0000001E   0x2100             MOVS     R1,#+0
    545          
    546                  Vdc_Min = Vdc_Min_Tmp;
   \   00000020   0x80E2             STRH     R2,[R4, #+6]
    547          
    548                  Vdc_Min_Tmp = 0x7FFF;
   \   00000022   0xF647 0x70FF      MOVW     R0,#+32767
   \   00000026   0xE002             B.N      ??DynamicTorqueLimits_1
    549              }
    550              else
    551              {
    552                  if(Vdc_Min_Tmp > vdc)
   \                     ??DynamicTorqueLimits_0: (+1)
   \   00000028   0x4290             CMP      R0,R2
   \   0000002A   0xBFC8             IT       GT 
   \   0000002C   0x4610             MOVGT    R0,R2
   \                     ??DynamicTorqueLimits_1: (+1)
   \   0000002E   0x8120             STRH     R0,[R4, #+8]
   \   00000030   0x80A1             STRH     R1,[R4, #+4]
    553                  {
    554                      Vdc_Min_Tmp = vdc;
    555                  }
    556              }
    557          
    558              if(Mci__GetDigital(MOTOR0, MCI_DI_MOTOR_STOP) == TRUE)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x.... 0x....      BL       Mci__GetDigital
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xD108             BNE.N    ??DynamicTorqueLimits_2
    559          	{
    560          		// update VdcNorm (management for torque limits for normative cycles)
    561          		if (Vdc_Min >= MciSetWm_Params->Vdc_Norm)
   \   0000003E   0x68E1             LDR      R1,[R4, #+12]
   \   00000040   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   00000044   0xF9B1 0x107E      LDRSH    R1,[R1, #+126]
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xDB0D             BLT.N    ??DynamicTorqueLimits_3
    562          		{ // Torque Limits for Normative Cycles can be applied
    563          			VdcNorm_Flag = TRUE;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x70A0             STRB     R0,[R4, #+2]
    564          		}
    565          		else
    566          		{ // Always apply standard torque limits
    567          			VdcNorm_Flag = FALSE;
    568          		}
    569          	}
    570          
    571              if ((LimitNorm_Request) && (VdcNorm_Flag))
   \                     ??DynamicTorqueLimits_2: (+1)
   \   00000050   0x7860             LDRB     R0,[R4, #+1]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xBF1C             ITT      NE 
   \   00000056   0x78A0             LDRBNE   R0,[R4, #+2]
   \   00000058   0x2800             CMPNE    R0,#+0
   \   0000005A   0xD007             BEQ.N    ??DynamicTorqueLimits_4
    572              {//
    573                  torque_limit_table = &MciSetWm_Params->TorqueLimit_Norm[0];
   \   0000005C   0x68E0             LDR      R0,[R4, #+12]
   \   0000005E   0xF100 0x054E      ADD      R5,R0,#+78
    574                  m_limit_table = &MciSetWm_Params->MLimit_Norm[0];
   \   00000062   0xF100 0x066E      ADD      R6,R0,#+110
   \   00000066   0xE006             B.N      ??DynamicTorqueLimits_5
    575              }
   \                     ??DynamicTorqueLimits_3: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x70A0             STRB     R0,[R4, #+2]
    576              else
    577              {//
    578                  torque_limit_table = &MciSetWm_Params->TorqueLimit[0];
   \                     ??DynamicTorqueLimits_4: (+1)
   \   0000006C   0x68E0             LDR      R0,[R4, #+12]
   \   0000006E   0xF100 0x053E      ADD      R5,R0,#+62
    579                  m_limit_table = &MciSetWm_Params->MLimit[0];
   \   00000072   0xF100 0x065E      ADD      R6,R0,#+94
    580              }
    581          
    582              if(Mci__GetDigital(MOTOR0, MCI_DI_MOTOR_RUNNING) == TRUE)
   \                     ??DynamicTorqueLimits_5: (+1)
   \   00000076   0x2104             MOVS     R1,#+4
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x.... 0x....      BL       Mci__GetDigital
   \   0000007E   0x2801             CMP      R0,#+1
   \   00000080   0xD164             BNE.N    ??DynamicTorqueLimits_6
    583              {
    584                  //---------------------------------------------------------------------------------------------------------------------
    585                  //                   Dynamic Torque Limits
    586                  //       assign torque limit according to Speed ranges
    587                  //     [ sSetFileParams.f16Speed_Limit[TORQUE_LIM_LENGHT] ]
    588                  //     [ sSetFileParams.f16Torque_Limit[TORQUE_LIM_LENGHT] ]
    589                  //                [ #define TORQUE_LIM_LENGHT 8 ]
    590                  //---------------------------------------------------------------------------------------------------------------------
    591              	speed = (sint16) ((float32)(Mci__GetAnalog(MOTOR0, MCI_AI_ACTUAL_SPEED_S16)) * SPEED_CONV_FACTOR);
   \   00000082   0x2102             MOVS     R1,#+2
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x.... 0x....      BL       Mci__GetAnalog
   \   0000008A   0xEE00 0x0A10      VMOV     S0,R0
    592          
    593                  for (i = 0; i < TORQUE_LIM_LENGHT; i++)
   \   0000008E   0x68E2             LDR      R2,[R4, #+12]
   \   00000090   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000094   0xEDDF 0x....      VLDR.W   S1,??DataTable4  ;; 0x471ab000
   \   00000098   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   0000009C   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
    594                  {
    595                      if (MciSetWm_Params->SpeedLimit[i]!=0)
   \   000000A0   0xF9B2 0x302E      LDRSH    R3,[R2, #+46]
   \   000000A4   0xEE10 0x0A10      VMOV     R0,S0
   \   000000A8   0xB200             SXTH     R0,R0
   \   000000AA   0x2B00             CMP      R3,#+0
   \   000000AC   0xD04F             BEQ.N    ??DynamicTorqueLimits_7
    596                      {
    597                          if(speed < MciSetWm_Params->SpeedLimit[i])
   \   000000AE   0x4298             CMP      R0,R3
   \   000000B0   0xDB4D             BLT.N    ??DynamicTorqueLimits_7
   \   000000B2   0xF9B2 0x3030      LDRSH    R3,[R2, #+48]
   \   000000B6   0x2101             MOVS     R1,#+1
   \   000000B8   0xB333             CBZ.N    R3,??DynamicTorqueLimits_8
   \   000000BA   0x4298             CMP      R0,R3
   \   000000BC   0xDB24             BLT.N    ??DynamicTorqueLimits_8
   \   000000BE   0xF9B2 0x3032      LDRSH    R3,[R2, #+50]
   \   000000C2   0x2102             MOVS     R1,#+2
   \   000000C4   0xB303             CBZ.N    R3,??DynamicTorqueLimits_8
   \   000000C6   0x4298             CMP      R0,R3
   \   000000C8   0xDB1E             BLT.N    ??DynamicTorqueLimits_8
   \   000000CA   0xF9B2 0x3034      LDRSH    R3,[R2, #+52]
   \   000000CE   0x2103             MOVS     R1,#+3
   \   000000D0   0xB1D3             CBZ.N    R3,??DynamicTorqueLimits_8
   \   000000D2   0x4298             CMP      R0,R3
   \   000000D4   0xDB18             BLT.N    ??DynamicTorqueLimits_8
   \   000000D6   0xF9B2 0x3036      LDRSH    R3,[R2, #+54]
   \   000000DA   0x2104             MOVS     R1,#+4
   \   000000DC   0xB1A3             CBZ.N    R3,??DynamicTorqueLimits_8
   \   000000DE   0x4298             CMP      R0,R3
   \   000000E0   0xDB12             BLT.N    ??DynamicTorqueLimits_8
   \   000000E2   0xF9B2 0x3038      LDRSH    R3,[R2, #+56]
   \   000000E6   0x2105             MOVS     R1,#+5
   \   000000E8   0xB173             CBZ.N    R3,??DynamicTorqueLimits_8
   \   000000EA   0x4298             CMP      R0,R3
   \   000000EC   0xDB0C             BLT.N    ??DynamicTorqueLimits_8
   \   000000EE   0xF9B2 0x303A      LDRSH    R3,[R2, #+58]
   \   000000F2   0x2106             MOVS     R1,#+6
   \   000000F4   0xB143             CBZ.N    R3,??DynamicTorqueLimits_8
   \   000000F6   0x4298             CMP      R0,R3
   \   000000F8   0xDB06             BLT.N    ??DynamicTorqueLimits_8
   \   000000FA   0xF9B2 0x303C      LDRSH    R3,[R2, #+60]
   \   000000FE   0x2107             MOVS     R1,#+7
   \   00000100   0xB113             CBZ.N    R3,??DynamicTorqueLimits_8
   \   00000102   0x4298             CMP      R0,R3
   \   00000104   0xBFA8             IT       GE 
    598                          {
    599                              break;
    600                          }
    601                      }
    602                      else
    603                      {
    604                          break;
    605                      }
    606                  }
   \   00000106   0x2108             MOVGE    R1,#+8
    607          
    608          
    609                  if (i==0)
    610                  {
    611                      torque_limit=0;
    612                  }
    613                  else
    614                  {
    615                      // to avoid no limits on overspeed
    616                      if (MciSetWm_Params->SpeedLimit[i]==0)
   \                     ??DynamicTorqueLimits_8: (+1)
   \   00000108   0xEB02 0x0341      ADD      R3,R2,R1, LSL #+1
   \   0000010C   0xF9B3 0x302E      LDRSH    R3,[R3, #+46]
   \   00000110   0xB90B             CBNZ.N   R3,??DynamicTorqueLimits_9
    617                      {
    618                          i--;
   \   00000112   0x1E49             SUBS     R1,R1,#+1
   \   00000114   0xB289             UXTH     R1,R1
    619                      }
    620          
    621                      //Linear Limits
    622                      torque_limit = torque_limit_table[i] + IQMATH__Q15MULQ15(m_limit_table[i],(speed-MciSetWm_Params->SpeedLimit[i]));
   \                     ??DynamicTorqueLimits_9: (+1)
   \   00000116   0xF935 0x3011      LDRSH    R3,[R5, R1, LSL #+1]
   \   0000011A   0xF936 0x4011      LDRSH    R4,[R6, R1, LSL #+1]
   \   0000011E   0xEB02 0x0141      ADD      R1,R2,R1, LSL #+1
   \   00000122   0xF9B1 0x102E      LDRSH    R1,[R1, #+46]
   \   00000126   0x1A40             SUBS     R0,R0,R1
   \   00000128   0x4360             MULS     R0,R0,R4
   \   0000012A   0x13C0             ASRS     R0,R0,#+15
   \   0000012C   0xFA03 0xF080      SXTAH    R0,R3,R0
   \   00000130   0xEE00 0x0A10      VMOV     S0,R0
    623          
    624                  }
    625          
    626                  // translate the limit from Indesit to DTC torque base system
    627                  torque_limit = (sint32)((float)torque_limit * TORQUE_CONV_FACTOR);  // torque Nm <<16
    628          
    629                  Mci__SetAnalog(MOTOR0, MCI_AO_SPEED_LIMIT_INDEX, torque_limit);
   \                     ??DynamicTorqueLimits_10: (+1)
   \   00000134   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000138   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000013C   0xEEBE 0x0AEE      VCVT.S32.F32 S0,S0,#+3
   \   00000140   0xEE10 0x2A10      VMOV     R2,S0
   \   00000144   0x2105             MOVS     R1,#+5
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0x.... 0x....      B.W      Mci__SetAnalog
    630          
    631              }
    632          
    633          }
   \                     ??DynamicTorqueLimits_6: (+1)
   \   0000014C   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??DynamicTorqueLimits_7: (+1)
   \   0000014E   0xED9F 0x....      VLDR.W   S0,??DataTable4_1  ;; 0x0
   \   00000152   0xE7EF             B.N      ??DynamicTorqueLimits_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x471AB000         DC32     0x471ab000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     ParamsReady
    634          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   DynamicTorqueLimits
        16   -> Mci__GetAnalog
        16   -> Mci__GetDigital
         0   -> Mci__SetAnalog
       0   MciSetWm__5msHandler
         0   -> DynamicTorqueLimits
       0   MciSetWm__Initialize
       0   MciSetWm__IsParamsReady
       0   MciSetWm__LimitNormRequest


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
     340  DynamicTorqueLimits
      24  MciSetWm__5msHandler
      26  MciSetWm__Initialize
       6  MciSetWm__IsParamsReady
       6  MciSetWm__LimitNormRequest
     156  ParamsReady
          LimitNorm_Request
          VdcNorm_Flag
          Vdc_Period_Cnt
          Vdc_Min
          Vdc_Min_Tmp
          MciSetWm_Params
          MciSetWm_Params_SF

 
 156 bytes in section .data
 414 bytes in section .text
 
 414 bytes of CODE memory
 156 bytes of DATA memory

Errors: none
Warnings: none
