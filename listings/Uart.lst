###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        19/Nov/2024  13:15:52
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  XCategory\Driver\Uart\Uart.c
#    Command line =  
#        -I./ -I../cx/ -I../cx/inc/ -ICategory/ -ICategory/Application/
#        -ICategory/Application/ApplicationWasherMcu/
#        -ICategory/Application/ApplicationWasherMcu/AnalysisAverage/
#        -ICategory/Application/ApplicationWasherMcu/Arbitration/
#        -ICategory/Application/ApplicationWasherMcu/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Motion/
#        -ICategory/Application/ApplicationWasherMcu/Motion/MotionError/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Pulse/
#        -ICategory/Application/ApplicationWasherMcu/Motion/RotateXDeg/
#        -ICategory/Application/ApplicationWasherMcu/Motion/SpinDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/StopDrum/
#        -ICategory/Application/ApplicationWasherMcu/Motion/Wash/
#        -ICategory/Application/ApplicationWasherMcu/MotorActivity/
#        -ICategory/Application/ApplicationWasherMcu/SpeedMaintain/
#        -ICategory/Application/BandLimiter/ -ICategory/Application/Beagle/
#        -ICategory/Application/CommandManager/
#        -ICategory/Application/DigitalFilter/
#        -ICategory/Application/Extraction/
#        -ICategory/Application/Extraction/CodeGeneration/
#        -ICategory/Application/Extraction/CodeGeneration/SharedUtils/
#        -ICategory/Application/Extraction/Dependencies/
#        -ICategory/Application/FaultManager/
#        -ICategory/Application/MciSensorsWm/ -ICategory/Application/MciSetWm/
#        -ICategory/Application/MciSetWmFloat/ -ICategory/Application/ParamEst/
#        -ICategory/Application/ParamEstExc/ -ICategory/Application/Params/
#        -ICategory/Application/ProtocolInfo/
#        -ICategory/Application/ProtocolMainExternal/
#        -ICategory/Application/SRMotorSafetyInfoParamsMgr_Core/
#        -ICategory/Application/ThermalModel/
#        -ICategory/Application/ThermalModel/ThermalModelCore/
#        -ICategory/Common/ -ICategory/Common/BoardDebugging/
#        -ICategory/Common/MasterCommander/
#        -ICategory/Common/MasterCommander/Source/
#        -ICategory/Common/MasterCommander/Source/HAL/ -ICategory/Hbl/
#        -IProjectSpecific/ -IProjectSpecific/Application/
#        -IProjectSpecific/Application/API007App/
#        -IProjectSpecific/Application/Api221_Filter_Mci_Err/
#        -IProjectSpecific/Application/ModeManagement/
#        -IProjectSpecific/Application/ProductInfo/
#        -IProjectSpecific/Application/RemoteFunctions/
#        -IProjectSpecific/Application/SRMcuSpeedMonitor/
#        -IProjectSpecific/Application/ThermalModel/
#        -IProjectSpecific/CommonCore/ -IProjectSpecific/Driver/
#        -IProjectSpecific/Indesit/ -IProjectSpecific/MasterCommander/
#        -IProjectSpecific/Mci/ -IProjectSpecific/Mci/Mcl/
#        -IProjectSpecific/Mci/Mcl/old_xls/ -IXCategory/
#        -IXCategory/Application/ -IXCategory/Application/MciParametersLoader/
#        -IXCategory/Application/Mode/ -IXCategory/Application/Reveal_APIs/
#        -IXCategory/Application/Reveal_APIs/API003Disc/
#        -IXCategory/Application/Reveal_APIs/API005LowLevel/
#        -IXCategory/Application/Reveal_APIs/API007Data/
#        -IXCategory/Application/Reveal_APIs/API009System/
#        -IXCategory/Application/Reveal_APIs/API010PollVar/
#        -IXCategory/Application/Reveal_APIs/API011AppCtr/
#        -IXCategory/Application/Reveal_APIs/API013RemoteFunction/
#        -IXCategory/Application/Reveal_APIs/API018Diagnostic/
#        -IXCategory/Application/Reveal_APIs/API019ProductInfo/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/
#        -IXCategory/Application/Reveal_APIs/API220MotorControl/API/
#        -IXCategory/Application/Reveal_APIs/API221MotionCtrl/
#        -IXCategory/Application/Reveal_APIs/SRAPI020Safety/
#        -IXCategory/Application/SFUpdater/ -IXCategory/Common/
#        -IXCategory/Common/Crc16/ -IXCategory/Common/Crc8/
#        -IXCategory/Common/Log/ -IXCategory/Common/SettingFile/
#        -IXCategory/Common/SRClockMonitor/ -IXCategory/Common/SRData/
#        -IXCategory/Common/SRException/ -IXCategory/Common/SRFlow/
#        -IXCategory/Common/SRIsrMonitor/ -IXCategory/Common/SRMain/
#        -IXCategory/Common/SRMcuSpeedMonitor/ -IXCategory/Common/SRPowerMgr/
#        -IXCategory/Common/SRSignature/ -IXCategory/Common/SRSystemConfig/
#        -IXCategory/Common/SRTimerReference/ -IXCategory/Common/SystemConfig/
#        -IXCategory/Common/SystemTimers/ -IXCategory/Common/Utilities/
#        -IXCategory/Driver/ -IXCategory/Driver/API/
#        -IXCategory/Driver/API/Comparator/ -IXCategory/Driver/API/DataFlash/
#        -IXCategory/Driver/API/Dma/ -IXCategory/Driver/API/Flash/
#        -IXCategory/Driver/API/Gpio/ -IXCategory/Driver/API/Micro/
#        -IXCategory/Driver/API/Spi/ -IXCategory/Driver/API/SRMCAtod/
#        -IXCategory/Driver/API/SRMCPwm/ -IXCategory/Driver/API/TimerInterrupt/
#        -IXCategory/Driver/API/Uart/ -IXCategory/Driver/Comparator/
#        -IXCategory/Driver/DataFlash/ -IXCategory/Driver/Dma/
#        -IXCategory/Driver/Flash/ -IXCategory/Driver/Gpio/
#        -IXCategory/Driver/Micro/ -IXCategory/Driver/Spi/
#        -IXCategory/Driver/SRMCAtod/ -IXCategory/Driver/SRMCPwm/
#        -IXCategory/Driver/TimerInterrupt/ -IXCategory/Driver/Uart/
#        -IXCategory/Hbl/ -IXCategory/Hbl/Mci/
#        -IXCategory/Hbl/Mci/InverterTemp/ -IXCategory/Hbl/Mci/Mcl/
#        -IXCategory/Hbl/Mci/Mcl/Braking/ -IXCategory/Hbl/Mci/Mcl/MacroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MclFvt/ -IXCategory/Hbl/Mci/Mcl/MicroBlocks/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/ClrkPark/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Filters/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Math/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/Pi/
#        -IXCategory/Hbl/Mci/Mcl/MicroBlocks/PwmModulation/
#        -IXCategory/Hbl/Mci/Mcl/ResistanceEstimation/
#        -IXCategory/Hbl/Mci/PowerModuleManager/
#        -IXCategory/Hbl/Mci/SpeedRefGen/ -IXCategory/Hbl/Mci/SurgeRelay/
#        -IXCategory/Hbl/SRMotorSafetyMgr/
#        -IXCategory/Hbl/SRMotorSafetyMgr/API/ -IXCategory/Service/
#        -IXCategory/Service/Reveal/ -IXCategory/Service/Win/ --remarks
#        --no_tbaa --debug --use_c++_inline --only_stdout --dlib_config
#        ..\cx\inc\DLib_Config_Normal.h -r -D
#        ENABLE_JUMP_TO_APPLICATION_WITHOUT_IAP_FIRMWARE -D ARM_MATH_CM4 -e
#        --silent --endian=little --cpu Cortex-M4 --fpu=VFPv4_sp -Ohs -o
#        Uart.obj -l ..\listings\Uart.lst XCategory\Driver\Uart\Uart.c
#    List file    =  ..\listings\Uart.lst
#    Object file  =  Uart.obj
#
###############################################################################

C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Driver\Uart\Uart.c
      1          /**
      2           *  @file
      3           *  @brief    Uart GDM module for Kinetis MKV3x family implements the Uart Standard API (Application Programming Interface).
      4           *  @details  This module provides the interface to the application such as initialization of Uart,\n
      5           *              transmission and reception of serial data.
      6           *
      7           * <pre>
      8           * The UART0,UART1 and UART2 are available in the below port pins in MKV3x Controllers
      9           * ------------------------------------------------------------------------
     10           * |                           MKV3x_FAMILY                               |
     11           * |----------------------------------------------------------------------|
     12           * |         Uart COM            |  REMAP 0 | REMAP 1 | REMAP 2 | REMAP 3 |
     13           * |-----------------------------|----------|---------|---------|---------|
     14           * |    COM0     |   Tx Pin      | PORTA 2  | PORTA 14| PORTB 1 | PORTB 17|
     15           * |   (UART0)   |---------------|----------|---------|---------|---------|
     16           * |             |   Rx Pin      | PORTA 1  | PORTA 15| PORTB 0 | PORTB 16|
     17           * |-------------|---------------|----------|---------|--------- ---------
     18           * |    COM1     |   Tx Pin      | PORTC 4  | PORTE 0 |
     19           * |   (UART1)   |---------------|----------|---------|
     20           * |             |   Rx pin      | PORTC 3  | PORTE 1 |
     21           * |-------------|---------------|----------|---------|
     22           * |    COM2     |   Tx Pin      | PORTD 3  | PORTE 16|
     23           * |   (UART2)   |---------------|----------|---------|
     24           * |             |   Rx pin      | PORTD 2  | PORTI 17|
     25           * --------------------------------------------------- </pre>
     26           *
     27           * @note: UART0 & UART1: Configures on System Clock
     28           * 				  UART2: Configured on Bus Clock
     29           *
     30           *  $Header: Uart.c 1.3 2015/08/17 18:49:13EDT Natak Rahul (NATAKRB) Exp  $
     31           *
     32           *   @copyright  Copyright 2007-2012-$Date: 2015/08/17 18:49:13EDT $. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
     33           */
     34          //-------------------------------------- Include Files ----------------------------------------------------------------
     35          #include "C_Extensions.h"
     36          #include "Micro.h"
     37          #include "Gpio.h"

  extern const volatile GPIO_DEF * GPIO_PORT_LIST[];
  ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Driver\Gpio\Gpio_macros.h",34  Remark[Pe083]: 
          type qualifier specified more than once

  PACKED typedef struct
         ^
"C:\Data\Python\Windy_sBpm_Floating\source\XCategory\Driver\API\Gpio\Gpio.h",41  Remark[Pe082]: 
          storage class is not first
     38          #include "Uart.h"
     39          
     40          //=====================================================================================================================
     41          //Compiler directive
     42          //=====================================================================================================================
     43          #ifndef UART_POLLING_MODE
     44              #define UART_POLLING_MODE				DISABLED
     45          #endif
     46          
     47          //! UART0 means COM0
     48          #ifndef UART0_FEATURE
     49              #define UART0_FEATURE					ENABLED
     50          #endif
     51          
     52          //! UART1 means COM1
     53          #ifndef UART1_FEATURE
     54              #define UART1_FEATURE					DISABLED
     55          #endif
     56          
     57          //! UART2 means COM2
     58          #ifndef UART2_FEATURE
     59              #define UART2_FEATURE					DISABLED
     60          #endif
     61          
     62          
     63          //! Enable the Variables, Constants & Defines only if the either one of the UART is enabled
     64          #if ((UART0_FEATURE == ENABLED)||(UART1_FEATURE == ENABLED)||(UART2_FEATURE == ENABLED))
     65              #if (UART0_FEATURE == ENABLED)
     66                  #ifndef UART0_TX_BUF_SIZE
     67                      #define UART0_TX_BUF_SIZE						22
     68                  #elif (UART0_TX_BUF_SIZE > 255 )
     69                      #error " UART0_TX_BUF_SIZE should not be more than 255 in Uart_prm.h file"
     70                  #endif
     71          
     72                  #ifndef UART0_RX_BUF_SIZE
     73                      #define UART0_RX_BUF_SIZE						22
     74                  #elif (UART0_RX_BUF_SIZE > 255 )
     75                      #error " UART0_RX_BUF_SIZE should not be more than 255 in Uart_prm.h file"
     76                  #endif
     77          
     78                  #ifndef COM0_PREEMPTION_PRIORITY
     79                      #define COM0_PREEMPTION_PRIORITY				0
     80                  #elif (COM0_PREEMPTION_PRIORITY > 3)
     81                      #error " COM0_PREEMPTION_PRIORITY should be either 0,1,2,3. Where 0 is the Highest priority and 3 is the lowest priority."
     82                  #endif
     83              #endif
     84          
     85              #if (UART1_FEATURE == ENABLED)
     86                  #ifndef UART1_TX_BUF_SIZE
     87                      #define UART1_TX_BUF_SIZE						22
     88                  #elif (UART1_TX_BUF_SIZE > 255 )
     89                      #error " UART1_TX_BUF_SIZE should not be more than 255 in Uart_prm.h file"
     90                  #endif
     91          
     92                  #ifndef UART1_RX_BUF_SIZE
     93                      #define UART1_RX_BUF_SIZE						22
     94                  #elif (UART1_RX_BUF_SIZE > 255 )
     95                      #error " UART1_RX_BUF_SIZE should not be more than 255 in Uart_prm.h file"
     96                  #endif
     97          
     98                  #ifndef COM1_PREEMPTION_PRIORITY
     99                      #define COM1_PREEMPTION_PRIORITY                0
    100                  #elif (COM1_PREEMPTION_PRIORITY > 3)
    101                      #error " COM1_PREEMPTION_PRIORITY should be either 0,1,2,3. Where 0 is the Highest priority and 3 is the lowest priority."
    102                  #endif
    103              #endif
    104          
    105              #if (UART2_FEATURE == ENABLED)
    106                  #ifndef UART2_TX_BUF_SIZE
    107                      #define UART2_TX_BUF_SIZE						22
    108                  #elif (UART2_TX_BUF_SIZE > 255 )
    109                      #error " UART2_TX_BUF_SIZE should not be more than 255 in Uart_prm.h file"
    110                  #endif
    111          
    112                  #ifndef UART2_RX_BUF_SIZE
    113                      #define UART2_RX_BUF_SIZE						22
    114                  #elif (UART2_RX_BUF_SIZE > 255 )
    115                      #error " UART2_RX_BUF_SIZE should not be more than 255 in Uart_prm.h file"
    116                  #endif
    117          
    118                  #ifndef COM2_PREEMPTION_PRIORITY
    119                      #define COM2_PREEMPTION_PRIORITY                0
    120                  #elif (COM2_PREEMPTION_PRIORITY > 3)
    121                      #error " COM2_PREEMPTION_PRIORITY should be either 0,1,2,3. Where 0 is the Highest priority and 3 is the lowest priority."
    122                  #endif
    123              #endif
    124          
    125          #endif
    126          
    127          //-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
    128          //! UART CR1 register clear Mask
    129          #define CR1_CLEAR_MASK                          			((uint8)(UART_C1_LOOPS_MASK| UART_C1_M_MASK |  \
    130                                                                               UART_C1_WAKE_MASK |UART_C1_ILT_MASK |  \
    131                                                                               UART_C1_PE_MASK |UART_C1_PT_MASK))
    132          
    133          //! UART CR2 register clock bits clear Mask
    134          #define CR2_CLEAR_MASK                          			((uint8)(UART_C2_TIE_MASK| UART_C2_TCIE_MASK |  \
    135          																	 UART_C2_RIE_MASK| UART_C2_ILIE_MASK |  \
    136                                                                               UART_C2_TE_MASK |UART_C2_RE_MASK |  \
    137                                                                               UART_C2_RWU_MASK |UART_C2_SBK_MASK))
    138          
    139          //! UART CR3 register clear Mask
    140          #define CR3_CLEAR_MASK                          			((uint8)( UART_C3_TXINV_MASK | UART_C3_ORIE_MASK | \
    141                                                                                UART_C3_NEIE_MASK | UART_C3_FEIE_MASK | \
    142                                                                                UART_C3_PEIE_MASK))
    143          
    144          //UART Stop bit
    145          #define  USART_CR2_1_STOPBIT                    			((uint8)0x00)        //One Stop bit
    146          #define  USART_CR2_2_STOPBIT                    			((uint8)0x20)        //Two Stop bit
    147          
    148          #if ((UART0_FEATURE == ENABLED)||(UART1_FEATURE == ENABLED)||(UART2_FEATURE == ENABLED)||(UART4_FEATURE == ENABLED))

   \                                 In section .text, align 4, keep-with-next
    149              static const uint32 BDRATE[] = {1200,2400,4800,9600,19200,38400,57600,115200,230400,9600,9600,300,600};
   \                     BDRATE:
   \   00000000   0x000004B0         DC32 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400, 9600
   \              0x00000960   
   \              0x000012C0   
   \              0x00002580   
   \              0x00004B00   
   \              0x00009600   
   \              0x0000E100   
   \              0x0001C200   
   \              0x00038400   
   \              0x00002580   
   \   00000028   0x00002580         DC32 9600, 300, 600
   \              0x0000012C   
   \              0x00000258   
    150          

   \                                 In section .text, align 4, keep-with-next
    151              static UART_BASIC_DEF * const UART_PTR[] =
   \                     UART_PTR:
   \   00000000   0x4006A000         DC32 4006A000H, 4006B000H, 0H
   \              0x4006B000   
   \              0x00000000   
    152              {
    153                  #if (UART0_FEATURE == ENABLED)
    154                      &UART0,
    155                  #else
    156                      NULL,
    157                  #endif
    158          
    159                  #if (UART1_FEATURE == ENABLED)
    160                      &UART1,
    161                  #else
    162                      NULL,
    163                  #endif
    164          
    165                  #if (UART2_FEATURE == ENABLED)
    166                      &UART2,
    167                  #else
    168                      NULL,
    169                  #endif
    170          
    171               };
    172          
    173              typedef struct
    174              {
    175                  uint16 parity_err      :1;
    176                  uint16 frame_err       :1;
    177                  uint16 noise_err       :1;
    178                  uint16 overrun_err     :1;
    179                  uint16 incomming_break :1;
    180                  uint16 data            :8;
    181                  uint16 unused12_to_15  :3;
    182              } DATA_REGISTER_TYPE;
    183          
    184              #if (UART0_FEATURE == ENABLED)

   \                                 In section .bss, align 4
    185                  static DATA_REGISTER_TYPE UART0_Rx_Buffer[UART0_RX_BUF_SIZE];
    186                  static uint8 UART0_Tx_Buffer[UART0_TX_BUF_SIZE];
    187                  static uint8 UART0_Tx_Write_Index;
   \                     UART0_Tx_Write_Index:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 1
   \   00000003                      DS8 1
   \   00000004                      DS8 1
   \   00000005                      DS8 1
   \   00000006                      DS8 1
   \   00000007                      DS8 1
   \   00000008                      DS8 1
   \   00000009                      DS8 1
   \   0000000A                      DS8 2
   \   0000000C                      DS8 44
   \   00000038                      DS8 24
   \   00000050                      DS8 4
   \   00000054                      DS8 44
   \   00000080                      DS8 24
   \   00000098                      DS8 4
    188                  static uint8 UART0_Tx_Read_Index;
    189                  static uint8 UART0_Rx_Write_Index;
    190                  static uint8 UART0_Rx_Read_Index;
    191                  static uint8 UART0_Break;
    192                  static DATA_REGISTER_TYPE UART0_LastData;
    193              #endif
    194          
    195              #if (UART1_FEATURE == ENABLED)
    196                  static DATA_REGISTER_TYPE UART1_Rx_Buffer[UART1_RX_BUF_SIZE];
    197                  static uint8 UART1_Tx_Buffer[UART1_TX_BUF_SIZE];
    198                  static uint8 UART1_Tx_Write_Index;
    199                  static uint8 UART1_Tx_Read_Index;
    200                  static uint8 UART1_Rx_Write_Index;
    201                  static uint8 UART1_Rx_Read_Index;
    202                  static uint8 UART1_Break;
    203                  static DATA_REGISTER_TYPE  UART1_LastData;
    204              #endif
    205          
    206              #if (UART2_FEATURE == ENABLED)
    207                  static DATA_REGISTER_TYPE UART2_Rx_Buffer[UART2_RX_BUF_SIZE];
    208                  static uint8 UART2_Tx_Buffer[UART2_TX_BUF_SIZE];
    209                  static uint8 UART2_Tx_Write_Index;
    210                  static uint8 UART2_Tx_Read_Index;
    211                  static uint8 UART2_Rx_Write_Index;
    212                  static uint8 UART2_Rx_Read_Index;
    213                  static uint8 UART2_Break;
    214                  static DATA_REGISTER_TYPE UART2_LastData;
    215              #endif
    216          
    217          #endif
    218          
    219          //-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
    220          
    221          //=====================================================================================================================
    222          //-------------------------------------- Public Functions -------------------------------------------------------------
    223          //=====================================================================================================================
    224          //---------------------------------------------------------------------------------------------------------------------
    225          /**
    226           *    @brief    This method initializes a specific Uart with given configuration such as baud rate (i.e. speed),\n
    227           *              stop bits and parity. It also initializes the Uart module variables.
    228           *    @details  Before using Uart module this method should be called to initialize specific Uart.
    229           *    @param    uart    : Defines the Uart COM port
    230           *    @param    speed   : Defines the baud rate for Uart
    231           *    @param    stops   : Defines the stop bit for Uart
    232           *    @param    parity  : Defines the parity bit for Uart
    233           *    @return   TRUE (1)    :  If the Uart is successfully initialized.
    234           *              FALSE (0)   : Failed to initialize the Uart.
    235           *
    236           *    @image    html    Uart__Initialize.jpg
    237           */

   \                                 In section .text, align 2, keep-with-next
    238          BOOL_TYPE Uart__Initialize(UART_ENUM_DEF uart, UART_SPEED_DEF speed,UART_STOP_DEF stops, UART_PARITY_DEF parity)
    239          {
   \                     Uart__Initialize: (+1)
   \   00000000   0xE92D 0x46F0      PUSH     {R4-R7,R9,R10,LR}
   \   00000004   0x4605             MOV      R5,R0
    240          #if ((UART0_FEATURE == ENABLED)||(UART1_FEATURE == ENABLED)||(UART2_FEATURE == ENABLED))
    241          	uint8 u8tmpreg;
    242          	uint16 u16tmpreg;
    243          	uint32 busclock;
    244          	BOOL_TYPE response;
    245          	UART_BASIC_DEF * com;
    246          
    247          	u8tmpreg = 0;
    248          	u16tmpreg = 0;
    249          	response = FALSE;
   \   00000006   0x2000             MOVS     R0,#+0
    250          	com = NULL;
    251          
    252          	if (uart < COM3)
   \   00000008   0x462E             MOV      R6,R5
   \   0000000A   0xB081             SUB      SP,SP,#+4
   \   0000000C   0x4691             MOV      R9,R2
   \   0000000E   0x461C             MOV      R4,R3
   \   00000010   0x2E03             CMP      R6,#+3
   \   00000012   0xDA75             BGE.N    ??Uart__Initialize_0
   \   00000014   0x.... 0x....      ADR.W    R2,UART_PTR
   \   00000018   0xF852 0x7026      LDR      R7,[R2, R6, LSL #+2]
    253          	{
    254          		com = UART_PTR[uart];
    255          
    256          		if (com != NULL)
   \   0000001C   0x2F00             CMP      R7,#+0
   \   0000001E   0xD06F             BEQ.N    ??Uart__Initialize_0
    257          		{
    258          			if (speed <= (B230400))
   \   00000020   0x468A             MOV      R10,R1
   \   00000022   0xF1BA 0x0F09      CMP      R10,#+9
   \   00000026   0xDA6B             BGE.N    ??Uart__Initialize_0
    259          			{
    260          				Uart__Clear(uart);
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x.... 0x....      BL       Uart__Clear
    261          
    262          			#if(UART0_FEATURE == ENABLED)
    263          				if (uart == COM0)
   \   0000002E   0xB95D             CBNZ.N   R5,??Uart__Initialize_1
    264          				{
    265          					SIM.SCGC4 |= SIM_SCGC4_UART0_MASK;											//Clock Enabled for UART0 module
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40048034
   \   00000034   0x6801             LDR      R1,[R0, #+0]
   \   00000036   0xF441 0x6180      ORR      R1,R1,#0x400
   \   0000003A   0x6001             STR      R1,[R0, #+0]
    266          					#if (UART0_REMAP == 0)														//Configure the Uart0 Tx and Rx port-pin
    267          						PCIPORTA.PCR[2] = PORT_PCR_MUX(2);										//PTE0 pin - UART Tx
    268          						PCIPORTA.PCR[1] = PORT_PCR_MUX(2);										//PTE1 pin - UART Rx
    269          					#elif(UART0_REMAP == 1)
    270          						PCIPORTA.PCR[14] = PORT_PCR_MUX(3);										//PTE0 pin - UART Tx
    271          						PCIPORTA.PCR[15] = PORT_PCR_MUX(3);										//PTE1 pin - UART Rx
    272          					#elif(UART0_REMAP == 2)
    273          						PCIPORTB.PCR[1] = PORT_PCR_MUX(7);										//PTB1 pin - UART Tx
    274          						PCIPORTB.PCR[0] = PORT_PCR_MUX(7);										//PTB0 pin - UART Rx
    275          					#else
    276          						PCIPORTB.PCR[17] = PORT_PCR_MUX(3);										//PTB17 pin - UART Tx
   \   0000003C   0xF44F 0x7140      MOV      R1,#+768
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x4004a040
   \   00000044   0x6041             STR      R1,[R0, #+4]
    277          						PCIPORTB.PCR[16] = PORT_PCR_MUX(3);										//PTB16 pin - UART Rx
   \   00000046   0x6001             STR      R1,[R0, #+0]
    278          				#endif
    279          
    280          				}
    281          			#endif
    282          
    283          			#if(UART1_FEATURE == ENABLED)
    284          				if(uart == COM1)
   \                     ??Uart__Initialize_1: (+1)
   \   00000048   0x2E01             CMP      R6,#+1
   \   0000004A   0xD10D             BNE.N    ??Uart__Initialize_2
    285          				{
    286          					SIM.SCGC4 |= SIM_SCGC4_UART1_MASK;											//Clock Enabled for UART1 module
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40048034
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0xF441 0x6100      ORR      R1,R1,#0x800
   \   00000056   0x6001             STR      R1,[R0, #+0]
    287          					#if (UART1_REMAP == 0)														//Configure UART1 Tx and Rx port-pin
    288          						PCIPORTC.PCR[4] = PORT_PCR_MUX(3);										//PTE0 pin - UART Tx
   \   00000058   0xF44F 0x7140      MOV      R1,#+768
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x4004a040
   \   00000060   0xF8C0 0x1FD0      STR      R1,[R0, #+4048]
    289          						PCIPORTC.PCR[3] = PORT_PCR_MUX(3);										//PTE1 pin - UART Rx
   \   00000064   0xF8C0 0x1FCC      STR      R1,[R0, #+4044]
    290          					#else
    291          						PCIPORTE.PCR[0] = PORT_PCR_MUX(3);										//PTE0 pin - UART Tx
    292          						PCIPORTE.PCR[1] = PORT_PCR_MUX(3);										//PTE1 pin - UART Rx
    293          					#endif
    294          				}
    295          			#endif
    296          
    297          			#if(UART2_FEATURE == ENABLED)
    298          				if(uart == COM2)
    299          				{
    300          					SIM_CLK.SIM_SCGC |= SIM_SCGC_UART2_MASK;									//Clock Enabled for UART2 module
    301          					#if (UART2_REMAP == 0)
    302          						PCIPORTD.PCR[3] = PORT_PCR_MUX(3);										//PTD3 pin - UART Tx
    303          						PCIPORTD.PCR[2] = PORT_PCR_MUX(3);										//PTD2 pin - UART Rx
    304          					#else
    305          						PCIPORTE.PCR[16] = PORT_PCR_MUX(3);										//PTE16 pin - UART Tx
    306          						PCIPORTE.PCR[17] = PORT_PCR_MUX(3);										//PTE17 pin - UART Rx
    307          					#endif
    308          
    309          				}
    310          			#endif
    311          
    312          				//Make sure that the transmitter and receiver are disabled while changing the settings
    313          				com->UART_C2 = (uint8) ~(CR2_CLEAR_MASK);
                 				                       ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \                     ??Uart__Initialize_2: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x70F8             STRB     R0,[R7, #+3]
   \   0000006C   0x2C01             CMP      R4,#+1
    314          
    315          				//---------------------------- UART C1 Configuration -----------------------
    316          				u8tmpreg = com->UART_C1;
    317          				u8tmpreg &= (uint8) ~(CR1_CLEAR_MASK);      // Clear M, PCE, PS, TE and RE bits
                 				                    ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \   0000006E   0x78B8             LDRB     R0,[R7, #+2]
   \   00000070   0xF000 0x0060      AND      R0,R0,#0x60
    318          
    319          				// Configure the UART Word Length, Parity and mode -----------------------
    320          				// Set the M bits When the parity is ON
    321          				// Set PCE(Parity Control) and PS(Parity selection) as per the request
    322          				// Over sampling by 16 method is selected
    323          				if (parity == UART_PARITY_EVEN)
   \   00000074   0xBF08             IT       EQ 
    324          				{
    325          					u8tmpreg |= (UART_C1_PE_MASK | UART_C1_M_MASK);
   \   00000076   0xF040 0x0012      ORREQ    R0,R0,#0x12
   \   0000007A   0xD003             BEQ.N    ??Uart__Initialize_3
    326          				}
    327          				else if (parity == UART_PARITY_ODD)
   \   0000007C   0x2C02             CMP      R4,#+2
   \   0000007E   0xBF08             IT       EQ 
    328          				{
    329          					u8tmpreg |= (UART_C1_PE_MASK | UART_C1_M_MASK | UART_C1_PT_MASK);
   \   00000080   0xF040 0x0013      ORREQ    R0,R0,#0x13
    330          				}
    331          
    332          				com->UART_C1 = u8tmpreg;                                  		// Write to USART CR1
   \                     ??Uart__Initialize_3: (+1)
   \   00000084   0x70B8             STRB     R0,[R7, #+2]
    333          				com->UART_C3 = 0x00;                                      		//UART C3 Configuration
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x71B8             STRB     R0,[R7, #+6]
   \   0000008A   0xF1B9 0x0F01      CMP      R9,#+1
    334          				//---------------------------- UART BRRH Configuration ----------------------
    335          				u8tmpreg = com->UART_BRRH;
    336          				// Clear STOP[13:12] bits
    337          				u8tmpreg &=	(uint32) ~((uint32) UART_BDH_SBNS_MASK);
   \   0000008E   0x7838             LDRB     R0,[R7, #+0]
   \   00000090   0xF000 0x00DF      AND      R0,R0,#0xDF
    338          
    339          				// Configure the UART Stop Bits ------------
    340          				// Set STOP bit according to UART_StopBits value i.e SBSN bit value of BRR register
    341          				if (stops == UART_STOP_BIT_2)
   \   00000094   0xBF08             IT       EQ 
    342          				{
    343          					u8tmpreg |= (uint32) USART_CR2_2_STOPBIT;             		// 1 Stop Bit by default
   \   00000096   0xF040 0x0020      ORREQ    R0,R0,#0x20
    344          				}
    345          
    346          				com->UART_BRRH = u8tmpreg;                                		// Write Stop bit to UART CR2
   \   0000009A   0x7038             STRB     R0,[R7, #+0]
    347          				//---------------------------- UART BRRH & BRRL Configuration ------------------
    348          
    349          				//Baudrate = UART Module Clock/(SBR[12:0] * 16)
    350          				//         Kinteis - Calculate baud settings
    351          				//         u16Sbr = (((u32SysClk)>>4) + (u32Baud>>1))/u32Baud;
    352          
    353          				if((UART0_FEATURE == ENABLED)|(UART1_FEATURE == ENABLED))
    354          				{
    355          					busclock = Micro__GetClock()->SYSCLK_Frequency;			//System clock: UART0 & UART1
   \   0000009C   0x.... 0x....      BL       Micro__GetClock
    356          				}
    357          				else
    358          				{
    359          					busclock = Micro__GetClock()->BUSCLK_Frequency;			//System clock: UART2
    360          				}
    361          
    362          				u16tmpreg = ((busclock) / (BDRATE[speed] * 16));
   \   000000A0   0x.... 0x....      ADR.W    R1,BDRATE
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0xF851 0x102A      LDR      R1,[R1, R10, LSL #+2]
   \   000000AA   0x0109             LSLS     R1,R1,#+4
   \   000000AC   0xFBB0 0xF0F1      UDIV     R0,R0,R1
    363          				u8tmpreg = com->UART_BRRH & ~(UART_BDH_SBR_MASK);            	//Save current value of UART0 BDH except for the SBR field
    364          				com->UART_BRRH = u8tmpreg | (u16tmpreg >> 8);                	//Write Calculated Baud Rate in the Baudrate register
   \   000000B0   0x7839             LDRB     R1,[R7, #+0]
   \   000000B2   0xB280             UXTH     R0,R0
   \   000000B4   0xF001 0x01E0      AND      R1,R1,#0xE0
   \   000000B8   0xEA41 0x2110      ORR      R1,R1,R0, LSR #+8
   \   000000BC   0x7039             STRB     R1,[R7, #+0]
    365          				com->UART_BRRL = (uint8) (u16tmpreg & UART_BDL_SBR_MASK);
   \   000000BE   0x7078             STRB     R0,[R7, #+1]
    366          
    367          			#if (UART_POLLING_MODE == DISABLED)
    368          
    369          				#if (UART0_FEATURE == ENABLED)									//Enable UART0 Interrupt and Set Priority for UART0
    370          					if (uart == COM0)
   \   000000C0   0xB94D             CBNZ.N   R5,??Uart__Initialize_4
    371          					{
    372          						Micro__NVICEnableIRQ(UART0_STATUS_IRQ_CHANNEL,COM0_PREEMPTION_PRIORITY, COM0_CHANNEL_SUB_PRIORITY);
   \   000000C2   0x2201             MOVS     R2,#+1
   \   000000C4   0x2103             MOVS     R1,#+3
   \   000000C6   0x201F             MOVS     R0,#+31
   \   000000C8   0x.... 0x....      BL       Micro__NVICEnableIRQ
    373          						Micro__NVICEnableIRQ(UART0_ERROR_IRQ_CHANNEL,	COM0_PREEMPTION_PRIORITY, COM0_CHANNEL_SUB_PRIORITY);
   \   000000CC   0x2201             MOVS     R2,#+1
   \   000000CE   0x2103             MOVS     R1,#+3
   \   000000D0   0x2020             MOVS     R0,#+32
   \   000000D2   0x.... 0x....      BL       Micro__NVICEnableIRQ
    374          					}
    375          				#endif
    376          
    377          				#if (UART1_FEATURE == ENABLED)									//Enable UART1 Interrupt and Set Priority for UART1
    378          					if (uart == COM1)
   \                     ??Uart__Initialize_4: (+1)
   \   000000D6   0x2E01             CMP      R6,#+1
   \   000000D8   0xD109             BNE.N    ??Uart__Initialize_5
    379          					{
    380          						Micro__NVICEnableIRQ(UART1_STATUS_IRQ_CHANNEL,COM1_PREEMPTION_PRIORITY, COM1_CHANNEL_SUB_PRIORITY);
   \   000000DA   0x2201             MOVS     R2,#+1
   \   000000DC   0x2103             MOVS     R1,#+3
   \   000000DE   0x2021             MOVS     R0,#+33
   \   000000E0   0x.... 0x....      BL       Micro__NVICEnableIRQ
    381          						Micro__NVICEnableIRQ(UART1_ERROR_IRQ_CHANNEL,	COM1_PREEMPTION_PRIORITY, COM1_CHANNEL_SUB_PRIORITY);
   \   000000E4   0x2201             MOVS     R2,#+1
   \   000000E6   0x2103             MOVS     R1,#+3
   \   000000E8   0x2022             MOVS     R0,#+34
   \   000000EA   0x.... 0x....      BL       Micro__NVICEnableIRQ
   \                     ??Uart__Initialize_5: (+1)
   \   000000EE   0x78F8             LDRB     R0,[R7, #+3]
   \   000000F0   0xF040 0x00AC      ORR      R0,R0,#0xAC
   \   000000F4   0x70F8             STRB     R0,[R7, #+3]
   \   000000F6   0x79B8             LDRB     R0,[R7, #+6]
   \   000000F8   0xF040 0x000F      ORR      R0,R0,#0xF
   \   000000FC   0x71B8             STRB     R0,[R7, #+6]
    382          					}
    383          
    384          				#endif
    385          
    386          				#if (UART2_FEATURE == ENABLED)									//Enable UART2 Interrupt and Set Priority for UART2
    387          					if (uart == COM2)
    388          					{
    389          						Micro__NVICEnableIRQ(UART2_STATUS_IRQ_CHANNEL,COM2_PREEMPTION_PRIORITY, COM2_CHANNEL_SUB_PRIORITY);
    390          						Micro__NVICEnableIRQ(UART2_ERROR_IRQ_CHANNEL,	COM2_PREEMPTION_PRIORITY, COM2_CHANNEL_SUB_PRIORITY);
    391          					}
    392          				#endif
    393          
    394          			#endif
    395          
    396          				Uart__Enable(uart, UART_OPTION_ALL);                    		//Enable UARTx module
    397          				response = TRUE;
   \   000000FE   0x2001             MOVS     R0,#+1
    398          			}
    399          		}
    400          	}
    401          #else
    402          	uint8 response;
    403          	response = FALSE;
    404          #endif
    405          
    406          	return response;
   \                     ??Uart__Initialize_0: (+1)
   \   00000100   0xB001             ADD      SP,SP,#+4
   \   00000102   0xE8BD 0x86F0      POP      {R4-R7,R9,R10,PC}  ;; return
    407          }
    408          
    409          //---------------------------------------------------------------------------------------------------------------------
    410          /**
    411           *  @brief      This method clears transmit and receive FIFO buffers of a specific uart.
    412           *
    413           *  @param      uart: uart enumerator
    414           *    @image    html    Uart__Clear.jpg
    415           */

   \                                 In section .text, align 2, keep-with-next
    416          void Uart__Clear(UART_ENUM_DEF uart)
    417          {
    418              #if ((UART0_FEATURE == ENABLED)||(UART1_FEATURE == ENABLED)||(UART2_FEATURE == ENABLED))
    419                  MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    420                  MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \                     Uart__Clear: (+1)
   \   00000000   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   00000004   0xB672             CPSID    I
    421          
    422                  #if (UART0_FEATURE == ENABLED)
    423                      if (uart == COM0)
   \   00000006   0xB948             CBNZ.N   R0,??Uart__Clear_0
    424                      {
    425                          UART0_Break = FALSE;
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable15_2
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x7113             STRB     R3,[R2, #+4]
    426          
    427                          //Clear the Read and Write Index of Tx and Rx FIFO
    428                          UART0_Tx_Write_Index = 0;
   \   00000010   0x7013             STRB     R3,[R2, #+0]
    429                          UART0_Tx_Read_Index = 0;
   \   00000012   0x7053             STRB     R3,[R2, #+1]
    430                          UART0_Rx_Write_Index = 0;
   \   00000014   0x7093             STRB     R3,[R2, #+2]
    431                          UART0_Rx_Read_Index = 0;
   \   00000016   0x70D3             STRB     R3,[R2, #+3]
    432                          *((uint16 *)(&UART0_LastData)) = 0;
   \   00000018   0xF8A2 0x3050      STRH     R3,[R2, #+80]
    433                      }
    434                  #endif
    435          
    436                  #if (UART1_FEATURE == ENABLED)
    437                      if (uart == COM1)
   \                     ??Uart__Clear_0: (+1)
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD109             BNE.N    ??Uart__Clear_1
    438                      {
    439                          UART1_Break = FALSE;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      LDR.W    R2,??DataTable15_2
   \   00000026   0x7250             STRB     R0,[R2, #+9]
    440          
    441                          //Clear the Read and Write Index of Tx and Rx FIFO
    442                          UART1_Tx_Write_Index = 0;
   \   00000028   0x7150             STRB     R0,[R2, #+5]
    443                          UART1_Tx_Read_Index = 0;
   \   0000002A   0x7190             STRB     R0,[R2, #+6]
    444                          UART1_Rx_Write_Index = 0;
   \   0000002C   0x71D0             STRB     R0,[R2, #+7]
    445                          UART1_Rx_Read_Index = 0;
   \   0000002E   0x7210             STRB     R0,[R2, #+8]
    446                          *((uint16 *)(&UART1_LastData)) = 0;
   \   00000030   0xF8A2 0x0098      STRH     R0,[R2, #+152]
    447                      }
    448                  #endif
    449          
    450                  #if (UART2_FEATURE == ENABLED)
    451                      if (uart == COM2)
    452                      {
    453                          UART2_Break = FALSE;
    454          
    455                          //Clear the Read and Write Index of Tx and Rx FIFO
    456                          UART2_Tx_Write_Index = 0;
    457                          UART2_Tx_Read_Index = 0;
    458                          UART2_Rx_Write_Index = 0;
    459                          UART2_Rx_Read_Index = 0;
    460                          *((uint16 *)(&UART2_LastData)) = 0;
    461                      }
    462                  #endif
    463          
    464                  MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \                     ??Uart__Clear_1: (+1)
   \   00000034   0xF381 0x8810      MSR      PRIMASK,R1
    465              #endif
    466          }
   \   00000038   0x4770             BX       LR               ;; return
    467          
    468          //---------------------------------------------------------------------------------------------------------------------
    469          /**
    470           * @brief    This method clears the transmit FIFO buffers of a specific Uart.
    471           * @param uart    : Defines the Uart COM port
    472           */

   \                                 In section .text, align 2, keep-with-next
    473          void Uart__ClearTx(UART_ENUM_DEF uart)
    474          {
    475              #if ((UART0_FEATURE == ENABLED)||(UART1_FEATURE == ENABLED)||(UART2_FEATURE == ENABLED))
    476                  MICRO_DECLARE_INTERRUPT_CONTEXT_LOCAL();
    477                  MICRO_SAVE_INTERRUPT_CONTEXT_LOCAL();
   \                     Uart__ClearTx: (+1)
   \   00000000   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   00000004   0xB672             CPSID    I
    478          
    479                  #if (UART0_FEATURE == ENABLED)
    480                      if (uart == COM0)
   \   00000006   0xB920             CBNZ.N   R0,??Uart__ClearTx_0
    481                      {
    482                          //Clear the Read and Write Index of Tx and Rx FIFO
    483                          UART0_Tx_Write_Index = 0;
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable15_2
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x7013             STRB     R3,[R2, #+0]
    484                          UART0_Tx_Read_Index = 0;
   \   00000010   0x7053             STRB     R3,[R2, #+1]
    485                      }
    486                  #endif
    487          
    488                  #if (UART1_FEATURE == ENABLED)
    489                      if (uart == COM1)
   \                     ??Uart__ClearTx_0: (+1)
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD104             BNE.N    ??Uart__ClearTx_1
    490                      {
    491                          //Clear the Read and Write Index of Tx and Rx FIFO
    492                          UART1_Tx_Write_Index = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable15_2
   \   0000001C   0x7150             STRB     R0,[R2, #+5]
    493                          UART1_Tx_Read_Index = 0;
   \   0000001E   0x7190             STRB     R0,[R2, #+6]
    494                      }
    495                  #endif
    496          
    497                  #if (UART2_FEATURE == ENABLED)
    498                      if (uart == COM2)
    499                      {
    500                          //Clear the Read and Write Index of Tx and Rx FIFO
    501                          UART2_Tx_Write_Index = 0;
    502                          UART2_Tx_Read_Index = 0;
    503                      }
    504                  #endif
    505          
    506                  MICRO_RESTORE_INTERRUPT_CONTEXT_LOCAL();
   \                     ??Uart__ClearTx_1: (+1)
   \   00000020   0xF381 0x8810      MSR      PRIMASK,R1
    507              #endif
    508          }
   \   00000024   0x4770             BX       LR               ;; return
    509          
    510          //---------------------------------------------------------------------------------------------------------------------
    511          /**
    512           *    @brief    This method enables transmission, reception or both depending on option for
    513           *              specific uart.
    514           *    @details  This method enables an option (UART_OPTION_ALL,UART_OPTION_TX_EN,UART_OPTION_RX_EN)
    515           *              for a specific Uart.
    516           *    @param    uart   : Defines the Specific Uart COM port
    517           *    @param    option : Defines the option to enable the transmitter, receiver or both of the
    518           *                       specific Uart.
    519           *
    520           *    @image    html    Uart__Enable.jpg
    521           */

   \                                 In section .text, align 2, keep-with-next
    522          void Uart__Enable(UART_ENUM_DEF uart,UART_ENABLE_OPTIONS_DEF option)
    523          {
    524              #if ((UART0_FEATURE == ENABLED)||(UART1_FEATURE == ENABLED)||(UART2_FEATURE == ENABLED))
    525          	UART_BASIC_DEF  *com;
    526          
    527          	com = NULL;
    528              if (uart < COM3 )
   \                     Uart__Enable: (+1)
   \   00000000   0x2803             CMP      R0,#+3
   \   00000002   0xDA19             BGE.N    ??Uart__Enable_0
    529              {
    530                  com =  UART_PTR[uart];
   \   00000004   0x.... 0x....      ADR.W    R2,UART_PTR
   \   00000008   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
    531          
    532                  if (com != NULL)
   \   0000000C   0xB1A2             CBZ.N    R2,??Uart__Enable_0
    533                  {
    534                      switch (option)
   \   0000000E   0xB119             CBZ.N    R1,??Uart__Enable_1
   \   00000010   0x2902             CMP      R1,#+2
   \   00000012   0xD009             BEQ.N    ??Uart__Enable_2
   \   00000014   0xD304             BCC.N    ??Uart__Enable_3
   \   00000016   0x4770             BX       LR
    535                      {
    536                          case UART_OPTION_ALL:
    537                              #if (UART_POLLING_MODE == ENABLED)
    538                          		com->UART_C2 |= UART_C2_TE_MASK;
    539                          		com->UART_C2 |= UART_C2_RE_MASK;
    540                              #else
    541                          		com->UART_C2 |= (UART_C2_RIE_MASK | UART_C2_RE_MASK | UART_C2_TIE_MASK | UART_C2_TE_MASK );
   \                     ??Uart__Enable_1: (+1)
   \   00000018   0x78D0             LDRB     R0,[R2, #+3]
   \   0000001A   0xF040 0x00AC      ORR      R0,R0,#0xAC
   \   0000001E   0xE006             B.N      ??Uart__Enable_4
    542                          		com->UART_C3 |= (UART_C3_ORIE_MASK |UART_C3_NEIE_MASK | UART_C3_FEIE_MASK | UART_C3_PEIE_MASK);
    543                              #endif
    544                              break;
    545          
    546                          case UART_OPTION_TX_EN:
    547                              #if (UART_POLLING_MODE == ENABLED)
    548                      			com->UART_C2 |= UART_C2_TE_MASK;
    549                              #else
    550                      			com->UART_C2 |= (UART_C2_TIE_MASK | UART_C2_TE_MASK);
   \                     ??Uart__Enable_3: (+1)
   \   00000020   0x78D0             LDRB     R0,[R2, #+3]
   \   00000022   0xF040 0x0088      ORR      R0,R0,#0x88
   \   00000026   0xE002             B.N      ??Uart__Enable_4
    551                      			com->UART_C3 |= (UART_C3_ORIE_MASK |UART_C3_NEIE_MASK | UART_C3_FEIE_MASK | UART_C3_PEIE_MASK);
    552                              #endif
    553          
    554                              break;
    555                          case UART_OPTION_RX_EN:
    556                              #if (UART_POLLING_MODE == ENABLED)
    557                      			com->UART_C2 |= UART_C2_RE_MASK;
    558                              #else
    559                      			com->UART_C2 |= (UART_C2_RIE_MASK |UART_C2_RE_MASK );
   \                     ??Uart__Enable_2: (+1)
   \   00000028   0x78D0             LDRB     R0,[R2, #+3]
   \   0000002A   0xF040 0x0024      ORR      R0,R0,#0x24
   \                     ??Uart__Enable_4: (+1)
   \   0000002E   0x70D0             STRB     R0,[R2, #+3]
    560                      			com->UART_C3 |= (UART_C3_ORIE_MASK |UART_C3_NEIE_MASK | UART_C3_FEIE_MASK | UART_C3_PEIE_MASK);
   \   00000030   0x7990             LDRB     R0,[R2, #+6]
   \   00000032   0xF040 0x000F      ORR      R0,R0,#0xF
   \   00000036   0x7190             STRB     R0,[R2, #+6]
    561                              #endif
    562                              break;
    563                          default:
    564                              break;
    565                      }
    566                  }
    567              }
    568              #endif
    569          }
   \                     ??Uart__Enable_0: (+1)
   \   00000038   0x4770             BX       LR               ;; return
    570          
    571          //---------------------------------------------------------------------------------------------------------------------
    572          /**
    573           *    @brief    This method disables transmission, reception or both depending on option for
    574           *              specific uart.
    575           *    @details  This method disables an option (UART_OPTION_ALL,UART_OPTION_TX_EN,UART_OPTION_RX_EN)
    576           *              for a specific Uart.
    577           *    @param    uart   : Defines the Specific Uart COM port
    578           *    @param    option : Defines the option to disable the transmitter, receiver or both of the
    579           *                       specific Uart.
    580           *
    581           *    @image    html    Uart__Disable.jpg
    582           */

   \                                 In section .text, align 2, keep-with-next
    583          void Uart__Disable(UART_ENUM_DEF uart,UART_ENABLE_OPTIONS_DEF option)
    584          {
    585              #if ((UART0_FEATURE == ENABLED)||(UART1_FEATURE == ENABLED)||(UART2_FEATURE == ENABLED))
    586              UART_BASIC_DEF * com;
    587          
    588              if (uart < COM3 )
   \                     Uart__Disable: (+1)
   \   00000000   0x2803             CMP      R0,#+3
   \   00000002   0xDA19             BGE.N    ??Uart__Disable_0
    589              {
    590                  com = UART_PTR[uart];
   \   00000004   0x.... 0x....      ADR.W    R2,UART_PTR
   \   00000008   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
    591          
    592                  if (com != NULL)
   \   0000000C   0xB1A0             CBZ.N    R0,??Uart__Disable_0
    593                  {
    594                      switch (option)
   \   0000000E   0xB119             CBZ.N    R1,??Uart__Disable_1
   \   00000010   0x2902             CMP      R1,#+2
   \   00000012   0xD009             BEQ.N    ??Uart__Disable_2
   \   00000014   0xD304             BCC.N    ??Uart__Disable_3
   \   00000016   0x4770             BX       LR
    595                      {
    596                          case UART_OPTION_ALL:
    597                          	com->UART_C2 &= (uint8)~((uint8)(UART_C2_RIE_MASK | UART_C2_RE_MASK | UART_C2_TE_MASK | UART_C2_TIE_MASK));
                                 	                       ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \                     ??Uart__Disable_1: (+1)
   \   00000018   0x78C1             LDRB     R1,[R0, #+3]
   \   0000001A   0xF001 0x0153      AND      R1,R1,#0x53
   \   0000001E   0xE006             B.N      ??Uart__Disable_4
    598                          	com->UART_C3 &= (uint8)~((uint8)(UART_C3_ORIE_MASK |UART_C3_NEIE_MASK | UART_C3_FEIE_MASK | UART_C3_PEIE_MASK));
                                 	                       ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
    599                              break;
    600          
    601                          case UART_OPTION_TX_EN:
    602                          	com->UART_C2 &= (uint8)~((uint8)(UART_C2_TE_MASK | UART_C2_TIE_MASK));
                                 	                       ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \                     ??Uart__Disable_3: (+1)
   \   00000020   0x78C1             LDRB     R1,[R0, #+3]
   \   00000022   0xF001 0x0177      AND      R1,R1,#0x77
   \   00000026   0xE002             B.N      ??Uart__Disable_4
    603                          	com->UART_C3 &= (uint8)~((uint8)(UART_C3_ORIE_MASK |UART_C3_NEIE_MASK | UART_C3_FEIE_MASK | UART_C3_PEIE_MASK));
                                 	                       ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
    604                              break;
    605          
    606                          case UART_OPTION_RX_EN:
    607                          	com->UART_C2 &= (uint8)~((uint8)(UART_C2_RE_MASK | UART_C2_RIE_MASK));
                                 	                       ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \                     ??Uart__Disable_2: (+1)
   \   00000028   0x78C1             LDRB     R1,[R0, #+3]
   \   0000002A   0xF001 0x01DB      AND      R1,R1,#0xDB
   \                     ??Uart__Disable_4: (+1)
   \   0000002E   0x70C1             STRB     R1,[R0, #+3]
    608                          	com->UART_C3 &= (uint8)~((uint8)(UART_C3_ORIE_MASK |UART_C3_NEIE_MASK | UART_C3_FEIE_MASK | UART_C3_PEIE_MASK));
                                 	                       ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \   00000030   0x7981             LDRB     R1,[R0, #+6]
   \   00000032   0xF001 0x01F0      AND      R1,R1,#0xF0
   \   00000036   0x7181             STRB     R1,[R0, #+6]
    609                              break;
    610          
    611                          default:
    612                              break;
    613                      }
    614                  }
    615              }
    616             #endif
    617          }
   \                     ??Uart__Disable_0: (+1)
   \   00000038   0x4770             BX       LR               ;; return
    618          
    619          //---------------------------------------------------------------------------------------------------------------------
    620          /**
    621           *    @brief    This method writes data from source (buffer address mentioned by the Application) to\n
    622           *              the destination (Transmitter FIFO) as per the size mentioned to the specific Uart\n
    623           *              and also returns the response for the write operation.
    624           *    @details  The data in the Transmitter FIFO is sent to other Uart node through the\n
    625           *              specified Uart COM port whenever the Transmitter is free.\n
    626           *              Before writing into the Transmitter FIFO check for the FIFO availability using Uart__GetStatus() API\n
    627           *              to avoid the over writing on the existing data.
    628           *    @param    uart : Defines the Specific Uart COM port.
    629           *    @param    buf : Indicates the buffers address which contains the data to be sent.
    630           *    @param    size : Defines the number of bytes to be sent.
    631           *    @return   TRUE (1): If the data written in the transmission FIFO is successful.
    632           *              FALSE (0): If data written in the transmission FIFO is failed.
    633           *
    634           *    @image    html    Uart__Write.jpg
    635           */

   \                                 In section .text, align 4, keep-with-next
    636          BOOL_TYPE Uart__Write(UART_ENUM_DEF uart, uint8 * buf,uint8 size)
    637          {
   \                     Uart__Write: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    638              #if ((UART0_FEATURE == ENABLED)||(UART1_FEATURE == ENABLED)||(UART2_FEATURE == ENABLED))
    639                  BOOL_TYPE response;
    640                  uint8 count;
    641                  uint8 pt;
    642          
    643                  response = TRUE;
    644          
    645                  #if (UART0_FEATURE == ENABLED)
    646                      if (uart == COM0)
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable15_2
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD13E             BNE.N    ??Uart__Write_0
    647                      {
    648                          pt = UART0_Tx_Write_Index;
   \   0000000A   0x781D             LDRB     R5,[R3, #+0]
    649                          for (count = 0; count < size; count++)
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD03A             BEQ.N    ??Uart__Write_1
   \   00000010   0xF012 0x0603      ANDS     R6,R2,#0x3
   \   00000014   0xD00B             BEQ.N    ??Uart__Write_2
    650                          {
    651                              UART0_Tx_Buffer[pt] = *buf;
   \                     ??Uart__Write_3: (+1)
   \   00000016   0x18EC             ADDS     R4,R5,R3
   \   00000018   0xF811 0x7B01      LDRB     R7,[R1], #+1
   \   0000001C   0xF884 0x7038      STRB     R7,[R4, #+56]
    652                              buf++;
    653                              pt++;
   \   00000020   0x1C6D             ADDS     R5,R5,#+1
    654                              if (pt >= UART0_TX_BUF_SIZE)
   \   00000022   0xB2ED             UXTB     R5,R5
   \   00000024   0x2D16             CMP      R5,#+22
   \   00000026   0xBFA8             IT       GE 
    655                              {
    656                                  pt = 0;
   \   00000028   0x2500             MOVGE    R5,#+0
   \   0000002A   0x1E76             SUBS     R6,R6,#+1
   \   0000002C   0xD1F3             BNE.N    ??Uart__Write_3
   \                     ??Uart__Write_2: (+1)
   \   0000002E   0x0894             LSRS     R4,R2,#+2
   \   00000030   0xD029             BEQ.N    ??Uart__Write_1
   \                     ??Uart__Write_4: (+1)
   \   00000032   0x18EF             ADDS     R7,R5,R3
   \   00000034   0xF811 0x6B01      LDRB     R6,[R1], #+1
   \   00000038   0xF887 0x6038      STRB     R6,[R7, #+56]
   \   0000003C   0x1C6D             ADDS     R5,R5,#+1
   \   0000003E   0xB2ED             UXTB     R5,R5
   \   00000040   0x2D16             CMP      R5,#+22
   \   00000042   0xBFA8             IT       GE 
   \   00000044   0x2500             MOVGE    R5,#+0
   \   00000046   0x18EF             ADDS     R7,R5,R3
   \   00000048   0xF811 0x6B01      LDRB     R6,[R1], #+1
   \   0000004C   0xF887 0x6038      STRB     R6,[R7, #+56]
   \   00000050   0x1C6D             ADDS     R5,R5,#+1
   \   00000052   0xB2ED             UXTB     R5,R5
   \   00000054   0x2D16             CMP      R5,#+22
   \   00000056   0xBFA8             IT       GE 
   \   00000058   0x2500             MOVGE    R5,#+0
   \   0000005A   0x18EF             ADDS     R7,R5,R3
   \   0000005C   0xF811 0x6B01      LDRB     R6,[R1], #+1
   \   00000060   0xF887 0x6038      STRB     R6,[R7, #+56]
   \   00000064   0x1C6D             ADDS     R5,R5,#+1
   \   00000066   0xB2ED             UXTB     R5,R5
   \   00000068   0x2D16             CMP      R5,#+22
   \   0000006A   0xBFA8             IT       GE 
   \   0000006C   0x2500             MOVGE    R5,#+0
   \   0000006E   0x18EF             ADDS     R7,R5,R3
   \   00000070   0xF811 0x6B01      LDRB     R6,[R1], #+1
   \   00000074   0xF887 0x6038      STRB     R6,[R7, #+56]
   \   00000078   0x1C6D             ADDS     R5,R5,#+1
   \   0000007A   0xB2ED             UXTB     R5,R5
   \   0000007C   0x2D16             CMP      R5,#+22
   \   0000007E   0xBFA8             IT       GE 
   \   00000080   0x2500             MOVGE    R5,#+0
    657                              }
    658                          }
   \   00000082   0x1E64             SUBS     R4,R4,#+1
   \   00000084   0xD1D5             BNE.N    ??Uart__Write_4
    659                          UART0_Tx_Write_Index = pt;
   \                     ??Uart__Write_1: (+1)
   \   00000086   0x701D             STRB     R5,[R3, #+0]
    660                      }
    661                  #endif
    662          
    663                  #if (UART1_FEATURE == ENABLED)
    664                      if (uart == COM1)
   \                     ??Uart__Write_0: (+1)
   \   00000088   0x2801             CMP      R0,#+1
   \   0000008A   0xD13E             BNE.N    ??Uart__Write_5
    665                      {
    666                          pt = UART1_Tx_Write_Index;
   \   0000008C   0x795D             LDRB     R5,[R3, #+5]
    667                          for (count = 0; count < size; count++)
   \   0000008E   0x2A00             CMP      R2,#+0
   \   00000090   0xD03A             BEQ.N    ??Uart__Write_6
   \   00000092   0xF012 0x0003      ANDS     R0,R2,#0x3
   \   00000096   0xD00B             BEQ.N    ??Uart__Write_7
    668                          {
    669                              UART1_Tx_Buffer[pt] = *buf;
   \                     ??Uart__Write_8: (+1)
   \   00000098   0x18EE             ADDS     R6,R5,R3
   \   0000009A   0xF811 0x4B01      LDRB     R4,[R1], #+1
   \   0000009E   0xF886 0x4080      STRB     R4,[R6, #+128]
    670                              buf++;
    671                              pt++;
   \   000000A2   0x1C6D             ADDS     R5,R5,#+1
    672                              if (pt >= UART1_TX_BUF_SIZE)
   \   000000A4   0xB2ED             UXTB     R5,R5
   \   000000A6   0x2D16             CMP      R5,#+22
   \   000000A8   0xBFA8             IT       GE 
    673                              {
    674                                  pt = 0;
   \   000000AA   0x2500             MOVGE    R5,#+0
   \   000000AC   0x1E40             SUBS     R0,R0,#+1
   \   000000AE   0xD1F3             BNE.N    ??Uart__Write_8
   \                     ??Uart__Write_7: (+1)
   \   000000B0   0x0890             LSRS     R0,R2,#+2
   \   000000B2   0xD029             BEQ.N    ??Uart__Write_6
   \                     ??Uart__Write_9: (+1)
   \   000000B4   0xF811 0x2B01      LDRB     R2,[R1], #+1
   \   000000B8   0x18EC             ADDS     R4,R5,R3
   \   000000BA   0xF884 0x2080      STRB     R2,[R4, #+128]
   \   000000BE   0x1C6A             ADDS     R2,R5,#+1
   \   000000C0   0xB2D2             UXTB     R2,R2
   \   000000C2   0x2A16             CMP      R2,#+22
   \   000000C4   0xBFA8             IT       GE 
   \   000000C6   0x2200             MOVGE    R2,#+0
   \   000000C8   0x18D5             ADDS     R5,R2,R3
   \   000000CA   0xF811 0x4B01      LDRB     R4,[R1], #+1
   \   000000CE   0xF885 0x4080      STRB     R4,[R5, #+128]
   \   000000D2   0x1C52             ADDS     R2,R2,#+1
   \   000000D4   0xB2D2             UXTB     R2,R2
   \   000000D6   0x2A16             CMP      R2,#+22
   \   000000D8   0xBFA8             IT       GE 
   \   000000DA   0x2200             MOVGE    R2,#+0
   \   000000DC   0x18D5             ADDS     R5,R2,R3
   \   000000DE   0xF811 0x4B01      LDRB     R4,[R1], #+1
   \   000000E2   0xF885 0x4080      STRB     R4,[R5, #+128]
   \   000000E6   0x1C52             ADDS     R2,R2,#+1
   \   000000E8   0xB2D2             UXTB     R2,R2
   \   000000EA   0x2A16             CMP      R2,#+22
   \   000000EC   0xBFA8             IT       GE 
   \   000000EE   0x2200             MOVGE    R2,#+0
   \   000000F0   0xF811 0x4B01      LDRB     R4,[R1], #+1
   \   000000F4   0x18D5             ADDS     R5,R2,R3
   \   000000F6   0xF885 0x4080      STRB     R4,[R5, #+128]
   \   000000FA   0x1C55             ADDS     R5,R2,#+1
   \   000000FC   0xB2ED             UXTB     R5,R5
   \   000000FE   0x2D16             CMP      R5,#+22
   \   00000100   0xBFA8             IT       GE 
   \   00000102   0x2500             MOVGE    R5,#+0
    675                              }
    676                          }
   \   00000104   0x1E40             SUBS     R0,R0,#+1
   \   00000106   0xD1D5             BNE.N    ??Uart__Write_9
    677                          UART1_Tx_Write_Index = pt;
   \                     ??Uart__Write_6: (+1)
   \   00000108   0x715D             STRB     R5,[R3, #+5]
    678                      }
    679                  #endif
    680          
    681                  #if (UART2_FEATURE == ENABLED)
    682                      if (uart == COM2)
    683                      {
    684                          pt = UART2_Tx_Write_Index;
    685                          for (count = 0; count < size; count++)
    686                          {
    687                              UART2_Tx_Buffer[pt] = *buf;
    688                              buf++;
    689                              pt++;
    690                              if (pt >= UART2_TX_BUF_SIZE)
    691                              {
    692                                  pt = 0;
    693                              }
    694                          }
    695                          UART2_Tx_Write_Index = pt;
    696                      }
    697                  #endif
    698          
    699              #else
    700                  BOOL_TYPE response;
    701                  response = FALSE;
    702              #endif
    703          
    704              return (response);
   \                     ??Uart__Write_5: (+1)
   \   0000010A   0xBCF0             POP      {R4-R7}
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0x4770             BX       LR               ;; return
    705          }
    706          
    707          //---------------------------------------------------------------------------------------------------------------------
    708          /**
    709           *    @brief    This method reads data from receive FIFO and\n
    710           *              copies to the address of the buffer mentioned by the Application as per the size and\n
    711           *              also returns the response for the read operation.
    712           *    @details  Before reading the Receiver FIFO check for the data availability in the\n
    713           *              Receiver FIFO using Uart__GetStatus() API.
    714           *    @param    uart : Defines the Specific Uart COM port.
    715           *    @param    buf : Indicates the buffers address
    716           *    @param    size : Defines the number of bytes to be sent.
    717           *    @return   TRUE (1): If data reading from receive FIFO is successful. The amount of bytes
    718           *                        requested was available to read
    719           *              FALSE (0): If data reading from receive FIFO is unsuccessful. There was not
    720           *                         enough data to be read, fewer bytes than the size requested
    721           *
    722           *    @image    html    Uart__Read.jpg
    723           */

   \                                 In section .text, align 4, keep-with-next
    724          BOOL_TYPE Uart__Read(UART_ENUM_DEF uart, uint8 * buf,uint8 size)
    725          {
   \                     Uart__Read: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    726              #if ((UART0_FEATURE == ENABLED)||(UART1_FEATURE == ENABLED)||(UART2_FEATURE == ENABLED))
    727                  BOOL_TYPE response;
    728                  uint8 count;
    729                  uint8 pt;
    730          
    731                  response = TRUE;
   \   00000004   0x2301             MOVS     R3,#+1
    732          
    733                  #if (UART0_FEATURE == ENABLED)
    734                      if (uart == COM0)
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable15_2
   \   0000000A   0xB9F8             CBNZ.N   R0,??Uart__Read_0
   \   0000000C   0x78E7             LDRB     R7,[R4, #+3]
    735                      {
    736                          pt = UART0_Rx_Read_Index;
    737          
    738                          for (count = 0; count < size; count++)
   \   0000000E   0xF894 0xC002      LDRB     R12,[R4, #+2]
   \   00000012   0x463D             MOV      R5,R7
   \   00000014   0x2600             MOVS     R6,#+0
   \   00000016   0xE011             B.N      ??Uart__Read_1
    739                          {
    740                              if (pt != UART0_Rx_Write_Index)
    741                              {
    742                                  *buf = UART0_Rx_Buffer[pt].data;
   \                     ??Uart__Read_2: (+1)
   \   00000018   0xEB04 0x0E45      ADD      LR,R4,R5, LSL #+1
    743                                  *((uint16 *)(&UART0_LastData)) = *((uint16 *)(&UART0_Rx_Buffer[pt]));
    744          
    745                                  buf++;
    746                                  pt++;
   \   0000001C   0x1C6D             ADDS     R5,R5,#+1
   \   0000001E   0xF8BE 0x800C      LDRH     R8,[LR, #+12]
   \   00000022   0xEA4F 0x1858      LSR      R8,R8,#+5
   \   00000026   0xF801 0x8B01      STRB     R8,[R1], #+1
   \   0000002A   0xB2ED             UXTB     R5,R5
   \   0000002C   0xF8BE 0xE00C      LDRH     LR,[LR, #+12]
   \   00000030   0xF8A4 0xE050      STRH     LR,[R4, #+80]
    747          
    748                                  if (pt >= UART0_RX_BUF_SIZE)
   \   00000034   0x2D16             CMP      R5,#+22
   \   00000036   0xBFA8             IT       GE 
    749                                  {
    750                                      pt = 0;
   \   00000038   0x2500             MOVGE    R5,#+0
    751                                  }
    752                              }
   \   0000003A   0x1C76             ADDS     R6,R6,#+1
   \                     ??Uart__Read_1: (+1)
   \   0000003C   0xB2F6             UXTB     R6,R6
   \   0000003E   0x4296             CMP      R6,R2
   \   00000040   0xD203             BCS.N    ??Uart__Read_3
   \   00000042   0x4565             CMP      R5,R12
   \   00000044   0xD1E8             BNE.N    ??Uart__Read_2
    753                              else
    754                              {
    755                                  response = FALSE;
   \   00000046   0x2300             MOVS     R3,#+0
    756                                  pt = UART0_Rx_Read_Index;
   \   00000048   0x463D             MOV      R5,R7
    757                                  break;
    758                              }
    759                          }
    760          
    761                          UART0_Rx_Read_Index = pt;
   \                     ??Uart__Read_3: (+1)
   \   0000004A   0x70E5             STRB     R5,[R4, #+3]
    762                      }
    763                      #endif
    764          
    765                  #if (UART1_FEATURE == ENABLED)
    766                      if (uart == COM1)
   \                     ??Uart__Read_0: (+1)
   \   0000004C   0x7A27             LDRB     R7,[R4, #+8]
   \   0000004E   0x2801             CMP      R0,#+1
   \   00000050   0xD11D             BNE.N    ??Uart__Read_4
    767                      {
    768                          pt = UART1_Rx_Read_Index;
    769          
    770                          for (count = 0; count < size; count++)
   \   00000052   0x79E0             LDRB     R0,[R4, #+7]
   \   00000054   0x463D             MOV      R5,R7
   \   00000056   0x2600             MOVS     R6,#+0
   \   00000058   0xE013             B.N      ??Uart__Read_5
   \   0000005A   0xBF00             Nop      
    771                          {
    772                              if (pt != UART1_Rx_Write_Index)
    773                              {
    774                                  *buf = UART1_Rx_Buffer[pt].data;
   \                     ??Uart__Read_6: (+1)
   \   0000005C   0xEB04 0x0745      ADD      R7,R4,R5, LSL #+1
    775                                  *((uint16 *)(&UART1_LastData)) = *((uint16 *)(&UART1_Rx_Buffer[pt]));
    776                                  buf++;
    777                                  pt++;
   \   00000060   0x1C6D             ADDS     R5,R5,#+1
   \   00000062   0xF8B7 0xC054      LDRH     R12,[R7, #+84]
   \   00000066   0xEA4F 0x1C5C      LSR      R12,R12,#+5
   \   0000006A   0xF801 0xCB01      STRB     R12,[R1], #+1
   \   0000006E   0xB2ED             UXTB     R5,R5
   \   00000070   0xF8B7 0x7054      LDRH     R7,[R7, #+84]
   \   00000074   0xF8A4 0x7098      STRH     R7,[R4, #+152]
    778          
    779                                  if (pt >= UART1_RX_BUF_SIZE)
   \   00000078   0x2D16             CMP      R5,#+22
   \   0000007A   0xBFA8             IT       GE 
    780                                  {
    781                                      pt = 0;
   \   0000007C   0x2500             MOVGE    R5,#+0
    782                                  }
    783                              }
    784                              else
    785                              {
    786                                  response = FALSE;
    787                                  pt = UART1_Rx_Read_Index;
    788                                  break;
    789                              }
    790          
    791                              UART1_Rx_Read_Index = pt;
   \   0000007E   0x462F             MOV      R7,R5
   \   00000080   0x1C76             ADDS     R6,R6,#+1
   \                     ??Uart__Read_5: (+1)
   \   00000082   0xB2F6             UXTB     R6,R6
   \   00000084   0x4296             CMP      R6,R2
   \   00000086   0xD202             BCS.N    ??Uart__Read_4
   \   00000088   0x4285             CMP      R5,R0
   \   0000008A   0xD1E7             BNE.N    ??Uart__Read_6
   \   0000008C   0x2300             MOVS     R3,#+0
   \                     ??Uart__Read_4: (+1)
   \   0000008E   0x7227             STRB     R7,[R4, #+8]
    792                          }
    793                      }
    794                  #endif
    795          
    796                  #if (UART2_FEATURE == ENABLED)
    797                      if (uart == COM2)
    798                      {
    799                          pt = UART2_Rx_Read_Index;
    800          
    801                          for (count = 0; count < size; count++)
    802                          {
    803                              if (pt != UART2_Rx_Write_Index)
    804                              {
    805                                  *buf = UART2_Rx_Buffer[pt].data;
    806                                  *((uint16 *)(&UART2_LastData)) = *((uint16 *)(&UART2_Rx_Buffer[pt]));
    807          
    808                                  buf++;
    809                                  pt++;
    810          
    811                                  if (pt >= UART2_RX_BUF_SIZE)
    812                                  {
    813                                      pt = 0;
    814                                  }
    815                              }
    816                              else
    817                              {
    818                                  response = FALSE;
    819                                  pt = UART2_Rx_Read_Index;
    820                                  break;
    821                              }
    822                          }
    823          
    824                          UART2_Rx_Read_Index = pt;
    825                      }
    826                      #endif
    827              #else
    828                  BOOL_TYPE response;
    829                  response = FALSE;
    830              #endif
    831          
    832              return (response);
   \   00000090   0x4618             MOV      R0,R3
   \   00000092   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    833          }
    834          
    835          //---------------------------------------------------------------------------------------------------------------------
    836          /**
    837           *    @brief    This method writes one byte of data into the Uart transmitter FIFO.
    838           *    @details  The data in the Transmitter FIFO is sent to other Uart node through the specified Uart COM port\n
    839           *              whenever the Transmitter is free.\n
    840           *              Before writing into the Transmitter FIFO check for the FIFO availability using Uart__GetStatus() API\n
    841           *              to avoid the over writing on the existing data.
    842           *    @param    uart : Defines the Specific Uart COM port.
    843           *    @param    data : data to be written into the transmission FIFO.
    844           *    @return   TRUE (1): If data writing into transmission FIFO is successful.
    845           *              FALSE (0): If data writing into transmission FIFO is unsuccessful.
    846           *
    847           *    @image    html    Uart__WriteByte.jpg
    848           */

   \                                 In section .text, align 2, keep-with-next
    849          BOOL_TYPE Uart__WriteByte(UART_ENUM_DEF uart,uint8 data)
    850          {
   \                     Uart__WriteByte: (+1)
   \   00000000   0xB402             PUSH     {R1}
    851          	BOOL_TYPE response;
    852              response = FALSE;
    853          
    854              #if ((UART0_FEATURE == ENABLED)||(UART1_FEATURE == ENABLED)||(UART2_FEATURE == ENABLED))
    855                  response = Uart__Write(uart,&data,1);
   \   00000002   0xA900             ADD      R1,SP,#+0
   \   00000004   0xB980             CBNZ.N   R0,??Uart__WriteByte_0
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable15_2
   \   0000000A   0x7813             LDRB     R3,[R2, #+0]
   \   0000000C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000010   0xEB03 0x0C02      ADD      R12,R3,R2
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
   \   00000016   0xF88C 0x1038      STRB     R1,[R12, #+56]
   \   0000001A   0xB2DB             UXTB     R3,R3
   \   0000001C   0xF10D 0x0101      ADD      R1,SP,#+1
   \   00000020   0x2B16             CMP      R3,#+22
   \   00000022   0xBFA8             IT       GE 
   \   00000024   0x2300             MOVGE    R3,#+0
   \   00000026   0x7013             STRB     R3,[R2, #+0]
   \                     ??Uart__WriteByte_0: (+1)
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD10C             BNE.N    ??Uart__WriteByte_1
   \   0000002C   0x.... 0x....      LDR.W    R2,??DataTable15_2
   \   00000030   0x7950             LDRB     R0,[R2, #+5]
   \   00000032   0x7809             LDRB     R1,[R1, #+0]
   \   00000034   0x1883             ADDS     R3,R0,R2
   \   00000036   0xF883 0x1080      STRB     R1,[R3, #+128]
   \   0000003A   0x1C43             ADDS     R3,R0,#+1
   \   0000003C   0xB2DB             UXTB     R3,R3
   \   0000003E   0x2B16             CMP      R3,#+22
   \   00000040   0xBFA8             IT       GE 
   \   00000042   0x2300             MOVGE    R3,#+0
   \   00000044   0x7153             STRB     R3,[R2, #+5]
    856              #endif
    857          
    858              return (response);
   \                     ??Uart__WriteByte_1: (+1)
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xB001             ADD      SP,SP,#+4
   \   0000004A   0x4770             BX       LR               ;; return
    859          }
    860          
    861          //---------------------------------------------------------------------------------------------------------------------
    862          /**
    863           *    @brief    This method reads one byte of data from Uart receiver FIFO.
    864           *    @details  Before reading the Receiver FIFO check for the data availability in the Receiver FIFO
    865           *              using Uart__GetStatus() API.
    866           *    @param    uart : Defines the Specific Uart COM port.
    867           *    @return   uint8: data read from UART receive FIFO
    868           *
    869           *    @image    html    Uart__ReadByte.jpg
    870           */

   \                                 In section .text, align 2, keep-with-next
    871          uint8 Uart__ReadByte(UART_ENUM_DEF uart)
    872          {
   \                     Uart__ReadByte: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    873              #if ((UART0_FEATURE == ENABLED)||(UART1_FEATURE == ENABLED)||(UART2_FEATURE == ENABLED))
    874                  uint8 response;
    875          
    876                  response = FALSE;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0xF88D 0x1000      STRB     R1,[SP, #+0]
    877          
    878                  Uart__Read(uart,&response,1);
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable15_2
   \   0000000E   0xB9A8             CBNZ.N   R0,??Uart__ReadByte_0
   \   00000010   0x78D3             LDRB     R3,[R2, #+3]
   \   00000012   0xF892 0xC002      LDRB     R12,[R2, #+2]
   \   00000016   0x4563             CMP      R3,R12
   \   00000018   0xD00F             BEQ.N    ??Uart__ReadByte_1
   \   0000001A   0xEB02 0x0143      ADD      R1,R2,R3, LSL #+1
   \   0000001E   0x1C5B             ADDS     R3,R3,#+1
   \   00000020   0x8989             LDRH     R1,[R1, #+12]
   \   00000022   0xF8A2 0x1050      STRH     R1,[R2, #+80]
   \   00000026   0xEA4F 0x1C51      LSR      R12,R1,#+5
   \   0000002A   0xB2DB             UXTB     R3,R3
   \   0000002C   0xF88D 0xC000      STRB     R12,[SP, #+0]
   \   00000030   0xF10D 0x0101      ADD      R1,SP,#+1
   \   00000034   0x2B16             CMP      R3,#+22
   \   00000036   0xBFA8             IT       GE 
   \   00000038   0x2300             MOVGE    R3,#+0
   \                     ??Uart__ReadByte_1: (+1)
   \   0000003A   0x70D3             STRB     R3,[R2, #+3]
   \                     ??Uart__ReadByte_0: (+1)
   \   0000003C   0x7A13             LDRB     R3,[R2, #+8]
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD113             BNE.N    ??Uart__ReadByte_2
   \   00000042   0x79D0             LDRB     R0,[R2, #+7]
   \   00000044   0x4283             CMP      R3,R0
   \   00000046   0xD010             BEQ.N    ??Uart__ReadByte_2
   \   00000048   0xEB02 0x0043      ADD      R0,R2,R3, LSL #+1
   \   0000004C   0x1C5B             ADDS     R3,R3,#+1
   \   0000004E   0xF8B0 0xC054      LDRH     R12,[R0, #+84]
   \   00000052   0xEA4F 0x1C5C      LSR      R12,R12,#+5
   \   00000056   0xF881 0xC000      STRB     R12,[R1, #+0]
   \   0000005A   0xB2DB             UXTB     R3,R3
   \   0000005C   0xF8B0 0x0054      LDRH     R0,[R0, #+84]
   \   00000060   0xF8A2 0x0098      STRH     R0,[R2, #+152]
   \   00000064   0x2B16             CMP      R3,#+22
   \   00000066   0xBFA8             IT       GE 
   \   00000068   0x2300             MOVGE    R3,#+0
    879              #else
    880                  uint8 response;
    881                  response = FALSE;
    882              #endif
    883          
    884              return (response);
   \                     ??Uart__ReadByte_2: (+1)
   \   0000006A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000006E   0x7213             STRB     R3,[R2, #+8]
   \   00000070   0xB001             ADD      SP,SP,#+4
   \   00000072   0x4770             BX       LR               ;; return
    885          }
    886          
    887          //---------------------------------------------------------------------------------------------------------------------
    888          /**
    889           *    @brief    This method starts sending break signal through a specific uart.
    890           *    @details  Break signal should be sent If the Uart Node requires more time to participate in the Uart communication.
    891           *              The break signal should be released once the node is ready to participate in the communication.
    892           *              The Break signal should not be hold for the long time.
    893           *    @param    uart : Defines the Specific Uart COM port.
    894           *    @image    html    Uart__SendBreak.jpg
    895           */

   \                                 In section .text, align 2, keep-with-next
    896          void Uart__SendBreak(UART_ENUM_DEF uart)
    897          {
   \                     Uart__SendBreak: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    898          	#if ((UART0_FEATURE == ENABLED)||(UART1_FEATURE == ENABLED)||(UART2_FEATURE == ENABLED))
    899          		Uart__Disable(uart, UART_OPTION_TX_EN);
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x2C03             CMP      R4,#+3
   \   00000006   0xDA0C             BGE.N    ??Uart__SendBreak_0
   \   00000008   0x.... 0x....      ADR.W    R1,UART_PTR
   \   0000000C   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000010   0xB139             CBZ.N    R1,??Uart__SendBreak_0
   \   00000012   0x78CA             LDRB     R2,[R1, #+3]
   \   00000014   0xF002 0x0277      AND      R2,R2,#0x77
   \   00000018   0x70CA             STRB     R2,[R1, #+3]
   \   0000001A   0x798A             LDRB     R2,[R1, #+6]
   \   0000001C   0xF002 0x02F0      AND      R2,R2,#0xF0
   \   00000020   0x718A             STRB     R2,[R1, #+6]
    900          
    901          		#if (UART0_FEATURE == ENABLED)
    902          			if (uart == COM0)
   \                     ??Uart__SendBreak_0: (+1)
   \   00000022   0xB960             CBNZ.N   R0,??Uart__SendBreak_1
    903          			{
    904          				UART0_Break = TRUE;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x....             LDR.N    R1,??DataTable15_2
   \   00000028   0x7108             STRB     R0,[R1, #+4]
    905          				//Configure the Uart Tx pin as OUTPUT PUSHPULL and drive LOW on the pin
    906          				#if(UART0_REMAP == 0)
    907          					Gpio__PinConfig(PORTB,1,OUTPUT_PUSHPULL);
    908          					Gpio__PinWrite(PORTB,1,0);
    909          				#else
    910          					Gpio__PinConfig(PORTA,3,OUTPUT_PUSHPULL);
   \   0000002A   0x2206             MOVS     R2,#+6
   \   0000002C   0x2103             MOVS     R1,#+3
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x.... 0x....      BL       Gpio__PinConfig
    911          					Gpio__PinWrite(PORTA,3,0);
                 					                       ^
Warning[Pe188]: enumerated type mixed with another type
   \   00000034   0x2200             MOVS     R2,#+0
   \   00000036   0x2103             MOVS     R1,#+3
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      BL       Gpio__PinWrite
    912          				#endif
    913          			}
    914          		#endif
    915          
    916          		#if (UART1_FEATURE == ENABLED)
    917          			if (uart == COM1)
   \                     ??Uart__SendBreak_1: (+1)
   \   0000003E   0x2C01             CMP      R4,#+1
   \   00000040   0xD10E             BNE.N    ??Uart__SendBreak_2
    918          			{
    919          				UART1_Break = TRUE;
   \   00000042   0x....             LDR.N    R1,??DataTable15_2
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x7248             STRB     R0,[R1, #+9]
    920          				//Configure the Uart Tx pin as OUTPUT PUSHPULL and drive LOW on the pin
    921          				#if(UART1_REMAP == 0)
    922          					Gpio__PinConfig(PORTC,7,OUTPUT_PUSHPULL);
   \   00000048   0x2206             MOVS     R2,#+6
   \   0000004A   0x2107             MOVS     R1,#+7
   \   0000004C   0x2002             MOVS     R0,#+2
   \   0000004E   0x.... 0x....      BL       Gpio__PinConfig
    923          					Gpio__PinWrite(PORTC,7,0);
                 					                       ^
Warning[Pe188]: enumerated type mixed with another type
   \   00000052   0xE8BD 0x4010      POP      {R4,LR}
   \   00000056   0x2200             MOVS     R2,#+0
   \   00000058   0x2107             MOVS     R1,#+7
   \   0000005A   0x2002             MOVS     R0,#+2
   \   0000005C   0x.... 0x....      B.W      Gpio__PinWrite
    924          				#else
    925          //					Gpio__PinConfig(PORTF,3,OUTPUT_PUSHPULL);
    926          //					Gpio__PinWrite(PORTF,3,0);
    927          				#endif
    928          			}
    929          		#endif
    930          
    931          		#if (UART2_FEATURE == ENABLED)
    932          			if (uart == COM2)
    933          			{
    934          				UART2_Break = TRUE;
    935          				//Configure the Uart Tx pin as OUTPUT PUSHPULL and drive LOW on the pin
    936          				#if(UART2_REMAP == 0)
    937          					Gpio__PinConfig(PORTD, 7, OUTPUT_PUSHPULL);
    938          					Gpio__PinWrite(PORTD, 7, 0);
    939          				#else
    940          					Gpio__PinConfig(PORTI,1,OUTPUT_PUSHPULL);
    941          					Gpio__PinWrite(PORTI,1,0);
    942          				#endif
    943          			}
    944          		#endif
    945          
    946          	#endif
    947          }
   \                     ??Uart__SendBreak_2: (+1)
   \   00000060   0xBD10             POP      {R4,PC}          ;; return
    948          
    949          //---------------------------------------------------------------------------------------------------------------------
    950          /**
    951           *    @brief    This procedure stops sending a break signal through a specific Uart.
    952           *    @details  The break signal should be release once the node is ready to participate in the communication.
    953           *    @param    uart : Defines the Specific Uart COM port.
    954           *    @image    html    Uart__SendBreak_Verify.jpg
    955           */

   \                                 In section .text, align 2, keep-with-next
    956          void Uart__StopBreak(UART_ENUM_DEF uart)
    957          {
    958              #if ((UART0_FEATURE == ENABLED)||(UART1_FEATURE == ENABLED)||(UART2_FEATURE == ENABLED))
    959          
    960          		#if (UART0_FEATURE == ENABLED)
    961          			if (uart == COM0)
   \                     Uart__StopBreak: (+1)
   \   00000000   0xB910             CBNZ.N   R0,??Uart__StopBreak_0
    962          			{
    963          				UART0_Break = FALSE;                     //Configure the Uart Tx port-pin
   \   00000002   0x....             LDR.N    R2,??DataTable15_2
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7111             STRB     R1,[R2, #+4]
    964          			}
    965          		#endif
    966          
    967          		#if (UART1_FEATURE == ENABLED)
    968          			if (uart == COM1)
   \                     ??Uart__StopBreak_0: (+1)
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD103             BNE.N    ??Uart__StopBreak_1
    969          			{
    970          				UART1_Break = FALSE;                     //Configure the Uart Tx port-pin
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x....             LDR.N    R2,??DataTable15_2
   \   00000010   0x7251             STRB     R1,[R2, #+9]
   \   00000012   0xE001             B.N      ??Uart__StopBreak_2
    971          			}
    972          		#endif
    973          
    974          		#if (UART2_FEATURE == ENABLED)
    975          			if (uart == COM2)
    976          			{
    977          				UART2_Break = FALSE;                     //Configure the Uart Tx port-pin
    978          			}
    979          		#endif
    980          
    981          		Uart__Enable(uart,UART_OPTION_TX_EN);            //Uart Tx Pin configuration
   \                     ??Uart__StopBreak_1: (+1)
   \   00000014   0x2803             CMP      R0,#+3
   \   00000016   0xDA0C             BGE.N    ??Uart__StopBreak_3
   \                     ??Uart__StopBreak_2: (+1)
   \   00000018   0x.... 0x....      ADR.W    R1,UART_PTR
   \   0000001C   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000020   0xB139             CBZ.N    R1,??Uart__StopBreak_3
   \   00000022   0x78C8             LDRB     R0,[R1, #+3]
   \   00000024   0xF040 0x0088      ORR      R0,R0,#0x88
   \   00000028   0x70C8             STRB     R0,[R1, #+3]
   \   0000002A   0x7988             LDRB     R0,[R1, #+6]
   \   0000002C   0xF040 0x000F      ORR      R0,R0,#0xF
   \   00000030   0x7188             STRB     R0,[R1, #+6]
    982          
    983              #endif
    984          }
   \                     ??Uart__StopBreak_3: (+1)
   \   00000032   0x4770             BX       LR               ;; return
    985          
    986          //---------------------------------------------------------------------------------------------------------------------
    987          /**
    988           *    @brief    This method checks the status of the specific Uart.
    989           *    @details  This method checks the break in, break out signal, transmit and receive FIFO availability for\n
    990           *              writing and reading, transmit FIFO empty and error status of received frame.
    991           *    @param    uart : Defines the Specific Uart COM port.
    992           *    @param    index : Index enumerator defines which status should be checked for specific Uart.
    993           *
    994           *    @return   UART_STATUS_BREAK_IN:\n
    995           *              Response:   TRUE (1) = If it detects the Break signal sent by other node.\n
    996           *                          FALSE (0) = No break signal is detected.\n
    997           *              UART_STATUS_BREAK_OUT:\n
    998           *              Response:   TRUE (1) = A break signal is sent;\n
    999           *                          FALSE (0) = No break signal is sent;\n
   1000           *              UART_STATUS_TX_EMPTY:\n
   1001           *              Response:   TRUE (1) = The transmission FIFO is empty;\n
   1002           *                          FALSE (0) = The transmission FIFO is not empty;\n
   1003           *              UART_STATUS_TX_AVAILABLE:\n
   1004           *              Response:   The response is the free space in the Transmission FIFO\n
   1005           *                          If the response is 1 means the only one byte is free in the Tx FIFO,\n
   1006           *                          if response is 10 means only 10 bytes are free in the Tx FIFO.\n
   1007           *              UART_STATUS_RX_AVAILABLE:\n
   1008           *              Response:   The amount of bytes available in the Reception FIFO;\n
   1009           *                          If the response is 1 means the only one byte is available to read the Rx FIFO,\n
   1010           *                          If response is 10 means only 10 bytes are available to read the the Rx FIFO.\n
   1011           *              UART_STATUS_ERROR:\n
   1012           *              Response:   TRUE (1) = Error detected (Over run, Framing, Parity or noise_err error)\n
   1013           *                          FALSE (0) = No error detected.
   1014           *
   1015           */

   \                                 In section .text, align 4, keep-with-next
   1016          uint8 Uart__GetStatus(UART_ENUM_DEF uart,UART_STATUS_DEF index)
   1017          {
   \                     Uart__GetStatus: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1018              #if ((UART0_FEATURE == ENABLED)||(UART1_FEATURE == ENABLED)||(UART2_FEATURE == ENABLED))
   1019                  uint8 response;
   1020          
   1021                  response = FALSE;
   \   00000002   0x2200             MOVS     R2,#+0
   1022          
   1023                  // UART_Rx_Write_Index and UART_Tx_Read_Index variables values gets updated from the Uart Interrupt which runs at the highest priority in asynchronous way
   1024                  // The value shall be copied to the local variable and perform the operation instead of relying on the variable which is changing its value based on the interrupt
   1025                  uint8 local_uart_rx_write_index = 0;
   1026                  uint8 local_uart_tx_read_index = 0;
   1027          
   1028                  #if (UART0_FEATURE == ENABLED)
   1029                      if (uart == COM0)
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD131             BNE.N    ??Uart__GetStatus_2
   1030                      {
   1031                          switch(index)
   \   00000008   0x2905             CMP      R1,#+5
   \   0000000A   0xD82F             BHI.N    ??Uart__GetStatus_2
   \   0000000C   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??Uart__GetStatus_0:
   \   00000010   0x03 0x0A          DC8      0x3,0xA,0xD,0x13
   \              0x0D 0x13    
   \   00000014   0x1D 0x27          DC8      0x1D,0x27
   1032                          {
   1033                              case UART_STATUS_BREAK_IN:
   1034                                  if(UART0_LastData.incomming_break == TRUE)
   \                     ??Uart__GetStatus_3: (+1)
   \   00000016   0x....             LDR.N    R3,??DataTable15_2
   \   00000018   0xF8B3 0x3050      LDRH     R3,[R3, #+80]
   \   0000001C   0xF3C3 0x1300      UBFX     R3,R3,#+4,#+1
   \   00000020   0x2B00             CMP      R3,#+0
   \   00000022   0xE021             B.N      ??Uart__GetStatus_4
   1035                                  {
   1036                                      response = TRUE;
   1037                                  }
   1038                                  break;
   1039          
   1040                              case UART_STATUS_BREAK_OUT:
   1041                                  response = UART0_Break;
   \                     ??Uart__GetStatus_5: (+1)
   \   00000024   0x....             LDR.N    R2,??DataTable15_2
   \   00000026   0x7912             LDRB     R2,[R2, #+4]
   1042                                  break;
   \   00000028   0xE020             B.N      ??Uart__GetStatus_2
   1043          
   1044                              case UART_STATUS_TX_EMPTY:
   1045                                  if (UART0_Tx_Read_Index == UART0_Tx_Write_Index)
   \                     ??Uart__GetStatus_6: (+1)
   \   0000002A   0x....             LDR.N    R3,??DataTable15_2
   \   0000002C   0x785C             LDRB     R4,[R3, #+1]
   \   0000002E   0x781B             LDRB     R3,[R3, #+0]
   \   00000030   0x429C             CMP      R4,R3
   \   00000032   0xD11B             BNE.N    ??Uart__GetStatus_2
   1046                                  {
   1047                                      response = TRUE;
   \   00000034   0xE019             B.N      ??Uart__GetStatus_7
   1048                                  }
   1049                                  break;
   1050          
   1051                              case UART_STATUS_TX_AVAILABLE:
   1052                                  local_uart_tx_read_index = UART0_Tx_Read_Index;
   \                     ??Uart__GetStatus_8: (+1)
   \   00000036   0x....             LDR.N    R3,??DataTable15_2
   \   00000038   0x785A             LDRB     R2,[R3, #+1]
   1053                                  if (local_uart_tx_read_index <= UART0_Tx_Write_Index)
   \   0000003A   0x781B             LDRB     R3,[R3, #+0]
   \   0000003C   0x1AD4             SUBS     R4,R2,R3
   \   0000003E   0x4293             CMP      R3,R2
   \   00000040   0xBFB4             ITE      LT 
   1054                                  {
   1055                                      response = (UART0_TX_BUF_SIZE - UART0_Tx_Write_Index) + local_uart_tx_read_index - 1;
   1056                                  }
   1057                                  else
   1058                                  {
   1059                                      response = local_uart_tx_read_index - UART0_Tx_Write_Index - 1;
   \   00000042   0x1E62             SUBLT    R2,R4,#+1
   1060                                  }
   \   00000044   0xF104 0x0215      ADDGE    R2,R4,#+21
   \   00000048   0xE010             B.N      ??Uart__GetStatus_2
   1061                                  break;
   1062          
   1063                              case UART_STATUS_RX_AVAILABLE:
   1064                                  local_uart_rx_write_index = UART0_Rx_Write_Index;
   \                     ??Uart__GetStatus_9: (+1)
   \   0000004A   0x....             LDR.N    R3,??DataTable15_2
   \   0000004C   0x789A             LDRB     R2,[R3, #+2]
   1065                                  if (UART0_Rx_Read_Index <= local_uart_rx_write_index)
   \   0000004E   0x78DB             LDRB     R3,[R3, #+3]
   \   00000050   0x429A             CMP      R2,R3
   \   00000052   0xBFBA             ITTE     LT 
   1066                                  {
   1067                                      response = local_uart_rx_write_index - UART0_Rx_Read_Index;
   1068                                  }
   1069                                  else
   1070                                  {
   1071                                      response = (UART0_RX_BUF_SIZE -  UART0_Rx_Read_Index) + local_uart_rx_write_index;
   \   00000054   0xF1C3 0x0316      RSBLT    R3,R3,#+22
   \   00000058   0x18D2             ADDLT    R2,R2,R3
   1072                                  }
   \   0000005A   0x1AD2             SUBGE    R2,R2,R3
   \   0000005C   0xE006             B.N      ??Uart__GetStatus_2
   1073                                  break;
   1074          
   1075                              case UART_STATUS_ERROR:
   1076                                  if((UART0_LastData.overrun_err)||       // Overrun error
   1077                                     (UART0_LastData.noise_err)||             // Noisy error
   1078                                     (UART0_LastData.frame_err)||         // Frame error
   1079                                     (UART0_LastData.parity_err))         // Parity error
   \                     ??Uart__GetStatus_10: (+1)
   \   0000005E   0x....             LDR.N    R3,??DataTable15_2
   \   00000060   0xF893 0x3050      LDRB     R3,[R3, #+80]
   \   00000064   0x240F             MOVS     R4,#+15
   \   00000066   0x4223             TST      R3,R4
   \                     ??Uart__GetStatus_4: (+1)
   \   00000068   0xD000             BEQ.N    ??Uart__GetStatus_2
   1080                                  {
   1081                                      response = TRUE;
   \                     ??Uart__GetStatus_7: (+1)
   \   0000006A   0x2201             MOVS     R2,#+1
   1082                                  }
   1083                                  break;
   1084          
   1085                              default:
   1086                                  break;
   1087                          }
   1088                      }
   1089                  #endif
   1090          
   1091                  #if (UART1_FEATURE == ENABLED)
   1092                      if (uart == COM1)
   \                     ??Uart__GetStatus_2: (+1)
   \   0000006C   0x2801             CMP      R0,#+1
   \   0000006E   0xD137             BNE.N    ??Uart__GetStatus_11
   1093                      {
   1094                          switch(index)
   \   00000070   0x2905             CMP      R1,#+5
   \   00000072   0xD835             BHI.N    ??Uart__GetStatus_11
   \   00000074   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??Uart__GetStatus_1:
   \   00000078   0x03 0x0A          DC8      0x3,0xA,0xF,0x15
   \              0x0F 0x15    
   \   0000007C   0x21 0x2D          DC8      0x21,0x2D
   1095                          {
   1096                              case UART_STATUS_BREAK_IN:
   1097                                  if(UART1_LastData.incomming_break == TRUE)
   \                     ??Uart__GetStatus_12: (+1)
   \   0000007E   0x....             LDR.N    R0,??DataTable15_2
   \   00000080   0xF8B0 0x0098      LDRH     R0,[R0, #+152]
   \   00000084   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xE027             B.N      ??Uart__GetStatus_13
   1098                                  {
   1099                                      response = TRUE;
   1100                                  }
   1101                                  break;
   1102          
   1103                              case UART_STATUS_BREAK_OUT:
   1104                                  response = UART1_Break;
   \                     ??Uart__GetStatus_14: (+1)
   \   0000008C   0x....             LDR.N    R0,??DataTable15_2
   \   0000008E   0x7A42             LDRB     R2,[R0, #+9]
   1105                                  break;
   1106          
   1107                              case UART_STATUS_TX_EMPTY:
   1108                                  if (UART1_Tx_Read_Index == UART1_Tx_Write_Index)
   1109                                  {
   1110                                      response = TRUE;
   1111                                  }
   1112                                  break;
   1113          
   1114                              case UART_STATUS_TX_AVAILABLE:
   1115                                  local_uart_tx_read_index = UART1_Tx_Read_Index;
   1116                                  if (local_uart_tx_read_index <= UART1_Tx_Write_Index)
   1117                                  {
   1118                                      response = (UART1_TX_BUF_SIZE - UART1_Tx_Write_Index) + local_uart_tx_read_index - 1;
   1119                                  }
   1120                                  else
   1121                                  {
   1122                                      response = local_uart_tx_read_index - UART1_Tx_Write_Index - 1;
   1123                                  }
   1124                                  break;
   1125          
   1126                              case UART_STATUS_RX_AVAILABLE:
   1127                                  local_uart_rx_write_index = UART1_Rx_Write_Index;
   1128                                  if (UART1_Rx_Read_Index <= local_uart_rx_write_index)
   1129                                  {
   1130                                      response = local_uart_rx_write_index - UART1_Rx_Read_Index;
   1131                                  }
   1132                                  else
   1133                                  {
   1134                                      response = (UART1_RX_BUF_SIZE -  UART1_Rx_Read_Index) + local_uart_rx_write_index;
   1135                                  }
   1136                                  break;
   1137          
   1138                              case UART_STATUS_ERROR:
   1139                                  if((UART1_LastData.overrun_err)||       // Overrun error
   1140                                     (UART1_LastData.noise_err)||             // Noisy error
   1141                                     (UART1_LastData.frame_err)||         // Frame error
   1142                                     (UART1_LastData.parity_err))         // Parity error
   1143                                  {
   1144                                      response = TRUE;
   1145                                  }
   1146                                  break;
   1147          
   1148                              default:
   1149                                  break;
   1150                          }
   1151                      }
   1152                  #endif
   1153          
   1154                  #if (UART2_FEATURE == ENABLED)
   1155                      if (uart == COM2)
   1156                      {
   1157                          switch(index)
   1158                          {
   1159                              case UART_STATUS_BREAK_IN:
   1160                                  if(UART2_LastData.incomming_break == TRUE)
   1161                                  {
   1162                                      response = TRUE;
   1163                                  }
   1164                                  break;
   1165          
   1166                              case UART_STATUS_BREAK_OUT:
   1167                                  response = UART2_Break;
   1168                                  break;
   1169          
   1170                              case UART_STATUS_TX_EMPTY:
   1171                                  if (UART2_Tx_Read_Index == UART2_Tx_Write_Index)
   1172                                  {
   1173                                      response = TRUE;
   1174                                  }
   1175                                  break;
   1176          
   1177                              case UART_STATUS_TX_AVAILABLE:
   1178                                  local_uart_tx_read_index = UART2_Tx_Read_Index;
   1179                                  if (local_uart_tx_read_index <= UART2_Tx_Write_Index)
   1180                                  {
   1181                                      response = (UART1_TX_BUF_SIZE - UART2_Tx_Write_Index) + local_uart_tx_read_index - 3;
   1182                                  }
   1183                                  else
   1184                                  {
   1185                                      response = local_uart_tx_read_index - UART2_Tx_Write_Index - 3;
   1186                                  }
   1187                                  break;
   1188          
   1189                              case UART_STATUS_RX_AVAILABLE:
   1190                                  local_uart_rx_write_index = UART2_Rx_Write_Index;
   1191                                  if (UART2_Rx_Read_Index <= local_uart_rx_write_index)
   1192                                  {
   1193                                      response = local_uart_rx_write_index - UART2_Rx_Read_Index;
   1194                                  }
   1195                                  else
   1196                                  {
   1197                                      response = (UART2_RX_BUF_SIZE -  UART2_Rx_Read_Index) + local_uart_rx_write_index;
   1198                                  }
   1199                                  break;
   1200          
   1201                              case UART_STATUS_ERROR:
   1202                                  if((UART2_LastData.overrun_err)||       // Overrun error
   1203                                     (UART2_LastData.noise_err)||             // Noisy error
   1204                                     (UART2_LastData.frame_err)||         // Frame error
   1205                                     (UART2_LastData.parity_err))         // Parity error
   1206                                  {
   1207                                      response = TRUE;
   1208                                  }
   1209                                  break;
   1210          
   1211                              default:
   1212                                  break;
   1213                          }
   1214                      }
   1215                  #endif
   1216          
   1217              #else
   1218                  uint8 response;
   1219                  response = FALSE;
   1220              #endif
   1221          
   1222              return (response);
   \   00000090   0xBC10             POP      {R4}
   \   00000092   0xB2D0             UXTB     R0,R2
   \   00000094   0x4770             BX       LR
   \                     ??Uart__GetStatus_15: (+1)
   \   00000096   0x....             LDR.N    R3,??DataTable15_2
   \   00000098   0x7998             LDRB     R0,[R3, #+6]
   \   0000009A   0x7959             LDRB     R1,[R3, #+5]
   \   0000009C   0x4288             CMP      R0,R1
   \   0000009E   0xD11F             BNE.N    ??Uart__GetStatus_11
   \   000000A0   0xE01D             B.N      ??Uart__GetStatus_16
   \                     ??Uart__GetStatus_17: (+1)
   \   000000A2   0x....             LDR.N    R3,??DataTable15_2
   \   000000A4   0x799A             LDRB     R2,[R3, #+6]
   \   000000A6   0x7958             LDRB     R0,[R3, #+5]
   \   000000A8   0x1A11             SUBS     R1,R2,R0
   \   000000AA   0x4290             CMP      R0,R2
   \   000000AC   0xBFB4             ITE      LT 
   \   000000AE   0x1E4A             SUBLT    R2,R1,#+1
   \   000000B0   0xF101 0x0215      ADDGE    R2,R1,#+21
   \   000000B4   0xBC10             POP      {R4}
   \   000000B6   0xB2D0             UXTB     R0,R2
   \   000000B8   0x4770             BX       LR
   \                     ??Uart__GetStatus_18: (+1)
   \   000000BA   0x....             LDR.N    R3,??DataTable15_2
   \   000000BC   0x79DA             LDRB     R2,[R3, #+7]
   \   000000BE   0x7A18             LDRB     R0,[R3, #+8]
   \   000000C0   0x4282             CMP      R2,R0
   \   000000C2   0xBFBA             ITTE     LT 
   \   000000C4   0xF1C0 0x0016      RSBLT    R0,R0,#+22
   \   000000C8   0x1812             ADDLT    R2,R2,R0
   \   000000CA   0x1A12             SUBGE    R2,R2,R0
   \   000000CC   0xBC10             POP      {R4}
   \   000000CE   0xB2D0             UXTB     R0,R2
   \   000000D0   0x4770             BX       LR
   \                     ??Uart__GetStatus_19: (+1)
   \   000000D2   0x....             LDR.N    R0,??DataTable15_2
   \   000000D4   0xF890 0x0098      LDRB     R0,[R0, #+152]
   \   000000D8   0x210F             MOVS     R1,#+15
   \   000000DA   0x4208             TST      R0,R1
   \                     ??Uart__GetStatus_13: (+1)
   \   000000DC   0xD000             BEQ.N    ??Uart__GetStatus_11
   \                     ??Uart__GetStatus_16: (+1)
   \   000000DE   0x2201             MOVS     R2,#+1
   \                     ??Uart__GetStatus_11: (+1)
   \   000000E0   0xBC10             POP      {R4}
   \   000000E2   0xB2D0             UXTB     R0,R2
   \   000000E4   0x4770             BX       LR               ;; return
   1223          }
   1224          
   1225          //---------------------------------------------------------------------------------------------------------------------
   1226          /**
   1227           *    @brief    This method handles Uart Data Transmission and also the break signal
   1228           *    @details  The break signal has highest priority then the Data Transmission.\n
   1229           *              If the application requests for the Break signal transmission then handler inserts break signal after
   1230           *              completion of the ongoing transmission\n
   1231           *              and stops the further Data transmission until the Break signal is resumed.\n
   1232           *              This method checks if there is data in transmit FIFO. If data is present then this method\n
   1233           *              transmits the data on Uart.
   1234           *
   1235           *    @image    html    Uart__Handler.jpg
   1236           */

   \                                 In section .text, align 2, keep-with-next
   1237          void Uart__Handler(void)
   1238          {
   1239              #if (UART0_FEATURE == ENABLED)
   1240                  #if (UART_POLLING_MODE == ENABLED)
   1241                      //COM0 Handling
   1242                      Uart__Interrupt0();
   1243                  #else
   1244                      if (UART0_Tx_Write_Index != UART0_Tx_Read_Index)   // Is there something to be sent?
   \                     Uart__Handler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15_2
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x7842             LDRB     R2,[R0, #+1]
   \   00000006   0x4291             CMP      R1,R2
   \   00000008   0xD00E             BEQ.N    ??Uart__Handler_0
   1245                      {
   1246                      	if(((UART0.UART_C2 & UART_C2_TE_MASK)== FALSE)||
   1247                     			((UART0.UART_C2 & UART_C2_TIE_MASK)== FALSE))
   \   0000000A   0x....             LDR.N    R1,??DataTable15_3  ;; 0x4006a003
   \   0000000C   0x780A             LDRB     R2,[R1, #+0]
   \   0000000E   0x0712             LSLS     R2,R2,#+28
   \   00000010   0xD502             BPL.N    ??Uart__Handler_1
   \   00000012   0x780A             LDRB     R2,[R1, #+0]
   \   00000014   0x0612             LSLS     R2,R2,#+24
   \   00000016   0xD407             BMI.N    ??Uart__Handler_0
   1248                          {
   1249                              Uart__Enable(COM0, UART_OPTION_TX_EN);
   \                     ??Uart__Handler_1: (+1)
   \   00000018   0x780A             LDRB     R2,[R1, #+0]
   \   0000001A   0xF042 0x0288      ORR      R2,R2,#0x88
   \   0000001E   0x700A             STRB     R2,[R1, #+0]
   \   00000020   0x78CA             LDRB     R2,[R1, #+3]
   \   00000022   0xF042 0x020F      ORR      R2,R2,#0xF
   \   00000026   0x70CA             STRB     R2,[R1, #+3]
   1250                          }
   1251                      }
   1252                  #endif
   1253              #endif
   1254          
   1255              #if (UART1_FEATURE == ENABLED)
   1256                  #if (UART_POLLING_MODE == ENABLED)
   1257                      //COM1 Handling
   1258                      Uart__Interrupt1();
   1259                  #else
   1260                      if (UART1_Tx_Write_Index != UART1_Tx_Read_Index)   // Is there something to be sent?
   \                     ??Uart__Handler_0: (+1)
   \   00000028   0x7941             LDRB     R1,[R0, #+5]
   \   0000002A   0x7980             LDRB     R0,[R0, #+6]
   \   0000002C   0x4281             CMP      R1,R0
   \   0000002E   0xD00E             BEQ.N    ??Uart__Handler_2
   1261                      {
   1262                      	if(((UART1.UART_C2 & UART_C2_TE_MASK)== FALSE)||
   1263                     			((UART1.UART_C2 & UART_C2_TIE_MASK)== FALSE))
   \   00000030   0x....             LDR.N    R0,??DataTable15_4  ;; 0x4006b003
   \   00000032   0x7801             LDRB     R1,[R0, #+0]
   \   00000034   0x0709             LSLS     R1,R1,#+28
   \   00000036   0xD502             BPL.N    ??Uart__Handler_3
   \   00000038   0x7801             LDRB     R1,[R0, #+0]
   \   0000003A   0x0609             LSLS     R1,R1,#+24
   \   0000003C   0xD407             BMI.N    ??Uart__Handler_2
   1264                          {
   1265                              Uart__Enable(COM1, UART_OPTION_TX_EN);
   \                     ??Uart__Handler_3: (+1)
   \   0000003E   0x7801             LDRB     R1,[R0, #+0]
   \   00000040   0xF041 0x0188      ORR      R1,R1,#0x88
   \   00000044   0x7001             STRB     R1,[R0, #+0]
   \   00000046   0x78C1             LDRB     R1,[R0, #+3]
   \   00000048   0xF041 0x010F      ORR      R1,R1,#0xF
   \   0000004C   0x70C1             STRB     R1,[R0, #+3]
   1266                          }
   1267                      }
   1268                  #endif
   1269              #endif
   1270          
   1271              #if (UART2_FEATURE == ENABLED)
   1272                  #if (UART_POLLING_MODE == ENABLED)
   1273                      //COM2 Handling
   1274                      Uart__Interrupt2();
   1275                  #else
   1276                      if (UART2_Tx_Write_Index != UART2_Tx_Read_Index)   // Is there something to be sent?
   1277                      {
   1278                      	if(((UART2.UART_C2 & UART_C2_TE_MASK)== FALSE)||
   1279                     			((UART2.UART_C2 & UART_C2_TIE_MASK)== FALSE))
   1280                          {
   1281                              Uart__Enable(COM2, UART_OPTION_TX_EN);
   1282                          }
   1283                      }
   1284                  #endif
   1285              #endif
   1286          
   1287          }
   \                     ??Uart__Handler_2: (+1)
   \   0000004E   0x4770             BX       LR               ;; return
   1288          
   1289          ////---------------------------------------------------------------------------------------------------------------------
   1290          ///**
   1291          // *    @brief    This method handles the Uart0 receive interrupt.
   1292          // *    @details  This needs to be configured in the InterruptVector_prm.h file as below-\n
   1293          // *              #define USART0_RX_INTERRUPTION      Uart__Uart1RxIsr\n
   1294          // *              This ISR is called whenever the data is received in the Uart_DR register.
   1295          // */

   \                                 In section .text, align 2, keep-with-next
   1296          void Uart__Interrupt0(void)
   1297          {
   \                     Uart__Interrupt0: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   1298          #if (UART0_FEATURE == ENABLED)
   1299          	volatile UART_BASIC_DEF status;
   1300          	uint8 index;
   1301          	volatile uint8 data;
   1302          
   1303          	status.UART_S1 = UART0.UART_S1;					//Read UART Status Register 1
   \   00000002   0x....             LDR.N    R0,??DataTable15_3  ;; 0x4006a003
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x7841             LDRB     R1,[R0, #+1]
   \   00000008   0xF88D 0x1008      STRB     R1,[SP, #+8]
   1304          
   1305          	//Receive part----------------------------------------------
   1306          	if (((status.UART_S1)& ((UART_S1_RDRF_MASK) | (UART_S1_OR_MASK) | (UART_S1_NF_MASK)   |
   1307          			                (UART_S1_FE_MASK)   | (UART_S1_PF_MASK))) != FALSE)
   \   0000000C   0x232F             MOVS     R3,#+47
   \   0000000E   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   00000012   0x....             LDR.N    R1,??DataTable15_2
   \   00000014   0x421A             TST      R2,R3
   \   00000016   0xD028             BEQ.N    ??Uart__Interrupt0_0
   1308          	{
   1309          		data = (UART0.UART_DATA & (uint8) 0xFF);                          //Read data from UART_DATA register
   \   00000018   0x7902             LDRB     R2,[R0, #+4]
   \   0000001A   0xF88D 0x2000      STRB     R2,[SP, #+0]
   1310          
   1311          		if ((status.UART_S1 & UART_S1_RDRF_MASK) != FALSE)
   \   0000001E   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   00000022   0x0692             LSLS     R2,R2,#+26
   \   00000024   0xD521             BPL.N    ??Uart__Interrupt0_0
   1312          		{
   1313          			index = UART0_Rx_Write_Index;
   \   00000026   0x788A             LDRB     R2,[R1, #+2]
   1314          
   1315          			*((uint16 *) (&UART0_Rx_Buffer[index])) = 0;
   \   00000028   0xEB01 0x0342      ADD      R3,R1,R2, LSL #+1
   \   0000002C   0x2400             MOVS     R4,#+0
   \   0000002E   0x819C             STRH     R4,[R3, #+12]
   1316          
   1317          			*((uint16 *) (&UART0_Rx_Buffer[index])) = (uint8) status.UART_S1;
   \   00000030   0xF89D 0x4008      LDRB     R4,[SP, #+8]
   \   00000034   0x819C             STRH     R4,[R3, #+12]
   1318          
   1319          			UART0_Rx_Buffer[index].data = data;                               //Copy UART Receive data in UART1_Rx_Buffer.
   \   00000036   0xF89D 0x4000      LDRB     R4,[SP, #+0]
   \   0000003A   0x899D             LDRH     R5,[R3, #+12]
   \   0000003C   0xF364 0x154C      BFI      R5,R4,#+5,#+8
   \   00000040   0x819D             STRH     R5,[R3, #+12]
   1320          
   1321          			if (((UART0.UART_S1 & UART_S1_FE_MASK) != FALSE) && (UART0_Rx_Buffer[index].data == 0))
   \   00000042   0x899C             LDRH     R4,[R3, #+12]
   \   00000044   0x7845             LDRB     R5,[R0, #+1]
   \   00000046   0x07AD             LSLS     R5,R5,#+30
   \   00000048   0xD505             BPL.N    ??Uart__Interrupt0_1
   \   0000004A   0xF3C4 0x1547      UBFX     R5,R4,#+5,#+8
   \   0000004E   0xB915             CBNZ.N   R5,??Uart__Interrupt0_1
   1322          			{
   1323          				UART0_Rx_Buffer[index].incomming_break = TRUE;                //Framing error detected
   \   00000050   0xF044 0x0410      ORR      R4,R4,#0x10
   \   00000054   0xE002             B.N      ??Uart__Interrupt0_2
   1324          			}
   1325          			else
   1326          			{
   1327          				UART0_Rx_Buffer[index].incomming_break = FALSE;               //No Framing error detected
   \                     ??Uart__Interrupt0_1: (+1)
   \   00000056   0xF64F 0x75EF      MOVW     R5,#+65519
   \   0000005A   0x402C             ANDS     R4,R5,R4
   1328          			}
   1329          
   1330          			index++;
   \                     ??Uart__Interrupt0_2: (+1)
   \   0000005C   0x1C52             ADDS     R2,R2,#+1
   \   0000005E   0xB2D2             UXTB     R2,R2
   \   00000060   0x819C             STRH     R4,[R3, #+12]
   1331          
   1332          			if (index >= UART0_RX_BUF_SIZE)
   \   00000062   0x2A16             CMP      R2,#+22
   \   00000064   0xBFA8             IT       GE 
   1333          			{
   1334          				index = 0;
   \   00000066   0x2200             MOVGE    R2,#+0
   1335          			}
   1336          
   1337          			UART0_Rx_Write_Index = index;
   \   00000068   0x708A             STRB     R2,[R1, #+2]
   1338          		}
   1339          	}
   1340          
   1341          	//Transmitter Part -----------------------------------------------------------------------------------------------
   1342          	#if (UART_POLLING_MODE == DISABLED)
   1343          		if ((UART0.UART_C2 & UART_C2_TIE_MASK) != FALSE)
   \                     ??Uart__Interrupt0_0: (+1)
   \   0000006A   0x7802             LDRB     R2,[R0, #+0]
   \   0000006C   0x784B             LDRB     R3,[R1, #+1]
   \   0000006E   0x0612             LSLS     R2,R2,#+24
   \   00000070   0xD517             BPL.N    ??Uart__Interrupt0_3
   1344          	#endif
   1345          	{
   1346          		if ((status.UART_S1 & UART_S1_TDRE_MASK) != FALSE)
   \   00000072   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   00000076   0x0612             LSLS     R2,R2,#+24
   \   00000078   0xD513             BPL.N    ??Uart__Interrupt0_3
   1347          		{
   1348          			if (UART0_Tx_Write_Index == UART0_Tx_Read_Index)
   \   0000007A   0x780A             LDRB     R2,[R1, #+0]
   \   0000007C   0x429A             CMP      R2,R3
   \   0000007E   0xD107             BNE.N    ??Uart__Interrupt0_4
   1349          			{
   1350          				#if (UART_POLLING_MODE == DISABLED)                           //UART Running in Interrupt Mode
   1351          					UART0.UART_C2 &= (uint8) ~(UART_C2_TIE_MASK);
   \   00000080   0x7802             LDRB     R2,[R0, #+0]
   \   00000082   0xF002 0x027F      AND      R2,R2,#0x7F
   \   00000086   0x7002             STRB     R2,[R0, #+0]
   \   00000088   0x704B             STRB     R3,[R1, #+1]
   1352          				#endif
   1353          			}
   1354          			else
   1355          			{
   1356          				#if (UART_POLLING_MODE == ENABLED)                            //UART Running in Polling Mode
   1357          					if((UART0.UART_C2 & UART_C2_TE_MASK) == FALSE)
   1358          					{
   1359          						Uart__Enable(COM0, UART_OPTION_TX_EN);
   1360          					}
   1361          				#endif
   1362          
   1363          				UART0.UART_DATA = (UART0_Tx_Buffer[UART0_Tx_Read_Index]	& (uint16) 0x01FF);
   1364          
   1365          				UART0_Tx_Read_Index++;
   1366          				if (UART0_Tx_Read_Index >= UART0_TX_BUF_SIZE)                 //Check Tx Buffer Size
   1367          				{
   1368          					UART0_Tx_Read_Index = 0;
   1369          				}
   1370          			}
   1371          		}
   1372          
   1373          	}
   1374          #else
   1375          	UART0.UART_C2 &= (uint8)~((uint8)(UART_C2_TIE_MASK | UART_C2_RIE_MASK | UART_C2_TE_MASK | UART_C2_RE_MASK));
   1376          #endif
   1377          
   1378          }
   \   0000008A   0xB005             ADD      SP,SP,#+20
   \   0000008C   0xBC30             POP      {R4,R5}
   \   0000008E   0x4770             BX       LR
   \                     ??Uart__Interrupt0_4: (+1)
   \   00000090   0x185A             ADDS     R2,R3,R1
   \   00000092   0x1C5B             ADDS     R3,R3,#+1
   \   00000094   0xF892 0x2038      LDRB     R2,[R2, #+56]
   \   00000098   0x7102             STRB     R2,[R0, #+4]
   \   0000009A   0xB2DB             UXTB     R3,R3
   \   0000009C   0x2B16             CMP      R3,#+22
   \   0000009E   0xBFA8             IT       GE 
   \   000000A0   0x2300             MOVGE    R3,#+0
   \                     ??Uart__Interrupt0_3: (+1)
   \   000000A2   0x704B             STRB     R3,[R1, #+1]
   \   000000A4   0xB005             ADD      SP,SP,#+20
   \   000000A6   0xBC30             POP      {R4,R5}
   \   000000A8   0x4770             BX       LR               ;; return
   1379          
   1380          //---------------------------------------------------------------------------------------------------------------------
   1381          /**
   1382           *    @brief    This method handles the Uart1 receive interrupt.
   1383           *    @details  This needs to be configured in the InterruptVector_prm.h file as below-\n
   1384           *              #define USART1_RX_INTERRUPTION      Uart__Uart1RxIsr\n
   1385           *              This ISR is called whenever the data is received in the UART_DATA register.
   1386           */

   \                                 In section .text, align 2, keep-with-next
   1387          void Uart__Interrupt1(void)
   1388          {
   \                     Uart__Interrupt1: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   1389          #if (UART1_FEATURE == ENABLED)
   1390          	volatile UART_BASIC_DEF status;
   1391          	uint8 index;
   1392          	volatile uint8 data;
   1393          
   1394          	status.UART_S1 = UART1.UART_S1;					//Read UART Status Register 1
   \   00000002   0x....             LDR.N    R0,??DataTable15_4  ;; 0x4006b003
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x7841             LDRB     R1,[R0, #+1]
   \   00000008   0xF88D 0x1008      STRB     R1,[SP, #+8]
   1395          
   1396          	//Receive part----------------------------------------------
   1397          	if (((status.UART_S1)& ((UART_S1_RDRF_MASK) | (UART_S1_OR_MASK) | (UART_S1_NF_MASK) |
   1398          			                (UART_S1_FE_MASK) | (UART_S1_PF_MASK))) != FALSE)
   \   0000000C   0x232F             MOVS     R3,#+47
   \   0000000E   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   00000012   0x....             LDR.N    R1,??DataTable15_2
   \   00000014   0x421A             TST      R2,R3
   \   00000016   0xD02E             BEQ.N    ??Uart__Interrupt1_0
   1399          	{
   1400          		data = (UART1.UART_DATA & (uint8) 0xFF);                        //Read data from UART_DATA register
   \   00000018   0x7902             LDRB     R2,[R0, #+4]
   \   0000001A   0xF88D 0x2000      STRB     R2,[SP, #+0]
   1401          
   1402          		if ((status.UART_S1 & UART_S1_RDRF_MASK) != FALSE)
   \   0000001E   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   00000022   0x0692             LSLS     R2,R2,#+26
   \   00000024   0xD527             BPL.N    ??Uart__Interrupt1_0
   1403          		{
   1404          
   1405          			index = UART1_Rx_Write_Index;
   \   00000026   0x79CA             LDRB     R2,[R1, #+7]
   1406          
   1407          			*((uint16 *) (&UART1_Rx_Buffer[index])) = 0;
   \   00000028   0xEB01 0x0342      ADD      R3,R1,R2, LSL #+1
   \   0000002C   0x2400             MOVS     R4,#+0
   \   0000002E   0xF8A3 0x4054      STRH     R4,[R3, #+84]
   1408          			*((uint16 *) (&UART1_Rx_Buffer[index])) = (uint8) status.UART_S1;
   \   00000032   0xF89D 0x4008      LDRB     R4,[SP, #+8]
   \   00000036   0xF8A3 0x4054      STRH     R4,[R3, #+84]
   1409          
   1410          			UART1_Rx_Buffer[index].data = data;                             //Copy UART Receive data in UART1_Rx_Buffer.
   \   0000003A   0xF89D 0x4000      LDRB     R4,[SP, #+0]
   \   0000003E   0xF8B3 0x5054      LDRH     R5,[R3, #+84]
   \   00000042   0xF364 0x154C      BFI      R5,R4,#+5,#+8
   \   00000046   0xF8A3 0x5054      STRH     R5,[R3, #+84]
   1411          
   1412          			if (((UART1.UART_S1 & UART_S1_FE_MASK) != FALSE) && (UART1_Rx_Buffer[index].data == 0))
   \   0000004A   0xF8B3 0x4054      LDRH     R4,[R3, #+84]
   \   0000004E   0x7845             LDRB     R5,[R0, #+1]
   \   00000050   0x07AD             LSLS     R5,R5,#+30
   \   00000052   0xD505             BPL.N    ??Uart__Interrupt1_1
   \   00000054   0xF3C4 0x1547      UBFX     R5,R4,#+5,#+8
   \   00000058   0xB915             CBNZ.N   R5,??Uart__Interrupt1_1
   1413          			{
   1414          				UART1_Rx_Buffer[index].incomming_break = TRUE;               //Framing error
   \   0000005A   0xF044 0x0410      ORR      R4,R4,#0x10
   \   0000005E   0xE002             B.N      ??Uart__Interrupt1_2
   1415          			}
   1416          			else
   1417          			{
   1418          				UART1_Rx_Buffer[index].incomming_break = FALSE;              //No Framing error detected
   \                     ??Uart__Interrupt1_1: (+1)
   \   00000060   0xF64F 0x75EF      MOVW     R5,#+65519
   \   00000064   0x402C             ANDS     R4,R5,R4
   1419          			}
   1420          
   1421          			index++;
   \                     ??Uart__Interrupt1_2: (+1)
   \   00000066   0x1C52             ADDS     R2,R2,#+1
   \   00000068   0xB2D2             UXTB     R2,R2
   \   0000006A   0xF8A3 0x4054      STRH     R4,[R3, #+84]
   1422          
   1423          			if (index >= UART1_RX_BUF_SIZE)                                  //Check Rx Buffer Size
   \   0000006E   0x2A16             CMP      R2,#+22
   \   00000070   0xBFA8             IT       GE 
   1424          			{
   1425          				index = 0;
   \   00000072   0x2200             MOVGE    R2,#+0
   1426          			}
   1427          
   1428          			UART1_Rx_Write_Index = index;
   \   00000074   0x71CA             STRB     R2,[R1, #+7]
   1429          		}
   1430          	}
   1431          
   1432          	//Transmitter---------------------------------------------------------------------------------------------------
   1433          	#if (UART_POLLING_MODE == DISABLED)
   1434          		if ((UART1.UART_C2 & UART_C2_TIE_MASK) != FALSE)
   \                     ??Uart__Interrupt1_0: (+1)
   \   00000076   0x7802             LDRB     R2,[R0, #+0]
   \   00000078   0x798B             LDRB     R3,[R1, #+6]
   \   0000007A   0x0612             LSLS     R2,R2,#+24
   \   0000007C   0xD517             BPL.N    ??Uart__Interrupt1_3
   1435          	#endif
   1436          	{
   1437          		if ((status.UART_S1 & UART_S1_TDRE_MASK) != FALSE)
   \   0000007E   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   00000082   0x0612             LSLS     R2,R2,#+24
   \   00000084   0xD513             BPL.N    ??Uart__Interrupt1_3
   1438          		{
   1439          			if (UART1_Tx_Write_Index == UART1_Tx_Read_Index)
   \   00000086   0x794A             LDRB     R2,[R1, #+5]
   \   00000088   0x429A             CMP      R2,R3
   \   0000008A   0xD107             BNE.N    ??Uart__Interrupt1_4
   1440          			{
   1441          				#if (UART_POLLING_MODE == DISABLED)                           //UART Running in Interrupt Mode
   1442          					UART1.UART_C2 &= (uint8) ~(UART_C2_TIE_MASK);
   \   0000008C   0x7802             LDRB     R2,[R0, #+0]
   \   0000008E   0xF002 0x027F      AND      R2,R2,#0x7F
   \   00000092   0x7002             STRB     R2,[R0, #+0]
   \   00000094   0x718B             STRB     R3,[R1, #+6]
   1443          				#endif
   1444          			}
   1445          			else
   1446          			{
   1447          				#if (UART_POLLING_MODE == ENABLED)                            //UART Running in Polling Mode
   1448          					if((UART1.UART_C2 & UART_C2_TE_MASK) == FALSE)
   1449          					{
   1450          						Uart__Enable(COM1, UART_OPTION_TX_EN);
   1451          					}
   1452          				#endif
   1453          
   1454          				UART1.UART_DATA = (UART1_Tx_Buffer[UART1_Tx_Read_Index]	& (uint16) 0x01FF);   //Transmit UART data
   1455          
   1456          				UART1_Tx_Read_Index++;
   1457          				if (UART1_Tx_Read_Index >= UART1_TX_BUF_SIZE)                 //Check Tx Buffer Size
   1458          				{
   1459          					UART1_Tx_Read_Index = 0;
   1460          				}
   1461          			}
   1462          		}
   1463          
   1464          	}
   1465          #else
   1466          	UART1.UART_C2 &= (uint8)~((uint8)(UART_C2_TIE_MASK | UART_C2_RIE_MASK | UART_C2_TE_MASK | UART_C2_RE_MASK));
   1467          #endif
   1468          }
   \   00000096   0xB005             ADD      SP,SP,#+20
   \   00000098   0xBC30             POP      {R4,R5}
   \   0000009A   0x4770             BX       LR
   \                     ??Uart__Interrupt1_4: (+1)
   \   0000009C   0x185A             ADDS     R2,R3,R1
   \   0000009E   0x1C5B             ADDS     R3,R3,#+1
   \   000000A0   0xF892 0x2080      LDRB     R2,[R2, #+128]
   \   000000A4   0x7102             STRB     R2,[R0, #+4]
   \   000000A6   0xB2DB             UXTB     R3,R3
   \   000000A8   0x2B16             CMP      R3,#+22
   \   000000AA   0xBFA8             IT       GE 
   \   000000AC   0x2300             MOVGE    R3,#+0
   \                     ??Uart__Interrupt1_3: (+1)
   \   000000AE   0x718B             STRB     R3,[R1, #+6]
   \   000000B0   0xB005             ADD      SP,SP,#+20
   \   000000B2   0xBC30             POP      {R4,R5}
   \   000000B4   0x4770             BX       LR               ;; return
   1469          
   1470          //---------------------------------------------------------------------------------------------------------------------
   1471          /**
   1472           *    @brief    This method handles the Uart3 receive interrupt.
   1473           *    @details  This needs to be configured in the InterruptVector_prm.h file as below-\n
   1474           *              #define USART3_RX_INTERRUPTION      Uart__Uart3RxIsr\n
   1475           *              This ISR is called whenever the data is received in the Uart_DR register.
   1476           */

   \                                 In section .text, align 2, keep-with-next
   1477          void Uart__Interrupt2(void)
   1478          {
   1479          #if (UART2_FEATURE == ENABLED)
   1480          	volatile UART_BASIC_DEF status;
   1481          	uint8 index;
   1482          	volatile uint8 data;
   1483          
   1484          	status.UART_S1 = UART2.UART_S1;				//Read UART Status Register 1
   1485          
   1486          	//Receive part----------------------------------------------
   1487          	if (((status.UART_S1)& ((UART_S1_RDRF_MASK) | (UART_S1_OR_MASK) | (UART_S1_NF_MASK) |
   1488          							(UART_S1_FE_MASK) |	(UART_S1_PF_MASK))) != FALSE)
   1489          	{
   1490          		data = (UART2.UART_DATA & (uint8) 0xFF);                          //Read data from UART_DATA register
   1491          
   1492          		if ((status.UART_S1 & UART_S1_RDRF_MASK) != FALSE)
   1493          		{
   1494          			index = UART2_Rx_Write_Index;
   1495          
   1496          			*((uint16 *) (&UART2_Rx_Buffer[index])) = 0;
   1497          
   1498          			*((uint16 *) (&UART2_Rx_Buffer[index])) = (uint8) status.UART_S1;
   1499          
   1500          			UART2_Rx_Buffer[index].data = data;                               //Copy UART Receive data in UART1_Rx_Buffer.
   1501          
   1502          			if (((UART2.UART_S1 & UART_S1_FE_MASK) != FALSE) && (UART2_Rx_Buffer[index].data == 0))
   1503          			{
   1504          				UART2_Rx_Buffer[index].incomming_break = TRUE;                //Framing error detected
   1505          			}
   1506          			else
   1507          			{
   1508          				UART2_Rx_Buffer[index].incomming_break = FALSE;               //No Framing error detected
   1509          			}
   1510          			index++;
   1511          
   1512          			if (index >= UART2_RX_BUF_SIZE)
   1513          			{
   1514          				index = 0;
   1515          			}
   1516          
   1517          			UART2_Rx_Write_Index = index;
   1518          		}
   1519          	}
   1520          
   1521          	//Transmitter---------------------------------------------------------------------------------------------------
   1522          	#if (UART_POLLING_MODE == DISABLED)
   1523          		if ((UART2.UART_C2 & UART_C2_TIE_MASK) != FALSE)
   1524          	#endif
   1525          	{
   1526          		if ((status.UART_S1 & UART_S1_TDRE_MASK) != FALSE)
   1527          		{
   1528          			if (UART2_Tx_Write_Index == UART2_Tx_Read_Index)
   1529          			{
   1530          				#if (UART_POLLING_MODE == DISABLED)                           //UART Running in Interrupt Mode
   1531          					UART2.UART_C2 &= (uint8) ~(UART_C2_TIE_MASK);
   1532          				#endif
   1533          			}
   1534          			else
   1535          			{
   1536          			#if (UART_POLLING_MODE == ENABLED)                                //UART Running in Polling Mode
   1537          				if((UART2.UART_C2 & UART_C2_TE_MASK) == FALSE)
   1538          				{
   1539          					Uart__Enable(COM1, UART_OPTION_TX_EN);
   1540          				}
   1541          			#endif
   1542          
   1543          				UART2.UART_DATA = (UART2_Tx_Buffer[UART2_Tx_Read_Index]	& (uint16) 0x01FF);
   1544          
   1545          				UART2_Tx_Read_Index++;
   1546          				if (UART2_Tx_Read_Index >= UART2_TX_BUF_SIZE)                 //Check Tx Buffer Size
   1547          				{
   1548          					UART2_Tx_Read_Index = 0;
   1549          				}
   1550          			}
   1551          		}
   1552          
   1553          	}
   1554          #else
   1555          	UART2.UART_C2 &= (uint8) ~((uint8) (UART_C2_TIE_MASK | UART_C2_RIE_MASK | UART_C2_TE_MASK | UART_C2_RE_MASK));
                 	                         ^
Remark[Pa091]: operator operates on value promoted to int (with possibly
          unexpected result)
   \                     Uart__Interrupt2: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15_5  ;; 0x4006c003
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0xF001 0x0153      AND      R1,R1,#0x53
   \   00000008   0x7001             STRB     R1,[R0, #+0]
   1556          #endif
   1557          
   1558          }
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x4004A040         DC32     0x4004a040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x........         DC32     UART0_Tx_Write_Index

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x4006A003         DC32     0x4006a003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x4006B003         DC32     0x4006b003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x4006C003         DC32     0x4006c003
   1559          
   1560          //=====================================================================================================================
   1561          //-------------------------------------- Private Functions ------------------------------------------------------------
   1562          //=====================================================================================================================

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Uart__Clear
       0   Uart__ClearTx
       0   Uart__Disable
       0   Uart__Enable
       4   Uart__GetStatus
       0   Uart__Handler
      32   Uart__Initialize
        32   -> Micro__GetClock
        32   -> Micro__NVICEnableIRQ
        32   -> Uart__Clear
      28   Uart__Interrupt0
      28   Uart__Interrupt1
       0   Uart__Interrupt2
      24   Uart__Read
       4   Uart__ReadByte
       8   Uart__SendBreak
         8   -> Gpio__PinConfig
         0   -> Gpio__PinWrite
         8   -> Gpio__PinWrite
       0   Uart__StopBreak
      16   Uart__Write
       4   Uart__WriteByte


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
      52  BDRATE
     156  UART0_Tx_Write_Index
          UART0_Tx_Read_Index
          UART0_Rx_Write_Index
          UART0_Rx_Read_Index
          UART0_Break
          UART1_Tx_Write_Index
          UART1_Tx_Read_Index
          UART1_Rx_Write_Index
          UART1_Rx_Read_Index
          UART1_Break
          UART0_Rx_Buffer
          UART0_Tx_Buffer
          UART0_LastData
          UART1_Rx_Buffer
          UART1_Tx_Buffer
          UART1_LastData
      12  UART_PTR
      58  Uart__Clear
      38  Uart__ClearTx
      58  Uart__Disable
      58  Uart__Enable
     230  Uart__GetStatus
      80  Uart__Handler
     262  Uart__Initialize
     170  Uart__Interrupt0
     182  Uart__Interrupt1
      12  Uart__Interrupt2
     150  Uart__Read
     116  Uart__ReadByte
      98  Uart__SendBreak
      52  Uart__StopBreak
     272  Uart__Write
      76  Uart__WriteByte

 
   156 bytes in section .bss
 2 000 bytes in section .text
 
 2 000 bytes of CODE memory
   156 bytes of DATA memory

Errors: none
Warnings: 2
